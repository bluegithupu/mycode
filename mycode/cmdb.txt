File path: /Users/mac/Desktop/woker_code/cmdb-api/cmd/apiserver/apiserver.go
```golang
package main

import (
	"flag"
	"log"
	"luban-cmdb-api/cmd/apiserver/app"
	"luban-cmdb-api/pkg/apiserver/config"

	//_ "net/http/pprof"
	"os"

	"github.com/zeromicro/go-zero/core/conf"
	"github.com/zeromicro/go-zero/core/logx"

	"k8s.io/klog/v2"
)

// 这里用的是dev配置，用于本地启动。k8s环境用env配置，写在dockerfile里面
var configFile = flag.String("f", "./conf/dev.yaml", "the config file")

func main() {
	klog.Infof("cmdb  main  start .............................")
	flag.Parse()
	var c config.Config
	conf.MustLoad(*configFile, &c, conf.UseEnv())
	klog.SetOutputBySeverity("ERROR", os.Stdout)
	// set log
	logx.MustSetup(logx.LogConf{
		Mode:     "console",
		Level:    "debug",
		Encoding: "plain",
	})
	logx.DisableStat()

	cmd := app.NewAPISererCmd(c)
	if err := cmd.Execute(); err != nil {
		log.Fatalln(err)
	}
}

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/cmd/apiserver/app/server.go
```golang
package app

import (
	"fmt"
	"luban-cmdb-api/pkg/apiserver/config"
	"luban-cmdb-api/pkg/svcctx"

	"github.com/emicklei/go-restful/v3"
	"github.com/spf13/cobra"
	cliflag "k8s.io/component-base/cli/flag"
	"k8s.io/component-base/term"
	"k8s.io/klog/v2"

	"luban-cmdb-api/cmd/apiserver/app/options"
	"luban-cmdb-api/pkg/apiserver"
	"luban-cmdb-api/pkg/signal"
	"luban-cmdb-api/pkg/version"
)

func NewAPISererCmd(conf config.Config) *cobra.Command {
	opt := options.NewServerRunOptions(conf)
	cmd := &cobra.Command{
		Use:          "luban-cmdb-api",
		Short:        "luban cmdb api server",
		SilenceUsage: true,
		RunE: func(cmd *cobra.Command, args []string) error {
			// To help debugging, immediately print version
			klog.Infof("version: %s", version.Version)

			// print flags
			fs := cmd.Flags()
			cliflag.PrintFlags(fs)

			// TODO validate options
			return Run(opt, signal.SetupSignalHandler())
		},
	}

	//没有用到，为了解决启动报错的问题
	cmd.PersistentFlags().StringP("conf", "f", "./conf/env.yaml", "conf file path")

	fs := cmd.Flags()
	namedFlagSets := &cliflag.NamedFlagSets{}
	opt.AddFlags(namedFlagSets)
	for _, f := range namedFlagSets.FlagSets {
		fs.AddFlagSet(f)
	}
	usageFmt := "Usage:\n  %s\n"
	cols, _, _ := term.TerminalSize(cmd.OutOrStdout())
	cmd.SetUsageFunc(func(cmd *cobra.Command) error {
		fmt.Fprintf(cmd.OutOrStderr(), usageFmt, cmd.UseLine())
		cliflag.PrintSections(cmd.OutOrStderr(), *namedFlagSets, cols)
		return nil
	})
	cmd.SetHelpFunc(func(cmd *cobra.Command, args []string) {
		fmt.Fprintf(cmd.OutOrStdout(), "%s\n\n"+usageFmt, cmd.Long, cmd.UseLine())
		cliflag.PrintSections(cmd.OutOrStdout(), *namedFlagSets, cols)
	})
	return cmd
}

func Run(opts *options.ServerRunOptions, stopCh <-chan struct{}) error {
	server := apiserver.APIServer{
		Config: &opts.Config,
	}
	//可以通过传参的方式传下去，但是需要修改的地方太多
	_ = svcctx.NewServiceContext(opts.Config)
	if err := server.PrepareRun(); err != nil {
		return err
	}

	return server.Run(stopCh)
}

func globalLogging(req *restful.Request, resp *restful.Response, chain *restful.FilterChain) {
	klog.Infof("[global-filter (logger)] %s,%s\n", req.Request.Method, req.Request.URL)
	chain.ProcessFilter(req, resp)
}

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/cmd/apiserver/app/options/options.go
```golang
package options

import (
	"os"
	"strconv"

	"github.com/zeromicro/go-zero/core/logx"

	"luban-cmdb-api/pkg/apiserver/config"

	cliflag "k8s.io/component-base/cli/flag"
)

// TODO 现在配置没有通过参数传下去，修改量比较大，先用一个全局变量来用
var GlobalConfig ServerRunOptions

type ServerRunOptions struct {
	config.Config
}

func NewServerRunOptions(conf config.Config) *ServerRunOptions {

	//TODO 后面把这些环境变量全部放到配置文件中
	customerDomain := os.Getenv("STORAGE_OPTIONS_CUSTOMER_DOMAIN")
	if customerDomain == "" {
		customerDomain = config.DefaultSTORAGE_OPTIONS_CUSTOMER_DOMAIN
	}
	eBSAddr := os.Getenv("STORAGE_OPTIONS_EBS_ADDR")
	if eBSAddr == "" {
		eBSAddr = config.DefaultSTORAGE_OPTIONS_EBS_ADDR
	}
	ks3ServiceAPI := os.Getenv("STORAGE_OPTIONS_KS3_SERVICE_API")
	if ks3ServiceAPI == "" {
		ks3ServiceAPI = config.DefaultK3sServiceAPI
	}
	redisTaskHours := os.Getenv("REDIS_TASK_TIME")
	rdtHours := 24
	if redisTaskHours != "" {
		r, err := strconv.Atoi(redisTaskHours)
		if err == nil {
			rdtHours = r
		}
		err = nil
	}
	var (
		authURL    = "http://keystone.galaxy.cloud:8357/v2.0/"
		username   string
		password   string
		tenantName string
		regionName string
	)
	if len(os.Getenv("KUBERNETES_SERVICE_HOST")) > 0 {
		authURL = "http://keystone.galaxy.cloud:35357/v2.0/"
	}
	if username = os.Getenv("OS_USERNAME"); username == "" {
		username = "admin"
	}
	if password = os.Getenv("OS_PASSWORD"); password == "" {
		password = "ksc"
	}
	if tenantName = os.Getenv("OS_TENANT_NAME"); tenantName == "" {
		tenantName = "admin"
	}
	if regionName = os.Getenv("OS_REGION_NAME"); regionName == "" {
		regionName = "SHPBSRegionOne"
	}

	conf.OpenstackAuth = config.OpenstackAuth{
		AuthURL:    authURL, //os.Getenv("OS_AUTH_URL"),
		Username:   username,
		Password:   password,
		TenantName: tenantName,
		RegionName: regionName,
	}
	conf.DisableOpenstackAPI = false
	conf.StorageOptions = config.StorageOptions{
		CustomerDomain: customerDomain,
		EBSAddr:        eBSAddr,
		//StorageStateAddr: os.Getenv("STORAGE_OPTIONS_STORAGE_STATE_ADDR"),//库存的这个不再使用
		//PrometheusAddr:   os.Getenv("STORAGE_OPTIONS_PROMETHEUS_ADDR"), //不再使用
		Ks3ServiceAPI: ks3ServiceAPI,
	}
	conf.RedisTaskHours = rdtHours

	opt := ServerRunOptions{
		Config: conf,
	}
	GlobalConfig = opt
	logx.Info("=============== 服务启动配置 start ===============")
	logx.Infof("%+v", opt)
	logx.Info("=============== 服务启动配置 end =================")

	return &opt

	//return &ServerRunOptions{
	//	config.Config{
	//		ListenAddr: "0.0.0.0",
	//		ListenPort: 80,
	//		OpenstackAuth: config.OpenstackAuth{
	//			AuthURL:    authURL, //os.Getenv("OS_AUTH_URL"),
	//			Username:   username,
	//			Password:   password,
	//			TenantName: tenantName,
	//			RegionName: regionName,
	//		},
	//		//OpenstackAuth: config.OpenstackAuth{
	//		//	AuthURL:    "http://keystone.galaxy.cloud:35357/v2.0/", //os.Getenv("OS_AUTH_URL"),
	//		//	Username:   os.Getenv("OS_USERNAME"),
	//		//	Password:   os.Getenv("OS_PASSWORD"),
	//		//	TenantName: os.Getenv("OS_TENANT_NAME"),
	//		//	RegionName: os.Getenv("OS_REGION_NAME"),
	//		//},
	//		DisableOpenstackAPI: false,
	//		StorageOptions: config.StorageOptions{
	//			CustomerDomain: customerDomain,
	//			Ks3DSN:         ks3DSN,
	//			EBSAddr:        eBSAddr,
	//			//StorageStateAddr: os.Getenv("STORAGE_OPTIONS_STORAGE_STATE_ADDR"),//库存的这个不再使用
	//			//PrometheusAddr:   os.Getenv("STORAGE_OPTIONS_PROMETHEUS_ADDR"), //不再使用
	//			Ks3ServiceAPI: ks3ServiceAPI,
	//		},
	//		RedisTaskHours: rdtHours,
	//		//NovaInnerApi: os.Getenv("OS_NOVAINNERAPI_URL"),//不再使用
	//	},
	//}
}

func (opt *ServerRunOptions) AddFlags(fss *cliflag.NamedFlagSets) {
	fs := fss.FlagSet("generic")
	fs.StringVar(&opt.ListenAddr, "addr", opt.ListenAddr, "server listen address")
	fs.UintVar(&opt.ListenPort, "port", opt.ListenPort, "listen port")
	fs.StringVar(&opt.Ks3DSN, "ks3-dsn", opt.Ks3DSN,
		"ks3 database, e.g. <user>:<pass>@tcp(127.0.0.1:3306)/<dbname>?charset=utf8mb4&parseTime=True&loc=Local default: env[STORAGE_OPTIONS_KS3_DSN]")
	fs.StringVar(&opt.EBSAddr, "ebs-addr", opt.EBSAddr, "ebs api address, default: env[STORAGE_OPTIONS_EBS_ADDR]")
	//fs.StringVar(&opt.StorageStateAddr, "storage-state-addr", opt.StorageStateAddr, "storage state api address, default: env[STORAGE_OPTIONS_STORAGE_STATE_ADDR]")
	fs.StringVar(&opt.PrometheusAddr, "prometheus-addr", opt.PrometheusAddr, "prometheus server address, default: env[STORAGE_OPTIONS_PROMETHEUS_ADDR]")
	fs.StringVar(&opt.CustomerDomain, "customer-domain", opt.CustomerDomain, "customer domain name, e.g. cqpcloud.cn, default: env[STORAGE_OPTIONS_CUSTOMER_DOMAIN]")
	// klog.InitFlags()

	fs = fss.FlagSet("openstack")
	fs.BoolVar(&opt.DisableOpenstackAPI, "disable-openstack-api", opt.DisableOpenstackAPI, "Disable openstack api")
	fs.StringVar(&opt.AuthURL, "os-auth-url", opt.AuthURL, "Defaults to env[OS_AUTH_URL]")
	fs.StringVar(&opt.Username, "os-username", opt.Username, "Defaults to env[OS_USERNAME]")
	fs.StringVar(&opt.Password, "os-password", opt.Password, "Defaults to env[OS_PASSWORD]")
	fs.StringVar(&opt.TenantName, "os-tenant-name", opt.TenantName, "Defaults to env[OS_TENANT_NAME]")
	fs.StringVar(&opt.RegionName, "os-region-name", opt.RegionName, "Defaults to env[OS_REGION_NAME]")
}

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/data/db_test.go
```golang
package data

import (
	"context"
	"log"
	"luban-cmdb-api/data/ent"
	"luban-cmdb-api/data/ent/blockstorage"
	"testing"
	"time"

	_ "github.com/go-sql-driver/mysql"
)

func Test_1(t *testing.T) {
	ctx := context.Background()

	client, err := ent.Open("mysql", "luban:Kingsoft123@tcp(10.177.40.250:9306)/cmdb?charset=utf8mb4&parseTime=True&loc=Local")
	if err != nil {
		log.Fatalf("failed opening connection to mysql: %v", err)
	}
	defer client.Close()
	client = client.Debug()

	list, err := client.BlockStorage.Query().All(ctx)
	if err != nil {
		log.Fatalf("failed querying users: %v", err)
	}

	//log.Printf("users: %v", list)

	objSto := list[0]

	_, err = client.BlockStorage.
		Update().
		Where(blockstorage.InstanceID(objSto.InstanceID)).
		SetLastUpdateTime(time.Now()).
		Save(ctx)

	if err != nil {
		log.Fatalf("failed update users: %v", err)

	}

	_, err = client.ObjectStorage.Delete().Exec(ctx)
	if err != nil {
		log.Fatalf("failed delete expired data: %v", err)
	}

}

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/data/ent/objectstorage_query.go
```golang
// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"fmt"
	"luban-cmdb-api/data/ent/objectstorage"
	"luban-cmdb-api/data/ent/predicate"
	"math"

	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
	"entgo.io/ent/schema/field"
)

// ObjectStorageQuery is the builder for querying ObjectStorage entities.
type ObjectStorageQuery struct {
	config
	ctx        *QueryContext
	order      []OrderFunc
	inters     []Interceptor
	predicates []predicate.ObjectStorage
	// intermediate query (i.e. traversal path).
	sql  *sql.Selector
	path func(context.Context) (*sql.Selector, error)
}

// Where adds a new predicate for the ObjectStorageQuery builder.
func (osq *ObjectStorageQuery) Where(ps ...predicate.ObjectStorage) *ObjectStorageQuery {
	osq.predicates = append(osq.predicates, ps...)
	return osq
}

// Limit the number of records to be returned by this query.
func (osq *ObjectStorageQuery) Limit(limit int) *ObjectStorageQuery {
	osq.ctx.Limit = &limit
	return osq
}

// Offset to start from.
func (osq *ObjectStorageQuery) Offset(offset int) *ObjectStorageQuery {
	osq.ctx.Offset = &offset
	return osq
}

// Unique configures the query builder to filter duplicate records on query.
// By default, unique is set to true, and can be disabled using this method.
func (osq *ObjectStorageQuery) Unique(unique bool) *ObjectStorageQuery {
	osq.ctx.Unique = &unique
	return osq
}

// Order specifies how the records should be ordered.
func (osq *ObjectStorageQuery) Order(o ...OrderFunc) *ObjectStorageQuery {
	osq.order = append(osq.order, o...)
	return osq
}

// First returns the first ObjectStorage entity from the query.
// Returns a *NotFoundError when no ObjectStorage was found.
func (osq *ObjectStorageQuery) First(ctx context.Context) (*ObjectStorage, error) {
	nodes, err := osq.Limit(1).All(setContextOp(ctx, osq.ctx, "First"))
	if err != nil {
		return nil, err
	}
	if len(nodes) == 0 {
		return nil, &NotFoundError{objectstorage.Label}
	}
	return nodes[0], nil
}

// FirstX is like First, but panics if an error occurs.
func (osq *ObjectStorageQuery) FirstX(ctx context.Context) *ObjectStorage {
	node, err := osq.First(ctx)
	if err != nil && !IsNotFound(err) {
		panic(err)
	}
	return node
}

// FirstID returns the first ObjectStorage ID from the query.
// Returns a *NotFoundError when no ObjectStorage ID was found.
func (osq *ObjectStorageQuery) FirstID(ctx context.Context) (id string, err error) {
	var ids []string
	if ids, err = osq.Limit(1).IDs(setContextOp(ctx, osq.ctx, "FirstID")); err != nil {
		return
	}
	if len(ids) == 0 {
		err = &NotFoundError{objectstorage.Label}
		return
	}
	return ids[0], nil
}

// FirstIDX is like FirstID, but panics if an error occurs.
func (osq *ObjectStorageQuery) FirstIDX(ctx context.Context) string {
	id, err := osq.FirstID(ctx)
	if err != nil && !IsNotFound(err) {
		panic(err)
	}
	return id
}

// Only returns a single ObjectStorage entity found by the query, ensuring it only returns one.
// Returns a *NotSingularError when more than one ObjectStorage entity is found.
// Returns a *NotFoundError when no ObjectStorage entities are found.
func (osq *ObjectStorageQuery) Only(ctx context.Context) (*ObjectStorage, error) {
	nodes, err := osq.Limit(2).All(setContextOp(ctx, osq.ctx, "Only"))
	if err != nil {
		return nil, err
	}
	switch len(nodes) {
	case 1:
		return nodes[0], nil
	case 0:
		return nil, &NotFoundError{objectstorage.Label}
	default:
		return nil, &NotSingularError{objectstorage.Label}
	}
}

// OnlyX is like Only, but panics if an error occurs.
func (osq *ObjectStorageQuery) OnlyX(ctx context.Context) *ObjectStorage {
	node, err := osq.Only(ctx)
	if err != nil {
		panic(err)
	}
	return node
}

// OnlyID is like Only, but returns the only ObjectStorage ID in the query.
// Returns a *NotSingularError when more than one ObjectStorage ID is found.
// Returns a *NotFoundError when no entities are found.
func (osq *ObjectStorageQuery) OnlyID(ctx context.Context) (id string, err error) {
	var ids []string
	if ids, err = osq.Limit(2).IDs(setContextOp(ctx, osq.ctx, "OnlyID")); err != nil {
		return
	}
	switch len(ids) {
	case 1:
		id = ids[0]
	case 0:
		err = &NotFoundError{objectstorage.Label}
	default:
		err = &NotSingularError{objectstorage.Label}
	}
	return
}

// OnlyIDX is like OnlyID, but panics if an error occurs.
func (osq *ObjectStorageQuery) OnlyIDX(ctx context.Context) string {
	id, err := osq.OnlyID(ctx)
	if err != nil {
		panic(err)
	}
	return id
}

// All executes the query and returns a list of ObjectStorages.
func (osq *ObjectStorageQuery) All(ctx context.Context) ([]*ObjectStorage, error) {
	ctx = setContextOp(ctx, osq.ctx, "All")
	if err := osq.prepareQuery(ctx); err != nil {
		return nil, err
	}
	qr := querierAll[[]*ObjectStorage, *ObjectStorageQuery]()
	return withInterceptors[[]*ObjectStorage](ctx, osq, qr, osq.inters)
}

// AllX is like All, but panics if an error occurs.
func (osq *ObjectStorageQuery) AllX(ctx context.Context) []*ObjectStorage {
	nodes, err := osq.All(ctx)
	if err != nil {
		panic(err)
	}
	return nodes
}

// IDs executes the query and returns a list of ObjectStorage IDs.
func (osq *ObjectStorageQuery) IDs(ctx context.Context) (ids []string, err error) {
	if osq.ctx.Unique == nil && osq.path != nil {
		osq.Unique(true)
	}
	ctx = setContextOp(ctx, osq.ctx, "IDs")
	if err = osq.Select(objectstorage.FieldID).Scan(ctx, &ids); err != nil {
		return nil, err
	}
	return ids, nil
}

// IDsX is like IDs, but panics if an error occurs.
func (osq *ObjectStorageQuery) IDsX(ctx context.Context) []string {
	ids, err := osq.IDs(ctx)
	if err != nil {
		panic(err)
	}
	return ids
}

// Count returns the count of the given query.
func (osq *ObjectStorageQuery) Count(ctx context.Context) (int, error) {
	ctx = setContextOp(ctx, osq.ctx, "Count")
	if err := osq.prepareQuery(ctx); err != nil {
		return 0, err
	}
	return withInterceptors[int](ctx, osq, querierCount[*ObjectStorageQuery](), osq.inters)
}

// CountX is like Count, but panics if an error occurs.
func (osq *ObjectStorageQuery) CountX(ctx context.Context) int {
	count, err := osq.Count(ctx)
	if err != nil {
		panic(err)
	}
	return count
}

// Exist returns true if the query has elements in the graph.
func (osq *ObjectStorageQuery) Exist(ctx context.Context) (bool, error) {
	ctx = setContextOp(ctx, osq.ctx, "Exist")
	switch _, err := osq.FirstID(ctx); {
	case IsNotFound(err):
		return false, nil
	case err != nil:
		return false, fmt.Errorf("ent: check existence: %w", err)
	default:
		return true, nil
	}
}

// ExistX is like Exist, but panics if an error occurs.
func (osq *ObjectStorageQuery) ExistX(ctx context.Context) bool {
	exist, err := osq.Exist(ctx)
	if err != nil {
		panic(err)
	}
	return exist
}

// Clone returns a duplicate of the ObjectStorageQuery builder, including all associated steps. It can be
// used to prepare common query builders and use them differently after the clone is made.
func (osq *ObjectStorageQuery) Clone() *ObjectStorageQuery {
	if osq == nil {
		return nil
	}
	return &ObjectStorageQuery{
		config:     osq.config,
		ctx:        osq.ctx.Clone(),
		order:      append([]OrderFunc{}, osq.order...),
		inters:     append([]Interceptor{}, osq.inters...),
		predicates: append([]predicate.ObjectStorage{}, osq.predicates...),
		// clone intermediate query.
		sql:  osq.sql.Clone(),
		path: osq.path,
	}
}

// GroupBy is used to group vertices by one or more fields/columns.
// It is often used with aggregate functions, like: count, max, mean, min, sum.
//
// Example:
//
//	var v []struct {
//		Name string `json:"name,omitempty"`
//		Count int `json:"count,omitempty"`
//	}
//
//	client.ObjectStorage.Query().
//		GroupBy(objectstorage.FieldName).
//		Aggregate(ent.Count()).
//		Scan(ctx, &v)
func (osq *ObjectStorageQuery) GroupBy(field string, fields ...string) *ObjectStorageGroupBy {
	osq.ctx.Fields = append([]string{field}, fields...)
	grbuild := &ObjectStorageGroupBy{build: osq}
	grbuild.flds = &osq.ctx.Fields
	grbuild.label = objectstorage.Label
	grbuild.scan = grbuild.Scan
	return grbuild
}

// Select allows the selection one or more fields/columns for the given query,
// instead of selecting all fields in the entity.
//
// Example:
//
//	var v []struct {
//		Name string `json:"name,omitempty"`
//	}
//
//	client.ObjectStorage.Query().
//		Select(objectstorage.FieldName).
//		Scan(ctx, &v)
func (osq *ObjectStorageQuery) Select(fields ...string) *ObjectStorageSelect {
	osq.ctx.Fields = append(osq.ctx.Fields, fields...)
	sbuild := &ObjectStorageSelect{ObjectStorageQuery: osq}
	sbuild.label = objectstorage.Label
	sbuild.flds, sbuild.scan = &osq.ctx.Fields, sbuild.Scan
	return sbuild
}

// Aggregate returns a ObjectStorageSelect configured with the given aggregations.
func (osq *ObjectStorageQuery) Aggregate(fns ...AggregateFunc) *ObjectStorageSelect {
	return osq.Select().Aggregate(fns...)
}

func (osq *ObjectStorageQuery) prepareQuery(ctx context.Context) error {
	for _, inter := range osq.inters {
		if inter == nil {
			return fmt.Errorf("ent: uninitialized interceptor (forgotten import ent/runtime?)")
		}
		if trv, ok := inter.(Traverser); ok {
			if err := trv.Traverse(ctx, osq); err != nil {
				return err
			}
		}
	}
	for _, f := range osq.ctx.Fields {
		if !objectstorage.ValidColumn(f) {
			return &ValidationError{Name: f, err: fmt.Errorf("ent: invalid field %q for query", f)}
		}
	}
	if osq.path != nil {
		prev, err := osq.path(ctx)
		if err != nil {
			return err
		}
		osq.sql = prev
	}
	return nil
}

func (osq *ObjectStorageQuery) sqlAll(ctx context.Context, hooks ...queryHook) ([]*ObjectStorage, error) {
	var (
		nodes = []*ObjectStorage{}
		_spec = osq.querySpec()
	)
	_spec.ScanValues = func(columns []string) ([]any, error) {
		return (*ObjectStorage).scanValues(nil, columns)
	}
	_spec.Assign = func(columns []string, values []any) error {
		node := &ObjectStorage{config: osq.config}
		nodes = append(nodes, node)
		return node.assignValues(columns, values)
	}
	for i := range hooks {
		hooks[i](ctx, _spec)
	}
	if err := sqlgraph.QueryNodes(ctx, osq.driver, _spec); err != nil {
		return nil, err
	}
	if len(nodes) == 0 {
		return nodes, nil
	}
	return nodes, nil
}

func (osq *ObjectStorageQuery) sqlCount(ctx context.Context) (int, error) {
	_spec := osq.querySpec()
	_spec.Node.Columns = osq.ctx.Fields
	if len(osq.ctx.Fields) > 0 {
		_spec.Unique = osq.ctx.Unique != nil && *osq.ctx.Unique
	}
	return sqlgraph.CountNodes(ctx, osq.driver, _spec)
}

func (osq *ObjectStorageQuery) querySpec() *sqlgraph.QuerySpec {
	_spec := sqlgraph.NewQuerySpec(objectstorage.Table, objectstorage.Columns, sqlgraph.NewFieldSpec(objectstorage.FieldID, field.TypeString))
	_spec.From = osq.sql
	if unique := osq.ctx.Unique; unique != nil {
		_spec.Unique = *unique
	} else if osq.path != nil {
		_spec.Unique = true
	}
	if fields := osq.ctx.Fields; len(fields) > 0 {
		_spec.Node.Columns = make([]string, 0, len(fields))
		_spec.Node.Columns = append(_spec.Node.Columns, objectstorage.FieldID)
		for i := range fields {
			if fields[i] != objectstorage.FieldID {
				_spec.Node.Columns = append(_spec.Node.Columns, fields[i])
			}
		}
	}
	if ps := osq.predicates; len(ps) > 0 {
		_spec.Predicate = func(selector *sql.Selector) {
			for i := range ps {
				ps[i](selector)
			}
		}
	}
	if limit := osq.ctx.Limit; limit != nil {
		_spec.Limit = *limit
	}
	if offset := osq.ctx.Offset; offset != nil {
		_spec.Offset = *offset
	}
	if ps := osq.order; len(ps) > 0 {
		_spec.Order = func(selector *sql.Selector) {
			for i := range ps {
				ps[i](selector)
			}
		}
	}
	return _spec
}

func (osq *ObjectStorageQuery) sqlQuery(ctx context.Context) *sql.Selector {
	builder := sql.Dialect(osq.driver.Dialect())
	t1 := builder.Table(objectstorage.Table)
	columns := osq.ctx.Fields
	if len(columns) == 0 {
		columns = objectstorage.Columns
	}
	selector := builder.Select(t1.Columns(columns...)...).From(t1)
	if osq.sql != nil {
		selector = osq.sql
		selector.Select(selector.Columns(columns...)...)
	}
	if osq.ctx.Unique != nil && *osq.ctx.Unique {
		selector.Distinct()
	}
	for _, p := range osq.predicates {
		p(selector)
	}
	for _, p := range osq.order {
		p(selector)
	}
	if offset := osq.ctx.Offset; offset != nil {
		// limit is mandatory for offset clause. We start
		// with default value, and override it below if needed.
		selector.Offset(*offset).Limit(math.MaxInt32)
	}
	if limit := osq.ctx.Limit; limit != nil {
		selector.Limit(*limit)
	}
	return selector
}

// ObjectStorageGroupBy is the group-by builder for ObjectStorage entities.
type ObjectStorageGroupBy struct {
	selector
	build *ObjectStorageQuery
}

// Aggregate adds the given aggregation functions to the group-by query.
func (osgb *ObjectStorageGroupBy) Aggregate(fns ...AggregateFunc) *ObjectStorageGroupBy {
	osgb.fns = append(osgb.fns, fns...)
	return osgb
}

// Scan applies the selector query and scans the result into the given value.
func (osgb *ObjectStorageGroupBy) Scan(ctx context.Context, v any) error {
	ctx = setContextOp(ctx, osgb.build.ctx, "GroupBy")
	if err := osgb.build.prepareQuery(ctx); err != nil {
		return err
	}
	return scanWithInterceptors[*ObjectStorageQuery, *ObjectStorageGroupBy](ctx, osgb.build, osgb, osgb.build.inters, v)
}

func (osgb *ObjectStorageGroupBy) sqlScan(ctx context.Context, root *ObjectStorageQuery, v any) error {
	selector := root.sqlQuery(ctx).Select()
	aggregation := make([]string, 0, len(osgb.fns))
	for _, fn := range osgb.fns {
		aggregation = append(aggregation, fn(selector))
	}
	if len(selector.SelectedColumns()) == 0 {
		columns := make([]string, 0, len(*osgb.flds)+len(osgb.fns))
		for _, f := range *osgb.flds {
			columns = append(columns, selector.C(f))
		}
		columns = append(columns, aggregation...)
		selector.Select(columns...)
	}
	selector.GroupBy(selector.Columns(*osgb.flds...)...)
	if err := selector.Err(); err != nil {
		return err
	}
	rows := &sql.Rows{}
	query, args := selector.Query()
	if err := osgb.build.driver.Query(ctx, query, args, rows); err != nil {
		return err
	}
	defer rows.Close()
	return sql.ScanSlice(rows, v)
}

// ObjectStorageSelect is the builder for selecting fields of ObjectStorage entities.
type ObjectStorageSelect struct {
	*ObjectStorageQuery
	selector
}

// Aggregate adds the given aggregation functions to the selector query.
func (oss *ObjectStorageSelect) Aggregate(fns ...AggregateFunc) *ObjectStorageSelect {
	oss.fns = append(oss.fns, fns...)
	return oss
}

// Scan applies the selector query and scans the result into the given value.
func (oss *ObjectStorageSelect) Scan(ctx context.Context, v any) error {
	ctx = setContextOp(ctx, oss.ctx, "Select")
	if err := oss.prepareQuery(ctx); err != nil {
		return err
	}
	return scanWithInterceptors[*ObjectStorageQuery, *ObjectStorageSelect](ctx, oss.ObjectStorageQuery, oss, oss.inters, v)
}

func (oss *ObjectStorageSelect) sqlScan(ctx context.Context, root *ObjectStorageQuery, v any) error {
	selector := root.sqlQuery(ctx)
	aggregation := make([]string, 0, len(oss.fns))
	for _, fn := range oss.fns {
		aggregation = append(aggregation, fn(selector))
	}
	switch n := len(*oss.selector.flds); {
	case n == 0 && len(aggregation) > 0:
		selector.Select(aggregation...)
	case n != 0 && len(aggregation) > 0:
		selector.AppendSelect(aggregation...)
	}
	rows := &sql.Rows{}
	query, args := selector.Query()
	if err := oss.driver.Query(ctx, query, args, rows); err != nil {
		return err
	}
	defer rows.Close()
	return sql.ScanSlice(rows, v)
}

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/data/ent/generate.go
```golang
package ent

//go:generate go run -mod=mod entgo.io/ent/cmd/ent generate ./schema

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/data/ent/objectstorage_delete.go
```golang
// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"luban-cmdb-api/data/ent/objectstorage"
	"luban-cmdb-api/data/ent/predicate"

	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
	"entgo.io/ent/schema/field"
)

// ObjectStorageDelete is the builder for deleting a ObjectStorage entity.
type ObjectStorageDelete struct {
	config
	hooks    []Hook
	mutation *ObjectStorageMutation
}

// Where appends a list predicates to the ObjectStorageDelete builder.
func (osd *ObjectStorageDelete) Where(ps ...predicate.ObjectStorage) *ObjectStorageDelete {
	osd.mutation.Where(ps...)
	return osd
}

// Exec executes the deletion query and returns how many vertices were deleted.
func (osd *ObjectStorageDelete) Exec(ctx context.Context) (int, error) {
	return withHooks[int, ObjectStorageMutation](ctx, osd.sqlExec, osd.mutation, osd.hooks)
}

// ExecX is like Exec, but panics if an error occurs.
func (osd *ObjectStorageDelete) ExecX(ctx context.Context) int {
	n, err := osd.Exec(ctx)
	if err != nil {
		panic(err)
	}
	return n
}

func (osd *ObjectStorageDelete) sqlExec(ctx context.Context) (int, error) {
	_spec := sqlgraph.NewDeleteSpec(objectstorage.Table, sqlgraph.NewFieldSpec(objectstorage.FieldID, field.TypeString))
	if ps := osd.mutation.predicates; len(ps) > 0 {
		_spec.Predicate = func(selector *sql.Selector) {
			for i := range ps {
				ps[i](selector)
			}
		}
	}
	affected, err := sqlgraph.DeleteNodes(ctx, osd.driver, _spec)
	if err != nil && sqlgraph.IsConstraintError(err) {
		err = &ConstraintError{msg: err.Error(), wrap: err}
	}
	osd.mutation.done = true
	return affected, err
}

// ObjectStorageDeleteOne is the builder for deleting a single ObjectStorage entity.
type ObjectStorageDeleteOne struct {
	osd *ObjectStorageDelete
}

// Where appends a list predicates to the ObjectStorageDelete builder.
func (osdo *ObjectStorageDeleteOne) Where(ps ...predicate.ObjectStorage) *ObjectStorageDeleteOne {
	osdo.osd.mutation.Where(ps...)
	return osdo
}

// Exec executes the deletion query.
func (osdo *ObjectStorageDeleteOne) Exec(ctx context.Context) error {
	n, err := osdo.osd.Exec(ctx)
	switch {
	case err != nil:
		return err
	case n == 0:
		return &NotFoundError{objectstorage.Label}
	default:
		return nil
	}
}

// ExecX is like Exec, but panics if an error occurs.
func (osdo *ObjectStorageDeleteOne) ExecX(ctx context.Context) {
	if err := osdo.Exec(ctx); err != nil {
		panic(err)
	}
}

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/data/ent/ebsvolume_update.go
```golang
// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"luban-cmdb-api/data/ent/ebsvolume"
	"luban-cmdb-api/data/ent/predicate"
	"time"

	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
	"entgo.io/ent/schema/field"
)

// EbsVolumeUpdate is the builder for updating EbsVolume entities.
type EbsVolumeUpdate struct {
	config
	hooks    []Hook
	mutation *EbsVolumeMutation
}

// Where appends a list predicates to the EbsVolumeUpdate builder.
func (evu *EbsVolumeUpdate) Where(ps ...predicate.EbsVolume) *EbsVolumeUpdate {
	evu.mutation.Where(ps...)
	return evu
}

// SetGalaxy sets the "galaxy" field.
func (evu *EbsVolumeUpdate) SetGalaxy(s string) *EbsVolumeUpdate {
	evu.mutation.SetGalaxy(s)
	return evu
}

// SetNillableGalaxy sets the "galaxy" field if the given value is not nil.
func (evu *EbsVolumeUpdate) SetNillableGalaxy(s *string) *EbsVolumeUpdate {
	if s != nil {
		evu.SetGalaxy(*s)
	}
	return evu
}

// ClearGalaxy clears the value of the "galaxy" field.
func (evu *EbsVolumeUpdate) ClearGalaxy() *EbsVolumeUpdate {
	evu.mutation.ClearGalaxy()
	return evu
}

// SetRegion sets the "region" field.
func (evu *EbsVolumeUpdate) SetRegion(s string) *EbsVolumeUpdate {
	evu.mutation.SetRegion(s)
	return evu
}

// SetAz sets the "az" field.
func (evu *EbsVolumeUpdate) SetAz(s string) *EbsVolumeUpdate {
	evu.mutation.SetAz(s)
	return evu
}

// SetNillableAz sets the "az" field if the given value is not nil.
func (evu *EbsVolumeUpdate) SetNillableAz(s *string) *EbsVolumeUpdate {
	if s != nil {
		evu.SetAz(*s)
	}
	return evu
}

// ClearAz clears the value of the "az" field.
func (evu *EbsVolumeUpdate) ClearAz() *EbsVolumeUpdate {
	evu.mutation.ClearAz()
	return evu
}

// SetCreatedAt sets the "created_at" field.
func (evu *EbsVolumeUpdate) SetCreatedAt(t time.Time) *EbsVolumeUpdate {
	evu.mutation.SetCreatedAt(t)
	return evu
}

// SetNillableCreatedAt sets the "created_at" field if the given value is not nil.
func (evu *EbsVolumeUpdate) SetNillableCreatedAt(t *time.Time) *EbsVolumeUpdate {
	if t != nil {
		evu.SetCreatedAt(*t)
	}
	return evu
}

// ClearCreatedAt clears the value of the "created_at" field.
func (evu *EbsVolumeUpdate) ClearCreatedAt() *EbsVolumeUpdate {
	evu.mutation.ClearCreatedAt()
	return evu
}

// SetUpdatedAt sets the "updated_at" field.
func (evu *EbsVolumeUpdate) SetUpdatedAt(t time.Time) *EbsVolumeUpdate {
	evu.mutation.SetUpdatedAt(t)
	return evu
}

// SetVersion sets the "version" field.
func (evu *EbsVolumeUpdate) SetVersion(s string) *EbsVolumeUpdate {
	evu.mutation.SetVersion(s)
	return evu
}

// SetNillableVersion sets the "version" field if the given value is not nil.
func (evu *EbsVolumeUpdate) SetNillableVersion(s *string) *EbsVolumeUpdate {
	if s != nil {
		evu.SetVersion(*s)
	}
	return evu
}

// ClearVersion clears the value of the "version" field.
func (evu *EbsVolumeUpdate) ClearVersion() *EbsVolumeUpdate {
	evu.mutation.ClearVersion()
	return evu
}

// SetVolumeID sets the "volume_id" field.
func (evu *EbsVolumeUpdate) SetVolumeID(s string) *EbsVolumeUpdate {
	evu.mutation.SetVolumeID(s)
	return evu
}

// SetNillableVolumeID sets the "volume_id" field if the given value is not nil.
func (evu *EbsVolumeUpdate) SetNillableVolumeID(s *string) *EbsVolumeUpdate {
	if s != nil {
		evu.SetVolumeID(*s)
	}
	return evu
}

// ClearVolumeID clears the value of the "volume_id" field.
func (evu *EbsVolumeUpdate) ClearVolumeID() *EbsVolumeUpdate {
	evu.mutation.ClearVolumeID()
	return evu
}

// SetName sets the "name" field.
func (evu *EbsVolumeUpdate) SetName(s string) *EbsVolumeUpdate {
	evu.mutation.SetName(s)
	return evu
}

// SetPoolID sets the "pool_id" field.
func (evu *EbsVolumeUpdate) SetPoolID(s string) *EbsVolumeUpdate {
	evu.mutation.SetPoolID(s)
	return evu
}

// SetNillablePoolID sets the "pool_id" field if the given value is not nil.
func (evu *EbsVolumeUpdate) SetNillablePoolID(s *string) *EbsVolumeUpdate {
	if s != nil {
		evu.SetPoolID(*s)
	}
	return evu
}

// ClearPoolID clears the value of the "pool_id" field.
func (evu *EbsVolumeUpdate) ClearPoolID() *EbsVolumeUpdate {
	evu.mutation.ClearPoolID()
	return evu
}

// SetPoolName sets the "pool_name" field.
func (evu *EbsVolumeUpdate) SetPoolName(s string) *EbsVolumeUpdate {
	evu.mutation.SetPoolName(s)
	return evu
}

// SetNillablePoolName sets the "pool_name" field if the given value is not nil.
func (evu *EbsVolumeUpdate) SetNillablePoolName(s *string) *EbsVolumeUpdate {
	if s != nil {
		evu.SetPoolName(*s)
	}
	return evu
}

// ClearPoolName clears the value of the "pool_name" field.
func (evu *EbsVolumeUpdate) ClearPoolName() *EbsVolumeUpdate {
	evu.mutation.ClearPoolName()
	return evu
}

// SetSize sets the "size" field.
func (evu *EbsVolumeUpdate) SetSize(i int32) *EbsVolumeUpdate {
	evu.mutation.ResetSize()
	evu.mutation.SetSize(i)
	return evu
}

// SetNillableSize sets the "size" field if the given value is not nil.
func (evu *EbsVolumeUpdate) SetNillableSize(i *int32) *EbsVolumeUpdate {
	if i != nil {
		evu.SetSize(*i)
	}
	return evu
}

// AddSize adds i to the "size" field.
func (evu *EbsVolumeUpdate) AddSize(i int32) *EbsVolumeUpdate {
	evu.mutation.AddSize(i)
	return evu
}

// ClearSize clears the value of the "size" field.
func (evu *EbsVolumeUpdate) ClearSize() *EbsVolumeUpdate {
	evu.mutation.ClearSize()
	return evu
}

// SetStatus sets the "status" field.
func (evu *EbsVolumeUpdate) SetStatus(s string) *EbsVolumeUpdate {
	evu.mutation.SetStatus(s)
	return evu
}

// SetNillableStatus sets the "status" field if the given value is not nil.
func (evu *EbsVolumeUpdate) SetNillableStatus(s *string) *EbsVolumeUpdate {
	if s != nil {
		evu.SetStatus(*s)
	}
	return evu
}

// ClearStatus clears the value of the "status" field.
func (evu *EbsVolumeUpdate) ClearStatus() *EbsVolumeUpdate {
	evu.mutation.ClearStatus()
	return evu
}

// SetStatusName sets the "status_name" field.
func (evu *EbsVolumeUpdate) SetStatusName(s string) *EbsVolumeUpdate {
	evu.mutation.SetStatusName(s)
	return evu
}

// SetNillableStatusName sets the "status_name" field if the given value is not nil.
func (evu *EbsVolumeUpdate) SetNillableStatusName(s *string) *EbsVolumeUpdate {
	if s != nil {
		evu.SetStatusName(*s)
	}
	return evu
}

// ClearStatusName clears the value of the "status_name" field.
func (evu *EbsVolumeUpdate) ClearStatusName() *EbsVolumeUpdate {
	evu.mutation.ClearStatusName()
	return evu
}

// SetVolumeType sets the "volume_type" field.
func (evu *EbsVolumeUpdate) SetVolumeType(s string) *EbsVolumeUpdate {
	evu.mutation.SetVolumeType(s)
	return evu
}

// SetNillableVolumeType sets the "volume_type" field if the given value is not nil.
func (evu *EbsVolumeUpdate) SetNillableVolumeType(s *string) *EbsVolumeUpdate {
	if s != nil {
		evu.SetVolumeType(*s)
	}
	return evu
}

// ClearVolumeType clears the value of the "volume_type" field.
func (evu *EbsVolumeUpdate) ClearVolumeType() *EbsVolumeUpdate {
	evu.mutation.ClearVolumeType()
	return evu
}

// SetVMID sets the "vm_id" field.
func (evu *EbsVolumeUpdate) SetVMID(s string) *EbsVolumeUpdate {
	evu.mutation.SetVMID(s)
	return evu
}

// SetVMName sets the "vm_name" field.
func (evu *EbsVolumeUpdate) SetVMName(s string) *EbsVolumeUpdate {
	evu.mutation.SetVMName(s)
	return evu
}

// SetTenantID sets the "tenant_id" field.
func (evu *EbsVolumeUpdate) SetTenantID(s string) *EbsVolumeUpdate {
	evu.mutation.SetTenantID(s)
	return evu
}

// SetNillableTenantID sets the "tenant_id" field if the given value is not nil.
func (evu *EbsVolumeUpdate) SetNillableTenantID(s *string) *EbsVolumeUpdate {
	if s != nil {
		evu.SetTenantID(*s)
	}
	return evu
}

// ClearTenantID clears the value of the "tenant_id" field.
func (evu *EbsVolumeUpdate) ClearTenantID() *EbsVolumeUpdate {
	evu.mutation.ClearTenantID()
	return evu
}

// SetTenantName sets the "tenant_name" field.
func (evu *EbsVolumeUpdate) SetTenantName(s string) *EbsVolumeUpdate {
	evu.mutation.SetTenantName(s)
	return evu
}

// SetNillableTenantName sets the "tenant_name" field if the given value is not nil.
func (evu *EbsVolumeUpdate) SetNillableTenantName(s *string) *EbsVolumeUpdate {
	if s != nil {
		evu.SetTenantName(*s)
	}
	return evu
}

// ClearTenantName clears the value of the "tenant_name" field.
func (evu *EbsVolumeUpdate) ClearTenantName() *EbsVolumeUpdate {
	evu.mutation.ClearTenantName()
	return evu
}

// SetProjectID sets the "project_id" field.
func (evu *EbsVolumeUpdate) SetProjectID(s string) *EbsVolumeUpdate {
	evu.mutation.SetProjectID(s)
	return evu
}

// SetProjectName sets the "project_name" field.
func (evu *EbsVolumeUpdate) SetProjectName(s string) *EbsVolumeUpdate {
	evu.mutation.SetProjectName(s)
	return evu
}

// SetCreateTime sets the "create_time" field.
func (evu *EbsVolumeUpdate) SetCreateTime(t time.Time) *EbsVolumeUpdate {
	evu.mutation.SetCreateTime(t)
	return evu
}

// SetNillableCreateTime sets the "create_time" field if the given value is not nil.
func (evu *EbsVolumeUpdate) SetNillableCreateTime(t *time.Time) *EbsVolumeUpdate {
	if t != nil {
		evu.SetCreateTime(*t)
	}
	return evu
}

// ClearCreateTime clears the value of the "create_time" field.
func (evu *EbsVolumeUpdate) ClearCreateTime() *EbsVolumeUpdate {
	evu.mutation.ClearCreateTime()
	return evu
}

// SetServiceEndTime sets the "service_end_time" field.
func (evu *EbsVolumeUpdate) SetServiceEndTime(t time.Time) *EbsVolumeUpdate {
	evu.mutation.SetServiceEndTime(t)
	return evu
}

// SetNillableServiceEndTime sets the "service_end_time" field if the given value is not nil.
func (evu *EbsVolumeUpdate) SetNillableServiceEndTime(t *time.Time) *EbsVolumeUpdate {
	if t != nil {
		evu.SetServiceEndTime(*t)
	}
	return evu
}

// ClearServiceEndTime clears the value of the "service_end_time" field.
func (evu *EbsVolumeUpdate) ClearServiceEndTime() *EbsVolumeUpdate {
	evu.mutation.ClearServiceEndTime()
	return evu
}

// SetDeleted sets the "deleted" field.
func (evu *EbsVolumeUpdate) SetDeleted(b bool) *EbsVolumeUpdate {
	evu.mutation.SetDeleted(b)
	return evu
}

// SetNillableDeleted sets the "deleted" field if the given value is not nil.
func (evu *EbsVolumeUpdate) SetNillableDeleted(b *bool) *EbsVolumeUpdate {
	if b != nil {
		evu.SetDeleted(*b)
	}
	return evu
}

// ClearDeleted clears the value of the "deleted" field.
func (evu *EbsVolumeUpdate) ClearDeleted() *EbsVolumeUpdate {
	evu.mutation.ClearDeleted()
	return evu
}

// Mutation returns the EbsVolumeMutation object of the builder.
func (evu *EbsVolumeUpdate) Mutation() *EbsVolumeMutation {
	return evu.mutation
}

// Save executes the query and returns the number of nodes affected by the update operation.
func (evu *EbsVolumeUpdate) Save(ctx context.Context) (int, error) {
	return withHooks[int, EbsVolumeMutation](ctx, evu.sqlSave, evu.mutation, evu.hooks)
}

// SaveX is like Save, but panics if an error occurs.
func (evu *EbsVolumeUpdate) SaveX(ctx context.Context) int {
	affected, err := evu.Save(ctx)
	if err != nil {
		panic(err)
	}
	return affected
}

// Exec executes the query.
func (evu *EbsVolumeUpdate) Exec(ctx context.Context) error {
	_, err := evu.Save(ctx)
	return err
}

// ExecX is like Exec, but panics if an error occurs.
func (evu *EbsVolumeUpdate) ExecX(ctx context.Context) {
	if err := evu.Exec(ctx); err != nil {
		panic(err)
	}
}

func (evu *EbsVolumeUpdate) sqlSave(ctx context.Context) (n int, err error) {
	_spec := sqlgraph.NewUpdateSpec(ebsvolume.Table, ebsvolume.Columns, sqlgraph.NewFieldSpec(ebsvolume.FieldID, field.TypeInt))
	if ps := evu.mutation.predicates; len(ps) > 0 {
		_spec.Predicate = func(selector *sql.Selector) {
			for i := range ps {
				ps[i](selector)
			}
		}
	}
	if value, ok := evu.mutation.Galaxy(); ok {
		_spec.SetField(ebsvolume.FieldGalaxy, field.TypeString, value)
	}
	if evu.mutation.GalaxyCleared() {
		_spec.ClearField(ebsvolume.FieldGalaxy, field.TypeString)
	}
	if value, ok := evu.mutation.Region(); ok {
		_spec.SetField(ebsvolume.FieldRegion, field.TypeString, value)
	}
	if value, ok := evu.mutation.Az(); ok {
		_spec.SetField(ebsvolume.FieldAz, field.TypeString, value)
	}
	if evu.mutation.AzCleared() {
		_spec.ClearField(ebsvolume.FieldAz, field.TypeString)
	}
	if value, ok := evu.mutation.CreatedAt(); ok {
		_spec.SetField(ebsvolume.FieldCreatedAt, field.TypeTime, value)
	}
	if evu.mutation.CreatedAtCleared() {
		_spec.ClearField(ebsvolume.FieldCreatedAt, field.TypeTime)
	}
	if value, ok := evu.mutation.UpdatedAt(); ok {
		_spec.SetField(ebsvolume.FieldUpdatedAt, field.TypeTime, value)
	}
	if value, ok := evu.mutation.Version(); ok {
		_spec.SetField(ebsvolume.FieldVersion, field.TypeString, value)
	}
	if evu.mutation.VersionCleared() {
		_spec.ClearField(ebsvolume.FieldVersion, field.TypeString)
	}
	if value, ok := evu.mutation.VolumeID(); ok {
		_spec.SetField(ebsvolume.FieldVolumeID, field.TypeString, value)
	}
	if evu.mutation.VolumeIDCleared() {
		_spec.ClearField(ebsvolume.FieldVolumeID, field.TypeString)
	}
	if value, ok := evu.mutation.Name(); ok {
		_spec.SetField(ebsvolume.FieldName, field.TypeString, value)
	}
	if value, ok := evu.mutation.PoolID(); ok {
		_spec.SetField(ebsvolume.FieldPoolID, field.TypeString, value)
	}
	if evu.mutation.PoolIDCleared() {
		_spec.ClearField(ebsvolume.FieldPoolID, field.TypeString)
	}
	if value, ok := evu.mutation.PoolName(); ok {
		_spec.SetField(ebsvolume.FieldPoolName, field.TypeString, value)
	}
	if evu.mutation.PoolNameCleared() {
		_spec.ClearField(ebsvolume.FieldPoolName, field.TypeString)
	}
	if value, ok := evu.mutation.Size(); ok {
		_spec.SetField(ebsvolume.FieldSize, field.TypeInt32, value)
	}
	if value, ok := evu.mutation.AddedSize(); ok {
		_spec.AddField(ebsvolume.FieldSize, field.TypeInt32, value)
	}
	if evu.mutation.SizeCleared() {
		_spec.ClearField(ebsvolume.FieldSize, field.TypeInt32)
	}
	if value, ok := evu.mutation.Status(); ok {
		_spec.SetField(ebsvolume.FieldStatus, field.TypeString, value)
	}
	if evu.mutation.StatusCleared() {
		_spec.ClearField(ebsvolume.FieldStatus, field.TypeString)
	}
	if value, ok := evu.mutation.StatusName(); ok {
		_spec.SetField(ebsvolume.FieldStatusName, field.TypeString, value)
	}
	if evu.mutation.StatusNameCleared() {
		_spec.ClearField(ebsvolume.FieldStatusName, field.TypeString)
	}
	if value, ok := evu.mutation.VolumeType(); ok {
		_spec.SetField(ebsvolume.FieldVolumeType, field.TypeString, value)
	}
	if evu.mutation.VolumeTypeCleared() {
		_spec.ClearField(ebsvolume.FieldVolumeType, field.TypeString)
	}
	if value, ok := evu.mutation.VMID(); ok {
		_spec.SetField(ebsvolume.FieldVMID, field.TypeString, value)
	}
	if value, ok := evu.mutation.VMName(); ok {
		_spec.SetField(ebsvolume.FieldVMName, field.TypeString, value)
	}
	if value, ok := evu.mutation.TenantID(); ok {
		_spec.SetField(ebsvolume.FieldTenantID, field.TypeString, value)
	}
	if evu.mutation.TenantIDCleared() {
		_spec.ClearField(ebsvolume.FieldTenantID, field.TypeString)
	}
	if value, ok := evu.mutation.TenantName(); ok {
		_spec.SetField(ebsvolume.FieldTenantName, field.TypeString, value)
	}
	if evu.mutation.TenantNameCleared() {
		_spec.ClearField(ebsvolume.FieldTenantName, field.TypeString)
	}
	if value, ok := evu.mutation.ProjectID(); ok {
		_spec.SetField(ebsvolume.FieldProjectID, field.TypeString, value)
	}
	if value, ok := evu.mutation.ProjectName(); ok {
		_spec.SetField(ebsvolume.FieldProjectName, field.TypeString, value)
	}
	if value, ok := evu.mutation.CreateTime(); ok {
		_spec.SetField(ebsvolume.FieldCreateTime, field.TypeTime, value)
	}
	if evu.mutation.CreateTimeCleared() {
		_spec.ClearField(ebsvolume.FieldCreateTime, field.TypeTime)
	}
	if value, ok := evu.mutation.ServiceEndTime(); ok {
		_spec.SetField(ebsvolume.FieldServiceEndTime, field.TypeTime, value)
	}
	if evu.mutation.ServiceEndTimeCleared() {
		_spec.ClearField(ebsvolume.FieldServiceEndTime, field.TypeTime)
	}
	if value, ok := evu.mutation.Deleted(); ok {
		_spec.SetField(ebsvolume.FieldDeleted, field.TypeBool, value)
	}
	if evu.mutation.DeletedCleared() {
		_spec.ClearField(ebsvolume.FieldDeleted, field.TypeBool)
	}
	if n, err = sqlgraph.UpdateNodes(ctx, evu.driver, _spec); err != nil {
		if _, ok := err.(*sqlgraph.NotFoundError); ok {
			err = &NotFoundError{ebsvolume.Label}
		} else if sqlgraph.IsConstraintError(err) {
			err = &ConstraintError{msg: err.Error(), wrap: err}
		}
		return 0, err
	}
	evu.mutation.done = true
	return n, nil
}

// EbsVolumeUpdateOne is the builder for updating a single EbsVolume entity.
type EbsVolumeUpdateOne struct {
	config
	fields   []string
	hooks    []Hook
	mutation *EbsVolumeMutation
}

// SetGalaxy sets the "galaxy" field.
func (evuo *EbsVolumeUpdateOne) SetGalaxy(s string) *EbsVolumeUpdateOne {
	evuo.mutation.SetGalaxy(s)
	return evuo
}

// SetNillableGalaxy sets the "galaxy" field if the given value is not nil.
func (evuo *EbsVolumeUpdateOne) SetNillableGalaxy(s *string) *EbsVolumeUpdateOne {
	if s != nil {
		evuo.SetGalaxy(*s)
	}
	return evuo
}

// ClearGalaxy clears the value of the "galaxy" field.
func (evuo *EbsVolumeUpdateOne) ClearGalaxy() *EbsVolumeUpdateOne {
	evuo.mutation.ClearGalaxy()
	return evuo
}

// SetRegion sets the "region" field.
func (evuo *EbsVolumeUpdateOne) SetRegion(s string) *EbsVolumeUpdateOne {
	evuo.mutation.SetRegion(s)
	return evuo
}

// SetAz sets the "az" field.
func (evuo *EbsVolumeUpdateOne) SetAz(s string) *EbsVolumeUpdateOne {
	evuo.mutation.SetAz(s)
	return evuo
}

// SetNillableAz sets the "az" field if the given value is not nil.
func (evuo *EbsVolumeUpdateOne) SetNillableAz(s *string) *EbsVolumeUpdateOne {
	if s != nil {
		evuo.SetAz(*s)
	}
	return evuo
}

// ClearAz clears the value of the "az" field.
func (evuo *EbsVolumeUpdateOne) ClearAz() *EbsVolumeUpdateOne {
	evuo.mutation.ClearAz()
	return evuo
}

// SetCreatedAt sets the "created_at" field.
func (evuo *EbsVolumeUpdateOne) SetCreatedAt(t time.Time) *EbsVolumeUpdateOne {
	evuo.mutation.SetCreatedAt(t)
	return evuo
}

// SetNillableCreatedAt sets the "created_at" field if the given value is not nil.
func (evuo *EbsVolumeUpdateOne) SetNillableCreatedAt(t *time.Time) *EbsVolumeUpdateOne {
	if t != nil {
		evuo.SetCreatedAt(*t)
	}
	return evuo
}

// ClearCreatedAt clears the value of the "created_at" field.
func (evuo *EbsVolumeUpdateOne) ClearCreatedAt() *EbsVolumeUpdateOne {
	evuo.mutation.ClearCreatedAt()
	return evuo
}

// SetUpdatedAt sets the "updated_at" field.
func (evuo *EbsVolumeUpdateOne) SetUpdatedAt(t time.Time) *EbsVolumeUpdateOne {
	evuo.mutation.SetUpdatedAt(t)
	return evuo
}

// SetVersion sets the "version" field.
func (evuo *EbsVolumeUpdateOne) SetVersion(s string) *EbsVolumeUpdateOne {
	evuo.mutation.SetVersion(s)
	return evuo
}

// SetNillableVersion sets the "version" field if the given value is not nil.
func (evuo *EbsVolumeUpdateOne) SetNillableVersion(s *string) *EbsVolumeUpdateOne {
	if s != nil {
		evuo.SetVersion(*s)
	}
	return evuo
}

// ClearVersion clears the value of the "version" field.
func (evuo *EbsVolumeUpdateOne) ClearVersion() *EbsVolumeUpdateOne {
	evuo.mutation.ClearVersion()
	return evuo
}

// SetVolumeID sets the "volume_id" field.
func (evuo *EbsVolumeUpdateOne) SetVolumeID(s string) *EbsVolumeUpdateOne {
	evuo.mutation.SetVolumeID(s)
	return evuo
}

// SetNillableVolumeID sets the "volume_id" field if the given value is not nil.
func (evuo *EbsVolumeUpdateOne) SetNillableVolumeID(s *string) *EbsVolumeUpdateOne {
	if s != nil {
		evuo.SetVolumeID(*s)
	}
	return evuo
}

// ClearVolumeID clears the value of the "volume_id" field.
func (evuo *EbsVolumeUpdateOne) ClearVolumeID() *EbsVolumeUpdateOne {
	evuo.mutation.ClearVolumeID()
	return evuo
}

// SetName sets the "name" field.
func (evuo *EbsVolumeUpdateOne) SetName(s string) *EbsVolumeUpdateOne {
	evuo.mutation.SetName(s)
	return evuo
}

// SetPoolID sets the "pool_id" field.
func (evuo *EbsVolumeUpdateOne) SetPoolID(s string) *EbsVolumeUpdateOne {
	evuo.mutation.SetPoolID(s)
	return evuo
}

// SetNillablePoolID sets the "pool_id" field if the given value is not nil.
func (evuo *EbsVolumeUpdateOne) SetNillablePoolID(s *string) *EbsVolumeUpdateOne {
	if s != nil {
		evuo.SetPoolID(*s)
	}
	return evuo
}

// ClearPoolID clears the value of the "pool_id" field.
func (evuo *EbsVolumeUpdateOne) ClearPoolID() *EbsVolumeUpdateOne {
	evuo.mutation.ClearPoolID()
	return evuo
}

// SetPoolName sets the "pool_name" field.
func (evuo *EbsVolumeUpdateOne) SetPoolName(s string) *EbsVolumeUpdateOne {
	evuo.mutation.SetPoolName(s)
	return evuo
}

// SetNillablePoolName sets the "pool_name" field if the given value is not nil.
func (evuo *EbsVolumeUpdateOne) SetNillablePoolName(s *string) *EbsVolumeUpdateOne {
	if s != nil {
		evuo.SetPoolName(*s)
	}
	return evuo
}

// ClearPoolName clears the value of the "pool_name" field.
func (evuo *EbsVolumeUpdateOne) ClearPoolName() *EbsVolumeUpdateOne {
	evuo.mutation.ClearPoolName()
	return evuo
}

// SetSize sets the "size" field.
func (evuo *EbsVolumeUpdateOne) SetSize(i int32) *EbsVolumeUpdateOne {
	evuo.mutation.ResetSize()
	evuo.mutation.SetSize(i)
	return evuo
}

// SetNillableSize sets the "size" field if the given value is not nil.
func (evuo *EbsVolumeUpdateOne) SetNillableSize(i *int32) *EbsVolumeUpdateOne {
	if i != nil {
		evuo.SetSize(*i)
	}
	return evuo
}

// AddSize adds i to the "size" field.
func (evuo *EbsVolumeUpdateOne) AddSize(i int32) *EbsVolumeUpdateOne {
	evuo.mutation.AddSize(i)
	return evuo
}

// ClearSize clears the value of the "size" field.
func (evuo *EbsVolumeUpdateOne) ClearSize() *EbsVolumeUpdateOne {
	evuo.mutation.ClearSize()
	return evuo
}

// SetStatus sets the "status" field.
func (evuo *EbsVolumeUpdateOne) SetStatus(s string) *EbsVolumeUpdateOne {
	evuo.mutation.SetStatus(s)
	return evuo
}

// SetNillableStatus sets the "status" field if the given value is not nil.
func (evuo *EbsVolumeUpdateOne) SetNillableStatus(s *string) *EbsVolumeUpdateOne {
	if s != nil {
		evuo.SetStatus(*s)
	}
	return evuo
}

// ClearStatus clears the value of the "status" field.
func (evuo *EbsVolumeUpdateOne) ClearStatus() *EbsVolumeUpdateOne {
	evuo.mutation.ClearStatus()
	return evuo
}

// SetStatusName sets the "status_name" field.
func (evuo *EbsVolumeUpdateOne) SetStatusName(s string) *EbsVolumeUpdateOne {
	evuo.mutation.SetStatusName(s)
	return evuo
}

// SetNillableStatusName sets the "status_name" field if the given value is not nil.
func (evuo *EbsVolumeUpdateOne) SetNillableStatusName(s *string) *EbsVolumeUpdateOne {
	if s != nil {
		evuo.SetStatusName(*s)
	}
	return evuo
}

// ClearStatusName clears the value of the "status_name" field.
func (evuo *EbsVolumeUpdateOne) ClearStatusName() *EbsVolumeUpdateOne {
	evuo.mutation.ClearStatusName()
	return evuo
}

// SetVolumeType sets the "volume_type" field.
func (evuo *EbsVolumeUpdateOne) SetVolumeType(s string) *EbsVolumeUpdateOne {
	evuo.mutation.SetVolumeType(s)
	return evuo
}

// SetNillableVolumeType sets the "volume_type" field if the given value is not nil.
func (evuo *EbsVolumeUpdateOne) SetNillableVolumeType(s *string) *EbsVolumeUpdateOne {
	if s != nil {
		evuo.SetVolumeType(*s)
	}
	return evuo
}

// ClearVolumeType clears the value of the "volume_type" field.
func (evuo *EbsVolumeUpdateOne) ClearVolumeType() *EbsVolumeUpdateOne {
	evuo.mutation.ClearVolumeType()
	return evuo
}

// SetVMID sets the "vm_id" field.
func (evuo *EbsVolumeUpdateOne) SetVMID(s string) *EbsVolumeUpdateOne {
	evuo.mutation.SetVMID(s)
	return evuo
}

// SetVMName sets the "vm_name" field.
func (evuo *EbsVolumeUpdateOne) SetVMName(s string) *EbsVolumeUpdateOne {
	evuo.mutation.SetVMName(s)
	return evuo
}

// SetTenantID sets the "tenant_id" field.
func (evuo *EbsVolumeUpdateOne) SetTenantID(s string) *EbsVolumeUpdateOne {
	evuo.mutation.SetTenantID(s)
	return evuo
}

// SetNillableTenantID sets the "tenant_id" field if the given value is not nil.
func (evuo *EbsVolumeUpdateOne) SetNillableTenantID(s *string) *EbsVolumeUpdateOne {
	if s != nil {
		evuo.SetTenantID(*s)
	}
	return evuo
}

// ClearTenantID clears the value of the "tenant_id" field.
func (evuo *EbsVolumeUpdateOne) ClearTenantID() *EbsVolumeUpdateOne {
	evuo.mutation.ClearTenantID()
	return evuo
}

// SetTenantName sets the "tenant_name" field.
func (evuo *EbsVolumeUpdateOne) SetTenantName(s string) *EbsVolumeUpdateOne {
	evuo.mutation.SetTenantName(s)
	return evuo
}

// SetNillableTenantName sets the "tenant_name" field if the given value is not nil.
func (evuo *EbsVolumeUpdateOne) SetNillableTenantName(s *string) *EbsVolumeUpdateOne {
	if s != nil {
		evuo.SetTenantName(*s)
	}
	return evuo
}

// ClearTenantName clears the value of the "tenant_name" field.
func (evuo *EbsVolumeUpdateOne) ClearTenantName() *EbsVolumeUpdateOne {
	evuo.mutation.ClearTenantName()
	return evuo
}

// SetProjectID sets the "project_id" field.
func (evuo *EbsVolumeUpdateOne) SetProjectID(s string) *EbsVolumeUpdateOne {
	evuo.mutation.SetProjectID(s)
	return evuo
}

// SetProjectName sets the "project_name" field.
func (evuo *EbsVolumeUpdateOne) SetProjectName(s string) *EbsVolumeUpdateOne {
	evuo.mutation.SetProjectName(s)
	return evuo
}

// SetCreateTime sets the "create_time" field.
func (evuo *EbsVolumeUpdateOne) SetCreateTime(t time.Time) *EbsVolumeUpdateOne {
	evuo.mutation.SetCreateTime(t)
	return evuo
}

// SetNillableCreateTime sets the "create_time" field if the given value is not nil.
func (evuo *EbsVolumeUpdateOne) SetNillableCreateTime(t *time.Time) *EbsVolumeUpdateOne {
	if t != nil {
		evuo.SetCreateTime(*t)
	}
	return evuo
}

// ClearCreateTime clears the value of the "create_time" field.
func (evuo *EbsVolumeUpdateOne) ClearCreateTime() *EbsVolumeUpdateOne {
	evuo.mutation.ClearCreateTime()
	return evuo
}

// SetServiceEndTime sets the "service_end_time" field.
func (evuo *EbsVolumeUpdateOne) SetServiceEndTime(t time.Time) *EbsVolumeUpdateOne {
	evuo.mutation.SetServiceEndTime(t)
	return evuo
}

// SetNillableServiceEndTime sets the "service_end_time" field if the given value is not nil.
func (evuo *EbsVolumeUpdateOne) SetNillableServiceEndTime(t *time.Time) *EbsVolumeUpdateOne {
	if t != nil {
		evuo.SetServiceEndTime(*t)
	}
	return evuo
}

// ClearServiceEndTime clears the value of the "service_end_time" field.
func (evuo *EbsVolumeUpdateOne) ClearServiceEndTime() *EbsVolumeUpdateOne {
	evuo.mutation.ClearServiceEndTime()
	return evuo
}

// SetDeleted sets the "deleted" field.
func (evuo *EbsVolumeUpdateOne) SetDeleted(b bool) *EbsVolumeUpdateOne {
	evuo.mutation.SetDeleted(b)
	return evuo
}

// SetNillableDeleted sets the "deleted" field if the given value is not nil.
func (evuo *EbsVolumeUpdateOne) SetNillableDeleted(b *bool) *EbsVolumeUpdateOne {
	if b != nil {
		evuo.SetDeleted(*b)
	}
	return evuo
}

// ClearDeleted clears the value of the "deleted" field.
func (evuo *EbsVolumeUpdateOne) ClearDeleted() *EbsVolumeUpdateOne {
	evuo.mutation.ClearDeleted()
	return evuo
}

// Mutation returns the EbsVolumeMutation object of the builder.
func (evuo *EbsVolumeUpdateOne) Mutation() *EbsVolumeMutation {
	return evuo.mutation
}

// Where appends a list predicates to the EbsVolumeUpdate builder.
func (evuo *EbsVolumeUpdateOne) Where(ps ...predicate.EbsVolume) *EbsVolumeUpdateOne {
	evuo.mutation.Where(ps...)
	return evuo
}

// Select allows selecting one or more fields (columns) of the returned entity.
// The default is selecting all fields defined in the entity schema.
func (evuo *EbsVolumeUpdateOne) Select(field string, fields ...string) *EbsVolumeUpdateOne {
	evuo.fields = append([]string{field}, fields...)
	return evuo
}

// Save executes the query and returns the updated EbsVolume entity.
func (evuo *EbsVolumeUpdateOne) Save(ctx context.Context) (*EbsVolume, error) {
	return withHooks[*EbsVolume, EbsVolumeMutation](ctx, evuo.sqlSave, evuo.mutation, evuo.hooks)
}

// SaveX is like Save, but panics if an error occurs.
func (evuo *EbsVolumeUpdateOne) SaveX(ctx context.Context) *EbsVolume {
	node, err := evuo.Save(ctx)
	if err != nil {
		panic(err)
	}
	return node
}

// Exec executes the query on the entity.
func (evuo *EbsVolumeUpdateOne) Exec(ctx context.Context) error {
	_, err := evuo.Save(ctx)
	return err
}

// ExecX is like Exec, but panics if an error occurs.
func (evuo *EbsVolumeUpdateOne) ExecX(ctx context.Context) {
	if err := evuo.Exec(ctx); err != nil {
		panic(err)
	}
}

func (evuo *EbsVolumeUpdateOne) sqlSave(ctx context.Context) (_node *EbsVolume, err error) {
	_spec := sqlgraph.NewUpdateSpec(ebsvolume.Table, ebsvolume.Columns, sqlgraph.NewFieldSpec(ebsvolume.FieldID, field.TypeInt))
	id, ok := evuo.mutation.ID()
	if !ok {
		return nil, &ValidationError{Name: "id", err: errors.New(`ent: missing "EbsVolume.id" for update`)}
	}
	_spec.Node.ID.Value = id
	if fields := evuo.fields; len(fields) > 0 {
		_spec.Node.Columns = make([]string, 0, len(fields))
		_spec.Node.Columns = append(_spec.Node.Columns, ebsvolume.FieldID)
		for _, f := range fields {
			if !ebsvolume.ValidColumn(f) {
				return nil, &ValidationError{Name: f, err: fmt.Errorf("ent: invalid field %q for query", f)}
			}
			if f != ebsvolume.FieldID {
				_spec.Node.Columns = append(_spec.Node.Columns, f)
			}
		}
	}
	if ps := evuo.mutation.predicates; len(ps) > 0 {
		_spec.Predicate = func(selector *sql.Selector) {
			for i := range ps {
				ps[i](selector)
			}
		}
	}
	if value, ok := evuo.mutation.Galaxy(); ok {
		_spec.SetField(ebsvolume.FieldGalaxy, field.TypeString, value)
	}
	if evuo.mutation.GalaxyCleared() {
		_spec.ClearField(ebsvolume.FieldGalaxy, field.TypeString)
	}
	if value, ok := evuo.mutation.Region(); ok {
		_spec.SetField(ebsvolume.FieldRegion, field.TypeString, value)
	}
	if value, ok := evuo.mutation.Az(); ok {
		_spec.SetField(ebsvolume.FieldAz, field.TypeString, value)
	}
	if evuo.mutation.AzCleared() {
		_spec.ClearField(ebsvolume.FieldAz, field.TypeString)
	}
	if value, ok := evuo.mutation.CreatedAt(); ok {
		_spec.SetField(ebsvolume.FieldCreatedAt, field.TypeTime, value)
	}
	if evuo.mutation.CreatedAtCleared() {
		_spec.ClearField(ebsvolume.FieldCreatedAt, field.TypeTime)
	}
	if value, ok := evuo.mutation.UpdatedAt(); ok {
		_spec.SetField(ebsvolume.FieldUpdatedAt, field.TypeTime, value)
	}
	if value, ok := evuo.mutation.Version(); ok {
		_spec.SetField(ebsvolume.FieldVersion, field.TypeString, value)
	}
	if evuo.mutation.VersionCleared() {
		_spec.ClearField(ebsvolume.FieldVersion, field.TypeString)
	}
	if value, ok := evuo.mutation.VolumeID(); ok {
		_spec.SetField(ebsvolume.FieldVolumeID, field.TypeString, value)
	}
	if evuo.mutation.VolumeIDCleared() {
		_spec.ClearField(ebsvolume.FieldVolumeID, field.TypeString)
	}
	if value, ok := evuo.mutation.Name(); ok {
		_spec.SetField(ebsvolume.FieldName, field.TypeString, value)
	}
	if value, ok := evuo.mutation.PoolID(); ok {
		_spec.SetField(ebsvolume.FieldPoolID, field.TypeString, value)
	}
	if evuo.mutation.PoolIDCleared() {
		_spec.ClearField(ebsvolume.FieldPoolID, field.TypeString)
	}
	if value, ok := evuo.mutation.PoolName(); ok {
		_spec.SetField(ebsvolume.FieldPoolName, field.TypeString, value)
	}
	if evuo.mutation.PoolNameCleared() {
		_spec.ClearField(ebsvolume.FieldPoolName, field.TypeString)
	}
	if value, ok := evuo.mutation.Size(); ok {
		_spec.SetField(ebsvolume.FieldSize, field.TypeInt32, value)
	}
	if value, ok := evuo.mutation.AddedSize(); ok {
		_spec.AddField(ebsvolume.FieldSize, field.TypeInt32, value)
	}
	if evuo.mutation.SizeCleared() {
		_spec.ClearField(ebsvolume.FieldSize, field.TypeInt32)
	}
	if value, ok := evuo.mutation.Status(); ok {
		_spec.SetField(ebsvolume.FieldStatus, field.TypeString, value)
	}
	if evuo.mutation.StatusCleared() {
		_spec.ClearField(ebsvolume.FieldStatus, field.TypeString)
	}
	if value, ok := evuo.mutation.StatusName(); ok {
		_spec.SetField(ebsvolume.FieldStatusName, field.TypeString, value)
	}
	if evuo.mutation.StatusNameCleared() {
		_spec.ClearField(ebsvolume.FieldStatusName, field.TypeString)
	}
	if value, ok := evuo.mutation.VolumeType(); ok {
		_spec.SetField(ebsvolume.FieldVolumeType, field.TypeString, value)
	}
	if evuo.mutation.VolumeTypeCleared() {
		_spec.ClearField(ebsvolume.FieldVolumeType, field.TypeString)
	}
	if value, ok := evuo.mutation.VMID(); ok {
		_spec.SetField(ebsvolume.FieldVMID, field.TypeString, value)
	}
	if value, ok := evuo.mutation.VMName(); ok {
		_spec.SetField(ebsvolume.FieldVMName, field.TypeString, value)
	}
	if value, ok := evuo.mutation.TenantID(); ok {
		_spec.SetField(ebsvolume.FieldTenantID, field.TypeString, value)
	}
	if evuo.mutation.TenantIDCleared() {
		_spec.ClearField(ebsvolume.FieldTenantID, field.TypeString)
	}
	if value, ok := evuo.mutation.TenantName(); ok {
		_spec.SetField(ebsvolume.FieldTenantName, field.TypeString, value)
	}
	if evuo.mutation.TenantNameCleared() {
		_spec.ClearField(ebsvolume.FieldTenantName, field.TypeString)
	}
	if value, ok := evuo.mutation.ProjectID(); ok {
		_spec.SetField(ebsvolume.FieldProjectID, field.TypeString, value)
	}
	if value, ok := evuo.mutation.ProjectName(); ok {
		_spec.SetField(ebsvolume.FieldProjectName, field.TypeString, value)
	}
	if value, ok := evuo.mutation.CreateTime(); ok {
		_spec.SetField(ebsvolume.FieldCreateTime, field.TypeTime, value)
	}
	if evuo.mutation.CreateTimeCleared() {
		_spec.ClearField(ebsvolume.FieldCreateTime, field.TypeTime)
	}
	if value, ok := evuo.mutation.ServiceEndTime(); ok {
		_spec.SetField(ebsvolume.FieldServiceEndTime, field.TypeTime, value)
	}
	if evuo.mutation.ServiceEndTimeCleared() {
		_spec.ClearField(ebsvolume.FieldServiceEndTime, field.TypeTime)
	}
	if value, ok := evuo.mutation.Deleted(); ok {
		_spec.SetField(ebsvolume.FieldDeleted, field.TypeBool, value)
	}
	if evuo.mutation.DeletedCleared() {
		_spec.ClearField(ebsvolume.FieldDeleted, field.TypeBool)
	}
	_node = &EbsVolume{config: evuo.config}
	_spec.Assign = _node.assignValues
	_spec.ScanValues = _node.scanValues
	if err = sqlgraph.UpdateNode(ctx, evuo.driver, _spec); err != nil {
		if _, ok := err.(*sqlgraph.NotFoundError); ok {
			err = &NotFoundError{ebsvolume.Label}
		} else if sqlgraph.IsConstraintError(err) {
			err = &ConstraintError{msg: err.Error(), wrap: err}
		}
		return nil, err
	}
	evuo.mutation.done = true
	return _node, nil
}

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/data/ent/objectstorage_update.go
```golang
// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"luban-cmdb-api/data/ent/objectstorage"
	"luban-cmdb-api/data/ent/predicate"
	"time"

	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
	"entgo.io/ent/schema/field"
)

// ObjectStorageUpdate is the builder for updating ObjectStorage entities.
type ObjectStorageUpdate struct {
	config
	hooks    []Hook
	mutation *ObjectStorageMutation
}

// Where appends a list predicates to the ObjectStorageUpdate builder.
func (osu *ObjectStorageUpdate) Where(ps ...predicate.ObjectStorage) *ObjectStorageUpdate {
	osu.mutation.Where(ps...)
	return osu
}

// SetName sets the "name" field.
func (osu *ObjectStorageUpdate) SetName(s string) *ObjectStorageUpdate {
	osu.mutation.SetName(s)
	return osu
}

// SetNillableName sets the "name" field if the given value is not nil.
func (osu *ObjectStorageUpdate) SetNillableName(s *string) *ObjectStorageUpdate {
	if s != nil {
		osu.SetName(*s)
	}
	return osu
}

// ClearName clears the value of the "name" field.
func (osu *ObjectStorageUpdate) ClearName() *ObjectStorageUpdate {
	osu.mutation.ClearName()
	return osu
}

// SetSize sets the "size" field.
func (osu *ObjectStorageUpdate) SetSize(i int) *ObjectStorageUpdate {
	osu.mutation.ResetSize()
	osu.mutation.SetSize(i)
	return osu
}

// SetNillableSize sets the "size" field if the given value is not nil.
func (osu *ObjectStorageUpdate) SetNillableSize(i *int) *ObjectStorageUpdate {
	if i != nil {
		osu.SetSize(*i)
	}
	return osu
}

// AddSize adds i to the "size" field.
func (osu *ObjectStorageUpdate) AddSize(i int) *ObjectStorageUpdate {
	osu.mutation.AddSize(i)
	return osu
}

// ClearSize clears the value of the "size" field.
func (osu *ObjectStorageUpdate) ClearSize() *ObjectStorageUpdate {
	osu.mutation.ClearSize()
	return osu
}

// SetStorageType sets the "storage_type" field.
func (osu *ObjectStorageUpdate) SetStorageType(s string) *ObjectStorageUpdate {
	osu.mutation.SetStorageType(s)
	return osu
}

// SetNillableStorageType sets the "storage_type" field if the given value is not nil.
func (osu *ObjectStorageUpdate) SetNillableStorageType(s *string) *ObjectStorageUpdate {
	if s != nil {
		osu.SetStorageType(*s)
	}
	return osu
}

// ClearStorageType clears the value of the "storage_type" field.
func (osu *ObjectStorageUpdate) ClearStorageType() *ObjectStorageUpdate {
	osu.mutation.ClearStorageType()
	return osu
}

// SetRegion sets the "region" field.
func (osu *ObjectStorageUpdate) SetRegion(s string) *ObjectStorageUpdate {
	osu.mutation.SetRegion(s)
	return osu
}

// SetNillableRegion sets the "region" field if the given value is not nil.
func (osu *ObjectStorageUpdate) SetNillableRegion(s *string) *ObjectStorageUpdate {
	if s != nil {
		osu.SetRegion(*s)
	}
	return osu
}

// ClearRegion clears the value of the "region" field.
func (osu *ObjectStorageUpdate) ClearRegion() *ObjectStorageUpdate {
	osu.mutation.ClearRegion()
	return osu
}

// SetRegionCode sets the "region_code" field.
func (osu *ObjectStorageUpdate) SetRegionCode(s string) *ObjectStorageUpdate {
	osu.mutation.SetRegionCode(s)
	return osu
}

// SetNillableRegionCode sets the "region_code" field if the given value is not nil.
func (osu *ObjectStorageUpdate) SetNillableRegionCode(s *string) *ObjectStorageUpdate {
	if s != nil {
		osu.SetRegionCode(*s)
	}
	return osu
}

// ClearRegionCode clears the value of the "region_code" field.
func (osu *ObjectStorageUpdate) ClearRegionCode() *ObjectStorageUpdate {
	osu.mutation.ClearRegionCode()
	return osu
}

// SetAz sets the "az" field.
func (osu *ObjectStorageUpdate) SetAz(s string) *ObjectStorageUpdate {
	osu.mutation.SetAz(s)
	return osu
}

// SetNillableAz sets the "az" field if the given value is not nil.
func (osu *ObjectStorageUpdate) SetNillableAz(s *string) *ObjectStorageUpdate {
	if s != nil {
		osu.SetAz(*s)
	}
	return osu
}

// ClearAz clears the value of the "az" field.
func (osu *ObjectStorageUpdate) ClearAz() *ObjectStorageUpdate {
	osu.mutation.ClearAz()
	return osu
}

// SetAzCode sets the "az_code" field.
func (osu *ObjectStorageUpdate) SetAzCode(s string) *ObjectStorageUpdate {
	osu.mutation.SetAzCode(s)
	return osu
}

// SetNillableAzCode sets the "az_code" field if the given value is not nil.
func (osu *ObjectStorageUpdate) SetNillableAzCode(s *string) *ObjectStorageUpdate {
	if s != nil {
		osu.SetAzCode(*s)
	}
	return osu
}

// ClearAzCode clears the value of the "az_code" field.
func (osu *ObjectStorageUpdate) ClearAzCode() *ObjectStorageUpdate {
	osu.mutation.ClearAzCode()
	return osu
}

// SetTenantID sets the "tenant_id" field.
func (osu *ObjectStorageUpdate) SetTenantID(s string) *ObjectStorageUpdate {
	osu.mutation.SetTenantID(s)
	return osu
}

// SetNillableTenantID sets the "tenant_id" field if the given value is not nil.
func (osu *ObjectStorageUpdate) SetNillableTenantID(s *string) *ObjectStorageUpdate {
	if s != nil {
		osu.SetTenantID(*s)
	}
	return osu
}

// ClearTenantID clears the value of the "tenant_id" field.
func (osu *ObjectStorageUpdate) ClearTenantID() *ObjectStorageUpdate {
	osu.mutation.ClearTenantID()
	return osu
}

// SetTenantName sets the "tenant_name" field.
func (osu *ObjectStorageUpdate) SetTenantName(s string) *ObjectStorageUpdate {
	osu.mutation.SetTenantName(s)
	return osu
}

// SetNillableTenantName sets the "tenant_name" field if the given value is not nil.
func (osu *ObjectStorageUpdate) SetNillableTenantName(s *string) *ObjectStorageUpdate {
	if s != nil {
		osu.SetTenantName(*s)
	}
	return osu
}

// ClearTenantName clears the value of the "tenant_name" field.
func (osu *ObjectStorageUpdate) ClearTenantName() *ObjectStorageUpdate {
	osu.mutation.ClearTenantName()
	return osu
}

// SetInnerDomainName sets the "inner_domain_name" field.
func (osu *ObjectStorageUpdate) SetInnerDomainName(s string) *ObjectStorageUpdate {
	osu.mutation.SetInnerDomainName(s)
	return osu
}

// SetNillableInnerDomainName sets the "inner_domain_name" field if the given value is not nil.
func (osu *ObjectStorageUpdate) SetNillableInnerDomainName(s *string) *ObjectStorageUpdate {
	if s != nil {
		osu.SetInnerDomainName(*s)
	}
	return osu
}

// ClearInnerDomainName clears the value of the "inner_domain_name" field.
func (osu *ObjectStorageUpdate) ClearInnerDomainName() *ObjectStorageUpdate {
	osu.mutation.ClearInnerDomainName()
	return osu
}

// SetOuterDomainName sets the "outer_domain_name" field.
func (osu *ObjectStorageUpdate) SetOuterDomainName(s string) *ObjectStorageUpdate {
	osu.mutation.SetOuterDomainName(s)
	return osu
}

// SetNillableOuterDomainName sets the "outer_domain_name" field if the given value is not nil.
func (osu *ObjectStorageUpdate) SetNillableOuterDomainName(s *string) *ObjectStorageUpdate {
	if s != nil {
		osu.SetOuterDomainName(*s)
	}
	return osu
}

// ClearOuterDomainName clears the value of the "outer_domain_name" field.
func (osu *ObjectStorageUpdate) ClearOuterDomainName() *ObjectStorageUpdate {
	osu.mutation.ClearOuterDomainName()
	return osu
}

// SetCreateTime sets the "create_time" field.
func (osu *ObjectStorageUpdate) SetCreateTime(i int) *ObjectStorageUpdate {
	osu.mutation.ResetCreateTime()
	osu.mutation.SetCreateTime(i)
	return osu
}

// SetNillableCreateTime sets the "create_time" field if the given value is not nil.
func (osu *ObjectStorageUpdate) SetNillableCreateTime(i *int) *ObjectStorageUpdate {
	if i != nil {
		osu.SetCreateTime(*i)
	}
	return osu
}

// AddCreateTime adds i to the "create_time" field.
func (osu *ObjectStorageUpdate) AddCreateTime(i int) *ObjectStorageUpdate {
	osu.mutation.AddCreateTime(i)
	return osu
}

// ClearCreateTime clears the value of the "create_time" field.
func (osu *ObjectStorageUpdate) ClearCreateTime() *ObjectStorageUpdate {
	osu.mutation.ClearCreateTime()
	return osu
}

// SetPolicy sets the "policy" field.
func (osu *ObjectStorageUpdate) SetPolicy(s string) *ObjectStorageUpdate {
	osu.mutation.SetPolicy(s)
	return osu
}

// SetNillablePolicy sets the "policy" field if the given value is not nil.
func (osu *ObjectStorageUpdate) SetNillablePolicy(s *string) *ObjectStorageUpdate {
	if s != nil {
		osu.SetPolicy(*s)
	}
	return osu
}

// ClearPolicy clears the value of the "policy" field.
func (osu *ObjectStorageUpdate) ClearPolicy() *ObjectStorageUpdate {
	osu.mutation.ClearPolicy()
	return osu
}

// SetBucketDomains sets the "bucket_domains" field.
func (osu *ObjectStorageUpdate) SetBucketDomains(s string) *ObjectStorageUpdate {
	osu.mutation.SetBucketDomains(s)
	return osu
}

// SetNillableBucketDomains sets the "bucket_domains" field if the given value is not nil.
func (osu *ObjectStorageUpdate) SetNillableBucketDomains(s *string) *ObjectStorageUpdate {
	if s != nil {
		osu.SetBucketDomains(*s)
	}
	return osu
}

// ClearBucketDomains clears the value of the "bucket_domains" field.
func (osu *ObjectStorageUpdate) ClearBucketDomains() *ObjectStorageUpdate {
	osu.mutation.ClearBucketDomains()
	return osu
}

// SetResourcePoolID sets the "resource_pool_id" field.
func (osu *ObjectStorageUpdate) SetResourcePoolID(i int) *ObjectStorageUpdate {
	osu.mutation.ResetResourcePoolID()
	osu.mutation.SetResourcePoolID(i)
	return osu
}

// SetNillableResourcePoolID sets the "resource_pool_id" field if the given value is not nil.
func (osu *ObjectStorageUpdate) SetNillableResourcePoolID(i *int) *ObjectStorageUpdate {
	if i != nil {
		osu.SetResourcePoolID(*i)
	}
	return osu
}

// AddResourcePoolID adds i to the "resource_pool_id" field.
func (osu *ObjectStorageUpdate) AddResourcePoolID(i int) *ObjectStorageUpdate {
	osu.mutation.AddResourcePoolID(i)
	return osu
}

// ClearResourcePoolID clears the value of the "resource_pool_id" field.
func (osu *ObjectStorageUpdate) ClearResourcePoolID() *ObjectStorageUpdate {
	osu.mutation.ClearResourcePoolID()
	return osu
}

// SetResourcePoolName sets the "resource_pool_name" field.
func (osu *ObjectStorageUpdate) SetResourcePoolName(s string) *ObjectStorageUpdate {
	osu.mutation.SetResourcePoolName(s)
	return osu
}

// SetNillableResourcePoolName sets the "resource_pool_name" field if the given value is not nil.
func (osu *ObjectStorageUpdate) SetNillableResourcePoolName(s *string) *ObjectStorageUpdate {
	if s != nil {
		osu.SetResourcePoolName(*s)
	}
	return osu
}

// ClearResourcePoolName clears the value of the "resource_pool_name" field.
func (osu *ObjectStorageUpdate) ClearResourcePoolName() *ObjectStorageUpdate {
	osu.mutation.ClearResourcePoolName()
	return osu
}

// SetObjectCount sets the "object_count" field.
func (osu *ObjectStorageUpdate) SetObjectCount(i int) *ObjectStorageUpdate {
	osu.mutation.ResetObjectCount()
	osu.mutation.SetObjectCount(i)
	return osu
}

// SetNillableObjectCount sets the "object_count" field if the given value is not nil.
func (osu *ObjectStorageUpdate) SetNillableObjectCount(i *int) *ObjectStorageUpdate {
	if i != nil {
		osu.SetObjectCount(*i)
	}
	return osu
}

// AddObjectCount adds i to the "object_count" field.
func (osu *ObjectStorageUpdate) AddObjectCount(i int) *ObjectStorageUpdate {
	osu.mutation.AddObjectCount(i)
	return osu
}

// ClearObjectCount clears the value of the "object_count" field.
func (osu *ObjectStorageUpdate) ClearObjectCount() *ObjectStorageUpdate {
	osu.mutation.ClearObjectCount()
	return osu
}

// SetCurrentSize sets the "current_size" field.
func (osu *ObjectStorageUpdate) SetCurrentSize(i int) *ObjectStorageUpdate {
	osu.mutation.ResetCurrentSize()
	osu.mutation.SetCurrentSize(i)
	return osu
}

// SetNillableCurrentSize sets the "current_size" field if the given value is not nil.
func (osu *ObjectStorageUpdate) SetNillableCurrentSize(i *int) *ObjectStorageUpdate {
	if i != nil {
		osu.SetCurrentSize(*i)
	}
	return osu
}

// AddCurrentSize adds i to the "current_size" field.
func (osu *ObjectStorageUpdate) AddCurrentSize(i int) *ObjectStorageUpdate {
	osu.mutation.AddCurrentSize(i)
	return osu
}

// ClearCurrentSize clears the value of the "current_size" field.
func (osu *ObjectStorageUpdate) ClearCurrentSize() *ObjectStorageUpdate {
	osu.mutation.ClearCurrentSize()
	return osu
}

// SetLast30DayDownload sets the "last30_day_download" field.
func (osu *ObjectStorageUpdate) SetLast30DayDownload(i int) *ObjectStorageUpdate {
	osu.mutation.ResetLast30DayDownload()
	osu.mutation.SetLast30DayDownload(i)
	return osu
}

// SetNillableLast30DayDownload sets the "last30_day_download" field if the given value is not nil.
func (osu *ObjectStorageUpdate) SetNillableLast30DayDownload(i *int) *ObjectStorageUpdate {
	if i != nil {
		osu.SetLast30DayDownload(*i)
	}
	return osu
}

// AddLast30DayDownload adds i to the "last30_day_download" field.
func (osu *ObjectStorageUpdate) AddLast30DayDownload(i int) *ObjectStorageUpdate {
	osu.mutation.AddLast30DayDownload(i)
	return osu
}

// ClearLast30DayDownload clears the value of the "last30_day_download" field.
func (osu *ObjectStorageUpdate) ClearLast30DayDownload() *ObjectStorageUpdate {
	osu.mutation.ClearLast30DayDownload()
	return osu
}

// SetLast30DayAPICallTimes sets the "last30_day_api_call_times" field.
func (osu *ObjectStorageUpdate) SetLast30DayAPICallTimes(i int) *ObjectStorageUpdate {
	osu.mutation.ResetLast30DayAPICallTimes()
	osu.mutation.SetLast30DayAPICallTimes(i)
	return osu
}

// SetNillableLast30DayAPICallTimes sets the "last30_day_api_call_times" field if the given value is not nil.
func (osu *ObjectStorageUpdate) SetNillableLast30DayAPICallTimes(i *int) *ObjectStorageUpdate {
	if i != nil {
		osu.SetLast30DayAPICallTimes(*i)
	}
	return osu
}

// AddLast30DayAPICallTimes adds i to the "last30_day_api_call_times" field.
func (osu *ObjectStorageUpdate) AddLast30DayAPICallTimes(i int) *ObjectStorageUpdate {
	osu.mutation.AddLast30DayAPICallTimes(i)
	return osu
}

// ClearLast30DayAPICallTimes clears the value of the "last30_day_api_call_times" field.
func (osu *ObjectStorageUpdate) ClearLast30DayAPICallTimes() *ObjectStorageUpdate {
	osu.mutation.ClearLast30DayAPICallTimes()
	return osu
}

// SetLastUpdateTime sets the "last_update_time" field.
func (osu *ObjectStorageUpdate) SetLastUpdateTime(t time.Time) *ObjectStorageUpdate {
	osu.mutation.SetLastUpdateTime(t)
	return osu
}

// Mutation returns the ObjectStorageMutation object of the builder.
func (osu *ObjectStorageUpdate) Mutation() *ObjectStorageMutation {
	return osu.mutation
}

// Save executes the query and returns the number of nodes affected by the update operation.
func (osu *ObjectStorageUpdate) Save(ctx context.Context) (int, error) {
	return withHooks[int, ObjectStorageMutation](ctx, osu.sqlSave, osu.mutation, osu.hooks)
}

// SaveX is like Save, but panics if an error occurs.
func (osu *ObjectStorageUpdate) SaveX(ctx context.Context) int {
	affected, err := osu.Save(ctx)
	if err != nil {
		panic(err)
	}
	return affected
}

// Exec executes the query.
func (osu *ObjectStorageUpdate) Exec(ctx context.Context) error {
	_, err := osu.Save(ctx)
	return err
}

// ExecX is like Exec, but panics if an error occurs.
func (osu *ObjectStorageUpdate) ExecX(ctx context.Context) {
	if err := osu.Exec(ctx); err != nil {
		panic(err)
	}
}

func (osu *ObjectStorageUpdate) sqlSave(ctx context.Context) (n int, err error) {
	_spec := sqlgraph.NewUpdateSpec(objectstorage.Table, objectstorage.Columns, sqlgraph.NewFieldSpec(objectstorage.FieldID, field.TypeString))
	if ps := osu.mutation.predicates; len(ps) > 0 {
		_spec.Predicate = func(selector *sql.Selector) {
			for i := range ps {
				ps[i](selector)
			}
		}
	}
	if value, ok := osu.mutation.Name(); ok {
		_spec.SetField(objectstorage.FieldName, field.TypeString, value)
	}
	if osu.mutation.NameCleared() {
		_spec.ClearField(objectstorage.FieldName, field.TypeString)
	}
	if value, ok := osu.mutation.Size(); ok {
		_spec.SetField(objectstorage.FieldSize, field.TypeInt, value)
	}
	if value, ok := osu.mutation.AddedSize(); ok {
		_spec.AddField(objectstorage.FieldSize, field.TypeInt, value)
	}
	if osu.mutation.SizeCleared() {
		_spec.ClearField(objectstorage.FieldSize, field.TypeInt)
	}
	if value, ok := osu.mutation.StorageType(); ok {
		_spec.SetField(objectstorage.FieldStorageType, field.TypeString, value)
	}
	if osu.mutation.StorageTypeCleared() {
		_spec.ClearField(objectstorage.FieldStorageType, field.TypeString)
	}
	if value, ok := osu.mutation.Region(); ok {
		_spec.SetField(objectstorage.FieldRegion, field.TypeString, value)
	}
	if osu.mutation.RegionCleared() {
		_spec.ClearField(objectstorage.FieldRegion, field.TypeString)
	}
	if value, ok := osu.mutation.RegionCode(); ok {
		_spec.SetField(objectstorage.FieldRegionCode, field.TypeString, value)
	}
	if osu.mutation.RegionCodeCleared() {
		_spec.ClearField(objectstorage.FieldRegionCode, field.TypeString)
	}
	if value, ok := osu.mutation.Az(); ok {
		_spec.SetField(objectstorage.FieldAz, field.TypeString, value)
	}
	if osu.mutation.AzCleared() {
		_spec.ClearField(objectstorage.FieldAz, field.TypeString)
	}
	if value, ok := osu.mutation.AzCode(); ok {
		_spec.SetField(objectstorage.FieldAzCode, field.TypeString, value)
	}
	if osu.mutation.AzCodeCleared() {
		_spec.ClearField(objectstorage.FieldAzCode, field.TypeString)
	}
	if value, ok := osu.mutation.TenantID(); ok {
		_spec.SetField(objectstorage.FieldTenantID, field.TypeString, value)
	}
	if osu.mutation.TenantIDCleared() {
		_spec.ClearField(objectstorage.FieldTenantID, field.TypeString)
	}
	if value, ok := osu.mutation.TenantName(); ok {
		_spec.SetField(objectstorage.FieldTenantName, field.TypeString, value)
	}
	if osu.mutation.TenantNameCleared() {
		_spec.ClearField(objectstorage.FieldTenantName, field.TypeString)
	}
	if value, ok := osu.mutation.InnerDomainName(); ok {
		_spec.SetField(objectstorage.FieldInnerDomainName, field.TypeString, value)
	}
	if osu.mutation.InnerDomainNameCleared() {
		_spec.ClearField(objectstorage.FieldInnerDomainName, field.TypeString)
	}
	if value, ok := osu.mutation.OuterDomainName(); ok {
		_spec.SetField(objectstorage.FieldOuterDomainName, field.TypeString, value)
	}
	if osu.mutation.OuterDomainNameCleared() {
		_spec.ClearField(objectstorage.FieldOuterDomainName, field.TypeString)
	}
	if value, ok := osu.mutation.CreateTime(); ok {
		_spec.SetField(objectstorage.FieldCreateTime, field.TypeInt, value)
	}
	if value, ok := osu.mutation.AddedCreateTime(); ok {
		_spec.AddField(objectstorage.FieldCreateTime, field.TypeInt, value)
	}
	if osu.mutation.CreateTimeCleared() {
		_spec.ClearField(objectstorage.FieldCreateTime, field.TypeInt)
	}
	if value, ok := osu.mutation.Policy(); ok {
		_spec.SetField(objectstorage.FieldPolicy, field.TypeString, value)
	}
	if osu.mutation.PolicyCleared() {
		_spec.ClearField(objectstorage.FieldPolicy, field.TypeString)
	}
	if value, ok := osu.mutation.BucketDomains(); ok {
		_spec.SetField(objectstorage.FieldBucketDomains, field.TypeString, value)
	}
	if osu.mutation.BucketDomainsCleared() {
		_spec.ClearField(objectstorage.FieldBucketDomains, field.TypeString)
	}
	if value, ok := osu.mutation.ResourcePoolID(); ok {
		_spec.SetField(objectstorage.FieldResourcePoolID, field.TypeInt, value)
	}
	if value, ok := osu.mutation.AddedResourcePoolID(); ok {
		_spec.AddField(objectstorage.FieldResourcePoolID, field.TypeInt, value)
	}
	if osu.mutation.ResourcePoolIDCleared() {
		_spec.ClearField(objectstorage.FieldResourcePoolID, field.TypeInt)
	}
	if value, ok := osu.mutation.ResourcePoolName(); ok {
		_spec.SetField(objectstorage.FieldResourcePoolName, field.TypeString, value)
	}
	if osu.mutation.ResourcePoolNameCleared() {
		_spec.ClearField(objectstorage.FieldResourcePoolName, field.TypeString)
	}
	if value, ok := osu.mutation.ObjectCount(); ok {
		_spec.SetField(objectstorage.FieldObjectCount, field.TypeInt, value)
	}
	if value, ok := osu.mutation.AddedObjectCount(); ok {
		_spec.AddField(objectstorage.FieldObjectCount, field.TypeInt, value)
	}
	if osu.mutation.ObjectCountCleared() {
		_spec.ClearField(objectstorage.FieldObjectCount, field.TypeInt)
	}
	if value, ok := osu.mutation.CurrentSize(); ok {
		_spec.SetField(objectstorage.FieldCurrentSize, field.TypeInt, value)
	}
	if value, ok := osu.mutation.AddedCurrentSize(); ok {
		_spec.AddField(objectstorage.FieldCurrentSize, field.TypeInt, value)
	}
	if osu.mutation.CurrentSizeCleared() {
		_spec.ClearField(objectstorage.FieldCurrentSize, field.TypeInt)
	}
	if value, ok := osu.mutation.Last30DayDownload(); ok {
		_spec.SetField(objectstorage.FieldLast30DayDownload, field.TypeInt, value)
	}
	if value, ok := osu.mutation.AddedLast30DayDownload(); ok {
		_spec.AddField(objectstorage.FieldLast30DayDownload, field.TypeInt, value)
	}
	if osu.mutation.Last30DayDownloadCleared() {
		_spec.ClearField(objectstorage.FieldLast30DayDownload, field.TypeInt)
	}
	if value, ok := osu.mutation.Last30DayAPICallTimes(); ok {
		_spec.SetField(objectstorage.FieldLast30DayAPICallTimes, field.TypeInt, value)
	}
	if value, ok := osu.mutation.AddedLast30DayAPICallTimes(); ok {
		_spec.AddField(objectstorage.FieldLast30DayAPICallTimes, field.TypeInt, value)
	}
	if osu.mutation.Last30DayAPICallTimesCleared() {
		_spec.ClearField(objectstorage.FieldLast30DayAPICallTimes, field.TypeInt)
	}
	if value, ok := osu.mutation.LastUpdateTime(); ok {
		_spec.SetField(objectstorage.FieldLastUpdateTime, field.TypeTime, value)
	}
	if n, err = sqlgraph.UpdateNodes(ctx, osu.driver, _spec); err != nil {
		if _, ok := err.(*sqlgraph.NotFoundError); ok {
			err = &NotFoundError{objectstorage.Label}
		} else if sqlgraph.IsConstraintError(err) {
			err = &ConstraintError{msg: err.Error(), wrap: err}
		}
		return 0, err
	}
	osu.mutation.done = true
	return n, nil
}

// ObjectStorageUpdateOne is the builder for updating a single ObjectStorage entity.
type ObjectStorageUpdateOne struct {
	config
	fields   []string
	hooks    []Hook
	mutation *ObjectStorageMutation
}

// SetName sets the "name" field.
func (osuo *ObjectStorageUpdateOne) SetName(s string) *ObjectStorageUpdateOne {
	osuo.mutation.SetName(s)
	return osuo
}

// SetNillableName sets the "name" field if the given value is not nil.
func (osuo *ObjectStorageUpdateOne) SetNillableName(s *string) *ObjectStorageUpdateOne {
	if s != nil {
		osuo.SetName(*s)
	}
	return osuo
}

// ClearName clears the value of the "name" field.
func (osuo *ObjectStorageUpdateOne) ClearName() *ObjectStorageUpdateOne {
	osuo.mutation.ClearName()
	return osuo
}

// SetSize sets the "size" field.
func (osuo *ObjectStorageUpdateOne) SetSize(i int) *ObjectStorageUpdateOne {
	osuo.mutation.ResetSize()
	osuo.mutation.SetSize(i)
	return osuo
}

// SetNillableSize sets the "size" field if the given value is not nil.
func (osuo *ObjectStorageUpdateOne) SetNillableSize(i *int) *ObjectStorageUpdateOne {
	if i != nil {
		osuo.SetSize(*i)
	}
	return osuo
}

// AddSize adds i to the "size" field.
func (osuo *ObjectStorageUpdateOne) AddSize(i int) *ObjectStorageUpdateOne {
	osuo.mutation.AddSize(i)
	return osuo
}

// ClearSize clears the value of the "size" field.
func (osuo *ObjectStorageUpdateOne) ClearSize() *ObjectStorageUpdateOne {
	osuo.mutation.ClearSize()
	return osuo
}

// SetStorageType sets the "storage_type" field.
func (osuo *ObjectStorageUpdateOne) SetStorageType(s string) *ObjectStorageUpdateOne {
	osuo.mutation.SetStorageType(s)
	return osuo
}

// SetNillableStorageType sets the "storage_type" field if the given value is not nil.
func (osuo *ObjectStorageUpdateOne) SetNillableStorageType(s *string) *ObjectStorageUpdateOne {
	if s != nil {
		osuo.SetStorageType(*s)
	}
	return osuo
}

// ClearStorageType clears the value of the "storage_type" field.
func (osuo *ObjectStorageUpdateOne) ClearStorageType() *ObjectStorageUpdateOne {
	osuo.mutation.ClearStorageType()
	return osuo
}

// SetRegion sets the "region" field.
func (osuo *ObjectStorageUpdateOne) SetRegion(s string) *ObjectStorageUpdateOne {
	osuo.mutation.SetRegion(s)
	return osuo
}

// SetNillableRegion sets the "region" field if the given value is not nil.
func (osuo *ObjectStorageUpdateOne) SetNillableRegion(s *string) *ObjectStorageUpdateOne {
	if s != nil {
		osuo.SetRegion(*s)
	}
	return osuo
}

// ClearRegion clears the value of the "region" field.
func (osuo *ObjectStorageUpdateOne) ClearRegion() *ObjectStorageUpdateOne {
	osuo.mutation.ClearRegion()
	return osuo
}

// SetRegionCode sets the "region_code" field.
func (osuo *ObjectStorageUpdateOne) SetRegionCode(s string) *ObjectStorageUpdateOne {
	osuo.mutation.SetRegionCode(s)
	return osuo
}

// SetNillableRegionCode sets the "region_code" field if the given value is not nil.
func (osuo *ObjectStorageUpdateOne) SetNillableRegionCode(s *string) *ObjectStorageUpdateOne {
	if s != nil {
		osuo.SetRegionCode(*s)
	}
	return osuo
}

// ClearRegionCode clears the value of the "region_code" field.
func (osuo *ObjectStorageUpdateOne) ClearRegionCode() *ObjectStorageUpdateOne {
	osuo.mutation.ClearRegionCode()
	return osuo
}

// SetAz sets the "az" field.
func (osuo *ObjectStorageUpdateOne) SetAz(s string) *ObjectStorageUpdateOne {
	osuo.mutation.SetAz(s)
	return osuo
}

// SetNillableAz sets the "az" field if the given value is not nil.
func (osuo *ObjectStorageUpdateOne) SetNillableAz(s *string) *ObjectStorageUpdateOne {
	if s != nil {
		osuo.SetAz(*s)
	}
	return osuo
}

// ClearAz clears the value of the "az" field.
func (osuo *ObjectStorageUpdateOne) ClearAz() *ObjectStorageUpdateOne {
	osuo.mutation.ClearAz()
	return osuo
}

// SetAzCode sets the "az_code" field.
func (osuo *ObjectStorageUpdateOne) SetAzCode(s string) *ObjectStorageUpdateOne {
	osuo.mutation.SetAzCode(s)
	return osuo
}

// SetNillableAzCode sets the "az_code" field if the given value is not nil.
func (osuo *ObjectStorageUpdateOne) SetNillableAzCode(s *string) *ObjectStorageUpdateOne {
	if s != nil {
		osuo.SetAzCode(*s)
	}
	return osuo
}

// ClearAzCode clears the value of the "az_code" field.
func (osuo *ObjectStorageUpdateOne) ClearAzCode() *ObjectStorageUpdateOne {
	osuo.mutation.ClearAzCode()
	return osuo
}

// SetTenantID sets the "tenant_id" field.
func (osuo *ObjectStorageUpdateOne) SetTenantID(s string) *ObjectStorageUpdateOne {
	osuo.mutation.SetTenantID(s)
	return osuo
}

// SetNillableTenantID sets the "tenant_id" field if the given value is not nil.
func (osuo *ObjectStorageUpdateOne) SetNillableTenantID(s *string) *ObjectStorageUpdateOne {
	if s != nil {
		osuo.SetTenantID(*s)
	}
	return osuo
}

// ClearTenantID clears the value of the "tenant_id" field.
func (osuo *ObjectStorageUpdateOne) ClearTenantID() *ObjectStorageUpdateOne {
	osuo.mutation.ClearTenantID()
	return osuo
}

// SetTenantName sets the "tenant_name" field.
func (osuo *ObjectStorageUpdateOne) SetTenantName(s string) *ObjectStorageUpdateOne {
	osuo.mutation.SetTenantName(s)
	return osuo
}

// SetNillableTenantName sets the "tenant_name" field if the given value is not nil.
func (osuo *ObjectStorageUpdateOne) SetNillableTenantName(s *string) *ObjectStorageUpdateOne {
	if s != nil {
		osuo.SetTenantName(*s)
	}
	return osuo
}

// ClearTenantName clears the value of the "tenant_name" field.
func (osuo *ObjectStorageUpdateOne) ClearTenantName() *ObjectStorageUpdateOne {
	osuo.mutation.ClearTenantName()
	return osuo
}

// SetInnerDomainName sets the "inner_domain_name" field.
func (osuo *ObjectStorageUpdateOne) SetInnerDomainName(s string) *ObjectStorageUpdateOne {
	osuo.mutation.SetInnerDomainName(s)
	return osuo
}

// SetNillableInnerDomainName sets the "inner_domain_name" field if the given value is not nil.
func (osuo *ObjectStorageUpdateOne) SetNillableInnerDomainName(s *string) *ObjectStorageUpdateOne {
	if s != nil {
		osuo.SetInnerDomainName(*s)
	}
	return osuo
}

// ClearInnerDomainName clears the value of the "inner_domain_name" field.
func (osuo *ObjectStorageUpdateOne) ClearInnerDomainName() *ObjectStorageUpdateOne {
	osuo.mutation.ClearInnerDomainName()
	return osuo
}

// SetOuterDomainName sets the "outer_domain_name" field.
func (osuo *ObjectStorageUpdateOne) SetOuterDomainName(s string) *ObjectStorageUpdateOne {
	osuo.mutation.SetOuterDomainName(s)
	return osuo
}

// SetNillableOuterDomainName sets the "outer_domain_name" field if the given value is not nil.
func (osuo *ObjectStorageUpdateOne) SetNillableOuterDomainName(s *string) *ObjectStorageUpdateOne {
	if s != nil {
		osuo.SetOuterDomainName(*s)
	}
	return osuo
}

// ClearOuterDomainName clears the value of the "outer_domain_name" field.
func (osuo *ObjectStorageUpdateOne) ClearOuterDomainName() *ObjectStorageUpdateOne {
	osuo.mutation.ClearOuterDomainName()
	return osuo
}

// SetCreateTime sets the "create_time" field.
func (osuo *ObjectStorageUpdateOne) SetCreateTime(i int) *ObjectStorageUpdateOne {
	osuo.mutation.ResetCreateTime()
	osuo.mutation.SetCreateTime(i)
	return osuo
}

// SetNillableCreateTime sets the "create_time" field if the given value is not nil.
func (osuo *ObjectStorageUpdateOne) SetNillableCreateTime(i *int) *ObjectStorageUpdateOne {
	if i != nil {
		osuo.SetCreateTime(*i)
	}
	return osuo
}

// AddCreateTime adds i to the "create_time" field.
func (osuo *ObjectStorageUpdateOne) AddCreateTime(i int) *ObjectStorageUpdateOne {
	osuo.mutation.AddCreateTime(i)
	return osuo
}

// ClearCreateTime clears the value of the "create_time" field.
func (osuo *ObjectStorageUpdateOne) ClearCreateTime() *ObjectStorageUpdateOne {
	osuo.mutation.ClearCreateTime()
	return osuo
}

// SetPolicy sets the "policy" field.
func (osuo *ObjectStorageUpdateOne) SetPolicy(s string) *ObjectStorageUpdateOne {
	osuo.mutation.SetPolicy(s)
	return osuo
}

// SetNillablePolicy sets the "policy" field if the given value is not nil.
func (osuo *ObjectStorageUpdateOne) SetNillablePolicy(s *string) *ObjectStorageUpdateOne {
	if s != nil {
		osuo.SetPolicy(*s)
	}
	return osuo
}

// ClearPolicy clears the value of the "policy" field.
func (osuo *ObjectStorageUpdateOne) ClearPolicy() *ObjectStorageUpdateOne {
	osuo.mutation.ClearPolicy()
	return osuo
}

// SetBucketDomains sets the "bucket_domains" field.
func (osuo *ObjectStorageUpdateOne) SetBucketDomains(s string) *ObjectStorageUpdateOne {
	osuo.mutation.SetBucketDomains(s)
	return osuo
}

// SetNillableBucketDomains sets the "bucket_domains" field if the given value is not nil.
func (osuo *ObjectStorageUpdateOne) SetNillableBucketDomains(s *string) *ObjectStorageUpdateOne {
	if s != nil {
		osuo.SetBucketDomains(*s)
	}
	return osuo
}

// ClearBucketDomains clears the value of the "bucket_domains" field.
func (osuo *ObjectStorageUpdateOne) ClearBucketDomains() *ObjectStorageUpdateOne {
	osuo.mutation.ClearBucketDomains()
	return osuo
}

// SetResourcePoolID sets the "resource_pool_id" field.
func (osuo *ObjectStorageUpdateOne) SetResourcePoolID(i int) *ObjectStorageUpdateOne {
	osuo.mutation.ResetResourcePoolID()
	osuo.mutation.SetResourcePoolID(i)
	return osuo
}

// SetNillableResourcePoolID sets the "resource_pool_id" field if the given value is not nil.
func (osuo *ObjectStorageUpdateOne) SetNillableResourcePoolID(i *int) *ObjectStorageUpdateOne {
	if i != nil {
		osuo.SetResourcePoolID(*i)
	}
	return osuo
}

// AddResourcePoolID adds i to the "resource_pool_id" field.
func (osuo *ObjectStorageUpdateOne) AddResourcePoolID(i int) *ObjectStorageUpdateOne {
	osuo.mutation.AddResourcePoolID(i)
	return osuo
}

// ClearResourcePoolID clears the value of the "resource_pool_id" field.
func (osuo *ObjectStorageUpdateOne) ClearResourcePoolID() *ObjectStorageUpdateOne {
	osuo.mutation.ClearResourcePoolID()
	return osuo
}

// SetResourcePoolName sets the "resource_pool_name" field.
func (osuo *ObjectStorageUpdateOne) SetResourcePoolName(s string) *ObjectStorageUpdateOne {
	osuo.mutation.SetResourcePoolName(s)
	return osuo
}

// SetNillableResourcePoolName sets the "resource_pool_name" field if the given value is not nil.
func (osuo *ObjectStorageUpdateOne) SetNillableResourcePoolName(s *string) *ObjectStorageUpdateOne {
	if s != nil {
		osuo.SetResourcePoolName(*s)
	}
	return osuo
}

// ClearResourcePoolName clears the value of the "resource_pool_name" field.
func (osuo *ObjectStorageUpdateOne) ClearResourcePoolName() *ObjectStorageUpdateOne {
	osuo.mutation.ClearResourcePoolName()
	return osuo
}

// SetObjectCount sets the "object_count" field.
func (osuo *ObjectStorageUpdateOne) SetObjectCount(i int) *ObjectStorageUpdateOne {
	osuo.mutation.ResetObjectCount()
	osuo.mutation.SetObjectCount(i)
	return osuo
}

// SetNillableObjectCount sets the "object_count" field if the given value is not nil.
func (osuo *ObjectStorageUpdateOne) SetNillableObjectCount(i *int) *ObjectStorageUpdateOne {
	if i != nil {
		osuo.SetObjectCount(*i)
	}
	return osuo
}

// AddObjectCount adds i to the "object_count" field.
func (osuo *ObjectStorageUpdateOne) AddObjectCount(i int) *ObjectStorageUpdateOne {
	osuo.mutation.AddObjectCount(i)
	return osuo
}

// ClearObjectCount clears the value of the "object_count" field.
func (osuo *ObjectStorageUpdateOne) ClearObjectCount() *ObjectStorageUpdateOne {
	osuo.mutation.ClearObjectCount()
	return osuo
}

// SetCurrentSize sets the "current_size" field.
func (osuo *ObjectStorageUpdateOne) SetCurrentSize(i int) *ObjectStorageUpdateOne {
	osuo.mutation.ResetCurrentSize()
	osuo.mutation.SetCurrentSize(i)
	return osuo
}

// SetNillableCurrentSize sets the "current_size" field if the given value is not nil.
func (osuo *ObjectStorageUpdateOne) SetNillableCurrentSize(i *int) *ObjectStorageUpdateOne {
	if i != nil {
		osuo.SetCurrentSize(*i)
	}
	return osuo
}

// AddCurrentSize adds i to the "current_size" field.
func (osuo *ObjectStorageUpdateOne) AddCurrentSize(i int) *ObjectStorageUpdateOne {
	osuo.mutation.AddCurrentSize(i)
	return osuo
}

// ClearCurrentSize clears the value of the "current_size" field.
func (osuo *ObjectStorageUpdateOne) ClearCurrentSize() *ObjectStorageUpdateOne {
	osuo.mutation.ClearCurrentSize()
	return osuo
}

// SetLast30DayDownload sets the "last30_day_download" field.
func (osuo *ObjectStorageUpdateOne) SetLast30DayDownload(i int) *ObjectStorageUpdateOne {
	osuo.mutation.ResetLast30DayDownload()
	osuo.mutation.SetLast30DayDownload(i)
	return osuo
}

// SetNillableLast30DayDownload sets the "last30_day_download" field if the given value is not nil.
func (osuo *ObjectStorageUpdateOne) SetNillableLast30DayDownload(i *int) *ObjectStorageUpdateOne {
	if i != nil {
		osuo.SetLast30DayDownload(*i)
	}
	return osuo
}

// AddLast30DayDownload adds i to the "last30_day_download" field.
func (osuo *ObjectStorageUpdateOne) AddLast30DayDownload(i int) *ObjectStorageUpdateOne {
	osuo.mutation.AddLast30DayDownload(i)
	return osuo
}

// ClearLast30DayDownload clears the value of the "last30_day_download" field.
func (osuo *ObjectStorageUpdateOne) ClearLast30DayDownload() *ObjectStorageUpdateOne {
	osuo.mutation.ClearLast30DayDownload()
	return osuo
}

// SetLast30DayAPICallTimes sets the "last30_day_api_call_times" field.
func (osuo *ObjectStorageUpdateOne) SetLast30DayAPICallTimes(i int) *ObjectStorageUpdateOne {
	osuo.mutation.ResetLast30DayAPICallTimes()
	osuo.mutation.SetLast30DayAPICallTimes(i)
	return osuo
}

// SetNillableLast30DayAPICallTimes sets the "last30_day_api_call_times" field if the given value is not nil.
func (osuo *ObjectStorageUpdateOne) SetNillableLast30DayAPICallTimes(i *int) *ObjectStorageUpdateOne {
	if i != nil {
		osuo.SetLast30DayAPICallTimes(*i)
	}
	return osuo
}

// AddLast30DayAPICallTimes adds i to the "last30_day_api_call_times" field.
func (osuo *ObjectStorageUpdateOne) AddLast30DayAPICallTimes(i int) *ObjectStorageUpdateOne {
	osuo.mutation.AddLast30DayAPICallTimes(i)
	return osuo
}

// ClearLast30DayAPICallTimes clears the value of the "last30_day_api_call_times" field.
func (osuo *ObjectStorageUpdateOne) ClearLast30DayAPICallTimes() *ObjectStorageUpdateOne {
	osuo.mutation.ClearLast30DayAPICallTimes()
	return osuo
}

// SetLastUpdateTime sets the "last_update_time" field.
func (osuo *ObjectStorageUpdateOne) SetLastUpdateTime(t time.Time) *ObjectStorageUpdateOne {
	osuo.mutation.SetLastUpdateTime(t)
	return osuo
}

// Mutation returns the ObjectStorageMutation object of the builder.
func (osuo *ObjectStorageUpdateOne) Mutation() *ObjectStorageMutation {
	return osuo.mutation
}

// Where appends a list predicates to the ObjectStorageUpdate builder.
func (osuo *ObjectStorageUpdateOne) Where(ps ...predicate.ObjectStorage) *ObjectStorageUpdateOne {
	osuo.mutation.Where(ps...)
	return osuo
}

// Select allows selecting one or more fields (columns) of the returned entity.
// The default is selecting all fields defined in the entity schema.
func (osuo *ObjectStorageUpdateOne) Select(field string, fields ...string) *ObjectStorageUpdateOne {
	osuo.fields = append([]string{field}, fields...)
	return osuo
}

// Save executes the query and returns the updated ObjectStorage entity.
func (osuo *ObjectStorageUpdateOne) Save(ctx context.Context) (*ObjectStorage, error) {
	return withHooks[*ObjectStorage, ObjectStorageMutation](ctx, osuo.sqlSave, osuo.mutation, osuo.hooks)
}

// SaveX is like Save, but panics if an error occurs.
func (osuo *ObjectStorageUpdateOne) SaveX(ctx context.Context) *ObjectStorage {
	node, err := osuo.Save(ctx)
	if err != nil {
		panic(err)
	}
	return node
}

// Exec executes the query on the entity.
func (osuo *ObjectStorageUpdateOne) Exec(ctx context.Context) error {
	_, err := osuo.Save(ctx)
	return err
}

// ExecX is like Exec, but panics if an error occurs.
func (osuo *ObjectStorageUpdateOne) ExecX(ctx context.Context) {
	if err := osuo.Exec(ctx); err != nil {
		panic(err)
	}
}

func (osuo *ObjectStorageUpdateOne) sqlSave(ctx context.Context) (_node *ObjectStorage, err error) {
	_spec := sqlgraph.NewUpdateSpec(objectstorage.Table, objectstorage.Columns, sqlgraph.NewFieldSpec(objectstorage.FieldID, field.TypeString))
	id, ok := osuo.mutation.ID()
	if !ok {
		return nil, &ValidationError{Name: "id", err: errors.New(`ent: missing "ObjectStorage.id" for update`)}
	}
	_spec.Node.ID.Value = id
	if fields := osuo.fields; len(fields) > 0 {
		_spec.Node.Columns = make([]string, 0, len(fields))
		_spec.Node.Columns = append(_spec.Node.Columns, objectstorage.FieldID)
		for _, f := range fields {
			if !objectstorage.ValidColumn(f) {
				return nil, &ValidationError{Name: f, err: fmt.Errorf("ent: invalid field %q for query", f)}
			}
			if f != objectstorage.FieldID {
				_spec.Node.Columns = append(_spec.Node.Columns, f)
			}
		}
	}
	if ps := osuo.mutation.predicates; len(ps) > 0 {
		_spec.Predicate = func(selector *sql.Selector) {
			for i := range ps {
				ps[i](selector)
			}
		}
	}
	if value, ok := osuo.mutation.Name(); ok {
		_spec.SetField(objectstorage.FieldName, field.TypeString, value)
	}
	if osuo.mutation.NameCleared() {
		_spec.ClearField(objectstorage.FieldName, field.TypeString)
	}
	if value, ok := osuo.mutation.Size(); ok {
		_spec.SetField(objectstorage.FieldSize, field.TypeInt, value)
	}
	if value, ok := osuo.mutation.AddedSize(); ok {
		_spec.AddField(objectstorage.FieldSize, field.TypeInt, value)
	}
	if osuo.mutation.SizeCleared() {
		_spec.ClearField(objectstorage.FieldSize, field.TypeInt)
	}
	if value, ok := osuo.mutation.StorageType(); ok {
		_spec.SetField(objectstorage.FieldStorageType, field.TypeString, value)
	}
	if osuo.mutation.StorageTypeCleared() {
		_spec.ClearField(objectstorage.FieldStorageType, field.TypeString)
	}
	if value, ok := osuo.mutation.Region(); ok {
		_spec.SetField(objectstorage.FieldRegion, field.TypeString, value)
	}
	if osuo.mutation.RegionCleared() {
		_spec.ClearField(objectstorage.FieldRegion, field.TypeString)
	}
	if value, ok := osuo.mutation.RegionCode(); ok {
		_spec.SetField(objectstorage.FieldRegionCode, field.TypeString, value)
	}
	if osuo.mutation.RegionCodeCleared() {
		_spec.ClearField(objectstorage.FieldRegionCode, field.TypeString)
	}
	if value, ok := osuo.mutation.Az(); ok {
		_spec.SetField(objectstorage.FieldAz, field.TypeString, value)
	}
	if osuo.mutation.AzCleared() {
		_spec.ClearField(objectstorage.FieldAz, field.TypeString)
	}
	if value, ok := osuo.mutation.AzCode(); ok {
		_spec.SetField(objectstorage.FieldAzCode, field.TypeString, value)
	}
	if osuo.mutation.AzCodeCleared() {
		_spec.ClearField(objectstorage.FieldAzCode, field.TypeString)
	}
	if value, ok := osuo.mutation.TenantID(); ok {
		_spec.SetField(objectstorage.FieldTenantID, field.TypeString, value)
	}
	if osuo.mutation.TenantIDCleared() {
		_spec.ClearField(objectstorage.FieldTenantID, field.TypeString)
	}
	if value, ok := osuo.mutation.TenantName(); ok {
		_spec.SetField(objectstorage.FieldTenantName, field.TypeString, value)
	}
	if osuo.mutation.TenantNameCleared() {
		_spec.ClearField(objectstorage.FieldTenantName, field.TypeString)
	}
	if value, ok := osuo.mutation.InnerDomainName(); ok {
		_spec.SetField(objectstorage.FieldInnerDomainName, field.TypeString, value)
	}
	if osuo.mutation.InnerDomainNameCleared() {
		_spec.ClearField(objectstorage.FieldInnerDomainName, field.TypeString)
	}
	if value, ok := osuo.mutation.OuterDomainName(); ok {
		_spec.SetField(objectstorage.FieldOuterDomainName, field.TypeString, value)
	}
	if osuo.mutation.OuterDomainNameCleared() {
		_spec.ClearField(objectstorage.FieldOuterDomainName, field.TypeString)
	}
	if value, ok := osuo.mutation.CreateTime(); ok {
		_spec.SetField(objectstorage.FieldCreateTime, field.TypeInt, value)
	}
	if value, ok := osuo.mutation.AddedCreateTime(); ok {
		_spec.AddField(objectstorage.FieldCreateTime, field.TypeInt, value)
	}
	if osuo.mutation.CreateTimeCleared() {
		_spec.ClearField(objectstorage.FieldCreateTime, field.TypeInt)
	}
	if value, ok := osuo.mutation.Policy(); ok {
		_spec.SetField(objectstorage.FieldPolicy, field.TypeString, value)
	}
	if osuo.mutation.PolicyCleared() {
		_spec.ClearField(objectstorage.FieldPolicy, field.TypeString)
	}
	if value, ok := osuo.mutation.BucketDomains(); ok {
		_spec.SetField(objectstorage.FieldBucketDomains, field.TypeString, value)
	}
	if osuo.mutation.BucketDomainsCleared() {
		_spec.ClearField(objectstorage.FieldBucketDomains, field.TypeString)
	}
	if value, ok := osuo.mutation.ResourcePoolID(); ok {
		_spec.SetField(objectstorage.FieldResourcePoolID, field.TypeInt, value)
	}
	if value, ok := osuo.mutation.AddedResourcePoolID(); ok {
		_spec.AddField(objectstorage.FieldResourcePoolID, field.TypeInt, value)
	}
	if osuo.mutation.ResourcePoolIDCleared() {
		_spec.ClearField(objectstorage.FieldResourcePoolID, field.TypeInt)
	}
	if value, ok := osuo.mutation.ResourcePoolName(); ok {
		_spec.SetField(objectstorage.FieldResourcePoolName, field.TypeString, value)
	}
	if osuo.mutation.ResourcePoolNameCleared() {
		_spec.ClearField(objectstorage.FieldResourcePoolName, field.TypeString)
	}
	if value, ok := osuo.mutation.ObjectCount(); ok {
		_spec.SetField(objectstorage.FieldObjectCount, field.TypeInt, value)
	}
	if value, ok := osuo.mutation.AddedObjectCount(); ok {
		_spec.AddField(objectstorage.FieldObjectCount, field.TypeInt, value)
	}
	if osuo.mutation.ObjectCountCleared() {
		_spec.ClearField(objectstorage.FieldObjectCount, field.TypeInt)
	}
	if value, ok := osuo.mutation.CurrentSize(); ok {
		_spec.SetField(objectstorage.FieldCurrentSize, field.TypeInt, value)
	}
	if value, ok := osuo.mutation.AddedCurrentSize(); ok {
		_spec.AddField(objectstorage.FieldCurrentSize, field.TypeInt, value)
	}
	if osuo.mutation.CurrentSizeCleared() {
		_spec.ClearField(objectstorage.FieldCurrentSize, field.TypeInt)
	}
	if value, ok := osuo.mutation.Last30DayDownload(); ok {
		_spec.SetField(objectstorage.FieldLast30DayDownload, field.TypeInt, value)
	}
	if value, ok := osuo.mutation.AddedLast30DayDownload(); ok {
		_spec.AddField(objectstorage.FieldLast30DayDownload, field.TypeInt, value)
	}
	if osuo.mutation.Last30DayDownloadCleared() {
		_spec.ClearField(objectstorage.FieldLast30DayDownload, field.TypeInt)
	}
	if value, ok := osuo.mutation.Last30DayAPICallTimes(); ok {
		_spec.SetField(objectstorage.FieldLast30DayAPICallTimes, field.TypeInt, value)
	}
	if value, ok := osuo.mutation.AddedLast30DayAPICallTimes(); ok {
		_spec.AddField(objectstorage.FieldLast30DayAPICallTimes, field.TypeInt, value)
	}
	if osuo.mutation.Last30DayAPICallTimesCleared() {
		_spec.ClearField(objectstorage.FieldLast30DayAPICallTimes, field.TypeInt)
	}
	if value, ok := osuo.mutation.LastUpdateTime(); ok {
		_spec.SetField(objectstorage.FieldLastUpdateTime, field.TypeTime, value)
	}
	_node = &ObjectStorage{config: osuo.config}
	_spec.Assign = _node.assignValues
	_spec.ScanValues = _node.scanValues
	if err = sqlgraph.UpdateNode(ctx, osuo.driver, _spec); err != nil {
		if _, ok := err.(*sqlgraph.NotFoundError); ok {
			err = &NotFoundError{objectstorage.Label}
		} else if sqlgraph.IsConstraintError(err) {
			err = &ConstraintError{msg: err.Error(), wrap: err}
		}
		return nil, err
	}
	osuo.mutation.done = true
	return _node, nil
}

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/data/ent/ebsvolume_delete.go
```golang
// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"luban-cmdb-api/data/ent/ebsvolume"
	"luban-cmdb-api/data/ent/predicate"

	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
	"entgo.io/ent/schema/field"
)

// EbsVolumeDelete is the builder for deleting a EbsVolume entity.
type EbsVolumeDelete struct {
	config
	hooks    []Hook
	mutation *EbsVolumeMutation
}

// Where appends a list predicates to the EbsVolumeDelete builder.
func (evd *EbsVolumeDelete) Where(ps ...predicate.EbsVolume) *EbsVolumeDelete {
	evd.mutation.Where(ps...)
	return evd
}

// Exec executes the deletion query and returns how many vertices were deleted.
func (evd *EbsVolumeDelete) Exec(ctx context.Context) (int, error) {
	return withHooks[int, EbsVolumeMutation](ctx, evd.sqlExec, evd.mutation, evd.hooks)
}

// ExecX is like Exec, but panics if an error occurs.
func (evd *EbsVolumeDelete) ExecX(ctx context.Context) int {
	n, err := evd.Exec(ctx)
	if err != nil {
		panic(err)
	}
	return n
}

func (evd *EbsVolumeDelete) sqlExec(ctx context.Context) (int, error) {
	_spec := sqlgraph.NewDeleteSpec(ebsvolume.Table, sqlgraph.NewFieldSpec(ebsvolume.FieldID, field.TypeInt))
	if ps := evd.mutation.predicates; len(ps) > 0 {
		_spec.Predicate = func(selector *sql.Selector) {
			for i := range ps {
				ps[i](selector)
			}
		}
	}
	affected, err := sqlgraph.DeleteNodes(ctx, evd.driver, _spec)
	if err != nil && sqlgraph.IsConstraintError(err) {
		err = &ConstraintError{msg: err.Error(), wrap: err}
	}
	evd.mutation.done = true
	return affected, err
}

// EbsVolumeDeleteOne is the builder for deleting a single EbsVolume entity.
type EbsVolumeDeleteOne struct {
	evd *EbsVolumeDelete
}

// Where appends a list predicates to the EbsVolumeDelete builder.
func (evdo *EbsVolumeDeleteOne) Where(ps ...predicate.EbsVolume) *EbsVolumeDeleteOne {
	evdo.evd.mutation.Where(ps...)
	return evdo
}

// Exec executes the deletion query.
func (evdo *EbsVolumeDeleteOne) Exec(ctx context.Context) error {
	n, err := evdo.evd.Exec(ctx)
	switch {
	case err != nil:
		return err
	case n == 0:
		return &NotFoundError{ebsvolume.Label}
	default:
		return nil
	}
}

// ExecX is like Exec, but panics if an error occurs.
func (evdo *EbsVolumeDeleteOne) ExecX(ctx context.Context) {
	if err := evdo.Exec(ctx); err != nil {
		panic(err)
	}
}

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/data/ent/blockstorage_update.go
```golang
// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"luban-cmdb-api/data/ent/blockstorage"
	"luban-cmdb-api/data/ent/predicate"
	"time"

	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
	"entgo.io/ent/schema/field"
)

// BlockStorageUpdate is the builder for updating BlockStorage entities.
type BlockStorageUpdate struct {
	config
	hooks    []Hook
	mutation *BlockStorageMutation
}

// Where appends a list predicates to the BlockStorageUpdate builder.
func (bsu *BlockStorageUpdate) Where(ps ...predicate.BlockStorage) *BlockStorageUpdate {
	bsu.mutation.Where(ps...)
	return bsu
}

// SetName sets the "name" field.
func (bsu *BlockStorageUpdate) SetName(s string) *BlockStorageUpdate {
	bsu.mutation.SetName(s)
	return bsu
}

// SetInstanceID sets the "instance_id" field.
func (bsu *BlockStorageUpdate) SetInstanceID(s string) *BlockStorageUpdate {
	bsu.mutation.SetInstanceID(s)
	return bsu
}

// SetRegion sets the "region" field.
func (bsu *BlockStorageUpdate) SetRegion(s string) *BlockStorageUpdate {
	bsu.mutation.SetRegion(s)
	return bsu
}

// SetRegionCode sets the "region_code" field.
func (bsu *BlockStorageUpdate) SetRegionCode(s string) *BlockStorageUpdate {
	bsu.mutation.SetRegionCode(s)
	return bsu
}

// SetAz sets the "az" field.
func (bsu *BlockStorageUpdate) SetAz(s string) *BlockStorageUpdate {
	bsu.mutation.SetAz(s)
	return bsu
}

// SetAzCode sets the "az_code" field.
func (bsu *BlockStorageUpdate) SetAzCode(s string) *BlockStorageUpdate {
	bsu.mutation.SetAzCode(s)
	return bsu
}

// SetResourcePool sets the "resource_pool" field.
func (bsu *BlockStorageUpdate) SetResourcePool(s string) *BlockStorageUpdate {
	bsu.mutation.SetResourcePool(s)
	return bsu
}

// SetResourcePoolType sets the "resource_pool_type" field.
func (bsu *BlockStorageUpdate) SetResourcePoolType(s string) *BlockStorageUpdate {
	bsu.mutation.SetResourcePoolType(s)
	return bsu
}

// SetUseStatus sets the "use_status" field.
func (bsu *BlockStorageUpdate) SetUseStatus(s string) *BlockStorageUpdate {
	bsu.mutation.SetUseStatus(s)
	return bsu
}

// SetTenantID sets the "tenant_id" field.
func (bsu *BlockStorageUpdate) SetTenantID(s string) *BlockStorageUpdate {
	bsu.mutation.SetTenantID(s)
	return bsu
}

// SetTenantName sets the "tenant_name" field.
func (bsu *BlockStorageUpdate) SetTenantName(s string) *BlockStorageUpdate {
	bsu.mutation.SetTenantName(s)
	return bsu
}

// SetVM sets the "vm" field.
func (bsu *BlockStorageUpdate) SetVM(s string) *BlockStorageUpdate {
	bsu.mutation.SetVM(s)
	return bsu
}

// SetVMID sets the "vm_id" field.
func (bsu *BlockStorageUpdate) SetVMID(s string) *BlockStorageUpdate {
	bsu.mutation.SetVMID(s)
	return bsu
}

// SetCreateTime sets the "create_time" field.
func (bsu *BlockStorageUpdate) SetCreateTime(i int) *BlockStorageUpdate {
	bsu.mutation.ResetCreateTime()
	bsu.mutation.SetCreateTime(i)
	return bsu
}

// AddCreateTime adds i to the "create_time" field.
func (bsu *BlockStorageUpdate) AddCreateTime(i int) *BlockStorageUpdate {
	bsu.mutation.AddCreateTime(i)
	return bsu
}

// SetSize sets the "size" field.
func (bsu *BlockStorageUpdate) SetSize(i int32) *BlockStorageUpdate {
	bsu.mutation.ResetSize()
	bsu.mutation.SetSize(i)
	return bsu
}

// AddSize adds i to the "size" field.
func (bsu *BlockStorageUpdate) AddSize(i int32) *BlockStorageUpdate {
	bsu.mutation.AddSize(i)
	return bsu
}

// SetMountPoint sets the "mount_point" field.
func (bsu *BlockStorageUpdate) SetMountPoint(s string) *BlockStorageUpdate {
	bsu.mutation.SetMountPoint(s)
	return bsu
}

// SetLastUpdateTime sets the "last_update_time" field.
func (bsu *BlockStorageUpdate) SetLastUpdateTime(t time.Time) *BlockStorageUpdate {
	bsu.mutation.SetLastUpdateTime(t)
	return bsu
}

// Mutation returns the BlockStorageMutation object of the builder.
func (bsu *BlockStorageUpdate) Mutation() *BlockStorageMutation {
	return bsu.mutation
}

// Save executes the query and returns the number of nodes affected by the update operation.
func (bsu *BlockStorageUpdate) Save(ctx context.Context) (int, error) {
	return withHooks[int, BlockStorageMutation](ctx, bsu.sqlSave, bsu.mutation, bsu.hooks)
}

// SaveX is like Save, but panics if an error occurs.
func (bsu *BlockStorageUpdate) SaveX(ctx context.Context) int {
	affected, err := bsu.Save(ctx)
	if err != nil {
		panic(err)
	}
	return affected
}

// Exec executes the query.
func (bsu *BlockStorageUpdate) Exec(ctx context.Context) error {
	_, err := bsu.Save(ctx)
	return err
}

// ExecX is like Exec, but panics if an error occurs.
func (bsu *BlockStorageUpdate) ExecX(ctx context.Context) {
	if err := bsu.Exec(ctx); err != nil {
		panic(err)
	}
}

func (bsu *BlockStorageUpdate) sqlSave(ctx context.Context) (n int, err error) {
	_spec := sqlgraph.NewUpdateSpec(blockstorage.Table, blockstorage.Columns, sqlgraph.NewFieldSpec(blockstorage.FieldID, field.TypeInt))
	if ps := bsu.mutation.predicates; len(ps) > 0 {
		_spec.Predicate = func(selector *sql.Selector) {
			for i := range ps {
				ps[i](selector)
			}
		}
	}
	if value, ok := bsu.mutation.Name(); ok {
		_spec.SetField(blockstorage.FieldName, field.TypeString, value)
	}
	if value, ok := bsu.mutation.InstanceID(); ok {
		_spec.SetField(blockstorage.FieldInstanceID, field.TypeString, value)
	}
	if value, ok := bsu.mutation.Region(); ok {
		_spec.SetField(blockstorage.FieldRegion, field.TypeString, value)
	}
	if value, ok := bsu.mutation.RegionCode(); ok {
		_spec.SetField(blockstorage.FieldRegionCode, field.TypeString, value)
	}
	if value, ok := bsu.mutation.Az(); ok {
		_spec.SetField(blockstorage.FieldAz, field.TypeString, value)
	}
	if value, ok := bsu.mutation.AzCode(); ok {
		_spec.SetField(blockstorage.FieldAzCode, field.TypeString, value)
	}
	if value, ok := bsu.mutation.ResourcePool(); ok {
		_spec.SetField(blockstorage.FieldResourcePool, field.TypeString, value)
	}
	if value, ok := bsu.mutation.ResourcePoolType(); ok {
		_spec.SetField(blockstorage.FieldResourcePoolType, field.TypeString, value)
	}
	if value, ok := bsu.mutation.UseStatus(); ok {
		_spec.SetField(blockstorage.FieldUseStatus, field.TypeString, value)
	}
	if value, ok := bsu.mutation.TenantID(); ok {
		_spec.SetField(blockstorage.FieldTenantID, field.TypeString, value)
	}
	if value, ok := bsu.mutation.TenantName(); ok {
		_spec.SetField(blockstorage.FieldTenantName, field.TypeString, value)
	}
	if value, ok := bsu.mutation.VM(); ok {
		_spec.SetField(blockstorage.FieldVM, field.TypeString, value)
	}
	if value, ok := bsu.mutation.VMID(); ok {
		_spec.SetField(blockstorage.FieldVMID, field.TypeString, value)
	}
	if value, ok := bsu.mutation.CreateTime(); ok {
		_spec.SetField(blockstorage.FieldCreateTime, field.TypeInt, value)
	}
	if value, ok := bsu.mutation.AddedCreateTime(); ok {
		_spec.AddField(blockstorage.FieldCreateTime, field.TypeInt, value)
	}
	if value, ok := bsu.mutation.Size(); ok {
		_spec.SetField(blockstorage.FieldSize, field.TypeInt32, value)
	}
	if value, ok := bsu.mutation.AddedSize(); ok {
		_spec.AddField(blockstorage.FieldSize, field.TypeInt32, value)
	}
	if value, ok := bsu.mutation.MountPoint(); ok {
		_spec.SetField(blockstorage.FieldMountPoint, field.TypeString, value)
	}
	if value, ok := bsu.mutation.LastUpdateTime(); ok {
		_spec.SetField(blockstorage.FieldLastUpdateTime, field.TypeTime, value)
	}
	if n, err = sqlgraph.UpdateNodes(ctx, bsu.driver, _spec); err != nil {
		if _, ok := err.(*sqlgraph.NotFoundError); ok {
			err = &NotFoundError{blockstorage.Label}
		} else if sqlgraph.IsConstraintError(err) {
			err = &ConstraintError{msg: err.Error(), wrap: err}
		}
		return 0, err
	}
	bsu.mutation.done = true
	return n, nil
}

// BlockStorageUpdateOne is the builder for updating a single BlockStorage entity.
type BlockStorageUpdateOne struct {
	config
	fields   []string
	hooks    []Hook
	mutation *BlockStorageMutation
}

// SetName sets the "name" field.
func (bsuo *BlockStorageUpdateOne) SetName(s string) *BlockStorageUpdateOne {
	bsuo.mutation.SetName(s)
	return bsuo
}

// SetInstanceID sets the "instance_id" field.
func (bsuo *BlockStorageUpdateOne) SetInstanceID(s string) *BlockStorageUpdateOne {
	bsuo.mutation.SetInstanceID(s)
	return bsuo
}

// SetRegion sets the "region" field.
func (bsuo *BlockStorageUpdateOne) SetRegion(s string) *BlockStorageUpdateOne {
	bsuo.mutation.SetRegion(s)
	return bsuo
}

// SetRegionCode sets the "region_code" field.
func (bsuo *BlockStorageUpdateOne) SetRegionCode(s string) *BlockStorageUpdateOne {
	bsuo.mutation.SetRegionCode(s)
	return bsuo
}

// SetAz sets the "az" field.
func (bsuo *BlockStorageUpdateOne) SetAz(s string) *BlockStorageUpdateOne {
	bsuo.mutation.SetAz(s)
	return bsuo
}

// SetAzCode sets the "az_code" field.
func (bsuo *BlockStorageUpdateOne) SetAzCode(s string) *BlockStorageUpdateOne {
	bsuo.mutation.SetAzCode(s)
	return bsuo
}

// SetResourcePool sets the "resource_pool" field.
func (bsuo *BlockStorageUpdateOne) SetResourcePool(s string) *BlockStorageUpdateOne {
	bsuo.mutation.SetResourcePool(s)
	return bsuo
}

// SetResourcePoolType sets the "resource_pool_type" field.
func (bsuo *BlockStorageUpdateOne) SetResourcePoolType(s string) *BlockStorageUpdateOne {
	bsuo.mutation.SetResourcePoolType(s)
	return bsuo
}

// SetUseStatus sets the "use_status" field.
func (bsuo *BlockStorageUpdateOne) SetUseStatus(s string) *BlockStorageUpdateOne {
	bsuo.mutation.SetUseStatus(s)
	return bsuo
}

// SetTenantID sets the "tenant_id" field.
func (bsuo *BlockStorageUpdateOne) SetTenantID(s string) *BlockStorageUpdateOne {
	bsuo.mutation.SetTenantID(s)
	return bsuo
}

// SetTenantName sets the "tenant_name" field.
func (bsuo *BlockStorageUpdateOne) SetTenantName(s string) *BlockStorageUpdateOne {
	bsuo.mutation.SetTenantName(s)
	return bsuo
}

// SetVM sets the "vm" field.
func (bsuo *BlockStorageUpdateOne) SetVM(s string) *BlockStorageUpdateOne {
	bsuo.mutation.SetVM(s)
	return bsuo
}

// SetVMID sets the "vm_id" field.
func (bsuo *BlockStorageUpdateOne) SetVMID(s string) *BlockStorageUpdateOne {
	bsuo.mutation.SetVMID(s)
	return bsuo
}

// SetCreateTime sets the "create_time" field.
func (bsuo *BlockStorageUpdateOne) SetCreateTime(i int) *BlockStorageUpdateOne {
	bsuo.mutation.ResetCreateTime()
	bsuo.mutation.SetCreateTime(i)
	return bsuo
}

// AddCreateTime adds i to the "create_time" field.
func (bsuo *BlockStorageUpdateOne) AddCreateTime(i int) *BlockStorageUpdateOne {
	bsuo.mutation.AddCreateTime(i)
	return bsuo
}

// SetSize sets the "size" field.
func (bsuo *BlockStorageUpdateOne) SetSize(i int32) *BlockStorageUpdateOne {
	bsuo.mutation.ResetSize()
	bsuo.mutation.SetSize(i)
	return bsuo
}

// AddSize adds i to the "size" field.
func (bsuo *BlockStorageUpdateOne) AddSize(i int32) *BlockStorageUpdateOne {
	bsuo.mutation.AddSize(i)
	return bsuo
}

// SetMountPoint sets the "mount_point" field.
func (bsuo *BlockStorageUpdateOne) SetMountPoint(s string) *BlockStorageUpdateOne {
	bsuo.mutation.SetMountPoint(s)
	return bsuo
}

// SetLastUpdateTime sets the "last_update_time" field.
func (bsuo *BlockStorageUpdateOne) SetLastUpdateTime(t time.Time) *BlockStorageUpdateOne {
	bsuo.mutation.SetLastUpdateTime(t)
	return bsuo
}

// Mutation returns the BlockStorageMutation object of the builder.
func (bsuo *BlockStorageUpdateOne) Mutation() *BlockStorageMutation {
	return bsuo.mutation
}

// Where appends a list predicates to the BlockStorageUpdate builder.
func (bsuo *BlockStorageUpdateOne) Where(ps ...predicate.BlockStorage) *BlockStorageUpdateOne {
	bsuo.mutation.Where(ps...)
	return bsuo
}

// Select allows selecting one or more fields (columns) of the returned entity.
// The default is selecting all fields defined in the entity schema.
func (bsuo *BlockStorageUpdateOne) Select(field string, fields ...string) *BlockStorageUpdateOne {
	bsuo.fields = append([]string{field}, fields...)
	return bsuo
}

// Save executes the query and returns the updated BlockStorage entity.
func (bsuo *BlockStorageUpdateOne) Save(ctx context.Context) (*BlockStorage, error) {
	return withHooks[*BlockStorage, BlockStorageMutation](ctx, bsuo.sqlSave, bsuo.mutation, bsuo.hooks)
}

// SaveX is like Save, but panics if an error occurs.
func (bsuo *BlockStorageUpdateOne) SaveX(ctx context.Context) *BlockStorage {
	node, err := bsuo.Save(ctx)
	if err != nil {
		panic(err)
	}
	return node
}

// Exec executes the query on the entity.
func (bsuo *BlockStorageUpdateOne) Exec(ctx context.Context) error {
	_, err := bsuo.Save(ctx)
	return err
}

// ExecX is like Exec, but panics if an error occurs.
func (bsuo *BlockStorageUpdateOne) ExecX(ctx context.Context) {
	if err := bsuo.Exec(ctx); err != nil {
		panic(err)
	}
}

func (bsuo *BlockStorageUpdateOne) sqlSave(ctx context.Context) (_node *BlockStorage, err error) {
	_spec := sqlgraph.NewUpdateSpec(blockstorage.Table, blockstorage.Columns, sqlgraph.NewFieldSpec(blockstorage.FieldID, field.TypeInt))
	id, ok := bsuo.mutation.ID()
	if !ok {
		return nil, &ValidationError{Name: "id", err: errors.New(`ent: missing "BlockStorage.id" for update`)}
	}
	_spec.Node.ID.Value = id
	if fields := bsuo.fields; len(fields) > 0 {
		_spec.Node.Columns = make([]string, 0, len(fields))
		_spec.Node.Columns = append(_spec.Node.Columns, blockstorage.FieldID)
		for _, f := range fields {
			if !blockstorage.ValidColumn(f) {
				return nil, &ValidationError{Name: f, err: fmt.Errorf("ent: invalid field %q for query", f)}
			}
			if f != blockstorage.FieldID {
				_spec.Node.Columns = append(_spec.Node.Columns, f)
			}
		}
	}
	if ps := bsuo.mutation.predicates; len(ps) > 0 {
		_spec.Predicate = func(selector *sql.Selector) {
			for i := range ps {
				ps[i](selector)
			}
		}
	}
	if value, ok := bsuo.mutation.Name(); ok {
		_spec.SetField(blockstorage.FieldName, field.TypeString, value)
	}
	if value, ok := bsuo.mutation.InstanceID(); ok {
		_spec.SetField(blockstorage.FieldInstanceID, field.TypeString, value)
	}
	if value, ok := bsuo.mutation.Region(); ok {
		_spec.SetField(blockstorage.FieldRegion, field.TypeString, value)
	}
	if value, ok := bsuo.mutation.RegionCode(); ok {
		_spec.SetField(blockstorage.FieldRegionCode, field.TypeString, value)
	}
	if value, ok := bsuo.mutation.Az(); ok {
		_spec.SetField(blockstorage.FieldAz, field.TypeString, value)
	}
	if value, ok := bsuo.mutation.AzCode(); ok {
		_spec.SetField(blockstorage.FieldAzCode, field.TypeString, value)
	}
	if value, ok := bsuo.mutation.ResourcePool(); ok {
		_spec.SetField(blockstorage.FieldResourcePool, field.TypeString, value)
	}
	if value, ok := bsuo.mutation.ResourcePoolType(); ok {
		_spec.SetField(blockstorage.FieldResourcePoolType, field.TypeString, value)
	}
	if value, ok := bsuo.mutation.UseStatus(); ok {
		_spec.SetField(blockstorage.FieldUseStatus, field.TypeString, value)
	}
	if value, ok := bsuo.mutation.TenantID(); ok {
		_spec.SetField(blockstorage.FieldTenantID, field.TypeString, value)
	}
	if value, ok := bsuo.mutation.TenantName(); ok {
		_spec.SetField(blockstorage.FieldTenantName, field.TypeString, value)
	}
	if value, ok := bsuo.mutation.VM(); ok {
		_spec.SetField(blockstorage.FieldVM, field.TypeString, value)
	}
	if value, ok := bsuo.mutation.VMID(); ok {
		_spec.SetField(blockstorage.FieldVMID, field.TypeString, value)
	}
	if value, ok := bsuo.mutation.CreateTime(); ok {
		_spec.SetField(blockstorage.FieldCreateTime, field.TypeInt, value)
	}
	if value, ok := bsuo.mutation.AddedCreateTime(); ok {
		_spec.AddField(blockstorage.FieldCreateTime, field.TypeInt, value)
	}
	if value, ok := bsuo.mutation.Size(); ok {
		_spec.SetField(blockstorage.FieldSize, field.TypeInt32, value)
	}
	if value, ok := bsuo.mutation.AddedSize(); ok {
		_spec.AddField(blockstorage.FieldSize, field.TypeInt32, value)
	}
	if value, ok := bsuo.mutation.MountPoint(); ok {
		_spec.SetField(blockstorage.FieldMountPoint, field.TypeString, value)
	}
	if value, ok := bsuo.mutation.LastUpdateTime(); ok {
		_spec.SetField(blockstorage.FieldLastUpdateTime, field.TypeTime, value)
	}
	_node = &BlockStorage{config: bsuo.config}
	_spec.Assign = _node.assignValues
	_spec.ScanValues = _node.scanValues
	if err = sqlgraph.UpdateNode(ctx, bsuo.driver, _spec); err != nil {
		if _, ok := err.(*sqlgraph.NotFoundError); ok {
			err = &NotFoundError{blockstorage.Label}
		} else if sqlgraph.IsConstraintError(err) {
			err = &ConstraintError{msg: err.Error(), wrap: err}
		}
		return nil, err
	}
	bsuo.mutation.done = true
	return _node, nil
}

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/data/ent/blockstorage_delete.go
```golang
// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"luban-cmdb-api/data/ent/blockstorage"
	"luban-cmdb-api/data/ent/predicate"

	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
	"entgo.io/ent/schema/field"
)

// BlockStorageDelete is the builder for deleting a BlockStorage entity.
type BlockStorageDelete struct {
	config
	hooks    []Hook
	mutation *BlockStorageMutation
}

// Where appends a list predicates to the BlockStorageDelete builder.
func (bsd *BlockStorageDelete) Where(ps ...predicate.BlockStorage) *BlockStorageDelete {
	bsd.mutation.Where(ps...)
	return bsd
}

// Exec executes the deletion query and returns how many vertices were deleted.
func (bsd *BlockStorageDelete) Exec(ctx context.Context) (int, error) {
	return withHooks[int, BlockStorageMutation](ctx, bsd.sqlExec, bsd.mutation, bsd.hooks)
}

// ExecX is like Exec, but panics if an error occurs.
func (bsd *BlockStorageDelete) ExecX(ctx context.Context) int {
	n, err := bsd.Exec(ctx)
	if err != nil {
		panic(err)
	}
	return n
}

func (bsd *BlockStorageDelete) sqlExec(ctx context.Context) (int, error) {
	_spec := sqlgraph.NewDeleteSpec(blockstorage.Table, sqlgraph.NewFieldSpec(blockstorage.FieldID, field.TypeInt))
	if ps := bsd.mutation.predicates; len(ps) > 0 {
		_spec.Predicate = func(selector *sql.Selector) {
			for i := range ps {
				ps[i](selector)
			}
		}
	}
	affected, err := sqlgraph.DeleteNodes(ctx, bsd.driver, _spec)
	if err != nil && sqlgraph.IsConstraintError(err) {
		err = &ConstraintError{msg: err.Error(), wrap: err}
	}
	bsd.mutation.done = true
	return affected, err
}

// BlockStorageDeleteOne is the builder for deleting a single BlockStorage entity.
type BlockStorageDeleteOne struct {
	bsd *BlockStorageDelete
}

// Where appends a list predicates to the BlockStorageDelete builder.
func (bsdo *BlockStorageDeleteOne) Where(ps ...predicate.BlockStorage) *BlockStorageDeleteOne {
	bsdo.bsd.mutation.Where(ps...)
	return bsdo
}

// Exec executes the deletion query.
func (bsdo *BlockStorageDeleteOne) Exec(ctx context.Context) error {
	n, err := bsdo.bsd.Exec(ctx)
	switch {
	case err != nil:
		return err
	case n == 0:
		return &NotFoundError{blockstorage.Label}
	default:
		return nil
	}
}

// ExecX is like Exec, but panics if an error occurs.
func (bsdo *BlockStorageDeleteOne) ExecX(ctx context.Context) {
	if err := bsdo.Exec(ctx); err != nil {
		panic(err)
	}
}

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/data/ent/ebsvolume_query.go
```golang
// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"fmt"
	"luban-cmdb-api/data/ent/ebsvolume"
	"luban-cmdb-api/data/ent/predicate"
	"math"

	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
	"entgo.io/ent/schema/field"
)

// EbsVolumeQuery is the builder for querying EbsVolume entities.
type EbsVolumeQuery struct {
	config
	ctx        *QueryContext
	order      []OrderFunc
	inters     []Interceptor
	predicates []predicate.EbsVolume
	// intermediate query (i.e. traversal path).
	sql  *sql.Selector
	path func(context.Context) (*sql.Selector, error)
}

// Where adds a new predicate for the EbsVolumeQuery builder.
func (evq *EbsVolumeQuery) Where(ps ...predicate.EbsVolume) *EbsVolumeQuery {
	evq.predicates = append(evq.predicates, ps...)
	return evq
}

// Limit the number of records to be returned by this query.
func (evq *EbsVolumeQuery) Limit(limit int) *EbsVolumeQuery {
	evq.ctx.Limit = &limit
	return evq
}

// Offset to start from.
func (evq *EbsVolumeQuery) Offset(offset int) *EbsVolumeQuery {
	evq.ctx.Offset = &offset
	return evq
}

// Unique configures the query builder to filter duplicate records on query.
// By default, unique is set to true, and can be disabled using this method.
func (evq *EbsVolumeQuery) Unique(unique bool) *EbsVolumeQuery {
	evq.ctx.Unique = &unique
	return evq
}

// Order specifies how the records should be ordered.
func (evq *EbsVolumeQuery) Order(o ...OrderFunc) *EbsVolumeQuery {
	evq.order = append(evq.order, o...)
	return evq
}

// First returns the first EbsVolume entity from the query.
// Returns a *NotFoundError when no EbsVolume was found.
func (evq *EbsVolumeQuery) First(ctx context.Context) (*EbsVolume, error) {
	nodes, err := evq.Limit(1).All(setContextOp(ctx, evq.ctx, "First"))
	if err != nil {
		return nil, err
	}
	if len(nodes) == 0 {
		return nil, &NotFoundError{ebsvolume.Label}
	}
	return nodes[0], nil
}

// FirstX is like First, but panics if an error occurs.
func (evq *EbsVolumeQuery) FirstX(ctx context.Context) *EbsVolume {
	node, err := evq.First(ctx)
	if err != nil && !IsNotFound(err) {
		panic(err)
	}
	return node
}

// FirstID returns the first EbsVolume ID from the query.
// Returns a *NotFoundError when no EbsVolume ID was found.
func (evq *EbsVolumeQuery) FirstID(ctx context.Context) (id int, err error) {
	var ids []int
	if ids, err = evq.Limit(1).IDs(setContextOp(ctx, evq.ctx, "FirstID")); err != nil {
		return
	}
	if len(ids) == 0 {
		err = &NotFoundError{ebsvolume.Label}
		return
	}
	return ids[0], nil
}

// FirstIDX is like FirstID, but panics if an error occurs.
func (evq *EbsVolumeQuery) FirstIDX(ctx context.Context) int {
	id, err := evq.FirstID(ctx)
	if err != nil && !IsNotFound(err) {
		panic(err)
	}
	return id
}

// Only returns a single EbsVolume entity found by the query, ensuring it only returns one.
// Returns a *NotSingularError when more than one EbsVolume entity is found.
// Returns a *NotFoundError when no EbsVolume entities are found.
func (evq *EbsVolumeQuery) Only(ctx context.Context) (*EbsVolume, error) {
	nodes, err := evq.Limit(2).All(setContextOp(ctx, evq.ctx, "Only"))
	if err != nil {
		return nil, err
	}
	switch len(nodes) {
	case 1:
		return nodes[0], nil
	case 0:
		return nil, &NotFoundError{ebsvolume.Label}
	default:
		return nil, &NotSingularError{ebsvolume.Label}
	}
}

// OnlyX is like Only, but panics if an error occurs.
func (evq *EbsVolumeQuery) OnlyX(ctx context.Context) *EbsVolume {
	node, err := evq.Only(ctx)
	if err != nil {
		panic(err)
	}
	return node
}

// OnlyID is like Only, but returns the only EbsVolume ID in the query.
// Returns a *NotSingularError when more than one EbsVolume ID is found.
// Returns a *NotFoundError when no entities are found.
func (evq *EbsVolumeQuery) OnlyID(ctx context.Context) (id int, err error) {
	var ids []int
	if ids, err = evq.Limit(2).IDs(setContextOp(ctx, evq.ctx, "OnlyID")); err != nil {
		return
	}
	switch len(ids) {
	case 1:
		id = ids[0]
	case 0:
		err = &NotFoundError{ebsvolume.Label}
	default:
		err = &NotSingularError{ebsvolume.Label}
	}
	return
}

// OnlyIDX is like OnlyID, but panics if an error occurs.
func (evq *EbsVolumeQuery) OnlyIDX(ctx context.Context) int {
	id, err := evq.OnlyID(ctx)
	if err != nil {
		panic(err)
	}
	return id
}

// All executes the query and returns a list of EbsVolumes.
func (evq *EbsVolumeQuery) All(ctx context.Context) ([]*EbsVolume, error) {
	ctx = setContextOp(ctx, evq.ctx, "All")
	if err := evq.prepareQuery(ctx); err != nil {
		return nil, err
	}
	qr := querierAll[[]*EbsVolume, *EbsVolumeQuery]()
	return withInterceptors[[]*EbsVolume](ctx, evq, qr, evq.inters)
}

// AllX is like All, but panics if an error occurs.
func (evq *EbsVolumeQuery) AllX(ctx context.Context) []*EbsVolume {
	nodes, err := evq.All(ctx)
	if err != nil {
		panic(err)
	}
	return nodes
}

// IDs executes the query and returns a list of EbsVolume IDs.
func (evq *EbsVolumeQuery) IDs(ctx context.Context) (ids []int, err error) {
	if evq.ctx.Unique == nil && evq.path != nil {
		evq.Unique(true)
	}
	ctx = setContextOp(ctx, evq.ctx, "IDs")
	if err = evq.Select(ebsvolume.FieldID).Scan(ctx, &ids); err != nil {
		return nil, err
	}
	return ids, nil
}

// IDsX is like IDs, but panics if an error occurs.
func (evq *EbsVolumeQuery) IDsX(ctx context.Context) []int {
	ids, err := evq.IDs(ctx)
	if err != nil {
		panic(err)
	}
	return ids
}

// Count returns the count of the given query.
func (evq *EbsVolumeQuery) Count(ctx context.Context) (int, error) {
	ctx = setContextOp(ctx, evq.ctx, "Count")
	if err := evq.prepareQuery(ctx); err != nil {
		return 0, err
	}
	return withInterceptors[int](ctx, evq, querierCount[*EbsVolumeQuery](), evq.inters)
}

// CountX is like Count, but panics if an error occurs.
func (evq *EbsVolumeQuery) CountX(ctx context.Context) int {
	count, err := evq.Count(ctx)
	if err != nil {
		panic(err)
	}
	return count
}

// Exist returns true if the query has elements in the graph.
func (evq *EbsVolumeQuery) Exist(ctx context.Context) (bool, error) {
	ctx = setContextOp(ctx, evq.ctx, "Exist")
	switch _, err := evq.FirstID(ctx); {
	case IsNotFound(err):
		return false, nil
	case err != nil:
		return false, fmt.Errorf("ent: check existence: %w", err)
	default:
		return true, nil
	}
}

// ExistX is like Exist, but panics if an error occurs.
func (evq *EbsVolumeQuery) ExistX(ctx context.Context) bool {
	exist, err := evq.Exist(ctx)
	if err != nil {
		panic(err)
	}
	return exist
}

// Clone returns a duplicate of the EbsVolumeQuery builder, including all associated steps. It can be
// used to prepare common query builders and use them differently after the clone is made.
func (evq *EbsVolumeQuery) Clone() *EbsVolumeQuery {
	if evq == nil {
		return nil
	}
	return &EbsVolumeQuery{
		config:     evq.config,
		ctx:        evq.ctx.Clone(),
		order:      append([]OrderFunc{}, evq.order...),
		inters:     append([]Interceptor{}, evq.inters...),
		predicates: append([]predicate.EbsVolume{}, evq.predicates...),
		// clone intermediate query.
		sql:  evq.sql.Clone(),
		path: evq.path,
	}
}

// GroupBy is used to group vertices by one or more fields/columns.
// It is often used with aggregate functions, like: count, max, mean, min, sum.
//
// Example:
//
//	var v []struct {
//		Galaxy string `json:"galaxy,omitempty"`
//		Count int `json:"count,omitempty"`
//	}
//
//	client.EbsVolume.Query().
//		GroupBy(ebsvolume.FieldGalaxy).
//		Aggregate(ent.Count()).
//		Scan(ctx, &v)
func (evq *EbsVolumeQuery) GroupBy(field string, fields ...string) *EbsVolumeGroupBy {
	evq.ctx.Fields = append([]string{field}, fields...)
	grbuild := &EbsVolumeGroupBy{build: evq}
	grbuild.flds = &evq.ctx.Fields
	grbuild.label = ebsvolume.Label
	grbuild.scan = grbuild.Scan
	return grbuild
}

// Select allows the selection one or more fields/columns for the given query,
// instead of selecting all fields in the entity.
//
// Example:
//
//	var v []struct {
//		Galaxy string `json:"galaxy,omitempty"`
//	}
//
//	client.EbsVolume.Query().
//		Select(ebsvolume.FieldGalaxy).
//		Scan(ctx, &v)
func (evq *EbsVolumeQuery) Select(fields ...string) *EbsVolumeSelect {
	evq.ctx.Fields = append(evq.ctx.Fields, fields...)
	sbuild := &EbsVolumeSelect{EbsVolumeQuery: evq}
	sbuild.label = ebsvolume.Label
	sbuild.flds, sbuild.scan = &evq.ctx.Fields, sbuild.Scan
	return sbuild
}

// Aggregate returns a EbsVolumeSelect configured with the given aggregations.
func (evq *EbsVolumeQuery) Aggregate(fns ...AggregateFunc) *EbsVolumeSelect {
	return evq.Select().Aggregate(fns...)
}

func (evq *EbsVolumeQuery) prepareQuery(ctx context.Context) error {
	for _, inter := range evq.inters {
		if inter == nil {
			return fmt.Errorf("ent: uninitialized interceptor (forgotten import ent/runtime?)")
		}
		if trv, ok := inter.(Traverser); ok {
			if err := trv.Traverse(ctx, evq); err != nil {
				return err
			}
		}
	}
	for _, f := range evq.ctx.Fields {
		if !ebsvolume.ValidColumn(f) {
			return &ValidationError{Name: f, err: fmt.Errorf("ent: invalid field %q for query", f)}
		}
	}
	if evq.path != nil {
		prev, err := evq.path(ctx)
		if err != nil {
			return err
		}
		evq.sql = prev
	}
	return nil
}

func (evq *EbsVolumeQuery) sqlAll(ctx context.Context, hooks ...queryHook) ([]*EbsVolume, error) {
	var (
		nodes = []*EbsVolume{}
		_spec = evq.querySpec()
	)
	_spec.ScanValues = func(columns []string) ([]any, error) {
		return (*EbsVolume).scanValues(nil, columns)
	}
	_spec.Assign = func(columns []string, values []any) error {
		node := &EbsVolume{config: evq.config}
		nodes = append(nodes, node)
		return node.assignValues(columns, values)
	}
	for i := range hooks {
		hooks[i](ctx, _spec)
	}
	if err := sqlgraph.QueryNodes(ctx, evq.driver, _spec); err != nil {
		return nil, err
	}
	if len(nodes) == 0 {
		return nodes, nil
	}
	return nodes, nil
}

func (evq *EbsVolumeQuery) sqlCount(ctx context.Context) (int, error) {
	_spec := evq.querySpec()
	_spec.Node.Columns = evq.ctx.Fields
	if len(evq.ctx.Fields) > 0 {
		_spec.Unique = evq.ctx.Unique != nil && *evq.ctx.Unique
	}
	return sqlgraph.CountNodes(ctx, evq.driver, _spec)
}

func (evq *EbsVolumeQuery) querySpec() *sqlgraph.QuerySpec {
	_spec := sqlgraph.NewQuerySpec(ebsvolume.Table, ebsvolume.Columns, sqlgraph.NewFieldSpec(ebsvolume.FieldID, field.TypeInt))
	_spec.From = evq.sql
	if unique := evq.ctx.Unique; unique != nil {
		_spec.Unique = *unique
	} else if evq.path != nil {
		_spec.Unique = true
	}
	if fields := evq.ctx.Fields; len(fields) > 0 {
		_spec.Node.Columns = make([]string, 0, len(fields))
		_spec.Node.Columns = append(_spec.Node.Columns, ebsvolume.FieldID)
		for i := range fields {
			if fields[i] != ebsvolume.FieldID {
				_spec.Node.Columns = append(_spec.Node.Columns, fields[i])
			}
		}
	}
	if ps := evq.predicates; len(ps) > 0 {
		_spec.Predicate = func(selector *sql.Selector) {
			for i := range ps {
				ps[i](selector)
			}
		}
	}
	if limit := evq.ctx.Limit; limit != nil {
		_spec.Limit = *limit
	}
	if offset := evq.ctx.Offset; offset != nil {
		_spec.Offset = *offset
	}
	if ps := evq.order; len(ps) > 0 {
		_spec.Order = func(selector *sql.Selector) {
			for i := range ps {
				ps[i](selector)
			}
		}
	}
	return _spec
}

func (evq *EbsVolumeQuery) sqlQuery(ctx context.Context) *sql.Selector {
	builder := sql.Dialect(evq.driver.Dialect())
	t1 := builder.Table(ebsvolume.Table)
	columns := evq.ctx.Fields
	if len(columns) == 0 {
		columns = ebsvolume.Columns
	}
	selector := builder.Select(t1.Columns(columns...)...).From(t1)
	if evq.sql != nil {
		selector = evq.sql
		selector.Select(selector.Columns(columns...)...)
	}
	if evq.ctx.Unique != nil && *evq.ctx.Unique {
		selector.Distinct()
	}
	for _, p := range evq.predicates {
		p(selector)
	}
	for _, p := range evq.order {
		p(selector)
	}
	if offset := evq.ctx.Offset; offset != nil {
		// limit is mandatory for offset clause. We start
		// with default value, and override it below if needed.
		selector.Offset(*offset).Limit(math.MaxInt32)
	}
	if limit := evq.ctx.Limit; limit != nil {
		selector.Limit(*limit)
	}
	return selector
}

// EbsVolumeGroupBy is the group-by builder for EbsVolume entities.
type EbsVolumeGroupBy struct {
	selector
	build *EbsVolumeQuery
}

// Aggregate adds the given aggregation functions to the group-by query.
func (evgb *EbsVolumeGroupBy) Aggregate(fns ...AggregateFunc) *EbsVolumeGroupBy {
	evgb.fns = append(evgb.fns, fns...)
	return evgb
}

// Scan applies the selector query and scans the result into the given value.
func (evgb *EbsVolumeGroupBy) Scan(ctx context.Context, v any) error {
	ctx = setContextOp(ctx, evgb.build.ctx, "GroupBy")
	if err := evgb.build.prepareQuery(ctx); err != nil {
		return err
	}
	return scanWithInterceptors[*EbsVolumeQuery, *EbsVolumeGroupBy](ctx, evgb.build, evgb, evgb.build.inters, v)
}

func (evgb *EbsVolumeGroupBy) sqlScan(ctx context.Context, root *EbsVolumeQuery, v any) error {
	selector := root.sqlQuery(ctx).Select()
	aggregation := make([]string, 0, len(evgb.fns))
	for _, fn := range evgb.fns {
		aggregation = append(aggregation, fn(selector))
	}
	if len(selector.SelectedColumns()) == 0 {
		columns := make([]string, 0, len(*evgb.flds)+len(evgb.fns))
		for _, f := range *evgb.flds {
			columns = append(columns, selector.C(f))
		}
		columns = append(columns, aggregation...)
		selector.Select(columns...)
	}
	selector.GroupBy(selector.Columns(*evgb.flds...)...)
	if err := selector.Err(); err != nil {
		return err
	}
	rows := &sql.Rows{}
	query, args := selector.Query()
	if err := evgb.build.driver.Query(ctx, query, args, rows); err != nil {
		return err
	}
	defer rows.Close()
	return sql.ScanSlice(rows, v)
}

// EbsVolumeSelect is the builder for selecting fields of EbsVolume entities.
type EbsVolumeSelect struct {
	*EbsVolumeQuery
	selector
}

// Aggregate adds the given aggregation functions to the selector query.
func (evs *EbsVolumeSelect) Aggregate(fns ...AggregateFunc) *EbsVolumeSelect {
	evs.fns = append(evs.fns, fns...)
	return evs
}

// Scan applies the selector query and scans the result into the given value.
func (evs *EbsVolumeSelect) Scan(ctx context.Context, v any) error {
	ctx = setContextOp(ctx, evs.ctx, "Select")
	if err := evs.prepareQuery(ctx); err != nil {
		return err
	}
	return scanWithInterceptors[*EbsVolumeQuery, *EbsVolumeSelect](ctx, evs.EbsVolumeQuery, evs, evs.inters, v)
}

func (evs *EbsVolumeSelect) sqlScan(ctx context.Context, root *EbsVolumeQuery, v any) error {
	selector := root.sqlQuery(ctx)
	aggregation := make([]string, 0, len(evs.fns))
	for _, fn := range evs.fns {
		aggregation = append(aggregation, fn(selector))
	}
	switch n := len(*evs.selector.flds); {
	case n == 0 && len(aggregation) > 0:
		selector.Select(aggregation...)
	case n != 0 && len(aggregation) > 0:
		selector.AppendSelect(aggregation...)
	}
	rows := &sql.Rows{}
	query, args := selector.Query()
	if err := evs.driver.Query(ctx, query, args, rows); err != nil {
		return err
	}
	defer rows.Close()
	return sql.ScanSlice(rows, v)
}

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/data/ent/blockstorage_create.go
```golang
// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"luban-cmdb-api/data/ent/blockstorage"
	"time"

	"entgo.io/ent/dialect/sql/sqlgraph"
	"entgo.io/ent/schema/field"
)

// BlockStorageCreate is the builder for creating a BlockStorage entity.
type BlockStorageCreate struct {
	config
	mutation *BlockStorageMutation
	hooks    []Hook
}

// SetName sets the "name" field.
func (bsc *BlockStorageCreate) SetName(s string) *BlockStorageCreate {
	bsc.mutation.SetName(s)
	return bsc
}

// SetInstanceID sets the "instance_id" field.
func (bsc *BlockStorageCreate) SetInstanceID(s string) *BlockStorageCreate {
	bsc.mutation.SetInstanceID(s)
	return bsc
}

// SetRegion sets the "region" field.
func (bsc *BlockStorageCreate) SetRegion(s string) *BlockStorageCreate {
	bsc.mutation.SetRegion(s)
	return bsc
}

// SetRegionCode sets the "region_code" field.
func (bsc *BlockStorageCreate) SetRegionCode(s string) *BlockStorageCreate {
	bsc.mutation.SetRegionCode(s)
	return bsc
}

// SetAz sets the "az" field.
func (bsc *BlockStorageCreate) SetAz(s string) *BlockStorageCreate {
	bsc.mutation.SetAz(s)
	return bsc
}

// SetAzCode sets the "az_code" field.
func (bsc *BlockStorageCreate) SetAzCode(s string) *BlockStorageCreate {
	bsc.mutation.SetAzCode(s)
	return bsc
}

// SetResourcePool sets the "resource_pool" field.
func (bsc *BlockStorageCreate) SetResourcePool(s string) *BlockStorageCreate {
	bsc.mutation.SetResourcePool(s)
	return bsc
}

// SetResourcePoolType sets the "resource_pool_type" field.
func (bsc *BlockStorageCreate) SetResourcePoolType(s string) *BlockStorageCreate {
	bsc.mutation.SetResourcePoolType(s)
	return bsc
}

// SetUseStatus sets the "use_status" field.
func (bsc *BlockStorageCreate) SetUseStatus(s string) *BlockStorageCreate {
	bsc.mutation.SetUseStatus(s)
	return bsc
}

// SetTenantID sets the "tenant_id" field.
func (bsc *BlockStorageCreate) SetTenantID(s string) *BlockStorageCreate {
	bsc.mutation.SetTenantID(s)
	return bsc
}

// SetTenantName sets the "tenant_name" field.
func (bsc *BlockStorageCreate) SetTenantName(s string) *BlockStorageCreate {
	bsc.mutation.SetTenantName(s)
	return bsc
}

// SetVM sets the "vm" field.
func (bsc *BlockStorageCreate) SetVM(s string) *BlockStorageCreate {
	bsc.mutation.SetVM(s)
	return bsc
}

// SetVMID sets the "vm_id" field.
func (bsc *BlockStorageCreate) SetVMID(s string) *BlockStorageCreate {
	bsc.mutation.SetVMID(s)
	return bsc
}

// SetCreateTime sets the "create_time" field.
func (bsc *BlockStorageCreate) SetCreateTime(i int) *BlockStorageCreate {
	bsc.mutation.SetCreateTime(i)
	return bsc
}

// SetSize sets the "size" field.
func (bsc *BlockStorageCreate) SetSize(i int32) *BlockStorageCreate {
	bsc.mutation.SetSize(i)
	return bsc
}

// SetMountPoint sets the "mount_point" field.
func (bsc *BlockStorageCreate) SetMountPoint(s string) *BlockStorageCreate {
	bsc.mutation.SetMountPoint(s)
	return bsc
}

// SetLastUpdateTime sets the "last_update_time" field.
func (bsc *BlockStorageCreate) SetLastUpdateTime(t time.Time) *BlockStorageCreate {
	bsc.mutation.SetLastUpdateTime(t)
	return bsc
}

// SetID sets the "id" field.
func (bsc *BlockStorageCreate) SetID(i int) *BlockStorageCreate {
	bsc.mutation.SetID(i)
	return bsc
}

// Mutation returns the BlockStorageMutation object of the builder.
func (bsc *BlockStorageCreate) Mutation() *BlockStorageMutation {
	return bsc.mutation
}

// Save creates the BlockStorage in the database.
func (bsc *BlockStorageCreate) Save(ctx context.Context) (*BlockStorage, error) {
	return withHooks[*BlockStorage, BlockStorageMutation](ctx, bsc.sqlSave, bsc.mutation, bsc.hooks)
}

// SaveX calls Save and panics if Save returns an error.
func (bsc *BlockStorageCreate) SaveX(ctx context.Context) *BlockStorage {
	v, err := bsc.Save(ctx)
	if err != nil {
		panic(err)
	}
	return v
}

// Exec executes the query.
func (bsc *BlockStorageCreate) Exec(ctx context.Context) error {
	_, err := bsc.Save(ctx)
	return err
}

// ExecX is like Exec, but panics if an error occurs.
func (bsc *BlockStorageCreate) ExecX(ctx context.Context) {
	if err := bsc.Exec(ctx); err != nil {
		panic(err)
	}
}

// check runs all checks and user-defined validators on the builder.
func (bsc *BlockStorageCreate) check() error {
	if _, ok := bsc.mutation.Name(); !ok {
		return &ValidationError{Name: "name", err: errors.New(`ent: missing required field "BlockStorage.name"`)}
	}
	if _, ok := bsc.mutation.InstanceID(); !ok {
		return &ValidationError{Name: "instance_id", err: errors.New(`ent: missing required field "BlockStorage.instance_id"`)}
	}
	if _, ok := bsc.mutation.Region(); !ok {
		return &ValidationError{Name: "region", err: errors.New(`ent: missing required field "BlockStorage.region"`)}
	}
	if _, ok := bsc.mutation.RegionCode(); !ok {
		return &ValidationError{Name: "region_code", err: errors.New(`ent: missing required field "BlockStorage.region_code"`)}
	}
	if _, ok := bsc.mutation.Az(); !ok {
		return &ValidationError{Name: "az", err: errors.New(`ent: missing required field "BlockStorage.az"`)}
	}
	if _, ok := bsc.mutation.AzCode(); !ok {
		return &ValidationError{Name: "az_code", err: errors.New(`ent: missing required field "BlockStorage.az_code"`)}
	}
	if _, ok := bsc.mutation.ResourcePool(); !ok {
		return &ValidationError{Name: "resource_pool", err: errors.New(`ent: missing required field "BlockStorage.resource_pool"`)}
	}
	if _, ok := bsc.mutation.ResourcePoolType(); !ok {
		return &ValidationError{Name: "resource_pool_type", err: errors.New(`ent: missing required field "BlockStorage.resource_pool_type"`)}
	}
	if _, ok := bsc.mutation.UseStatus(); !ok {
		return &ValidationError{Name: "use_status", err: errors.New(`ent: missing required field "BlockStorage.use_status"`)}
	}
	if _, ok := bsc.mutation.TenantID(); !ok {
		return &ValidationError{Name: "tenant_id", err: errors.New(`ent: missing required field "BlockStorage.tenant_id"`)}
	}
	if _, ok := bsc.mutation.TenantName(); !ok {
		return &ValidationError{Name: "tenant_name", err: errors.New(`ent: missing required field "BlockStorage.tenant_name"`)}
	}
	if _, ok := bsc.mutation.VM(); !ok {
		return &ValidationError{Name: "vm", err: errors.New(`ent: missing required field "BlockStorage.vm"`)}
	}
	if _, ok := bsc.mutation.VMID(); !ok {
		return &ValidationError{Name: "vm_id", err: errors.New(`ent: missing required field "BlockStorage.vm_id"`)}
	}
	if _, ok := bsc.mutation.CreateTime(); !ok {
		return &ValidationError{Name: "create_time", err: errors.New(`ent: missing required field "BlockStorage.create_time"`)}
	}
	if _, ok := bsc.mutation.Size(); !ok {
		return &ValidationError{Name: "size", err: errors.New(`ent: missing required field "BlockStorage.size"`)}
	}
	if _, ok := bsc.mutation.MountPoint(); !ok {
		return &ValidationError{Name: "mount_point", err: errors.New(`ent: missing required field "BlockStorage.mount_point"`)}
	}
	if _, ok := bsc.mutation.LastUpdateTime(); !ok {
		return &ValidationError{Name: "last_update_time", err: errors.New(`ent: missing required field "BlockStorage.last_update_time"`)}
	}
	return nil
}

func (bsc *BlockStorageCreate) sqlSave(ctx context.Context) (*BlockStorage, error) {
	if err := bsc.check(); err != nil {
		return nil, err
	}
	_node, _spec := bsc.createSpec()
	if err := sqlgraph.CreateNode(ctx, bsc.driver, _spec); err != nil {
		if sqlgraph.IsConstraintError(err) {
			err = &ConstraintError{msg: err.Error(), wrap: err}
		}
		return nil, err
	}
	if _spec.ID.Value != _node.ID {
		id := _spec.ID.Value.(int64)
		_node.ID = int(id)
	}
	bsc.mutation.id = &_node.ID
	bsc.mutation.done = true
	return _node, nil
}

func (bsc *BlockStorageCreate) createSpec() (*BlockStorage, *sqlgraph.CreateSpec) {
	var (
		_node = &BlockStorage{config: bsc.config}
		_spec = sqlgraph.NewCreateSpec(blockstorage.Table, sqlgraph.NewFieldSpec(blockstorage.FieldID, field.TypeInt))
	)
	if id, ok := bsc.mutation.ID(); ok {
		_node.ID = id
		_spec.ID.Value = id
	}
	if value, ok := bsc.mutation.Name(); ok {
		_spec.SetField(blockstorage.FieldName, field.TypeString, value)
		_node.Name = value
	}
	if value, ok := bsc.mutation.InstanceID(); ok {
		_spec.SetField(blockstorage.FieldInstanceID, field.TypeString, value)
		_node.InstanceID = value
	}
	if value, ok := bsc.mutation.Region(); ok {
		_spec.SetField(blockstorage.FieldRegion, field.TypeString, value)
		_node.Region = value
	}
	if value, ok := bsc.mutation.RegionCode(); ok {
		_spec.SetField(blockstorage.FieldRegionCode, field.TypeString, value)
		_node.RegionCode = value
	}
	if value, ok := bsc.mutation.Az(); ok {
		_spec.SetField(blockstorage.FieldAz, field.TypeString, value)
		_node.Az = value
	}
	if value, ok := bsc.mutation.AzCode(); ok {
		_spec.SetField(blockstorage.FieldAzCode, field.TypeString, value)
		_node.AzCode = value
	}
	if value, ok := bsc.mutation.ResourcePool(); ok {
		_spec.SetField(blockstorage.FieldResourcePool, field.TypeString, value)
		_node.ResourcePool = value
	}
	if value, ok := bsc.mutation.ResourcePoolType(); ok {
		_spec.SetField(blockstorage.FieldResourcePoolType, field.TypeString, value)
		_node.ResourcePoolType = value
	}
	if value, ok := bsc.mutation.UseStatus(); ok {
		_spec.SetField(blockstorage.FieldUseStatus, field.TypeString, value)
		_node.UseStatus = value
	}
	if value, ok := bsc.mutation.TenantID(); ok {
		_spec.SetField(blockstorage.FieldTenantID, field.TypeString, value)
		_node.TenantID = value
	}
	if value, ok := bsc.mutation.TenantName(); ok {
		_spec.SetField(blockstorage.FieldTenantName, field.TypeString, value)
		_node.TenantName = value
	}
	if value, ok := bsc.mutation.VM(); ok {
		_spec.SetField(blockstorage.FieldVM, field.TypeString, value)
		_node.VM = value
	}
	if value, ok := bsc.mutation.VMID(); ok {
		_spec.SetField(blockstorage.FieldVMID, field.TypeString, value)
		_node.VMID = value
	}
	if value, ok := bsc.mutation.CreateTime(); ok {
		_spec.SetField(blockstorage.FieldCreateTime, field.TypeInt, value)
		_node.CreateTime = value
	}
	if value, ok := bsc.mutation.Size(); ok {
		_spec.SetField(blockstorage.FieldSize, field.TypeInt32, value)
		_node.Size = value
	}
	if value, ok := bsc.mutation.MountPoint(); ok {
		_spec.SetField(blockstorage.FieldMountPoint, field.TypeString, value)
		_node.MountPoint = value
	}
	if value, ok := bsc.mutation.LastUpdateTime(); ok {
		_spec.SetField(blockstorage.FieldLastUpdateTime, field.TypeTime, value)
		_node.LastUpdateTime = value
	}
	return _node, _spec
}

// BlockStorageCreateBulk is the builder for creating many BlockStorage entities in bulk.
type BlockStorageCreateBulk struct {
	config
	builders []*BlockStorageCreate
}

// Save creates the BlockStorage entities in the database.
func (bscb *BlockStorageCreateBulk) Save(ctx context.Context) ([]*BlockStorage, error) {
	specs := make([]*sqlgraph.CreateSpec, len(bscb.builders))
	nodes := make([]*BlockStorage, len(bscb.builders))
	mutators := make([]Mutator, len(bscb.builders))
	for i := range bscb.builders {
		func(i int, root context.Context) {
			builder := bscb.builders[i]
			var mut Mutator = MutateFunc(func(ctx context.Context, m Mutation) (Value, error) {
				mutation, ok := m.(*BlockStorageMutation)
				if !ok {
					return nil, fmt.Errorf("unexpected mutation type %T", m)
				}
				if err := builder.check(); err != nil {
					return nil, err
				}
				builder.mutation = mutation
				nodes[i], specs[i] = builder.createSpec()
				var err error
				if i < len(mutators)-1 {
					_, err = mutators[i+1].Mutate(root, bscb.builders[i+1].mutation)
				} else {
					spec := &sqlgraph.BatchCreateSpec{Nodes: specs}
					// Invoke the actual operation on the latest mutation in the chain.
					if err = sqlgraph.BatchCreate(ctx, bscb.driver, spec); err != nil {
						if sqlgraph.IsConstraintError(err) {
							err = &ConstraintError{msg: err.Error(), wrap: err}
						}
					}
				}
				if err != nil {
					return nil, err
				}
				mutation.id = &nodes[i].ID
				if specs[i].ID.Value != nil && nodes[i].ID == 0 {
					id := specs[i].ID.Value.(int64)
					nodes[i].ID = int(id)
				}
				mutation.done = true
				return nodes[i], nil
			})
			for i := len(builder.hooks) - 1; i >= 0; i-- {
				mut = builder.hooks[i](mut)
			}
			mutators[i] = mut
		}(i, ctx)
	}
	if len(mutators) > 0 {
		if _, err := mutators[0].Mutate(ctx, bscb.builders[0].mutation); err != nil {
			return nil, err
		}
	}
	return nodes, nil
}

// SaveX is like Save, but panics if an error occurs.
func (bscb *BlockStorageCreateBulk) SaveX(ctx context.Context) []*BlockStorage {
	v, err := bscb.Save(ctx)
	if err != nil {
		panic(err)
	}
	return v
}

// Exec executes the query.
func (bscb *BlockStorageCreateBulk) Exec(ctx context.Context) error {
	_, err := bscb.Save(ctx)
	return err
}

// ExecX is like Exec, but panics if an error occurs.
func (bscb *BlockStorageCreateBulk) ExecX(ctx context.Context) {
	if err := bscb.Exec(ctx); err != nil {
		panic(err)
	}
}

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/data/ent/objectstorage.go
```golang
// Code generated by ent, DO NOT EDIT.

package ent

import (
	"fmt"
	"luban-cmdb-api/data/ent/objectstorage"
	"strings"
	"time"

	"entgo.io/ent/dialect/sql"
)

// ObjectStorage is the model entity for the ObjectStorage schema.
type ObjectStorage struct {
	config `json:"-"`
	// ID of the ent.
	ID string `json:"id,omitempty"`
	// Name holds the value of the "name" field.
	Name string `json:"name,omitempty"`
	// Size holds the value of the "size" field.
	Size int `json:"size,omitempty"`
	// StorageType holds the value of the "storage_type" field.
	StorageType string `json:"storage_type,omitempty"`
	// Region holds the value of the "region" field.
	Region string `json:"region,omitempty"`
	// RegionCode holds the value of the "region_code" field.
	RegionCode string `json:"region_code,omitempty"`
	// Az holds the value of the "az" field.
	Az string `json:"az,omitempty"`
	// AzCode holds the value of the "az_code" field.
	AzCode string `json:"az_code,omitempty"`
	// TenantID holds the value of the "tenant_id" field.
	TenantID string `json:"tenant_id,omitempty"`
	// TenantName holds the value of the "tenant_name" field.
	TenantName string `json:"tenant_name,omitempty"`
	// InnerDomainName holds the value of the "inner_domain_name" field.
	InnerDomainName string `json:"inner_domain_name,omitempty"`
	// OuterDomainName holds the value of the "outer_domain_name" field.
	OuterDomainName string `json:"outer_domain_name,omitempty"`
	// CreateTime holds the value of the "create_time" field.
	CreateTime int `json:"create_time,omitempty"`
	// Policy holds the value of the "policy" field.
	Policy string `json:"policy,omitempty"`
	// BucketDomains holds the value of the "bucket_domains" field.
	BucketDomains string `json:"bucket_domains,omitempty"`
	// ResourcePoolID holds the value of the "resource_pool_id" field.
	ResourcePoolID int `json:"resource_pool_id,omitempty"`
	// ResourcePoolName holds the value of the "resource_pool_name" field.
	ResourcePoolName string `json:"resource_pool_name,omitempty"`
	// ObjectCount holds the value of the "object_count" field.
	ObjectCount int `json:"object_count,omitempty"`
	// CurrentSize holds the value of the "current_size" field.
	CurrentSize int `json:"current_size,omitempty"`
	// Last30DayDownload holds the value of the "last30_day_download" field.
	Last30DayDownload int `json:"last30_day_download,omitempty"`
	// Last30DayAPICallTimes holds the value of the "last30_day_api_call_times" field.
	Last30DayAPICallTimes int `json:"last30_day_api_call_times,omitempty"`
	// LastUpdateTime holds the value of the "last_update_time" field.
	LastUpdateTime time.Time `json:"last_update_time,omitempty"`
}

// scanValues returns the types for scanning values from sql.Rows.
func (*ObjectStorage) scanValues(columns []string) ([]any, error) {
	values := make([]any, len(columns))
	for i := range columns {
		switch columns[i] {
		case objectstorage.FieldSize, objectstorage.FieldCreateTime, objectstorage.FieldResourcePoolID, objectstorage.FieldObjectCount, objectstorage.FieldCurrentSize, objectstorage.FieldLast30DayDownload, objectstorage.FieldLast30DayAPICallTimes:
			values[i] = new(sql.NullInt64)
		case objectstorage.FieldID, objectstorage.FieldName, objectstorage.FieldStorageType, objectstorage.FieldRegion, objectstorage.FieldRegionCode, objectstorage.FieldAz, objectstorage.FieldAzCode, objectstorage.FieldTenantID, objectstorage.FieldTenantName, objectstorage.FieldInnerDomainName, objectstorage.FieldOuterDomainName, objectstorage.FieldPolicy, objectstorage.FieldBucketDomains, objectstorage.FieldResourcePoolName:
			values[i] = new(sql.NullString)
		case objectstorage.FieldLastUpdateTime:
			values[i] = new(sql.NullTime)
		default:
			return nil, fmt.Errorf("unexpected column %q for type ObjectStorage", columns[i])
		}
	}
	return values, nil
}

// assignValues assigns the values that were returned from sql.Rows (after scanning)
// to the ObjectStorage fields.
func (os *ObjectStorage) assignValues(columns []string, values []any) error {
	if m, n := len(values), len(columns); m < n {
		return fmt.Errorf("mismatch number of scan values: %d != %d", m, n)
	}
	for i := range columns {
		switch columns[i] {
		case objectstorage.FieldID:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field id", values[i])
			} else if value.Valid {
				os.ID = value.String
			}
		case objectstorage.FieldName:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field name", values[i])
			} else if value.Valid {
				os.Name = value.String
			}
		case objectstorage.FieldSize:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field size", values[i])
			} else if value.Valid {
				os.Size = int(value.Int64)
			}
		case objectstorage.FieldStorageType:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field storage_type", values[i])
			} else if value.Valid {
				os.StorageType = value.String
			}
		case objectstorage.FieldRegion:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field region", values[i])
			} else if value.Valid {
				os.Region = value.String
			}
		case objectstorage.FieldRegionCode:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field region_code", values[i])
			} else if value.Valid {
				os.RegionCode = value.String
			}
		case objectstorage.FieldAz:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field az", values[i])
			} else if value.Valid {
				os.Az = value.String
			}
		case objectstorage.FieldAzCode:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field az_code", values[i])
			} else if value.Valid {
				os.AzCode = value.String
			}
		case objectstorage.FieldTenantID:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field tenant_id", values[i])
			} else if value.Valid {
				os.TenantID = value.String
			}
		case objectstorage.FieldTenantName:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field tenant_name", values[i])
			} else if value.Valid {
				os.TenantName = value.String
			}
		case objectstorage.FieldInnerDomainName:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field inner_domain_name", values[i])
			} else if value.Valid {
				os.InnerDomainName = value.String
			}
		case objectstorage.FieldOuterDomainName:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field outer_domain_name", values[i])
			} else if value.Valid {
				os.OuterDomainName = value.String
			}
		case objectstorage.FieldCreateTime:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field create_time", values[i])
			} else if value.Valid {
				os.CreateTime = int(value.Int64)
			}
		case objectstorage.FieldPolicy:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field policy", values[i])
			} else if value.Valid {
				os.Policy = value.String
			}
		case objectstorage.FieldBucketDomains:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field bucket_domains", values[i])
			} else if value.Valid {
				os.BucketDomains = value.String
			}
		case objectstorage.FieldResourcePoolID:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field resource_pool_id", values[i])
			} else if value.Valid {
				os.ResourcePoolID = int(value.Int64)
			}
		case objectstorage.FieldResourcePoolName:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field resource_pool_name", values[i])
			} else if value.Valid {
				os.ResourcePoolName = value.String
			}
		case objectstorage.FieldObjectCount:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field object_count", values[i])
			} else if value.Valid {
				os.ObjectCount = int(value.Int64)
			}
		case objectstorage.FieldCurrentSize:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field current_size", values[i])
			} else if value.Valid {
				os.CurrentSize = int(value.Int64)
			}
		case objectstorage.FieldLast30DayDownload:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field last30_day_download", values[i])
			} else if value.Valid {
				os.Last30DayDownload = int(value.Int64)
			}
		case objectstorage.FieldLast30DayAPICallTimes:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field last30_day_api_call_times", values[i])
			} else if value.Valid {
				os.Last30DayAPICallTimes = int(value.Int64)
			}
		case objectstorage.FieldLastUpdateTime:
			if value, ok := values[i].(*sql.NullTime); !ok {
				return fmt.Errorf("unexpected type %T for field last_update_time", values[i])
			} else if value.Valid {
				os.LastUpdateTime = value.Time
			}
		}
	}
	return nil
}

// Update returns a builder for updating this ObjectStorage.
// Note that you need to call ObjectStorage.Unwrap() before calling this method if this ObjectStorage
// was returned from a transaction, and the transaction was committed or rolled back.
func (os *ObjectStorage) Update() *ObjectStorageUpdateOne {
	return NewObjectStorageClient(os.config).UpdateOne(os)
}

// Unwrap unwraps the ObjectStorage entity that was returned from a transaction after it was closed,
// so that all future queries will be executed through the driver which created the transaction.
func (os *ObjectStorage) Unwrap() *ObjectStorage {
	_tx, ok := os.config.driver.(*txDriver)
	if !ok {
		panic("ent: ObjectStorage is not a transactional entity")
	}
	os.config.driver = _tx.drv
	return os
}

// String implements the fmt.Stringer.
func (os *ObjectStorage) String() string {
	var builder strings.Builder
	builder.WriteString("ObjectStorage(")
	builder.WriteString(fmt.Sprintf("id=%v, ", os.ID))
	builder.WriteString("name=")
	builder.WriteString(os.Name)
	builder.WriteString(", ")
	builder.WriteString("size=")
	builder.WriteString(fmt.Sprintf("%v", os.Size))
	builder.WriteString(", ")
	builder.WriteString("storage_type=")
	builder.WriteString(os.StorageType)
	builder.WriteString(", ")
	builder.WriteString("region=")
	builder.WriteString(os.Region)
	builder.WriteString(", ")
	builder.WriteString("region_code=")
	builder.WriteString(os.RegionCode)
	builder.WriteString(", ")
	builder.WriteString("az=")
	builder.WriteString(os.Az)
	builder.WriteString(", ")
	builder.WriteString("az_code=")
	builder.WriteString(os.AzCode)
	builder.WriteString(", ")
	builder.WriteString("tenant_id=")
	builder.WriteString(os.TenantID)
	builder.WriteString(", ")
	builder.WriteString("tenant_name=")
	builder.WriteString(os.TenantName)
	builder.WriteString(", ")
	builder.WriteString("inner_domain_name=")
	builder.WriteString(os.InnerDomainName)
	builder.WriteString(", ")
	builder.WriteString("outer_domain_name=")
	builder.WriteString(os.OuterDomainName)
	builder.WriteString(", ")
	builder.WriteString("create_time=")
	builder.WriteString(fmt.Sprintf("%v", os.CreateTime))
	builder.WriteString(", ")
	builder.WriteString("policy=")
	builder.WriteString(os.Policy)
	builder.WriteString(", ")
	builder.WriteString("bucket_domains=")
	builder.WriteString(os.BucketDomains)
	builder.WriteString(", ")
	builder.WriteString("resource_pool_id=")
	builder.WriteString(fmt.Sprintf("%v", os.ResourcePoolID))
	builder.WriteString(", ")
	builder.WriteString("resource_pool_name=")
	builder.WriteString(os.ResourcePoolName)
	builder.WriteString(", ")
	builder.WriteString("object_count=")
	builder.WriteString(fmt.Sprintf("%v", os.ObjectCount))
	builder.WriteString(", ")
	builder.WriteString("current_size=")
	builder.WriteString(fmt.Sprintf("%v", os.CurrentSize))
	builder.WriteString(", ")
	builder.WriteString("last30_day_download=")
	builder.WriteString(fmt.Sprintf("%v", os.Last30DayDownload))
	builder.WriteString(", ")
	builder.WriteString("last30_day_api_call_times=")
	builder.WriteString(fmt.Sprintf("%v", os.Last30DayAPICallTimes))
	builder.WriteString(", ")
	builder.WriteString("last_update_time=")
	builder.WriteString(os.LastUpdateTime.Format(time.ANSIC))
	builder.WriteByte(')')
	return builder.String()
}

// ObjectStorages is a parsable slice of ObjectStorage.
type ObjectStorages []*ObjectStorage

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/data/ent/ebsvolume_create.go
```golang
// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"luban-cmdb-api/data/ent/ebsvolume"
	"time"

	"entgo.io/ent/dialect/sql/sqlgraph"
	"entgo.io/ent/schema/field"
)

// EbsVolumeCreate is the builder for creating a EbsVolume entity.
type EbsVolumeCreate struct {
	config
	mutation *EbsVolumeMutation
	hooks    []Hook
}

// SetGalaxy sets the "galaxy" field.
func (evc *EbsVolumeCreate) SetGalaxy(s string) *EbsVolumeCreate {
	evc.mutation.SetGalaxy(s)
	return evc
}

// SetNillableGalaxy sets the "galaxy" field if the given value is not nil.
func (evc *EbsVolumeCreate) SetNillableGalaxy(s *string) *EbsVolumeCreate {
	if s != nil {
		evc.SetGalaxy(*s)
	}
	return evc
}

// SetRegion sets the "region" field.
func (evc *EbsVolumeCreate) SetRegion(s string) *EbsVolumeCreate {
	evc.mutation.SetRegion(s)
	return evc
}

// SetAz sets the "az" field.
func (evc *EbsVolumeCreate) SetAz(s string) *EbsVolumeCreate {
	evc.mutation.SetAz(s)
	return evc
}

// SetNillableAz sets the "az" field if the given value is not nil.
func (evc *EbsVolumeCreate) SetNillableAz(s *string) *EbsVolumeCreate {
	if s != nil {
		evc.SetAz(*s)
	}
	return evc
}

// SetCreatedAt sets the "created_at" field.
func (evc *EbsVolumeCreate) SetCreatedAt(t time.Time) *EbsVolumeCreate {
	evc.mutation.SetCreatedAt(t)
	return evc
}

// SetNillableCreatedAt sets the "created_at" field if the given value is not nil.
func (evc *EbsVolumeCreate) SetNillableCreatedAt(t *time.Time) *EbsVolumeCreate {
	if t != nil {
		evc.SetCreatedAt(*t)
	}
	return evc
}

// SetUpdatedAt sets the "updated_at" field.
func (evc *EbsVolumeCreate) SetUpdatedAt(t time.Time) *EbsVolumeCreate {
	evc.mutation.SetUpdatedAt(t)
	return evc
}

// SetVersion sets the "version" field.
func (evc *EbsVolumeCreate) SetVersion(s string) *EbsVolumeCreate {
	evc.mutation.SetVersion(s)
	return evc
}

// SetNillableVersion sets the "version" field if the given value is not nil.
func (evc *EbsVolumeCreate) SetNillableVersion(s *string) *EbsVolumeCreate {
	if s != nil {
		evc.SetVersion(*s)
	}
	return evc
}

// SetVolumeID sets the "volume_id" field.
func (evc *EbsVolumeCreate) SetVolumeID(s string) *EbsVolumeCreate {
	evc.mutation.SetVolumeID(s)
	return evc
}

// SetNillableVolumeID sets the "volume_id" field if the given value is not nil.
func (evc *EbsVolumeCreate) SetNillableVolumeID(s *string) *EbsVolumeCreate {
	if s != nil {
		evc.SetVolumeID(*s)
	}
	return evc
}

// SetName sets the "name" field.
func (evc *EbsVolumeCreate) SetName(s string) *EbsVolumeCreate {
	evc.mutation.SetName(s)
	return evc
}

// SetPoolID sets the "pool_id" field.
func (evc *EbsVolumeCreate) SetPoolID(s string) *EbsVolumeCreate {
	evc.mutation.SetPoolID(s)
	return evc
}

// SetNillablePoolID sets the "pool_id" field if the given value is not nil.
func (evc *EbsVolumeCreate) SetNillablePoolID(s *string) *EbsVolumeCreate {
	if s != nil {
		evc.SetPoolID(*s)
	}
	return evc
}

// SetPoolName sets the "pool_name" field.
func (evc *EbsVolumeCreate) SetPoolName(s string) *EbsVolumeCreate {
	evc.mutation.SetPoolName(s)
	return evc
}

// SetNillablePoolName sets the "pool_name" field if the given value is not nil.
func (evc *EbsVolumeCreate) SetNillablePoolName(s *string) *EbsVolumeCreate {
	if s != nil {
		evc.SetPoolName(*s)
	}
	return evc
}

// SetSize sets the "size" field.
func (evc *EbsVolumeCreate) SetSize(i int32) *EbsVolumeCreate {
	evc.mutation.SetSize(i)
	return evc
}

// SetNillableSize sets the "size" field if the given value is not nil.
func (evc *EbsVolumeCreate) SetNillableSize(i *int32) *EbsVolumeCreate {
	if i != nil {
		evc.SetSize(*i)
	}
	return evc
}

// SetStatus sets the "status" field.
func (evc *EbsVolumeCreate) SetStatus(s string) *EbsVolumeCreate {
	evc.mutation.SetStatus(s)
	return evc
}

// SetNillableStatus sets the "status" field if the given value is not nil.
func (evc *EbsVolumeCreate) SetNillableStatus(s *string) *EbsVolumeCreate {
	if s != nil {
		evc.SetStatus(*s)
	}
	return evc
}

// SetStatusName sets the "status_name" field.
func (evc *EbsVolumeCreate) SetStatusName(s string) *EbsVolumeCreate {
	evc.mutation.SetStatusName(s)
	return evc
}

// SetNillableStatusName sets the "status_name" field if the given value is not nil.
func (evc *EbsVolumeCreate) SetNillableStatusName(s *string) *EbsVolumeCreate {
	if s != nil {
		evc.SetStatusName(*s)
	}
	return evc
}

// SetVolumeType sets the "volume_type" field.
func (evc *EbsVolumeCreate) SetVolumeType(s string) *EbsVolumeCreate {
	evc.mutation.SetVolumeType(s)
	return evc
}

// SetNillableVolumeType sets the "volume_type" field if the given value is not nil.
func (evc *EbsVolumeCreate) SetNillableVolumeType(s *string) *EbsVolumeCreate {
	if s != nil {
		evc.SetVolumeType(*s)
	}
	return evc
}

// SetVMID sets the "vm_id" field.
func (evc *EbsVolumeCreate) SetVMID(s string) *EbsVolumeCreate {
	evc.mutation.SetVMID(s)
	return evc
}

// SetVMName sets the "vm_name" field.
func (evc *EbsVolumeCreate) SetVMName(s string) *EbsVolumeCreate {
	evc.mutation.SetVMName(s)
	return evc
}

// SetTenantID sets the "tenant_id" field.
func (evc *EbsVolumeCreate) SetTenantID(s string) *EbsVolumeCreate {
	evc.mutation.SetTenantID(s)
	return evc
}

// SetNillableTenantID sets the "tenant_id" field if the given value is not nil.
func (evc *EbsVolumeCreate) SetNillableTenantID(s *string) *EbsVolumeCreate {
	if s != nil {
		evc.SetTenantID(*s)
	}
	return evc
}

// SetTenantName sets the "tenant_name" field.
func (evc *EbsVolumeCreate) SetTenantName(s string) *EbsVolumeCreate {
	evc.mutation.SetTenantName(s)
	return evc
}

// SetNillableTenantName sets the "tenant_name" field if the given value is not nil.
func (evc *EbsVolumeCreate) SetNillableTenantName(s *string) *EbsVolumeCreate {
	if s != nil {
		evc.SetTenantName(*s)
	}
	return evc
}

// SetProjectID sets the "project_id" field.
func (evc *EbsVolumeCreate) SetProjectID(s string) *EbsVolumeCreate {
	evc.mutation.SetProjectID(s)
	return evc
}

// SetProjectName sets the "project_name" field.
func (evc *EbsVolumeCreate) SetProjectName(s string) *EbsVolumeCreate {
	evc.mutation.SetProjectName(s)
	return evc
}

// SetCreateTime sets the "create_time" field.
func (evc *EbsVolumeCreate) SetCreateTime(t time.Time) *EbsVolumeCreate {
	evc.mutation.SetCreateTime(t)
	return evc
}

// SetNillableCreateTime sets the "create_time" field if the given value is not nil.
func (evc *EbsVolumeCreate) SetNillableCreateTime(t *time.Time) *EbsVolumeCreate {
	if t != nil {
		evc.SetCreateTime(*t)
	}
	return evc
}

// SetServiceEndTime sets the "service_end_time" field.
func (evc *EbsVolumeCreate) SetServiceEndTime(t time.Time) *EbsVolumeCreate {
	evc.mutation.SetServiceEndTime(t)
	return evc
}

// SetNillableServiceEndTime sets the "service_end_time" field if the given value is not nil.
func (evc *EbsVolumeCreate) SetNillableServiceEndTime(t *time.Time) *EbsVolumeCreate {
	if t != nil {
		evc.SetServiceEndTime(*t)
	}
	return evc
}

// SetDeleted sets the "deleted" field.
func (evc *EbsVolumeCreate) SetDeleted(b bool) *EbsVolumeCreate {
	evc.mutation.SetDeleted(b)
	return evc
}

// SetNillableDeleted sets the "deleted" field if the given value is not nil.
func (evc *EbsVolumeCreate) SetNillableDeleted(b *bool) *EbsVolumeCreate {
	if b != nil {
		evc.SetDeleted(*b)
	}
	return evc
}

// SetID sets the "id" field.
func (evc *EbsVolumeCreate) SetID(i int) *EbsVolumeCreate {
	evc.mutation.SetID(i)
	return evc
}

// Mutation returns the EbsVolumeMutation object of the builder.
func (evc *EbsVolumeCreate) Mutation() *EbsVolumeMutation {
	return evc.mutation
}

// Save creates the EbsVolume in the database.
func (evc *EbsVolumeCreate) Save(ctx context.Context) (*EbsVolume, error) {
	return withHooks[*EbsVolume, EbsVolumeMutation](ctx, evc.sqlSave, evc.mutation, evc.hooks)
}

// SaveX calls Save and panics if Save returns an error.
func (evc *EbsVolumeCreate) SaveX(ctx context.Context) *EbsVolume {
	v, err := evc.Save(ctx)
	if err != nil {
		panic(err)
	}
	return v
}

// Exec executes the query.
func (evc *EbsVolumeCreate) Exec(ctx context.Context) error {
	_, err := evc.Save(ctx)
	return err
}

// ExecX is like Exec, but panics if an error occurs.
func (evc *EbsVolumeCreate) ExecX(ctx context.Context) {
	if err := evc.Exec(ctx); err != nil {
		panic(err)
	}
}

// check runs all checks and user-defined validators on the builder.
func (evc *EbsVolumeCreate) check() error {
	if _, ok := evc.mutation.Region(); !ok {
		return &ValidationError{Name: "region", err: errors.New(`ent: missing required field "EbsVolume.region"`)}
	}
	if _, ok := evc.mutation.UpdatedAt(); !ok {
		return &ValidationError{Name: "updated_at", err: errors.New(`ent: missing required field "EbsVolume.updated_at"`)}
	}
	if _, ok := evc.mutation.Name(); !ok {
		return &ValidationError{Name: "name", err: errors.New(`ent: missing required field "EbsVolume.name"`)}
	}
	if _, ok := evc.mutation.VMID(); !ok {
		return &ValidationError{Name: "vm_id", err: errors.New(`ent: missing required field "EbsVolume.vm_id"`)}
	}
	if _, ok := evc.mutation.VMName(); !ok {
		return &ValidationError{Name: "vm_name", err: errors.New(`ent: missing required field "EbsVolume.vm_name"`)}
	}
	if _, ok := evc.mutation.ProjectID(); !ok {
		return &ValidationError{Name: "project_id", err: errors.New(`ent: missing required field "EbsVolume.project_id"`)}
	}
	if _, ok := evc.mutation.ProjectName(); !ok {
		return &ValidationError{Name: "project_name", err: errors.New(`ent: missing required field "EbsVolume.project_name"`)}
	}
	return nil
}

func (evc *EbsVolumeCreate) sqlSave(ctx context.Context) (*EbsVolume, error) {
	if err := evc.check(); err != nil {
		return nil, err
	}
	_node, _spec := evc.createSpec()
	if err := sqlgraph.CreateNode(ctx, evc.driver, _spec); err != nil {
		if sqlgraph.IsConstraintError(err) {
			err = &ConstraintError{msg: err.Error(), wrap: err}
		}
		return nil, err
	}
	if _spec.ID.Value != _node.ID {
		id := _spec.ID.Value.(int64)
		_node.ID = int(id)
	}
	evc.mutation.id = &_node.ID
	evc.mutation.done = true
	return _node, nil
}

func (evc *EbsVolumeCreate) createSpec() (*EbsVolume, *sqlgraph.CreateSpec) {
	var (
		_node = &EbsVolume{config: evc.config}
		_spec = sqlgraph.NewCreateSpec(ebsvolume.Table, sqlgraph.NewFieldSpec(ebsvolume.FieldID, field.TypeInt))
	)
	if id, ok := evc.mutation.ID(); ok {
		_node.ID = id
		_spec.ID.Value = id
	}
	if value, ok := evc.mutation.Galaxy(); ok {
		_spec.SetField(ebsvolume.FieldGalaxy, field.TypeString, value)
		_node.Galaxy = value
	}
	if value, ok := evc.mutation.Region(); ok {
		_spec.SetField(ebsvolume.FieldRegion, field.TypeString, value)
		_node.Region = value
	}
	if value, ok := evc.mutation.Az(); ok {
		_spec.SetField(ebsvolume.FieldAz, field.TypeString, value)
		_node.Az = value
	}
	if value, ok := evc.mutation.CreatedAt(); ok {
		_spec.SetField(ebsvolume.FieldCreatedAt, field.TypeTime, value)
		_node.CreatedAt = value
	}
	if value, ok := evc.mutation.UpdatedAt(); ok {
		_spec.SetField(ebsvolume.FieldUpdatedAt, field.TypeTime, value)
		_node.UpdatedAt = value
	}
	if value, ok := evc.mutation.Version(); ok {
		_spec.SetField(ebsvolume.FieldVersion, field.TypeString, value)
		_node.Version = value
	}
	if value, ok := evc.mutation.VolumeID(); ok {
		_spec.SetField(ebsvolume.FieldVolumeID, field.TypeString, value)
		_node.VolumeID = value
	}
	if value, ok := evc.mutation.Name(); ok {
		_spec.SetField(ebsvolume.FieldName, field.TypeString, value)
		_node.Name = value
	}
	if value, ok := evc.mutation.PoolID(); ok {
		_spec.SetField(ebsvolume.FieldPoolID, field.TypeString, value)
		_node.PoolID = value
	}
	if value, ok := evc.mutation.PoolName(); ok {
		_spec.SetField(ebsvolume.FieldPoolName, field.TypeString, value)
		_node.PoolName = value
	}
	if value, ok := evc.mutation.Size(); ok {
		_spec.SetField(ebsvolume.FieldSize, field.TypeInt32, value)
		_node.Size = value
	}
	if value, ok := evc.mutation.Status(); ok {
		_spec.SetField(ebsvolume.FieldStatus, field.TypeString, value)
		_node.Status = value
	}
	if value, ok := evc.mutation.StatusName(); ok {
		_spec.SetField(ebsvolume.FieldStatusName, field.TypeString, value)
		_node.StatusName = value
	}
	if value, ok := evc.mutation.VolumeType(); ok {
		_spec.SetField(ebsvolume.FieldVolumeType, field.TypeString, value)
		_node.VolumeType = value
	}
	if value, ok := evc.mutation.VMID(); ok {
		_spec.SetField(ebsvolume.FieldVMID, field.TypeString, value)
		_node.VMID = value
	}
	if value, ok := evc.mutation.VMName(); ok {
		_spec.SetField(ebsvolume.FieldVMName, field.TypeString, value)
		_node.VMName = value
	}
	if value, ok := evc.mutation.TenantID(); ok {
		_spec.SetField(ebsvolume.FieldTenantID, field.TypeString, value)
		_node.TenantID = value
	}
	if value, ok := evc.mutation.TenantName(); ok {
		_spec.SetField(ebsvolume.FieldTenantName, field.TypeString, value)
		_node.TenantName = value
	}
	if value, ok := evc.mutation.ProjectID(); ok {
		_spec.SetField(ebsvolume.FieldProjectID, field.TypeString, value)
		_node.ProjectID = value
	}
	if value, ok := evc.mutation.ProjectName(); ok {
		_spec.SetField(ebsvolume.FieldProjectName, field.TypeString, value)
		_node.ProjectName = value
	}
	if value, ok := evc.mutation.CreateTime(); ok {
		_spec.SetField(ebsvolume.FieldCreateTime, field.TypeTime, value)
		_node.CreateTime = value
	}
	if value, ok := evc.mutation.ServiceEndTime(); ok {
		_spec.SetField(ebsvolume.FieldServiceEndTime, field.TypeTime, value)
		_node.ServiceEndTime = value
	}
	if value, ok := evc.mutation.Deleted(); ok {
		_spec.SetField(ebsvolume.FieldDeleted, field.TypeBool, value)
		_node.Deleted = value
	}
	return _node, _spec
}

// EbsVolumeCreateBulk is the builder for creating many EbsVolume entities in bulk.
type EbsVolumeCreateBulk struct {
	config
	builders []*EbsVolumeCreate
}

// Save creates the EbsVolume entities in the database.
func (evcb *EbsVolumeCreateBulk) Save(ctx context.Context) ([]*EbsVolume, error) {
	specs := make([]*sqlgraph.CreateSpec, len(evcb.builders))
	nodes := make([]*EbsVolume, len(evcb.builders))
	mutators := make([]Mutator, len(evcb.builders))
	for i := range evcb.builders {
		func(i int, root context.Context) {
			builder := evcb.builders[i]
			var mut Mutator = MutateFunc(func(ctx context.Context, m Mutation) (Value, error) {
				mutation, ok := m.(*EbsVolumeMutation)
				if !ok {
					return nil, fmt.Errorf("unexpected mutation type %T", m)
				}
				if err := builder.check(); err != nil {
					return nil, err
				}
				builder.mutation = mutation
				nodes[i], specs[i] = builder.createSpec()
				var err error
				if i < len(mutators)-1 {
					_, err = mutators[i+1].Mutate(root, evcb.builders[i+1].mutation)
				} else {
					spec := &sqlgraph.BatchCreateSpec{Nodes: specs}
					// Invoke the actual operation on the latest mutation in the chain.
					if err = sqlgraph.BatchCreate(ctx, evcb.driver, spec); err != nil {
						if sqlgraph.IsConstraintError(err) {
							err = &ConstraintError{msg: err.Error(), wrap: err}
						}
					}
				}
				if err != nil {
					return nil, err
				}
				mutation.id = &nodes[i].ID
				if specs[i].ID.Value != nil && nodes[i].ID == 0 {
					id := specs[i].ID.Value.(int64)
					nodes[i].ID = int(id)
				}
				mutation.done = true
				return nodes[i], nil
			})
			for i := len(builder.hooks) - 1; i >= 0; i-- {
				mut = builder.hooks[i](mut)
			}
			mutators[i] = mut
		}(i, ctx)
	}
	if len(mutators) > 0 {
		if _, err := mutators[0].Mutate(ctx, evcb.builders[0].mutation); err != nil {
			return nil, err
		}
	}
	return nodes, nil
}

// SaveX is like Save, but panics if an error occurs.
func (evcb *EbsVolumeCreateBulk) SaveX(ctx context.Context) []*EbsVolume {
	v, err := evcb.Save(ctx)
	if err != nil {
		panic(err)
	}
	return v
}

// Exec executes the query.
func (evcb *EbsVolumeCreateBulk) Exec(ctx context.Context) error {
	_, err := evcb.Save(ctx)
	return err
}

// ExecX is like Exec, but panics if an error occurs.
func (evcb *EbsVolumeCreateBulk) ExecX(ctx context.Context) {
	if err := evcb.Exec(ctx); err != nil {
		panic(err)
	}
}

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/data/ent/objectstorage_create.go
```golang
// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"luban-cmdb-api/data/ent/objectstorage"
	"time"

	"entgo.io/ent/dialect/sql/sqlgraph"
	"entgo.io/ent/schema/field"
)

// ObjectStorageCreate is the builder for creating a ObjectStorage entity.
type ObjectStorageCreate struct {
	config
	mutation *ObjectStorageMutation
	hooks    []Hook
}

// SetName sets the "name" field.
func (osc *ObjectStorageCreate) SetName(s string) *ObjectStorageCreate {
	osc.mutation.SetName(s)
	return osc
}

// SetNillableName sets the "name" field if the given value is not nil.
func (osc *ObjectStorageCreate) SetNillableName(s *string) *ObjectStorageCreate {
	if s != nil {
		osc.SetName(*s)
	}
	return osc
}

// SetSize sets the "size" field.
func (osc *ObjectStorageCreate) SetSize(i int) *ObjectStorageCreate {
	osc.mutation.SetSize(i)
	return osc
}

// SetNillableSize sets the "size" field if the given value is not nil.
func (osc *ObjectStorageCreate) SetNillableSize(i *int) *ObjectStorageCreate {
	if i != nil {
		osc.SetSize(*i)
	}
	return osc
}

// SetStorageType sets the "storage_type" field.
func (osc *ObjectStorageCreate) SetStorageType(s string) *ObjectStorageCreate {
	osc.mutation.SetStorageType(s)
	return osc
}

// SetNillableStorageType sets the "storage_type" field if the given value is not nil.
func (osc *ObjectStorageCreate) SetNillableStorageType(s *string) *ObjectStorageCreate {
	if s != nil {
		osc.SetStorageType(*s)
	}
	return osc
}

// SetRegion sets the "region" field.
func (osc *ObjectStorageCreate) SetRegion(s string) *ObjectStorageCreate {
	osc.mutation.SetRegion(s)
	return osc
}

// SetNillableRegion sets the "region" field if the given value is not nil.
func (osc *ObjectStorageCreate) SetNillableRegion(s *string) *ObjectStorageCreate {
	if s != nil {
		osc.SetRegion(*s)
	}
	return osc
}

// SetRegionCode sets the "region_code" field.
func (osc *ObjectStorageCreate) SetRegionCode(s string) *ObjectStorageCreate {
	osc.mutation.SetRegionCode(s)
	return osc
}

// SetNillableRegionCode sets the "region_code" field if the given value is not nil.
func (osc *ObjectStorageCreate) SetNillableRegionCode(s *string) *ObjectStorageCreate {
	if s != nil {
		osc.SetRegionCode(*s)
	}
	return osc
}

// SetAz sets the "az" field.
func (osc *ObjectStorageCreate) SetAz(s string) *ObjectStorageCreate {
	osc.mutation.SetAz(s)
	return osc
}

// SetNillableAz sets the "az" field if the given value is not nil.
func (osc *ObjectStorageCreate) SetNillableAz(s *string) *ObjectStorageCreate {
	if s != nil {
		osc.SetAz(*s)
	}
	return osc
}

// SetAzCode sets the "az_code" field.
func (osc *ObjectStorageCreate) SetAzCode(s string) *ObjectStorageCreate {
	osc.mutation.SetAzCode(s)
	return osc
}

// SetNillableAzCode sets the "az_code" field if the given value is not nil.
func (osc *ObjectStorageCreate) SetNillableAzCode(s *string) *ObjectStorageCreate {
	if s != nil {
		osc.SetAzCode(*s)
	}
	return osc
}

// SetTenantID sets the "tenant_id" field.
func (osc *ObjectStorageCreate) SetTenantID(s string) *ObjectStorageCreate {
	osc.mutation.SetTenantID(s)
	return osc
}

// SetNillableTenantID sets the "tenant_id" field if the given value is not nil.
func (osc *ObjectStorageCreate) SetNillableTenantID(s *string) *ObjectStorageCreate {
	if s != nil {
		osc.SetTenantID(*s)
	}
	return osc
}

// SetTenantName sets the "tenant_name" field.
func (osc *ObjectStorageCreate) SetTenantName(s string) *ObjectStorageCreate {
	osc.mutation.SetTenantName(s)
	return osc
}

// SetNillableTenantName sets the "tenant_name" field if the given value is not nil.
func (osc *ObjectStorageCreate) SetNillableTenantName(s *string) *ObjectStorageCreate {
	if s != nil {
		osc.SetTenantName(*s)
	}
	return osc
}

// SetInnerDomainName sets the "inner_domain_name" field.
func (osc *ObjectStorageCreate) SetInnerDomainName(s string) *ObjectStorageCreate {
	osc.mutation.SetInnerDomainName(s)
	return osc
}

// SetNillableInnerDomainName sets the "inner_domain_name" field if the given value is not nil.
func (osc *ObjectStorageCreate) SetNillableInnerDomainName(s *string) *ObjectStorageCreate {
	if s != nil {
		osc.SetInnerDomainName(*s)
	}
	return osc
}

// SetOuterDomainName sets the "outer_domain_name" field.
func (osc *ObjectStorageCreate) SetOuterDomainName(s string) *ObjectStorageCreate {
	osc.mutation.SetOuterDomainName(s)
	return osc
}

// SetNillableOuterDomainName sets the "outer_domain_name" field if the given value is not nil.
func (osc *ObjectStorageCreate) SetNillableOuterDomainName(s *string) *ObjectStorageCreate {
	if s != nil {
		osc.SetOuterDomainName(*s)
	}
	return osc
}

// SetCreateTime sets the "create_time" field.
func (osc *ObjectStorageCreate) SetCreateTime(i int) *ObjectStorageCreate {
	osc.mutation.SetCreateTime(i)
	return osc
}

// SetNillableCreateTime sets the "create_time" field if the given value is not nil.
func (osc *ObjectStorageCreate) SetNillableCreateTime(i *int) *ObjectStorageCreate {
	if i != nil {
		osc.SetCreateTime(*i)
	}
	return osc
}

// SetPolicy sets the "policy" field.
func (osc *ObjectStorageCreate) SetPolicy(s string) *ObjectStorageCreate {
	osc.mutation.SetPolicy(s)
	return osc
}

// SetNillablePolicy sets the "policy" field if the given value is not nil.
func (osc *ObjectStorageCreate) SetNillablePolicy(s *string) *ObjectStorageCreate {
	if s != nil {
		osc.SetPolicy(*s)
	}
	return osc
}

// SetBucketDomains sets the "bucket_domains" field.
func (osc *ObjectStorageCreate) SetBucketDomains(s string) *ObjectStorageCreate {
	osc.mutation.SetBucketDomains(s)
	return osc
}

// SetNillableBucketDomains sets the "bucket_domains" field if the given value is not nil.
func (osc *ObjectStorageCreate) SetNillableBucketDomains(s *string) *ObjectStorageCreate {
	if s != nil {
		osc.SetBucketDomains(*s)
	}
	return osc
}

// SetResourcePoolID sets the "resource_pool_id" field.
func (osc *ObjectStorageCreate) SetResourcePoolID(i int) *ObjectStorageCreate {
	osc.mutation.SetResourcePoolID(i)
	return osc
}

// SetNillableResourcePoolID sets the "resource_pool_id" field if the given value is not nil.
func (osc *ObjectStorageCreate) SetNillableResourcePoolID(i *int) *ObjectStorageCreate {
	if i != nil {
		osc.SetResourcePoolID(*i)
	}
	return osc
}

// SetResourcePoolName sets the "resource_pool_name" field.
func (osc *ObjectStorageCreate) SetResourcePoolName(s string) *ObjectStorageCreate {
	osc.mutation.SetResourcePoolName(s)
	return osc
}

// SetNillableResourcePoolName sets the "resource_pool_name" field if the given value is not nil.
func (osc *ObjectStorageCreate) SetNillableResourcePoolName(s *string) *ObjectStorageCreate {
	if s != nil {
		osc.SetResourcePoolName(*s)
	}
	return osc
}

// SetObjectCount sets the "object_count" field.
func (osc *ObjectStorageCreate) SetObjectCount(i int) *ObjectStorageCreate {
	osc.mutation.SetObjectCount(i)
	return osc
}

// SetNillableObjectCount sets the "object_count" field if the given value is not nil.
func (osc *ObjectStorageCreate) SetNillableObjectCount(i *int) *ObjectStorageCreate {
	if i != nil {
		osc.SetObjectCount(*i)
	}
	return osc
}

// SetCurrentSize sets the "current_size" field.
func (osc *ObjectStorageCreate) SetCurrentSize(i int) *ObjectStorageCreate {
	osc.mutation.SetCurrentSize(i)
	return osc
}

// SetNillableCurrentSize sets the "current_size" field if the given value is not nil.
func (osc *ObjectStorageCreate) SetNillableCurrentSize(i *int) *ObjectStorageCreate {
	if i != nil {
		osc.SetCurrentSize(*i)
	}
	return osc
}

// SetLast30DayDownload sets the "last30_day_download" field.
func (osc *ObjectStorageCreate) SetLast30DayDownload(i int) *ObjectStorageCreate {
	osc.mutation.SetLast30DayDownload(i)
	return osc
}

// SetNillableLast30DayDownload sets the "last30_day_download" field if the given value is not nil.
func (osc *ObjectStorageCreate) SetNillableLast30DayDownload(i *int) *ObjectStorageCreate {
	if i != nil {
		osc.SetLast30DayDownload(*i)
	}
	return osc
}

// SetLast30DayAPICallTimes sets the "last30_day_api_call_times" field.
func (osc *ObjectStorageCreate) SetLast30DayAPICallTimes(i int) *ObjectStorageCreate {
	osc.mutation.SetLast30DayAPICallTimes(i)
	return osc
}

// SetNillableLast30DayAPICallTimes sets the "last30_day_api_call_times" field if the given value is not nil.
func (osc *ObjectStorageCreate) SetNillableLast30DayAPICallTimes(i *int) *ObjectStorageCreate {
	if i != nil {
		osc.SetLast30DayAPICallTimes(*i)
	}
	return osc
}

// SetLastUpdateTime sets the "last_update_time" field.
func (osc *ObjectStorageCreate) SetLastUpdateTime(t time.Time) *ObjectStorageCreate {
	osc.mutation.SetLastUpdateTime(t)
	return osc
}

// SetID sets the "id" field.
func (osc *ObjectStorageCreate) SetID(s string) *ObjectStorageCreate {
	osc.mutation.SetID(s)
	return osc
}

// Mutation returns the ObjectStorageMutation object of the builder.
func (osc *ObjectStorageCreate) Mutation() *ObjectStorageMutation {
	return osc.mutation
}

// Save creates the ObjectStorage in the database.
func (osc *ObjectStorageCreate) Save(ctx context.Context) (*ObjectStorage, error) {
	return withHooks[*ObjectStorage, ObjectStorageMutation](ctx, osc.sqlSave, osc.mutation, osc.hooks)
}

// SaveX calls Save and panics if Save returns an error.
func (osc *ObjectStorageCreate) SaveX(ctx context.Context) *ObjectStorage {
	v, err := osc.Save(ctx)
	if err != nil {
		panic(err)
	}
	return v
}

// Exec executes the query.
func (osc *ObjectStorageCreate) Exec(ctx context.Context) error {
	_, err := osc.Save(ctx)
	return err
}

// ExecX is like Exec, but panics if an error occurs.
func (osc *ObjectStorageCreate) ExecX(ctx context.Context) {
	if err := osc.Exec(ctx); err != nil {
		panic(err)
	}
}

// check runs all checks and user-defined validators on the builder.
func (osc *ObjectStorageCreate) check() error {
	if _, ok := osc.mutation.LastUpdateTime(); !ok {
		return &ValidationError{Name: "last_update_time", err: errors.New(`ent: missing required field "ObjectStorage.last_update_time"`)}
	}
	return nil
}

func (osc *ObjectStorageCreate) sqlSave(ctx context.Context) (*ObjectStorage, error) {
	if err := osc.check(); err != nil {
		return nil, err
	}
	_node, _spec := osc.createSpec()
	if err := sqlgraph.CreateNode(ctx, osc.driver, _spec); err != nil {
		if sqlgraph.IsConstraintError(err) {
			err = &ConstraintError{msg: err.Error(), wrap: err}
		}
		return nil, err
	}
	if _spec.ID.Value != nil {
		if id, ok := _spec.ID.Value.(string); ok {
			_node.ID = id
		} else {
			return nil, fmt.Errorf("unexpected ObjectStorage.ID type: %T", _spec.ID.Value)
		}
	}
	osc.mutation.id = &_node.ID
	osc.mutation.done = true
	return _node, nil
}

func (osc *ObjectStorageCreate) createSpec() (*ObjectStorage, *sqlgraph.CreateSpec) {
	var (
		_node = &ObjectStorage{config: osc.config}
		_spec = sqlgraph.NewCreateSpec(objectstorage.Table, sqlgraph.NewFieldSpec(objectstorage.FieldID, field.TypeString))
	)
	if id, ok := osc.mutation.ID(); ok {
		_node.ID = id
		_spec.ID.Value = id
	}
	if value, ok := osc.mutation.Name(); ok {
		_spec.SetField(objectstorage.FieldName, field.TypeString, value)
		_node.Name = value
	}
	if value, ok := osc.mutation.Size(); ok {
		_spec.SetField(objectstorage.FieldSize, field.TypeInt, value)
		_node.Size = value
	}
	if value, ok := osc.mutation.StorageType(); ok {
		_spec.SetField(objectstorage.FieldStorageType, field.TypeString, value)
		_node.StorageType = value
	}
	if value, ok := osc.mutation.Region(); ok {
		_spec.SetField(objectstorage.FieldRegion, field.TypeString, value)
		_node.Region = value
	}
	if value, ok := osc.mutation.RegionCode(); ok {
		_spec.SetField(objectstorage.FieldRegionCode, field.TypeString, value)
		_node.RegionCode = value
	}
	if value, ok := osc.mutation.Az(); ok {
		_spec.SetField(objectstorage.FieldAz, field.TypeString, value)
		_node.Az = value
	}
	if value, ok := osc.mutation.AzCode(); ok {
		_spec.SetField(objectstorage.FieldAzCode, field.TypeString, value)
		_node.AzCode = value
	}
	if value, ok := osc.mutation.TenantID(); ok {
		_spec.SetField(objectstorage.FieldTenantID, field.TypeString, value)
		_node.TenantID = value
	}
	if value, ok := osc.mutation.TenantName(); ok {
		_spec.SetField(objectstorage.FieldTenantName, field.TypeString, value)
		_node.TenantName = value
	}
	if value, ok := osc.mutation.InnerDomainName(); ok {
		_spec.SetField(objectstorage.FieldInnerDomainName, field.TypeString, value)
		_node.InnerDomainName = value
	}
	if value, ok := osc.mutation.OuterDomainName(); ok {
		_spec.SetField(objectstorage.FieldOuterDomainName, field.TypeString, value)
		_node.OuterDomainName = value
	}
	if value, ok := osc.mutation.CreateTime(); ok {
		_spec.SetField(objectstorage.FieldCreateTime, field.TypeInt, value)
		_node.CreateTime = value
	}
	if value, ok := osc.mutation.Policy(); ok {
		_spec.SetField(objectstorage.FieldPolicy, field.TypeString, value)
		_node.Policy = value
	}
	if value, ok := osc.mutation.BucketDomains(); ok {
		_spec.SetField(objectstorage.FieldBucketDomains, field.TypeString, value)
		_node.BucketDomains = value
	}
	if value, ok := osc.mutation.ResourcePoolID(); ok {
		_spec.SetField(objectstorage.FieldResourcePoolID, field.TypeInt, value)
		_node.ResourcePoolID = value
	}
	if value, ok := osc.mutation.ResourcePoolName(); ok {
		_spec.SetField(objectstorage.FieldResourcePoolName, field.TypeString, value)
		_node.ResourcePoolName = value
	}
	if value, ok := osc.mutation.ObjectCount(); ok {
		_spec.SetField(objectstorage.FieldObjectCount, field.TypeInt, value)
		_node.ObjectCount = value
	}
	if value, ok := osc.mutation.CurrentSize(); ok {
		_spec.SetField(objectstorage.FieldCurrentSize, field.TypeInt, value)
		_node.CurrentSize = value
	}
	if value, ok := osc.mutation.Last30DayDownload(); ok {
		_spec.SetField(objectstorage.FieldLast30DayDownload, field.TypeInt, value)
		_node.Last30DayDownload = value
	}
	if value, ok := osc.mutation.Last30DayAPICallTimes(); ok {
		_spec.SetField(objectstorage.FieldLast30DayAPICallTimes, field.TypeInt, value)
		_node.Last30DayAPICallTimes = value
	}
	if value, ok := osc.mutation.LastUpdateTime(); ok {
		_spec.SetField(objectstorage.FieldLastUpdateTime, field.TypeTime, value)
		_node.LastUpdateTime = value
	}
	return _node, _spec
}

// ObjectStorageCreateBulk is the builder for creating many ObjectStorage entities in bulk.
type ObjectStorageCreateBulk struct {
	config
	builders []*ObjectStorageCreate
}

// Save creates the ObjectStorage entities in the database.
func (oscb *ObjectStorageCreateBulk) Save(ctx context.Context) ([]*ObjectStorage, error) {
	specs := make([]*sqlgraph.CreateSpec, len(oscb.builders))
	nodes := make([]*ObjectStorage, len(oscb.builders))
	mutators := make([]Mutator, len(oscb.builders))
	for i := range oscb.builders {
		func(i int, root context.Context) {
			builder := oscb.builders[i]
			var mut Mutator = MutateFunc(func(ctx context.Context, m Mutation) (Value, error) {
				mutation, ok := m.(*ObjectStorageMutation)
				if !ok {
					return nil, fmt.Errorf("unexpected mutation type %T", m)
				}
				if err := builder.check(); err != nil {
					return nil, err
				}
				builder.mutation = mutation
				nodes[i], specs[i] = builder.createSpec()
				var err error
				if i < len(mutators)-1 {
					_, err = mutators[i+1].Mutate(root, oscb.builders[i+1].mutation)
				} else {
					spec := &sqlgraph.BatchCreateSpec{Nodes: specs}
					// Invoke the actual operation on the latest mutation in the chain.
					if err = sqlgraph.BatchCreate(ctx, oscb.driver, spec); err != nil {
						if sqlgraph.IsConstraintError(err) {
							err = &ConstraintError{msg: err.Error(), wrap: err}
						}
					}
				}
				if err != nil {
					return nil, err
				}
				mutation.id = &nodes[i].ID
				mutation.done = true
				return nodes[i], nil
			})
			for i := len(builder.hooks) - 1; i >= 0; i-- {
				mut = builder.hooks[i](mut)
			}
			mutators[i] = mut
		}(i, ctx)
	}
	if len(mutators) > 0 {
		if _, err := mutators[0].Mutate(ctx, oscb.builders[0].mutation); err != nil {
			return nil, err
		}
	}
	return nodes, nil
}

// SaveX is like Save, but panics if an error occurs.
func (oscb *ObjectStorageCreateBulk) SaveX(ctx context.Context) []*ObjectStorage {
	v, err := oscb.Save(ctx)
	if err != nil {
		panic(err)
	}
	return v
}

// Exec executes the query.
func (oscb *ObjectStorageCreateBulk) Exec(ctx context.Context) error {
	_, err := oscb.Save(ctx)
	return err
}

// ExecX is like Exec, but panics if an error occurs.
func (oscb *ObjectStorageCreateBulk) ExecX(ctx context.Context) {
	if err := oscb.Exec(ctx); err != nil {
		panic(err)
	}
}

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/data/ent/runtime.go
```golang
// Code generated by ent, DO NOT EDIT.

package ent

// The init function reads all schema descriptors with runtime code
// (default values, validators, hooks and policies) and stitches it
// to their package variables.
func init() {
}

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/data/ent/blockstorage.go
```golang
// Code generated by ent, DO NOT EDIT.

package ent

import (
	"fmt"
	"luban-cmdb-api/data/ent/blockstorage"
	"strings"
	"time"

	"entgo.io/ent/dialect/sql"
)

// BlockStorage is the model entity for the BlockStorage schema.
type BlockStorage struct {
	config `json:"-"`
	// ID of the ent.
	ID int `json:"id,omitempty"`
	// Name holds the value of the "name" field.
	Name string `json:"name,omitempty"`
	// InstanceID holds the value of the "instance_id" field.
	InstanceID string `json:"instance_id,omitempty"`
	// Region holds the value of the "region" field.
	Region string `json:"region,omitempty"`
	// RegionCode holds the value of the "region_code" field.
	RegionCode string `json:"region_code,omitempty"`
	// Az holds the value of the "az" field.
	Az string `json:"az,omitempty"`
	// AzCode holds the value of the "az_code" field.
	AzCode string `json:"az_code,omitempty"`
	// ResourcePool holds the value of the "resource_pool" field.
	ResourcePool string `json:"resource_pool,omitempty"`
	// ResourcePoolType holds the value of the "resource_pool_type" field.
	ResourcePoolType string `json:"resource_pool_type,omitempty"`
	// UseStatus holds the value of the "use_status" field.
	UseStatus string `json:"use_status,omitempty"`
	// TenantID holds the value of the "tenant_id" field.
	TenantID string `json:"tenant_id,omitempty"`
	// TenantName holds the value of the "tenant_name" field.
	TenantName string `json:"tenant_name,omitempty"`
	// VM holds the value of the "vm" field.
	VM string `json:"vm,omitempty"`
	// VMID holds the value of the "vm_id" field.
	VMID string `json:"vm_id,omitempty"`
	// CreateTime holds the value of the "create_time" field.
	CreateTime int `json:"create_time,omitempty"`
	// Size holds the value of the "size" field.
	Size int32 `json:"size,omitempty"`
	// MountPoint holds the value of the "mount_point" field.
	MountPoint string `json:"mount_point,omitempty"`
	// LastUpdateTime holds the value of the "last_update_time" field.
	LastUpdateTime time.Time `json:"last_update_time,omitempty"`
}

// scanValues returns the types for scanning values from sql.Rows.
func (*BlockStorage) scanValues(columns []string) ([]any, error) {
	values := make([]any, len(columns))
	for i := range columns {
		switch columns[i] {
		case blockstorage.FieldID, blockstorage.FieldCreateTime, blockstorage.FieldSize:
			values[i] = new(sql.NullInt64)
		case blockstorage.FieldName, blockstorage.FieldInstanceID, blockstorage.FieldRegion, blockstorage.FieldRegionCode, blockstorage.FieldAz, blockstorage.FieldAzCode, blockstorage.FieldResourcePool, blockstorage.FieldResourcePoolType, blockstorage.FieldUseStatus, blockstorage.FieldTenantID, blockstorage.FieldTenantName, blockstorage.FieldVM, blockstorage.FieldVMID, blockstorage.FieldMountPoint:
			values[i] = new(sql.NullString)
		case blockstorage.FieldLastUpdateTime:
			values[i] = new(sql.NullTime)
		default:
			return nil, fmt.Errorf("unexpected column %q for type BlockStorage", columns[i])
		}
	}
	return values, nil
}

// assignValues assigns the values that were returned from sql.Rows (after scanning)
// to the BlockStorage fields.
func (bs *BlockStorage) assignValues(columns []string, values []any) error {
	if m, n := len(values), len(columns); m < n {
		return fmt.Errorf("mismatch number of scan values: %d != %d", m, n)
	}
	for i := range columns {
		switch columns[i] {
		case blockstorage.FieldID:
			value, ok := values[i].(*sql.NullInt64)
			if !ok {
				return fmt.Errorf("unexpected type %T for field id", value)
			}
			bs.ID = int(value.Int64)
		case blockstorage.FieldName:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field name", values[i])
			} else if value.Valid {
				bs.Name = value.String
			}
		case blockstorage.FieldInstanceID:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field instance_id", values[i])
			} else if value.Valid {
				bs.InstanceID = value.String
			}
		case blockstorage.FieldRegion:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field region", values[i])
			} else if value.Valid {
				bs.Region = value.String
			}
		case blockstorage.FieldRegionCode:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field region_code", values[i])
			} else if value.Valid {
				bs.RegionCode = value.String
			}
		case blockstorage.FieldAz:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field az", values[i])
			} else if value.Valid {
				bs.Az = value.String
			}
		case blockstorage.FieldAzCode:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field az_code", values[i])
			} else if value.Valid {
				bs.AzCode = value.String
			}
		case blockstorage.FieldResourcePool:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field resource_pool", values[i])
			} else if value.Valid {
				bs.ResourcePool = value.String
			}
		case blockstorage.FieldResourcePoolType:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field resource_pool_type", values[i])
			} else if value.Valid {
				bs.ResourcePoolType = value.String
			}
		case blockstorage.FieldUseStatus:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field use_status", values[i])
			} else if value.Valid {
				bs.UseStatus = value.String
			}
		case blockstorage.FieldTenantID:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field tenant_id", values[i])
			} else if value.Valid {
				bs.TenantID = value.String
			}
		case blockstorage.FieldTenantName:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field tenant_name", values[i])
			} else if value.Valid {
				bs.TenantName = value.String
			}
		case blockstorage.FieldVM:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field vm", values[i])
			} else if value.Valid {
				bs.VM = value.String
			}
		case blockstorage.FieldVMID:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field vm_id", values[i])
			} else if value.Valid {
				bs.VMID = value.String
			}
		case blockstorage.FieldCreateTime:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field create_time", values[i])
			} else if value.Valid {
				bs.CreateTime = int(value.Int64)
			}
		case blockstorage.FieldSize:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field size", values[i])
			} else if value.Valid {
				bs.Size = int32(value.Int64)
			}
		case blockstorage.FieldMountPoint:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field mount_point", values[i])
			} else if value.Valid {
				bs.MountPoint = value.String
			}
		case blockstorage.FieldLastUpdateTime:
			if value, ok := values[i].(*sql.NullTime); !ok {
				return fmt.Errorf("unexpected type %T for field last_update_time", values[i])
			} else if value.Valid {
				bs.LastUpdateTime = value.Time
			}
		}
	}
	return nil
}

// Update returns a builder for updating this BlockStorage.
// Note that you need to call BlockStorage.Unwrap() before calling this method if this BlockStorage
// was returned from a transaction, and the transaction was committed or rolled back.
func (bs *BlockStorage) Update() *BlockStorageUpdateOne {
	return NewBlockStorageClient(bs.config).UpdateOne(bs)
}

// Unwrap unwraps the BlockStorage entity that was returned from a transaction after it was closed,
// so that all future queries will be executed through the driver which created the transaction.
func (bs *BlockStorage) Unwrap() *BlockStorage {
	_tx, ok := bs.config.driver.(*txDriver)
	if !ok {
		panic("ent: BlockStorage is not a transactional entity")
	}
	bs.config.driver = _tx.drv
	return bs
}

// String implements the fmt.Stringer.
func (bs *BlockStorage) String() string {
	var builder strings.Builder
	builder.WriteString("BlockStorage(")
	builder.WriteString(fmt.Sprintf("id=%v, ", bs.ID))
	builder.WriteString("name=")
	builder.WriteString(bs.Name)
	builder.WriteString(", ")
	builder.WriteString("instance_id=")
	builder.WriteString(bs.InstanceID)
	builder.WriteString(", ")
	builder.WriteString("region=")
	builder.WriteString(bs.Region)
	builder.WriteString(", ")
	builder.WriteString("region_code=")
	builder.WriteString(bs.RegionCode)
	builder.WriteString(", ")
	builder.WriteString("az=")
	builder.WriteString(bs.Az)
	builder.WriteString(", ")
	builder.WriteString("az_code=")
	builder.WriteString(bs.AzCode)
	builder.WriteString(", ")
	builder.WriteString("resource_pool=")
	builder.WriteString(bs.ResourcePool)
	builder.WriteString(", ")
	builder.WriteString("resource_pool_type=")
	builder.WriteString(bs.ResourcePoolType)
	builder.WriteString(", ")
	builder.WriteString("use_status=")
	builder.WriteString(bs.UseStatus)
	builder.WriteString(", ")
	builder.WriteString("tenant_id=")
	builder.WriteString(bs.TenantID)
	builder.WriteString(", ")
	builder.WriteString("tenant_name=")
	builder.WriteString(bs.TenantName)
	builder.WriteString(", ")
	builder.WriteString("vm=")
	builder.WriteString(bs.VM)
	builder.WriteString(", ")
	builder.WriteString("vm_id=")
	builder.WriteString(bs.VMID)
	builder.WriteString(", ")
	builder.WriteString("create_time=")
	builder.WriteString(fmt.Sprintf("%v", bs.CreateTime))
	builder.WriteString(", ")
	builder.WriteString("size=")
	builder.WriteString(fmt.Sprintf("%v", bs.Size))
	builder.WriteString(", ")
	builder.WriteString("mount_point=")
	builder.WriteString(bs.MountPoint)
	builder.WriteString(", ")
	builder.WriteString("last_update_time=")
	builder.WriteString(bs.LastUpdateTime.Format(time.ANSIC))
	builder.WriteByte(')')
	return builder.String()
}

// BlockStorages is a parsable slice of BlockStorage.
type BlockStorages []*BlockStorage

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/data/ent/objectstoragebucket_create.go
```golang
// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"luban-cmdb-api/data/ent/objectstoragebucket"
	"time"

	"entgo.io/ent/dialect/sql/sqlgraph"
	"entgo.io/ent/schema/field"
)

// ObjectstorageBucketCreate is the builder for creating a ObjectstorageBucket entity.
type ObjectstorageBucketCreate struct {
	config
	mutation *ObjectstorageBucketMutation
	hooks    []Hook
}

// SetCreatedAt sets the "created_at" field.
func (obc *ObjectstorageBucketCreate) SetCreatedAt(t time.Time) *ObjectstorageBucketCreate {
	obc.mutation.SetCreatedAt(t)
	return obc
}

// SetNillableCreatedAt sets the "created_at" field if the given value is not nil.
func (obc *ObjectstorageBucketCreate) SetNillableCreatedAt(t *time.Time) *ObjectstorageBucketCreate {
	if t != nil {
		obc.SetCreatedAt(*t)
	}
	return obc
}

// SetUpdatedAt sets the "updated_at" field.
func (obc *ObjectstorageBucketCreate) SetUpdatedAt(t time.Time) *ObjectstorageBucketCreate {
	obc.mutation.SetUpdatedAt(t)
	return obc
}

// SetNillableUpdatedAt sets the "updated_at" field if the given value is not nil.
func (obc *ObjectstorageBucketCreate) SetNillableUpdatedAt(t *time.Time) *ObjectstorageBucketCreate {
	if t != nil {
		obc.SetUpdatedAt(*t)
	}
	return obc
}

// SetVersion sets the "version" field.
func (obc *ObjectstorageBucketCreate) SetVersion(s string) *ObjectstorageBucketCreate {
	obc.mutation.SetVersion(s)
	return obc
}

// SetNillableVersion sets the "version" field if the given value is not nil.
func (obc *ObjectstorageBucketCreate) SetNillableVersion(s *string) *ObjectstorageBucketCreate {
	if s != nil {
		obc.SetVersion(*s)
	}
	return obc
}

// SetGalaxy sets the "galaxy" field.
func (obc *ObjectstorageBucketCreate) SetGalaxy(s string) *ObjectstorageBucketCreate {
	obc.mutation.SetGalaxy(s)
	return obc
}

// SetNillableGalaxy sets the "galaxy" field if the given value is not nil.
func (obc *ObjectstorageBucketCreate) SetNillableGalaxy(s *string) *ObjectstorageBucketCreate {
	if s != nil {
		obc.SetGalaxy(*s)
	}
	return obc
}

// SetRegion sets the "region" field.
func (obc *ObjectstorageBucketCreate) SetRegion(s string) *ObjectstorageBucketCreate {
	obc.mutation.SetRegion(s)
	return obc
}

// SetNillableRegion sets the "region" field if the given value is not nil.
func (obc *ObjectstorageBucketCreate) SetNillableRegion(s *string) *ObjectstorageBucketCreate {
	if s != nil {
		obc.SetRegion(*s)
	}
	return obc
}

// SetDeleted sets the "deleted" field.
func (obc *ObjectstorageBucketCreate) SetDeleted(b bool) *ObjectstorageBucketCreate {
	obc.mutation.SetDeleted(b)
	return obc
}

// SetNillableDeleted sets the "deleted" field if the given value is not nil.
func (obc *ObjectstorageBucketCreate) SetNillableDeleted(b *bool) *ObjectstorageBucketCreate {
	if b != nil {
		obc.SetDeleted(*b)
	}
	return obc
}

// SetBucketID sets the "bucket_id" field.
func (obc *ObjectstorageBucketCreate) SetBucketID(i int) *ObjectstorageBucketCreate {
	obc.mutation.SetBucketID(i)
	return obc
}

// SetName sets the "name" field.
func (obc *ObjectstorageBucketCreate) SetName(s string) *ObjectstorageBucketCreate {
	obc.mutation.SetName(s)
	return obc
}

// SetTenantID sets the "tenant_id" field.
func (obc *ObjectstorageBucketCreate) SetTenantID(s string) *ObjectstorageBucketCreate {
	obc.mutation.SetTenantID(s)
	return obc
}

// SetTenantName sets the "tenant_name" field.
func (obc *ObjectstorageBucketCreate) SetTenantName(s string) *ObjectstorageBucketCreate {
	obc.mutation.SetTenantName(s)
	return obc
}

// SetNillableTenantName sets the "tenant_name" field if the given value is not nil.
func (obc *ObjectstorageBucketCreate) SetNillableTenantName(s *string) *ObjectstorageBucketCreate {
	if s != nil {
		obc.SetTenantName(*s)
	}
	return obc
}

// SetProjectID sets the "project_id" field.
func (obc *ObjectstorageBucketCreate) SetProjectID(s string) *ObjectstorageBucketCreate {
	obc.mutation.SetProjectID(s)
	return obc
}

// SetProjectName sets the "project_name" field.
func (obc *ObjectstorageBucketCreate) SetProjectName(s string) *ObjectstorageBucketCreate {
	obc.mutation.SetProjectName(s)
	return obc
}

// SetStorageclass sets the "storageclass" field.
func (obc *ObjectstorageBucketCreate) SetStorageclass(s string) *ObjectstorageBucketCreate {
	obc.mutation.SetStorageclass(s)
	return obc
}

// SetNillableStorageclass sets the "storageclass" field if the given value is not nil.
func (obc *ObjectstorageBucketCreate) SetNillableStorageclass(s *string) *ObjectstorageBucketCreate {
	if s != nil {
		obc.SetStorageclass(*s)
	}
	return obc
}

// SetStorageclassName sets the "storageclass_name" field.
func (obc *ObjectstorageBucketCreate) SetStorageclassName(s string) *ObjectstorageBucketCreate {
	obc.mutation.SetStorageclassName(s)
	return obc
}

// SetNillableStorageclassName sets the "storageclass_name" field if the given value is not nil.
func (obc *ObjectstorageBucketCreate) SetNillableStorageclassName(s *string) *ObjectstorageBucketCreate {
	if s != nil {
		obc.SetStorageclassName(*s)
	}
	return obc
}

// SetInnerEndpoint sets the "inner_endpoint" field.
func (obc *ObjectstorageBucketCreate) SetInnerEndpoint(s string) *ObjectstorageBucketCreate {
	obc.mutation.SetInnerEndpoint(s)
	return obc
}

// SetOuterEndpoint sets the "outer_endpoint" field.
func (obc *ObjectstorageBucketCreate) SetOuterEndpoint(s string) *ObjectstorageBucketCreate {
	obc.mutation.SetOuterEndpoint(s)
	return obc
}

// SetInnerDomain sets the "inner_domain" field.
func (obc *ObjectstorageBucketCreate) SetInnerDomain(s string) *ObjectstorageBucketCreate {
	obc.mutation.SetInnerDomain(s)
	return obc
}

// SetNillableInnerDomain sets the "inner_domain" field if the given value is not nil.
func (obc *ObjectstorageBucketCreate) SetNillableInnerDomain(s *string) *ObjectstorageBucketCreate {
	if s != nil {
		obc.SetInnerDomain(*s)
	}
	return obc
}

// SetOuterDomain sets the "outer_domain" field.
func (obc *ObjectstorageBucketCreate) SetOuterDomain(s string) *ObjectstorageBucketCreate {
	obc.mutation.SetOuterDomain(s)
	return obc
}

// SetNillableOuterDomain sets the "outer_domain" field if the given value is not nil.
func (obc *ObjectstorageBucketCreate) SetNillableOuterDomain(s *string) *ObjectstorageBucketCreate {
	if s != nil {
		obc.SetOuterDomain(*s)
	}
	return obc
}

// SetPoolID sets the "pool_id" field.
func (obc *ObjectstorageBucketCreate) SetPoolID(s string) *ObjectstorageBucketCreate {
	obc.mutation.SetPoolID(s)
	return obc
}

// SetNillablePoolID sets the "pool_id" field if the given value is not nil.
func (obc *ObjectstorageBucketCreate) SetNillablePoolID(s *string) *ObjectstorageBucketCreate {
	if s != nil {
		obc.SetPoolID(*s)
	}
	return obc
}

// SetPoolName sets the "pool_name" field.
func (obc *ObjectstorageBucketCreate) SetPoolName(s string) *ObjectstorageBucketCreate {
	obc.mutation.SetPoolName(s)
	return obc
}

// SetNillablePoolName sets the "pool_name" field if the given value is not nil.
func (obc *ObjectstorageBucketCreate) SetNillablePoolName(s *string) *ObjectstorageBucketCreate {
	if s != nil {
		obc.SetPoolName(*s)
	}
	return obc
}

// SetTotalStorage sets the "total_storage" field.
func (obc *ObjectstorageBucketCreate) SetTotalStorage(i int) *ObjectstorageBucketCreate {
	obc.mutation.SetTotalStorage(i)
	return obc
}

// SetNillableTotalStorage sets the "total_storage" field if the given value is not nil.
func (obc *ObjectstorageBucketCreate) SetNillableTotalStorage(i *int) *ObjectstorageBucketCreate {
	if i != nil {
		obc.SetTotalStorage(*i)
	}
	return obc
}

// SetAddStorage sets the "add_storage" field.
func (obc *ObjectstorageBucketCreate) SetAddStorage(i int) *ObjectstorageBucketCreate {
	obc.mutation.SetAddStorage(i)
	return obc
}

// SetNillableAddStorage sets the "add_storage" field if the given value is not nil.
func (obc *ObjectstorageBucketCreate) SetNillableAddStorage(i *int) *ObjectstorageBucketCreate {
	if i != nil {
		obc.SetAddStorage(*i)
	}
	return obc
}

// SetDeleteStorage sets the "delete_storage" field.
func (obc *ObjectstorageBucketCreate) SetDeleteStorage(i int) *ObjectstorageBucketCreate {
	obc.mutation.SetDeleteStorage(i)
	return obc
}

// SetNillableDeleteStorage sets the "delete_storage" field if the given value is not nil.
func (obc *ObjectstorageBucketCreate) SetNillableDeleteStorage(i *int) *ObjectstorageBucketCreate {
	if i != nil {
		obc.SetDeleteStorage(*i)
	}
	return obc
}

// SetTotalObject sets the "total_object" field.
func (obc *ObjectstorageBucketCreate) SetTotalObject(i int) *ObjectstorageBucketCreate {
	obc.mutation.SetTotalObject(i)
	return obc
}

// SetNillableTotalObject sets the "total_object" field if the given value is not nil.
func (obc *ObjectstorageBucketCreate) SetNillableTotalObject(i *int) *ObjectstorageBucketCreate {
	if i != nil {
		obc.SetTotalObject(*i)
	}
	return obc
}

// SetAddObject sets the "add_object" field.
func (obc *ObjectstorageBucketCreate) SetAddObject(i int) *ObjectstorageBucketCreate {
	obc.mutation.SetAddObject(i)
	return obc
}

// SetNillableAddObject sets the "add_object" field if the given value is not nil.
func (obc *ObjectstorageBucketCreate) SetNillableAddObject(i *int) *ObjectstorageBucketCreate {
	if i != nil {
		obc.SetAddObject(*i)
	}
	return obc
}

// SetDeleteObject sets the "delete_object" field.
func (obc *ObjectstorageBucketCreate) SetDeleteObject(i int) *ObjectstorageBucketCreate {
	obc.mutation.SetDeleteObject(i)
	return obc
}

// SetNillableDeleteObject sets the "delete_object" field if the given value is not nil.
func (obc *ObjectstorageBucketCreate) SetNillableDeleteObject(i *int) *ObjectstorageBucketCreate {
	if i != nil {
		obc.SetDeleteObject(*i)
	}
	return obc
}

// SetDownloadFlow sets the "download_flow" field.
func (obc *ObjectstorageBucketCreate) SetDownloadFlow(i int) *ObjectstorageBucketCreate {
	obc.mutation.SetDownloadFlow(i)
	return obc
}

// SetNillableDownloadFlow sets the "download_flow" field if the given value is not nil.
func (obc *ObjectstorageBucketCreate) SetNillableDownloadFlow(i *int) *ObjectstorageBucketCreate {
	if i != nil {
		obc.SetDownloadFlow(*i)
	}
	return obc
}

// SetUploadFlow sets the "upload_flow" field.
func (obc *ObjectstorageBucketCreate) SetUploadFlow(i int) *ObjectstorageBucketCreate {
	obc.mutation.SetUploadFlow(i)
	return obc
}

// SetNillableUploadFlow sets the "upload_flow" field if the given value is not nil.
func (obc *ObjectstorageBucketCreate) SetNillableUploadFlow(i *int) *ObjectstorageBucketCreate {
	if i != nil {
		obc.SetUploadFlow(*i)
	}
	return obc
}

// SetRequestAmount sets the "request_amount" field.
func (obc *ObjectstorageBucketCreate) SetRequestAmount(i int) *ObjectstorageBucketCreate {
	obc.mutation.SetRequestAmount(i)
	return obc
}

// SetNillableRequestAmount sets the "request_amount" field if the given value is not nil.
func (obc *ObjectstorageBucketCreate) SetNillableRequestAmount(i *int) *ObjectstorageBucketCreate {
	if i != nil {
		obc.SetRequestAmount(*i)
	}
	return obc
}

// SetDownloadFlowMonth sets the "download_flow_month" field.
func (obc *ObjectstorageBucketCreate) SetDownloadFlowMonth(i int) *ObjectstorageBucketCreate {
	obc.mutation.SetDownloadFlowMonth(i)
	return obc
}

// SetUploadFlowMonth sets the "upload_flow_month" field.
func (obc *ObjectstorageBucketCreate) SetUploadFlowMonth(i int) *ObjectstorageBucketCreate {
	obc.mutation.SetUploadFlowMonth(i)
	return obc
}

// SetRequestAmountMonth sets the "request_amount_month" field.
func (obc *ObjectstorageBucketCreate) SetRequestAmountMonth(i int) *ObjectstorageBucketCreate {
	obc.mutation.SetRequestAmountMonth(i)
	return obc
}

// SetCreateTime sets the "create_time" field.
func (obc *ObjectstorageBucketCreate) SetCreateTime(t time.Time) *ObjectstorageBucketCreate {
	obc.mutation.SetCreateTime(t)
	return obc
}

// SetNillableCreateTime sets the "create_time" field if the given value is not nil.
func (obc *ObjectstorageBucketCreate) SetNillableCreateTime(t *time.Time) *ObjectstorageBucketCreate {
	if t != nil {
		obc.SetCreateTime(*t)
	}
	return obc
}

// SetID sets the "id" field.
func (obc *ObjectstorageBucketCreate) SetID(u uint64) *ObjectstorageBucketCreate {
	obc.mutation.SetID(u)
	return obc
}

// Mutation returns the ObjectstorageBucketMutation object of the builder.
func (obc *ObjectstorageBucketCreate) Mutation() *ObjectstorageBucketMutation {
	return obc.mutation
}

// Save creates the ObjectstorageBucket in the database.
func (obc *ObjectstorageBucketCreate) Save(ctx context.Context) (*ObjectstorageBucket, error) {
	return withHooks[*ObjectstorageBucket, ObjectstorageBucketMutation](ctx, obc.sqlSave, obc.mutation, obc.hooks)
}

// SaveX calls Save and panics if Save returns an error.
func (obc *ObjectstorageBucketCreate) SaveX(ctx context.Context) *ObjectstorageBucket {
	v, err := obc.Save(ctx)
	if err != nil {
		panic(err)
	}
	return v
}

// Exec executes the query.
func (obc *ObjectstorageBucketCreate) Exec(ctx context.Context) error {
	_, err := obc.Save(ctx)
	return err
}

// ExecX is like Exec, but panics if an error occurs.
func (obc *ObjectstorageBucketCreate) ExecX(ctx context.Context) {
	if err := obc.Exec(ctx); err != nil {
		panic(err)
	}
}

// check runs all checks and user-defined validators on the builder.
func (obc *ObjectstorageBucketCreate) check() error {
	if _, ok := obc.mutation.BucketID(); !ok {
		return &ValidationError{Name: "bucket_id", err: errors.New(`ent: missing required field "ObjectstorageBucket.bucket_id"`)}
	}
	if _, ok := obc.mutation.Name(); !ok {
		return &ValidationError{Name: "name", err: errors.New(`ent: missing required field "ObjectstorageBucket.name"`)}
	}
	if _, ok := obc.mutation.TenantID(); !ok {
		return &ValidationError{Name: "tenant_id", err: errors.New(`ent: missing required field "ObjectstorageBucket.tenant_id"`)}
	}
	if _, ok := obc.mutation.ProjectID(); !ok {
		return &ValidationError{Name: "project_id", err: errors.New(`ent: missing required field "ObjectstorageBucket.project_id"`)}
	}
	if _, ok := obc.mutation.ProjectName(); !ok {
		return &ValidationError{Name: "project_name", err: errors.New(`ent: missing required field "ObjectstorageBucket.project_name"`)}
	}
	if _, ok := obc.mutation.InnerEndpoint(); !ok {
		return &ValidationError{Name: "inner_endpoint", err: errors.New(`ent: missing required field "ObjectstorageBucket.inner_endpoint"`)}
	}
	if _, ok := obc.mutation.OuterEndpoint(); !ok {
		return &ValidationError{Name: "outer_endpoint", err: errors.New(`ent: missing required field "ObjectstorageBucket.outer_endpoint"`)}
	}
	if _, ok := obc.mutation.DownloadFlowMonth(); !ok {
		return &ValidationError{Name: "download_flow_month", err: errors.New(`ent: missing required field "ObjectstorageBucket.download_flow_month"`)}
	}
	if _, ok := obc.mutation.UploadFlowMonth(); !ok {
		return &ValidationError{Name: "upload_flow_month", err: errors.New(`ent: missing required field "ObjectstorageBucket.upload_flow_month"`)}
	}
	if _, ok := obc.mutation.RequestAmountMonth(); !ok {
		return &ValidationError{Name: "request_amount_month", err: errors.New(`ent: missing required field "ObjectstorageBucket.request_amount_month"`)}
	}
	return nil
}

func (obc *ObjectstorageBucketCreate) sqlSave(ctx context.Context) (*ObjectstorageBucket, error) {
	if err := obc.check(); err != nil {
		return nil, err
	}
	_node, _spec := obc.createSpec()
	if err := sqlgraph.CreateNode(ctx, obc.driver, _spec); err != nil {
		if sqlgraph.IsConstraintError(err) {
			err = &ConstraintError{msg: err.Error(), wrap: err}
		}
		return nil, err
	}
	if _spec.ID.Value != _node.ID {
		id := _spec.ID.Value.(int64)
		_node.ID = uint64(id)
	}
	obc.mutation.id = &_node.ID
	obc.mutation.done = true
	return _node, nil
}

func (obc *ObjectstorageBucketCreate) createSpec() (*ObjectstorageBucket, *sqlgraph.CreateSpec) {
	var (
		_node = &ObjectstorageBucket{config: obc.config}
		_spec = sqlgraph.NewCreateSpec(objectstoragebucket.Table, sqlgraph.NewFieldSpec(objectstoragebucket.FieldID, field.TypeUint64))
	)
	if id, ok := obc.mutation.ID(); ok {
		_node.ID = id
		_spec.ID.Value = id
	}
	if value, ok := obc.mutation.CreatedAt(); ok {
		_spec.SetField(objectstoragebucket.FieldCreatedAt, field.TypeTime, value)
		_node.CreatedAt = value
	}
	if value, ok := obc.mutation.UpdatedAt(); ok {
		_spec.SetField(objectstoragebucket.FieldUpdatedAt, field.TypeTime, value)
		_node.UpdatedAt = value
	}
	if value, ok := obc.mutation.Version(); ok {
		_spec.SetField(objectstoragebucket.FieldVersion, field.TypeString, value)
		_node.Version = value
	}
	if value, ok := obc.mutation.Galaxy(); ok {
		_spec.SetField(objectstoragebucket.FieldGalaxy, field.TypeString, value)
		_node.Galaxy = value
	}
	if value, ok := obc.mutation.Region(); ok {
		_spec.SetField(objectstoragebucket.FieldRegion, field.TypeString, value)
		_node.Region = value
	}
	if value, ok := obc.mutation.Deleted(); ok {
		_spec.SetField(objectstoragebucket.FieldDeleted, field.TypeBool, value)
		_node.Deleted = value
	}
	if value, ok := obc.mutation.BucketID(); ok {
		_spec.SetField(objectstoragebucket.FieldBucketID, field.TypeInt, value)
		_node.BucketID = value
	}
	if value, ok := obc.mutation.Name(); ok {
		_spec.SetField(objectstoragebucket.FieldName, field.TypeString, value)
		_node.Name = value
	}
	if value, ok := obc.mutation.TenantID(); ok {
		_spec.SetField(objectstoragebucket.FieldTenantID, field.TypeString, value)
		_node.TenantID = value
	}
	if value, ok := obc.mutation.TenantName(); ok {
		_spec.SetField(objectstoragebucket.FieldTenantName, field.TypeString, value)
		_node.TenantName = value
	}
	if value, ok := obc.mutation.ProjectID(); ok {
		_spec.SetField(objectstoragebucket.FieldProjectID, field.TypeString, value)
		_node.ProjectID = value
	}
	if value, ok := obc.mutation.ProjectName(); ok {
		_spec.SetField(objectstoragebucket.FieldProjectName, field.TypeString, value)
		_node.ProjectName = value
	}
	if value, ok := obc.mutation.Storageclass(); ok {
		_spec.SetField(objectstoragebucket.FieldStorageclass, field.TypeString, value)
		_node.Storageclass = value
	}
	if value, ok := obc.mutation.StorageclassName(); ok {
		_spec.SetField(objectstoragebucket.FieldStorageclassName, field.TypeString, value)
		_node.StorageclassName = value
	}
	if value, ok := obc.mutation.InnerEndpoint(); ok {
		_spec.SetField(objectstoragebucket.FieldInnerEndpoint, field.TypeString, value)
		_node.InnerEndpoint = value
	}
	if value, ok := obc.mutation.OuterEndpoint(); ok {
		_spec.SetField(objectstoragebucket.FieldOuterEndpoint, field.TypeString, value)
		_node.OuterEndpoint = value
	}
	if value, ok := obc.mutation.InnerDomain(); ok {
		_spec.SetField(objectstoragebucket.FieldInnerDomain, field.TypeString, value)
		_node.InnerDomain = value
	}
	if value, ok := obc.mutation.OuterDomain(); ok {
		_spec.SetField(objectstoragebucket.FieldOuterDomain, field.TypeString, value)
		_node.OuterDomain = value
	}
	if value, ok := obc.mutation.PoolID(); ok {
		_spec.SetField(objectstoragebucket.FieldPoolID, field.TypeString, value)
		_node.PoolID = value
	}
	if value, ok := obc.mutation.PoolName(); ok {
		_spec.SetField(objectstoragebucket.FieldPoolName, field.TypeString, value)
		_node.PoolName = value
	}
	if value, ok := obc.mutation.TotalStorage(); ok {
		_spec.SetField(objectstoragebucket.FieldTotalStorage, field.TypeInt, value)
		_node.TotalStorage = value
	}
	if value, ok := obc.mutation.AddStorage(); ok {
		_spec.SetField(objectstoragebucket.FieldAddStorage, field.TypeInt, value)
		_node.AddStorage = value
	}
	if value, ok := obc.mutation.DeleteStorage(); ok {
		_spec.SetField(objectstoragebucket.FieldDeleteStorage, field.TypeInt, value)
		_node.DeleteStorage = value
	}
	if value, ok := obc.mutation.TotalObject(); ok {
		_spec.SetField(objectstoragebucket.FieldTotalObject, field.TypeInt, value)
		_node.TotalObject = value
	}
	if value, ok := obc.mutation.AddObject(); ok {
		_spec.SetField(objectstoragebucket.FieldAddObject, field.TypeInt, value)
		_node.AddObject = value
	}
	if value, ok := obc.mutation.DeleteObject(); ok {
		_spec.SetField(objectstoragebucket.FieldDeleteObject, field.TypeInt, value)
		_node.DeleteObject = value
	}
	if value, ok := obc.mutation.DownloadFlow(); ok {
		_spec.SetField(objectstoragebucket.FieldDownloadFlow, field.TypeInt, value)
		_node.DownloadFlow = value
	}
	if value, ok := obc.mutation.UploadFlow(); ok {
		_spec.SetField(objectstoragebucket.FieldUploadFlow, field.TypeInt, value)
		_node.UploadFlow = value
	}
	if value, ok := obc.mutation.RequestAmount(); ok {
		_spec.SetField(objectstoragebucket.FieldRequestAmount, field.TypeInt, value)
		_node.RequestAmount = value
	}
	if value, ok := obc.mutation.DownloadFlowMonth(); ok {
		_spec.SetField(objectstoragebucket.FieldDownloadFlowMonth, field.TypeInt, value)
		_node.DownloadFlowMonth = value
	}
	if value, ok := obc.mutation.UploadFlowMonth(); ok {
		_spec.SetField(objectstoragebucket.FieldUploadFlowMonth, field.TypeInt, value)
		_node.UploadFlowMonth = value
	}
	if value, ok := obc.mutation.RequestAmountMonth(); ok {
		_spec.SetField(objectstoragebucket.FieldRequestAmountMonth, field.TypeInt, value)
		_node.RequestAmountMonth = value
	}
	if value, ok := obc.mutation.CreateTime(); ok {
		_spec.SetField(objectstoragebucket.FieldCreateTime, field.TypeTime, value)
		_node.CreateTime = value
	}
	return _node, _spec
}

// ObjectstorageBucketCreateBulk is the builder for creating many ObjectstorageBucket entities in bulk.
type ObjectstorageBucketCreateBulk struct {
	config
	builders []*ObjectstorageBucketCreate
}

// Save creates the ObjectstorageBucket entities in the database.
func (obcb *ObjectstorageBucketCreateBulk) Save(ctx context.Context) ([]*ObjectstorageBucket, error) {
	specs := make([]*sqlgraph.CreateSpec, len(obcb.builders))
	nodes := make([]*ObjectstorageBucket, len(obcb.builders))
	mutators := make([]Mutator, len(obcb.builders))
	for i := range obcb.builders {
		func(i int, root context.Context) {
			builder := obcb.builders[i]
			var mut Mutator = MutateFunc(func(ctx context.Context, m Mutation) (Value, error) {
				mutation, ok := m.(*ObjectstorageBucketMutation)
				if !ok {
					return nil, fmt.Errorf("unexpected mutation type %T", m)
				}
				if err := builder.check(); err != nil {
					return nil, err
				}
				builder.mutation = mutation
				nodes[i], specs[i] = builder.createSpec()
				var err error
				if i < len(mutators)-1 {
					_, err = mutators[i+1].Mutate(root, obcb.builders[i+1].mutation)
				} else {
					spec := &sqlgraph.BatchCreateSpec{Nodes: specs}
					// Invoke the actual operation on the latest mutation in the chain.
					if err = sqlgraph.BatchCreate(ctx, obcb.driver, spec); err != nil {
						if sqlgraph.IsConstraintError(err) {
							err = &ConstraintError{msg: err.Error(), wrap: err}
						}
					}
				}
				if err != nil {
					return nil, err
				}
				mutation.id = &nodes[i].ID
				if specs[i].ID.Value != nil && nodes[i].ID == 0 {
					id := specs[i].ID.Value.(int64)
					nodes[i].ID = uint64(id)
				}
				mutation.done = true
				return nodes[i], nil
			})
			for i := len(builder.hooks) - 1; i >= 0; i-- {
				mut = builder.hooks[i](mut)
			}
			mutators[i] = mut
		}(i, ctx)
	}
	if len(mutators) > 0 {
		if _, err := mutators[0].Mutate(ctx, obcb.builders[0].mutation); err != nil {
			return nil, err
		}
	}
	return nodes, nil
}

// SaveX is like Save, but panics if an error occurs.
func (obcb *ObjectstorageBucketCreateBulk) SaveX(ctx context.Context) []*ObjectstorageBucket {
	v, err := obcb.Save(ctx)
	if err != nil {
		panic(err)
	}
	return v
}

// Exec executes the query.
func (obcb *ObjectstorageBucketCreateBulk) Exec(ctx context.Context) error {
	_, err := obcb.Save(ctx)
	return err
}

// ExecX is like Exec, but panics if an error occurs.
func (obcb *ObjectstorageBucketCreateBulk) ExecX(ctx context.Context) {
	if err := obcb.Exec(ctx); err != nil {
		panic(err)
	}
}

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/data/ent/objectstoragebucket_update.go
```golang
// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"luban-cmdb-api/data/ent/objectstoragebucket"
	"luban-cmdb-api/data/ent/predicate"
	"time"

	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
	"entgo.io/ent/schema/field"
)

// ObjectstorageBucketUpdate is the builder for updating ObjectstorageBucket entities.
type ObjectstorageBucketUpdate struct {
	config
	hooks    []Hook
	mutation *ObjectstorageBucketMutation
}

// Where appends a list predicates to the ObjectstorageBucketUpdate builder.
func (obu *ObjectstorageBucketUpdate) Where(ps ...predicate.ObjectstorageBucket) *ObjectstorageBucketUpdate {
	obu.mutation.Where(ps...)
	return obu
}

// SetCreatedAt sets the "created_at" field.
func (obu *ObjectstorageBucketUpdate) SetCreatedAt(t time.Time) *ObjectstorageBucketUpdate {
	obu.mutation.SetCreatedAt(t)
	return obu
}

// SetNillableCreatedAt sets the "created_at" field if the given value is not nil.
func (obu *ObjectstorageBucketUpdate) SetNillableCreatedAt(t *time.Time) *ObjectstorageBucketUpdate {
	if t != nil {
		obu.SetCreatedAt(*t)
	}
	return obu
}

// ClearCreatedAt clears the value of the "created_at" field.
func (obu *ObjectstorageBucketUpdate) ClearCreatedAt() *ObjectstorageBucketUpdate {
	obu.mutation.ClearCreatedAt()
	return obu
}

// SetUpdatedAt sets the "updated_at" field.
func (obu *ObjectstorageBucketUpdate) SetUpdatedAt(t time.Time) *ObjectstorageBucketUpdate {
	obu.mutation.SetUpdatedAt(t)
	return obu
}

// SetNillableUpdatedAt sets the "updated_at" field if the given value is not nil.
func (obu *ObjectstorageBucketUpdate) SetNillableUpdatedAt(t *time.Time) *ObjectstorageBucketUpdate {
	if t != nil {
		obu.SetUpdatedAt(*t)
	}
	return obu
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (obu *ObjectstorageBucketUpdate) ClearUpdatedAt() *ObjectstorageBucketUpdate {
	obu.mutation.ClearUpdatedAt()
	return obu
}

// SetVersion sets the "version" field.
func (obu *ObjectstorageBucketUpdate) SetVersion(s string) *ObjectstorageBucketUpdate {
	obu.mutation.SetVersion(s)
	return obu
}

// SetNillableVersion sets the "version" field if the given value is not nil.
func (obu *ObjectstorageBucketUpdate) SetNillableVersion(s *string) *ObjectstorageBucketUpdate {
	if s != nil {
		obu.SetVersion(*s)
	}
	return obu
}

// ClearVersion clears the value of the "version" field.
func (obu *ObjectstorageBucketUpdate) ClearVersion() *ObjectstorageBucketUpdate {
	obu.mutation.ClearVersion()
	return obu
}

// SetGalaxy sets the "galaxy" field.
func (obu *ObjectstorageBucketUpdate) SetGalaxy(s string) *ObjectstorageBucketUpdate {
	obu.mutation.SetGalaxy(s)
	return obu
}

// SetNillableGalaxy sets the "galaxy" field if the given value is not nil.
func (obu *ObjectstorageBucketUpdate) SetNillableGalaxy(s *string) *ObjectstorageBucketUpdate {
	if s != nil {
		obu.SetGalaxy(*s)
	}
	return obu
}

// ClearGalaxy clears the value of the "galaxy" field.
func (obu *ObjectstorageBucketUpdate) ClearGalaxy() *ObjectstorageBucketUpdate {
	obu.mutation.ClearGalaxy()
	return obu
}

// SetRegion sets the "region" field.
func (obu *ObjectstorageBucketUpdate) SetRegion(s string) *ObjectstorageBucketUpdate {
	obu.mutation.SetRegion(s)
	return obu
}

// SetNillableRegion sets the "region" field if the given value is not nil.
func (obu *ObjectstorageBucketUpdate) SetNillableRegion(s *string) *ObjectstorageBucketUpdate {
	if s != nil {
		obu.SetRegion(*s)
	}
	return obu
}

// ClearRegion clears the value of the "region" field.
func (obu *ObjectstorageBucketUpdate) ClearRegion() *ObjectstorageBucketUpdate {
	obu.mutation.ClearRegion()
	return obu
}

// SetDeleted sets the "deleted" field.
func (obu *ObjectstorageBucketUpdate) SetDeleted(b bool) *ObjectstorageBucketUpdate {
	obu.mutation.SetDeleted(b)
	return obu
}

// SetNillableDeleted sets the "deleted" field if the given value is not nil.
func (obu *ObjectstorageBucketUpdate) SetNillableDeleted(b *bool) *ObjectstorageBucketUpdate {
	if b != nil {
		obu.SetDeleted(*b)
	}
	return obu
}

// ClearDeleted clears the value of the "deleted" field.
func (obu *ObjectstorageBucketUpdate) ClearDeleted() *ObjectstorageBucketUpdate {
	obu.mutation.ClearDeleted()
	return obu
}

// SetBucketID sets the "bucket_id" field.
func (obu *ObjectstorageBucketUpdate) SetBucketID(i int) *ObjectstorageBucketUpdate {
	obu.mutation.ResetBucketID()
	obu.mutation.SetBucketID(i)
	return obu
}

// AddBucketID adds i to the "bucket_id" field.
func (obu *ObjectstorageBucketUpdate) AddBucketID(i int) *ObjectstorageBucketUpdate {
	obu.mutation.AddBucketID(i)
	return obu
}

// SetName sets the "name" field.
func (obu *ObjectstorageBucketUpdate) SetName(s string) *ObjectstorageBucketUpdate {
	obu.mutation.SetName(s)
	return obu
}

// SetTenantID sets the "tenant_id" field.
func (obu *ObjectstorageBucketUpdate) SetTenantID(s string) *ObjectstorageBucketUpdate {
	obu.mutation.SetTenantID(s)
	return obu
}

// SetTenantName sets the "tenant_name" field.
func (obu *ObjectstorageBucketUpdate) SetTenantName(s string) *ObjectstorageBucketUpdate {
	obu.mutation.SetTenantName(s)
	return obu
}

// SetNillableTenantName sets the "tenant_name" field if the given value is not nil.
func (obu *ObjectstorageBucketUpdate) SetNillableTenantName(s *string) *ObjectstorageBucketUpdate {
	if s != nil {
		obu.SetTenantName(*s)
	}
	return obu
}

// ClearTenantName clears the value of the "tenant_name" field.
func (obu *ObjectstorageBucketUpdate) ClearTenantName() *ObjectstorageBucketUpdate {
	obu.mutation.ClearTenantName()
	return obu
}

// SetProjectID sets the "project_id" field.
func (obu *ObjectstorageBucketUpdate) SetProjectID(s string) *ObjectstorageBucketUpdate {
	obu.mutation.SetProjectID(s)
	return obu
}

// SetProjectName sets the "project_name" field.
func (obu *ObjectstorageBucketUpdate) SetProjectName(s string) *ObjectstorageBucketUpdate {
	obu.mutation.SetProjectName(s)
	return obu
}

// SetStorageclass sets the "storageclass" field.
func (obu *ObjectstorageBucketUpdate) SetStorageclass(s string) *ObjectstorageBucketUpdate {
	obu.mutation.SetStorageclass(s)
	return obu
}

// SetNillableStorageclass sets the "storageclass" field if the given value is not nil.
func (obu *ObjectstorageBucketUpdate) SetNillableStorageclass(s *string) *ObjectstorageBucketUpdate {
	if s != nil {
		obu.SetStorageclass(*s)
	}
	return obu
}

// ClearStorageclass clears the value of the "storageclass" field.
func (obu *ObjectstorageBucketUpdate) ClearStorageclass() *ObjectstorageBucketUpdate {
	obu.mutation.ClearStorageclass()
	return obu
}

// SetStorageclassName sets the "storageclass_name" field.
func (obu *ObjectstorageBucketUpdate) SetStorageclassName(s string) *ObjectstorageBucketUpdate {
	obu.mutation.SetStorageclassName(s)
	return obu
}

// SetNillableStorageclassName sets the "storageclass_name" field if the given value is not nil.
func (obu *ObjectstorageBucketUpdate) SetNillableStorageclassName(s *string) *ObjectstorageBucketUpdate {
	if s != nil {
		obu.SetStorageclassName(*s)
	}
	return obu
}

// ClearStorageclassName clears the value of the "storageclass_name" field.
func (obu *ObjectstorageBucketUpdate) ClearStorageclassName() *ObjectstorageBucketUpdate {
	obu.mutation.ClearStorageclassName()
	return obu
}

// SetInnerEndpoint sets the "inner_endpoint" field.
func (obu *ObjectstorageBucketUpdate) SetInnerEndpoint(s string) *ObjectstorageBucketUpdate {
	obu.mutation.SetInnerEndpoint(s)
	return obu
}

// SetOuterEndpoint sets the "outer_endpoint" field.
func (obu *ObjectstorageBucketUpdate) SetOuterEndpoint(s string) *ObjectstorageBucketUpdate {
	obu.mutation.SetOuterEndpoint(s)
	return obu
}

// SetInnerDomain sets the "inner_domain" field.
func (obu *ObjectstorageBucketUpdate) SetInnerDomain(s string) *ObjectstorageBucketUpdate {
	obu.mutation.SetInnerDomain(s)
	return obu
}

// SetNillableInnerDomain sets the "inner_domain" field if the given value is not nil.
func (obu *ObjectstorageBucketUpdate) SetNillableInnerDomain(s *string) *ObjectstorageBucketUpdate {
	if s != nil {
		obu.SetInnerDomain(*s)
	}
	return obu
}

// ClearInnerDomain clears the value of the "inner_domain" field.
func (obu *ObjectstorageBucketUpdate) ClearInnerDomain() *ObjectstorageBucketUpdate {
	obu.mutation.ClearInnerDomain()
	return obu
}

// SetOuterDomain sets the "outer_domain" field.
func (obu *ObjectstorageBucketUpdate) SetOuterDomain(s string) *ObjectstorageBucketUpdate {
	obu.mutation.SetOuterDomain(s)
	return obu
}

// SetNillableOuterDomain sets the "outer_domain" field if the given value is not nil.
func (obu *ObjectstorageBucketUpdate) SetNillableOuterDomain(s *string) *ObjectstorageBucketUpdate {
	if s != nil {
		obu.SetOuterDomain(*s)
	}
	return obu
}

// ClearOuterDomain clears the value of the "outer_domain" field.
func (obu *ObjectstorageBucketUpdate) ClearOuterDomain() *ObjectstorageBucketUpdate {
	obu.mutation.ClearOuterDomain()
	return obu
}

// SetPoolID sets the "pool_id" field.
func (obu *ObjectstorageBucketUpdate) SetPoolID(s string) *ObjectstorageBucketUpdate {
	obu.mutation.SetPoolID(s)
	return obu
}

// SetNillablePoolID sets the "pool_id" field if the given value is not nil.
func (obu *ObjectstorageBucketUpdate) SetNillablePoolID(s *string) *ObjectstorageBucketUpdate {
	if s != nil {
		obu.SetPoolID(*s)
	}
	return obu
}

// ClearPoolID clears the value of the "pool_id" field.
func (obu *ObjectstorageBucketUpdate) ClearPoolID() *ObjectstorageBucketUpdate {
	obu.mutation.ClearPoolID()
	return obu
}

// SetPoolName sets the "pool_name" field.
func (obu *ObjectstorageBucketUpdate) SetPoolName(s string) *ObjectstorageBucketUpdate {
	obu.mutation.SetPoolName(s)
	return obu
}

// SetNillablePoolName sets the "pool_name" field if the given value is not nil.
func (obu *ObjectstorageBucketUpdate) SetNillablePoolName(s *string) *ObjectstorageBucketUpdate {
	if s != nil {
		obu.SetPoolName(*s)
	}
	return obu
}

// ClearPoolName clears the value of the "pool_name" field.
func (obu *ObjectstorageBucketUpdate) ClearPoolName() *ObjectstorageBucketUpdate {
	obu.mutation.ClearPoolName()
	return obu
}

// SetTotalStorage sets the "total_storage" field.
func (obu *ObjectstorageBucketUpdate) SetTotalStorage(i int) *ObjectstorageBucketUpdate {
	obu.mutation.ResetTotalStorage()
	obu.mutation.SetTotalStorage(i)
	return obu
}

// SetNillableTotalStorage sets the "total_storage" field if the given value is not nil.
func (obu *ObjectstorageBucketUpdate) SetNillableTotalStorage(i *int) *ObjectstorageBucketUpdate {
	if i != nil {
		obu.SetTotalStorage(*i)
	}
	return obu
}

// AddTotalStorage adds i to the "total_storage" field.
func (obu *ObjectstorageBucketUpdate) AddTotalStorage(i int) *ObjectstorageBucketUpdate {
	obu.mutation.AddTotalStorage(i)
	return obu
}

// ClearTotalStorage clears the value of the "total_storage" field.
func (obu *ObjectstorageBucketUpdate) ClearTotalStorage() *ObjectstorageBucketUpdate {
	obu.mutation.ClearTotalStorage()
	return obu
}

// SetAddStorage sets the "add_storage" field.
func (obu *ObjectstorageBucketUpdate) SetAddStorage(i int) *ObjectstorageBucketUpdate {
	obu.mutation.ResetAddStorage()
	obu.mutation.SetAddStorage(i)
	return obu
}

// SetNillableAddStorage sets the "add_storage" field if the given value is not nil.
func (obu *ObjectstorageBucketUpdate) SetNillableAddStorage(i *int) *ObjectstorageBucketUpdate {
	if i != nil {
		obu.SetAddStorage(*i)
	}
	return obu
}

// AddAddStorage adds i to the "add_storage" field.
func (obu *ObjectstorageBucketUpdate) AddAddStorage(i int) *ObjectstorageBucketUpdate {
	obu.mutation.AddAddStorage(i)
	return obu
}

// ClearAddStorage clears the value of the "add_storage" field.
func (obu *ObjectstorageBucketUpdate) ClearAddStorage() *ObjectstorageBucketUpdate {
	obu.mutation.ClearAddStorage()
	return obu
}

// SetDeleteStorage sets the "delete_storage" field.
func (obu *ObjectstorageBucketUpdate) SetDeleteStorage(i int) *ObjectstorageBucketUpdate {
	obu.mutation.ResetDeleteStorage()
	obu.mutation.SetDeleteStorage(i)
	return obu
}

// SetNillableDeleteStorage sets the "delete_storage" field if the given value is not nil.
func (obu *ObjectstorageBucketUpdate) SetNillableDeleteStorage(i *int) *ObjectstorageBucketUpdate {
	if i != nil {
		obu.SetDeleteStorage(*i)
	}
	return obu
}

// AddDeleteStorage adds i to the "delete_storage" field.
func (obu *ObjectstorageBucketUpdate) AddDeleteStorage(i int) *ObjectstorageBucketUpdate {
	obu.mutation.AddDeleteStorage(i)
	return obu
}

// ClearDeleteStorage clears the value of the "delete_storage" field.
func (obu *ObjectstorageBucketUpdate) ClearDeleteStorage() *ObjectstorageBucketUpdate {
	obu.mutation.ClearDeleteStorage()
	return obu
}

// SetTotalObject sets the "total_object" field.
func (obu *ObjectstorageBucketUpdate) SetTotalObject(i int) *ObjectstorageBucketUpdate {
	obu.mutation.ResetTotalObject()
	obu.mutation.SetTotalObject(i)
	return obu
}

// SetNillableTotalObject sets the "total_object" field if the given value is not nil.
func (obu *ObjectstorageBucketUpdate) SetNillableTotalObject(i *int) *ObjectstorageBucketUpdate {
	if i != nil {
		obu.SetTotalObject(*i)
	}
	return obu
}

// AddTotalObject adds i to the "total_object" field.
func (obu *ObjectstorageBucketUpdate) AddTotalObject(i int) *ObjectstorageBucketUpdate {
	obu.mutation.AddTotalObject(i)
	return obu
}

// ClearTotalObject clears the value of the "total_object" field.
func (obu *ObjectstorageBucketUpdate) ClearTotalObject() *ObjectstorageBucketUpdate {
	obu.mutation.ClearTotalObject()
	return obu
}

// SetAddObject sets the "add_object" field.
func (obu *ObjectstorageBucketUpdate) SetAddObject(i int) *ObjectstorageBucketUpdate {
	obu.mutation.ResetAddObject()
	obu.mutation.SetAddObject(i)
	return obu
}

// SetNillableAddObject sets the "add_object" field if the given value is not nil.
func (obu *ObjectstorageBucketUpdate) SetNillableAddObject(i *int) *ObjectstorageBucketUpdate {
	if i != nil {
		obu.SetAddObject(*i)
	}
	return obu
}

// AddAddObject adds i to the "add_object" field.
func (obu *ObjectstorageBucketUpdate) AddAddObject(i int) *ObjectstorageBucketUpdate {
	obu.mutation.AddAddObject(i)
	return obu
}

// ClearAddObject clears the value of the "add_object" field.
func (obu *ObjectstorageBucketUpdate) ClearAddObject() *ObjectstorageBucketUpdate {
	obu.mutation.ClearAddObject()
	return obu
}

// SetDeleteObject sets the "delete_object" field.
func (obu *ObjectstorageBucketUpdate) SetDeleteObject(i int) *ObjectstorageBucketUpdate {
	obu.mutation.ResetDeleteObject()
	obu.mutation.SetDeleteObject(i)
	return obu
}

// SetNillableDeleteObject sets the "delete_object" field if the given value is not nil.
func (obu *ObjectstorageBucketUpdate) SetNillableDeleteObject(i *int) *ObjectstorageBucketUpdate {
	if i != nil {
		obu.SetDeleteObject(*i)
	}
	return obu
}

// AddDeleteObject adds i to the "delete_object" field.
func (obu *ObjectstorageBucketUpdate) AddDeleteObject(i int) *ObjectstorageBucketUpdate {
	obu.mutation.AddDeleteObject(i)
	return obu
}

// ClearDeleteObject clears the value of the "delete_object" field.
func (obu *ObjectstorageBucketUpdate) ClearDeleteObject() *ObjectstorageBucketUpdate {
	obu.mutation.ClearDeleteObject()
	return obu
}

// SetDownloadFlow sets the "download_flow" field.
func (obu *ObjectstorageBucketUpdate) SetDownloadFlow(i int) *ObjectstorageBucketUpdate {
	obu.mutation.ResetDownloadFlow()
	obu.mutation.SetDownloadFlow(i)
	return obu
}

// SetNillableDownloadFlow sets the "download_flow" field if the given value is not nil.
func (obu *ObjectstorageBucketUpdate) SetNillableDownloadFlow(i *int) *ObjectstorageBucketUpdate {
	if i != nil {
		obu.SetDownloadFlow(*i)
	}
	return obu
}

// AddDownloadFlow adds i to the "download_flow" field.
func (obu *ObjectstorageBucketUpdate) AddDownloadFlow(i int) *ObjectstorageBucketUpdate {
	obu.mutation.AddDownloadFlow(i)
	return obu
}

// ClearDownloadFlow clears the value of the "download_flow" field.
func (obu *ObjectstorageBucketUpdate) ClearDownloadFlow() *ObjectstorageBucketUpdate {
	obu.mutation.ClearDownloadFlow()
	return obu
}

// SetUploadFlow sets the "upload_flow" field.
func (obu *ObjectstorageBucketUpdate) SetUploadFlow(i int) *ObjectstorageBucketUpdate {
	obu.mutation.ResetUploadFlow()
	obu.mutation.SetUploadFlow(i)
	return obu
}

// SetNillableUploadFlow sets the "upload_flow" field if the given value is not nil.
func (obu *ObjectstorageBucketUpdate) SetNillableUploadFlow(i *int) *ObjectstorageBucketUpdate {
	if i != nil {
		obu.SetUploadFlow(*i)
	}
	return obu
}

// AddUploadFlow adds i to the "upload_flow" field.
func (obu *ObjectstorageBucketUpdate) AddUploadFlow(i int) *ObjectstorageBucketUpdate {
	obu.mutation.AddUploadFlow(i)
	return obu
}

// ClearUploadFlow clears the value of the "upload_flow" field.
func (obu *ObjectstorageBucketUpdate) ClearUploadFlow() *ObjectstorageBucketUpdate {
	obu.mutation.ClearUploadFlow()
	return obu
}

// SetRequestAmount sets the "request_amount" field.
func (obu *ObjectstorageBucketUpdate) SetRequestAmount(i int) *ObjectstorageBucketUpdate {
	obu.mutation.ResetRequestAmount()
	obu.mutation.SetRequestAmount(i)
	return obu
}

// SetNillableRequestAmount sets the "request_amount" field if the given value is not nil.
func (obu *ObjectstorageBucketUpdate) SetNillableRequestAmount(i *int) *ObjectstorageBucketUpdate {
	if i != nil {
		obu.SetRequestAmount(*i)
	}
	return obu
}

// AddRequestAmount adds i to the "request_amount" field.
func (obu *ObjectstorageBucketUpdate) AddRequestAmount(i int) *ObjectstorageBucketUpdate {
	obu.mutation.AddRequestAmount(i)
	return obu
}

// ClearRequestAmount clears the value of the "request_amount" field.
func (obu *ObjectstorageBucketUpdate) ClearRequestAmount() *ObjectstorageBucketUpdate {
	obu.mutation.ClearRequestAmount()
	return obu
}

// SetDownloadFlowMonth sets the "download_flow_month" field.
func (obu *ObjectstorageBucketUpdate) SetDownloadFlowMonth(i int) *ObjectstorageBucketUpdate {
	obu.mutation.ResetDownloadFlowMonth()
	obu.mutation.SetDownloadFlowMonth(i)
	return obu
}

// AddDownloadFlowMonth adds i to the "download_flow_month" field.
func (obu *ObjectstorageBucketUpdate) AddDownloadFlowMonth(i int) *ObjectstorageBucketUpdate {
	obu.mutation.AddDownloadFlowMonth(i)
	return obu
}

// SetUploadFlowMonth sets the "upload_flow_month" field.
func (obu *ObjectstorageBucketUpdate) SetUploadFlowMonth(i int) *ObjectstorageBucketUpdate {
	obu.mutation.ResetUploadFlowMonth()
	obu.mutation.SetUploadFlowMonth(i)
	return obu
}

// AddUploadFlowMonth adds i to the "upload_flow_month" field.
func (obu *ObjectstorageBucketUpdate) AddUploadFlowMonth(i int) *ObjectstorageBucketUpdate {
	obu.mutation.AddUploadFlowMonth(i)
	return obu
}

// SetRequestAmountMonth sets the "request_amount_month" field.
func (obu *ObjectstorageBucketUpdate) SetRequestAmountMonth(i int) *ObjectstorageBucketUpdate {
	obu.mutation.ResetRequestAmountMonth()
	obu.mutation.SetRequestAmountMonth(i)
	return obu
}

// AddRequestAmountMonth adds i to the "request_amount_month" field.
func (obu *ObjectstorageBucketUpdate) AddRequestAmountMonth(i int) *ObjectstorageBucketUpdate {
	obu.mutation.AddRequestAmountMonth(i)
	return obu
}

// SetCreateTime sets the "create_time" field.
func (obu *ObjectstorageBucketUpdate) SetCreateTime(t time.Time) *ObjectstorageBucketUpdate {
	obu.mutation.SetCreateTime(t)
	return obu
}

// SetNillableCreateTime sets the "create_time" field if the given value is not nil.
func (obu *ObjectstorageBucketUpdate) SetNillableCreateTime(t *time.Time) *ObjectstorageBucketUpdate {
	if t != nil {
		obu.SetCreateTime(*t)
	}
	return obu
}

// ClearCreateTime clears the value of the "create_time" field.
func (obu *ObjectstorageBucketUpdate) ClearCreateTime() *ObjectstorageBucketUpdate {
	obu.mutation.ClearCreateTime()
	return obu
}

// Mutation returns the ObjectstorageBucketMutation object of the builder.
func (obu *ObjectstorageBucketUpdate) Mutation() *ObjectstorageBucketMutation {
	return obu.mutation
}

// Save executes the query and returns the number of nodes affected by the update operation.
func (obu *ObjectstorageBucketUpdate) Save(ctx context.Context) (int, error) {
	return withHooks[int, ObjectstorageBucketMutation](ctx, obu.sqlSave, obu.mutation, obu.hooks)
}

// SaveX is like Save, but panics if an error occurs.
func (obu *ObjectstorageBucketUpdate) SaveX(ctx context.Context) int {
	affected, err := obu.Save(ctx)
	if err != nil {
		panic(err)
	}
	return affected
}

// Exec executes the query.
func (obu *ObjectstorageBucketUpdate) Exec(ctx context.Context) error {
	_, err := obu.Save(ctx)
	return err
}

// ExecX is like Exec, but panics if an error occurs.
func (obu *ObjectstorageBucketUpdate) ExecX(ctx context.Context) {
	if err := obu.Exec(ctx); err != nil {
		panic(err)
	}
}

func (obu *ObjectstorageBucketUpdate) sqlSave(ctx context.Context) (n int, err error) {
	_spec := sqlgraph.NewUpdateSpec(objectstoragebucket.Table, objectstoragebucket.Columns, sqlgraph.NewFieldSpec(objectstoragebucket.FieldID, field.TypeUint64))
	if ps := obu.mutation.predicates; len(ps) > 0 {
		_spec.Predicate = func(selector *sql.Selector) {
			for i := range ps {
				ps[i](selector)
			}
		}
	}
	if value, ok := obu.mutation.CreatedAt(); ok {
		_spec.SetField(objectstoragebucket.FieldCreatedAt, field.TypeTime, value)
	}
	if obu.mutation.CreatedAtCleared() {
		_spec.ClearField(objectstoragebucket.FieldCreatedAt, field.TypeTime)
	}
	if value, ok := obu.mutation.UpdatedAt(); ok {
		_spec.SetField(objectstoragebucket.FieldUpdatedAt, field.TypeTime, value)
	}
	if obu.mutation.UpdatedAtCleared() {
		_spec.ClearField(objectstoragebucket.FieldUpdatedAt, field.TypeTime)
	}
	if value, ok := obu.mutation.Version(); ok {
		_spec.SetField(objectstoragebucket.FieldVersion, field.TypeString, value)
	}
	if obu.mutation.VersionCleared() {
		_spec.ClearField(objectstoragebucket.FieldVersion, field.TypeString)
	}
	if value, ok := obu.mutation.Galaxy(); ok {
		_spec.SetField(objectstoragebucket.FieldGalaxy, field.TypeString, value)
	}
	if obu.mutation.GalaxyCleared() {
		_spec.ClearField(objectstoragebucket.FieldGalaxy, field.TypeString)
	}
	if value, ok := obu.mutation.Region(); ok {
		_spec.SetField(objectstoragebucket.FieldRegion, field.TypeString, value)
	}
	if obu.mutation.RegionCleared() {
		_spec.ClearField(objectstoragebucket.FieldRegion, field.TypeString)
	}
	if value, ok := obu.mutation.Deleted(); ok {
		_spec.SetField(objectstoragebucket.FieldDeleted, field.TypeBool, value)
	}
	if obu.mutation.DeletedCleared() {
		_spec.ClearField(objectstoragebucket.FieldDeleted, field.TypeBool)
	}
	if value, ok := obu.mutation.BucketID(); ok {
		_spec.SetField(objectstoragebucket.FieldBucketID, field.TypeInt, value)
	}
	if value, ok := obu.mutation.AddedBucketID(); ok {
		_spec.AddField(objectstoragebucket.FieldBucketID, field.TypeInt, value)
	}
	if value, ok := obu.mutation.Name(); ok {
		_spec.SetField(objectstoragebucket.FieldName, field.TypeString, value)
	}
	if value, ok := obu.mutation.TenantID(); ok {
		_spec.SetField(objectstoragebucket.FieldTenantID, field.TypeString, value)
	}
	if value, ok := obu.mutation.TenantName(); ok {
		_spec.SetField(objectstoragebucket.FieldTenantName, field.TypeString, value)
	}
	if obu.mutation.TenantNameCleared() {
		_spec.ClearField(objectstoragebucket.FieldTenantName, field.TypeString)
	}
	if value, ok := obu.mutation.ProjectID(); ok {
		_spec.SetField(objectstoragebucket.FieldProjectID, field.TypeString, value)
	}
	if value, ok := obu.mutation.ProjectName(); ok {
		_spec.SetField(objectstoragebucket.FieldProjectName, field.TypeString, value)
	}
	if value, ok := obu.mutation.Storageclass(); ok {
		_spec.SetField(objectstoragebucket.FieldStorageclass, field.TypeString, value)
	}
	if obu.mutation.StorageclassCleared() {
		_spec.ClearField(objectstoragebucket.FieldStorageclass, field.TypeString)
	}
	if value, ok := obu.mutation.StorageclassName(); ok {
		_spec.SetField(objectstoragebucket.FieldStorageclassName, field.TypeString, value)
	}
	if obu.mutation.StorageclassNameCleared() {
		_spec.ClearField(objectstoragebucket.FieldStorageclassName, field.TypeString)
	}
	if value, ok := obu.mutation.InnerEndpoint(); ok {
		_spec.SetField(objectstoragebucket.FieldInnerEndpoint, field.TypeString, value)
	}
	if value, ok := obu.mutation.OuterEndpoint(); ok {
		_spec.SetField(objectstoragebucket.FieldOuterEndpoint, field.TypeString, value)
	}
	if value, ok := obu.mutation.InnerDomain(); ok {
		_spec.SetField(objectstoragebucket.FieldInnerDomain, field.TypeString, value)
	}
	if obu.mutation.InnerDomainCleared() {
		_spec.ClearField(objectstoragebucket.FieldInnerDomain, field.TypeString)
	}
	if value, ok := obu.mutation.OuterDomain(); ok {
		_spec.SetField(objectstoragebucket.FieldOuterDomain, field.TypeString, value)
	}
	if obu.mutation.OuterDomainCleared() {
		_spec.ClearField(objectstoragebucket.FieldOuterDomain, field.TypeString)
	}
	if value, ok := obu.mutation.PoolID(); ok {
		_spec.SetField(objectstoragebucket.FieldPoolID, field.TypeString, value)
	}
	if obu.mutation.PoolIDCleared() {
		_spec.ClearField(objectstoragebucket.FieldPoolID, field.TypeString)
	}
	if value, ok := obu.mutation.PoolName(); ok {
		_spec.SetField(objectstoragebucket.FieldPoolName, field.TypeString, value)
	}
	if obu.mutation.PoolNameCleared() {
		_spec.ClearField(objectstoragebucket.FieldPoolName, field.TypeString)
	}
	if value, ok := obu.mutation.TotalStorage(); ok {
		_spec.SetField(objectstoragebucket.FieldTotalStorage, field.TypeInt, value)
	}
	if value, ok := obu.mutation.AddedTotalStorage(); ok {
		_spec.AddField(objectstoragebucket.FieldTotalStorage, field.TypeInt, value)
	}
	if obu.mutation.TotalStorageCleared() {
		_spec.ClearField(objectstoragebucket.FieldTotalStorage, field.TypeInt)
	}
	if value, ok := obu.mutation.AddStorage(); ok {
		_spec.SetField(objectstoragebucket.FieldAddStorage, field.TypeInt, value)
	}
	if value, ok := obu.mutation.AddedAddStorage(); ok {
		_spec.AddField(objectstoragebucket.FieldAddStorage, field.TypeInt, value)
	}
	if obu.mutation.AddStorageCleared() {
		_spec.ClearField(objectstoragebucket.FieldAddStorage, field.TypeInt)
	}
	if value, ok := obu.mutation.DeleteStorage(); ok {
		_spec.SetField(objectstoragebucket.FieldDeleteStorage, field.TypeInt, value)
	}
	if value, ok := obu.mutation.AddedDeleteStorage(); ok {
		_spec.AddField(objectstoragebucket.FieldDeleteStorage, field.TypeInt, value)
	}
	if obu.mutation.DeleteStorageCleared() {
		_spec.ClearField(objectstoragebucket.FieldDeleteStorage, field.TypeInt)
	}
	if value, ok := obu.mutation.TotalObject(); ok {
		_spec.SetField(objectstoragebucket.FieldTotalObject, field.TypeInt, value)
	}
	if value, ok := obu.mutation.AddedTotalObject(); ok {
		_spec.AddField(objectstoragebucket.FieldTotalObject, field.TypeInt, value)
	}
	if obu.mutation.TotalObjectCleared() {
		_spec.ClearField(objectstoragebucket.FieldTotalObject, field.TypeInt)
	}
	if value, ok := obu.mutation.AddObject(); ok {
		_spec.SetField(objectstoragebucket.FieldAddObject, field.TypeInt, value)
	}
	if value, ok := obu.mutation.AddedAddObject(); ok {
		_spec.AddField(objectstoragebucket.FieldAddObject, field.TypeInt, value)
	}
	if obu.mutation.AddObjectCleared() {
		_spec.ClearField(objectstoragebucket.FieldAddObject, field.TypeInt)
	}
	if value, ok := obu.mutation.DeleteObject(); ok {
		_spec.SetField(objectstoragebucket.FieldDeleteObject, field.TypeInt, value)
	}
	if value, ok := obu.mutation.AddedDeleteObject(); ok {
		_spec.AddField(objectstoragebucket.FieldDeleteObject, field.TypeInt, value)
	}
	if obu.mutation.DeleteObjectCleared() {
		_spec.ClearField(objectstoragebucket.FieldDeleteObject, field.TypeInt)
	}
	if value, ok := obu.mutation.DownloadFlow(); ok {
		_spec.SetField(objectstoragebucket.FieldDownloadFlow, field.TypeInt, value)
	}
	if value, ok := obu.mutation.AddedDownloadFlow(); ok {
		_spec.AddField(objectstoragebucket.FieldDownloadFlow, field.TypeInt, value)
	}
	if obu.mutation.DownloadFlowCleared() {
		_spec.ClearField(objectstoragebucket.FieldDownloadFlow, field.TypeInt)
	}
	if value, ok := obu.mutation.UploadFlow(); ok {
		_spec.SetField(objectstoragebucket.FieldUploadFlow, field.TypeInt, value)
	}
	if value, ok := obu.mutation.AddedUploadFlow(); ok {
		_spec.AddField(objectstoragebucket.FieldUploadFlow, field.TypeInt, value)
	}
	if obu.mutation.UploadFlowCleared() {
		_spec.ClearField(objectstoragebucket.FieldUploadFlow, field.TypeInt)
	}
	if value, ok := obu.mutation.RequestAmount(); ok {
		_spec.SetField(objectstoragebucket.FieldRequestAmount, field.TypeInt, value)
	}
	if value, ok := obu.mutation.AddedRequestAmount(); ok {
		_spec.AddField(objectstoragebucket.FieldRequestAmount, field.TypeInt, value)
	}
	if obu.mutation.RequestAmountCleared() {
		_spec.ClearField(objectstoragebucket.FieldRequestAmount, field.TypeInt)
	}
	if value, ok := obu.mutation.DownloadFlowMonth(); ok {
		_spec.SetField(objectstoragebucket.FieldDownloadFlowMonth, field.TypeInt, value)
	}
	if value, ok := obu.mutation.AddedDownloadFlowMonth(); ok {
		_spec.AddField(objectstoragebucket.FieldDownloadFlowMonth, field.TypeInt, value)
	}
	if value, ok := obu.mutation.UploadFlowMonth(); ok {
		_spec.SetField(objectstoragebucket.FieldUploadFlowMonth, field.TypeInt, value)
	}
	if value, ok := obu.mutation.AddedUploadFlowMonth(); ok {
		_spec.AddField(objectstoragebucket.FieldUploadFlowMonth, field.TypeInt, value)
	}
	if value, ok := obu.mutation.RequestAmountMonth(); ok {
		_spec.SetField(objectstoragebucket.FieldRequestAmountMonth, field.TypeInt, value)
	}
	if value, ok := obu.mutation.AddedRequestAmountMonth(); ok {
		_spec.AddField(objectstoragebucket.FieldRequestAmountMonth, field.TypeInt, value)
	}
	if value, ok := obu.mutation.CreateTime(); ok {
		_spec.SetField(objectstoragebucket.FieldCreateTime, field.TypeTime, value)
	}
	if obu.mutation.CreateTimeCleared() {
		_spec.ClearField(objectstoragebucket.FieldCreateTime, field.TypeTime)
	}
	if n, err = sqlgraph.UpdateNodes(ctx, obu.driver, _spec); err != nil {
		if _, ok := err.(*sqlgraph.NotFoundError); ok {
			err = &NotFoundError{objectstoragebucket.Label}
		} else if sqlgraph.IsConstraintError(err) {
			err = &ConstraintError{msg: err.Error(), wrap: err}
		}
		return 0, err
	}
	obu.mutation.done = true
	return n, nil
}

// ObjectstorageBucketUpdateOne is the builder for updating a single ObjectstorageBucket entity.
type ObjectstorageBucketUpdateOne struct {
	config
	fields   []string
	hooks    []Hook
	mutation *ObjectstorageBucketMutation
}

// SetCreatedAt sets the "created_at" field.
func (obuo *ObjectstorageBucketUpdateOne) SetCreatedAt(t time.Time) *ObjectstorageBucketUpdateOne {
	obuo.mutation.SetCreatedAt(t)
	return obuo
}

// SetNillableCreatedAt sets the "created_at" field if the given value is not nil.
func (obuo *ObjectstorageBucketUpdateOne) SetNillableCreatedAt(t *time.Time) *ObjectstorageBucketUpdateOne {
	if t != nil {
		obuo.SetCreatedAt(*t)
	}
	return obuo
}

// ClearCreatedAt clears the value of the "created_at" field.
func (obuo *ObjectstorageBucketUpdateOne) ClearCreatedAt() *ObjectstorageBucketUpdateOne {
	obuo.mutation.ClearCreatedAt()
	return obuo
}

// SetUpdatedAt sets the "updated_at" field.
func (obuo *ObjectstorageBucketUpdateOne) SetUpdatedAt(t time.Time) *ObjectstorageBucketUpdateOne {
	obuo.mutation.SetUpdatedAt(t)
	return obuo
}

// SetNillableUpdatedAt sets the "updated_at" field if the given value is not nil.
func (obuo *ObjectstorageBucketUpdateOne) SetNillableUpdatedAt(t *time.Time) *ObjectstorageBucketUpdateOne {
	if t != nil {
		obuo.SetUpdatedAt(*t)
	}
	return obuo
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (obuo *ObjectstorageBucketUpdateOne) ClearUpdatedAt() *ObjectstorageBucketUpdateOne {
	obuo.mutation.ClearUpdatedAt()
	return obuo
}

// SetVersion sets the "version" field.
func (obuo *ObjectstorageBucketUpdateOne) SetVersion(s string) *ObjectstorageBucketUpdateOne {
	obuo.mutation.SetVersion(s)
	return obuo
}

// SetNillableVersion sets the "version" field if the given value is not nil.
func (obuo *ObjectstorageBucketUpdateOne) SetNillableVersion(s *string) *ObjectstorageBucketUpdateOne {
	if s != nil {
		obuo.SetVersion(*s)
	}
	return obuo
}

// ClearVersion clears the value of the "version" field.
func (obuo *ObjectstorageBucketUpdateOne) ClearVersion() *ObjectstorageBucketUpdateOne {
	obuo.mutation.ClearVersion()
	return obuo
}

// SetGalaxy sets the "galaxy" field.
func (obuo *ObjectstorageBucketUpdateOne) SetGalaxy(s string) *ObjectstorageBucketUpdateOne {
	obuo.mutation.SetGalaxy(s)
	return obuo
}

// SetNillableGalaxy sets the "galaxy" field if the given value is not nil.
func (obuo *ObjectstorageBucketUpdateOne) SetNillableGalaxy(s *string) *ObjectstorageBucketUpdateOne {
	if s != nil {
		obuo.SetGalaxy(*s)
	}
	return obuo
}

// ClearGalaxy clears the value of the "galaxy" field.
func (obuo *ObjectstorageBucketUpdateOne) ClearGalaxy() *ObjectstorageBucketUpdateOne {
	obuo.mutation.ClearGalaxy()
	return obuo
}

// SetRegion sets the "region" field.
func (obuo *ObjectstorageBucketUpdateOne) SetRegion(s string) *ObjectstorageBucketUpdateOne {
	obuo.mutation.SetRegion(s)
	return obuo
}

// SetNillableRegion sets the "region" field if the given value is not nil.
func (obuo *ObjectstorageBucketUpdateOne) SetNillableRegion(s *string) *ObjectstorageBucketUpdateOne {
	if s != nil {
		obuo.SetRegion(*s)
	}
	return obuo
}

// ClearRegion clears the value of the "region" field.
func (obuo *ObjectstorageBucketUpdateOne) ClearRegion() *ObjectstorageBucketUpdateOne {
	obuo.mutation.ClearRegion()
	return obuo
}

// SetDeleted sets the "deleted" field.
func (obuo *ObjectstorageBucketUpdateOne) SetDeleted(b bool) *ObjectstorageBucketUpdateOne {
	obuo.mutation.SetDeleted(b)
	return obuo
}

// SetNillableDeleted sets the "deleted" field if the given value is not nil.
func (obuo *ObjectstorageBucketUpdateOne) SetNillableDeleted(b *bool) *ObjectstorageBucketUpdateOne {
	if b != nil {
		obuo.SetDeleted(*b)
	}
	return obuo
}

// ClearDeleted clears the value of the "deleted" field.
func (obuo *ObjectstorageBucketUpdateOne) ClearDeleted() *ObjectstorageBucketUpdateOne {
	obuo.mutation.ClearDeleted()
	return obuo
}

// SetBucketID sets the "bucket_id" field.
func (obuo *ObjectstorageBucketUpdateOne) SetBucketID(i int) *ObjectstorageBucketUpdateOne {
	obuo.mutation.ResetBucketID()
	obuo.mutation.SetBucketID(i)
	return obuo
}

// AddBucketID adds i to the "bucket_id" field.
func (obuo *ObjectstorageBucketUpdateOne) AddBucketID(i int) *ObjectstorageBucketUpdateOne {
	obuo.mutation.AddBucketID(i)
	return obuo
}

// SetName sets the "name" field.
func (obuo *ObjectstorageBucketUpdateOne) SetName(s string) *ObjectstorageBucketUpdateOne {
	obuo.mutation.SetName(s)
	return obuo
}

// SetTenantID sets the "tenant_id" field.
func (obuo *ObjectstorageBucketUpdateOne) SetTenantID(s string) *ObjectstorageBucketUpdateOne {
	obuo.mutation.SetTenantID(s)
	return obuo
}

// SetTenantName sets the "tenant_name" field.
func (obuo *ObjectstorageBucketUpdateOne) SetTenantName(s string) *ObjectstorageBucketUpdateOne {
	obuo.mutation.SetTenantName(s)
	return obuo
}

// SetNillableTenantName sets the "tenant_name" field if the given value is not nil.
func (obuo *ObjectstorageBucketUpdateOne) SetNillableTenantName(s *string) *ObjectstorageBucketUpdateOne {
	if s != nil {
		obuo.SetTenantName(*s)
	}
	return obuo
}

// ClearTenantName clears the value of the "tenant_name" field.
func (obuo *ObjectstorageBucketUpdateOne) ClearTenantName() *ObjectstorageBucketUpdateOne {
	obuo.mutation.ClearTenantName()
	return obuo
}

// SetProjectID sets the "project_id" field.
func (obuo *ObjectstorageBucketUpdateOne) SetProjectID(s string) *ObjectstorageBucketUpdateOne {
	obuo.mutation.SetProjectID(s)
	return obuo
}

// SetProjectName sets the "project_name" field.
func (obuo *ObjectstorageBucketUpdateOne) SetProjectName(s string) *ObjectstorageBucketUpdateOne {
	obuo.mutation.SetProjectName(s)
	return obuo
}

// SetStorageclass sets the "storageclass" field.
func (obuo *ObjectstorageBucketUpdateOne) SetStorageclass(s string) *ObjectstorageBucketUpdateOne {
	obuo.mutation.SetStorageclass(s)
	return obuo
}

// SetNillableStorageclass sets the "storageclass" field if the given value is not nil.
func (obuo *ObjectstorageBucketUpdateOne) SetNillableStorageclass(s *string) *ObjectstorageBucketUpdateOne {
	if s != nil {
		obuo.SetStorageclass(*s)
	}
	return obuo
}

// ClearStorageclass clears the value of the "storageclass" field.
func (obuo *ObjectstorageBucketUpdateOne) ClearStorageclass() *ObjectstorageBucketUpdateOne {
	obuo.mutation.ClearStorageclass()
	return obuo
}

// SetStorageclassName sets the "storageclass_name" field.
func (obuo *ObjectstorageBucketUpdateOne) SetStorageclassName(s string) *ObjectstorageBucketUpdateOne {
	obuo.mutation.SetStorageclassName(s)
	return obuo
}

// SetNillableStorageclassName sets the "storageclass_name" field if the given value is not nil.
func (obuo *ObjectstorageBucketUpdateOne) SetNillableStorageclassName(s *string) *ObjectstorageBucketUpdateOne {
	if s != nil {
		obuo.SetStorageclassName(*s)
	}
	return obuo
}

// ClearStorageclassName clears the value of the "storageclass_name" field.
func (obuo *ObjectstorageBucketUpdateOne) ClearStorageclassName() *ObjectstorageBucketUpdateOne {
	obuo.mutation.ClearStorageclassName()
	return obuo
}

// SetInnerEndpoint sets the "inner_endpoint" field.
func (obuo *ObjectstorageBucketUpdateOne) SetInnerEndpoint(s string) *ObjectstorageBucketUpdateOne {
	obuo.mutation.SetInnerEndpoint(s)
	return obuo
}

// SetOuterEndpoint sets the "outer_endpoint" field.
func (obuo *ObjectstorageBucketUpdateOne) SetOuterEndpoint(s string) *ObjectstorageBucketUpdateOne {
	obuo.mutation.SetOuterEndpoint(s)
	return obuo
}

// SetInnerDomain sets the "inner_domain" field.
func (obuo *ObjectstorageBucketUpdateOne) SetInnerDomain(s string) *ObjectstorageBucketUpdateOne {
	obuo.mutation.SetInnerDomain(s)
	return obuo
}

// SetNillableInnerDomain sets the "inner_domain" field if the given value is not nil.
func (obuo *ObjectstorageBucketUpdateOne) SetNillableInnerDomain(s *string) *ObjectstorageBucketUpdateOne {
	if s != nil {
		obuo.SetInnerDomain(*s)
	}
	return obuo
}

// ClearInnerDomain clears the value of the "inner_domain" field.
func (obuo *ObjectstorageBucketUpdateOne) ClearInnerDomain() *ObjectstorageBucketUpdateOne {
	obuo.mutation.ClearInnerDomain()
	return obuo
}

// SetOuterDomain sets the "outer_domain" field.
func (obuo *ObjectstorageBucketUpdateOne) SetOuterDomain(s string) *ObjectstorageBucketUpdateOne {
	obuo.mutation.SetOuterDomain(s)
	return obuo
}

// SetNillableOuterDomain sets the "outer_domain" field if the given value is not nil.
func (obuo *ObjectstorageBucketUpdateOne) SetNillableOuterDomain(s *string) *ObjectstorageBucketUpdateOne {
	if s != nil {
		obuo.SetOuterDomain(*s)
	}
	return obuo
}

// ClearOuterDomain clears the value of the "outer_domain" field.
func (obuo *ObjectstorageBucketUpdateOne) ClearOuterDomain() *ObjectstorageBucketUpdateOne {
	obuo.mutation.ClearOuterDomain()
	return obuo
}

// SetPoolID sets the "pool_id" field.
func (obuo *ObjectstorageBucketUpdateOne) SetPoolID(s string) *ObjectstorageBucketUpdateOne {
	obuo.mutation.SetPoolID(s)
	return obuo
}

// SetNillablePoolID sets the "pool_id" field if the given value is not nil.
func (obuo *ObjectstorageBucketUpdateOne) SetNillablePoolID(s *string) *ObjectstorageBucketUpdateOne {
	if s != nil {
		obuo.SetPoolID(*s)
	}
	return obuo
}

// ClearPoolID clears the value of the "pool_id" field.
func (obuo *ObjectstorageBucketUpdateOne) ClearPoolID() *ObjectstorageBucketUpdateOne {
	obuo.mutation.ClearPoolID()
	return obuo
}

// SetPoolName sets the "pool_name" field.
func (obuo *ObjectstorageBucketUpdateOne) SetPoolName(s string) *ObjectstorageBucketUpdateOne {
	obuo.mutation.SetPoolName(s)
	return obuo
}

// SetNillablePoolName sets the "pool_name" field if the given value is not nil.
func (obuo *ObjectstorageBucketUpdateOne) SetNillablePoolName(s *string) *ObjectstorageBucketUpdateOne {
	if s != nil {
		obuo.SetPoolName(*s)
	}
	return obuo
}

// ClearPoolName clears the value of the "pool_name" field.
func (obuo *ObjectstorageBucketUpdateOne) ClearPoolName() *ObjectstorageBucketUpdateOne {
	obuo.mutation.ClearPoolName()
	return obuo
}

// SetTotalStorage sets the "total_storage" field.
func (obuo *ObjectstorageBucketUpdateOne) SetTotalStorage(i int) *ObjectstorageBucketUpdateOne {
	obuo.mutation.ResetTotalStorage()
	obuo.mutation.SetTotalStorage(i)
	return obuo
}

// SetNillableTotalStorage sets the "total_storage" field if the given value is not nil.
func (obuo *ObjectstorageBucketUpdateOne) SetNillableTotalStorage(i *int) *ObjectstorageBucketUpdateOne {
	if i != nil {
		obuo.SetTotalStorage(*i)
	}
	return obuo
}

// AddTotalStorage adds i to the "total_storage" field.
func (obuo *ObjectstorageBucketUpdateOne) AddTotalStorage(i int) *ObjectstorageBucketUpdateOne {
	obuo.mutation.AddTotalStorage(i)
	return obuo
}

// ClearTotalStorage clears the value of the "total_storage" field.
func (obuo *ObjectstorageBucketUpdateOne) ClearTotalStorage() *ObjectstorageBucketUpdateOne {
	obuo.mutation.ClearTotalStorage()
	return obuo
}

// SetAddStorage sets the "add_storage" field.
func (obuo *ObjectstorageBucketUpdateOne) SetAddStorage(i int) *ObjectstorageBucketUpdateOne {
	obuo.mutation.ResetAddStorage()
	obuo.mutation.SetAddStorage(i)
	return obuo
}

// SetNillableAddStorage sets the "add_storage" field if the given value is not nil.
func (obuo *ObjectstorageBucketUpdateOne) SetNillableAddStorage(i *int) *ObjectstorageBucketUpdateOne {
	if i != nil {
		obuo.SetAddStorage(*i)
	}
	return obuo
}

// AddAddStorage adds i to the "add_storage" field.
func (obuo *ObjectstorageBucketUpdateOne) AddAddStorage(i int) *ObjectstorageBucketUpdateOne {
	obuo.mutation.AddAddStorage(i)
	return obuo
}

// ClearAddStorage clears the value of the "add_storage" field.
func (obuo *ObjectstorageBucketUpdateOne) ClearAddStorage() *ObjectstorageBucketUpdateOne {
	obuo.mutation.ClearAddStorage()
	return obuo
}

// SetDeleteStorage sets the "delete_storage" field.
func (obuo *ObjectstorageBucketUpdateOne) SetDeleteStorage(i int) *ObjectstorageBucketUpdateOne {
	obuo.mutation.ResetDeleteStorage()
	obuo.mutation.SetDeleteStorage(i)
	return obuo
}

// SetNillableDeleteStorage sets the "delete_storage" field if the given value is not nil.
func (obuo *ObjectstorageBucketUpdateOne) SetNillableDeleteStorage(i *int) *ObjectstorageBucketUpdateOne {
	if i != nil {
		obuo.SetDeleteStorage(*i)
	}
	return obuo
}

// AddDeleteStorage adds i to the "delete_storage" field.
func (obuo *ObjectstorageBucketUpdateOne) AddDeleteStorage(i int) *ObjectstorageBucketUpdateOne {
	obuo.mutation.AddDeleteStorage(i)
	return obuo
}

// ClearDeleteStorage clears the value of the "delete_storage" field.
func (obuo *ObjectstorageBucketUpdateOne) ClearDeleteStorage() *ObjectstorageBucketUpdateOne {
	obuo.mutation.ClearDeleteStorage()
	return obuo
}

// SetTotalObject sets the "total_object" field.
func (obuo *ObjectstorageBucketUpdateOne) SetTotalObject(i int) *ObjectstorageBucketUpdateOne {
	obuo.mutation.ResetTotalObject()
	obuo.mutation.SetTotalObject(i)
	return obuo
}

// SetNillableTotalObject sets the "total_object" field if the given value is not nil.
func (obuo *ObjectstorageBucketUpdateOne) SetNillableTotalObject(i *int) *ObjectstorageBucketUpdateOne {
	if i != nil {
		obuo.SetTotalObject(*i)
	}
	return obuo
}

// AddTotalObject adds i to the "total_object" field.
func (obuo *ObjectstorageBucketUpdateOne) AddTotalObject(i int) *ObjectstorageBucketUpdateOne {
	obuo.mutation.AddTotalObject(i)
	return obuo
}

// ClearTotalObject clears the value of the "total_object" field.
func (obuo *ObjectstorageBucketUpdateOne) ClearTotalObject() *ObjectstorageBucketUpdateOne {
	obuo.mutation.ClearTotalObject()
	return obuo
}

// SetAddObject sets the "add_object" field.
func (obuo *ObjectstorageBucketUpdateOne) SetAddObject(i int) *ObjectstorageBucketUpdateOne {
	obuo.mutation.ResetAddObject()
	obuo.mutation.SetAddObject(i)
	return obuo
}

// SetNillableAddObject sets the "add_object" field if the given value is not nil.
func (obuo *ObjectstorageBucketUpdateOne) SetNillableAddObject(i *int) *ObjectstorageBucketUpdateOne {
	if i != nil {
		obuo.SetAddObject(*i)
	}
	return obuo
}

// AddAddObject adds i to the "add_object" field.
func (obuo *ObjectstorageBucketUpdateOne) AddAddObject(i int) *ObjectstorageBucketUpdateOne {
	obuo.mutation.AddAddObject(i)
	return obuo
}

// ClearAddObject clears the value of the "add_object" field.
func (obuo *ObjectstorageBucketUpdateOne) ClearAddObject() *ObjectstorageBucketUpdateOne {
	obuo.mutation.ClearAddObject()
	return obuo
}

// SetDeleteObject sets the "delete_object" field.
func (obuo *ObjectstorageBucketUpdateOne) SetDeleteObject(i int) *ObjectstorageBucketUpdateOne {
	obuo.mutation.ResetDeleteObject()
	obuo.mutation.SetDeleteObject(i)
	return obuo
}

// SetNillableDeleteObject sets the "delete_object" field if the given value is not nil.
func (obuo *ObjectstorageBucketUpdateOne) SetNillableDeleteObject(i *int) *ObjectstorageBucketUpdateOne {
	if i != nil {
		obuo.SetDeleteObject(*i)
	}
	return obuo
}

// AddDeleteObject adds i to the "delete_object" field.
func (obuo *ObjectstorageBucketUpdateOne) AddDeleteObject(i int) *ObjectstorageBucketUpdateOne {
	obuo.mutation.AddDeleteObject(i)
	return obuo
}

// ClearDeleteObject clears the value of the "delete_object" field.
func (obuo *ObjectstorageBucketUpdateOne) ClearDeleteObject() *ObjectstorageBucketUpdateOne {
	obuo.mutation.ClearDeleteObject()
	return obuo
}

// SetDownloadFlow sets the "download_flow" field.
func (obuo *ObjectstorageBucketUpdateOne) SetDownloadFlow(i int) *ObjectstorageBucketUpdateOne {
	obuo.mutation.ResetDownloadFlow()
	obuo.mutation.SetDownloadFlow(i)
	return obuo
}

// SetNillableDownloadFlow sets the "download_flow" field if the given value is not nil.
func (obuo *ObjectstorageBucketUpdateOne) SetNillableDownloadFlow(i *int) *ObjectstorageBucketUpdateOne {
	if i != nil {
		obuo.SetDownloadFlow(*i)
	}
	return obuo
}

// AddDownloadFlow adds i to the "download_flow" field.
func (obuo *ObjectstorageBucketUpdateOne) AddDownloadFlow(i int) *ObjectstorageBucketUpdateOne {
	obuo.mutation.AddDownloadFlow(i)
	return obuo
}

// ClearDownloadFlow clears the value of the "download_flow" field.
func (obuo *ObjectstorageBucketUpdateOne) ClearDownloadFlow() *ObjectstorageBucketUpdateOne {
	obuo.mutation.ClearDownloadFlow()
	return obuo
}

// SetUploadFlow sets the "upload_flow" field.
func (obuo *ObjectstorageBucketUpdateOne) SetUploadFlow(i int) *ObjectstorageBucketUpdateOne {
	obuo.mutation.ResetUploadFlow()
	obuo.mutation.SetUploadFlow(i)
	return obuo
}

// SetNillableUploadFlow sets the "upload_flow" field if the given value is not nil.
func (obuo *ObjectstorageBucketUpdateOne) SetNillableUploadFlow(i *int) *ObjectstorageBucketUpdateOne {
	if i != nil {
		obuo.SetUploadFlow(*i)
	}
	return obuo
}

// AddUploadFlow adds i to the "upload_flow" field.
func (obuo *ObjectstorageBucketUpdateOne) AddUploadFlow(i int) *ObjectstorageBucketUpdateOne {
	obuo.mutation.AddUploadFlow(i)
	return obuo
}

// ClearUploadFlow clears the value of the "upload_flow" field.
func (obuo *ObjectstorageBucketUpdateOne) ClearUploadFlow() *ObjectstorageBucketUpdateOne {
	obuo.mutation.ClearUploadFlow()
	return obuo
}

// SetRequestAmount sets the "request_amount" field.
func (obuo *ObjectstorageBucketUpdateOne) SetRequestAmount(i int) *ObjectstorageBucketUpdateOne {
	obuo.mutation.ResetRequestAmount()
	obuo.mutation.SetRequestAmount(i)
	return obuo
}

// SetNillableRequestAmount sets the "request_amount" field if the given value is not nil.
func (obuo *ObjectstorageBucketUpdateOne) SetNillableRequestAmount(i *int) *ObjectstorageBucketUpdateOne {
	if i != nil {
		obuo.SetRequestAmount(*i)
	}
	return obuo
}

// AddRequestAmount adds i to the "request_amount" field.
func (obuo *ObjectstorageBucketUpdateOne) AddRequestAmount(i int) *ObjectstorageBucketUpdateOne {
	obuo.mutation.AddRequestAmount(i)
	return obuo
}

// ClearRequestAmount clears the value of the "request_amount" field.
func (obuo *ObjectstorageBucketUpdateOne) ClearRequestAmount() *ObjectstorageBucketUpdateOne {
	obuo.mutation.ClearRequestAmount()
	return obuo
}

// SetDownloadFlowMonth sets the "download_flow_month" field.
func (obuo *ObjectstorageBucketUpdateOne) SetDownloadFlowMonth(i int) *ObjectstorageBucketUpdateOne {
	obuo.mutation.ResetDownloadFlowMonth()
	obuo.mutation.SetDownloadFlowMonth(i)
	return obuo
}

// AddDownloadFlowMonth adds i to the "download_flow_month" field.
func (obuo *ObjectstorageBucketUpdateOne) AddDownloadFlowMonth(i int) *ObjectstorageBucketUpdateOne {
	obuo.mutation.AddDownloadFlowMonth(i)
	return obuo
}

// SetUploadFlowMonth sets the "upload_flow_month" field.
func (obuo *ObjectstorageBucketUpdateOne) SetUploadFlowMonth(i int) *ObjectstorageBucketUpdateOne {
	obuo.mutation.ResetUploadFlowMonth()
	obuo.mutation.SetUploadFlowMonth(i)
	return obuo
}

// AddUploadFlowMonth adds i to the "upload_flow_month" field.
func (obuo *ObjectstorageBucketUpdateOne) AddUploadFlowMonth(i int) *ObjectstorageBucketUpdateOne {
	obuo.mutation.AddUploadFlowMonth(i)
	return obuo
}

// SetRequestAmountMonth sets the "request_amount_month" field.
func (obuo *ObjectstorageBucketUpdateOne) SetRequestAmountMonth(i int) *ObjectstorageBucketUpdateOne {
	obuo.mutation.ResetRequestAmountMonth()
	obuo.mutation.SetRequestAmountMonth(i)
	return obuo
}

// AddRequestAmountMonth adds i to the "request_amount_month" field.
func (obuo *ObjectstorageBucketUpdateOne) AddRequestAmountMonth(i int) *ObjectstorageBucketUpdateOne {
	obuo.mutation.AddRequestAmountMonth(i)
	return obuo
}

// SetCreateTime sets the "create_time" field.
func (obuo *ObjectstorageBucketUpdateOne) SetCreateTime(t time.Time) *ObjectstorageBucketUpdateOne {
	obuo.mutation.SetCreateTime(t)
	return obuo
}

// SetNillableCreateTime sets the "create_time" field if the given value is not nil.
func (obuo *ObjectstorageBucketUpdateOne) SetNillableCreateTime(t *time.Time) *ObjectstorageBucketUpdateOne {
	if t != nil {
		obuo.SetCreateTime(*t)
	}
	return obuo
}

// ClearCreateTime clears the value of the "create_time" field.
func (obuo *ObjectstorageBucketUpdateOne) ClearCreateTime() *ObjectstorageBucketUpdateOne {
	obuo.mutation.ClearCreateTime()
	return obuo
}

// Mutation returns the ObjectstorageBucketMutation object of the builder.
func (obuo *ObjectstorageBucketUpdateOne) Mutation() *ObjectstorageBucketMutation {
	return obuo.mutation
}

// Where appends a list predicates to the ObjectstorageBucketUpdate builder.
func (obuo *ObjectstorageBucketUpdateOne) Where(ps ...predicate.ObjectstorageBucket) *ObjectstorageBucketUpdateOne {
	obuo.mutation.Where(ps...)
	return obuo
}

// Select allows selecting one or more fields (columns) of the returned entity.
// The default is selecting all fields defined in the entity schema.
func (obuo *ObjectstorageBucketUpdateOne) Select(field string, fields ...string) *ObjectstorageBucketUpdateOne {
	obuo.fields = append([]string{field}, fields...)
	return obuo
}

// Save executes the query and returns the updated ObjectstorageBucket entity.
func (obuo *ObjectstorageBucketUpdateOne) Save(ctx context.Context) (*ObjectstorageBucket, error) {
	return withHooks[*ObjectstorageBucket, ObjectstorageBucketMutation](ctx, obuo.sqlSave, obuo.mutation, obuo.hooks)
}

// SaveX is like Save, but panics if an error occurs.
func (obuo *ObjectstorageBucketUpdateOne) SaveX(ctx context.Context) *ObjectstorageBucket {
	node, err := obuo.Save(ctx)
	if err != nil {
		panic(err)
	}
	return node
}

// Exec executes the query on the entity.
func (obuo *ObjectstorageBucketUpdateOne) Exec(ctx context.Context) error {
	_, err := obuo.Save(ctx)
	return err
}

// ExecX is like Exec, but panics if an error occurs.
func (obuo *ObjectstorageBucketUpdateOne) ExecX(ctx context.Context) {
	if err := obuo.Exec(ctx); err != nil {
		panic(err)
	}
}

func (obuo *ObjectstorageBucketUpdateOne) sqlSave(ctx context.Context) (_node *ObjectstorageBucket, err error) {
	_spec := sqlgraph.NewUpdateSpec(objectstoragebucket.Table, objectstoragebucket.Columns, sqlgraph.NewFieldSpec(objectstoragebucket.FieldID, field.TypeUint64))
	id, ok := obuo.mutation.ID()
	if !ok {
		return nil, &ValidationError{Name: "id", err: errors.New(`ent: missing "ObjectstorageBucket.id" for update`)}
	}
	_spec.Node.ID.Value = id
	if fields := obuo.fields; len(fields) > 0 {
		_spec.Node.Columns = make([]string, 0, len(fields))
		_spec.Node.Columns = append(_spec.Node.Columns, objectstoragebucket.FieldID)
		for _, f := range fields {
			if !objectstoragebucket.ValidColumn(f) {
				return nil, &ValidationError{Name: f, err: fmt.Errorf("ent: invalid field %q for query", f)}
			}
			if f != objectstoragebucket.FieldID {
				_spec.Node.Columns = append(_spec.Node.Columns, f)
			}
		}
	}
	if ps := obuo.mutation.predicates; len(ps) > 0 {
		_spec.Predicate = func(selector *sql.Selector) {
			for i := range ps {
				ps[i](selector)
			}
		}
	}
	if value, ok := obuo.mutation.CreatedAt(); ok {
		_spec.SetField(objectstoragebucket.FieldCreatedAt, field.TypeTime, value)
	}
	if obuo.mutation.CreatedAtCleared() {
		_spec.ClearField(objectstoragebucket.FieldCreatedAt, field.TypeTime)
	}
	if value, ok := obuo.mutation.UpdatedAt(); ok {
		_spec.SetField(objectstoragebucket.FieldUpdatedAt, field.TypeTime, value)
	}
	if obuo.mutation.UpdatedAtCleared() {
		_spec.ClearField(objectstoragebucket.FieldUpdatedAt, field.TypeTime)
	}
	if value, ok := obuo.mutation.Version(); ok {
		_spec.SetField(objectstoragebucket.FieldVersion, field.TypeString, value)
	}
	if obuo.mutation.VersionCleared() {
		_spec.ClearField(objectstoragebucket.FieldVersion, field.TypeString)
	}
	if value, ok := obuo.mutation.Galaxy(); ok {
		_spec.SetField(objectstoragebucket.FieldGalaxy, field.TypeString, value)
	}
	if obuo.mutation.GalaxyCleared() {
		_spec.ClearField(objectstoragebucket.FieldGalaxy, field.TypeString)
	}
	if value, ok := obuo.mutation.Region(); ok {
		_spec.SetField(objectstoragebucket.FieldRegion, field.TypeString, value)
	}
	if obuo.mutation.RegionCleared() {
		_spec.ClearField(objectstoragebucket.FieldRegion, field.TypeString)
	}
	if value, ok := obuo.mutation.Deleted(); ok {
		_spec.SetField(objectstoragebucket.FieldDeleted, field.TypeBool, value)
	}
	if obuo.mutation.DeletedCleared() {
		_spec.ClearField(objectstoragebucket.FieldDeleted, field.TypeBool)
	}
	if value, ok := obuo.mutation.BucketID(); ok {
		_spec.SetField(objectstoragebucket.FieldBucketID, field.TypeInt, value)
	}
	if value, ok := obuo.mutation.AddedBucketID(); ok {
		_spec.AddField(objectstoragebucket.FieldBucketID, field.TypeInt, value)
	}
	if value, ok := obuo.mutation.Name(); ok {
		_spec.SetField(objectstoragebucket.FieldName, field.TypeString, value)
	}
	if value, ok := obuo.mutation.TenantID(); ok {
		_spec.SetField(objectstoragebucket.FieldTenantID, field.TypeString, value)
	}
	if value, ok := obuo.mutation.TenantName(); ok {
		_spec.SetField(objectstoragebucket.FieldTenantName, field.TypeString, value)
	}
	if obuo.mutation.TenantNameCleared() {
		_spec.ClearField(objectstoragebucket.FieldTenantName, field.TypeString)
	}
	if value, ok := obuo.mutation.ProjectID(); ok {
		_spec.SetField(objectstoragebucket.FieldProjectID, field.TypeString, value)
	}
	if value, ok := obuo.mutation.ProjectName(); ok {
		_spec.SetField(objectstoragebucket.FieldProjectName, field.TypeString, value)
	}
	if value, ok := obuo.mutation.Storageclass(); ok {
		_spec.SetField(objectstoragebucket.FieldStorageclass, field.TypeString, value)
	}
	if obuo.mutation.StorageclassCleared() {
		_spec.ClearField(objectstoragebucket.FieldStorageclass, field.TypeString)
	}
	if value, ok := obuo.mutation.StorageclassName(); ok {
		_spec.SetField(objectstoragebucket.FieldStorageclassName, field.TypeString, value)
	}
	if obuo.mutation.StorageclassNameCleared() {
		_spec.ClearField(objectstoragebucket.FieldStorageclassName, field.TypeString)
	}
	if value, ok := obuo.mutation.InnerEndpoint(); ok {
		_spec.SetField(objectstoragebucket.FieldInnerEndpoint, field.TypeString, value)
	}
	if value, ok := obuo.mutation.OuterEndpoint(); ok {
		_spec.SetField(objectstoragebucket.FieldOuterEndpoint, field.TypeString, value)
	}
	if value, ok := obuo.mutation.InnerDomain(); ok {
		_spec.SetField(objectstoragebucket.FieldInnerDomain, field.TypeString, value)
	}
	if obuo.mutation.InnerDomainCleared() {
		_spec.ClearField(objectstoragebucket.FieldInnerDomain, field.TypeString)
	}
	if value, ok := obuo.mutation.OuterDomain(); ok {
		_spec.SetField(objectstoragebucket.FieldOuterDomain, field.TypeString, value)
	}
	if obuo.mutation.OuterDomainCleared() {
		_spec.ClearField(objectstoragebucket.FieldOuterDomain, field.TypeString)
	}
	if value, ok := obuo.mutation.PoolID(); ok {
		_spec.SetField(objectstoragebucket.FieldPoolID, field.TypeString, value)
	}
	if obuo.mutation.PoolIDCleared() {
		_spec.ClearField(objectstoragebucket.FieldPoolID, field.TypeString)
	}
	if value, ok := obuo.mutation.PoolName(); ok {
		_spec.SetField(objectstoragebucket.FieldPoolName, field.TypeString, value)
	}
	if obuo.mutation.PoolNameCleared() {
		_spec.ClearField(objectstoragebucket.FieldPoolName, field.TypeString)
	}
	if value, ok := obuo.mutation.TotalStorage(); ok {
		_spec.SetField(objectstoragebucket.FieldTotalStorage, field.TypeInt, value)
	}
	if value, ok := obuo.mutation.AddedTotalStorage(); ok {
		_spec.AddField(objectstoragebucket.FieldTotalStorage, field.TypeInt, value)
	}
	if obuo.mutation.TotalStorageCleared() {
		_spec.ClearField(objectstoragebucket.FieldTotalStorage, field.TypeInt)
	}
	if value, ok := obuo.mutation.AddStorage(); ok {
		_spec.SetField(objectstoragebucket.FieldAddStorage, field.TypeInt, value)
	}
	if value, ok := obuo.mutation.AddedAddStorage(); ok {
		_spec.AddField(objectstoragebucket.FieldAddStorage, field.TypeInt, value)
	}
	if obuo.mutation.AddStorageCleared() {
		_spec.ClearField(objectstoragebucket.FieldAddStorage, field.TypeInt)
	}
	if value, ok := obuo.mutation.DeleteStorage(); ok {
		_spec.SetField(objectstoragebucket.FieldDeleteStorage, field.TypeInt, value)
	}
	if value, ok := obuo.mutation.AddedDeleteStorage(); ok {
		_spec.AddField(objectstoragebucket.FieldDeleteStorage, field.TypeInt, value)
	}
	if obuo.mutation.DeleteStorageCleared() {
		_spec.ClearField(objectstoragebucket.FieldDeleteStorage, field.TypeInt)
	}
	if value, ok := obuo.mutation.TotalObject(); ok {
		_spec.SetField(objectstoragebucket.FieldTotalObject, field.TypeInt, value)
	}
	if value, ok := obuo.mutation.AddedTotalObject(); ok {
		_spec.AddField(objectstoragebucket.FieldTotalObject, field.TypeInt, value)
	}
	if obuo.mutation.TotalObjectCleared() {
		_spec.ClearField(objectstoragebucket.FieldTotalObject, field.TypeInt)
	}
	if value, ok := obuo.mutation.AddObject(); ok {
		_spec.SetField(objectstoragebucket.FieldAddObject, field.TypeInt, value)
	}
	if value, ok := obuo.mutation.AddedAddObject(); ok {
		_spec.AddField(objectstoragebucket.FieldAddObject, field.TypeInt, value)
	}
	if obuo.mutation.AddObjectCleared() {
		_spec.ClearField(objectstoragebucket.FieldAddObject, field.TypeInt)
	}
	if value, ok := obuo.mutation.DeleteObject(); ok {
		_spec.SetField(objectstoragebucket.FieldDeleteObject, field.TypeInt, value)
	}
	if value, ok := obuo.mutation.AddedDeleteObject(); ok {
		_spec.AddField(objectstoragebucket.FieldDeleteObject, field.TypeInt, value)
	}
	if obuo.mutation.DeleteObjectCleared() {
		_spec.ClearField(objectstoragebucket.FieldDeleteObject, field.TypeInt)
	}
	if value, ok := obuo.mutation.DownloadFlow(); ok {
		_spec.SetField(objectstoragebucket.FieldDownloadFlow, field.TypeInt, value)
	}
	if value, ok := obuo.mutation.AddedDownloadFlow(); ok {
		_spec.AddField(objectstoragebucket.FieldDownloadFlow, field.TypeInt, value)
	}
	if obuo.mutation.DownloadFlowCleared() {
		_spec.ClearField(objectstoragebucket.FieldDownloadFlow, field.TypeInt)
	}
	if value, ok := obuo.mutation.UploadFlow(); ok {
		_spec.SetField(objectstoragebucket.FieldUploadFlow, field.TypeInt, value)
	}
	if value, ok := obuo.mutation.AddedUploadFlow(); ok {
		_spec.AddField(objectstoragebucket.FieldUploadFlow, field.TypeInt, value)
	}
	if obuo.mutation.UploadFlowCleared() {
		_spec.ClearField(objectstoragebucket.FieldUploadFlow, field.TypeInt)
	}
	if value, ok := obuo.mutation.RequestAmount(); ok {
		_spec.SetField(objectstoragebucket.FieldRequestAmount, field.TypeInt, value)
	}
	if value, ok := obuo.mutation.AddedRequestAmount(); ok {
		_spec.AddField(objectstoragebucket.FieldRequestAmount, field.TypeInt, value)
	}
	if obuo.mutation.RequestAmountCleared() {
		_spec.ClearField(objectstoragebucket.FieldRequestAmount, field.TypeInt)
	}
	if value, ok := obuo.mutation.DownloadFlowMonth(); ok {
		_spec.SetField(objectstoragebucket.FieldDownloadFlowMonth, field.TypeInt, value)
	}
	if value, ok := obuo.mutation.AddedDownloadFlowMonth(); ok {
		_spec.AddField(objectstoragebucket.FieldDownloadFlowMonth, field.TypeInt, value)
	}
	if value, ok := obuo.mutation.UploadFlowMonth(); ok {
		_spec.SetField(objectstoragebucket.FieldUploadFlowMonth, field.TypeInt, value)
	}
	if value, ok := obuo.mutation.AddedUploadFlowMonth(); ok {
		_spec.AddField(objectstoragebucket.FieldUploadFlowMonth, field.TypeInt, value)
	}
	if value, ok := obuo.mutation.RequestAmountMonth(); ok {
		_spec.SetField(objectstoragebucket.FieldRequestAmountMonth, field.TypeInt, value)
	}
	if value, ok := obuo.mutation.AddedRequestAmountMonth(); ok {
		_spec.AddField(objectstoragebucket.FieldRequestAmountMonth, field.TypeInt, value)
	}
	if value, ok := obuo.mutation.CreateTime(); ok {
		_spec.SetField(objectstoragebucket.FieldCreateTime, field.TypeTime, value)
	}
	if obuo.mutation.CreateTimeCleared() {
		_spec.ClearField(objectstoragebucket.FieldCreateTime, field.TypeTime)
	}
	_node = &ObjectstorageBucket{config: obuo.config}
	_spec.Assign = _node.assignValues
	_spec.ScanValues = _node.scanValues
	if err = sqlgraph.UpdateNode(ctx, obuo.driver, _spec); err != nil {
		if _, ok := err.(*sqlgraph.NotFoundError); ok {
			err = &NotFoundError{objectstoragebucket.Label}
		} else if sqlgraph.IsConstraintError(err) {
			err = &ConstraintError{msg: err.Error(), wrap: err}
		}
		return nil, err
	}
	obuo.mutation.done = true
	return _node, nil
}

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/data/ent/objectstoragebucket_delete.go
```golang
// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"luban-cmdb-api/data/ent/objectstoragebucket"
	"luban-cmdb-api/data/ent/predicate"

	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
	"entgo.io/ent/schema/field"
)

// ObjectstorageBucketDelete is the builder for deleting a ObjectstorageBucket entity.
type ObjectstorageBucketDelete struct {
	config
	hooks    []Hook
	mutation *ObjectstorageBucketMutation
}

// Where appends a list predicates to the ObjectstorageBucketDelete builder.
func (obd *ObjectstorageBucketDelete) Where(ps ...predicate.ObjectstorageBucket) *ObjectstorageBucketDelete {
	obd.mutation.Where(ps...)
	return obd
}

// Exec executes the deletion query and returns how many vertices were deleted.
func (obd *ObjectstorageBucketDelete) Exec(ctx context.Context) (int, error) {
	return withHooks[int, ObjectstorageBucketMutation](ctx, obd.sqlExec, obd.mutation, obd.hooks)
}

// ExecX is like Exec, but panics if an error occurs.
func (obd *ObjectstorageBucketDelete) ExecX(ctx context.Context) int {
	n, err := obd.Exec(ctx)
	if err != nil {
		panic(err)
	}
	return n
}

func (obd *ObjectstorageBucketDelete) sqlExec(ctx context.Context) (int, error) {
	_spec := sqlgraph.NewDeleteSpec(objectstoragebucket.Table, sqlgraph.NewFieldSpec(objectstoragebucket.FieldID, field.TypeUint64))
	if ps := obd.mutation.predicates; len(ps) > 0 {
		_spec.Predicate = func(selector *sql.Selector) {
			for i := range ps {
				ps[i](selector)
			}
		}
	}
	affected, err := sqlgraph.DeleteNodes(ctx, obd.driver, _spec)
	if err != nil && sqlgraph.IsConstraintError(err) {
		err = &ConstraintError{msg: err.Error(), wrap: err}
	}
	obd.mutation.done = true
	return affected, err
}

// ObjectstorageBucketDeleteOne is the builder for deleting a single ObjectstorageBucket entity.
type ObjectstorageBucketDeleteOne struct {
	obd *ObjectstorageBucketDelete
}

// Where appends a list predicates to the ObjectstorageBucketDelete builder.
func (obdo *ObjectstorageBucketDeleteOne) Where(ps ...predicate.ObjectstorageBucket) *ObjectstorageBucketDeleteOne {
	obdo.obd.mutation.Where(ps...)
	return obdo
}

// Exec executes the deletion query.
func (obdo *ObjectstorageBucketDeleteOne) Exec(ctx context.Context) error {
	n, err := obdo.obd.Exec(ctx)
	switch {
	case err != nil:
		return err
	case n == 0:
		return &NotFoundError{objectstoragebucket.Label}
	default:
		return nil
	}
}

// ExecX is like Exec, but panics if an error occurs.
func (obdo *ObjectstorageBucketDeleteOne) ExecX(ctx context.Context) {
	if err := obdo.Exec(ctx); err != nil {
		panic(err)
	}
}

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/data/ent/client.go
```golang
// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"log"

	"luban-cmdb-api/data/ent/migrate"

	"luban-cmdb-api/data/ent/blockstorage"
	"luban-cmdb-api/data/ent/ebsvolume"
	"luban-cmdb-api/data/ent/objectstorage"
	"luban-cmdb-api/data/ent/objectstoragebucket"

	"entgo.io/ent"
	"entgo.io/ent/dialect"
	"entgo.io/ent/dialect/sql"
)

// Client is the client that holds all ent builders.
type Client struct {
	config
	// Schema is the client for creating, migrating and dropping schema.
	Schema *migrate.Schema
	// BlockStorage is the client for interacting with the BlockStorage builders.
	BlockStorage *BlockStorageClient
	// EbsVolume is the client for interacting with the EbsVolume builders.
	EbsVolume *EbsVolumeClient
	// ObjectStorage is the client for interacting with the ObjectStorage builders.
	ObjectStorage *ObjectStorageClient
	// ObjectstorageBucket is the client for interacting with the ObjectstorageBucket builders.
	ObjectstorageBucket *ObjectstorageBucketClient
}

// NewClient creates a new client configured with the given options.
func NewClient(opts ...Option) *Client {
	cfg := config{log: log.Println, hooks: &hooks{}, inters: &inters{}}
	cfg.options(opts...)
	client := &Client{config: cfg}
	client.init()
	return client
}

func (c *Client) init() {
	c.Schema = migrate.NewSchema(c.driver)
	c.BlockStorage = NewBlockStorageClient(c.config)
	c.EbsVolume = NewEbsVolumeClient(c.config)
	c.ObjectStorage = NewObjectStorageClient(c.config)
	c.ObjectstorageBucket = NewObjectstorageBucketClient(c.config)
}

type (
	// config is the configuration for the client and its builder.
	config struct {
		// driver used for executing database requests.
		driver dialect.Driver
		// debug enable a debug logging.
		debug bool
		// log used for logging on debug mode.
		log func(...any)
		// hooks to execute on mutations.
		hooks *hooks
		// interceptors to execute on queries.
		inters *inters
	}
	// Option function to configure the client.
	Option func(*config)
)

// options applies the options on the config object.
func (c *config) options(opts ...Option) {
	for _, opt := range opts {
		opt(c)
	}
	if c.debug {
		c.driver = dialect.Debug(c.driver, c.log)
	}
}

// Debug enables debug logging on the ent.Driver.
func Debug() Option {
	return func(c *config) {
		c.debug = true
	}
}

// Log sets the logging function for debug mode.
func Log(fn func(...any)) Option {
	return func(c *config) {
		c.log = fn
	}
}

// Driver configures the client driver.
func Driver(driver dialect.Driver) Option {
	return func(c *config) {
		c.driver = driver
	}
}

// Open opens a database/sql.DB specified by the driver name and
// the data source name, and returns a new client attached to it.
// Optional parameters can be added for configuring the client.
func Open(driverName, dataSourceName string, options ...Option) (*Client, error) {
	switch driverName {
	case dialect.MySQL, dialect.Postgres, dialect.SQLite:
		drv, err := sql.Open(driverName, dataSourceName)
		if err != nil {
			return nil, err
		}
		return NewClient(append(options, Driver(drv))...), nil
	default:
		return nil, fmt.Errorf("unsupported driver: %q", driverName)
	}
}

// Tx returns a new transactional client. The provided context
// is used until the transaction is committed or rolled back.
func (c *Client) Tx(ctx context.Context) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, errors.New("ent: cannot start a transaction within a transaction")
	}
	tx, err := newTx(ctx, c.driver)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = tx
	return &Tx{
		ctx:                 ctx,
		config:              cfg,
		BlockStorage:        NewBlockStorageClient(cfg),
		EbsVolume:           NewEbsVolumeClient(cfg),
		ObjectStorage:       NewObjectStorageClient(cfg),
		ObjectstorageBucket: NewObjectstorageBucketClient(cfg),
	}, nil
}

// BeginTx returns a transactional client with specified options.
func (c *Client) BeginTx(ctx context.Context, opts *sql.TxOptions) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, errors.New("ent: cannot start a transaction within a transaction")
	}
	tx, err := c.driver.(interface {
		BeginTx(context.Context, *sql.TxOptions) (dialect.Tx, error)
	}).BeginTx(ctx, opts)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = &txDriver{tx: tx, drv: c.driver}
	return &Tx{
		ctx:                 ctx,
		config:              cfg,
		BlockStorage:        NewBlockStorageClient(cfg),
		EbsVolume:           NewEbsVolumeClient(cfg),
		ObjectStorage:       NewObjectStorageClient(cfg),
		ObjectstorageBucket: NewObjectstorageBucketClient(cfg),
	}, nil
}

// Debug returns a new debug-client. It's used to get verbose logging on specific operations.
//
//	client.Debug().
//		BlockStorage.
//		Query().
//		Count(ctx)
func (c *Client) Debug() *Client {
	if c.debug {
		return c
	}
	cfg := c.config
	cfg.driver = dialect.Debug(c.driver, c.log)
	client := &Client{config: cfg}
	client.init()
	return client
}

// Close closes the database connection and prevents new queries from starting.
func (c *Client) Close() error {
	return c.driver.Close()
}

// Use adds the mutation hooks to all the entity clients.
// In order to add hooks to a specific client, call: `client.Node.Use(...)`.
func (c *Client) Use(hooks ...Hook) {
	c.BlockStorage.Use(hooks...)
	c.EbsVolume.Use(hooks...)
	c.ObjectStorage.Use(hooks...)
	c.ObjectstorageBucket.Use(hooks...)
}

// Intercept adds the query interceptors to all the entity clients.
// In order to add interceptors to a specific client, call: `client.Node.Intercept(...)`.
func (c *Client) Intercept(interceptors ...Interceptor) {
	c.BlockStorage.Intercept(interceptors...)
	c.EbsVolume.Intercept(interceptors...)
	c.ObjectStorage.Intercept(interceptors...)
	c.ObjectstorageBucket.Intercept(interceptors...)
}

// Mutate implements the ent.Mutator interface.
func (c *Client) Mutate(ctx context.Context, m Mutation) (Value, error) {
	switch m := m.(type) {
	case *BlockStorageMutation:
		return c.BlockStorage.mutate(ctx, m)
	case *EbsVolumeMutation:
		return c.EbsVolume.mutate(ctx, m)
	case *ObjectStorageMutation:
		return c.ObjectStorage.mutate(ctx, m)
	case *ObjectstorageBucketMutation:
		return c.ObjectstorageBucket.mutate(ctx, m)
	default:
		return nil, fmt.Errorf("ent: unknown mutation type %T", m)
	}
}

// BlockStorageClient is a client for the BlockStorage schema.
type BlockStorageClient struct {
	config
}

// NewBlockStorageClient returns a client for the BlockStorage from the given config.
func NewBlockStorageClient(c config) *BlockStorageClient {
	return &BlockStorageClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `blockstorage.Hooks(f(g(h())))`.
func (c *BlockStorageClient) Use(hooks ...Hook) {
	c.hooks.BlockStorage = append(c.hooks.BlockStorage, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `blockstorage.Intercept(f(g(h())))`.
func (c *BlockStorageClient) Intercept(interceptors ...Interceptor) {
	c.inters.BlockStorage = append(c.inters.BlockStorage, interceptors...)
}

// Create returns a builder for creating a BlockStorage entity.
func (c *BlockStorageClient) Create() *BlockStorageCreate {
	mutation := newBlockStorageMutation(c.config, OpCreate)
	return &BlockStorageCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of BlockStorage entities.
func (c *BlockStorageClient) CreateBulk(builders ...*BlockStorageCreate) *BlockStorageCreateBulk {
	return &BlockStorageCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for BlockStorage.
func (c *BlockStorageClient) Update() *BlockStorageUpdate {
	mutation := newBlockStorageMutation(c.config, OpUpdate)
	return &BlockStorageUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *BlockStorageClient) UpdateOne(bs *BlockStorage) *BlockStorageUpdateOne {
	mutation := newBlockStorageMutation(c.config, OpUpdateOne, withBlockStorage(bs))
	return &BlockStorageUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *BlockStorageClient) UpdateOneID(id int) *BlockStorageUpdateOne {
	mutation := newBlockStorageMutation(c.config, OpUpdateOne, withBlockStorageID(id))
	return &BlockStorageUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for BlockStorage.
func (c *BlockStorageClient) Delete() *BlockStorageDelete {
	mutation := newBlockStorageMutation(c.config, OpDelete)
	return &BlockStorageDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *BlockStorageClient) DeleteOne(bs *BlockStorage) *BlockStorageDeleteOne {
	return c.DeleteOneID(bs.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *BlockStorageClient) DeleteOneID(id int) *BlockStorageDeleteOne {
	builder := c.Delete().Where(blockstorage.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &BlockStorageDeleteOne{builder}
}

// Query returns a query builder for BlockStorage.
func (c *BlockStorageClient) Query() *BlockStorageQuery {
	return &BlockStorageQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeBlockStorage},
		inters: c.Interceptors(),
	}
}

// Get returns a BlockStorage entity by its id.
func (c *BlockStorageClient) Get(ctx context.Context, id int) (*BlockStorage, error) {
	return c.Query().Where(blockstorage.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *BlockStorageClient) GetX(ctx context.Context, id int) *BlockStorage {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *BlockStorageClient) Hooks() []Hook {
	return c.hooks.BlockStorage
}

// Interceptors returns the client interceptors.
func (c *BlockStorageClient) Interceptors() []Interceptor {
	return c.inters.BlockStorage
}

func (c *BlockStorageClient) mutate(ctx context.Context, m *BlockStorageMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&BlockStorageCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&BlockStorageUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&BlockStorageUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&BlockStorageDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown BlockStorage mutation op: %q", m.Op())
	}
}

// EbsVolumeClient is a client for the EbsVolume schema.
type EbsVolumeClient struct {
	config
}

// NewEbsVolumeClient returns a client for the EbsVolume from the given config.
func NewEbsVolumeClient(c config) *EbsVolumeClient {
	return &EbsVolumeClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `ebsvolume.Hooks(f(g(h())))`.
func (c *EbsVolumeClient) Use(hooks ...Hook) {
	c.hooks.EbsVolume = append(c.hooks.EbsVolume, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `ebsvolume.Intercept(f(g(h())))`.
func (c *EbsVolumeClient) Intercept(interceptors ...Interceptor) {
	c.inters.EbsVolume = append(c.inters.EbsVolume, interceptors...)
}

// Create returns a builder for creating a EbsVolume entity.
func (c *EbsVolumeClient) Create() *EbsVolumeCreate {
	mutation := newEbsVolumeMutation(c.config, OpCreate)
	return &EbsVolumeCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of EbsVolume entities.
func (c *EbsVolumeClient) CreateBulk(builders ...*EbsVolumeCreate) *EbsVolumeCreateBulk {
	return &EbsVolumeCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for EbsVolume.
func (c *EbsVolumeClient) Update() *EbsVolumeUpdate {
	mutation := newEbsVolumeMutation(c.config, OpUpdate)
	return &EbsVolumeUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *EbsVolumeClient) UpdateOne(ev *EbsVolume) *EbsVolumeUpdateOne {
	mutation := newEbsVolumeMutation(c.config, OpUpdateOne, withEbsVolume(ev))
	return &EbsVolumeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *EbsVolumeClient) UpdateOneID(id int) *EbsVolumeUpdateOne {
	mutation := newEbsVolumeMutation(c.config, OpUpdateOne, withEbsVolumeID(id))
	return &EbsVolumeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for EbsVolume.
func (c *EbsVolumeClient) Delete() *EbsVolumeDelete {
	mutation := newEbsVolumeMutation(c.config, OpDelete)
	return &EbsVolumeDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *EbsVolumeClient) DeleteOne(ev *EbsVolume) *EbsVolumeDeleteOne {
	return c.DeleteOneID(ev.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *EbsVolumeClient) DeleteOneID(id int) *EbsVolumeDeleteOne {
	builder := c.Delete().Where(ebsvolume.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &EbsVolumeDeleteOne{builder}
}

// Query returns a query builder for EbsVolume.
func (c *EbsVolumeClient) Query() *EbsVolumeQuery {
	return &EbsVolumeQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeEbsVolume},
		inters: c.Interceptors(),
	}
}

// Get returns a EbsVolume entity by its id.
func (c *EbsVolumeClient) Get(ctx context.Context, id int) (*EbsVolume, error) {
	return c.Query().Where(ebsvolume.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *EbsVolumeClient) GetX(ctx context.Context, id int) *EbsVolume {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *EbsVolumeClient) Hooks() []Hook {
	return c.hooks.EbsVolume
}

// Interceptors returns the client interceptors.
func (c *EbsVolumeClient) Interceptors() []Interceptor {
	return c.inters.EbsVolume
}

func (c *EbsVolumeClient) mutate(ctx context.Context, m *EbsVolumeMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&EbsVolumeCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&EbsVolumeUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&EbsVolumeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&EbsVolumeDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown EbsVolume mutation op: %q", m.Op())
	}
}

// ObjectStorageClient is a client for the ObjectStorage schema.
type ObjectStorageClient struct {
	config
}

// NewObjectStorageClient returns a client for the ObjectStorage from the given config.
func NewObjectStorageClient(c config) *ObjectStorageClient {
	return &ObjectStorageClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `objectstorage.Hooks(f(g(h())))`.
func (c *ObjectStorageClient) Use(hooks ...Hook) {
	c.hooks.ObjectStorage = append(c.hooks.ObjectStorage, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `objectstorage.Intercept(f(g(h())))`.
func (c *ObjectStorageClient) Intercept(interceptors ...Interceptor) {
	c.inters.ObjectStorage = append(c.inters.ObjectStorage, interceptors...)
}

// Create returns a builder for creating a ObjectStorage entity.
func (c *ObjectStorageClient) Create() *ObjectStorageCreate {
	mutation := newObjectStorageMutation(c.config, OpCreate)
	return &ObjectStorageCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of ObjectStorage entities.
func (c *ObjectStorageClient) CreateBulk(builders ...*ObjectStorageCreate) *ObjectStorageCreateBulk {
	return &ObjectStorageCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for ObjectStorage.
func (c *ObjectStorageClient) Update() *ObjectStorageUpdate {
	mutation := newObjectStorageMutation(c.config, OpUpdate)
	return &ObjectStorageUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ObjectStorageClient) UpdateOne(os *ObjectStorage) *ObjectStorageUpdateOne {
	mutation := newObjectStorageMutation(c.config, OpUpdateOne, withObjectStorage(os))
	return &ObjectStorageUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ObjectStorageClient) UpdateOneID(id string) *ObjectStorageUpdateOne {
	mutation := newObjectStorageMutation(c.config, OpUpdateOne, withObjectStorageID(id))
	return &ObjectStorageUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for ObjectStorage.
func (c *ObjectStorageClient) Delete() *ObjectStorageDelete {
	mutation := newObjectStorageMutation(c.config, OpDelete)
	return &ObjectStorageDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ObjectStorageClient) DeleteOne(os *ObjectStorage) *ObjectStorageDeleteOne {
	return c.DeleteOneID(os.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ObjectStorageClient) DeleteOneID(id string) *ObjectStorageDeleteOne {
	builder := c.Delete().Where(objectstorage.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ObjectStorageDeleteOne{builder}
}

// Query returns a query builder for ObjectStorage.
func (c *ObjectStorageClient) Query() *ObjectStorageQuery {
	return &ObjectStorageQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeObjectStorage},
		inters: c.Interceptors(),
	}
}

// Get returns a ObjectStorage entity by its id.
func (c *ObjectStorageClient) Get(ctx context.Context, id string) (*ObjectStorage, error) {
	return c.Query().Where(objectstorage.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ObjectStorageClient) GetX(ctx context.Context, id string) *ObjectStorage {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *ObjectStorageClient) Hooks() []Hook {
	return c.hooks.ObjectStorage
}

// Interceptors returns the client interceptors.
func (c *ObjectStorageClient) Interceptors() []Interceptor {
	return c.inters.ObjectStorage
}

func (c *ObjectStorageClient) mutate(ctx context.Context, m *ObjectStorageMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ObjectStorageCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ObjectStorageUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ObjectStorageUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ObjectStorageDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown ObjectStorage mutation op: %q", m.Op())
	}
}

// ObjectstorageBucketClient is a client for the ObjectstorageBucket schema.
type ObjectstorageBucketClient struct {
	config
}

// NewObjectstorageBucketClient returns a client for the ObjectstorageBucket from the given config.
func NewObjectstorageBucketClient(c config) *ObjectstorageBucketClient {
	return &ObjectstorageBucketClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `objectstoragebucket.Hooks(f(g(h())))`.
func (c *ObjectstorageBucketClient) Use(hooks ...Hook) {
	c.hooks.ObjectstorageBucket = append(c.hooks.ObjectstorageBucket, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `objectstoragebucket.Intercept(f(g(h())))`.
func (c *ObjectstorageBucketClient) Intercept(interceptors ...Interceptor) {
	c.inters.ObjectstorageBucket = append(c.inters.ObjectstorageBucket, interceptors...)
}

// Create returns a builder for creating a ObjectstorageBucket entity.
func (c *ObjectstorageBucketClient) Create() *ObjectstorageBucketCreate {
	mutation := newObjectstorageBucketMutation(c.config, OpCreate)
	return &ObjectstorageBucketCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of ObjectstorageBucket entities.
func (c *ObjectstorageBucketClient) CreateBulk(builders ...*ObjectstorageBucketCreate) *ObjectstorageBucketCreateBulk {
	return &ObjectstorageBucketCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for ObjectstorageBucket.
func (c *ObjectstorageBucketClient) Update() *ObjectstorageBucketUpdate {
	mutation := newObjectstorageBucketMutation(c.config, OpUpdate)
	return &ObjectstorageBucketUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ObjectstorageBucketClient) UpdateOne(ob *ObjectstorageBucket) *ObjectstorageBucketUpdateOne {
	mutation := newObjectstorageBucketMutation(c.config, OpUpdateOne, withObjectstorageBucket(ob))
	return &ObjectstorageBucketUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ObjectstorageBucketClient) UpdateOneID(id uint64) *ObjectstorageBucketUpdateOne {
	mutation := newObjectstorageBucketMutation(c.config, OpUpdateOne, withObjectstorageBucketID(id))
	return &ObjectstorageBucketUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for ObjectstorageBucket.
func (c *ObjectstorageBucketClient) Delete() *ObjectstorageBucketDelete {
	mutation := newObjectstorageBucketMutation(c.config, OpDelete)
	return &ObjectstorageBucketDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ObjectstorageBucketClient) DeleteOne(ob *ObjectstorageBucket) *ObjectstorageBucketDeleteOne {
	return c.DeleteOneID(ob.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ObjectstorageBucketClient) DeleteOneID(id uint64) *ObjectstorageBucketDeleteOne {
	builder := c.Delete().Where(objectstoragebucket.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ObjectstorageBucketDeleteOne{builder}
}

// Query returns a query builder for ObjectstorageBucket.
func (c *ObjectstorageBucketClient) Query() *ObjectstorageBucketQuery {
	return &ObjectstorageBucketQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeObjectstorageBucket},
		inters: c.Interceptors(),
	}
}

// Get returns a ObjectstorageBucket entity by its id.
func (c *ObjectstorageBucketClient) Get(ctx context.Context, id uint64) (*ObjectstorageBucket, error) {
	return c.Query().Where(objectstoragebucket.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ObjectstorageBucketClient) GetX(ctx context.Context, id uint64) *ObjectstorageBucket {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *ObjectstorageBucketClient) Hooks() []Hook {
	return c.hooks.ObjectstorageBucket
}

// Interceptors returns the client interceptors.
func (c *ObjectstorageBucketClient) Interceptors() []Interceptor {
	return c.inters.ObjectstorageBucket
}

func (c *ObjectstorageBucketClient) mutate(ctx context.Context, m *ObjectstorageBucketMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ObjectstorageBucketCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ObjectstorageBucketUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ObjectstorageBucketUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ObjectstorageBucketDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown ObjectstorageBucket mutation op: %q", m.Op())
	}
}

// hooks and interceptors per client, for fast access.
type (
	hooks struct {
		BlockStorage, EbsVolume, ObjectStorage, ObjectstorageBucket []ent.Hook
	}
	inters struct {
		BlockStorage, EbsVolume, ObjectStorage, ObjectstorageBucket []ent.Interceptor
	}
)

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/data/ent/objectstoragebucket.go
```golang
// Code generated by ent, DO NOT EDIT.

package ent

import (
	"fmt"
	"luban-cmdb-api/data/ent/objectstoragebucket"
	"strings"
	"time"

	"entgo.io/ent/dialect/sql"
)

// ObjectstorageBucket is the model entity for the ObjectstorageBucket schema.
type ObjectstorageBucket struct {
	config `json:"-"`
	// ID of the ent.
	ID uint64 `json:"id,omitempty"`
	// CreatedAt holds the value of the "created_at" field.
	CreatedAt time.Time `json:"created_at,omitempty"`
	// UpdatedAt holds the value of the "updated_at" field.
	UpdatedAt time.Time `json:"updated_at,omitempty"`
	// Version holds the value of the "version" field.
	Version string `json:"version,omitempty"`
	// Galaxy holds the value of the "galaxy" field.
	Galaxy string `json:"galaxy,omitempty"`
	// Region holds the value of the "region" field.
	Region string `json:"region,omitempty"`
	// 是否删除
	Deleted bool `json:"deleted,omitempty"`
	// BucketID holds the value of the "bucket_id" field.
	BucketID int `json:"bucket_id,omitempty"`
	// Name holds the value of the "name" field.
	Name string `json:"name,omitempty"`
	// 租户id
	TenantID string `json:"tenant_id,omitempty"`
	// 租户名
	TenantName string `json:"tenant_name,omitempty"`
	// 项目id
	ProjectID string `json:"project_id,omitempty"`
	// 项目名称
	ProjectName string `json:"project_name,omitempty"`
	// 存储类型
	Storageclass string `json:"storageclass,omitempty"`
	// 存储类型名称
	StorageclassName string `json:"storageclass_name,omitempty"`
	// 内网Endpoint
	InnerEndpoint string `json:"inner_endpoint,omitempty"`
	// 外网Endpoint
	OuterEndpoint string `json:"outer_endpoint,omitempty"`
	// 内网域名
	InnerDomain string `json:"inner_domain,omitempty"`
	// 外网域名
	OuterDomain string `json:"outer_domain,omitempty"`
	// 资源池id
	PoolID string `json:"pool_id,omitempty"`
	// 资源池名称
	PoolName string `json:"pool_name,omitempty"`
	// 总存储量
	TotalStorage int `json:"total_storage,omitempty"`
	// 新增使用量
	AddStorage int `json:"add_storage,omitempty"`
	// 删除量
	DeleteStorage int `json:"delete_storage,omitempty"`
	// 总文件数
	TotalObject int `json:"total_object,omitempty"`
	// 新增上传文件数
	AddObject int `json:"add_object,omitempty"`
	// 新增删除文件数
	DeleteObject int `json:"delete_object,omitempty"`
	// 下载量
	DownloadFlow int `json:"download_flow,omitempty"`
	// 上传量
	UploadFlow int `json:"upload_flow,omitempty"`
	// API请求次数
	RequestAmount int `json:"request_amount,omitempty"`
	// 近30天总下载量
	DownloadFlowMonth int `json:"download_flow_month,omitempty"`
	// 近30天总上传量
	UploadFlowMonth int `json:"upload_flow_month,omitempty"`
	// 近30天总API请求次数
	RequestAmountMonth int `json:"request_amount_month,omitempty"`
	// bucket的创建时间
	CreateTime time.Time `json:"create_time,omitempty"`
}

// scanValues returns the types for scanning values from sql.Rows.
func (*ObjectstorageBucket) scanValues(columns []string) ([]any, error) {
	values := make([]any, len(columns))
	for i := range columns {
		switch columns[i] {
		case objectstoragebucket.FieldDeleted:
			values[i] = new(sql.NullBool)
		case objectstoragebucket.FieldID, objectstoragebucket.FieldBucketID, objectstoragebucket.FieldTotalStorage, objectstoragebucket.FieldAddStorage, objectstoragebucket.FieldDeleteStorage, objectstoragebucket.FieldTotalObject, objectstoragebucket.FieldAddObject, objectstoragebucket.FieldDeleteObject, objectstoragebucket.FieldDownloadFlow, objectstoragebucket.FieldUploadFlow, objectstoragebucket.FieldRequestAmount, objectstoragebucket.FieldDownloadFlowMonth, objectstoragebucket.FieldUploadFlowMonth, objectstoragebucket.FieldRequestAmountMonth:
			values[i] = new(sql.NullInt64)
		case objectstoragebucket.FieldVersion, objectstoragebucket.FieldGalaxy, objectstoragebucket.FieldRegion, objectstoragebucket.FieldName, objectstoragebucket.FieldTenantID, objectstoragebucket.FieldTenantName, objectstoragebucket.FieldProjectID, objectstoragebucket.FieldProjectName, objectstoragebucket.FieldStorageclass, objectstoragebucket.FieldStorageclassName, objectstoragebucket.FieldInnerEndpoint, objectstoragebucket.FieldOuterEndpoint, objectstoragebucket.FieldInnerDomain, objectstoragebucket.FieldOuterDomain, objectstoragebucket.FieldPoolID, objectstoragebucket.FieldPoolName:
			values[i] = new(sql.NullString)
		case objectstoragebucket.FieldCreatedAt, objectstoragebucket.FieldUpdatedAt, objectstoragebucket.FieldCreateTime:
			values[i] = new(sql.NullTime)
		default:
			return nil, fmt.Errorf("unexpected column %q for type ObjectstorageBucket", columns[i])
		}
	}
	return values, nil
}

// assignValues assigns the values that were returned from sql.Rows (after scanning)
// to the ObjectstorageBucket fields.
func (ob *ObjectstorageBucket) assignValues(columns []string, values []any) error {
	if m, n := len(values), len(columns); m < n {
		return fmt.Errorf("mismatch number of scan values: %d != %d", m, n)
	}
	for i := range columns {
		switch columns[i] {
		case objectstoragebucket.FieldID:
			value, ok := values[i].(*sql.NullInt64)
			if !ok {
				return fmt.Errorf("unexpected type %T for field id", value)
			}
			ob.ID = uint64(value.Int64)
		case objectstoragebucket.FieldCreatedAt:
			if value, ok := values[i].(*sql.NullTime); !ok {
				return fmt.Errorf("unexpected type %T for field created_at", values[i])
			} else if value.Valid {
				ob.CreatedAt = value.Time
			}
		case objectstoragebucket.FieldUpdatedAt:
			if value, ok := values[i].(*sql.NullTime); !ok {
				return fmt.Errorf("unexpected type %T for field updated_at", values[i])
			} else if value.Valid {
				ob.UpdatedAt = value.Time
			}
		case objectstoragebucket.FieldVersion:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field version", values[i])
			} else if value.Valid {
				ob.Version = value.String
			}
		case objectstoragebucket.FieldGalaxy:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field galaxy", values[i])
			} else if value.Valid {
				ob.Galaxy = value.String
			}
		case objectstoragebucket.FieldRegion:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field region", values[i])
			} else if value.Valid {
				ob.Region = value.String
			}
		case objectstoragebucket.FieldDeleted:
			if value, ok := values[i].(*sql.NullBool); !ok {
				return fmt.Errorf("unexpected type %T for field deleted", values[i])
			} else if value.Valid {
				ob.Deleted = value.Bool
			}
		case objectstoragebucket.FieldBucketID:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field bucket_id", values[i])
			} else if value.Valid {
				ob.BucketID = int(value.Int64)
			}
		case objectstoragebucket.FieldName:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field name", values[i])
			} else if value.Valid {
				ob.Name = value.String
			}
		case objectstoragebucket.FieldTenantID:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field tenant_id", values[i])
			} else if value.Valid {
				ob.TenantID = value.String
			}
		case objectstoragebucket.FieldTenantName:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field tenant_name", values[i])
			} else if value.Valid {
				ob.TenantName = value.String
			}
		case objectstoragebucket.FieldProjectID:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field project_id", values[i])
			} else if value.Valid {
				ob.ProjectID = value.String
			}
		case objectstoragebucket.FieldProjectName:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field project_name", values[i])
			} else if value.Valid {
				ob.ProjectName = value.String
			}
		case objectstoragebucket.FieldStorageclass:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field storageclass", values[i])
			} else if value.Valid {
				ob.Storageclass = value.String
			}
		case objectstoragebucket.FieldStorageclassName:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field storageclass_name", values[i])
			} else if value.Valid {
				ob.StorageclassName = value.String
			}
		case objectstoragebucket.FieldInnerEndpoint:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field inner_endpoint", values[i])
			} else if value.Valid {
				ob.InnerEndpoint = value.String
			}
		case objectstoragebucket.FieldOuterEndpoint:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field outer_endpoint", values[i])
			} else if value.Valid {
				ob.OuterEndpoint = value.String
			}
		case objectstoragebucket.FieldInnerDomain:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field inner_domain", values[i])
			} else if value.Valid {
				ob.InnerDomain = value.String
			}
		case objectstoragebucket.FieldOuterDomain:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field outer_domain", values[i])
			} else if value.Valid {
				ob.OuterDomain = value.String
			}
		case objectstoragebucket.FieldPoolID:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field pool_id", values[i])
			} else if value.Valid {
				ob.PoolID = value.String
			}
		case objectstoragebucket.FieldPoolName:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field pool_name", values[i])
			} else if value.Valid {
				ob.PoolName = value.String
			}
		case objectstoragebucket.FieldTotalStorage:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field total_storage", values[i])
			} else if value.Valid {
				ob.TotalStorage = int(value.Int64)
			}
		case objectstoragebucket.FieldAddStorage:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field add_storage", values[i])
			} else if value.Valid {
				ob.AddStorage = int(value.Int64)
			}
		case objectstoragebucket.FieldDeleteStorage:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field delete_storage", values[i])
			} else if value.Valid {
				ob.DeleteStorage = int(value.Int64)
			}
		case objectstoragebucket.FieldTotalObject:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field total_object", values[i])
			} else if value.Valid {
				ob.TotalObject = int(value.Int64)
			}
		case objectstoragebucket.FieldAddObject:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field add_object", values[i])
			} else if value.Valid {
				ob.AddObject = int(value.Int64)
			}
		case objectstoragebucket.FieldDeleteObject:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field delete_object", values[i])
			} else if value.Valid {
				ob.DeleteObject = int(value.Int64)
			}
		case objectstoragebucket.FieldDownloadFlow:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field download_flow", values[i])
			} else if value.Valid {
				ob.DownloadFlow = int(value.Int64)
			}
		case objectstoragebucket.FieldUploadFlow:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field upload_flow", values[i])
			} else if value.Valid {
				ob.UploadFlow = int(value.Int64)
			}
		case objectstoragebucket.FieldRequestAmount:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field request_amount", values[i])
			} else if value.Valid {
				ob.RequestAmount = int(value.Int64)
			}
		case objectstoragebucket.FieldDownloadFlowMonth:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field download_flow_month", values[i])
			} else if value.Valid {
				ob.DownloadFlowMonth = int(value.Int64)
			}
		case objectstoragebucket.FieldUploadFlowMonth:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field upload_flow_month", values[i])
			} else if value.Valid {
				ob.UploadFlowMonth = int(value.Int64)
			}
		case objectstoragebucket.FieldRequestAmountMonth:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field request_amount_month", values[i])
			} else if value.Valid {
				ob.RequestAmountMonth = int(value.Int64)
			}
		case objectstoragebucket.FieldCreateTime:
			if value, ok := values[i].(*sql.NullTime); !ok {
				return fmt.Errorf("unexpected type %T for field create_time", values[i])
			} else if value.Valid {
				ob.CreateTime = value.Time
			}
		}
	}
	return nil
}

// Update returns a builder for updating this ObjectstorageBucket.
// Note that you need to call ObjectstorageBucket.Unwrap() before calling this method if this ObjectstorageBucket
// was returned from a transaction, and the transaction was committed or rolled back.
func (ob *ObjectstorageBucket) Update() *ObjectstorageBucketUpdateOne {
	return NewObjectstorageBucketClient(ob.config).UpdateOne(ob)
}

// Unwrap unwraps the ObjectstorageBucket entity that was returned from a transaction after it was closed,
// so that all future queries will be executed through the driver which created the transaction.
func (ob *ObjectstorageBucket) Unwrap() *ObjectstorageBucket {
	_tx, ok := ob.config.driver.(*txDriver)
	if !ok {
		panic("ent: ObjectstorageBucket is not a transactional entity")
	}
	ob.config.driver = _tx.drv
	return ob
}

// String implements the fmt.Stringer.
func (ob *ObjectstorageBucket) String() string {
	var builder strings.Builder
	builder.WriteString("ObjectstorageBucket(")
	builder.WriteString(fmt.Sprintf("id=%v, ", ob.ID))
	builder.WriteString("created_at=")
	builder.WriteString(ob.CreatedAt.Format(time.ANSIC))
	builder.WriteString(", ")
	builder.WriteString("updated_at=")
	builder.WriteString(ob.UpdatedAt.Format(time.ANSIC))
	builder.WriteString(", ")
	builder.WriteString("version=")
	builder.WriteString(ob.Version)
	builder.WriteString(", ")
	builder.WriteString("galaxy=")
	builder.WriteString(ob.Galaxy)
	builder.WriteString(", ")
	builder.WriteString("region=")
	builder.WriteString(ob.Region)
	builder.WriteString(", ")
	builder.WriteString("deleted=")
	builder.WriteString(fmt.Sprintf("%v", ob.Deleted))
	builder.WriteString(", ")
	builder.WriteString("bucket_id=")
	builder.WriteString(fmt.Sprintf("%v", ob.BucketID))
	builder.WriteString(", ")
	builder.WriteString("name=")
	builder.WriteString(ob.Name)
	builder.WriteString(", ")
	builder.WriteString("tenant_id=")
	builder.WriteString(ob.TenantID)
	builder.WriteString(", ")
	builder.WriteString("tenant_name=")
	builder.WriteString(ob.TenantName)
	builder.WriteString(", ")
	builder.WriteString("project_id=")
	builder.WriteString(ob.ProjectID)
	builder.WriteString(", ")
	builder.WriteString("project_name=")
	builder.WriteString(ob.ProjectName)
	builder.WriteString(", ")
	builder.WriteString("storageclass=")
	builder.WriteString(ob.Storageclass)
	builder.WriteString(", ")
	builder.WriteString("storageclass_name=")
	builder.WriteString(ob.StorageclassName)
	builder.WriteString(", ")
	builder.WriteString("inner_endpoint=")
	builder.WriteString(ob.InnerEndpoint)
	builder.WriteString(", ")
	builder.WriteString("outer_endpoint=")
	builder.WriteString(ob.OuterEndpoint)
	builder.WriteString(", ")
	builder.WriteString("inner_domain=")
	builder.WriteString(ob.InnerDomain)
	builder.WriteString(", ")
	builder.WriteString("outer_domain=")
	builder.WriteString(ob.OuterDomain)
	builder.WriteString(", ")
	builder.WriteString("pool_id=")
	builder.WriteString(ob.PoolID)
	builder.WriteString(", ")
	builder.WriteString("pool_name=")
	builder.WriteString(ob.PoolName)
	builder.WriteString(", ")
	builder.WriteString("total_storage=")
	builder.WriteString(fmt.Sprintf("%v", ob.TotalStorage))
	builder.WriteString(", ")
	builder.WriteString("add_storage=")
	builder.WriteString(fmt.Sprintf("%v", ob.AddStorage))
	builder.WriteString(", ")
	builder.WriteString("delete_storage=")
	builder.WriteString(fmt.Sprintf("%v", ob.DeleteStorage))
	builder.WriteString(", ")
	builder.WriteString("total_object=")
	builder.WriteString(fmt.Sprintf("%v", ob.TotalObject))
	builder.WriteString(", ")
	builder.WriteString("add_object=")
	builder.WriteString(fmt.Sprintf("%v", ob.AddObject))
	builder.WriteString(", ")
	builder.WriteString("delete_object=")
	builder.WriteString(fmt.Sprintf("%v", ob.DeleteObject))
	builder.WriteString(", ")
	builder.WriteString("download_flow=")
	builder.WriteString(fmt.Sprintf("%v", ob.DownloadFlow))
	builder.WriteString(", ")
	builder.WriteString("upload_flow=")
	builder.WriteString(fmt.Sprintf("%v", ob.UploadFlow))
	builder.WriteString(", ")
	builder.WriteString("request_amount=")
	builder.WriteString(fmt.Sprintf("%v", ob.RequestAmount))
	builder.WriteString(", ")
	builder.WriteString("download_flow_month=")
	builder.WriteString(fmt.Sprintf("%v", ob.DownloadFlowMonth))
	builder.WriteString(", ")
	builder.WriteString("upload_flow_month=")
	builder.WriteString(fmt.Sprintf("%v", ob.UploadFlowMonth))
	builder.WriteString(", ")
	builder.WriteString("request_amount_month=")
	builder.WriteString(fmt.Sprintf("%v", ob.RequestAmountMonth))
	builder.WriteString(", ")
	builder.WriteString("create_time=")
	builder.WriteString(ob.CreateTime.Format(time.ANSIC))
	builder.WriteByte(')')
	return builder.String()
}

// ObjectstorageBuckets is a parsable slice of ObjectstorageBucket.
type ObjectstorageBuckets []*ObjectstorageBucket

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/data/ent/mutation.go
```golang
// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"luban-cmdb-api/data/ent/blockstorage"
	"luban-cmdb-api/data/ent/ebsvolume"
	"luban-cmdb-api/data/ent/objectstorage"
	"luban-cmdb-api/data/ent/objectstoragebucket"
	"luban-cmdb-api/data/ent/predicate"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeBlockStorage        = "BlockStorage"
	TypeEbsVolume           = "EbsVolume"
	TypeObjectStorage       = "ObjectStorage"
	TypeObjectstorageBucket = "ObjectstorageBucket"
)

// BlockStorageMutation represents an operation that mutates the BlockStorage nodes in the graph.
type BlockStorageMutation struct {
	config
	op                 Op
	typ                string
	id                 *int
	name               *string
	instance_id        *string
	region             *string
	region_code        *string
	az                 *string
	az_code            *string
	resource_pool      *string
	resource_pool_type *string
	use_status         *string
	tenant_id          *string
	tenant_name        *string
	vm                 *string
	vm_id              *string
	create_time        *int
	addcreate_time     *int
	size               *int32
	addsize            *int32
	mount_point        *string
	last_update_time   *time.Time
	clearedFields      map[string]struct{}
	done               bool
	oldValue           func(context.Context) (*BlockStorage, error)
	predicates         []predicate.BlockStorage
}

var _ ent.Mutation = (*BlockStorageMutation)(nil)

// blockstorageOption allows management of the mutation configuration using functional options.
type blockstorageOption func(*BlockStorageMutation)

// newBlockStorageMutation creates new mutation for the BlockStorage entity.
func newBlockStorageMutation(c config, op Op, opts ...blockstorageOption) *BlockStorageMutation {
	m := &BlockStorageMutation{
		config:        c,
		op:            op,
		typ:           TypeBlockStorage,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBlockStorageID sets the ID field of the mutation.
func withBlockStorageID(id int) blockstorageOption {
	return func(m *BlockStorageMutation) {
		var (
			err   error
			once  sync.Once
			value *BlockStorage
		)
		m.oldValue = func(ctx context.Context) (*BlockStorage, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().BlockStorage.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBlockStorage sets the old BlockStorage of the mutation.
func withBlockStorage(node *BlockStorage) blockstorageOption {
	return func(m *BlockStorageMutation) {
		m.oldValue = func(context.Context) (*BlockStorage, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BlockStorageMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BlockStorageMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of BlockStorage entities.
func (m *BlockStorageMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *BlockStorageMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *BlockStorageMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().BlockStorage.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *BlockStorageMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *BlockStorageMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the BlockStorage entity.
// If the BlockStorage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlockStorageMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *BlockStorageMutation) ResetName() {
	m.name = nil
}

// SetInstanceID sets the "instance_id" field.
func (m *BlockStorageMutation) SetInstanceID(s string) {
	m.instance_id = &s
}

// InstanceID returns the value of the "instance_id" field in the mutation.
func (m *BlockStorageMutation) InstanceID() (r string, exists bool) {
	v := m.instance_id
	if v == nil {
		return
	}
	return *v, true
}

// OldInstanceID returns the old "instance_id" field's value of the BlockStorage entity.
// If the BlockStorage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlockStorageMutation) OldInstanceID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInstanceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInstanceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInstanceID: %w", err)
	}
	return oldValue.InstanceID, nil
}

// ResetInstanceID resets all changes to the "instance_id" field.
func (m *BlockStorageMutation) ResetInstanceID() {
	m.instance_id = nil
}

// SetRegion sets the "region" field.
func (m *BlockStorageMutation) SetRegion(s string) {
	m.region = &s
}

// Region returns the value of the "region" field in the mutation.
func (m *BlockStorageMutation) Region() (r string, exists bool) {
	v := m.region
	if v == nil {
		return
	}
	return *v, true
}

// OldRegion returns the old "region" field's value of the BlockStorage entity.
// If the BlockStorage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlockStorageMutation) OldRegion(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRegion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRegion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRegion: %w", err)
	}
	return oldValue.Region, nil
}

// ResetRegion resets all changes to the "region" field.
func (m *BlockStorageMutation) ResetRegion() {
	m.region = nil
}

// SetRegionCode sets the "region_code" field.
func (m *BlockStorageMutation) SetRegionCode(s string) {
	m.region_code = &s
}

// RegionCode returns the value of the "region_code" field in the mutation.
func (m *BlockStorageMutation) RegionCode() (r string, exists bool) {
	v := m.region_code
	if v == nil {
		return
	}
	return *v, true
}

// OldRegionCode returns the old "region_code" field's value of the BlockStorage entity.
// If the BlockStorage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlockStorageMutation) OldRegionCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRegionCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRegionCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRegionCode: %w", err)
	}
	return oldValue.RegionCode, nil
}

// ResetRegionCode resets all changes to the "region_code" field.
func (m *BlockStorageMutation) ResetRegionCode() {
	m.region_code = nil
}

// SetAz sets the "az" field.
func (m *BlockStorageMutation) SetAz(s string) {
	m.az = &s
}

// Az returns the value of the "az" field in the mutation.
func (m *BlockStorageMutation) Az() (r string, exists bool) {
	v := m.az
	if v == nil {
		return
	}
	return *v, true
}

// OldAz returns the old "az" field's value of the BlockStorage entity.
// If the BlockStorage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlockStorageMutation) OldAz(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAz is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAz requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAz: %w", err)
	}
	return oldValue.Az, nil
}

// ResetAz resets all changes to the "az" field.
func (m *BlockStorageMutation) ResetAz() {
	m.az = nil
}

// SetAzCode sets the "az_code" field.
func (m *BlockStorageMutation) SetAzCode(s string) {
	m.az_code = &s
}

// AzCode returns the value of the "az_code" field in the mutation.
func (m *BlockStorageMutation) AzCode() (r string, exists bool) {
	v := m.az_code
	if v == nil {
		return
	}
	return *v, true
}

// OldAzCode returns the old "az_code" field's value of the BlockStorage entity.
// If the BlockStorage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlockStorageMutation) OldAzCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAzCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAzCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAzCode: %w", err)
	}
	return oldValue.AzCode, nil
}

// ResetAzCode resets all changes to the "az_code" field.
func (m *BlockStorageMutation) ResetAzCode() {
	m.az_code = nil
}

// SetResourcePool sets the "resource_pool" field.
func (m *BlockStorageMutation) SetResourcePool(s string) {
	m.resource_pool = &s
}

// ResourcePool returns the value of the "resource_pool" field in the mutation.
func (m *BlockStorageMutation) ResourcePool() (r string, exists bool) {
	v := m.resource_pool
	if v == nil {
		return
	}
	return *v, true
}

// OldResourcePool returns the old "resource_pool" field's value of the BlockStorage entity.
// If the BlockStorage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlockStorageMutation) OldResourcePool(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResourcePool is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResourcePool requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResourcePool: %w", err)
	}
	return oldValue.ResourcePool, nil
}

// ResetResourcePool resets all changes to the "resource_pool" field.
func (m *BlockStorageMutation) ResetResourcePool() {
	m.resource_pool = nil
}

// SetResourcePoolType sets the "resource_pool_type" field.
func (m *BlockStorageMutation) SetResourcePoolType(s string) {
	m.resource_pool_type = &s
}

// ResourcePoolType returns the value of the "resource_pool_type" field in the mutation.
func (m *BlockStorageMutation) ResourcePoolType() (r string, exists bool) {
	v := m.resource_pool_type
	if v == nil {
		return
	}
	return *v, true
}

// OldResourcePoolType returns the old "resource_pool_type" field's value of the BlockStorage entity.
// If the BlockStorage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlockStorageMutation) OldResourcePoolType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResourcePoolType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResourcePoolType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResourcePoolType: %w", err)
	}
	return oldValue.ResourcePoolType, nil
}

// ResetResourcePoolType resets all changes to the "resource_pool_type" field.
func (m *BlockStorageMutation) ResetResourcePoolType() {
	m.resource_pool_type = nil
}

// SetUseStatus sets the "use_status" field.
func (m *BlockStorageMutation) SetUseStatus(s string) {
	m.use_status = &s
}

// UseStatus returns the value of the "use_status" field in the mutation.
func (m *BlockStorageMutation) UseStatus() (r string, exists bool) {
	v := m.use_status
	if v == nil {
		return
	}
	return *v, true
}

// OldUseStatus returns the old "use_status" field's value of the BlockStorage entity.
// If the BlockStorage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlockStorageMutation) OldUseStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUseStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUseStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUseStatus: %w", err)
	}
	return oldValue.UseStatus, nil
}

// ResetUseStatus resets all changes to the "use_status" field.
func (m *BlockStorageMutation) ResetUseStatus() {
	m.use_status = nil
}

// SetTenantID sets the "tenant_id" field.
func (m *BlockStorageMutation) SetTenantID(s string) {
	m.tenant_id = &s
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *BlockStorageMutation) TenantID() (r string, exists bool) {
	v := m.tenant_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the BlockStorage entity.
// If the BlockStorage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlockStorageMutation) OldTenantID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *BlockStorageMutation) ResetTenantID() {
	m.tenant_id = nil
}

// SetTenantName sets the "tenant_name" field.
func (m *BlockStorageMutation) SetTenantName(s string) {
	m.tenant_name = &s
}

// TenantName returns the value of the "tenant_name" field in the mutation.
func (m *BlockStorageMutation) TenantName() (r string, exists bool) {
	v := m.tenant_name
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantName returns the old "tenant_name" field's value of the BlockStorage entity.
// If the BlockStorage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlockStorageMutation) OldTenantName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantName: %w", err)
	}
	return oldValue.TenantName, nil
}

// ResetTenantName resets all changes to the "tenant_name" field.
func (m *BlockStorageMutation) ResetTenantName() {
	m.tenant_name = nil
}

// SetVM sets the "vm" field.
func (m *BlockStorageMutation) SetVM(s string) {
	m.vm = &s
}

// VM returns the value of the "vm" field in the mutation.
func (m *BlockStorageMutation) VM() (r string, exists bool) {
	v := m.vm
	if v == nil {
		return
	}
	return *v, true
}

// OldVM returns the old "vm" field's value of the BlockStorage entity.
// If the BlockStorage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlockStorageMutation) OldVM(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVM is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVM requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVM: %w", err)
	}
	return oldValue.VM, nil
}

// ResetVM resets all changes to the "vm" field.
func (m *BlockStorageMutation) ResetVM() {
	m.vm = nil
}

// SetVMID sets the "vm_id" field.
func (m *BlockStorageMutation) SetVMID(s string) {
	m.vm_id = &s
}

// VMID returns the value of the "vm_id" field in the mutation.
func (m *BlockStorageMutation) VMID() (r string, exists bool) {
	v := m.vm_id
	if v == nil {
		return
	}
	return *v, true
}

// OldVMID returns the old "vm_id" field's value of the BlockStorage entity.
// If the BlockStorage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlockStorageMutation) OldVMID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVMID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVMID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVMID: %w", err)
	}
	return oldValue.VMID, nil
}

// ResetVMID resets all changes to the "vm_id" field.
func (m *BlockStorageMutation) ResetVMID() {
	m.vm_id = nil
}

// SetCreateTime sets the "create_time" field.
func (m *BlockStorageMutation) SetCreateTime(i int) {
	m.create_time = &i
	m.addcreate_time = nil
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *BlockStorageMutation) CreateTime() (r int, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the BlockStorage entity.
// If the BlockStorage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlockStorageMutation) OldCreateTime(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// AddCreateTime adds i to the "create_time" field.
func (m *BlockStorageMutation) AddCreateTime(i int) {
	if m.addcreate_time != nil {
		*m.addcreate_time += i
	} else {
		m.addcreate_time = &i
	}
}

// AddedCreateTime returns the value that was added to the "create_time" field in this mutation.
func (m *BlockStorageMutation) AddedCreateTime() (r int, exists bool) {
	v := m.addcreate_time
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *BlockStorageMutation) ResetCreateTime() {
	m.create_time = nil
	m.addcreate_time = nil
}

// SetSize sets the "size" field.
func (m *BlockStorageMutation) SetSize(i int32) {
	m.size = &i
	m.addsize = nil
}

// Size returns the value of the "size" field in the mutation.
func (m *BlockStorageMutation) Size() (r int32, exists bool) {
	v := m.size
	if v == nil {
		return
	}
	return *v, true
}

// OldSize returns the old "size" field's value of the BlockStorage entity.
// If the BlockStorage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlockStorageMutation) OldSize(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSize is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSize requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSize: %w", err)
	}
	return oldValue.Size, nil
}

// AddSize adds i to the "size" field.
func (m *BlockStorageMutation) AddSize(i int32) {
	if m.addsize != nil {
		*m.addsize += i
	} else {
		m.addsize = &i
	}
}

// AddedSize returns the value that was added to the "size" field in this mutation.
func (m *BlockStorageMutation) AddedSize() (r int32, exists bool) {
	v := m.addsize
	if v == nil {
		return
	}
	return *v, true
}

// ResetSize resets all changes to the "size" field.
func (m *BlockStorageMutation) ResetSize() {
	m.size = nil
	m.addsize = nil
}

// SetMountPoint sets the "mount_point" field.
func (m *BlockStorageMutation) SetMountPoint(s string) {
	m.mount_point = &s
}

// MountPoint returns the value of the "mount_point" field in the mutation.
func (m *BlockStorageMutation) MountPoint() (r string, exists bool) {
	v := m.mount_point
	if v == nil {
		return
	}
	return *v, true
}

// OldMountPoint returns the old "mount_point" field's value of the BlockStorage entity.
// If the BlockStorage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlockStorageMutation) OldMountPoint(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMountPoint is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMountPoint requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMountPoint: %w", err)
	}
	return oldValue.MountPoint, nil
}

// ResetMountPoint resets all changes to the "mount_point" field.
func (m *BlockStorageMutation) ResetMountPoint() {
	m.mount_point = nil
}

// SetLastUpdateTime sets the "last_update_time" field.
func (m *BlockStorageMutation) SetLastUpdateTime(t time.Time) {
	m.last_update_time = &t
}

// LastUpdateTime returns the value of the "last_update_time" field in the mutation.
func (m *BlockStorageMutation) LastUpdateTime() (r time.Time, exists bool) {
	v := m.last_update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldLastUpdateTime returns the old "last_update_time" field's value of the BlockStorage entity.
// If the BlockStorage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlockStorageMutation) OldLastUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastUpdateTime: %w", err)
	}
	return oldValue.LastUpdateTime, nil
}

// ResetLastUpdateTime resets all changes to the "last_update_time" field.
func (m *BlockStorageMutation) ResetLastUpdateTime() {
	m.last_update_time = nil
}

// Where appends a list predicates to the BlockStorageMutation builder.
func (m *BlockStorageMutation) Where(ps ...predicate.BlockStorage) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the BlockStorageMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *BlockStorageMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.BlockStorage, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *BlockStorageMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *BlockStorageMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (BlockStorage).
func (m *BlockStorageMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *BlockStorageMutation) Fields() []string {
	fields := make([]string, 0, 17)
	if m.name != nil {
		fields = append(fields, blockstorage.FieldName)
	}
	if m.instance_id != nil {
		fields = append(fields, blockstorage.FieldInstanceID)
	}
	if m.region != nil {
		fields = append(fields, blockstorage.FieldRegion)
	}
	if m.region_code != nil {
		fields = append(fields, blockstorage.FieldRegionCode)
	}
	if m.az != nil {
		fields = append(fields, blockstorage.FieldAz)
	}
	if m.az_code != nil {
		fields = append(fields, blockstorage.FieldAzCode)
	}
	if m.resource_pool != nil {
		fields = append(fields, blockstorage.FieldResourcePool)
	}
	if m.resource_pool_type != nil {
		fields = append(fields, blockstorage.FieldResourcePoolType)
	}
	if m.use_status != nil {
		fields = append(fields, blockstorage.FieldUseStatus)
	}
	if m.tenant_id != nil {
		fields = append(fields, blockstorage.FieldTenantID)
	}
	if m.tenant_name != nil {
		fields = append(fields, blockstorage.FieldTenantName)
	}
	if m.vm != nil {
		fields = append(fields, blockstorage.FieldVM)
	}
	if m.vm_id != nil {
		fields = append(fields, blockstorage.FieldVMID)
	}
	if m.create_time != nil {
		fields = append(fields, blockstorage.FieldCreateTime)
	}
	if m.size != nil {
		fields = append(fields, blockstorage.FieldSize)
	}
	if m.mount_point != nil {
		fields = append(fields, blockstorage.FieldMountPoint)
	}
	if m.last_update_time != nil {
		fields = append(fields, blockstorage.FieldLastUpdateTime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *BlockStorageMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case blockstorage.FieldName:
		return m.Name()
	case blockstorage.FieldInstanceID:
		return m.InstanceID()
	case blockstorage.FieldRegion:
		return m.Region()
	case blockstorage.FieldRegionCode:
		return m.RegionCode()
	case blockstorage.FieldAz:
		return m.Az()
	case blockstorage.FieldAzCode:
		return m.AzCode()
	case blockstorage.FieldResourcePool:
		return m.ResourcePool()
	case blockstorage.FieldResourcePoolType:
		return m.ResourcePoolType()
	case blockstorage.FieldUseStatus:
		return m.UseStatus()
	case blockstorage.FieldTenantID:
		return m.TenantID()
	case blockstorage.FieldTenantName:
		return m.TenantName()
	case blockstorage.FieldVM:
		return m.VM()
	case blockstorage.FieldVMID:
		return m.VMID()
	case blockstorage.FieldCreateTime:
		return m.CreateTime()
	case blockstorage.FieldSize:
		return m.Size()
	case blockstorage.FieldMountPoint:
		return m.MountPoint()
	case blockstorage.FieldLastUpdateTime:
		return m.LastUpdateTime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *BlockStorageMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case blockstorage.FieldName:
		return m.OldName(ctx)
	case blockstorage.FieldInstanceID:
		return m.OldInstanceID(ctx)
	case blockstorage.FieldRegion:
		return m.OldRegion(ctx)
	case blockstorage.FieldRegionCode:
		return m.OldRegionCode(ctx)
	case blockstorage.FieldAz:
		return m.OldAz(ctx)
	case blockstorage.FieldAzCode:
		return m.OldAzCode(ctx)
	case blockstorage.FieldResourcePool:
		return m.OldResourcePool(ctx)
	case blockstorage.FieldResourcePoolType:
		return m.OldResourcePoolType(ctx)
	case blockstorage.FieldUseStatus:
		return m.OldUseStatus(ctx)
	case blockstorage.FieldTenantID:
		return m.OldTenantID(ctx)
	case blockstorage.FieldTenantName:
		return m.OldTenantName(ctx)
	case blockstorage.FieldVM:
		return m.OldVM(ctx)
	case blockstorage.FieldVMID:
		return m.OldVMID(ctx)
	case blockstorage.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case blockstorage.FieldSize:
		return m.OldSize(ctx)
	case blockstorage.FieldMountPoint:
		return m.OldMountPoint(ctx)
	case blockstorage.FieldLastUpdateTime:
		return m.OldLastUpdateTime(ctx)
	}
	return nil, fmt.Errorf("unknown BlockStorage field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BlockStorageMutation) SetField(name string, value ent.Value) error {
	switch name {
	case blockstorage.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case blockstorage.FieldInstanceID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInstanceID(v)
		return nil
	case blockstorage.FieldRegion:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRegion(v)
		return nil
	case blockstorage.FieldRegionCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRegionCode(v)
		return nil
	case blockstorage.FieldAz:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAz(v)
		return nil
	case blockstorage.FieldAzCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAzCode(v)
		return nil
	case blockstorage.FieldResourcePool:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResourcePool(v)
		return nil
	case blockstorage.FieldResourcePoolType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResourcePoolType(v)
		return nil
	case blockstorage.FieldUseStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUseStatus(v)
		return nil
	case blockstorage.FieldTenantID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case blockstorage.FieldTenantName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantName(v)
		return nil
	case blockstorage.FieldVM:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVM(v)
		return nil
	case blockstorage.FieldVMID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVMID(v)
		return nil
	case blockstorage.FieldCreateTime:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case blockstorage.FieldSize:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSize(v)
		return nil
	case blockstorage.FieldMountPoint:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMountPoint(v)
		return nil
	case blockstorage.FieldLastUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastUpdateTime(v)
		return nil
	}
	return fmt.Errorf("unknown BlockStorage field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *BlockStorageMutation) AddedFields() []string {
	var fields []string
	if m.addcreate_time != nil {
		fields = append(fields, blockstorage.FieldCreateTime)
	}
	if m.addsize != nil {
		fields = append(fields, blockstorage.FieldSize)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *BlockStorageMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case blockstorage.FieldCreateTime:
		return m.AddedCreateTime()
	case blockstorage.FieldSize:
		return m.AddedSize()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BlockStorageMutation) AddField(name string, value ent.Value) error {
	switch name {
	case blockstorage.FieldCreateTime:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreateTime(v)
		return nil
	case blockstorage.FieldSize:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSize(v)
		return nil
	}
	return fmt.Errorf("unknown BlockStorage numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *BlockStorageMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *BlockStorageMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *BlockStorageMutation) ClearField(name string) error {
	return fmt.Errorf("unknown BlockStorage nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *BlockStorageMutation) ResetField(name string) error {
	switch name {
	case blockstorage.FieldName:
		m.ResetName()
		return nil
	case blockstorage.FieldInstanceID:
		m.ResetInstanceID()
		return nil
	case blockstorage.FieldRegion:
		m.ResetRegion()
		return nil
	case blockstorage.FieldRegionCode:
		m.ResetRegionCode()
		return nil
	case blockstorage.FieldAz:
		m.ResetAz()
		return nil
	case blockstorage.FieldAzCode:
		m.ResetAzCode()
		return nil
	case blockstorage.FieldResourcePool:
		m.ResetResourcePool()
		return nil
	case blockstorage.FieldResourcePoolType:
		m.ResetResourcePoolType()
		return nil
	case blockstorage.FieldUseStatus:
		m.ResetUseStatus()
		return nil
	case blockstorage.FieldTenantID:
		m.ResetTenantID()
		return nil
	case blockstorage.FieldTenantName:
		m.ResetTenantName()
		return nil
	case blockstorage.FieldVM:
		m.ResetVM()
		return nil
	case blockstorage.FieldVMID:
		m.ResetVMID()
		return nil
	case blockstorage.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case blockstorage.FieldSize:
		m.ResetSize()
		return nil
	case blockstorage.FieldMountPoint:
		m.ResetMountPoint()
		return nil
	case blockstorage.FieldLastUpdateTime:
		m.ResetLastUpdateTime()
		return nil
	}
	return fmt.Errorf("unknown BlockStorage field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *BlockStorageMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *BlockStorageMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *BlockStorageMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *BlockStorageMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *BlockStorageMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *BlockStorageMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *BlockStorageMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown BlockStorage unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *BlockStorageMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown BlockStorage edge %s", name)
}

// EbsVolumeMutation represents an operation that mutates the EbsVolume nodes in the graph.
type EbsVolumeMutation struct {
	config
	op               Op
	typ              string
	id               *int
	galaxy           *string
	region           *string
	az               *string
	created_at       *time.Time
	updated_at       *time.Time
	version          *string
	volume_id        *string
	name             *string
	pool_id          *string
	pool_name        *string
	size             *int32
	addsize          *int32
	status           *string
	status_name      *string
	volume_type      *string
	vm_id            *string
	vm_name          *string
	tenant_id        *string
	tenant_name      *string
	project_id       *string
	project_name     *string
	create_time      *time.Time
	service_end_time *time.Time
	deleted          *bool
	clearedFields    map[string]struct{}
	done             bool
	oldValue         func(context.Context) (*EbsVolume, error)
	predicates       []predicate.EbsVolume
}

var _ ent.Mutation = (*EbsVolumeMutation)(nil)

// ebsvolumeOption allows management of the mutation configuration using functional options.
type ebsvolumeOption func(*EbsVolumeMutation)

// newEbsVolumeMutation creates new mutation for the EbsVolume entity.
func newEbsVolumeMutation(c config, op Op, opts ...ebsvolumeOption) *EbsVolumeMutation {
	m := &EbsVolumeMutation{
		config:        c,
		op:            op,
		typ:           TypeEbsVolume,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withEbsVolumeID sets the ID field of the mutation.
func withEbsVolumeID(id int) ebsvolumeOption {
	return func(m *EbsVolumeMutation) {
		var (
			err   error
			once  sync.Once
			value *EbsVolume
		)
		m.oldValue = func(ctx context.Context) (*EbsVolume, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().EbsVolume.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withEbsVolume sets the old EbsVolume of the mutation.
func withEbsVolume(node *EbsVolume) ebsvolumeOption {
	return func(m *EbsVolumeMutation) {
		m.oldValue = func(context.Context) (*EbsVolume, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m EbsVolumeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m EbsVolumeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of EbsVolume entities.
func (m *EbsVolumeMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *EbsVolumeMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *EbsVolumeMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().EbsVolume.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetGalaxy sets the "galaxy" field.
func (m *EbsVolumeMutation) SetGalaxy(s string) {
	m.galaxy = &s
}

// Galaxy returns the value of the "galaxy" field in the mutation.
func (m *EbsVolumeMutation) Galaxy() (r string, exists bool) {
	v := m.galaxy
	if v == nil {
		return
	}
	return *v, true
}

// OldGalaxy returns the old "galaxy" field's value of the EbsVolume entity.
// If the EbsVolume object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EbsVolumeMutation) OldGalaxy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGalaxy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGalaxy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGalaxy: %w", err)
	}
	return oldValue.Galaxy, nil
}

// ClearGalaxy clears the value of the "galaxy" field.
func (m *EbsVolumeMutation) ClearGalaxy() {
	m.galaxy = nil
	m.clearedFields[ebsvolume.FieldGalaxy] = struct{}{}
}

// GalaxyCleared returns if the "galaxy" field was cleared in this mutation.
func (m *EbsVolumeMutation) GalaxyCleared() bool {
	_, ok := m.clearedFields[ebsvolume.FieldGalaxy]
	return ok
}

// ResetGalaxy resets all changes to the "galaxy" field.
func (m *EbsVolumeMutation) ResetGalaxy() {
	m.galaxy = nil
	delete(m.clearedFields, ebsvolume.FieldGalaxy)
}

// SetRegion sets the "region" field.
func (m *EbsVolumeMutation) SetRegion(s string) {
	m.region = &s
}

// Region returns the value of the "region" field in the mutation.
func (m *EbsVolumeMutation) Region() (r string, exists bool) {
	v := m.region
	if v == nil {
		return
	}
	return *v, true
}

// OldRegion returns the old "region" field's value of the EbsVolume entity.
// If the EbsVolume object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EbsVolumeMutation) OldRegion(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRegion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRegion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRegion: %w", err)
	}
	return oldValue.Region, nil
}

// ResetRegion resets all changes to the "region" field.
func (m *EbsVolumeMutation) ResetRegion() {
	m.region = nil
}

// SetAz sets the "az" field.
func (m *EbsVolumeMutation) SetAz(s string) {
	m.az = &s
}

// Az returns the value of the "az" field in the mutation.
func (m *EbsVolumeMutation) Az() (r string, exists bool) {
	v := m.az
	if v == nil {
		return
	}
	return *v, true
}

// OldAz returns the old "az" field's value of the EbsVolume entity.
// If the EbsVolume object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EbsVolumeMutation) OldAz(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAz is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAz requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAz: %w", err)
	}
	return oldValue.Az, nil
}

// ClearAz clears the value of the "az" field.
func (m *EbsVolumeMutation) ClearAz() {
	m.az = nil
	m.clearedFields[ebsvolume.FieldAz] = struct{}{}
}

// AzCleared returns if the "az" field was cleared in this mutation.
func (m *EbsVolumeMutation) AzCleared() bool {
	_, ok := m.clearedFields[ebsvolume.FieldAz]
	return ok
}

// ResetAz resets all changes to the "az" field.
func (m *EbsVolumeMutation) ResetAz() {
	m.az = nil
	delete(m.clearedFields, ebsvolume.FieldAz)
}

// SetCreatedAt sets the "created_at" field.
func (m *EbsVolumeMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *EbsVolumeMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the EbsVolume entity.
// If the EbsVolume object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EbsVolumeMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *EbsVolumeMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[ebsvolume.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *EbsVolumeMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[ebsvolume.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *EbsVolumeMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, ebsvolume.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *EbsVolumeMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *EbsVolumeMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the EbsVolume entity.
// If the EbsVolume object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EbsVolumeMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *EbsVolumeMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetVersion sets the "version" field.
func (m *EbsVolumeMutation) SetVersion(s string) {
	m.version = &s
}

// Version returns the value of the "version" field in the mutation.
func (m *EbsVolumeMutation) Version() (r string, exists bool) {
	v := m.version
	if v == nil {
		return
	}
	return *v, true
}

// OldVersion returns the old "version" field's value of the EbsVolume entity.
// If the EbsVolume object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EbsVolumeMutation) OldVersion(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVersion: %w", err)
	}
	return oldValue.Version, nil
}

// ClearVersion clears the value of the "version" field.
func (m *EbsVolumeMutation) ClearVersion() {
	m.version = nil
	m.clearedFields[ebsvolume.FieldVersion] = struct{}{}
}

// VersionCleared returns if the "version" field was cleared in this mutation.
func (m *EbsVolumeMutation) VersionCleared() bool {
	_, ok := m.clearedFields[ebsvolume.FieldVersion]
	return ok
}

// ResetVersion resets all changes to the "version" field.
func (m *EbsVolumeMutation) ResetVersion() {
	m.version = nil
	delete(m.clearedFields, ebsvolume.FieldVersion)
}

// SetVolumeID sets the "volume_id" field.
func (m *EbsVolumeMutation) SetVolumeID(s string) {
	m.volume_id = &s
}

// VolumeID returns the value of the "volume_id" field in the mutation.
func (m *EbsVolumeMutation) VolumeID() (r string, exists bool) {
	v := m.volume_id
	if v == nil {
		return
	}
	return *v, true
}

// OldVolumeID returns the old "volume_id" field's value of the EbsVolume entity.
// If the EbsVolume object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EbsVolumeMutation) OldVolumeID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVolumeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVolumeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVolumeID: %w", err)
	}
	return oldValue.VolumeID, nil
}

// ClearVolumeID clears the value of the "volume_id" field.
func (m *EbsVolumeMutation) ClearVolumeID() {
	m.volume_id = nil
	m.clearedFields[ebsvolume.FieldVolumeID] = struct{}{}
}

// VolumeIDCleared returns if the "volume_id" field was cleared in this mutation.
func (m *EbsVolumeMutation) VolumeIDCleared() bool {
	_, ok := m.clearedFields[ebsvolume.FieldVolumeID]
	return ok
}

// ResetVolumeID resets all changes to the "volume_id" field.
func (m *EbsVolumeMutation) ResetVolumeID() {
	m.volume_id = nil
	delete(m.clearedFields, ebsvolume.FieldVolumeID)
}

// SetName sets the "name" field.
func (m *EbsVolumeMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *EbsVolumeMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the EbsVolume entity.
// If the EbsVolume object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EbsVolumeMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *EbsVolumeMutation) ResetName() {
	m.name = nil
}

// SetPoolID sets the "pool_id" field.
func (m *EbsVolumeMutation) SetPoolID(s string) {
	m.pool_id = &s
}

// PoolID returns the value of the "pool_id" field in the mutation.
func (m *EbsVolumeMutation) PoolID() (r string, exists bool) {
	v := m.pool_id
	if v == nil {
		return
	}
	return *v, true
}

// OldPoolID returns the old "pool_id" field's value of the EbsVolume entity.
// If the EbsVolume object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EbsVolumeMutation) OldPoolID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPoolID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPoolID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPoolID: %w", err)
	}
	return oldValue.PoolID, nil
}

// ClearPoolID clears the value of the "pool_id" field.
func (m *EbsVolumeMutation) ClearPoolID() {
	m.pool_id = nil
	m.clearedFields[ebsvolume.FieldPoolID] = struct{}{}
}

// PoolIDCleared returns if the "pool_id" field was cleared in this mutation.
func (m *EbsVolumeMutation) PoolIDCleared() bool {
	_, ok := m.clearedFields[ebsvolume.FieldPoolID]
	return ok
}

// ResetPoolID resets all changes to the "pool_id" field.
func (m *EbsVolumeMutation) ResetPoolID() {
	m.pool_id = nil
	delete(m.clearedFields, ebsvolume.FieldPoolID)
}

// SetPoolName sets the "pool_name" field.
func (m *EbsVolumeMutation) SetPoolName(s string) {
	m.pool_name = &s
}

// PoolName returns the value of the "pool_name" field in the mutation.
func (m *EbsVolumeMutation) PoolName() (r string, exists bool) {
	v := m.pool_name
	if v == nil {
		return
	}
	return *v, true
}

// OldPoolName returns the old "pool_name" field's value of the EbsVolume entity.
// If the EbsVolume object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EbsVolumeMutation) OldPoolName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPoolName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPoolName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPoolName: %w", err)
	}
	return oldValue.PoolName, nil
}

// ClearPoolName clears the value of the "pool_name" field.
func (m *EbsVolumeMutation) ClearPoolName() {
	m.pool_name = nil
	m.clearedFields[ebsvolume.FieldPoolName] = struct{}{}
}

// PoolNameCleared returns if the "pool_name" field was cleared in this mutation.
func (m *EbsVolumeMutation) PoolNameCleared() bool {
	_, ok := m.clearedFields[ebsvolume.FieldPoolName]
	return ok
}

// ResetPoolName resets all changes to the "pool_name" field.
func (m *EbsVolumeMutation) ResetPoolName() {
	m.pool_name = nil
	delete(m.clearedFields, ebsvolume.FieldPoolName)
}

// SetSize sets the "size" field.
func (m *EbsVolumeMutation) SetSize(i int32) {
	m.size = &i
	m.addsize = nil
}

// Size returns the value of the "size" field in the mutation.
func (m *EbsVolumeMutation) Size() (r int32, exists bool) {
	v := m.size
	if v == nil {
		return
	}
	return *v, true
}

// OldSize returns the old "size" field's value of the EbsVolume entity.
// If the EbsVolume object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EbsVolumeMutation) OldSize(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSize is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSize requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSize: %w", err)
	}
	return oldValue.Size, nil
}

// AddSize adds i to the "size" field.
func (m *EbsVolumeMutation) AddSize(i int32) {
	if m.addsize != nil {
		*m.addsize += i
	} else {
		m.addsize = &i
	}
}

// AddedSize returns the value that was added to the "size" field in this mutation.
func (m *EbsVolumeMutation) AddedSize() (r int32, exists bool) {
	v := m.addsize
	if v == nil {
		return
	}
	return *v, true
}

// ClearSize clears the value of the "size" field.
func (m *EbsVolumeMutation) ClearSize() {
	m.size = nil
	m.addsize = nil
	m.clearedFields[ebsvolume.FieldSize] = struct{}{}
}

// SizeCleared returns if the "size" field was cleared in this mutation.
func (m *EbsVolumeMutation) SizeCleared() bool {
	_, ok := m.clearedFields[ebsvolume.FieldSize]
	return ok
}

// ResetSize resets all changes to the "size" field.
func (m *EbsVolumeMutation) ResetSize() {
	m.size = nil
	m.addsize = nil
	delete(m.clearedFields, ebsvolume.FieldSize)
}

// SetStatus sets the "status" field.
func (m *EbsVolumeMutation) SetStatus(s string) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *EbsVolumeMutation) Status() (r string, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the EbsVolume entity.
// If the EbsVolume object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EbsVolumeMutation) OldStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ClearStatus clears the value of the "status" field.
func (m *EbsVolumeMutation) ClearStatus() {
	m.status = nil
	m.clearedFields[ebsvolume.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *EbsVolumeMutation) StatusCleared() bool {
	_, ok := m.clearedFields[ebsvolume.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *EbsVolumeMutation) ResetStatus() {
	m.status = nil
	delete(m.clearedFields, ebsvolume.FieldStatus)
}

// SetStatusName sets the "status_name" field.
func (m *EbsVolumeMutation) SetStatusName(s string) {
	m.status_name = &s
}

// StatusName returns the value of the "status_name" field in the mutation.
func (m *EbsVolumeMutation) StatusName() (r string, exists bool) {
	v := m.status_name
	if v == nil {
		return
	}
	return *v, true
}

// OldStatusName returns the old "status_name" field's value of the EbsVolume entity.
// If the EbsVolume object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EbsVolumeMutation) OldStatusName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatusName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatusName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatusName: %w", err)
	}
	return oldValue.StatusName, nil
}

// ClearStatusName clears the value of the "status_name" field.
func (m *EbsVolumeMutation) ClearStatusName() {
	m.status_name = nil
	m.clearedFields[ebsvolume.FieldStatusName] = struct{}{}
}

// StatusNameCleared returns if the "status_name" field was cleared in this mutation.
func (m *EbsVolumeMutation) StatusNameCleared() bool {
	_, ok := m.clearedFields[ebsvolume.FieldStatusName]
	return ok
}

// ResetStatusName resets all changes to the "status_name" field.
func (m *EbsVolumeMutation) ResetStatusName() {
	m.status_name = nil
	delete(m.clearedFields, ebsvolume.FieldStatusName)
}

// SetVolumeType sets the "volume_type" field.
func (m *EbsVolumeMutation) SetVolumeType(s string) {
	m.volume_type = &s
}

// VolumeType returns the value of the "volume_type" field in the mutation.
func (m *EbsVolumeMutation) VolumeType() (r string, exists bool) {
	v := m.volume_type
	if v == nil {
		return
	}
	return *v, true
}

// OldVolumeType returns the old "volume_type" field's value of the EbsVolume entity.
// If the EbsVolume object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EbsVolumeMutation) OldVolumeType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVolumeType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVolumeType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVolumeType: %w", err)
	}
	return oldValue.VolumeType, nil
}

// ClearVolumeType clears the value of the "volume_type" field.
func (m *EbsVolumeMutation) ClearVolumeType() {
	m.volume_type = nil
	m.clearedFields[ebsvolume.FieldVolumeType] = struct{}{}
}

// VolumeTypeCleared returns if the "volume_type" field was cleared in this mutation.
func (m *EbsVolumeMutation) VolumeTypeCleared() bool {
	_, ok := m.clearedFields[ebsvolume.FieldVolumeType]
	return ok
}

// ResetVolumeType resets all changes to the "volume_type" field.
func (m *EbsVolumeMutation) ResetVolumeType() {
	m.volume_type = nil
	delete(m.clearedFields, ebsvolume.FieldVolumeType)
}

// SetVMID sets the "vm_id" field.
func (m *EbsVolumeMutation) SetVMID(s string) {
	m.vm_id = &s
}

// VMID returns the value of the "vm_id" field in the mutation.
func (m *EbsVolumeMutation) VMID() (r string, exists bool) {
	v := m.vm_id
	if v == nil {
		return
	}
	return *v, true
}

// OldVMID returns the old "vm_id" field's value of the EbsVolume entity.
// If the EbsVolume object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EbsVolumeMutation) OldVMID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVMID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVMID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVMID: %w", err)
	}
	return oldValue.VMID, nil
}

// ResetVMID resets all changes to the "vm_id" field.
func (m *EbsVolumeMutation) ResetVMID() {
	m.vm_id = nil
}

// SetVMName sets the "vm_name" field.
func (m *EbsVolumeMutation) SetVMName(s string) {
	m.vm_name = &s
}

// VMName returns the value of the "vm_name" field in the mutation.
func (m *EbsVolumeMutation) VMName() (r string, exists bool) {
	v := m.vm_name
	if v == nil {
		return
	}
	return *v, true
}

// OldVMName returns the old "vm_name" field's value of the EbsVolume entity.
// If the EbsVolume object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EbsVolumeMutation) OldVMName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVMName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVMName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVMName: %w", err)
	}
	return oldValue.VMName, nil
}

// ResetVMName resets all changes to the "vm_name" field.
func (m *EbsVolumeMutation) ResetVMName() {
	m.vm_name = nil
}

// SetTenantID sets the "tenant_id" field.
func (m *EbsVolumeMutation) SetTenantID(s string) {
	m.tenant_id = &s
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *EbsVolumeMutation) TenantID() (r string, exists bool) {
	v := m.tenant_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the EbsVolume entity.
// If the EbsVolume object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EbsVolumeMutation) OldTenantID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// ClearTenantID clears the value of the "tenant_id" field.
func (m *EbsVolumeMutation) ClearTenantID() {
	m.tenant_id = nil
	m.clearedFields[ebsvolume.FieldTenantID] = struct{}{}
}

// TenantIDCleared returns if the "tenant_id" field was cleared in this mutation.
func (m *EbsVolumeMutation) TenantIDCleared() bool {
	_, ok := m.clearedFields[ebsvolume.FieldTenantID]
	return ok
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *EbsVolumeMutation) ResetTenantID() {
	m.tenant_id = nil
	delete(m.clearedFields, ebsvolume.FieldTenantID)
}

// SetTenantName sets the "tenant_name" field.
func (m *EbsVolumeMutation) SetTenantName(s string) {
	m.tenant_name = &s
}

// TenantName returns the value of the "tenant_name" field in the mutation.
func (m *EbsVolumeMutation) TenantName() (r string, exists bool) {
	v := m.tenant_name
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantName returns the old "tenant_name" field's value of the EbsVolume entity.
// If the EbsVolume object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EbsVolumeMutation) OldTenantName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantName: %w", err)
	}
	return oldValue.TenantName, nil
}

// ClearTenantName clears the value of the "tenant_name" field.
func (m *EbsVolumeMutation) ClearTenantName() {
	m.tenant_name = nil
	m.clearedFields[ebsvolume.FieldTenantName] = struct{}{}
}

// TenantNameCleared returns if the "tenant_name" field was cleared in this mutation.
func (m *EbsVolumeMutation) TenantNameCleared() bool {
	_, ok := m.clearedFields[ebsvolume.FieldTenantName]
	return ok
}

// ResetTenantName resets all changes to the "tenant_name" field.
func (m *EbsVolumeMutation) ResetTenantName() {
	m.tenant_name = nil
	delete(m.clearedFields, ebsvolume.FieldTenantName)
}

// SetProjectID sets the "project_id" field.
func (m *EbsVolumeMutation) SetProjectID(s string) {
	m.project_id = &s
}

// ProjectID returns the value of the "project_id" field in the mutation.
func (m *EbsVolumeMutation) ProjectID() (r string, exists bool) {
	v := m.project_id
	if v == nil {
		return
	}
	return *v, true
}

// OldProjectID returns the old "project_id" field's value of the EbsVolume entity.
// If the EbsVolume object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EbsVolumeMutation) OldProjectID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProjectID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProjectID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProjectID: %w", err)
	}
	return oldValue.ProjectID, nil
}

// ResetProjectID resets all changes to the "project_id" field.
func (m *EbsVolumeMutation) ResetProjectID() {
	m.project_id = nil
}

// SetProjectName sets the "project_name" field.
func (m *EbsVolumeMutation) SetProjectName(s string) {
	m.project_name = &s
}

// ProjectName returns the value of the "project_name" field in the mutation.
func (m *EbsVolumeMutation) ProjectName() (r string, exists bool) {
	v := m.project_name
	if v == nil {
		return
	}
	return *v, true
}

// OldProjectName returns the old "project_name" field's value of the EbsVolume entity.
// If the EbsVolume object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EbsVolumeMutation) OldProjectName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProjectName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProjectName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProjectName: %w", err)
	}
	return oldValue.ProjectName, nil
}

// ResetProjectName resets all changes to the "project_name" field.
func (m *EbsVolumeMutation) ResetProjectName() {
	m.project_name = nil
}

// SetCreateTime sets the "create_time" field.
func (m *EbsVolumeMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *EbsVolumeMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the EbsVolume entity.
// If the EbsVolume object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EbsVolumeMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ClearCreateTime clears the value of the "create_time" field.
func (m *EbsVolumeMutation) ClearCreateTime() {
	m.create_time = nil
	m.clearedFields[ebsvolume.FieldCreateTime] = struct{}{}
}

// CreateTimeCleared returns if the "create_time" field was cleared in this mutation.
func (m *EbsVolumeMutation) CreateTimeCleared() bool {
	_, ok := m.clearedFields[ebsvolume.FieldCreateTime]
	return ok
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *EbsVolumeMutation) ResetCreateTime() {
	m.create_time = nil
	delete(m.clearedFields, ebsvolume.FieldCreateTime)
}

// SetServiceEndTime sets the "service_end_time" field.
func (m *EbsVolumeMutation) SetServiceEndTime(t time.Time) {
	m.service_end_time = &t
}

// ServiceEndTime returns the value of the "service_end_time" field in the mutation.
func (m *EbsVolumeMutation) ServiceEndTime() (r time.Time, exists bool) {
	v := m.service_end_time
	if v == nil {
		return
	}
	return *v, true
}

// OldServiceEndTime returns the old "service_end_time" field's value of the EbsVolume entity.
// If the EbsVolume object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EbsVolumeMutation) OldServiceEndTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldServiceEndTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldServiceEndTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldServiceEndTime: %w", err)
	}
	return oldValue.ServiceEndTime, nil
}

// ClearServiceEndTime clears the value of the "service_end_time" field.
func (m *EbsVolumeMutation) ClearServiceEndTime() {
	m.service_end_time = nil
	m.clearedFields[ebsvolume.FieldServiceEndTime] = struct{}{}
}

// ServiceEndTimeCleared returns if the "service_end_time" field was cleared in this mutation.
func (m *EbsVolumeMutation) ServiceEndTimeCleared() bool {
	_, ok := m.clearedFields[ebsvolume.FieldServiceEndTime]
	return ok
}

// ResetServiceEndTime resets all changes to the "service_end_time" field.
func (m *EbsVolumeMutation) ResetServiceEndTime() {
	m.service_end_time = nil
	delete(m.clearedFields, ebsvolume.FieldServiceEndTime)
}

// SetDeleted sets the "deleted" field.
func (m *EbsVolumeMutation) SetDeleted(b bool) {
	m.deleted = &b
}

// Deleted returns the value of the "deleted" field in the mutation.
func (m *EbsVolumeMutation) Deleted() (r bool, exists bool) {
	v := m.deleted
	if v == nil {
		return
	}
	return *v, true
}

// OldDeleted returns the old "deleted" field's value of the EbsVolume entity.
// If the EbsVolume object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EbsVolumeMutation) OldDeleted(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeleted is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeleted requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeleted: %w", err)
	}
	return oldValue.Deleted, nil
}

// ClearDeleted clears the value of the "deleted" field.
func (m *EbsVolumeMutation) ClearDeleted() {
	m.deleted = nil
	m.clearedFields[ebsvolume.FieldDeleted] = struct{}{}
}

// DeletedCleared returns if the "deleted" field was cleared in this mutation.
func (m *EbsVolumeMutation) DeletedCleared() bool {
	_, ok := m.clearedFields[ebsvolume.FieldDeleted]
	return ok
}

// ResetDeleted resets all changes to the "deleted" field.
func (m *EbsVolumeMutation) ResetDeleted() {
	m.deleted = nil
	delete(m.clearedFields, ebsvolume.FieldDeleted)
}

// Where appends a list predicates to the EbsVolumeMutation builder.
func (m *EbsVolumeMutation) Where(ps ...predicate.EbsVolume) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the EbsVolumeMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *EbsVolumeMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.EbsVolume, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *EbsVolumeMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *EbsVolumeMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (EbsVolume).
func (m *EbsVolumeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *EbsVolumeMutation) Fields() []string {
	fields := make([]string, 0, 23)
	if m.galaxy != nil {
		fields = append(fields, ebsvolume.FieldGalaxy)
	}
	if m.region != nil {
		fields = append(fields, ebsvolume.FieldRegion)
	}
	if m.az != nil {
		fields = append(fields, ebsvolume.FieldAz)
	}
	if m.created_at != nil {
		fields = append(fields, ebsvolume.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, ebsvolume.FieldUpdatedAt)
	}
	if m.version != nil {
		fields = append(fields, ebsvolume.FieldVersion)
	}
	if m.volume_id != nil {
		fields = append(fields, ebsvolume.FieldVolumeID)
	}
	if m.name != nil {
		fields = append(fields, ebsvolume.FieldName)
	}
	if m.pool_id != nil {
		fields = append(fields, ebsvolume.FieldPoolID)
	}
	if m.pool_name != nil {
		fields = append(fields, ebsvolume.FieldPoolName)
	}
	if m.size != nil {
		fields = append(fields, ebsvolume.FieldSize)
	}
	if m.status != nil {
		fields = append(fields, ebsvolume.FieldStatus)
	}
	if m.status_name != nil {
		fields = append(fields, ebsvolume.FieldStatusName)
	}
	if m.volume_type != nil {
		fields = append(fields, ebsvolume.FieldVolumeType)
	}
	if m.vm_id != nil {
		fields = append(fields, ebsvolume.FieldVMID)
	}
	if m.vm_name != nil {
		fields = append(fields, ebsvolume.FieldVMName)
	}
	if m.tenant_id != nil {
		fields = append(fields, ebsvolume.FieldTenantID)
	}
	if m.tenant_name != nil {
		fields = append(fields, ebsvolume.FieldTenantName)
	}
	if m.project_id != nil {
		fields = append(fields, ebsvolume.FieldProjectID)
	}
	if m.project_name != nil {
		fields = append(fields, ebsvolume.FieldProjectName)
	}
	if m.create_time != nil {
		fields = append(fields, ebsvolume.FieldCreateTime)
	}
	if m.service_end_time != nil {
		fields = append(fields, ebsvolume.FieldServiceEndTime)
	}
	if m.deleted != nil {
		fields = append(fields, ebsvolume.FieldDeleted)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *EbsVolumeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case ebsvolume.FieldGalaxy:
		return m.Galaxy()
	case ebsvolume.FieldRegion:
		return m.Region()
	case ebsvolume.FieldAz:
		return m.Az()
	case ebsvolume.FieldCreatedAt:
		return m.CreatedAt()
	case ebsvolume.FieldUpdatedAt:
		return m.UpdatedAt()
	case ebsvolume.FieldVersion:
		return m.Version()
	case ebsvolume.FieldVolumeID:
		return m.VolumeID()
	case ebsvolume.FieldName:
		return m.Name()
	case ebsvolume.FieldPoolID:
		return m.PoolID()
	case ebsvolume.FieldPoolName:
		return m.PoolName()
	case ebsvolume.FieldSize:
		return m.Size()
	case ebsvolume.FieldStatus:
		return m.Status()
	case ebsvolume.FieldStatusName:
		return m.StatusName()
	case ebsvolume.FieldVolumeType:
		return m.VolumeType()
	case ebsvolume.FieldVMID:
		return m.VMID()
	case ebsvolume.FieldVMName:
		return m.VMName()
	case ebsvolume.FieldTenantID:
		return m.TenantID()
	case ebsvolume.FieldTenantName:
		return m.TenantName()
	case ebsvolume.FieldProjectID:
		return m.ProjectID()
	case ebsvolume.FieldProjectName:
		return m.ProjectName()
	case ebsvolume.FieldCreateTime:
		return m.CreateTime()
	case ebsvolume.FieldServiceEndTime:
		return m.ServiceEndTime()
	case ebsvolume.FieldDeleted:
		return m.Deleted()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *EbsVolumeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case ebsvolume.FieldGalaxy:
		return m.OldGalaxy(ctx)
	case ebsvolume.FieldRegion:
		return m.OldRegion(ctx)
	case ebsvolume.FieldAz:
		return m.OldAz(ctx)
	case ebsvolume.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case ebsvolume.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case ebsvolume.FieldVersion:
		return m.OldVersion(ctx)
	case ebsvolume.FieldVolumeID:
		return m.OldVolumeID(ctx)
	case ebsvolume.FieldName:
		return m.OldName(ctx)
	case ebsvolume.FieldPoolID:
		return m.OldPoolID(ctx)
	case ebsvolume.FieldPoolName:
		return m.OldPoolName(ctx)
	case ebsvolume.FieldSize:
		return m.OldSize(ctx)
	case ebsvolume.FieldStatus:
		return m.OldStatus(ctx)
	case ebsvolume.FieldStatusName:
		return m.OldStatusName(ctx)
	case ebsvolume.FieldVolumeType:
		return m.OldVolumeType(ctx)
	case ebsvolume.FieldVMID:
		return m.OldVMID(ctx)
	case ebsvolume.FieldVMName:
		return m.OldVMName(ctx)
	case ebsvolume.FieldTenantID:
		return m.OldTenantID(ctx)
	case ebsvolume.FieldTenantName:
		return m.OldTenantName(ctx)
	case ebsvolume.FieldProjectID:
		return m.OldProjectID(ctx)
	case ebsvolume.FieldProjectName:
		return m.OldProjectName(ctx)
	case ebsvolume.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case ebsvolume.FieldServiceEndTime:
		return m.OldServiceEndTime(ctx)
	case ebsvolume.FieldDeleted:
		return m.OldDeleted(ctx)
	}
	return nil, fmt.Errorf("unknown EbsVolume field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EbsVolumeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case ebsvolume.FieldGalaxy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGalaxy(v)
		return nil
	case ebsvolume.FieldRegion:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRegion(v)
		return nil
	case ebsvolume.FieldAz:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAz(v)
		return nil
	case ebsvolume.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case ebsvolume.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case ebsvolume.FieldVersion:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVersion(v)
		return nil
	case ebsvolume.FieldVolumeID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVolumeID(v)
		return nil
	case ebsvolume.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case ebsvolume.FieldPoolID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPoolID(v)
		return nil
	case ebsvolume.FieldPoolName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPoolName(v)
		return nil
	case ebsvolume.FieldSize:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSize(v)
		return nil
	case ebsvolume.FieldStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case ebsvolume.FieldStatusName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatusName(v)
		return nil
	case ebsvolume.FieldVolumeType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVolumeType(v)
		return nil
	case ebsvolume.FieldVMID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVMID(v)
		return nil
	case ebsvolume.FieldVMName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVMName(v)
		return nil
	case ebsvolume.FieldTenantID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case ebsvolume.FieldTenantName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantName(v)
		return nil
	case ebsvolume.FieldProjectID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProjectID(v)
		return nil
	case ebsvolume.FieldProjectName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProjectName(v)
		return nil
	case ebsvolume.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case ebsvolume.FieldServiceEndTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetServiceEndTime(v)
		return nil
	case ebsvolume.FieldDeleted:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeleted(v)
		return nil
	}
	return fmt.Errorf("unknown EbsVolume field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *EbsVolumeMutation) AddedFields() []string {
	var fields []string
	if m.addsize != nil {
		fields = append(fields, ebsvolume.FieldSize)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *EbsVolumeMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case ebsvolume.FieldSize:
		return m.AddedSize()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EbsVolumeMutation) AddField(name string, value ent.Value) error {
	switch name {
	case ebsvolume.FieldSize:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSize(v)
		return nil
	}
	return fmt.Errorf("unknown EbsVolume numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *EbsVolumeMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(ebsvolume.FieldGalaxy) {
		fields = append(fields, ebsvolume.FieldGalaxy)
	}
	if m.FieldCleared(ebsvolume.FieldAz) {
		fields = append(fields, ebsvolume.FieldAz)
	}
	if m.FieldCleared(ebsvolume.FieldCreatedAt) {
		fields = append(fields, ebsvolume.FieldCreatedAt)
	}
	if m.FieldCleared(ebsvolume.FieldVersion) {
		fields = append(fields, ebsvolume.FieldVersion)
	}
	if m.FieldCleared(ebsvolume.FieldVolumeID) {
		fields = append(fields, ebsvolume.FieldVolumeID)
	}
	if m.FieldCleared(ebsvolume.FieldPoolID) {
		fields = append(fields, ebsvolume.FieldPoolID)
	}
	if m.FieldCleared(ebsvolume.FieldPoolName) {
		fields = append(fields, ebsvolume.FieldPoolName)
	}
	if m.FieldCleared(ebsvolume.FieldSize) {
		fields = append(fields, ebsvolume.FieldSize)
	}
	if m.FieldCleared(ebsvolume.FieldStatus) {
		fields = append(fields, ebsvolume.FieldStatus)
	}
	if m.FieldCleared(ebsvolume.FieldStatusName) {
		fields = append(fields, ebsvolume.FieldStatusName)
	}
	if m.FieldCleared(ebsvolume.FieldVolumeType) {
		fields = append(fields, ebsvolume.FieldVolumeType)
	}
	if m.FieldCleared(ebsvolume.FieldTenantID) {
		fields = append(fields, ebsvolume.FieldTenantID)
	}
	if m.FieldCleared(ebsvolume.FieldTenantName) {
		fields = append(fields, ebsvolume.FieldTenantName)
	}
	if m.FieldCleared(ebsvolume.FieldCreateTime) {
		fields = append(fields, ebsvolume.FieldCreateTime)
	}
	if m.FieldCleared(ebsvolume.FieldServiceEndTime) {
		fields = append(fields, ebsvolume.FieldServiceEndTime)
	}
	if m.FieldCleared(ebsvolume.FieldDeleted) {
		fields = append(fields, ebsvolume.FieldDeleted)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *EbsVolumeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *EbsVolumeMutation) ClearField(name string) error {
	switch name {
	case ebsvolume.FieldGalaxy:
		m.ClearGalaxy()
		return nil
	case ebsvolume.FieldAz:
		m.ClearAz()
		return nil
	case ebsvolume.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case ebsvolume.FieldVersion:
		m.ClearVersion()
		return nil
	case ebsvolume.FieldVolumeID:
		m.ClearVolumeID()
		return nil
	case ebsvolume.FieldPoolID:
		m.ClearPoolID()
		return nil
	case ebsvolume.FieldPoolName:
		m.ClearPoolName()
		return nil
	case ebsvolume.FieldSize:
		m.ClearSize()
		return nil
	case ebsvolume.FieldStatus:
		m.ClearStatus()
		return nil
	case ebsvolume.FieldStatusName:
		m.ClearStatusName()
		return nil
	case ebsvolume.FieldVolumeType:
		m.ClearVolumeType()
		return nil
	case ebsvolume.FieldTenantID:
		m.ClearTenantID()
		return nil
	case ebsvolume.FieldTenantName:
		m.ClearTenantName()
		return nil
	case ebsvolume.FieldCreateTime:
		m.ClearCreateTime()
		return nil
	case ebsvolume.FieldServiceEndTime:
		m.ClearServiceEndTime()
		return nil
	case ebsvolume.FieldDeleted:
		m.ClearDeleted()
		return nil
	}
	return fmt.Errorf("unknown EbsVolume nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *EbsVolumeMutation) ResetField(name string) error {
	switch name {
	case ebsvolume.FieldGalaxy:
		m.ResetGalaxy()
		return nil
	case ebsvolume.FieldRegion:
		m.ResetRegion()
		return nil
	case ebsvolume.FieldAz:
		m.ResetAz()
		return nil
	case ebsvolume.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case ebsvolume.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case ebsvolume.FieldVersion:
		m.ResetVersion()
		return nil
	case ebsvolume.FieldVolumeID:
		m.ResetVolumeID()
		return nil
	case ebsvolume.FieldName:
		m.ResetName()
		return nil
	case ebsvolume.FieldPoolID:
		m.ResetPoolID()
		return nil
	case ebsvolume.FieldPoolName:
		m.ResetPoolName()
		return nil
	case ebsvolume.FieldSize:
		m.ResetSize()
		return nil
	case ebsvolume.FieldStatus:
		m.ResetStatus()
		return nil
	case ebsvolume.FieldStatusName:
		m.ResetStatusName()
		return nil
	case ebsvolume.FieldVolumeType:
		m.ResetVolumeType()
		return nil
	case ebsvolume.FieldVMID:
		m.ResetVMID()
		return nil
	case ebsvolume.FieldVMName:
		m.ResetVMName()
		return nil
	case ebsvolume.FieldTenantID:
		m.ResetTenantID()
		return nil
	case ebsvolume.FieldTenantName:
		m.ResetTenantName()
		return nil
	case ebsvolume.FieldProjectID:
		m.ResetProjectID()
		return nil
	case ebsvolume.FieldProjectName:
		m.ResetProjectName()
		return nil
	case ebsvolume.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case ebsvolume.FieldServiceEndTime:
		m.ResetServiceEndTime()
		return nil
	case ebsvolume.FieldDeleted:
		m.ResetDeleted()
		return nil
	}
	return fmt.Errorf("unknown EbsVolume field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *EbsVolumeMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *EbsVolumeMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *EbsVolumeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *EbsVolumeMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *EbsVolumeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *EbsVolumeMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *EbsVolumeMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown EbsVolume unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *EbsVolumeMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown EbsVolume edge %s", name)
}

// ObjectStorageMutation represents an operation that mutates the ObjectStorage nodes in the graph.
type ObjectStorageMutation struct {
	config
	op                           Op
	typ                          string
	id                           *string
	name                         *string
	size                         *int
	addsize                      *int
	storage_type                 *string
	region                       *string
	region_code                  *string
	az                           *string
	az_code                      *string
	tenant_id                    *string
	tenant_name                  *string
	inner_domain_name            *string
	outer_domain_name            *string
	create_time                  *int
	addcreate_time               *int
	policy                       *string
	bucket_domains               *string
	resource_pool_id             *int
	addresource_pool_id          *int
	resource_pool_name           *string
	object_count                 *int
	addobject_count              *int
	current_size                 *int
	addcurrent_size              *int
	last30_day_download          *int
	addlast30_day_download       *int
	last30_day_api_call_times    *int
	addlast30_day_api_call_times *int
	last_update_time             *time.Time
	clearedFields                map[string]struct{}
	done                         bool
	oldValue                     func(context.Context) (*ObjectStorage, error)
	predicates                   []predicate.ObjectStorage
}

var _ ent.Mutation = (*ObjectStorageMutation)(nil)

// objectstorageOption allows management of the mutation configuration using functional options.
type objectstorageOption func(*ObjectStorageMutation)

// newObjectStorageMutation creates new mutation for the ObjectStorage entity.
func newObjectStorageMutation(c config, op Op, opts ...objectstorageOption) *ObjectStorageMutation {
	m := &ObjectStorageMutation{
		config:        c,
		op:            op,
		typ:           TypeObjectStorage,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withObjectStorageID sets the ID field of the mutation.
func withObjectStorageID(id string) objectstorageOption {
	return func(m *ObjectStorageMutation) {
		var (
			err   error
			once  sync.Once
			value *ObjectStorage
		)
		m.oldValue = func(ctx context.Context) (*ObjectStorage, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ObjectStorage.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withObjectStorage sets the old ObjectStorage of the mutation.
func withObjectStorage(node *ObjectStorage) objectstorageOption {
	return func(m *ObjectStorageMutation) {
		m.oldValue = func(context.Context) (*ObjectStorage, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ObjectStorageMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ObjectStorageMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ObjectStorage entities.
func (m *ObjectStorageMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ObjectStorageMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ObjectStorageMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ObjectStorage.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *ObjectStorageMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ObjectStorageMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the ObjectStorage entity.
// If the ObjectStorage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ObjectStorageMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ClearName clears the value of the "name" field.
func (m *ObjectStorageMutation) ClearName() {
	m.name = nil
	m.clearedFields[objectstorage.FieldName] = struct{}{}
}

// NameCleared returns if the "name" field was cleared in this mutation.
func (m *ObjectStorageMutation) NameCleared() bool {
	_, ok := m.clearedFields[objectstorage.FieldName]
	return ok
}

// ResetName resets all changes to the "name" field.
func (m *ObjectStorageMutation) ResetName() {
	m.name = nil
	delete(m.clearedFields, objectstorage.FieldName)
}

// SetSize sets the "size" field.
func (m *ObjectStorageMutation) SetSize(i int) {
	m.size = &i
	m.addsize = nil
}

// Size returns the value of the "size" field in the mutation.
func (m *ObjectStorageMutation) Size() (r int, exists bool) {
	v := m.size
	if v == nil {
		return
	}
	return *v, true
}

// OldSize returns the old "size" field's value of the ObjectStorage entity.
// If the ObjectStorage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ObjectStorageMutation) OldSize(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSize is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSize requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSize: %w", err)
	}
	return oldValue.Size, nil
}

// AddSize adds i to the "size" field.
func (m *ObjectStorageMutation) AddSize(i int) {
	if m.addsize != nil {
		*m.addsize += i
	} else {
		m.addsize = &i
	}
}

// AddedSize returns the value that was added to the "size" field in this mutation.
func (m *ObjectStorageMutation) AddedSize() (r int, exists bool) {
	v := m.addsize
	if v == nil {
		return
	}
	return *v, true
}

// ClearSize clears the value of the "size" field.
func (m *ObjectStorageMutation) ClearSize() {
	m.size = nil
	m.addsize = nil
	m.clearedFields[objectstorage.FieldSize] = struct{}{}
}

// SizeCleared returns if the "size" field was cleared in this mutation.
func (m *ObjectStorageMutation) SizeCleared() bool {
	_, ok := m.clearedFields[objectstorage.FieldSize]
	return ok
}

// ResetSize resets all changes to the "size" field.
func (m *ObjectStorageMutation) ResetSize() {
	m.size = nil
	m.addsize = nil
	delete(m.clearedFields, objectstorage.FieldSize)
}

// SetStorageType sets the "storage_type" field.
func (m *ObjectStorageMutation) SetStorageType(s string) {
	m.storage_type = &s
}

// StorageType returns the value of the "storage_type" field in the mutation.
func (m *ObjectStorageMutation) StorageType() (r string, exists bool) {
	v := m.storage_type
	if v == nil {
		return
	}
	return *v, true
}

// OldStorageType returns the old "storage_type" field's value of the ObjectStorage entity.
// If the ObjectStorage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ObjectStorageMutation) OldStorageType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStorageType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStorageType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStorageType: %w", err)
	}
	return oldValue.StorageType, nil
}

// ClearStorageType clears the value of the "storage_type" field.
func (m *ObjectStorageMutation) ClearStorageType() {
	m.storage_type = nil
	m.clearedFields[objectstorage.FieldStorageType] = struct{}{}
}

// StorageTypeCleared returns if the "storage_type" field was cleared in this mutation.
func (m *ObjectStorageMutation) StorageTypeCleared() bool {
	_, ok := m.clearedFields[objectstorage.FieldStorageType]
	return ok
}

// ResetStorageType resets all changes to the "storage_type" field.
func (m *ObjectStorageMutation) ResetStorageType() {
	m.storage_type = nil
	delete(m.clearedFields, objectstorage.FieldStorageType)
}

// SetRegion sets the "region" field.
func (m *ObjectStorageMutation) SetRegion(s string) {
	m.region = &s
}

// Region returns the value of the "region" field in the mutation.
func (m *ObjectStorageMutation) Region() (r string, exists bool) {
	v := m.region
	if v == nil {
		return
	}
	return *v, true
}

// OldRegion returns the old "region" field's value of the ObjectStorage entity.
// If the ObjectStorage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ObjectStorageMutation) OldRegion(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRegion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRegion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRegion: %w", err)
	}
	return oldValue.Region, nil
}

// ClearRegion clears the value of the "region" field.
func (m *ObjectStorageMutation) ClearRegion() {
	m.region = nil
	m.clearedFields[objectstorage.FieldRegion] = struct{}{}
}

// RegionCleared returns if the "region" field was cleared in this mutation.
func (m *ObjectStorageMutation) RegionCleared() bool {
	_, ok := m.clearedFields[objectstorage.FieldRegion]
	return ok
}

// ResetRegion resets all changes to the "region" field.
func (m *ObjectStorageMutation) ResetRegion() {
	m.region = nil
	delete(m.clearedFields, objectstorage.FieldRegion)
}

// SetRegionCode sets the "region_code" field.
func (m *ObjectStorageMutation) SetRegionCode(s string) {
	m.region_code = &s
}

// RegionCode returns the value of the "region_code" field in the mutation.
func (m *ObjectStorageMutation) RegionCode() (r string, exists bool) {
	v := m.region_code
	if v == nil {
		return
	}
	return *v, true
}

// OldRegionCode returns the old "region_code" field's value of the ObjectStorage entity.
// If the ObjectStorage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ObjectStorageMutation) OldRegionCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRegionCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRegionCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRegionCode: %w", err)
	}
	return oldValue.RegionCode, nil
}

// ClearRegionCode clears the value of the "region_code" field.
func (m *ObjectStorageMutation) ClearRegionCode() {
	m.region_code = nil
	m.clearedFields[objectstorage.FieldRegionCode] = struct{}{}
}

// RegionCodeCleared returns if the "region_code" field was cleared in this mutation.
func (m *ObjectStorageMutation) RegionCodeCleared() bool {
	_, ok := m.clearedFields[objectstorage.FieldRegionCode]
	return ok
}

// ResetRegionCode resets all changes to the "region_code" field.
func (m *ObjectStorageMutation) ResetRegionCode() {
	m.region_code = nil
	delete(m.clearedFields, objectstorage.FieldRegionCode)
}

// SetAz sets the "az" field.
func (m *ObjectStorageMutation) SetAz(s string) {
	m.az = &s
}

// Az returns the value of the "az" field in the mutation.
func (m *ObjectStorageMutation) Az() (r string, exists bool) {
	v := m.az
	if v == nil {
		return
	}
	return *v, true
}

// OldAz returns the old "az" field's value of the ObjectStorage entity.
// If the ObjectStorage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ObjectStorageMutation) OldAz(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAz is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAz requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAz: %w", err)
	}
	return oldValue.Az, nil
}

// ClearAz clears the value of the "az" field.
func (m *ObjectStorageMutation) ClearAz() {
	m.az = nil
	m.clearedFields[objectstorage.FieldAz] = struct{}{}
}

// AzCleared returns if the "az" field was cleared in this mutation.
func (m *ObjectStorageMutation) AzCleared() bool {
	_, ok := m.clearedFields[objectstorage.FieldAz]
	return ok
}

// ResetAz resets all changes to the "az" field.
func (m *ObjectStorageMutation) ResetAz() {
	m.az = nil
	delete(m.clearedFields, objectstorage.FieldAz)
}

// SetAzCode sets the "az_code" field.
func (m *ObjectStorageMutation) SetAzCode(s string) {
	m.az_code = &s
}

// AzCode returns the value of the "az_code" field in the mutation.
func (m *ObjectStorageMutation) AzCode() (r string, exists bool) {
	v := m.az_code
	if v == nil {
		return
	}
	return *v, true
}

// OldAzCode returns the old "az_code" field's value of the ObjectStorage entity.
// If the ObjectStorage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ObjectStorageMutation) OldAzCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAzCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAzCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAzCode: %w", err)
	}
	return oldValue.AzCode, nil
}

// ClearAzCode clears the value of the "az_code" field.
func (m *ObjectStorageMutation) ClearAzCode() {
	m.az_code = nil
	m.clearedFields[objectstorage.FieldAzCode] = struct{}{}
}

// AzCodeCleared returns if the "az_code" field was cleared in this mutation.
func (m *ObjectStorageMutation) AzCodeCleared() bool {
	_, ok := m.clearedFields[objectstorage.FieldAzCode]
	return ok
}

// ResetAzCode resets all changes to the "az_code" field.
func (m *ObjectStorageMutation) ResetAzCode() {
	m.az_code = nil
	delete(m.clearedFields, objectstorage.FieldAzCode)
}

// SetTenantID sets the "tenant_id" field.
func (m *ObjectStorageMutation) SetTenantID(s string) {
	m.tenant_id = &s
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *ObjectStorageMutation) TenantID() (r string, exists bool) {
	v := m.tenant_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the ObjectStorage entity.
// If the ObjectStorage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ObjectStorageMutation) OldTenantID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// ClearTenantID clears the value of the "tenant_id" field.
func (m *ObjectStorageMutation) ClearTenantID() {
	m.tenant_id = nil
	m.clearedFields[objectstorage.FieldTenantID] = struct{}{}
}

// TenantIDCleared returns if the "tenant_id" field was cleared in this mutation.
func (m *ObjectStorageMutation) TenantIDCleared() bool {
	_, ok := m.clearedFields[objectstorage.FieldTenantID]
	return ok
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *ObjectStorageMutation) ResetTenantID() {
	m.tenant_id = nil
	delete(m.clearedFields, objectstorage.FieldTenantID)
}

// SetTenantName sets the "tenant_name" field.
func (m *ObjectStorageMutation) SetTenantName(s string) {
	m.tenant_name = &s
}

// TenantName returns the value of the "tenant_name" field in the mutation.
func (m *ObjectStorageMutation) TenantName() (r string, exists bool) {
	v := m.tenant_name
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantName returns the old "tenant_name" field's value of the ObjectStorage entity.
// If the ObjectStorage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ObjectStorageMutation) OldTenantName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantName: %w", err)
	}
	return oldValue.TenantName, nil
}

// ClearTenantName clears the value of the "tenant_name" field.
func (m *ObjectStorageMutation) ClearTenantName() {
	m.tenant_name = nil
	m.clearedFields[objectstorage.FieldTenantName] = struct{}{}
}

// TenantNameCleared returns if the "tenant_name" field was cleared in this mutation.
func (m *ObjectStorageMutation) TenantNameCleared() bool {
	_, ok := m.clearedFields[objectstorage.FieldTenantName]
	return ok
}

// ResetTenantName resets all changes to the "tenant_name" field.
func (m *ObjectStorageMutation) ResetTenantName() {
	m.tenant_name = nil
	delete(m.clearedFields, objectstorage.FieldTenantName)
}

// SetInnerDomainName sets the "inner_domain_name" field.
func (m *ObjectStorageMutation) SetInnerDomainName(s string) {
	m.inner_domain_name = &s
}

// InnerDomainName returns the value of the "inner_domain_name" field in the mutation.
func (m *ObjectStorageMutation) InnerDomainName() (r string, exists bool) {
	v := m.inner_domain_name
	if v == nil {
		return
	}
	return *v, true
}

// OldInnerDomainName returns the old "inner_domain_name" field's value of the ObjectStorage entity.
// If the ObjectStorage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ObjectStorageMutation) OldInnerDomainName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInnerDomainName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInnerDomainName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInnerDomainName: %w", err)
	}
	return oldValue.InnerDomainName, nil
}

// ClearInnerDomainName clears the value of the "inner_domain_name" field.
func (m *ObjectStorageMutation) ClearInnerDomainName() {
	m.inner_domain_name = nil
	m.clearedFields[objectstorage.FieldInnerDomainName] = struct{}{}
}

// InnerDomainNameCleared returns if the "inner_domain_name" field was cleared in this mutation.
func (m *ObjectStorageMutation) InnerDomainNameCleared() bool {
	_, ok := m.clearedFields[objectstorage.FieldInnerDomainName]
	return ok
}

// ResetInnerDomainName resets all changes to the "inner_domain_name" field.
func (m *ObjectStorageMutation) ResetInnerDomainName() {
	m.inner_domain_name = nil
	delete(m.clearedFields, objectstorage.FieldInnerDomainName)
}

// SetOuterDomainName sets the "outer_domain_name" field.
func (m *ObjectStorageMutation) SetOuterDomainName(s string) {
	m.outer_domain_name = &s
}

// OuterDomainName returns the value of the "outer_domain_name" field in the mutation.
func (m *ObjectStorageMutation) OuterDomainName() (r string, exists bool) {
	v := m.outer_domain_name
	if v == nil {
		return
	}
	return *v, true
}

// OldOuterDomainName returns the old "outer_domain_name" field's value of the ObjectStorage entity.
// If the ObjectStorage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ObjectStorageMutation) OldOuterDomainName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOuterDomainName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOuterDomainName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOuterDomainName: %w", err)
	}
	return oldValue.OuterDomainName, nil
}

// ClearOuterDomainName clears the value of the "outer_domain_name" field.
func (m *ObjectStorageMutation) ClearOuterDomainName() {
	m.outer_domain_name = nil
	m.clearedFields[objectstorage.FieldOuterDomainName] = struct{}{}
}

// OuterDomainNameCleared returns if the "outer_domain_name" field was cleared in this mutation.
func (m *ObjectStorageMutation) OuterDomainNameCleared() bool {
	_, ok := m.clearedFields[objectstorage.FieldOuterDomainName]
	return ok
}

// ResetOuterDomainName resets all changes to the "outer_domain_name" field.
func (m *ObjectStorageMutation) ResetOuterDomainName() {
	m.outer_domain_name = nil
	delete(m.clearedFields, objectstorage.FieldOuterDomainName)
}

// SetCreateTime sets the "create_time" field.
func (m *ObjectStorageMutation) SetCreateTime(i int) {
	m.create_time = &i
	m.addcreate_time = nil
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *ObjectStorageMutation) CreateTime() (r int, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the ObjectStorage entity.
// If the ObjectStorage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ObjectStorageMutation) OldCreateTime(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// AddCreateTime adds i to the "create_time" field.
func (m *ObjectStorageMutation) AddCreateTime(i int) {
	if m.addcreate_time != nil {
		*m.addcreate_time += i
	} else {
		m.addcreate_time = &i
	}
}

// AddedCreateTime returns the value that was added to the "create_time" field in this mutation.
func (m *ObjectStorageMutation) AddedCreateTime() (r int, exists bool) {
	v := m.addcreate_time
	if v == nil {
		return
	}
	return *v, true
}

// ClearCreateTime clears the value of the "create_time" field.
func (m *ObjectStorageMutation) ClearCreateTime() {
	m.create_time = nil
	m.addcreate_time = nil
	m.clearedFields[objectstorage.FieldCreateTime] = struct{}{}
}

// CreateTimeCleared returns if the "create_time" field was cleared in this mutation.
func (m *ObjectStorageMutation) CreateTimeCleared() bool {
	_, ok := m.clearedFields[objectstorage.FieldCreateTime]
	return ok
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *ObjectStorageMutation) ResetCreateTime() {
	m.create_time = nil
	m.addcreate_time = nil
	delete(m.clearedFields, objectstorage.FieldCreateTime)
}

// SetPolicy sets the "policy" field.
func (m *ObjectStorageMutation) SetPolicy(s string) {
	m.policy = &s
}

// Policy returns the value of the "policy" field in the mutation.
func (m *ObjectStorageMutation) Policy() (r string, exists bool) {
	v := m.policy
	if v == nil {
		return
	}
	return *v, true
}

// OldPolicy returns the old "policy" field's value of the ObjectStorage entity.
// If the ObjectStorage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ObjectStorageMutation) OldPolicy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPolicy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPolicy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPolicy: %w", err)
	}
	return oldValue.Policy, nil
}

// ClearPolicy clears the value of the "policy" field.
func (m *ObjectStorageMutation) ClearPolicy() {
	m.policy = nil
	m.clearedFields[objectstorage.FieldPolicy] = struct{}{}
}

// PolicyCleared returns if the "policy" field was cleared in this mutation.
func (m *ObjectStorageMutation) PolicyCleared() bool {
	_, ok := m.clearedFields[objectstorage.FieldPolicy]
	return ok
}

// ResetPolicy resets all changes to the "policy" field.
func (m *ObjectStorageMutation) ResetPolicy() {
	m.policy = nil
	delete(m.clearedFields, objectstorage.FieldPolicy)
}

// SetBucketDomains sets the "bucket_domains" field.
func (m *ObjectStorageMutation) SetBucketDomains(s string) {
	m.bucket_domains = &s
}

// BucketDomains returns the value of the "bucket_domains" field in the mutation.
func (m *ObjectStorageMutation) BucketDomains() (r string, exists bool) {
	v := m.bucket_domains
	if v == nil {
		return
	}
	return *v, true
}

// OldBucketDomains returns the old "bucket_domains" field's value of the ObjectStorage entity.
// If the ObjectStorage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ObjectStorageMutation) OldBucketDomains(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBucketDomains is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBucketDomains requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBucketDomains: %w", err)
	}
	return oldValue.BucketDomains, nil
}

// ClearBucketDomains clears the value of the "bucket_domains" field.
func (m *ObjectStorageMutation) ClearBucketDomains() {
	m.bucket_domains = nil
	m.clearedFields[objectstorage.FieldBucketDomains] = struct{}{}
}

// BucketDomainsCleared returns if the "bucket_domains" field was cleared in this mutation.
func (m *ObjectStorageMutation) BucketDomainsCleared() bool {
	_, ok := m.clearedFields[objectstorage.FieldBucketDomains]
	return ok
}

// ResetBucketDomains resets all changes to the "bucket_domains" field.
func (m *ObjectStorageMutation) ResetBucketDomains() {
	m.bucket_domains = nil
	delete(m.clearedFields, objectstorage.FieldBucketDomains)
}

// SetResourcePoolID sets the "resource_pool_id" field.
func (m *ObjectStorageMutation) SetResourcePoolID(i int) {
	m.resource_pool_id = &i
	m.addresource_pool_id = nil
}

// ResourcePoolID returns the value of the "resource_pool_id" field in the mutation.
func (m *ObjectStorageMutation) ResourcePoolID() (r int, exists bool) {
	v := m.resource_pool_id
	if v == nil {
		return
	}
	return *v, true
}

// OldResourcePoolID returns the old "resource_pool_id" field's value of the ObjectStorage entity.
// If the ObjectStorage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ObjectStorageMutation) OldResourcePoolID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResourcePoolID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResourcePoolID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResourcePoolID: %w", err)
	}
	return oldValue.ResourcePoolID, nil
}

// AddResourcePoolID adds i to the "resource_pool_id" field.
func (m *ObjectStorageMutation) AddResourcePoolID(i int) {
	if m.addresource_pool_id != nil {
		*m.addresource_pool_id += i
	} else {
		m.addresource_pool_id = &i
	}
}

// AddedResourcePoolID returns the value that was added to the "resource_pool_id" field in this mutation.
func (m *ObjectStorageMutation) AddedResourcePoolID() (r int, exists bool) {
	v := m.addresource_pool_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearResourcePoolID clears the value of the "resource_pool_id" field.
func (m *ObjectStorageMutation) ClearResourcePoolID() {
	m.resource_pool_id = nil
	m.addresource_pool_id = nil
	m.clearedFields[objectstorage.FieldResourcePoolID] = struct{}{}
}

// ResourcePoolIDCleared returns if the "resource_pool_id" field was cleared in this mutation.
func (m *ObjectStorageMutation) ResourcePoolIDCleared() bool {
	_, ok := m.clearedFields[objectstorage.FieldResourcePoolID]
	return ok
}

// ResetResourcePoolID resets all changes to the "resource_pool_id" field.
func (m *ObjectStorageMutation) ResetResourcePoolID() {
	m.resource_pool_id = nil
	m.addresource_pool_id = nil
	delete(m.clearedFields, objectstorage.FieldResourcePoolID)
}

// SetResourcePoolName sets the "resource_pool_name" field.
func (m *ObjectStorageMutation) SetResourcePoolName(s string) {
	m.resource_pool_name = &s
}

// ResourcePoolName returns the value of the "resource_pool_name" field in the mutation.
func (m *ObjectStorageMutation) ResourcePoolName() (r string, exists bool) {
	v := m.resource_pool_name
	if v == nil {
		return
	}
	return *v, true
}

// OldResourcePoolName returns the old "resource_pool_name" field's value of the ObjectStorage entity.
// If the ObjectStorage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ObjectStorageMutation) OldResourcePoolName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResourcePoolName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResourcePoolName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResourcePoolName: %w", err)
	}
	return oldValue.ResourcePoolName, nil
}

// ClearResourcePoolName clears the value of the "resource_pool_name" field.
func (m *ObjectStorageMutation) ClearResourcePoolName() {
	m.resource_pool_name = nil
	m.clearedFields[objectstorage.FieldResourcePoolName] = struct{}{}
}

// ResourcePoolNameCleared returns if the "resource_pool_name" field was cleared in this mutation.
func (m *ObjectStorageMutation) ResourcePoolNameCleared() bool {
	_, ok := m.clearedFields[objectstorage.FieldResourcePoolName]
	return ok
}

// ResetResourcePoolName resets all changes to the "resource_pool_name" field.
func (m *ObjectStorageMutation) ResetResourcePoolName() {
	m.resource_pool_name = nil
	delete(m.clearedFields, objectstorage.FieldResourcePoolName)
}

// SetObjectCount sets the "object_count" field.
func (m *ObjectStorageMutation) SetObjectCount(i int) {
	m.object_count = &i
	m.addobject_count = nil
}

// ObjectCount returns the value of the "object_count" field in the mutation.
func (m *ObjectStorageMutation) ObjectCount() (r int, exists bool) {
	v := m.object_count
	if v == nil {
		return
	}
	return *v, true
}

// OldObjectCount returns the old "object_count" field's value of the ObjectStorage entity.
// If the ObjectStorage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ObjectStorageMutation) OldObjectCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldObjectCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldObjectCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldObjectCount: %w", err)
	}
	return oldValue.ObjectCount, nil
}

// AddObjectCount adds i to the "object_count" field.
func (m *ObjectStorageMutation) AddObjectCount(i int) {
	if m.addobject_count != nil {
		*m.addobject_count += i
	} else {
		m.addobject_count = &i
	}
}

// AddedObjectCount returns the value that was added to the "object_count" field in this mutation.
func (m *ObjectStorageMutation) AddedObjectCount() (r int, exists bool) {
	v := m.addobject_count
	if v == nil {
		return
	}
	return *v, true
}

// ClearObjectCount clears the value of the "object_count" field.
func (m *ObjectStorageMutation) ClearObjectCount() {
	m.object_count = nil
	m.addobject_count = nil
	m.clearedFields[objectstorage.FieldObjectCount] = struct{}{}
}

// ObjectCountCleared returns if the "object_count" field was cleared in this mutation.
func (m *ObjectStorageMutation) ObjectCountCleared() bool {
	_, ok := m.clearedFields[objectstorage.FieldObjectCount]
	return ok
}

// ResetObjectCount resets all changes to the "object_count" field.
func (m *ObjectStorageMutation) ResetObjectCount() {
	m.object_count = nil
	m.addobject_count = nil
	delete(m.clearedFields, objectstorage.FieldObjectCount)
}

// SetCurrentSize sets the "current_size" field.
func (m *ObjectStorageMutation) SetCurrentSize(i int) {
	m.current_size = &i
	m.addcurrent_size = nil
}

// CurrentSize returns the value of the "current_size" field in the mutation.
func (m *ObjectStorageMutation) CurrentSize() (r int, exists bool) {
	v := m.current_size
	if v == nil {
		return
	}
	return *v, true
}

// OldCurrentSize returns the old "current_size" field's value of the ObjectStorage entity.
// If the ObjectStorage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ObjectStorageMutation) OldCurrentSize(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCurrentSize is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCurrentSize requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCurrentSize: %w", err)
	}
	return oldValue.CurrentSize, nil
}

// AddCurrentSize adds i to the "current_size" field.
func (m *ObjectStorageMutation) AddCurrentSize(i int) {
	if m.addcurrent_size != nil {
		*m.addcurrent_size += i
	} else {
		m.addcurrent_size = &i
	}
}

// AddedCurrentSize returns the value that was added to the "current_size" field in this mutation.
func (m *ObjectStorageMutation) AddedCurrentSize() (r int, exists bool) {
	v := m.addcurrent_size
	if v == nil {
		return
	}
	return *v, true
}

// ClearCurrentSize clears the value of the "current_size" field.
func (m *ObjectStorageMutation) ClearCurrentSize() {
	m.current_size = nil
	m.addcurrent_size = nil
	m.clearedFields[objectstorage.FieldCurrentSize] = struct{}{}
}

// CurrentSizeCleared returns if the "current_size" field was cleared in this mutation.
func (m *ObjectStorageMutation) CurrentSizeCleared() bool {
	_, ok := m.clearedFields[objectstorage.FieldCurrentSize]
	return ok
}

// ResetCurrentSize resets all changes to the "current_size" field.
func (m *ObjectStorageMutation) ResetCurrentSize() {
	m.current_size = nil
	m.addcurrent_size = nil
	delete(m.clearedFields, objectstorage.FieldCurrentSize)
}

// SetLast30DayDownload sets the "last30_day_download" field.
func (m *ObjectStorageMutation) SetLast30DayDownload(i int) {
	m.last30_day_download = &i
	m.addlast30_day_download = nil
}

// Last30DayDownload returns the value of the "last30_day_download" field in the mutation.
func (m *ObjectStorageMutation) Last30DayDownload() (r int, exists bool) {
	v := m.last30_day_download
	if v == nil {
		return
	}
	return *v, true
}

// OldLast30DayDownload returns the old "last30_day_download" field's value of the ObjectStorage entity.
// If the ObjectStorage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ObjectStorageMutation) OldLast30DayDownload(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLast30DayDownload is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLast30DayDownload requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLast30DayDownload: %w", err)
	}
	return oldValue.Last30DayDownload, nil
}

// AddLast30DayDownload adds i to the "last30_day_download" field.
func (m *ObjectStorageMutation) AddLast30DayDownload(i int) {
	if m.addlast30_day_download != nil {
		*m.addlast30_day_download += i
	} else {
		m.addlast30_day_download = &i
	}
}

// AddedLast30DayDownload returns the value that was added to the "last30_day_download" field in this mutation.
func (m *ObjectStorageMutation) AddedLast30DayDownload() (r int, exists bool) {
	v := m.addlast30_day_download
	if v == nil {
		return
	}
	return *v, true
}

// ClearLast30DayDownload clears the value of the "last30_day_download" field.
func (m *ObjectStorageMutation) ClearLast30DayDownload() {
	m.last30_day_download = nil
	m.addlast30_day_download = nil
	m.clearedFields[objectstorage.FieldLast30DayDownload] = struct{}{}
}

// Last30DayDownloadCleared returns if the "last30_day_download" field was cleared in this mutation.
func (m *ObjectStorageMutation) Last30DayDownloadCleared() bool {
	_, ok := m.clearedFields[objectstorage.FieldLast30DayDownload]
	return ok
}

// ResetLast30DayDownload resets all changes to the "last30_day_download" field.
func (m *ObjectStorageMutation) ResetLast30DayDownload() {
	m.last30_day_download = nil
	m.addlast30_day_download = nil
	delete(m.clearedFields, objectstorage.FieldLast30DayDownload)
}

// SetLast30DayAPICallTimes sets the "last30_day_api_call_times" field.
func (m *ObjectStorageMutation) SetLast30DayAPICallTimes(i int) {
	m.last30_day_api_call_times = &i
	m.addlast30_day_api_call_times = nil
}

// Last30DayAPICallTimes returns the value of the "last30_day_api_call_times" field in the mutation.
func (m *ObjectStorageMutation) Last30DayAPICallTimes() (r int, exists bool) {
	v := m.last30_day_api_call_times
	if v == nil {
		return
	}
	return *v, true
}

// OldLast30DayAPICallTimes returns the old "last30_day_api_call_times" field's value of the ObjectStorage entity.
// If the ObjectStorage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ObjectStorageMutation) OldLast30DayAPICallTimes(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLast30DayAPICallTimes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLast30DayAPICallTimes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLast30DayAPICallTimes: %w", err)
	}
	return oldValue.Last30DayAPICallTimes, nil
}

// AddLast30DayAPICallTimes adds i to the "last30_day_api_call_times" field.
func (m *ObjectStorageMutation) AddLast30DayAPICallTimes(i int) {
	if m.addlast30_day_api_call_times != nil {
		*m.addlast30_day_api_call_times += i
	} else {
		m.addlast30_day_api_call_times = &i
	}
}

// AddedLast30DayAPICallTimes returns the value that was added to the "last30_day_api_call_times" field in this mutation.
func (m *ObjectStorageMutation) AddedLast30DayAPICallTimes() (r int, exists bool) {
	v := m.addlast30_day_api_call_times
	if v == nil {
		return
	}
	return *v, true
}

// ClearLast30DayAPICallTimes clears the value of the "last30_day_api_call_times" field.
func (m *ObjectStorageMutation) ClearLast30DayAPICallTimes() {
	m.last30_day_api_call_times = nil
	m.addlast30_day_api_call_times = nil
	m.clearedFields[objectstorage.FieldLast30DayAPICallTimes] = struct{}{}
}

// Last30DayAPICallTimesCleared returns if the "last30_day_api_call_times" field was cleared in this mutation.
func (m *ObjectStorageMutation) Last30DayAPICallTimesCleared() bool {
	_, ok := m.clearedFields[objectstorage.FieldLast30DayAPICallTimes]
	return ok
}

// ResetLast30DayAPICallTimes resets all changes to the "last30_day_api_call_times" field.
func (m *ObjectStorageMutation) ResetLast30DayAPICallTimes() {
	m.last30_day_api_call_times = nil
	m.addlast30_day_api_call_times = nil
	delete(m.clearedFields, objectstorage.FieldLast30DayAPICallTimes)
}

// SetLastUpdateTime sets the "last_update_time" field.
func (m *ObjectStorageMutation) SetLastUpdateTime(t time.Time) {
	m.last_update_time = &t
}

// LastUpdateTime returns the value of the "last_update_time" field in the mutation.
func (m *ObjectStorageMutation) LastUpdateTime() (r time.Time, exists bool) {
	v := m.last_update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldLastUpdateTime returns the old "last_update_time" field's value of the ObjectStorage entity.
// If the ObjectStorage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ObjectStorageMutation) OldLastUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastUpdateTime: %w", err)
	}
	return oldValue.LastUpdateTime, nil
}

// ResetLastUpdateTime resets all changes to the "last_update_time" field.
func (m *ObjectStorageMutation) ResetLastUpdateTime() {
	m.last_update_time = nil
}

// Where appends a list predicates to the ObjectStorageMutation builder.
func (m *ObjectStorageMutation) Where(ps ...predicate.ObjectStorage) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ObjectStorageMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ObjectStorageMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ObjectStorage, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ObjectStorageMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ObjectStorageMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ObjectStorage).
func (m *ObjectStorageMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ObjectStorageMutation) Fields() []string {
	fields := make([]string, 0, 21)
	if m.name != nil {
		fields = append(fields, objectstorage.FieldName)
	}
	if m.size != nil {
		fields = append(fields, objectstorage.FieldSize)
	}
	if m.storage_type != nil {
		fields = append(fields, objectstorage.FieldStorageType)
	}
	if m.region != nil {
		fields = append(fields, objectstorage.FieldRegion)
	}
	if m.region_code != nil {
		fields = append(fields, objectstorage.FieldRegionCode)
	}
	if m.az != nil {
		fields = append(fields, objectstorage.FieldAz)
	}
	if m.az_code != nil {
		fields = append(fields, objectstorage.FieldAzCode)
	}
	if m.tenant_id != nil {
		fields = append(fields, objectstorage.FieldTenantID)
	}
	if m.tenant_name != nil {
		fields = append(fields, objectstorage.FieldTenantName)
	}
	if m.inner_domain_name != nil {
		fields = append(fields, objectstorage.FieldInnerDomainName)
	}
	if m.outer_domain_name != nil {
		fields = append(fields, objectstorage.FieldOuterDomainName)
	}
	if m.create_time != nil {
		fields = append(fields, objectstorage.FieldCreateTime)
	}
	if m.policy != nil {
		fields = append(fields, objectstorage.FieldPolicy)
	}
	if m.bucket_domains != nil {
		fields = append(fields, objectstorage.FieldBucketDomains)
	}
	if m.resource_pool_id != nil {
		fields = append(fields, objectstorage.FieldResourcePoolID)
	}
	if m.resource_pool_name != nil {
		fields = append(fields, objectstorage.FieldResourcePoolName)
	}
	if m.object_count != nil {
		fields = append(fields, objectstorage.FieldObjectCount)
	}
	if m.current_size != nil {
		fields = append(fields, objectstorage.FieldCurrentSize)
	}
	if m.last30_day_download != nil {
		fields = append(fields, objectstorage.FieldLast30DayDownload)
	}
	if m.last30_day_api_call_times != nil {
		fields = append(fields, objectstorage.FieldLast30DayAPICallTimes)
	}
	if m.last_update_time != nil {
		fields = append(fields, objectstorage.FieldLastUpdateTime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ObjectStorageMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case objectstorage.FieldName:
		return m.Name()
	case objectstorage.FieldSize:
		return m.Size()
	case objectstorage.FieldStorageType:
		return m.StorageType()
	case objectstorage.FieldRegion:
		return m.Region()
	case objectstorage.FieldRegionCode:
		return m.RegionCode()
	case objectstorage.FieldAz:
		return m.Az()
	case objectstorage.FieldAzCode:
		return m.AzCode()
	case objectstorage.FieldTenantID:
		return m.TenantID()
	case objectstorage.FieldTenantName:
		return m.TenantName()
	case objectstorage.FieldInnerDomainName:
		return m.InnerDomainName()
	case objectstorage.FieldOuterDomainName:
		return m.OuterDomainName()
	case objectstorage.FieldCreateTime:
		return m.CreateTime()
	case objectstorage.FieldPolicy:
		return m.Policy()
	case objectstorage.FieldBucketDomains:
		return m.BucketDomains()
	case objectstorage.FieldResourcePoolID:
		return m.ResourcePoolID()
	case objectstorage.FieldResourcePoolName:
		return m.ResourcePoolName()
	case objectstorage.FieldObjectCount:
		return m.ObjectCount()
	case objectstorage.FieldCurrentSize:
		return m.CurrentSize()
	case objectstorage.FieldLast30DayDownload:
		return m.Last30DayDownload()
	case objectstorage.FieldLast30DayAPICallTimes:
		return m.Last30DayAPICallTimes()
	case objectstorage.FieldLastUpdateTime:
		return m.LastUpdateTime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ObjectStorageMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case objectstorage.FieldName:
		return m.OldName(ctx)
	case objectstorage.FieldSize:
		return m.OldSize(ctx)
	case objectstorage.FieldStorageType:
		return m.OldStorageType(ctx)
	case objectstorage.FieldRegion:
		return m.OldRegion(ctx)
	case objectstorage.FieldRegionCode:
		return m.OldRegionCode(ctx)
	case objectstorage.FieldAz:
		return m.OldAz(ctx)
	case objectstorage.FieldAzCode:
		return m.OldAzCode(ctx)
	case objectstorage.FieldTenantID:
		return m.OldTenantID(ctx)
	case objectstorage.FieldTenantName:
		return m.OldTenantName(ctx)
	case objectstorage.FieldInnerDomainName:
		return m.OldInnerDomainName(ctx)
	case objectstorage.FieldOuterDomainName:
		return m.OldOuterDomainName(ctx)
	case objectstorage.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case objectstorage.FieldPolicy:
		return m.OldPolicy(ctx)
	case objectstorage.FieldBucketDomains:
		return m.OldBucketDomains(ctx)
	case objectstorage.FieldResourcePoolID:
		return m.OldResourcePoolID(ctx)
	case objectstorage.FieldResourcePoolName:
		return m.OldResourcePoolName(ctx)
	case objectstorage.FieldObjectCount:
		return m.OldObjectCount(ctx)
	case objectstorage.FieldCurrentSize:
		return m.OldCurrentSize(ctx)
	case objectstorage.FieldLast30DayDownload:
		return m.OldLast30DayDownload(ctx)
	case objectstorage.FieldLast30DayAPICallTimes:
		return m.OldLast30DayAPICallTimes(ctx)
	case objectstorage.FieldLastUpdateTime:
		return m.OldLastUpdateTime(ctx)
	}
	return nil, fmt.Errorf("unknown ObjectStorage field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ObjectStorageMutation) SetField(name string, value ent.Value) error {
	switch name {
	case objectstorage.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case objectstorage.FieldSize:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSize(v)
		return nil
	case objectstorage.FieldStorageType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStorageType(v)
		return nil
	case objectstorage.FieldRegion:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRegion(v)
		return nil
	case objectstorage.FieldRegionCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRegionCode(v)
		return nil
	case objectstorage.FieldAz:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAz(v)
		return nil
	case objectstorage.FieldAzCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAzCode(v)
		return nil
	case objectstorage.FieldTenantID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case objectstorage.FieldTenantName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantName(v)
		return nil
	case objectstorage.FieldInnerDomainName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInnerDomainName(v)
		return nil
	case objectstorage.FieldOuterDomainName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOuterDomainName(v)
		return nil
	case objectstorage.FieldCreateTime:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case objectstorage.FieldPolicy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPolicy(v)
		return nil
	case objectstorage.FieldBucketDomains:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBucketDomains(v)
		return nil
	case objectstorage.FieldResourcePoolID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResourcePoolID(v)
		return nil
	case objectstorage.FieldResourcePoolName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResourcePoolName(v)
		return nil
	case objectstorage.FieldObjectCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetObjectCount(v)
		return nil
	case objectstorage.FieldCurrentSize:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCurrentSize(v)
		return nil
	case objectstorage.FieldLast30DayDownload:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLast30DayDownload(v)
		return nil
	case objectstorage.FieldLast30DayAPICallTimes:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLast30DayAPICallTimes(v)
		return nil
	case objectstorage.FieldLastUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastUpdateTime(v)
		return nil
	}
	return fmt.Errorf("unknown ObjectStorage field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ObjectStorageMutation) AddedFields() []string {
	var fields []string
	if m.addsize != nil {
		fields = append(fields, objectstorage.FieldSize)
	}
	if m.addcreate_time != nil {
		fields = append(fields, objectstorage.FieldCreateTime)
	}
	if m.addresource_pool_id != nil {
		fields = append(fields, objectstorage.FieldResourcePoolID)
	}
	if m.addobject_count != nil {
		fields = append(fields, objectstorage.FieldObjectCount)
	}
	if m.addcurrent_size != nil {
		fields = append(fields, objectstorage.FieldCurrentSize)
	}
	if m.addlast30_day_download != nil {
		fields = append(fields, objectstorage.FieldLast30DayDownload)
	}
	if m.addlast30_day_api_call_times != nil {
		fields = append(fields, objectstorage.FieldLast30DayAPICallTimes)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ObjectStorageMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case objectstorage.FieldSize:
		return m.AddedSize()
	case objectstorage.FieldCreateTime:
		return m.AddedCreateTime()
	case objectstorage.FieldResourcePoolID:
		return m.AddedResourcePoolID()
	case objectstorage.FieldObjectCount:
		return m.AddedObjectCount()
	case objectstorage.FieldCurrentSize:
		return m.AddedCurrentSize()
	case objectstorage.FieldLast30DayDownload:
		return m.AddedLast30DayDownload()
	case objectstorage.FieldLast30DayAPICallTimes:
		return m.AddedLast30DayAPICallTimes()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ObjectStorageMutation) AddField(name string, value ent.Value) error {
	switch name {
	case objectstorage.FieldSize:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSize(v)
		return nil
	case objectstorage.FieldCreateTime:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreateTime(v)
		return nil
	case objectstorage.FieldResourcePoolID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddResourcePoolID(v)
		return nil
	case objectstorage.FieldObjectCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddObjectCount(v)
		return nil
	case objectstorage.FieldCurrentSize:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCurrentSize(v)
		return nil
	case objectstorage.FieldLast30DayDownload:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLast30DayDownload(v)
		return nil
	case objectstorage.FieldLast30DayAPICallTimes:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLast30DayAPICallTimes(v)
		return nil
	}
	return fmt.Errorf("unknown ObjectStorage numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ObjectStorageMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(objectstorage.FieldName) {
		fields = append(fields, objectstorage.FieldName)
	}
	if m.FieldCleared(objectstorage.FieldSize) {
		fields = append(fields, objectstorage.FieldSize)
	}
	if m.FieldCleared(objectstorage.FieldStorageType) {
		fields = append(fields, objectstorage.FieldStorageType)
	}
	if m.FieldCleared(objectstorage.FieldRegion) {
		fields = append(fields, objectstorage.FieldRegion)
	}
	if m.FieldCleared(objectstorage.FieldRegionCode) {
		fields = append(fields, objectstorage.FieldRegionCode)
	}
	if m.FieldCleared(objectstorage.FieldAz) {
		fields = append(fields, objectstorage.FieldAz)
	}
	if m.FieldCleared(objectstorage.FieldAzCode) {
		fields = append(fields, objectstorage.FieldAzCode)
	}
	if m.FieldCleared(objectstorage.FieldTenantID) {
		fields = append(fields, objectstorage.FieldTenantID)
	}
	if m.FieldCleared(objectstorage.FieldTenantName) {
		fields = append(fields, objectstorage.FieldTenantName)
	}
	if m.FieldCleared(objectstorage.FieldInnerDomainName) {
		fields = append(fields, objectstorage.FieldInnerDomainName)
	}
	if m.FieldCleared(objectstorage.FieldOuterDomainName) {
		fields = append(fields, objectstorage.FieldOuterDomainName)
	}
	if m.FieldCleared(objectstorage.FieldCreateTime) {
		fields = append(fields, objectstorage.FieldCreateTime)
	}
	if m.FieldCleared(objectstorage.FieldPolicy) {
		fields = append(fields, objectstorage.FieldPolicy)
	}
	if m.FieldCleared(objectstorage.FieldBucketDomains) {
		fields = append(fields, objectstorage.FieldBucketDomains)
	}
	if m.FieldCleared(objectstorage.FieldResourcePoolID) {
		fields = append(fields, objectstorage.FieldResourcePoolID)
	}
	if m.FieldCleared(objectstorage.FieldResourcePoolName) {
		fields = append(fields, objectstorage.FieldResourcePoolName)
	}
	if m.FieldCleared(objectstorage.FieldObjectCount) {
		fields = append(fields, objectstorage.FieldObjectCount)
	}
	if m.FieldCleared(objectstorage.FieldCurrentSize) {
		fields = append(fields, objectstorage.FieldCurrentSize)
	}
	if m.FieldCleared(objectstorage.FieldLast30DayDownload) {
		fields = append(fields, objectstorage.FieldLast30DayDownload)
	}
	if m.FieldCleared(objectstorage.FieldLast30DayAPICallTimes) {
		fields = append(fields, objectstorage.FieldLast30DayAPICallTimes)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ObjectStorageMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ObjectStorageMutation) ClearField(name string) error {
	switch name {
	case objectstorage.FieldName:
		m.ClearName()
		return nil
	case objectstorage.FieldSize:
		m.ClearSize()
		return nil
	case objectstorage.FieldStorageType:
		m.ClearStorageType()
		return nil
	case objectstorage.FieldRegion:
		m.ClearRegion()
		return nil
	case objectstorage.FieldRegionCode:
		m.ClearRegionCode()
		return nil
	case objectstorage.FieldAz:
		m.ClearAz()
		return nil
	case objectstorage.FieldAzCode:
		m.ClearAzCode()
		return nil
	case objectstorage.FieldTenantID:
		m.ClearTenantID()
		return nil
	case objectstorage.FieldTenantName:
		m.ClearTenantName()
		return nil
	case objectstorage.FieldInnerDomainName:
		m.ClearInnerDomainName()
		return nil
	case objectstorage.FieldOuterDomainName:
		m.ClearOuterDomainName()
		return nil
	case objectstorage.FieldCreateTime:
		m.ClearCreateTime()
		return nil
	case objectstorage.FieldPolicy:
		m.ClearPolicy()
		return nil
	case objectstorage.FieldBucketDomains:
		m.ClearBucketDomains()
		return nil
	case objectstorage.FieldResourcePoolID:
		m.ClearResourcePoolID()
		return nil
	case objectstorage.FieldResourcePoolName:
		m.ClearResourcePoolName()
		return nil
	case objectstorage.FieldObjectCount:
		m.ClearObjectCount()
		return nil
	case objectstorage.FieldCurrentSize:
		m.ClearCurrentSize()
		return nil
	case objectstorage.FieldLast30DayDownload:
		m.ClearLast30DayDownload()
		return nil
	case objectstorage.FieldLast30DayAPICallTimes:
		m.ClearLast30DayAPICallTimes()
		return nil
	}
	return fmt.Errorf("unknown ObjectStorage nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ObjectStorageMutation) ResetField(name string) error {
	switch name {
	case objectstorage.FieldName:
		m.ResetName()
		return nil
	case objectstorage.FieldSize:
		m.ResetSize()
		return nil
	case objectstorage.FieldStorageType:
		m.ResetStorageType()
		return nil
	case objectstorage.FieldRegion:
		m.ResetRegion()
		return nil
	case objectstorage.FieldRegionCode:
		m.ResetRegionCode()
		return nil
	case objectstorage.FieldAz:
		m.ResetAz()
		return nil
	case objectstorage.FieldAzCode:
		m.ResetAzCode()
		return nil
	case objectstorage.FieldTenantID:
		m.ResetTenantID()
		return nil
	case objectstorage.FieldTenantName:
		m.ResetTenantName()
		return nil
	case objectstorage.FieldInnerDomainName:
		m.ResetInnerDomainName()
		return nil
	case objectstorage.FieldOuterDomainName:
		m.ResetOuterDomainName()
		return nil
	case objectstorage.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case objectstorage.FieldPolicy:
		m.ResetPolicy()
		return nil
	case objectstorage.FieldBucketDomains:
		m.ResetBucketDomains()
		return nil
	case objectstorage.FieldResourcePoolID:
		m.ResetResourcePoolID()
		return nil
	case objectstorage.FieldResourcePoolName:
		m.ResetResourcePoolName()
		return nil
	case objectstorage.FieldObjectCount:
		m.ResetObjectCount()
		return nil
	case objectstorage.FieldCurrentSize:
		m.ResetCurrentSize()
		return nil
	case objectstorage.FieldLast30DayDownload:
		m.ResetLast30DayDownload()
		return nil
	case objectstorage.FieldLast30DayAPICallTimes:
		m.ResetLast30DayAPICallTimes()
		return nil
	case objectstorage.FieldLastUpdateTime:
		m.ResetLastUpdateTime()
		return nil
	}
	return fmt.Errorf("unknown ObjectStorage field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ObjectStorageMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ObjectStorageMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ObjectStorageMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ObjectStorageMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ObjectStorageMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ObjectStorageMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ObjectStorageMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown ObjectStorage unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ObjectStorageMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown ObjectStorage edge %s", name)
}

// ObjectstorageBucketMutation represents an operation that mutates the ObjectstorageBucket nodes in the graph.
type ObjectstorageBucketMutation struct {
	config
	op                      Op
	typ                     string
	id                      *uint64
	created_at              *time.Time
	updated_at              *time.Time
	version                 *string
	galaxy                  *string
	region                  *string
	deleted                 *bool
	bucket_id               *int
	addbucket_id            *int
	name                    *string
	tenant_id               *string
	tenant_name             *string
	project_id              *string
	project_name            *string
	storageclass            *string
	storageclass_name       *string
	inner_endpoint          *string
	outer_endpoint          *string
	inner_domain            *string
	outer_domain            *string
	pool_id                 *string
	pool_name               *string
	total_storage           *int
	addtotal_storage        *int
	add_storage             *int
	addadd_storage          *int
	delete_storage          *int
	adddelete_storage       *int
	total_object            *int
	addtotal_object         *int
	add_object              *int
	addadd_object           *int
	delete_object           *int
	adddelete_object        *int
	download_flow           *int
	adddownload_flow        *int
	upload_flow             *int
	addupload_flow          *int
	request_amount          *int
	addrequest_amount       *int
	download_flow_month     *int
	adddownload_flow_month  *int
	upload_flow_month       *int
	addupload_flow_month    *int
	request_amount_month    *int
	addrequest_amount_month *int
	create_time             *time.Time
	clearedFields           map[string]struct{}
	done                    bool
	oldValue                func(context.Context) (*ObjectstorageBucket, error)
	predicates              []predicate.ObjectstorageBucket
}

var _ ent.Mutation = (*ObjectstorageBucketMutation)(nil)

// objectstoragebucketOption allows management of the mutation configuration using functional options.
type objectstoragebucketOption func(*ObjectstorageBucketMutation)

// newObjectstorageBucketMutation creates new mutation for the ObjectstorageBucket entity.
func newObjectstorageBucketMutation(c config, op Op, opts ...objectstoragebucketOption) *ObjectstorageBucketMutation {
	m := &ObjectstorageBucketMutation{
		config:        c,
		op:            op,
		typ:           TypeObjectstorageBucket,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withObjectstorageBucketID sets the ID field of the mutation.
func withObjectstorageBucketID(id uint64) objectstoragebucketOption {
	return func(m *ObjectstorageBucketMutation) {
		var (
			err   error
			once  sync.Once
			value *ObjectstorageBucket
		)
		m.oldValue = func(ctx context.Context) (*ObjectstorageBucket, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ObjectstorageBucket.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withObjectstorageBucket sets the old ObjectstorageBucket of the mutation.
func withObjectstorageBucket(node *ObjectstorageBucket) objectstoragebucketOption {
	return func(m *ObjectstorageBucketMutation) {
		m.oldValue = func(context.Context) (*ObjectstorageBucket, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ObjectstorageBucketMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ObjectstorageBucketMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ObjectstorageBucket entities.
func (m *ObjectstorageBucketMutation) SetID(id uint64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ObjectstorageBucketMutation) ID() (id uint64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ObjectstorageBucketMutation) IDs(ctx context.Context) ([]uint64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ObjectstorageBucket.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *ObjectstorageBucketMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ObjectstorageBucketMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ObjectstorageBucket entity.
// If the ObjectstorageBucket object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ObjectstorageBucketMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *ObjectstorageBucketMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[objectstoragebucket.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *ObjectstorageBucketMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[objectstoragebucket.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ObjectstorageBucketMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, objectstoragebucket.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ObjectstorageBucketMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ObjectstorageBucketMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ObjectstorageBucket entity.
// If the ObjectstorageBucket object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ObjectstorageBucketMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *ObjectstorageBucketMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[objectstoragebucket.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *ObjectstorageBucketMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[objectstoragebucket.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ObjectstorageBucketMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, objectstoragebucket.FieldUpdatedAt)
}

// SetVersion sets the "version" field.
func (m *ObjectstorageBucketMutation) SetVersion(s string) {
	m.version = &s
}

// Version returns the value of the "version" field in the mutation.
func (m *ObjectstorageBucketMutation) Version() (r string, exists bool) {
	v := m.version
	if v == nil {
		return
	}
	return *v, true
}

// OldVersion returns the old "version" field's value of the ObjectstorageBucket entity.
// If the ObjectstorageBucket object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ObjectstorageBucketMutation) OldVersion(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVersion: %w", err)
	}
	return oldValue.Version, nil
}

// ClearVersion clears the value of the "version" field.
func (m *ObjectstorageBucketMutation) ClearVersion() {
	m.version = nil
	m.clearedFields[objectstoragebucket.FieldVersion] = struct{}{}
}

// VersionCleared returns if the "version" field was cleared in this mutation.
func (m *ObjectstorageBucketMutation) VersionCleared() bool {
	_, ok := m.clearedFields[objectstoragebucket.FieldVersion]
	return ok
}

// ResetVersion resets all changes to the "version" field.
func (m *ObjectstorageBucketMutation) ResetVersion() {
	m.version = nil
	delete(m.clearedFields, objectstoragebucket.FieldVersion)
}

// SetGalaxy sets the "galaxy" field.
func (m *ObjectstorageBucketMutation) SetGalaxy(s string) {
	m.galaxy = &s
}

// Galaxy returns the value of the "galaxy" field in the mutation.
func (m *ObjectstorageBucketMutation) Galaxy() (r string, exists bool) {
	v := m.galaxy
	if v == nil {
		return
	}
	return *v, true
}

// OldGalaxy returns the old "galaxy" field's value of the ObjectstorageBucket entity.
// If the ObjectstorageBucket object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ObjectstorageBucketMutation) OldGalaxy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGalaxy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGalaxy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGalaxy: %w", err)
	}
	return oldValue.Galaxy, nil
}

// ClearGalaxy clears the value of the "galaxy" field.
func (m *ObjectstorageBucketMutation) ClearGalaxy() {
	m.galaxy = nil
	m.clearedFields[objectstoragebucket.FieldGalaxy] = struct{}{}
}

// GalaxyCleared returns if the "galaxy" field was cleared in this mutation.
func (m *ObjectstorageBucketMutation) GalaxyCleared() bool {
	_, ok := m.clearedFields[objectstoragebucket.FieldGalaxy]
	return ok
}

// ResetGalaxy resets all changes to the "galaxy" field.
func (m *ObjectstorageBucketMutation) ResetGalaxy() {
	m.galaxy = nil
	delete(m.clearedFields, objectstoragebucket.FieldGalaxy)
}

// SetRegion sets the "region" field.
func (m *ObjectstorageBucketMutation) SetRegion(s string) {
	m.region = &s
}

// Region returns the value of the "region" field in the mutation.
func (m *ObjectstorageBucketMutation) Region() (r string, exists bool) {
	v := m.region
	if v == nil {
		return
	}
	return *v, true
}

// OldRegion returns the old "region" field's value of the ObjectstorageBucket entity.
// If the ObjectstorageBucket object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ObjectstorageBucketMutation) OldRegion(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRegion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRegion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRegion: %w", err)
	}
	return oldValue.Region, nil
}

// ClearRegion clears the value of the "region" field.
func (m *ObjectstorageBucketMutation) ClearRegion() {
	m.region = nil
	m.clearedFields[objectstoragebucket.FieldRegion] = struct{}{}
}

// RegionCleared returns if the "region" field was cleared in this mutation.
func (m *ObjectstorageBucketMutation) RegionCleared() bool {
	_, ok := m.clearedFields[objectstoragebucket.FieldRegion]
	return ok
}

// ResetRegion resets all changes to the "region" field.
func (m *ObjectstorageBucketMutation) ResetRegion() {
	m.region = nil
	delete(m.clearedFields, objectstoragebucket.FieldRegion)
}

// SetDeleted sets the "deleted" field.
func (m *ObjectstorageBucketMutation) SetDeleted(b bool) {
	m.deleted = &b
}

// Deleted returns the value of the "deleted" field in the mutation.
func (m *ObjectstorageBucketMutation) Deleted() (r bool, exists bool) {
	v := m.deleted
	if v == nil {
		return
	}
	return *v, true
}

// OldDeleted returns the old "deleted" field's value of the ObjectstorageBucket entity.
// If the ObjectstorageBucket object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ObjectstorageBucketMutation) OldDeleted(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeleted is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeleted requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeleted: %w", err)
	}
	return oldValue.Deleted, nil
}

// ClearDeleted clears the value of the "deleted" field.
func (m *ObjectstorageBucketMutation) ClearDeleted() {
	m.deleted = nil
	m.clearedFields[objectstoragebucket.FieldDeleted] = struct{}{}
}

// DeletedCleared returns if the "deleted" field was cleared in this mutation.
func (m *ObjectstorageBucketMutation) DeletedCleared() bool {
	_, ok := m.clearedFields[objectstoragebucket.FieldDeleted]
	return ok
}

// ResetDeleted resets all changes to the "deleted" field.
func (m *ObjectstorageBucketMutation) ResetDeleted() {
	m.deleted = nil
	delete(m.clearedFields, objectstoragebucket.FieldDeleted)
}

// SetBucketID sets the "bucket_id" field.
func (m *ObjectstorageBucketMutation) SetBucketID(i int) {
	m.bucket_id = &i
	m.addbucket_id = nil
}

// BucketID returns the value of the "bucket_id" field in the mutation.
func (m *ObjectstorageBucketMutation) BucketID() (r int, exists bool) {
	v := m.bucket_id
	if v == nil {
		return
	}
	return *v, true
}

// OldBucketID returns the old "bucket_id" field's value of the ObjectstorageBucket entity.
// If the ObjectstorageBucket object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ObjectstorageBucketMutation) OldBucketID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBucketID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBucketID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBucketID: %w", err)
	}
	return oldValue.BucketID, nil
}

// AddBucketID adds i to the "bucket_id" field.
func (m *ObjectstorageBucketMutation) AddBucketID(i int) {
	if m.addbucket_id != nil {
		*m.addbucket_id += i
	} else {
		m.addbucket_id = &i
	}
}

// AddedBucketID returns the value that was added to the "bucket_id" field in this mutation.
func (m *ObjectstorageBucketMutation) AddedBucketID() (r int, exists bool) {
	v := m.addbucket_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetBucketID resets all changes to the "bucket_id" field.
func (m *ObjectstorageBucketMutation) ResetBucketID() {
	m.bucket_id = nil
	m.addbucket_id = nil
}

// SetName sets the "name" field.
func (m *ObjectstorageBucketMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ObjectstorageBucketMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the ObjectstorageBucket entity.
// If the ObjectstorageBucket object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ObjectstorageBucketMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ObjectstorageBucketMutation) ResetName() {
	m.name = nil
}

// SetTenantID sets the "tenant_id" field.
func (m *ObjectstorageBucketMutation) SetTenantID(s string) {
	m.tenant_id = &s
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *ObjectstorageBucketMutation) TenantID() (r string, exists bool) {
	v := m.tenant_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the ObjectstorageBucket entity.
// If the ObjectstorageBucket object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ObjectstorageBucketMutation) OldTenantID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *ObjectstorageBucketMutation) ResetTenantID() {
	m.tenant_id = nil
}

// SetTenantName sets the "tenant_name" field.
func (m *ObjectstorageBucketMutation) SetTenantName(s string) {
	m.tenant_name = &s
}

// TenantName returns the value of the "tenant_name" field in the mutation.
func (m *ObjectstorageBucketMutation) TenantName() (r string, exists bool) {
	v := m.tenant_name
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantName returns the old "tenant_name" field's value of the ObjectstorageBucket entity.
// If the ObjectstorageBucket object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ObjectstorageBucketMutation) OldTenantName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantName: %w", err)
	}
	return oldValue.TenantName, nil
}

// ClearTenantName clears the value of the "tenant_name" field.
func (m *ObjectstorageBucketMutation) ClearTenantName() {
	m.tenant_name = nil
	m.clearedFields[objectstoragebucket.FieldTenantName] = struct{}{}
}

// TenantNameCleared returns if the "tenant_name" field was cleared in this mutation.
func (m *ObjectstorageBucketMutation) TenantNameCleared() bool {
	_, ok := m.clearedFields[objectstoragebucket.FieldTenantName]
	return ok
}

// ResetTenantName resets all changes to the "tenant_name" field.
func (m *ObjectstorageBucketMutation) ResetTenantName() {
	m.tenant_name = nil
	delete(m.clearedFields, objectstoragebucket.FieldTenantName)
}

// SetProjectID sets the "project_id" field.
func (m *ObjectstorageBucketMutation) SetProjectID(s string) {
	m.project_id = &s
}

// ProjectID returns the value of the "project_id" field in the mutation.
func (m *ObjectstorageBucketMutation) ProjectID() (r string, exists bool) {
	v := m.project_id
	if v == nil {
		return
	}
	return *v, true
}

// OldProjectID returns the old "project_id" field's value of the ObjectstorageBucket entity.
// If the ObjectstorageBucket object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ObjectstorageBucketMutation) OldProjectID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProjectID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProjectID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProjectID: %w", err)
	}
	return oldValue.ProjectID, nil
}

// ResetProjectID resets all changes to the "project_id" field.
func (m *ObjectstorageBucketMutation) ResetProjectID() {
	m.project_id = nil
}

// SetProjectName sets the "project_name" field.
func (m *ObjectstorageBucketMutation) SetProjectName(s string) {
	m.project_name = &s
}

// ProjectName returns the value of the "project_name" field in the mutation.
func (m *ObjectstorageBucketMutation) ProjectName() (r string, exists bool) {
	v := m.project_name
	if v == nil {
		return
	}
	return *v, true
}

// OldProjectName returns the old "project_name" field's value of the ObjectstorageBucket entity.
// If the ObjectstorageBucket object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ObjectstorageBucketMutation) OldProjectName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProjectName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProjectName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProjectName: %w", err)
	}
	return oldValue.ProjectName, nil
}

// ResetProjectName resets all changes to the "project_name" field.
func (m *ObjectstorageBucketMutation) ResetProjectName() {
	m.project_name = nil
}

// SetStorageclass sets the "storageclass" field.
func (m *ObjectstorageBucketMutation) SetStorageclass(s string) {
	m.storageclass = &s
}

// Storageclass returns the value of the "storageclass" field in the mutation.
func (m *ObjectstorageBucketMutation) Storageclass() (r string, exists bool) {
	v := m.storageclass
	if v == nil {
		return
	}
	return *v, true
}

// OldStorageclass returns the old "storageclass" field's value of the ObjectstorageBucket entity.
// If the ObjectstorageBucket object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ObjectstorageBucketMutation) OldStorageclass(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStorageclass is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStorageclass requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStorageclass: %w", err)
	}
	return oldValue.Storageclass, nil
}

// ClearStorageclass clears the value of the "storageclass" field.
func (m *ObjectstorageBucketMutation) ClearStorageclass() {
	m.storageclass = nil
	m.clearedFields[objectstoragebucket.FieldStorageclass] = struct{}{}
}

// StorageclassCleared returns if the "storageclass" field was cleared in this mutation.
func (m *ObjectstorageBucketMutation) StorageclassCleared() bool {
	_, ok := m.clearedFields[objectstoragebucket.FieldStorageclass]
	return ok
}

// ResetStorageclass resets all changes to the "storageclass" field.
func (m *ObjectstorageBucketMutation) ResetStorageclass() {
	m.storageclass = nil
	delete(m.clearedFields, objectstoragebucket.FieldStorageclass)
}

// SetStorageclassName sets the "storageclass_name" field.
func (m *ObjectstorageBucketMutation) SetStorageclassName(s string) {
	m.storageclass_name = &s
}

// StorageclassName returns the value of the "storageclass_name" field in the mutation.
func (m *ObjectstorageBucketMutation) StorageclassName() (r string, exists bool) {
	v := m.storageclass_name
	if v == nil {
		return
	}
	return *v, true
}

// OldStorageclassName returns the old "storageclass_name" field's value of the ObjectstorageBucket entity.
// If the ObjectstorageBucket object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ObjectstorageBucketMutation) OldStorageclassName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStorageclassName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStorageclassName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStorageclassName: %w", err)
	}
	return oldValue.StorageclassName, nil
}

// ClearStorageclassName clears the value of the "storageclass_name" field.
func (m *ObjectstorageBucketMutation) ClearStorageclassName() {
	m.storageclass_name = nil
	m.clearedFields[objectstoragebucket.FieldStorageclassName] = struct{}{}
}

// StorageclassNameCleared returns if the "storageclass_name" field was cleared in this mutation.
func (m *ObjectstorageBucketMutation) StorageclassNameCleared() bool {
	_, ok := m.clearedFields[objectstoragebucket.FieldStorageclassName]
	return ok
}

// ResetStorageclassName resets all changes to the "storageclass_name" field.
func (m *ObjectstorageBucketMutation) ResetStorageclassName() {
	m.storageclass_name = nil
	delete(m.clearedFields, objectstoragebucket.FieldStorageclassName)
}

// SetInnerEndpoint sets the "inner_endpoint" field.
func (m *ObjectstorageBucketMutation) SetInnerEndpoint(s string) {
	m.inner_endpoint = &s
}

// InnerEndpoint returns the value of the "inner_endpoint" field in the mutation.
func (m *ObjectstorageBucketMutation) InnerEndpoint() (r string, exists bool) {
	v := m.inner_endpoint
	if v == nil {
		return
	}
	return *v, true
}

// OldInnerEndpoint returns the old "inner_endpoint" field's value of the ObjectstorageBucket entity.
// If the ObjectstorageBucket object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ObjectstorageBucketMutation) OldInnerEndpoint(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInnerEndpoint is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInnerEndpoint requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInnerEndpoint: %w", err)
	}
	return oldValue.InnerEndpoint, nil
}

// ResetInnerEndpoint resets all changes to the "inner_endpoint" field.
func (m *ObjectstorageBucketMutation) ResetInnerEndpoint() {
	m.inner_endpoint = nil
}

// SetOuterEndpoint sets the "outer_endpoint" field.
func (m *ObjectstorageBucketMutation) SetOuterEndpoint(s string) {
	m.outer_endpoint = &s
}

// OuterEndpoint returns the value of the "outer_endpoint" field in the mutation.
func (m *ObjectstorageBucketMutation) OuterEndpoint() (r string, exists bool) {
	v := m.outer_endpoint
	if v == nil {
		return
	}
	return *v, true
}

// OldOuterEndpoint returns the old "outer_endpoint" field's value of the ObjectstorageBucket entity.
// If the ObjectstorageBucket object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ObjectstorageBucketMutation) OldOuterEndpoint(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOuterEndpoint is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOuterEndpoint requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOuterEndpoint: %w", err)
	}
	return oldValue.OuterEndpoint, nil
}

// ResetOuterEndpoint resets all changes to the "outer_endpoint" field.
func (m *ObjectstorageBucketMutation) ResetOuterEndpoint() {
	m.outer_endpoint = nil
}

// SetInnerDomain sets the "inner_domain" field.
func (m *ObjectstorageBucketMutation) SetInnerDomain(s string) {
	m.inner_domain = &s
}

// InnerDomain returns the value of the "inner_domain" field in the mutation.
func (m *ObjectstorageBucketMutation) InnerDomain() (r string, exists bool) {
	v := m.inner_domain
	if v == nil {
		return
	}
	return *v, true
}

// OldInnerDomain returns the old "inner_domain" field's value of the ObjectstorageBucket entity.
// If the ObjectstorageBucket object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ObjectstorageBucketMutation) OldInnerDomain(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInnerDomain is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInnerDomain requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInnerDomain: %w", err)
	}
	return oldValue.InnerDomain, nil
}

// ClearInnerDomain clears the value of the "inner_domain" field.
func (m *ObjectstorageBucketMutation) ClearInnerDomain() {
	m.inner_domain = nil
	m.clearedFields[objectstoragebucket.FieldInnerDomain] = struct{}{}
}

// InnerDomainCleared returns if the "inner_domain" field was cleared in this mutation.
func (m *ObjectstorageBucketMutation) InnerDomainCleared() bool {
	_, ok := m.clearedFields[objectstoragebucket.FieldInnerDomain]
	return ok
}

// ResetInnerDomain resets all changes to the "inner_domain" field.
func (m *ObjectstorageBucketMutation) ResetInnerDomain() {
	m.inner_domain = nil
	delete(m.clearedFields, objectstoragebucket.FieldInnerDomain)
}

// SetOuterDomain sets the "outer_domain" field.
func (m *ObjectstorageBucketMutation) SetOuterDomain(s string) {
	m.outer_domain = &s
}

// OuterDomain returns the value of the "outer_domain" field in the mutation.
func (m *ObjectstorageBucketMutation) OuterDomain() (r string, exists bool) {
	v := m.outer_domain
	if v == nil {
		return
	}
	return *v, true
}

// OldOuterDomain returns the old "outer_domain" field's value of the ObjectstorageBucket entity.
// If the ObjectstorageBucket object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ObjectstorageBucketMutation) OldOuterDomain(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOuterDomain is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOuterDomain requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOuterDomain: %w", err)
	}
	return oldValue.OuterDomain, nil
}

// ClearOuterDomain clears the value of the "outer_domain" field.
func (m *ObjectstorageBucketMutation) ClearOuterDomain() {
	m.outer_domain = nil
	m.clearedFields[objectstoragebucket.FieldOuterDomain] = struct{}{}
}

// OuterDomainCleared returns if the "outer_domain" field was cleared in this mutation.
func (m *ObjectstorageBucketMutation) OuterDomainCleared() bool {
	_, ok := m.clearedFields[objectstoragebucket.FieldOuterDomain]
	return ok
}

// ResetOuterDomain resets all changes to the "outer_domain" field.
func (m *ObjectstorageBucketMutation) ResetOuterDomain() {
	m.outer_domain = nil
	delete(m.clearedFields, objectstoragebucket.FieldOuterDomain)
}

// SetPoolID sets the "pool_id" field.
func (m *ObjectstorageBucketMutation) SetPoolID(s string) {
	m.pool_id = &s
}

// PoolID returns the value of the "pool_id" field in the mutation.
func (m *ObjectstorageBucketMutation) PoolID() (r string, exists bool) {
	v := m.pool_id
	if v == nil {
		return
	}
	return *v, true
}

// OldPoolID returns the old "pool_id" field's value of the ObjectstorageBucket entity.
// If the ObjectstorageBucket object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ObjectstorageBucketMutation) OldPoolID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPoolID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPoolID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPoolID: %w", err)
	}
	return oldValue.PoolID, nil
}

// ClearPoolID clears the value of the "pool_id" field.
func (m *ObjectstorageBucketMutation) ClearPoolID() {
	m.pool_id = nil
	m.clearedFields[objectstoragebucket.FieldPoolID] = struct{}{}
}

// PoolIDCleared returns if the "pool_id" field was cleared in this mutation.
func (m *ObjectstorageBucketMutation) PoolIDCleared() bool {
	_, ok := m.clearedFields[objectstoragebucket.FieldPoolID]
	return ok
}

// ResetPoolID resets all changes to the "pool_id" field.
func (m *ObjectstorageBucketMutation) ResetPoolID() {
	m.pool_id = nil
	delete(m.clearedFields, objectstoragebucket.FieldPoolID)
}

// SetPoolName sets the "pool_name" field.
func (m *ObjectstorageBucketMutation) SetPoolName(s string) {
	m.pool_name = &s
}

// PoolName returns the value of the "pool_name" field in the mutation.
func (m *ObjectstorageBucketMutation) PoolName() (r string, exists bool) {
	v := m.pool_name
	if v == nil {
		return
	}
	return *v, true
}

// OldPoolName returns the old "pool_name" field's value of the ObjectstorageBucket entity.
// If the ObjectstorageBucket object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ObjectstorageBucketMutation) OldPoolName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPoolName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPoolName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPoolName: %w", err)
	}
	return oldValue.PoolName, nil
}

// ClearPoolName clears the value of the "pool_name" field.
func (m *ObjectstorageBucketMutation) ClearPoolName() {
	m.pool_name = nil
	m.clearedFields[objectstoragebucket.FieldPoolName] = struct{}{}
}

// PoolNameCleared returns if the "pool_name" field was cleared in this mutation.
func (m *ObjectstorageBucketMutation) PoolNameCleared() bool {
	_, ok := m.clearedFields[objectstoragebucket.FieldPoolName]
	return ok
}

// ResetPoolName resets all changes to the "pool_name" field.
func (m *ObjectstorageBucketMutation) ResetPoolName() {
	m.pool_name = nil
	delete(m.clearedFields, objectstoragebucket.FieldPoolName)
}

// SetTotalStorage sets the "total_storage" field.
func (m *ObjectstorageBucketMutation) SetTotalStorage(i int) {
	m.total_storage = &i
	m.addtotal_storage = nil
}

// TotalStorage returns the value of the "total_storage" field in the mutation.
func (m *ObjectstorageBucketMutation) TotalStorage() (r int, exists bool) {
	v := m.total_storage
	if v == nil {
		return
	}
	return *v, true
}

// OldTotalStorage returns the old "total_storage" field's value of the ObjectstorageBucket entity.
// If the ObjectstorageBucket object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ObjectstorageBucketMutation) OldTotalStorage(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTotalStorage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTotalStorage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotalStorage: %w", err)
	}
	return oldValue.TotalStorage, nil
}

// AddTotalStorage adds i to the "total_storage" field.
func (m *ObjectstorageBucketMutation) AddTotalStorage(i int) {
	if m.addtotal_storage != nil {
		*m.addtotal_storage += i
	} else {
		m.addtotal_storage = &i
	}
}

// AddedTotalStorage returns the value that was added to the "total_storage" field in this mutation.
func (m *ObjectstorageBucketMutation) AddedTotalStorage() (r int, exists bool) {
	v := m.addtotal_storage
	if v == nil {
		return
	}
	return *v, true
}

// ClearTotalStorage clears the value of the "total_storage" field.
func (m *ObjectstorageBucketMutation) ClearTotalStorage() {
	m.total_storage = nil
	m.addtotal_storage = nil
	m.clearedFields[objectstoragebucket.FieldTotalStorage] = struct{}{}
}

// TotalStorageCleared returns if the "total_storage" field was cleared in this mutation.
func (m *ObjectstorageBucketMutation) TotalStorageCleared() bool {
	_, ok := m.clearedFields[objectstoragebucket.FieldTotalStorage]
	return ok
}

// ResetTotalStorage resets all changes to the "total_storage" field.
func (m *ObjectstorageBucketMutation) ResetTotalStorage() {
	m.total_storage = nil
	m.addtotal_storage = nil
	delete(m.clearedFields, objectstoragebucket.FieldTotalStorage)
}

// SetAddStorage sets the "add_storage" field.
func (m *ObjectstorageBucketMutation) SetAddStorage(i int) {
	m.add_storage = &i
	m.addadd_storage = nil
}

// AddStorage returns the value of the "add_storage" field in the mutation.
func (m *ObjectstorageBucketMutation) AddStorage() (r int, exists bool) {
	v := m.add_storage
	if v == nil {
		return
	}
	return *v, true
}

// OldAddStorage returns the old "add_storage" field's value of the ObjectstorageBucket entity.
// If the ObjectstorageBucket object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ObjectstorageBucketMutation) OldAddStorage(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAddStorage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAddStorage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAddStorage: %w", err)
	}
	return oldValue.AddStorage, nil
}

// AddAddStorage adds i to the "add_storage" field.
func (m *ObjectstorageBucketMutation) AddAddStorage(i int) {
	if m.addadd_storage != nil {
		*m.addadd_storage += i
	} else {
		m.addadd_storage = &i
	}
}

// AddedAddStorage returns the value that was added to the "add_storage" field in this mutation.
func (m *ObjectstorageBucketMutation) AddedAddStorage() (r int, exists bool) {
	v := m.addadd_storage
	if v == nil {
		return
	}
	return *v, true
}

// ClearAddStorage clears the value of the "add_storage" field.
func (m *ObjectstorageBucketMutation) ClearAddStorage() {
	m.add_storage = nil
	m.addadd_storage = nil
	m.clearedFields[objectstoragebucket.FieldAddStorage] = struct{}{}
}

// AddStorageCleared returns if the "add_storage" field was cleared in this mutation.
func (m *ObjectstorageBucketMutation) AddStorageCleared() bool {
	_, ok := m.clearedFields[objectstoragebucket.FieldAddStorage]
	return ok
}

// ResetAddStorage resets all changes to the "add_storage" field.
func (m *ObjectstorageBucketMutation) ResetAddStorage() {
	m.add_storage = nil
	m.addadd_storage = nil
	delete(m.clearedFields, objectstoragebucket.FieldAddStorage)
}

// SetDeleteStorage sets the "delete_storage" field.
func (m *ObjectstorageBucketMutation) SetDeleteStorage(i int) {
	m.delete_storage = &i
	m.adddelete_storage = nil
}

// DeleteStorage returns the value of the "delete_storage" field in the mutation.
func (m *ObjectstorageBucketMutation) DeleteStorage() (r int, exists bool) {
	v := m.delete_storage
	if v == nil {
		return
	}
	return *v, true
}

// OldDeleteStorage returns the old "delete_storage" field's value of the ObjectstorageBucket entity.
// If the ObjectstorageBucket object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ObjectstorageBucketMutation) OldDeleteStorage(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeleteStorage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeleteStorage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeleteStorage: %w", err)
	}
	return oldValue.DeleteStorage, nil
}

// AddDeleteStorage adds i to the "delete_storage" field.
func (m *ObjectstorageBucketMutation) AddDeleteStorage(i int) {
	if m.adddelete_storage != nil {
		*m.adddelete_storage += i
	} else {
		m.adddelete_storage = &i
	}
}

// AddedDeleteStorage returns the value that was added to the "delete_storage" field in this mutation.
func (m *ObjectstorageBucketMutation) AddedDeleteStorage() (r int, exists bool) {
	v := m.adddelete_storage
	if v == nil {
		return
	}
	return *v, true
}

// ClearDeleteStorage clears the value of the "delete_storage" field.
func (m *ObjectstorageBucketMutation) ClearDeleteStorage() {
	m.delete_storage = nil
	m.adddelete_storage = nil
	m.clearedFields[objectstoragebucket.FieldDeleteStorage] = struct{}{}
}

// DeleteStorageCleared returns if the "delete_storage" field was cleared in this mutation.
func (m *ObjectstorageBucketMutation) DeleteStorageCleared() bool {
	_, ok := m.clearedFields[objectstoragebucket.FieldDeleteStorage]
	return ok
}

// ResetDeleteStorage resets all changes to the "delete_storage" field.
func (m *ObjectstorageBucketMutation) ResetDeleteStorage() {
	m.delete_storage = nil
	m.adddelete_storage = nil
	delete(m.clearedFields, objectstoragebucket.FieldDeleteStorage)
}

// SetTotalObject sets the "total_object" field.
func (m *ObjectstorageBucketMutation) SetTotalObject(i int) {
	m.total_object = &i
	m.addtotal_object = nil
}

// TotalObject returns the value of the "total_object" field in the mutation.
func (m *ObjectstorageBucketMutation) TotalObject() (r int, exists bool) {
	v := m.total_object
	if v == nil {
		return
	}
	return *v, true
}

// OldTotalObject returns the old "total_object" field's value of the ObjectstorageBucket entity.
// If the ObjectstorageBucket object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ObjectstorageBucketMutation) OldTotalObject(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTotalObject is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTotalObject requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotalObject: %w", err)
	}
	return oldValue.TotalObject, nil
}

// AddTotalObject adds i to the "total_object" field.
func (m *ObjectstorageBucketMutation) AddTotalObject(i int) {
	if m.addtotal_object != nil {
		*m.addtotal_object += i
	} else {
		m.addtotal_object = &i
	}
}

// AddedTotalObject returns the value that was added to the "total_object" field in this mutation.
func (m *ObjectstorageBucketMutation) AddedTotalObject() (r int, exists bool) {
	v := m.addtotal_object
	if v == nil {
		return
	}
	return *v, true
}

// ClearTotalObject clears the value of the "total_object" field.
func (m *ObjectstorageBucketMutation) ClearTotalObject() {
	m.total_object = nil
	m.addtotal_object = nil
	m.clearedFields[objectstoragebucket.FieldTotalObject] = struct{}{}
}

// TotalObjectCleared returns if the "total_object" field was cleared in this mutation.
func (m *ObjectstorageBucketMutation) TotalObjectCleared() bool {
	_, ok := m.clearedFields[objectstoragebucket.FieldTotalObject]
	return ok
}

// ResetTotalObject resets all changes to the "total_object" field.
func (m *ObjectstorageBucketMutation) ResetTotalObject() {
	m.total_object = nil
	m.addtotal_object = nil
	delete(m.clearedFields, objectstoragebucket.FieldTotalObject)
}

// SetAddObject sets the "add_object" field.
func (m *ObjectstorageBucketMutation) SetAddObject(i int) {
	m.add_object = &i
	m.addadd_object = nil
}

// AddObject returns the value of the "add_object" field in the mutation.
func (m *ObjectstorageBucketMutation) AddObject() (r int, exists bool) {
	v := m.add_object
	if v == nil {
		return
	}
	return *v, true
}

// OldAddObject returns the old "add_object" field's value of the ObjectstorageBucket entity.
// If the ObjectstorageBucket object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ObjectstorageBucketMutation) OldAddObject(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAddObject is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAddObject requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAddObject: %w", err)
	}
	return oldValue.AddObject, nil
}

// AddAddObject adds i to the "add_object" field.
func (m *ObjectstorageBucketMutation) AddAddObject(i int) {
	if m.addadd_object != nil {
		*m.addadd_object += i
	} else {
		m.addadd_object = &i
	}
}

// AddedAddObject returns the value that was added to the "add_object" field in this mutation.
func (m *ObjectstorageBucketMutation) AddedAddObject() (r int, exists bool) {
	v := m.addadd_object
	if v == nil {
		return
	}
	return *v, true
}

// ClearAddObject clears the value of the "add_object" field.
func (m *ObjectstorageBucketMutation) ClearAddObject() {
	m.add_object = nil
	m.addadd_object = nil
	m.clearedFields[objectstoragebucket.FieldAddObject] = struct{}{}
}

// AddObjectCleared returns if the "add_object" field was cleared in this mutation.
func (m *ObjectstorageBucketMutation) AddObjectCleared() bool {
	_, ok := m.clearedFields[objectstoragebucket.FieldAddObject]
	return ok
}

// ResetAddObject resets all changes to the "add_object" field.
func (m *ObjectstorageBucketMutation) ResetAddObject() {
	m.add_object = nil
	m.addadd_object = nil
	delete(m.clearedFields, objectstoragebucket.FieldAddObject)
}

// SetDeleteObject sets the "delete_object" field.
func (m *ObjectstorageBucketMutation) SetDeleteObject(i int) {
	m.delete_object = &i
	m.adddelete_object = nil
}

// DeleteObject returns the value of the "delete_object" field in the mutation.
func (m *ObjectstorageBucketMutation) DeleteObject() (r int, exists bool) {
	v := m.delete_object
	if v == nil {
		return
	}
	return *v, true
}

// OldDeleteObject returns the old "delete_object" field's value of the ObjectstorageBucket entity.
// If the ObjectstorageBucket object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ObjectstorageBucketMutation) OldDeleteObject(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeleteObject is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeleteObject requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeleteObject: %w", err)
	}
	return oldValue.DeleteObject, nil
}

// AddDeleteObject adds i to the "delete_object" field.
func (m *ObjectstorageBucketMutation) AddDeleteObject(i int) {
	if m.adddelete_object != nil {
		*m.adddelete_object += i
	} else {
		m.adddelete_object = &i
	}
}

// AddedDeleteObject returns the value that was added to the "delete_object" field in this mutation.
func (m *ObjectstorageBucketMutation) AddedDeleteObject() (r int, exists bool) {
	v := m.adddelete_object
	if v == nil {
		return
	}
	return *v, true
}

// ClearDeleteObject clears the value of the "delete_object" field.
func (m *ObjectstorageBucketMutation) ClearDeleteObject() {
	m.delete_object = nil
	m.adddelete_object = nil
	m.clearedFields[objectstoragebucket.FieldDeleteObject] = struct{}{}
}

// DeleteObjectCleared returns if the "delete_object" field was cleared in this mutation.
func (m *ObjectstorageBucketMutation) DeleteObjectCleared() bool {
	_, ok := m.clearedFields[objectstoragebucket.FieldDeleteObject]
	return ok
}

// ResetDeleteObject resets all changes to the "delete_object" field.
func (m *ObjectstorageBucketMutation) ResetDeleteObject() {
	m.delete_object = nil
	m.adddelete_object = nil
	delete(m.clearedFields, objectstoragebucket.FieldDeleteObject)
}

// SetDownloadFlow sets the "download_flow" field.
func (m *ObjectstorageBucketMutation) SetDownloadFlow(i int) {
	m.download_flow = &i
	m.adddownload_flow = nil
}

// DownloadFlow returns the value of the "download_flow" field in the mutation.
func (m *ObjectstorageBucketMutation) DownloadFlow() (r int, exists bool) {
	v := m.download_flow
	if v == nil {
		return
	}
	return *v, true
}

// OldDownloadFlow returns the old "download_flow" field's value of the ObjectstorageBucket entity.
// If the ObjectstorageBucket object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ObjectstorageBucketMutation) OldDownloadFlow(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDownloadFlow is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDownloadFlow requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDownloadFlow: %w", err)
	}
	return oldValue.DownloadFlow, nil
}

// AddDownloadFlow adds i to the "download_flow" field.
func (m *ObjectstorageBucketMutation) AddDownloadFlow(i int) {
	if m.adddownload_flow != nil {
		*m.adddownload_flow += i
	} else {
		m.adddownload_flow = &i
	}
}

// AddedDownloadFlow returns the value that was added to the "download_flow" field in this mutation.
func (m *ObjectstorageBucketMutation) AddedDownloadFlow() (r int, exists bool) {
	v := m.adddownload_flow
	if v == nil {
		return
	}
	return *v, true
}

// ClearDownloadFlow clears the value of the "download_flow" field.
func (m *ObjectstorageBucketMutation) ClearDownloadFlow() {
	m.download_flow = nil
	m.adddownload_flow = nil
	m.clearedFields[objectstoragebucket.FieldDownloadFlow] = struct{}{}
}

// DownloadFlowCleared returns if the "download_flow" field was cleared in this mutation.
func (m *ObjectstorageBucketMutation) DownloadFlowCleared() bool {
	_, ok := m.clearedFields[objectstoragebucket.FieldDownloadFlow]
	return ok
}

// ResetDownloadFlow resets all changes to the "download_flow" field.
func (m *ObjectstorageBucketMutation) ResetDownloadFlow() {
	m.download_flow = nil
	m.adddownload_flow = nil
	delete(m.clearedFields, objectstoragebucket.FieldDownloadFlow)
}

// SetUploadFlow sets the "upload_flow" field.
func (m *ObjectstorageBucketMutation) SetUploadFlow(i int) {
	m.upload_flow = &i
	m.addupload_flow = nil
}

// UploadFlow returns the value of the "upload_flow" field in the mutation.
func (m *ObjectstorageBucketMutation) UploadFlow() (r int, exists bool) {
	v := m.upload_flow
	if v == nil {
		return
	}
	return *v, true
}

// OldUploadFlow returns the old "upload_flow" field's value of the ObjectstorageBucket entity.
// If the ObjectstorageBucket object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ObjectstorageBucketMutation) OldUploadFlow(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUploadFlow is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUploadFlow requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUploadFlow: %w", err)
	}
	return oldValue.UploadFlow, nil
}

// AddUploadFlow adds i to the "upload_flow" field.
func (m *ObjectstorageBucketMutation) AddUploadFlow(i int) {
	if m.addupload_flow != nil {
		*m.addupload_flow += i
	} else {
		m.addupload_flow = &i
	}
}

// AddedUploadFlow returns the value that was added to the "upload_flow" field in this mutation.
func (m *ObjectstorageBucketMutation) AddedUploadFlow() (r int, exists bool) {
	v := m.addupload_flow
	if v == nil {
		return
	}
	return *v, true
}

// ClearUploadFlow clears the value of the "upload_flow" field.
func (m *ObjectstorageBucketMutation) ClearUploadFlow() {
	m.upload_flow = nil
	m.addupload_flow = nil
	m.clearedFields[objectstoragebucket.FieldUploadFlow] = struct{}{}
}

// UploadFlowCleared returns if the "upload_flow" field was cleared in this mutation.
func (m *ObjectstorageBucketMutation) UploadFlowCleared() bool {
	_, ok := m.clearedFields[objectstoragebucket.FieldUploadFlow]
	return ok
}

// ResetUploadFlow resets all changes to the "upload_flow" field.
func (m *ObjectstorageBucketMutation) ResetUploadFlow() {
	m.upload_flow = nil
	m.addupload_flow = nil
	delete(m.clearedFields, objectstoragebucket.FieldUploadFlow)
}

// SetRequestAmount sets the "request_amount" field.
func (m *ObjectstorageBucketMutation) SetRequestAmount(i int) {
	m.request_amount = &i
	m.addrequest_amount = nil
}

// RequestAmount returns the value of the "request_amount" field in the mutation.
func (m *ObjectstorageBucketMutation) RequestAmount() (r int, exists bool) {
	v := m.request_amount
	if v == nil {
		return
	}
	return *v, true
}

// OldRequestAmount returns the old "request_amount" field's value of the ObjectstorageBucket entity.
// If the ObjectstorageBucket object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ObjectstorageBucketMutation) OldRequestAmount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRequestAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRequestAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRequestAmount: %w", err)
	}
	return oldValue.RequestAmount, nil
}

// AddRequestAmount adds i to the "request_amount" field.
func (m *ObjectstorageBucketMutation) AddRequestAmount(i int) {
	if m.addrequest_amount != nil {
		*m.addrequest_amount += i
	} else {
		m.addrequest_amount = &i
	}
}

// AddedRequestAmount returns the value that was added to the "request_amount" field in this mutation.
func (m *ObjectstorageBucketMutation) AddedRequestAmount() (r int, exists bool) {
	v := m.addrequest_amount
	if v == nil {
		return
	}
	return *v, true
}

// ClearRequestAmount clears the value of the "request_amount" field.
func (m *ObjectstorageBucketMutation) ClearRequestAmount() {
	m.request_amount = nil
	m.addrequest_amount = nil
	m.clearedFields[objectstoragebucket.FieldRequestAmount] = struct{}{}
}

// RequestAmountCleared returns if the "request_amount" field was cleared in this mutation.
func (m *ObjectstorageBucketMutation) RequestAmountCleared() bool {
	_, ok := m.clearedFields[objectstoragebucket.FieldRequestAmount]
	return ok
}

// ResetRequestAmount resets all changes to the "request_amount" field.
func (m *ObjectstorageBucketMutation) ResetRequestAmount() {
	m.request_amount = nil
	m.addrequest_amount = nil
	delete(m.clearedFields, objectstoragebucket.FieldRequestAmount)
}

// SetDownloadFlowMonth sets the "download_flow_month" field.
func (m *ObjectstorageBucketMutation) SetDownloadFlowMonth(i int) {
	m.download_flow_month = &i
	m.adddownload_flow_month = nil
}

// DownloadFlowMonth returns the value of the "download_flow_month" field in the mutation.
func (m *ObjectstorageBucketMutation) DownloadFlowMonth() (r int, exists bool) {
	v := m.download_flow_month
	if v == nil {
		return
	}
	return *v, true
}

// OldDownloadFlowMonth returns the old "download_flow_month" field's value of the ObjectstorageBucket entity.
// If the ObjectstorageBucket object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ObjectstorageBucketMutation) OldDownloadFlowMonth(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDownloadFlowMonth is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDownloadFlowMonth requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDownloadFlowMonth: %w", err)
	}
	return oldValue.DownloadFlowMonth, nil
}

// AddDownloadFlowMonth adds i to the "download_flow_month" field.
func (m *ObjectstorageBucketMutation) AddDownloadFlowMonth(i int) {
	if m.adddownload_flow_month != nil {
		*m.adddownload_flow_month += i
	} else {
		m.adddownload_flow_month = &i
	}
}

// AddedDownloadFlowMonth returns the value that was added to the "download_flow_month" field in this mutation.
func (m *ObjectstorageBucketMutation) AddedDownloadFlowMonth() (r int, exists bool) {
	v := m.adddownload_flow_month
	if v == nil {
		return
	}
	return *v, true
}

// ResetDownloadFlowMonth resets all changes to the "download_flow_month" field.
func (m *ObjectstorageBucketMutation) ResetDownloadFlowMonth() {
	m.download_flow_month = nil
	m.adddownload_flow_month = nil
}

// SetUploadFlowMonth sets the "upload_flow_month" field.
func (m *ObjectstorageBucketMutation) SetUploadFlowMonth(i int) {
	m.upload_flow_month = &i
	m.addupload_flow_month = nil
}

// UploadFlowMonth returns the value of the "upload_flow_month" field in the mutation.
func (m *ObjectstorageBucketMutation) UploadFlowMonth() (r int, exists bool) {
	v := m.upload_flow_month
	if v == nil {
		return
	}
	return *v, true
}

// OldUploadFlowMonth returns the old "upload_flow_month" field's value of the ObjectstorageBucket entity.
// If the ObjectstorageBucket object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ObjectstorageBucketMutation) OldUploadFlowMonth(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUploadFlowMonth is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUploadFlowMonth requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUploadFlowMonth: %w", err)
	}
	return oldValue.UploadFlowMonth, nil
}

// AddUploadFlowMonth adds i to the "upload_flow_month" field.
func (m *ObjectstorageBucketMutation) AddUploadFlowMonth(i int) {
	if m.addupload_flow_month != nil {
		*m.addupload_flow_month += i
	} else {
		m.addupload_flow_month = &i
	}
}

// AddedUploadFlowMonth returns the value that was added to the "upload_flow_month" field in this mutation.
func (m *ObjectstorageBucketMutation) AddedUploadFlowMonth() (r int, exists bool) {
	v := m.addupload_flow_month
	if v == nil {
		return
	}
	return *v, true
}

// ResetUploadFlowMonth resets all changes to the "upload_flow_month" field.
func (m *ObjectstorageBucketMutation) ResetUploadFlowMonth() {
	m.upload_flow_month = nil
	m.addupload_flow_month = nil
}

// SetRequestAmountMonth sets the "request_amount_month" field.
func (m *ObjectstorageBucketMutation) SetRequestAmountMonth(i int) {
	m.request_amount_month = &i
	m.addrequest_amount_month = nil
}

// RequestAmountMonth returns the value of the "request_amount_month" field in the mutation.
func (m *ObjectstorageBucketMutation) RequestAmountMonth() (r int, exists bool) {
	v := m.request_amount_month
	if v == nil {
		return
	}
	return *v, true
}

// OldRequestAmountMonth returns the old "request_amount_month" field's value of the ObjectstorageBucket entity.
// If the ObjectstorageBucket object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ObjectstorageBucketMutation) OldRequestAmountMonth(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRequestAmountMonth is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRequestAmountMonth requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRequestAmountMonth: %w", err)
	}
	return oldValue.RequestAmountMonth, nil
}

// AddRequestAmountMonth adds i to the "request_amount_month" field.
func (m *ObjectstorageBucketMutation) AddRequestAmountMonth(i int) {
	if m.addrequest_amount_month != nil {
		*m.addrequest_amount_month += i
	} else {
		m.addrequest_amount_month = &i
	}
}

// AddedRequestAmountMonth returns the value that was added to the "request_amount_month" field in this mutation.
func (m *ObjectstorageBucketMutation) AddedRequestAmountMonth() (r int, exists bool) {
	v := m.addrequest_amount_month
	if v == nil {
		return
	}
	return *v, true
}

// ResetRequestAmountMonth resets all changes to the "request_amount_month" field.
func (m *ObjectstorageBucketMutation) ResetRequestAmountMonth() {
	m.request_amount_month = nil
	m.addrequest_amount_month = nil
}

// SetCreateTime sets the "create_time" field.
func (m *ObjectstorageBucketMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *ObjectstorageBucketMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the ObjectstorageBucket entity.
// If the ObjectstorageBucket object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ObjectstorageBucketMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ClearCreateTime clears the value of the "create_time" field.
func (m *ObjectstorageBucketMutation) ClearCreateTime() {
	m.create_time = nil
	m.clearedFields[objectstoragebucket.FieldCreateTime] = struct{}{}
}

// CreateTimeCleared returns if the "create_time" field was cleared in this mutation.
func (m *ObjectstorageBucketMutation) CreateTimeCleared() bool {
	_, ok := m.clearedFields[objectstoragebucket.FieldCreateTime]
	return ok
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *ObjectstorageBucketMutation) ResetCreateTime() {
	m.create_time = nil
	delete(m.clearedFields, objectstoragebucket.FieldCreateTime)
}

// Where appends a list predicates to the ObjectstorageBucketMutation builder.
func (m *ObjectstorageBucketMutation) Where(ps ...predicate.ObjectstorageBucket) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ObjectstorageBucketMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ObjectstorageBucketMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ObjectstorageBucket, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ObjectstorageBucketMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ObjectstorageBucketMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ObjectstorageBucket).
func (m *ObjectstorageBucketMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ObjectstorageBucketMutation) Fields() []string {
	fields := make([]string, 0, 33)
	if m.created_at != nil {
		fields = append(fields, objectstoragebucket.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, objectstoragebucket.FieldUpdatedAt)
	}
	if m.version != nil {
		fields = append(fields, objectstoragebucket.FieldVersion)
	}
	if m.galaxy != nil {
		fields = append(fields, objectstoragebucket.FieldGalaxy)
	}
	if m.region != nil {
		fields = append(fields, objectstoragebucket.FieldRegion)
	}
	if m.deleted != nil {
		fields = append(fields, objectstoragebucket.FieldDeleted)
	}
	if m.bucket_id != nil {
		fields = append(fields, objectstoragebucket.FieldBucketID)
	}
	if m.name != nil {
		fields = append(fields, objectstoragebucket.FieldName)
	}
	if m.tenant_id != nil {
		fields = append(fields, objectstoragebucket.FieldTenantID)
	}
	if m.tenant_name != nil {
		fields = append(fields, objectstoragebucket.FieldTenantName)
	}
	if m.project_id != nil {
		fields = append(fields, objectstoragebucket.FieldProjectID)
	}
	if m.project_name != nil {
		fields = append(fields, objectstoragebucket.FieldProjectName)
	}
	if m.storageclass != nil {
		fields = append(fields, objectstoragebucket.FieldStorageclass)
	}
	if m.storageclass_name != nil {
		fields = append(fields, objectstoragebucket.FieldStorageclassName)
	}
	if m.inner_endpoint != nil {
		fields = append(fields, objectstoragebucket.FieldInnerEndpoint)
	}
	if m.outer_endpoint != nil {
		fields = append(fields, objectstoragebucket.FieldOuterEndpoint)
	}
	if m.inner_domain != nil {
		fields = append(fields, objectstoragebucket.FieldInnerDomain)
	}
	if m.outer_domain != nil {
		fields = append(fields, objectstoragebucket.FieldOuterDomain)
	}
	if m.pool_id != nil {
		fields = append(fields, objectstoragebucket.FieldPoolID)
	}
	if m.pool_name != nil {
		fields = append(fields, objectstoragebucket.FieldPoolName)
	}
	if m.total_storage != nil {
		fields = append(fields, objectstoragebucket.FieldTotalStorage)
	}
	if m.add_storage != nil {
		fields = append(fields, objectstoragebucket.FieldAddStorage)
	}
	if m.delete_storage != nil {
		fields = append(fields, objectstoragebucket.FieldDeleteStorage)
	}
	if m.total_object != nil {
		fields = append(fields, objectstoragebucket.FieldTotalObject)
	}
	if m.add_object != nil {
		fields = append(fields, objectstoragebucket.FieldAddObject)
	}
	if m.delete_object != nil {
		fields = append(fields, objectstoragebucket.FieldDeleteObject)
	}
	if m.download_flow != nil {
		fields = append(fields, objectstoragebucket.FieldDownloadFlow)
	}
	if m.upload_flow != nil {
		fields = append(fields, objectstoragebucket.FieldUploadFlow)
	}
	if m.request_amount != nil {
		fields = append(fields, objectstoragebucket.FieldRequestAmount)
	}
	if m.download_flow_month != nil {
		fields = append(fields, objectstoragebucket.FieldDownloadFlowMonth)
	}
	if m.upload_flow_month != nil {
		fields = append(fields, objectstoragebucket.FieldUploadFlowMonth)
	}
	if m.request_amount_month != nil {
		fields = append(fields, objectstoragebucket.FieldRequestAmountMonth)
	}
	if m.create_time != nil {
		fields = append(fields, objectstoragebucket.FieldCreateTime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ObjectstorageBucketMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case objectstoragebucket.FieldCreatedAt:
		return m.CreatedAt()
	case objectstoragebucket.FieldUpdatedAt:
		return m.UpdatedAt()
	case objectstoragebucket.FieldVersion:
		return m.Version()
	case objectstoragebucket.FieldGalaxy:
		return m.Galaxy()
	case objectstoragebucket.FieldRegion:
		return m.Region()
	case objectstoragebucket.FieldDeleted:
		return m.Deleted()
	case objectstoragebucket.FieldBucketID:
		return m.BucketID()
	case objectstoragebucket.FieldName:
		return m.Name()
	case objectstoragebucket.FieldTenantID:
		return m.TenantID()
	case objectstoragebucket.FieldTenantName:
		return m.TenantName()
	case objectstoragebucket.FieldProjectID:
		return m.ProjectID()
	case objectstoragebucket.FieldProjectName:
		return m.ProjectName()
	case objectstoragebucket.FieldStorageclass:
		return m.Storageclass()
	case objectstoragebucket.FieldStorageclassName:
		return m.StorageclassName()
	case objectstoragebucket.FieldInnerEndpoint:
		return m.InnerEndpoint()
	case objectstoragebucket.FieldOuterEndpoint:
		return m.OuterEndpoint()
	case objectstoragebucket.FieldInnerDomain:
		return m.InnerDomain()
	case objectstoragebucket.FieldOuterDomain:
		return m.OuterDomain()
	case objectstoragebucket.FieldPoolID:
		return m.PoolID()
	case objectstoragebucket.FieldPoolName:
		return m.PoolName()
	case objectstoragebucket.FieldTotalStorage:
		return m.TotalStorage()
	case objectstoragebucket.FieldAddStorage:
		return m.AddStorage()
	case objectstoragebucket.FieldDeleteStorage:
		return m.DeleteStorage()
	case objectstoragebucket.FieldTotalObject:
		return m.TotalObject()
	case objectstoragebucket.FieldAddObject:
		return m.AddObject()
	case objectstoragebucket.FieldDeleteObject:
		return m.DeleteObject()
	case objectstoragebucket.FieldDownloadFlow:
		return m.DownloadFlow()
	case objectstoragebucket.FieldUploadFlow:
		return m.UploadFlow()
	case objectstoragebucket.FieldRequestAmount:
		return m.RequestAmount()
	case objectstoragebucket.FieldDownloadFlowMonth:
		return m.DownloadFlowMonth()
	case objectstoragebucket.FieldUploadFlowMonth:
		return m.UploadFlowMonth()
	case objectstoragebucket.FieldRequestAmountMonth:
		return m.RequestAmountMonth()
	case objectstoragebucket.FieldCreateTime:
		return m.CreateTime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ObjectstorageBucketMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case objectstoragebucket.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case objectstoragebucket.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case objectstoragebucket.FieldVersion:
		return m.OldVersion(ctx)
	case objectstoragebucket.FieldGalaxy:
		return m.OldGalaxy(ctx)
	case objectstoragebucket.FieldRegion:
		return m.OldRegion(ctx)
	case objectstoragebucket.FieldDeleted:
		return m.OldDeleted(ctx)
	case objectstoragebucket.FieldBucketID:
		return m.OldBucketID(ctx)
	case objectstoragebucket.FieldName:
		return m.OldName(ctx)
	case objectstoragebucket.FieldTenantID:
		return m.OldTenantID(ctx)
	case objectstoragebucket.FieldTenantName:
		return m.OldTenantName(ctx)
	case objectstoragebucket.FieldProjectID:
		return m.OldProjectID(ctx)
	case objectstoragebucket.FieldProjectName:
		return m.OldProjectName(ctx)
	case objectstoragebucket.FieldStorageclass:
		return m.OldStorageclass(ctx)
	case objectstoragebucket.FieldStorageclassName:
		return m.OldStorageclassName(ctx)
	case objectstoragebucket.FieldInnerEndpoint:
		return m.OldInnerEndpoint(ctx)
	case objectstoragebucket.FieldOuterEndpoint:
		return m.OldOuterEndpoint(ctx)
	case objectstoragebucket.FieldInnerDomain:
		return m.OldInnerDomain(ctx)
	case objectstoragebucket.FieldOuterDomain:
		return m.OldOuterDomain(ctx)
	case objectstoragebucket.FieldPoolID:
		return m.OldPoolID(ctx)
	case objectstoragebucket.FieldPoolName:
		return m.OldPoolName(ctx)
	case objectstoragebucket.FieldTotalStorage:
		return m.OldTotalStorage(ctx)
	case objectstoragebucket.FieldAddStorage:
		return m.OldAddStorage(ctx)
	case objectstoragebucket.FieldDeleteStorage:
		return m.OldDeleteStorage(ctx)
	case objectstoragebucket.FieldTotalObject:
		return m.OldTotalObject(ctx)
	case objectstoragebucket.FieldAddObject:
		return m.OldAddObject(ctx)
	case objectstoragebucket.FieldDeleteObject:
		return m.OldDeleteObject(ctx)
	case objectstoragebucket.FieldDownloadFlow:
		return m.OldDownloadFlow(ctx)
	case objectstoragebucket.FieldUploadFlow:
		return m.OldUploadFlow(ctx)
	case objectstoragebucket.FieldRequestAmount:
		return m.OldRequestAmount(ctx)
	case objectstoragebucket.FieldDownloadFlowMonth:
		return m.OldDownloadFlowMonth(ctx)
	case objectstoragebucket.FieldUploadFlowMonth:
		return m.OldUploadFlowMonth(ctx)
	case objectstoragebucket.FieldRequestAmountMonth:
		return m.OldRequestAmountMonth(ctx)
	case objectstoragebucket.FieldCreateTime:
		return m.OldCreateTime(ctx)
	}
	return nil, fmt.Errorf("unknown ObjectstorageBucket field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ObjectstorageBucketMutation) SetField(name string, value ent.Value) error {
	switch name {
	case objectstoragebucket.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case objectstoragebucket.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case objectstoragebucket.FieldVersion:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVersion(v)
		return nil
	case objectstoragebucket.FieldGalaxy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGalaxy(v)
		return nil
	case objectstoragebucket.FieldRegion:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRegion(v)
		return nil
	case objectstoragebucket.FieldDeleted:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeleted(v)
		return nil
	case objectstoragebucket.FieldBucketID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBucketID(v)
		return nil
	case objectstoragebucket.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case objectstoragebucket.FieldTenantID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case objectstoragebucket.FieldTenantName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantName(v)
		return nil
	case objectstoragebucket.FieldProjectID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProjectID(v)
		return nil
	case objectstoragebucket.FieldProjectName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProjectName(v)
		return nil
	case objectstoragebucket.FieldStorageclass:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStorageclass(v)
		return nil
	case objectstoragebucket.FieldStorageclassName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStorageclassName(v)
		return nil
	case objectstoragebucket.FieldInnerEndpoint:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInnerEndpoint(v)
		return nil
	case objectstoragebucket.FieldOuterEndpoint:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOuterEndpoint(v)
		return nil
	case objectstoragebucket.FieldInnerDomain:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInnerDomain(v)
		return nil
	case objectstoragebucket.FieldOuterDomain:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOuterDomain(v)
		return nil
	case objectstoragebucket.FieldPoolID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPoolID(v)
		return nil
	case objectstoragebucket.FieldPoolName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPoolName(v)
		return nil
	case objectstoragebucket.FieldTotalStorage:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotalStorage(v)
		return nil
	case objectstoragebucket.FieldAddStorage:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAddStorage(v)
		return nil
	case objectstoragebucket.FieldDeleteStorage:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeleteStorage(v)
		return nil
	case objectstoragebucket.FieldTotalObject:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotalObject(v)
		return nil
	case objectstoragebucket.FieldAddObject:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAddObject(v)
		return nil
	case objectstoragebucket.FieldDeleteObject:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeleteObject(v)
		return nil
	case objectstoragebucket.FieldDownloadFlow:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDownloadFlow(v)
		return nil
	case objectstoragebucket.FieldUploadFlow:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUploadFlow(v)
		return nil
	case objectstoragebucket.FieldRequestAmount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRequestAmount(v)
		return nil
	case objectstoragebucket.FieldDownloadFlowMonth:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDownloadFlowMonth(v)
		return nil
	case objectstoragebucket.FieldUploadFlowMonth:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUploadFlowMonth(v)
		return nil
	case objectstoragebucket.FieldRequestAmountMonth:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRequestAmountMonth(v)
		return nil
	case objectstoragebucket.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	}
	return fmt.Errorf("unknown ObjectstorageBucket field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ObjectstorageBucketMutation) AddedFields() []string {
	var fields []string
	if m.addbucket_id != nil {
		fields = append(fields, objectstoragebucket.FieldBucketID)
	}
	if m.addtotal_storage != nil {
		fields = append(fields, objectstoragebucket.FieldTotalStorage)
	}
	if m.addadd_storage != nil {
		fields = append(fields, objectstoragebucket.FieldAddStorage)
	}
	if m.adddelete_storage != nil {
		fields = append(fields, objectstoragebucket.FieldDeleteStorage)
	}
	if m.addtotal_object != nil {
		fields = append(fields, objectstoragebucket.FieldTotalObject)
	}
	if m.addadd_object != nil {
		fields = append(fields, objectstoragebucket.FieldAddObject)
	}
	if m.adddelete_object != nil {
		fields = append(fields, objectstoragebucket.FieldDeleteObject)
	}
	if m.adddownload_flow != nil {
		fields = append(fields, objectstoragebucket.FieldDownloadFlow)
	}
	if m.addupload_flow != nil {
		fields = append(fields, objectstoragebucket.FieldUploadFlow)
	}
	if m.addrequest_amount != nil {
		fields = append(fields, objectstoragebucket.FieldRequestAmount)
	}
	if m.adddownload_flow_month != nil {
		fields = append(fields, objectstoragebucket.FieldDownloadFlowMonth)
	}
	if m.addupload_flow_month != nil {
		fields = append(fields, objectstoragebucket.FieldUploadFlowMonth)
	}
	if m.addrequest_amount_month != nil {
		fields = append(fields, objectstoragebucket.FieldRequestAmountMonth)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ObjectstorageBucketMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case objectstoragebucket.FieldBucketID:
		return m.AddedBucketID()
	case objectstoragebucket.FieldTotalStorage:
		return m.AddedTotalStorage()
	case objectstoragebucket.FieldAddStorage:
		return m.AddedAddStorage()
	case objectstoragebucket.FieldDeleteStorage:
		return m.AddedDeleteStorage()
	case objectstoragebucket.FieldTotalObject:
		return m.AddedTotalObject()
	case objectstoragebucket.FieldAddObject:
		return m.AddedAddObject()
	case objectstoragebucket.FieldDeleteObject:
		return m.AddedDeleteObject()
	case objectstoragebucket.FieldDownloadFlow:
		return m.AddedDownloadFlow()
	case objectstoragebucket.FieldUploadFlow:
		return m.AddedUploadFlow()
	case objectstoragebucket.FieldRequestAmount:
		return m.AddedRequestAmount()
	case objectstoragebucket.FieldDownloadFlowMonth:
		return m.AddedDownloadFlowMonth()
	case objectstoragebucket.FieldUploadFlowMonth:
		return m.AddedUploadFlowMonth()
	case objectstoragebucket.FieldRequestAmountMonth:
		return m.AddedRequestAmountMonth()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ObjectstorageBucketMutation) AddField(name string, value ent.Value) error {
	switch name {
	case objectstoragebucket.FieldBucketID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddBucketID(v)
		return nil
	case objectstoragebucket.FieldTotalStorage:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTotalStorage(v)
		return nil
	case objectstoragebucket.FieldAddStorage:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAddStorage(v)
		return nil
	case objectstoragebucket.FieldDeleteStorage:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeleteStorage(v)
		return nil
	case objectstoragebucket.FieldTotalObject:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTotalObject(v)
		return nil
	case objectstoragebucket.FieldAddObject:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAddObject(v)
		return nil
	case objectstoragebucket.FieldDeleteObject:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeleteObject(v)
		return nil
	case objectstoragebucket.FieldDownloadFlow:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDownloadFlow(v)
		return nil
	case objectstoragebucket.FieldUploadFlow:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUploadFlow(v)
		return nil
	case objectstoragebucket.FieldRequestAmount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRequestAmount(v)
		return nil
	case objectstoragebucket.FieldDownloadFlowMonth:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDownloadFlowMonth(v)
		return nil
	case objectstoragebucket.FieldUploadFlowMonth:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUploadFlowMonth(v)
		return nil
	case objectstoragebucket.FieldRequestAmountMonth:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRequestAmountMonth(v)
		return nil
	}
	return fmt.Errorf("unknown ObjectstorageBucket numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ObjectstorageBucketMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(objectstoragebucket.FieldCreatedAt) {
		fields = append(fields, objectstoragebucket.FieldCreatedAt)
	}
	if m.FieldCleared(objectstoragebucket.FieldUpdatedAt) {
		fields = append(fields, objectstoragebucket.FieldUpdatedAt)
	}
	if m.FieldCleared(objectstoragebucket.FieldVersion) {
		fields = append(fields, objectstoragebucket.FieldVersion)
	}
	if m.FieldCleared(objectstoragebucket.FieldGalaxy) {
		fields = append(fields, objectstoragebucket.FieldGalaxy)
	}
	if m.FieldCleared(objectstoragebucket.FieldRegion) {
		fields = append(fields, objectstoragebucket.FieldRegion)
	}
	if m.FieldCleared(objectstoragebucket.FieldDeleted) {
		fields = append(fields, objectstoragebucket.FieldDeleted)
	}
	if m.FieldCleared(objectstoragebucket.FieldTenantName) {
		fields = append(fields, objectstoragebucket.FieldTenantName)
	}
	if m.FieldCleared(objectstoragebucket.FieldStorageclass) {
		fields = append(fields, objectstoragebucket.FieldStorageclass)
	}
	if m.FieldCleared(objectstoragebucket.FieldStorageclassName) {
		fields = append(fields, objectstoragebucket.FieldStorageclassName)
	}
	if m.FieldCleared(objectstoragebucket.FieldInnerDomain) {
		fields = append(fields, objectstoragebucket.FieldInnerDomain)
	}
	if m.FieldCleared(objectstoragebucket.FieldOuterDomain) {
		fields = append(fields, objectstoragebucket.FieldOuterDomain)
	}
	if m.FieldCleared(objectstoragebucket.FieldPoolID) {
		fields = append(fields, objectstoragebucket.FieldPoolID)
	}
	if m.FieldCleared(objectstoragebucket.FieldPoolName) {
		fields = append(fields, objectstoragebucket.FieldPoolName)
	}
	if m.FieldCleared(objectstoragebucket.FieldTotalStorage) {
		fields = append(fields, objectstoragebucket.FieldTotalStorage)
	}
	if m.FieldCleared(objectstoragebucket.FieldAddStorage) {
		fields = append(fields, objectstoragebucket.FieldAddStorage)
	}
	if m.FieldCleared(objectstoragebucket.FieldDeleteStorage) {
		fields = append(fields, objectstoragebucket.FieldDeleteStorage)
	}
	if m.FieldCleared(objectstoragebucket.FieldTotalObject) {
		fields = append(fields, objectstoragebucket.FieldTotalObject)
	}
	if m.FieldCleared(objectstoragebucket.FieldAddObject) {
		fields = append(fields, objectstoragebucket.FieldAddObject)
	}
	if m.FieldCleared(objectstoragebucket.FieldDeleteObject) {
		fields = append(fields, objectstoragebucket.FieldDeleteObject)
	}
	if m.FieldCleared(objectstoragebucket.FieldDownloadFlow) {
		fields = append(fields, objectstoragebucket.FieldDownloadFlow)
	}
	if m.FieldCleared(objectstoragebucket.FieldUploadFlow) {
		fields = append(fields, objectstoragebucket.FieldUploadFlow)
	}
	if m.FieldCleared(objectstoragebucket.FieldRequestAmount) {
		fields = append(fields, objectstoragebucket.FieldRequestAmount)
	}
	if m.FieldCleared(objectstoragebucket.FieldCreateTime) {
		fields = append(fields, objectstoragebucket.FieldCreateTime)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ObjectstorageBucketMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ObjectstorageBucketMutation) ClearField(name string) error {
	switch name {
	case objectstoragebucket.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case objectstoragebucket.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case objectstoragebucket.FieldVersion:
		m.ClearVersion()
		return nil
	case objectstoragebucket.FieldGalaxy:
		m.ClearGalaxy()
		return nil
	case objectstoragebucket.FieldRegion:
		m.ClearRegion()
		return nil
	case objectstoragebucket.FieldDeleted:
		m.ClearDeleted()
		return nil
	case objectstoragebucket.FieldTenantName:
		m.ClearTenantName()
		return nil
	case objectstoragebucket.FieldStorageclass:
		m.ClearStorageclass()
		return nil
	case objectstoragebucket.FieldStorageclassName:
		m.ClearStorageclassName()
		return nil
	case objectstoragebucket.FieldInnerDomain:
		m.ClearInnerDomain()
		return nil
	case objectstoragebucket.FieldOuterDomain:
		m.ClearOuterDomain()
		return nil
	case objectstoragebucket.FieldPoolID:
		m.ClearPoolID()
		return nil
	case objectstoragebucket.FieldPoolName:
		m.ClearPoolName()
		return nil
	case objectstoragebucket.FieldTotalStorage:
		m.ClearTotalStorage()
		return nil
	case objectstoragebucket.FieldAddStorage:
		m.ClearAddStorage()
		return nil
	case objectstoragebucket.FieldDeleteStorage:
		m.ClearDeleteStorage()
		return nil
	case objectstoragebucket.FieldTotalObject:
		m.ClearTotalObject()
		return nil
	case objectstoragebucket.FieldAddObject:
		m.ClearAddObject()
		return nil
	case objectstoragebucket.FieldDeleteObject:
		m.ClearDeleteObject()
		return nil
	case objectstoragebucket.FieldDownloadFlow:
		m.ClearDownloadFlow()
		return nil
	case objectstoragebucket.FieldUploadFlow:
		m.ClearUploadFlow()
		return nil
	case objectstoragebucket.FieldRequestAmount:
		m.ClearRequestAmount()
		return nil
	case objectstoragebucket.FieldCreateTime:
		m.ClearCreateTime()
		return nil
	}
	return fmt.Errorf("unknown ObjectstorageBucket nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ObjectstorageBucketMutation) ResetField(name string) error {
	switch name {
	case objectstoragebucket.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case objectstoragebucket.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case objectstoragebucket.FieldVersion:
		m.ResetVersion()
		return nil
	case objectstoragebucket.FieldGalaxy:
		m.ResetGalaxy()
		return nil
	case objectstoragebucket.FieldRegion:
		m.ResetRegion()
		return nil
	case objectstoragebucket.FieldDeleted:
		m.ResetDeleted()
		return nil
	case objectstoragebucket.FieldBucketID:
		m.ResetBucketID()
		return nil
	case objectstoragebucket.FieldName:
		m.ResetName()
		return nil
	case objectstoragebucket.FieldTenantID:
		m.ResetTenantID()
		return nil
	case objectstoragebucket.FieldTenantName:
		m.ResetTenantName()
		return nil
	case objectstoragebucket.FieldProjectID:
		m.ResetProjectID()
		return nil
	case objectstoragebucket.FieldProjectName:
		m.ResetProjectName()
		return nil
	case objectstoragebucket.FieldStorageclass:
		m.ResetStorageclass()
		return nil
	case objectstoragebucket.FieldStorageclassName:
		m.ResetStorageclassName()
		return nil
	case objectstoragebucket.FieldInnerEndpoint:
		m.ResetInnerEndpoint()
		return nil
	case objectstoragebucket.FieldOuterEndpoint:
		m.ResetOuterEndpoint()
		return nil
	case objectstoragebucket.FieldInnerDomain:
		m.ResetInnerDomain()
		return nil
	case objectstoragebucket.FieldOuterDomain:
		m.ResetOuterDomain()
		return nil
	case objectstoragebucket.FieldPoolID:
		m.ResetPoolID()
		return nil
	case objectstoragebucket.FieldPoolName:
		m.ResetPoolName()
		return nil
	case objectstoragebucket.FieldTotalStorage:
		m.ResetTotalStorage()
		return nil
	case objectstoragebucket.FieldAddStorage:
		m.ResetAddStorage()
		return nil
	case objectstoragebucket.FieldDeleteStorage:
		m.ResetDeleteStorage()
		return nil
	case objectstoragebucket.FieldTotalObject:
		m.ResetTotalObject()
		return nil
	case objectstoragebucket.FieldAddObject:
		m.ResetAddObject()
		return nil
	case objectstoragebucket.FieldDeleteObject:
		m.ResetDeleteObject()
		return nil
	case objectstoragebucket.FieldDownloadFlow:
		m.ResetDownloadFlow()
		return nil
	case objectstoragebucket.FieldUploadFlow:
		m.ResetUploadFlow()
		return nil
	case objectstoragebucket.FieldRequestAmount:
		m.ResetRequestAmount()
		return nil
	case objectstoragebucket.FieldDownloadFlowMonth:
		m.ResetDownloadFlowMonth()
		return nil
	case objectstoragebucket.FieldUploadFlowMonth:
		m.ResetUploadFlowMonth()
		return nil
	case objectstoragebucket.FieldRequestAmountMonth:
		m.ResetRequestAmountMonth()
		return nil
	case objectstoragebucket.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	}
	return fmt.Errorf("unknown ObjectstorageBucket field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ObjectstorageBucketMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ObjectstorageBucketMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ObjectstorageBucketMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ObjectstorageBucketMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ObjectstorageBucketMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ObjectstorageBucketMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ObjectstorageBucketMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown ObjectstorageBucket unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ObjectstorageBucketMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown ObjectstorageBucket edge %s", name)
}

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/data/ent/blockstorage_query.go
```golang
// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"fmt"
	"luban-cmdb-api/data/ent/blockstorage"
	"luban-cmdb-api/data/ent/predicate"
	"math"

	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
	"entgo.io/ent/schema/field"
)

// BlockStorageQuery is the builder for querying BlockStorage entities.
type BlockStorageQuery struct {
	config
	ctx        *QueryContext
	order      []OrderFunc
	inters     []Interceptor
	predicates []predicate.BlockStorage
	// intermediate query (i.e. traversal path).
	sql  *sql.Selector
	path func(context.Context) (*sql.Selector, error)
}

// Where adds a new predicate for the BlockStorageQuery builder.
func (bsq *BlockStorageQuery) Where(ps ...predicate.BlockStorage) *BlockStorageQuery {
	bsq.predicates = append(bsq.predicates, ps...)
	return bsq
}

// Limit the number of records to be returned by this query.
func (bsq *BlockStorageQuery) Limit(limit int) *BlockStorageQuery {
	bsq.ctx.Limit = &limit
	return bsq
}

// Offset to start from.
func (bsq *BlockStorageQuery) Offset(offset int) *BlockStorageQuery {
	bsq.ctx.Offset = &offset
	return bsq
}

// Unique configures the query builder to filter duplicate records on query.
// By default, unique is set to true, and can be disabled using this method.
func (bsq *BlockStorageQuery) Unique(unique bool) *BlockStorageQuery {
	bsq.ctx.Unique = &unique
	return bsq
}

// Order specifies how the records should be ordered.
func (bsq *BlockStorageQuery) Order(o ...OrderFunc) *BlockStorageQuery {
	bsq.order = append(bsq.order, o...)
	return bsq
}

// First returns the first BlockStorage entity from the query.
// Returns a *NotFoundError when no BlockStorage was found.
func (bsq *BlockStorageQuery) First(ctx context.Context) (*BlockStorage, error) {
	nodes, err := bsq.Limit(1).All(setContextOp(ctx, bsq.ctx, "First"))
	if err != nil {
		return nil, err
	}
	if len(nodes) == 0 {
		return nil, &NotFoundError{blockstorage.Label}
	}
	return nodes[0], nil
}

// FirstX is like First, but panics if an error occurs.
func (bsq *BlockStorageQuery) FirstX(ctx context.Context) *BlockStorage {
	node, err := bsq.First(ctx)
	if err != nil && !IsNotFound(err) {
		panic(err)
	}
	return node
}

// FirstID returns the first BlockStorage ID from the query.
// Returns a *NotFoundError when no BlockStorage ID was found.
func (bsq *BlockStorageQuery) FirstID(ctx context.Context) (id int, err error) {
	var ids []int
	if ids, err = bsq.Limit(1).IDs(setContextOp(ctx, bsq.ctx, "FirstID")); err != nil {
		return
	}
	if len(ids) == 0 {
		err = &NotFoundError{blockstorage.Label}
		return
	}
	return ids[0], nil
}

// FirstIDX is like FirstID, but panics if an error occurs.
func (bsq *BlockStorageQuery) FirstIDX(ctx context.Context) int {
	id, err := bsq.FirstID(ctx)
	if err != nil && !IsNotFound(err) {
		panic(err)
	}
	return id
}

// Only returns a single BlockStorage entity found by the query, ensuring it only returns one.
// Returns a *NotSingularError when more than one BlockStorage entity is found.
// Returns a *NotFoundError when no BlockStorage entities are found.
func (bsq *BlockStorageQuery) Only(ctx context.Context) (*BlockStorage, error) {
	nodes, err := bsq.Limit(2).All(setContextOp(ctx, bsq.ctx, "Only"))
	if err != nil {
		return nil, err
	}
	switch len(nodes) {
	case 1:
		return nodes[0], nil
	case 0:
		return nil, &NotFoundError{blockstorage.Label}
	default:
		return nil, &NotSingularError{blockstorage.Label}
	}
}

// OnlyX is like Only, but panics if an error occurs.
func (bsq *BlockStorageQuery) OnlyX(ctx context.Context) *BlockStorage {
	node, err := bsq.Only(ctx)
	if err != nil {
		panic(err)
	}
	return node
}

// OnlyID is like Only, but returns the only BlockStorage ID in the query.
// Returns a *NotSingularError when more than one BlockStorage ID is found.
// Returns a *NotFoundError when no entities are found.
func (bsq *BlockStorageQuery) OnlyID(ctx context.Context) (id int, err error) {
	var ids []int
	if ids, err = bsq.Limit(2).IDs(setContextOp(ctx, bsq.ctx, "OnlyID")); err != nil {
		return
	}
	switch len(ids) {
	case 1:
		id = ids[0]
	case 0:
		err = &NotFoundError{blockstorage.Label}
	default:
		err = &NotSingularError{blockstorage.Label}
	}
	return
}

// OnlyIDX is like OnlyID, but panics if an error occurs.
func (bsq *BlockStorageQuery) OnlyIDX(ctx context.Context) int {
	id, err := bsq.OnlyID(ctx)
	if err != nil {
		panic(err)
	}
	return id
}

// All executes the query and returns a list of BlockStorages.
func (bsq *BlockStorageQuery) All(ctx context.Context) ([]*BlockStorage, error) {
	ctx = setContextOp(ctx, bsq.ctx, "All")
	if err := bsq.prepareQuery(ctx); err != nil {
		return nil, err
	}
	qr := querierAll[[]*BlockStorage, *BlockStorageQuery]()
	return withInterceptors[[]*BlockStorage](ctx, bsq, qr, bsq.inters)
}

// AllX is like All, but panics if an error occurs.
func (bsq *BlockStorageQuery) AllX(ctx context.Context) []*BlockStorage {
	nodes, err := bsq.All(ctx)
	if err != nil {
		panic(err)
	}
	return nodes
}

// IDs executes the query and returns a list of BlockStorage IDs.
func (bsq *BlockStorageQuery) IDs(ctx context.Context) (ids []int, err error) {
	if bsq.ctx.Unique == nil && bsq.path != nil {
		bsq.Unique(true)
	}
	ctx = setContextOp(ctx, bsq.ctx, "IDs")
	if err = bsq.Select(blockstorage.FieldID).Scan(ctx, &ids); err != nil {
		return nil, err
	}
	return ids, nil
}

// IDsX is like IDs, but panics if an error occurs.
func (bsq *BlockStorageQuery) IDsX(ctx context.Context) []int {
	ids, err := bsq.IDs(ctx)
	if err != nil {
		panic(err)
	}
	return ids
}

// Count returns the count of the given query.
func (bsq *BlockStorageQuery) Count(ctx context.Context) (int, error) {
	ctx = setContextOp(ctx, bsq.ctx, "Count")
	if err := bsq.prepareQuery(ctx); err != nil {
		return 0, err
	}
	return withInterceptors[int](ctx, bsq, querierCount[*BlockStorageQuery](), bsq.inters)
}

// CountX is like Count, but panics if an error occurs.
func (bsq *BlockStorageQuery) CountX(ctx context.Context) int {
	count, err := bsq.Count(ctx)
	if err != nil {
		panic(err)
	}
	return count
}

// Exist returns true if the query has elements in the graph.
func (bsq *BlockStorageQuery) Exist(ctx context.Context) (bool, error) {
	ctx = setContextOp(ctx, bsq.ctx, "Exist")
	switch _, err := bsq.FirstID(ctx); {
	case IsNotFound(err):
		return false, nil
	case err != nil:
		return false, fmt.Errorf("ent: check existence: %w", err)
	default:
		return true, nil
	}
}

// ExistX is like Exist, but panics if an error occurs.
func (bsq *BlockStorageQuery) ExistX(ctx context.Context) bool {
	exist, err := bsq.Exist(ctx)
	if err != nil {
		panic(err)
	}
	return exist
}

// Clone returns a duplicate of the BlockStorageQuery builder, including all associated steps. It can be
// used to prepare common query builders and use them differently after the clone is made.
func (bsq *BlockStorageQuery) Clone() *BlockStorageQuery {
	if bsq == nil {
		return nil
	}
	return &BlockStorageQuery{
		config:     bsq.config,
		ctx:        bsq.ctx.Clone(),
		order:      append([]OrderFunc{}, bsq.order...),
		inters:     append([]Interceptor{}, bsq.inters...),
		predicates: append([]predicate.BlockStorage{}, bsq.predicates...),
		// clone intermediate query.
		sql:  bsq.sql.Clone(),
		path: bsq.path,
	}
}

// GroupBy is used to group vertices by one or more fields/columns.
// It is often used with aggregate functions, like: count, max, mean, min, sum.
//
// Example:
//
//	var v []struct {
//		Name string `json:"name,omitempty"`
//		Count int `json:"count,omitempty"`
//	}
//
//	client.BlockStorage.Query().
//		GroupBy(blockstorage.FieldName).
//		Aggregate(ent.Count()).
//		Scan(ctx, &v)
func (bsq *BlockStorageQuery) GroupBy(field string, fields ...string) *BlockStorageGroupBy {
	bsq.ctx.Fields = append([]string{field}, fields...)
	grbuild := &BlockStorageGroupBy{build: bsq}
	grbuild.flds = &bsq.ctx.Fields
	grbuild.label = blockstorage.Label
	grbuild.scan = grbuild.Scan
	return grbuild
}

// Select allows the selection one or more fields/columns for the given query,
// instead of selecting all fields in the entity.
//
// Example:
//
//	var v []struct {
//		Name string `json:"name,omitempty"`
//	}
//
//	client.BlockStorage.Query().
//		Select(blockstorage.FieldName).
//		Scan(ctx, &v)
func (bsq *BlockStorageQuery) Select(fields ...string) *BlockStorageSelect {
	bsq.ctx.Fields = append(bsq.ctx.Fields, fields...)
	sbuild := &BlockStorageSelect{BlockStorageQuery: bsq}
	sbuild.label = blockstorage.Label
	sbuild.flds, sbuild.scan = &bsq.ctx.Fields, sbuild.Scan
	return sbuild
}

// Aggregate returns a BlockStorageSelect configured with the given aggregations.
func (bsq *BlockStorageQuery) Aggregate(fns ...AggregateFunc) *BlockStorageSelect {
	return bsq.Select().Aggregate(fns...)
}

func (bsq *BlockStorageQuery) prepareQuery(ctx context.Context) error {
	for _, inter := range bsq.inters {
		if inter == nil {
			return fmt.Errorf("ent: uninitialized interceptor (forgotten import ent/runtime?)")
		}
		if trv, ok := inter.(Traverser); ok {
			if err := trv.Traverse(ctx, bsq); err != nil {
				return err
			}
		}
	}
	for _, f := range bsq.ctx.Fields {
		if !blockstorage.ValidColumn(f) {
			return &ValidationError{Name: f, err: fmt.Errorf("ent: invalid field %q for query", f)}
		}
	}
	if bsq.path != nil {
		prev, err := bsq.path(ctx)
		if err != nil {
			return err
		}
		bsq.sql = prev
	}
	return nil
}

func (bsq *BlockStorageQuery) sqlAll(ctx context.Context, hooks ...queryHook) ([]*BlockStorage, error) {
	var (
		nodes = []*BlockStorage{}
		_spec = bsq.querySpec()
	)
	_spec.ScanValues = func(columns []string) ([]any, error) {
		return (*BlockStorage).scanValues(nil, columns)
	}
	_spec.Assign = func(columns []string, values []any) error {
		node := &BlockStorage{config: bsq.config}
		nodes = append(nodes, node)
		return node.assignValues(columns, values)
	}
	for i := range hooks {
		hooks[i](ctx, _spec)
	}
	if err := sqlgraph.QueryNodes(ctx, bsq.driver, _spec); err != nil {
		return nil, err
	}
	if len(nodes) == 0 {
		return nodes, nil
	}
	return nodes, nil
}

func (bsq *BlockStorageQuery) sqlCount(ctx context.Context) (int, error) {
	_spec := bsq.querySpec()
	_spec.Node.Columns = bsq.ctx.Fields
	if len(bsq.ctx.Fields) > 0 {
		_spec.Unique = bsq.ctx.Unique != nil && *bsq.ctx.Unique
	}
	return sqlgraph.CountNodes(ctx, bsq.driver, _spec)
}

func (bsq *BlockStorageQuery) querySpec() *sqlgraph.QuerySpec {
	_spec := sqlgraph.NewQuerySpec(blockstorage.Table, blockstorage.Columns, sqlgraph.NewFieldSpec(blockstorage.FieldID, field.TypeInt))
	_spec.From = bsq.sql
	if unique := bsq.ctx.Unique; unique != nil {
		_spec.Unique = *unique
	} else if bsq.path != nil {
		_spec.Unique = true
	}
	if fields := bsq.ctx.Fields; len(fields) > 0 {
		_spec.Node.Columns = make([]string, 0, len(fields))
		_spec.Node.Columns = append(_spec.Node.Columns, blockstorage.FieldID)
		for i := range fields {
			if fields[i] != blockstorage.FieldID {
				_spec.Node.Columns = append(_spec.Node.Columns, fields[i])
			}
		}
	}
	if ps := bsq.predicates; len(ps) > 0 {
		_spec.Predicate = func(selector *sql.Selector) {
			for i := range ps {
				ps[i](selector)
			}
		}
	}
	if limit := bsq.ctx.Limit; limit != nil {
		_spec.Limit = *limit
	}
	if offset := bsq.ctx.Offset; offset != nil {
		_spec.Offset = *offset
	}
	if ps := bsq.order; len(ps) > 0 {
		_spec.Order = func(selector *sql.Selector) {
			for i := range ps {
				ps[i](selector)
			}
		}
	}
	return _spec
}

func (bsq *BlockStorageQuery) sqlQuery(ctx context.Context) *sql.Selector {
	builder := sql.Dialect(bsq.driver.Dialect())
	t1 := builder.Table(blockstorage.Table)
	columns := bsq.ctx.Fields
	if len(columns) == 0 {
		columns = blockstorage.Columns
	}
	selector := builder.Select(t1.Columns(columns...)...).From(t1)
	if bsq.sql != nil {
		selector = bsq.sql
		selector.Select(selector.Columns(columns...)...)
	}
	if bsq.ctx.Unique != nil && *bsq.ctx.Unique {
		selector.Distinct()
	}
	for _, p := range bsq.predicates {
		p(selector)
	}
	for _, p := range bsq.order {
		p(selector)
	}
	if offset := bsq.ctx.Offset; offset != nil {
		// limit is mandatory for offset clause. We start
		// with default value, and override it below if needed.
		selector.Offset(*offset).Limit(math.MaxInt32)
	}
	if limit := bsq.ctx.Limit; limit != nil {
		selector.Limit(*limit)
	}
	return selector
}

// BlockStorageGroupBy is the group-by builder for BlockStorage entities.
type BlockStorageGroupBy struct {
	selector
	build *BlockStorageQuery
}

// Aggregate adds the given aggregation functions to the group-by query.
func (bsgb *BlockStorageGroupBy) Aggregate(fns ...AggregateFunc) *BlockStorageGroupBy {
	bsgb.fns = append(bsgb.fns, fns...)
	return bsgb
}

// Scan applies the selector query and scans the result into the given value.
func (bsgb *BlockStorageGroupBy) Scan(ctx context.Context, v any) error {
	ctx = setContextOp(ctx, bsgb.build.ctx, "GroupBy")
	if err := bsgb.build.prepareQuery(ctx); err != nil {
		return err
	}
	return scanWithInterceptors[*BlockStorageQuery, *BlockStorageGroupBy](ctx, bsgb.build, bsgb, bsgb.build.inters, v)
}

func (bsgb *BlockStorageGroupBy) sqlScan(ctx context.Context, root *BlockStorageQuery, v any) error {
	selector := root.sqlQuery(ctx).Select()
	aggregation := make([]string, 0, len(bsgb.fns))
	for _, fn := range bsgb.fns {
		aggregation = append(aggregation, fn(selector))
	}
	if len(selector.SelectedColumns()) == 0 {
		columns := make([]string, 0, len(*bsgb.flds)+len(bsgb.fns))
		for _, f := range *bsgb.flds {
			columns = append(columns, selector.C(f))
		}
		columns = append(columns, aggregation...)
		selector.Select(columns...)
	}
	selector.GroupBy(selector.Columns(*bsgb.flds...)...)
	if err := selector.Err(); err != nil {
		return err
	}
	rows := &sql.Rows{}
	query, args := selector.Query()
	if err := bsgb.build.driver.Query(ctx, query, args, rows); err != nil {
		return err
	}
	defer rows.Close()
	return sql.ScanSlice(rows, v)
}

// BlockStorageSelect is the builder for selecting fields of BlockStorage entities.
type BlockStorageSelect struct {
	*BlockStorageQuery
	selector
}

// Aggregate adds the given aggregation functions to the selector query.
func (bss *BlockStorageSelect) Aggregate(fns ...AggregateFunc) *BlockStorageSelect {
	bss.fns = append(bss.fns, fns...)
	return bss
}

// Scan applies the selector query and scans the result into the given value.
func (bss *BlockStorageSelect) Scan(ctx context.Context, v any) error {
	ctx = setContextOp(ctx, bss.ctx, "Select")
	if err := bss.prepareQuery(ctx); err != nil {
		return err
	}
	return scanWithInterceptors[*BlockStorageQuery, *BlockStorageSelect](ctx, bss.BlockStorageQuery, bss, bss.inters, v)
}

func (bss *BlockStorageSelect) sqlScan(ctx context.Context, root *BlockStorageQuery, v any) error {
	selector := root.sqlQuery(ctx)
	aggregation := make([]string, 0, len(bss.fns))
	for _, fn := range bss.fns {
		aggregation = append(aggregation, fn(selector))
	}
	switch n := len(*bss.selector.flds); {
	case n == 0 && len(aggregation) > 0:
		selector.Select(aggregation...)
	case n != 0 && len(aggregation) > 0:
		selector.AppendSelect(aggregation...)
	}
	rows := &sql.Rows{}
	query, args := selector.Query()
	if err := bss.driver.Query(ctx, query, args, rows); err != nil {
		return err
	}
	defer rows.Close()
	return sql.ScanSlice(rows, v)
}

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/data/ent/ebsvolume.go
```golang
// Code generated by ent, DO NOT EDIT.

package ent

import (
	"fmt"
	"luban-cmdb-api/data/ent/ebsvolume"
	"strings"
	"time"

	"entgo.io/ent/dialect/sql"
)

// EbsVolume is the model entity for the EbsVolume schema.
type EbsVolume struct {
	config `json:"-"`
	// ID of the ent.
	ID int `json:"id,omitempty"`
	// Galaxy holds the value of the "galaxy" field.
	Galaxy string `json:"galaxy,omitempty"`
	// 区域编码
	Region string `json:"region,omitempty"`
	// Az holds the value of the "az" field.
	Az string `json:"az,omitempty"`
	// 数据创建时间
	CreatedAt time.Time `json:"created_at,omitempty"`
	// UpdatedAt holds the value of the "updated_at" field.
	UpdatedAt time.Time `json:"updated_at,omitempty"`
	// Version holds the value of the "version" field.
	Version string `json:"version,omitempty"`
	// VolumeID holds the value of the "volume_id" field.
	VolumeID string `json:"volume_id,omitempty"`
	// 云硬盘名称
	Name string `json:"name,omitempty"`
	// PoolID holds the value of the "pool_id" field.
	PoolID string `json:"pool_id,omitempty"`
	// 资源池名称
	PoolName string `json:"pool_name,omitempty"`
	// Size holds the value of the "size" field.
	Size int32 `json:"size,omitempty"`
	// 使用状态
	Status string `json:"status,omitempty"`
	// StatusName holds the value of the "status_name" field.
	StatusName string `json:"status_name,omitempty"`
	// VolumeType holds the value of the "volume_type" field.
	VolumeType string `json:"volume_type,omitempty"`
	// 虚机id
	VMID string `json:"vm_id,omitempty"`
	// 虚机名
	VMName string `json:"vm_name,omitempty"`
	// 租户id
	TenantID string `json:"tenant_id,omitempty"`
	// 租户名
	TenantName string `json:"tenant_name,omitempty"`
	// 项目id
	ProjectID string `json:"project_id,omitempty"`
	// 项目名称
	ProjectName string `json:"project_name,omitempty"`
	// 云硬盘创建时间
	CreateTime time.Time `json:"create_time,omitempty"`
	// ServiceEndTime holds the value of the "service_end_time" field.
	ServiceEndTime time.Time `json:"service_end_time,omitempty"`
	// 0 正常 1 删除
	Deleted bool `json:"deleted,omitempty"`
}

// scanValues returns the types for scanning values from sql.Rows.
func (*EbsVolume) scanValues(columns []string) ([]any, error) {
	values := make([]any, len(columns))
	for i := range columns {
		switch columns[i] {
		case ebsvolume.FieldDeleted:
			values[i] = new(sql.NullBool)
		case ebsvolume.FieldID, ebsvolume.FieldSize:
			values[i] = new(sql.NullInt64)
		case ebsvolume.FieldGalaxy, ebsvolume.FieldRegion, ebsvolume.FieldAz, ebsvolume.FieldVersion, ebsvolume.FieldVolumeID, ebsvolume.FieldName, ebsvolume.FieldPoolID, ebsvolume.FieldPoolName, ebsvolume.FieldStatus, ebsvolume.FieldStatusName, ebsvolume.FieldVolumeType, ebsvolume.FieldVMID, ebsvolume.FieldVMName, ebsvolume.FieldTenantID, ebsvolume.FieldTenantName, ebsvolume.FieldProjectID, ebsvolume.FieldProjectName:
			values[i] = new(sql.NullString)
		case ebsvolume.FieldCreatedAt, ebsvolume.FieldUpdatedAt, ebsvolume.FieldCreateTime, ebsvolume.FieldServiceEndTime:
			values[i] = new(sql.NullTime)
		default:
			return nil, fmt.Errorf("unexpected column %q for type EbsVolume", columns[i])
		}
	}
	return values, nil
}

// assignValues assigns the values that were returned from sql.Rows (after scanning)
// to the EbsVolume fields.
func (ev *EbsVolume) assignValues(columns []string, values []any) error {
	if m, n := len(values), len(columns); m < n {
		return fmt.Errorf("mismatch number of scan values: %d != %d", m, n)
	}
	for i := range columns {
		switch columns[i] {
		case ebsvolume.FieldID:
			value, ok := values[i].(*sql.NullInt64)
			if !ok {
				return fmt.Errorf("unexpected type %T for field id", value)
			}
			ev.ID = int(value.Int64)
		case ebsvolume.FieldGalaxy:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field galaxy", values[i])
			} else if value.Valid {
				ev.Galaxy = value.String
			}
		case ebsvolume.FieldRegion:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field region", values[i])
			} else if value.Valid {
				ev.Region = value.String
			}
		case ebsvolume.FieldAz:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field az", values[i])
			} else if value.Valid {
				ev.Az = value.String
			}
		case ebsvolume.FieldCreatedAt:
			if value, ok := values[i].(*sql.NullTime); !ok {
				return fmt.Errorf("unexpected type %T for field created_at", values[i])
			} else if value.Valid {
				ev.CreatedAt = value.Time
			}
		case ebsvolume.FieldUpdatedAt:
			if value, ok := values[i].(*sql.NullTime); !ok {
				return fmt.Errorf("unexpected type %T for field updated_at", values[i])
			} else if value.Valid {
				ev.UpdatedAt = value.Time
			}
		case ebsvolume.FieldVersion:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field version", values[i])
			} else if value.Valid {
				ev.Version = value.String
			}
		case ebsvolume.FieldVolumeID:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field volume_id", values[i])
			} else if value.Valid {
				ev.VolumeID = value.String
			}
		case ebsvolume.FieldName:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field name", values[i])
			} else if value.Valid {
				ev.Name = value.String
			}
		case ebsvolume.FieldPoolID:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field pool_id", values[i])
			} else if value.Valid {
				ev.PoolID = value.String
			}
		case ebsvolume.FieldPoolName:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field pool_name", values[i])
			} else if value.Valid {
				ev.PoolName = value.String
			}
		case ebsvolume.FieldSize:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field size", values[i])
			} else if value.Valid {
				ev.Size = int32(value.Int64)
			}
		case ebsvolume.FieldStatus:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field status", values[i])
			} else if value.Valid {
				ev.Status = value.String
			}
		case ebsvolume.FieldStatusName:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field status_name", values[i])
			} else if value.Valid {
				ev.StatusName = value.String
			}
		case ebsvolume.FieldVolumeType:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field volume_type", values[i])
			} else if value.Valid {
				ev.VolumeType = value.String
			}
		case ebsvolume.FieldVMID:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field vm_id", values[i])
			} else if value.Valid {
				ev.VMID = value.String
			}
		case ebsvolume.FieldVMName:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field vm_name", values[i])
			} else if value.Valid {
				ev.VMName = value.String
			}
		case ebsvolume.FieldTenantID:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field tenant_id", values[i])
			} else if value.Valid {
				ev.TenantID = value.String
			}
		case ebsvolume.FieldTenantName:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field tenant_name", values[i])
			} else if value.Valid {
				ev.TenantName = value.String
			}
		case ebsvolume.FieldProjectID:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field project_id", values[i])
			} else if value.Valid {
				ev.ProjectID = value.String
			}
		case ebsvolume.FieldProjectName:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field project_name", values[i])
			} else if value.Valid {
				ev.ProjectName = value.String
			}
		case ebsvolume.FieldCreateTime:
			if value, ok := values[i].(*sql.NullTime); !ok {
				return fmt.Errorf("unexpected type %T for field create_time", values[i])
			} else if value.Valid {
				ev.CreateTime = value.Time
			}
		case ebsvolume.FieldServiceEndTime:
			if value, ok := values[i].(*sql.NullTime); !ok {
				return fmt.Errorf("unexpected type %T for field service_end_time", values[i])
			} else if value.Valid {
				ev.ServiceEndTime = value.Time
			}
		case ebsvolume.FieldDeleted:
			if value, ok := values[i].(*sql.NullBool); !ok {
				return fmt.Errorf("unexpected type %T for field deleted", values[i])
			} else if value.Valid {
				ev.Deleted = value.Bool
			}
		}
	}
	return nil
}

// Update returns a builder for updating this EbsVolume.
// Note that you need to call EbsVolume.Unwrap() before calling this method if this EbsVolume
// was returned from a transaction, and the transaction was committed or rolled back.
func (ev *EbsVolume) Update() *EbsVolumeUpdateOne {
	return NewEbsVolumeClient(ev.config).UpdateOne(ev)
}

// Unwrap unwraps the EbsVolume entity that was returned from a transaction after it was closed,
// so that all future queries will be executed through the driver which created the transaction.
func (ev *EbsVolume) Unwrap() *EbsVolume {
	_tx, ok := ev.config.driver.(*txDriver)
	if !ok {
		panic("ent: EbsVolume is not a transactional entity")
	}
	ev.config.driver = _tx.drv
	return ev
}

// String implements the fmt.Stringer.
func (ev *EbsVolume) String() string {
	var builder strings.Builder
	builder.WriteString("EbsVolume(")
	builder.WriteString(fmt.Sprintf("id=%v, ", ev.ID))
	builder.WriteString("galaxy=")
	builder.WriteString(ev.Galaxy)
	builder.WriteString(", ")
	builder.WriteString("region=")
	builder.WriteString(ev.Region)
	builder.WriteString(", ")
	builder.WriteString("az=")
	builder.WriteString(ev.Az)
	builder.WriteString(", ")
	builder.WriteString("created_at=")
	builder.WriteString(ev.CreatedAt.Format(time.ANSIC))
	builder.WriteString(", ")
	builder.WriteString("updated_at=")
	builder.WriteString(ev.UpdatedAt.Format(time.ANSIC))
	builder.WriteString(", ")
	builder.WriteString("version=")
	builder.WriteString(ev.Version)
	builder.WriteString(", ")
	builder.WriteString("volume_id=")
	builder.WriteString(ev.VolumeID)
	builder.WriteString(", ")
	builder.WriteString("name=")
	builder.WriteString(ev.Name)
	builder.WriteString(", ")
	builder.WriteString("pool_id=")
	builder.WriteString(ev.PoolID)
	builder.WriteString(", ")
	builder.WriteString("pool_name=")
	builder.WriteString(ev.PoolName)
	builder.WriteString(", ")
	builder.WriteString("size=")
	builder.WriteString(fmt.Sprintf("%v", ev.Size))
	builder.WriteString(", ")
	builder.WriteString("status=")
	builder.WriteString(ev.Status)
	builder.WriteString(", ")
	builder.WriteString("status_name=")
	builder.WriteString(ev.StatusName)
	builder.WriteString(", ")
	builder.WriteString("volume_type=")
	builder.WriteString(ev.VolumeType)
	builder.WriteString(", ")
	builder.WriteString("vm_id=")
	builder.WriteString(ev.VMID)
	builder.WriteString(", ")
	builder.WriteString("vm_name=")
	builder.WriteString(ev.VMName)
	builder.WriteString(", ")
	builder.WriteString("tenant_id=")
	builder.WriteString(ev.TenantID)
	builder.WriteString(", ")
	builder.WriteString("tenant_name=")
	builder.WriteString(ev.TenantName)
	builder.WriteString(", ")
	builder.WriteString("project_id=")
	builder.WriteString(ev.ProjectID)
	builder.WriteString(", ")
	builder.WriteString("project_name=")
	builder.WriteString(ev.ProjectName)
	builder.WriteString(", ")
	builder.WriteString("create_time=")
	builder.WriteString(ev.CreateTime.Format(time.ANSIC))
	builder.WriteString(", ")
	builder.WriteString("service_end_time=")
	builder.WriteString(ev.ServiceEndTime.Format(time.ANSIC))
	builder.WriteString(", ")
	builder.WriteString("deleted=")
	builder.WriteString(fmt.Sprintf("%v", ev.Deleted))
	builder.WriteByte(')')
	return builder.String()
}

// EbsVolumes is a parsable slice of EbsVolume.
type EbsVolumes []*EbsVolume

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/data/ent/ent.go
```golang
// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"luban-cmdb-api/data/ent/blockstorage"
	"luban-cmdb-api/data/ent/ebsvolume"
	"luban-cmdb-api/data/ent/objectstorage"
	"luban-cmdb-api/data/ent/objectstoragebucket"
	"reflect"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
)

// ent aliases to avoid import conflicts in user's code.
type (
	Op            = ent.Op
	Hook          = ent.Hook
	Value         = ent.Value
	Query         = ent.Query
	QueryContext  = ent.QueryContext
	Querier       = ent.Querier
	QuerierFunc   = ent.QuerierFunc
	Interceptor   = ent.Interceptor
	InterceptFunc = ent.InterceptFunc
	Traverser     = ent.Traverser
	TraverseFunc  = ent.TraverseFunc
	Policy        = ent.Policy
	Mutator       = ent.Mutator
	Mutation      = ent.Mutation
	MutateFunc    = ent.MutateFunc
)

type clientCtxKey struct{}

// FromContext returns a Client stored inside a context, or nil if there isn't one.
func FromContext(ctx context.Context) *Client {
	c, _ := ctx.Value(clientCtxKey{}).(*Client)
	return c
}

// NewContext returns a new context with the given Client attached.
func NewContext(parent context.Context, c *Client) context.Context {
	return context.WithValue(parent, clientCtxKey{}, c)
}

type txCtxKey struct{}

// TxFromContext returns a Tx stored inside a context, or nil if there isn't one.
func TxFromContext(ctx context.Context) *Tx {
	tx, _ := ctx.Value(txCtxKey{}).(*Tx)
	return tx
}

// NewTxContext returns a new context with the given Tx attached.
func NewTxContext(parent context.Context, tx *Tx) context.Context {
	return context.WithValue(parent, txCtxKey{}, tx)
}

// OrderFunc applies an ordering on the sql selector.
type OrderFunc func(*sql.Selector)

// columnChecker returns a function indicates if the column exists in the given column.
func columnChecker(table string) func(string) error {
	checks := map[string]func(string) bool{
		blockstorage.Table:        blockstorage.ValidColumn,
		ebsvolume.Table:           ebsvolume.ValidColumn,
		objectstorage.Table:       objectstorage.ValidColumn,
		objectstoragebucket.Table: objectstoragebucket.ValidColumn,
	}
	check, ok := checks[table]
	if !ok {
		return func(string) error {
			return fmt.Errorf("unknown table %q", table)
		}
	}
	return func(column string) error {
		if !check(column) {
			return fmt.Errorf("unknown column %q for table %q", column, table)
		}
		return nil
	}
}

// Asc applies the given fields in ASC order.
func Asc(fields ...string) OrderFunc {
	return func(s *sql.Selector) {
		check := columnChecker(s.TableName())
		for _, f := range fields {
			if err := check(f); err != nil {
				s.AddError(&ValidationError{Name: f, err: fmt.Errorf("ent: %w", err)})
			}
			s.OrderBy(sql.Asc(s.C(f)))
		}
	}
}

// Desc applies the given fields in DESC order.
func Desc(fields ...string) OrderFunc {
	return func(s *sql.Selector) {
		check := columnChecker(s.TableName())
		for _, f := range fields {
			if err := check(f); err != nil {
				s.AddError(&ValidationError{Name: f, err: fmt.Errorf("ent: %w", err)})
			}
			s.OrderBy(sql.Desc(s.C(f)))
		}
	}
}

// AggregateFunc applies an aggregation step on the group-by traversal/selector.
type AggregateFunc func(*sql.Selector) string

// As is a pseudo aggregation function for renaming another other functions with custom names. For example:
//
//	GroupBy(field1, field2).
//	Aggregate(ent.As(ent.Sum(field1), "sum_field1"), (ent.As(ent.Sum(field2), "sum_field2")).
//	Scan(ctx, &v)
func As(fn AggregateFunc, end string) AggregateFunc {
	return func(s *sql.Selector) string {
		return sql.As(fn(s), end)
	}
}

// Count applies the "count" aggregation function on each group.
func Count() AggregateFunc {
	return func(s *sql.Selector) string {
		return sql.Count("*")
	}
}

// Max applies the "max" aggregation function on the given field of each group.
func Max(field string) AggregateFunc {
	return func(s *sql.Selector) string {
		check := columnChecker(s.TableName())
		if err := check(field); err != nil {
			s.AddError(&ValidationError{Name: field, err: fmt.Errorf("ent: %w", err)})
			return ""
		}
		return sql.Max(s.C(field))
	}
}

// Mean applies the "mean" aggregation function on the given field of each group.
func Mean(field string) AggregateFunc {
	return func(s *sql.Selector) string {
		check := columnChecker(s.TableName())
		if err := check(field); err != nil {
			s.AddError(&ValidationError{Name: field, err: fmt.Errorf("ent: %w", err)})
			return ""
		}
		return sql.Avg(s.C(field))
	}
}

// Min applies the "min" aggregation function on the given field of each group.
func Min(field string) AggregateFunc {
	return func(s *sql.Selector) string {
		check := columnChecker(s.TableName())
		if err := check(field); err != nil {
			s.AddError(&ValidationError{Name: field, err: fmt.Errorf("ent: %w", err)})
			return ""
		}
		return sql.Min(s.C(field))
	}
}

// Sum applies the "sum" aggregation function on the given field of each group.
func Sum(field string) AggregateFunc {
	return func(s *sql.Selector) string {
		check := columnChecker(s.TableName())
		if err := check(field); err != nil {
			s.AddError(&ValidationError{Name: field, err: fmt.Errorf("ent: %w", err)})
			return ""
		}
		return sql.Sum(s.C(field))
	}
}

// ValidationError returns when validating a field or edge fails.
type ValidationError struct {
	Name string // Field or edge name.
	err  error
}

// Error implements the error interface.
func (e *ValidationError) Error() string {
	return e.err.Error()
}

// Unwrap implements the errors.Wrapper interface.
func (e *ValidationError) Unwrap() error {
	return e.err
}

// IsValidationError returns a boolean indicating whether the error is a validation error.
func IsValidationError(err error) bool {
	if err == nil {
		return false
	}
	var e *ValidationError
	return errors.As(err, &e)
}

// NotFoundError returns when trying to fetch a specific entity and it was not found in the database.
type NotFoundError struct {
	label string
}

// Error implements the error interface.
func (e *NotFoundError) Error() string {
	return "ent: " + e.label + " not found"
}

// IsNotFound returns a boolean indicating whether the error is a not found error.
func IsNotFound(err error) bool {
	if err == nil {
		return false
	}
	var e *NotFoundError
	return errors.As(err, &e)
}

// MaskNotFound masks not found error.
func MaskNotFound(err error) error {
	if IsNotFound(err) {
		return nil
	}
	return err
}

// NotSingularError returns when trying to fetch a singular entity and more then one was found in the database.
type NotSingularError struct {
	label string
}

// Error implements the error interface.
func (e *NotSingularError) Error() string {
	return "ent: " + e.label + " not singular"
}

// IsNotSingular returns a boolean indicating whether the error is a not singular error.
func IsNotSingular(err error) bool {
	if err == nil {
		return false
	}
	var e *NotSingularError
	return errors.As(err, &e)
}

// NotLoadedError returns when trying to get a node that was not loaded by the query.
type NotLoadedError struct {
	edge string
}

// Error implements the error interface.
func (e *NotLoadedError) Error() string {
	return "ent: " + e.edge + " edge was not loaded"
}

// IsNotLoaded returns a boolean indicating whether the error is a not loaded error.
func IsNotLoaded(err error) bool {
	if err == nil {
		return false
	}
	var e *NotLoadedError
	return errors.As(err, &e)
}

// ConstraintError returns when trying to create/update one or more entities and
// one or more of their constraints failed. For example, violation of edge or
// field uniqueness.
type ConstraintError struct {
	msg  string
	wrap error
}

// Error implements the error interface.
func (e ConstraintError) Error() string {
	return "ent: constraint failed: " + e.msg
}

// Unwrap implements the errors.Wrapper interface.
func (e *ConstraintError) Unwrap() error {
	return e.wrap
}

// IsConstraintError returns a boolean indicating whether the error is a constraint failure.
func IsConstraintError(err error) bool {
	if err == nil {
		return false
	}
	var e *ConstraintError
	return errors.As(err, &e)
}

// selector embedded by the different Select/GroupBy builders.
type selector struct {
	label string
	flds  *[]string
	fns   []AggregateFunc
	scan  func(context.Context, any) error
}

// ScanX is like Scan, but panics if an error occurs.
func (s *selector) ScanX(ctx context.Context, v any) {
	if err := s.scan(ctx, v); err != nil {
		panic(err)
	}
}

// Strings returns list of strings from a selector. It is only allowed when selecting one field.
func (s *selector) Strings(ctx context.Context) ([]string, error) {
	if len(*s.flds) > 1 {
		return nil, errors.New("ent: Strings is not achievable when selecting more than 1 field")
	}
	var v []string
	if err := s.scan(ctx, &v); err != nil {
		return nil, err
	}
	return v, nil
}

// StringsX is like Strings, but panics if an error occurs.
func (s *selector) StringsX(ctx context.Context) []string {
	v, err := s.Strings(ctx)
	if err != nil {
		panic(err)
	}
	return v
}

// String returns a single string from a selector. It is only allowed when selecting one field.
func (s *selector) String(ctx context.Context) (_ string, err error) {
	var v []string
	if v, err = s.Strings(ctx); err != nil {
		return
	}
	switch len(v) {
	case 1:
		return v[0], nil
	case 0:
		err = &NotFoundError{s.label}
	default:
		err = fmt.Errorf("ent: Strings returned %d results when one was expected", len(v))
	}
	return
}

// StringX is like String, but panics if an error occurs.
func (s *selector) StringX(ctx context.Context) string {
	v, err := s.String(ctx)
	if err != nil {
		panic(err)
	}
	return v
}

// Ints returns list of ints from a selector. It is only allowed when selecting one field.
func (s *selector) Ints(ctx context.Context) ([]int, error) {
	if len(*s.flds) > 1 {
		return nil, errors.New("ent: Ints is not achievable when selecting more than 1 field")
	}
	var v []int
	if err := s.scan(ctx, &v); err != nil {
		return nil, err
	}
	return v, nil
}

// IntsX is like Ints, but panics if an error occurs.
func (s *selector) IntsX(ctx context.Context) []int {
	v, err := s.Ints(ctx)
	if err != nil {
		panic(err)
	}
	return v
}

// Int returns a single int from a selector. It is only allowed when selecting one field.
func (s *selector) Int(ctx context.Context) (_ int, err error) {
	var v []int
	if v, err = s.Ints(ctx); err != nil {
		return
	}
	switch len(v) {
	case 1:
		return v[0], nil
	case 0:
		err = &NotFoundError{s.label}
	default:
		err = fmt.Errorf("ent: Ints returned %d results when one was expected", len(v))
	}
	return
}

// IntX is like Int, but panics if an error occurs.
func (s *selector) IntX(ctx context.Context) int {
	v, err := s.Int(ctx)
	if err != nil {
		panic(err)
	}
	return v
}

// Float64s returns list of float64s from a selector. It is only allowed when selecting one field.
func (s *selector) Float64s(ctx context.Context) ([]float64, error) {
	if len(*s.flds) > 1 {
		return nil, errors.New("ent: Float64s is not achievable when selecting more than 1 field")
	}
	var v []float64
	if err := s.scan(ctx, &v); err != nil {
		return nil, err
	}
	return v, nil
}

// Float64sX is like Float64s, but panics if an error occurs.
func (s *selector) Float64sX(ctx context.Context) []float64 {
	v, err := s.Float64s(ctx)
	if err != nil {
		panic(err)
	}
	return v
}

// Float64 returns a single float64 from a selector. It is only allowed when selecting one field.
func (s *selector) Float64(ctx context.Context) (_ float64, err error) {
	var v []float64
	if v, err = s.Float64s(ctx); err != nil {
		return
	}
	switch len(v) {
	case 1:
		return v[0], nil
	case 0:
		err = &NotFoundError{s.label}
	default:
		err = fmt.Errorf("ent: Float64s returned %d results when one was expected", len(v))
	}
	return
}

// Float64X is like Float64, but panics if an error occurs.
func (s *selector) Float64X(ctx context.Context) float64 {
	v, err := s.Float64(ctx)
	if err != nil {
		panic(err)
	}
	return v
}

// Bools returns list of bools from a selector. It is only allowed when selecting one field.
func (s *selector) Bools(ctx context.Context) ([]bool, error) {
	if len(*s.flds) > 1 {
		return nil, errors.New("ent: Bools is not achievable when selecting more than 1 field")
	}
	var v []bool
	if err := s.scan(ctx, &v); err != nil {
		return nil, err
	}
	return v, nil
}

// BoolsX is like Bools, but panics if an error occurs.
func (s *selector) BoolsX(ctx context.Context) []bool {
	v, err := s.Bools(ctx)
	if err != nil {
		panic(err)
	}
	return v
}

// Bool returns a single bool from a selector. It is only allowed when selecting one field.
func (s *selector) Bool(ctx context.Context) (_ bool, err error) {
	var v []bool
	if v, err = s.Bools(ctx); err != nil {
		return
	}
	switch len(v) {
	case 1:
		return v[0], nil
	case 0:
		err = &NotFoundError{s.label}
	default:
		err = fmt.Errorf("ent: Bools returned %d results when one was expected", len(v))
	}
	return
}

// BoolX is like Bool, but panics if an error occurs.
func (s *selector) BoolX(ctx context.Context) bool {
	v, err := s.Bool(ctx)
	if err != nil {
		panic(err)
	}
	return v
}

// withHooks invokes the builder operation with the given hooks, if any.
func withHooks[V Value, M any, PM interface {
	*M
	Mutation
}](ctx context.Context, exec func(context.Context) (V, error), mutation PM, hooks []Hook) (value V, err error) {
	if len(hooks) == 0 {
		return exec(ctx)
	}
	var mut Mutator = MutateFunc(func(ctx context.Context, m Mutation) (Value, error) {
		mutationT, ok := m.(PM)
		if !ok {
			return nil, fmt.Errorf("unexpected mutation type %T", m)
		}
		// Set the mutation to the builder.
		*mutation = *mutationT
		return exec(ctx)
	})
	for i := len(hooks) - 1; i >= 0; i-- {
		if hooks[i] == nil {
			return value, fmt.Errorf("ent: uninitialized hook (forgotten import ent/runtime?)")
		}
		mut = hooks[i](mut)
	}
	v, err := mut.Mutate(ctx, mutation)
	if err != nil {
		return value, err
	}
	nv, ok := v.(V)
	if !ok {
		return value, fmt.Errorf("unexpected node type %T returned from %T", v, mutation)
	}
	return nv, nil
}

// setContextOp returns a new context with the given QueryContext attached (including its op) in case it does not exist.
func setContextOp(ctx context.Context, qc *QueryContext, op string) context.Context {
	if ent.QueryFromContext(ctx) == nil {
		qc.Op = op
		ctx = ent.NewQueryContext(ctx, qc)
	}
	return ctx
}

func querierAll[V Value, Q interface {
	sqlAll(context.Context, ...queryHook) (V, error)
}]() Querier {
	return QuerierFunc(func(ctx context.Context, q Query) (Value, error) {
		query, ok := q.(Q)
		if !ok {
			return nil, fmt.Errorf("unexpected query type %T", q)
		}
		return query.sqlAll(ctx)
	})
}

func querierCount[Q interface {
	sqlCount(context.Context) (int, error)
}]() Querier {
	return QuerierFunc(func(ctx context.Context, q Query) (Value, error) {
		query, ok := q.(Q)
		if !ok {
			return nil, fmt.Errorf("unexpected query type %T", q)
		}
		return query.sqlCount(ctx)
	})
}

func withInterceptors[V Value](ctx context.Context, q Query, qr Querier, inters []Interceptor) (v V, err error) {
	for i := len(inters) - 1; i >= 0; i-- {
		qr = inters[i].Intercept(qr)
	}
	rv, err := qr.Query(ctx, q)
	if err != nil {
		return v, err
	}
	vt, ok := rv.(V)
	if !ok {
		return v, fmt.Errorf("unexpected type %T returned from %T. expected type: %T", vt, q, v)
	}
	return vt, nil
}

func scanWithInterceptors[Q1 ent.Query, Q2 interface {
	sqlScan(context.Context, Q1, any) error
}](ctx context.Context, rootQuery Q1, selectOrGroup Q2, inters []Interceptor, v any) error {
	rv := reflect.ValueOf(v)
	var qr Querier = QuerierFunc(func(ctx context.Context, q Query) (Value, error) {
		query, ok := q.(Q1)
		if !ok {
			return nil, fmt.Errorf("unexpected query type %T", q)
		}
		if err := selectOrGroup.sqlScan(ctx, query, v); err != nil {
			return nil, err
		}
		if k := rv.Kind(); k == reflect.Pointer && rv.Elem().CanInterface() {
			return rv.Elem().Interface(), nil
		}
		return v, nil
	})
	for i := len(inters) - 1; i >= 0; i-- {
		qr = inters[i].Intercept(qr)
	}
	vv, err := qr.Query(ctx, rootQuery)
	if err != nil {
		return err
	}
	switch rv2 := reflect.ValueOf(vv); {
	case rv.IsNil(), rv2.IsNil(), rv.Kind() != reflect.Pointer:
	case rv.Type() == rv2.Type():
		rv.Elem().Set(rv2.Elem())
	case rv.Elem().Type() == rv2.Type():
		rv.Elem().Set(rv2)
	}
	return nil
}

// queryHook describes an internal hook for the different sqlAll methods.
type queryHook func(context.Context, *sqlgraph.QuerySpec)

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/data/ent/tx.go
```golang
// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"sync"

	"entgo.io/ent/dialect"
)

// Tx is a transactional client that is created by calling Client.Tx().
type Tx struct {
	config
	// BlockStorage is the client for interacting with the BlockStorage builders.
	BlockStorage *BlockStorageClient
	// EbsVolume is the client for interacting with the EbsVolume builders.
	EbsVolume *EbsVolumeClient
	// ObjectStorage is the client for interacting with the ObjectStorage builders.
	ObjectStorage *ObjectStorageClient
	// ObjectstorageBucket is the client for interacting with the ObjectstorageBucket builders.
	ObjectstorageBucket *ObjectstorageBucketClient

	// lazily loaded.
	client     *Client
	clientOnce sync.Once
	// ctx lives for the life of the transaction. It is
	// the same context used by the underlying connection.
	ctx context.Context
}

type (
	// Committer is the interface that wraps the Commit method.
	Committer interface {
		Commit(context.Context, *Tx) error
	}

	// The CommitFunc type is an adapter to allow the use of ordinary
	// function as a Committer. If f is a function with the appropriate
	// signature, CommitFunc(f) is a Committer that calls f.
	CommitFunc func(context.Context, *Tx) error

	// CommitHook defines the "commit middleware". A function that gets a Committer
	// and returns a Committer. For example:
	//
	//	hook := func(next ent.Committer) ent.Committer {
	//		return ent.CommitFunc(func(ctx context.Context, tx *ent.Tx) error {
	//			// Do some stuff before.
	//			if err := next.Commit(ctx, tx); err != nil {
	//				return err
	//			}
	//			// Do some stuff after.
	//			return nil
	//		})
	//	}
	//
	CommitHook func(Committer) Committer
)

// Commit calls f(ctx, m).
func (f CommitFunc) Commit(ctx context.Context, tx *Tx) error {
	return f(ctx, tx)
}

// Commit commits the transaction.
func (tx *Tx) Commit() error {
	txDriver := tx.config.driver.(*txDriver)
	var fn Committer = CommitFunc(func(context.Context, *Tx) error {
		return txDriver.tx.Commit()
	})
	txDriver.mu.Lock()
	hooks := append([]CommitHook(nil), txDriver.onCommit...)
	txDriver.mu.Unlock()
	for i := len(hooks) - 1; i >= 0; i-- {
		fn = hooks[i](fn)
	}
	return fn.Commit(tx.ctx, tx)
}

// OnCommit adds a hook to call on commit.
func (tx *Tx) OnCommit(f CommitHook) {
	txDriver := tx.config.driver.(*txDriver)
	txDriver.mu.Lock()
	txDriver.onCommit = append(txDriver.onCommit, f)
	txDriver.mu.Unlock()
}

type (
	// Rollbacker is the interface that wraps the Rollback method.
	Rollbacker interface {
		Rollback(context.Context, *Tx) error
	}

	// The RollbackFunc type is an adapter to allow the use of ordinary
	// function as a Rollbacker. If f is a function with the appropriate
	// signature, RollbackFunc(f) is a Rollbacker that calls f.
	RollbackFunc func(context.Context, *Tx) error

	// RollbackHook defines the "rollback middleware". A function that gets a Rollbacker
	// and returns a Rollbacker. For example:
	//
	//	hook := func(next ent.Rollbacker) ent.Rollbacker {
	//		return ent.RollbackFunc(func(ctx context.Context, tx *ent.Tx) error {
	//			// Do some stuff before.
	//			if err := next.Rollback(ctx, tx); err != nil {
	//				return err
	//			}
	//			// Do some stuff after.
	//			return nil
	//		})
	//	}
	//
	RollbackHook func(Rollbacker) Rollbacker
)

// Rollback calls f(ctx, m).
func (f RollbackFunc) Rollback(ctx context.Context, tx *Tx) error {
	return f(ctx, tx)
}

// Rollback rollbacks the transaction.
func (tx *Tx) Rollback() error {
	txDriver := tx.config.driver.(*txDriver)
	var fn Rollbacker = RollbackFunc(func(context.Context, *Tx) error {
		return txDriver.tx.Rollback()
	})
	txDriver.mu.Lock()
	hooks := append([]RollbackHook(nil), txDriver.onRollback...)
	txDriver.mu.Unlock()
	for i := len(hooks) - 1; i >= 0; i-- {
		fn = hooks[i](fn)
	}
	return fn.Rollback(tx.ctx, tx)
}

// OnRollback adds a hook to call on rollback.
func (tx *Tx) OnRollback(f RollbackHook) {
	txDriver := tx.config.driver.(*txDriver)
	txDriver.mu.Lock()
	txDriver.onRollback = append(txDriver.onRollback, f)
	txDriver.mu.Unlock()
}

// Client returns a Client that binds to current transaction.
func (tx *Tx) Client() *Client {
	tx.clientOnce.Do(func() {
		tx.client = &Client{config: tx.config}
		tx.client.init()
	})
	return tx.client
}

func (tx *Tx) init() {
	tx.BlockStorage = NewBlockStorageClient(tx.config)
	tx.EbsVolume = NewEbsVolumeClient(tx.config)
	tx.ObjectStorage = NewObjectStorageClient(tx.config)
	tx.ObjectstorageBucket = NewObjectstorageBucketClient(tx.config)
}

// txDriver wraps the given dialect.Tx with a nop dialect.Driver implementation.
// The idea is to support transactions without adding any extra code to the builders.
// When a builder calls to driver.Tx(), it gets the same dialect.Tx instance.
// Commit and Rollback are nop for the internal builders and the user must call one
// of them in order to commit or rollback the transaction.
//
// If a closed transaction is embedded in one of the generated entities, and the entity
// applies a query, for example: BlockStorage.QueryXXX(), the query will be executed
// through the driver which created this transaction.
//
// Note that txDriver is not goroutine safe.
type txDriver struct {
	// the driver we started the transaction from.
	drv dialect.Driver
	// tx is the underlying transaction.
	tx dialect.Tx
	// completion hooks.
	mu         sync.Mutex
	onCommit   []CommitHook
	onRollback []RollbackHook
}

// newTx creates a new transactional driver.
func newTx(ctx context.Context, drv dialect.Driver) (*txDriver, error) {
	tx, err := drv.Tx(ctx)
	if err != nil {
		return nil, err
	}
	return &txDriver{tx: tx, drv: drv}, nil
}

// Tx returns the transaction wrapper (txDriver) to avoid Commit or Rollback calls
// from the internal builders. Should be called only by the internal builders.
func (tx *txDriver) Tx(context.Context) (dialect.Tx, error) { return tx, nil }

// Dialect returns the dialect of the driver we started the transaction from.
func (tx *txDriver) Dialect() string { return tx.drv.Dialect() }

// Close is a nop close.
func (*txDriver) Close() error { return nil }

// Commit is a nop commit for the internal builders.
// User must call `Tx.Commit` in order to commit the transaction.
func (*txDriver) Commit() error { return nil }

// Rollback is a nop rollback for the internal builders.
// User must call `Tx.Rollback` in order to rollback the transaction.
func (*txDriver) Rollback() error { return nil }

// Exec calls tx.Exec.
func (tx *txDriver) Exec(ctx context.Context, query string, args, v any) error {
	return tx.tx.Exec(ctx, query, args, v)
}

// Query calls tx.Query.
func (tx *txDriver) Query(ctx context.Context, query string, args, v any) error {
	return tx.tx.Query(ctx, query, args, v)
}

var _ dialect.Driver = (*txDriver)(nil)

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/data/ent/objectstoragebucket_query.go
```golang
// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"fmt"
	"luban-cmdb-api/data/ent/objectstoragebucket"
	"luban-cmdb-api/data/ent/predicate"
	"math"

	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
	"entgo.io/ent/schema/field"
)

// ObjectstorageBucketQuery is the builder for querying ObjectstorageBucket entities.
type ObjectstorageBucketQuery struct {
	config
	ctx        *QueryContext
	order      []OrderFunc
	inters     []Interceptor
	predicates []predicate.ObjectstorageBucket
	// intermediate query (i.e. traversal path).
	sql  *sql.Selector
	path func(context.Context) (*sql.Selector, error)
}

// Where adds a new predicate for the ObjectstorageBucketQuery builder.
func (obq *ObjectstorageBucketQuery) Where(ps ...predicate.ObjectstorageBucket) *ObjectstorageBucketQuery {
	obq.predicates = append(obq.predicates, ps...)
	return obq
}

// Limit the number of records to be returned by this query.
func (obq *ObjectstorageBucketQuery) Limit(limit int) *ObjectstorageBucketQuery {
	obq.ctx.Limit = &limit
	return obq
}

// Offset to start from.
func (obq *ObjectstorageBucketQuery) Offset(offset int) *ObjectstorageBucketQuery {
	obq.ctx.Offset = &offset
	return obq
}

// Unique configures the query builder to filter duplicate records on query.
// By default, unique is set to true, and can be disabled using this method.
func (obq *ObjectstorageBucketQuery) Unique(unique bool) *ObjectstorageBucketQuery {
	obq.ctx.Unique = &unique
	return obq
}

// Order specifies how the records should be ordered.
func (obq *ObjectstorageBucketQuery) Order(o ...OrderFunc) *ObjectstorageBucketQuery {
	obq.order = append(obq.order, o...)
	return obq
}

// First returns the first ObjectstorageBucket entity from the query.
// Returns a *NotFoundError when no ObjectstorageBucket was found.
func (obq *ObjectstorageBucketQuery) First(ctx context.Context) (*ObjectstorageBucket, error) {
	nodes, err := obq.Limit(1).All(setContextOp(ctx, obq.ctx, "First"))
	if err != nil {
		return nil, err
	}
	if len(nodes) == 0 {
		return nil, &NotFoundError{objectstoragebucket.Label}
	}
	return nodes[0], nil
}

// FirstX is like First, but panics if an error occurs.
func (obq *ObjectstorageBucketQuery) FirstX(ctx context.Context) *ObjectstorageBucket {
	node, err := obq.First(ctx)
	if err != nil && !IsNotFound(err) {
		panic(err)
	}
	return node
}

// FirstID returns the first ObjectstorageBucket ID from the query.
// Returns a *NotFoundError when no ObjectstorageBucket ID was found.
func (obq *ObjectstorageBucketQuery) FirstID(ctx context.Context) (id uint64, err error) {
	var ids []uint64
	if ids, err = obq.Limit(1).IDs(setContextOp(ctx, obq.ctx, "FirstID")); err != nil {
		return
	}
	if len(ids) == 0 {
		err = &NotFoundError{objectstoragebucket.Label}
		return
	}
	return ids[0], nil
}

// FirstIDX is like FirstID, but panics if an error occurs.
func (obq *ObjectstorageBucketQuery) FirstIDX(ctx context.Context) uint64 {
	id, err := obq.FirstID(ctx)
	if err != nil && !IsNotFound(err) {
		panic(err)
	}
	return id
}

// Only returns a single ObjectstorageBucket entity found by the query, ensuring it only returns one.
// Returns a *NotSingularError when more than one ObjectstorageBucket entity is found.
// Returns a *NotFoundError when no ObjectstorageBucket entities are found.
func (obq *ObjectstorageBucketQuery) Only(ctx context.Context) (*ObjectstorageBucket, error) {
	nodes, err := obq.Limit(2).All(setContextOp(ctx, obq.ctx, "Only"))
	if err != nil {
		return nil, err
	}
	switch len(nodes) {
	case 1:
		return nodes[0], nil
	case 0:
		return nil, &NotFoundError{objectstoragebucket.Label}
	default:
		return nil, &NotSingularError{objectstoragebucket.Label}
	}
}

// OnlyX is like Only, but panics if an error occurs.
func (obq *ObjectstorageBucketQuery) OnlyX(ctx context.Context) *ObjectstorageBucket {
	node, err := obq.Only(ctx)
	if err != nil {
		panic(err)
	}
	return node
}

// OnlyID is like Only, but returns the only ObjectstorageBucket ID in the query.
// Returns a *NotSingularError when more than one ObjectstorageBucket ID is found.
// Returns a *NotFoundError when no entities are found.
func (obq *ObjectstorageBucketQuery) OnlyID(ctx context.Context) (id uint64, err error) {
	var ids []uint64
	if ids, err = obq.Limit(2).IDs(setContextOp(ctx, obq.ctx, "OnlyID")); err != nil {
		return
	}
	switch len(ids) {
	case 1:
		id = ids[0]
	case 0:
		err = &NotFoundError{objectstoragebucket.Label}
	default:
		err = &NotSingularError{objectstoragebucket.Label}
	}
	return
}

// OnlyIDX is like OnlyID, but panics if an error occurs.
func (obq *ObjectstorageBucketQuery) OnlyIDX(ctx context.Context) uint64 {
	id, err := obq.OnlyID(ctx)
	if err != nil {
		panic(err)
	}
	return id
}

// All executes the query and returns a list of ObjectstorageBuckets.
func (obq *ObjectstorageBucketQuery) All(ctx context.Context) ([]*ObjectstorageBucket, error) {
	ctx = setContextOp(ctx, obq.ctx, "All")
	if err := obq.prepareQuery(ctx); err != nil {
		return nil, err
	}
	qr := querierAll[[]*ObjectstorageBucket, *ObjectstorageBucketQuery]()
	return withInterceptors[[]*ObjectstorageBucket](ctx, obq, qr, obq.inters)
}

// AllX is like All, but panics if an error occurs.
func (obq *ObjectstorageBucketQuery) AllX(ctx context.Context) []*ObjectstorageBucket {
	nodes, err := obq.All(ctx)
	if err != nil {
		panic(err)
	}
	return nodes
}

// IDs executes the query and returns a list of ObjectstorageBucket IDs.
func (obq *ObjectstorageBucketQuery) IDs(ctx context.Context) (ids []uint64, err error) {
	if obq.ctx.Unique == nil && obq.path != nil {
		obq.Unique(true)
	}
	ctx = setContextOp(ctx, obq.ctx, "IDs")
	if err = obq.Select(objectstoragebucket.FieldID).Scan(ctx, &ids); err != nil {
		return nil, err
	}
	return ids, nil
}

// IDsX is like IDs, but panics if an error occurs.
func (obq *ObjectstorageBucketQuery) IDsX(ctx context.Context) []uint64 {
	ids, err := obq.IDs(ctx)
	if err != nil {
		panic(err)
	}
	return ids
}

// Count returns the count of the given query.
func (obq *ObjectstorageBucketQuery) Count(ctx context.Context) (int, error) {
	ctx = setContextOp(ctx, obq.ctx, "Count")
	if err := obq.prepareQuery(ctx); err != nil {
		return 0, err
	}
	return withInterceptors[int](ctx, obq, querierCount[*ObjectstorageBucketQuery](), obq.inters)
}

// CountX is like Count, but panics if an error occurs.
func (obq *ObjectstorageBucketQuery) CountX(ctx context.Context) int {
	count, err := obq.Count(ctx)
	if err != nil {
		panic(err)
	}
	return count
}

// Exist returns true if the query has elements in the graph.
func (obq *ObjectstorageBucketQuery) Exist(ctx context.Context) (bool, error) {
	ctx = setContextOp(ctx, obq.ctx, "Exist")
	switch _, err := obq.FirstID(ctx); {
	case IsNotFound(err):
		return false, nil
	case err != nil:
		return false, fmt.Errorf("ent: check existence: %w", err)
	default:
		return true, nil
	}
}

// ExistX is like Exist, but panics if an error occurs.
func (obq *ObjectstorageBucketQuery) ExistX(ctx context.Context) bool {
	exist, err := obq.Exist(ctx)
	if err != nil {
		panic(err)
	}
	return exist
}

// Clone returns a duplicate of the ObjectstorageBucketQuery builder, including all associated steps. It can be
// used to prepare common query builders and use them differently after the clone is made.
func (obq *ObjectstorageBucketQuery) Clone() *ObjectstorageBucketQuery {
	if obq == nil {
		return nil
	}
	return &ObjectstorageBucketQuery{
		config:     obq.config,
		ctx:        obq.ctx.Clone(),
		order:      append([]OrderFunc{}, obq.order...),
		inters:     append([]Interceptor{}, obq.inters...),
		predicates: append([]predicate.ObjectstorageBucket{}, obq.predicates...),
		// clone intermediate query.
		sql:  obq.sql.Clone(),
		path: obq.path,
	}
}

// GroupBy is used to group vertices by one or more fields/columns.
// It is often used with aggregate functions, like: count, max, mean, min, sum.
//
// Example:
//
//	var v []struct {
//		CreatedAt time.Time `json:"created_at,omitempty"`
//		Count int `json:"count,omitempty"`
//	}
//
//	client.ObjectstorageBucket.Query().
//		GroupBy(objectstoragebucket.FieldCreatedAt).
//		Aggregate(ent.Count()).
//		Scan(ctx, &v)
func (obq *ObjectstorageBucketQuery) GroupBy(field string, fields ...string) *ObjectstorageBucketGroupBy {
	obq.ctx.Fields = append([]string{field}, fields...)
	grbuild := &ObjectstorageBucketGroupBy{build: obq}
	grbuild.flds = &obq.ctx.Fields
	grbuild.label = objectstoragebucket.Label
	grbuild.scan = grbuild.Scan
	return grbuild
}

// Select allows the selection one or more fields/columns for the given query,
// instead of selecting all fields in the entity.
//
// Example:
//
//	var v []struct {
//		CreatedAt time.Time `json:"created_at,omitempty"`
//	}
//
//	client.ObjectstorageBucket.Query().
//		Select(objectstoragebucket.FieldCreatedAt).
//		Scan(ctx, &v)
func (obq *ObjectstorageBucketQuery) Select(fields ...string) *ObjectstorageBucketSelect {
	obq.ctx.Fields = append(obq.ctx.Fields, fields...)
	sbuild := &ObjectstorageBucketSelect{ObjectstorageBucketQuery: obq}
	sbuild.label = objectstoragebucket.Label
	sbuild.flds, sbuild.scan = &obq.ctx.Fields, sbuild.Scan
	return sbuild
}

// Aggregate returns a ObjectstorageBucketSelect configured with the given aggregations.
func (obq *ObjectstorageBucketQuery) Aggregate(fns ...AggregateFunc) *ObjectstorageBucketSelect {
	return obq.Select().Aggregate(fns...)
}

func (obq *ObjectstorageBucketQuery) prepareQuery(ctx context.Context) error {
	for _, inter := range obq.inters {
		if inter == nil {
			return fmt.Errorf("ent: uninitialized interceptor (forgotten import ent/runtime?)")
		}
		if trv, ok := inter.(Traverser); ok {
			if err := trv.Traverse(ctx, obq); err != nil {
				return err
			}
		}
	}
	for _, f := range obq.ctx.Fields {
		if !objectstoragebucket.ValidColumn(f) {
			return &ValidationError{Name: f, err: fmt.Errorf("ent: invalid field %q for query", f)}
		}
	}
	if obq.path != nil {
		prev, err := obq.path(ctx)
		if err != nil {
			return err
		}
		obq.sql = prev
	}
	return nil
}

func (obq *ObjectstorageBucketQuery) sqlAll(ctx context.Context, hooks ...queryHook) ([]*ObjectstorageBucket, error) {
	var (
		nodes = []*ObjectstorageBucket{}
		_spec = obq.querySpec()
	)
	_spec.ScanValues = func(columns []string) ([]any, error) {
		return (*ObjectstorageBucket).scanValues(nil, columns)
	}
	_spec.Assign = func(columns []string, values []any) error {
		node := &ObjectstorageBucket{config: obq.config}
		nodes = append(nodes, node)
		return node.assignValues(columns, values)
	}
	for i := range hooks {
		hooks[i](ctx, _spec)
	}
	if err := sqlgraph.QueryNodes(ctx, obq.driver, _spec); err != nil {
		return nil, err
	}
	if len(nodes) == 0 {
		return nodes, nil
	}
	return nodes, nil
}

func (obq *ObjectstorageBucketQuery) sqlCount(ctx context.Context) (int, error) {
	_spec := obq.querySpec()
	_spec.Node.Columns = obq.ctx.Fields
	if len(obq.ctx.Fields) > 0 {
		_spec.Unique = obq.ctx.Unique != nil && *obq.ctx.Unique
	}
	return sqlgraph.CountNodes(ctx, obq.driver, _spec)
}

func (obq *ObjectstorageBucketQuery) querySpec() *sqlgraph.QuerySpec {
	_spec := sqlgraph.NewQuerySpec(objectstoragebucket.Table, objectstoragebucket.Columns, sqlgraph.NewFieldSpec(objectstoragebucket.FieldID, field.TypeUint64))
	_spec.From = obq.sql
	if unique := obq.ctx.Unique; unique != nil {
		_spec.Unique = *unique
	} else if obq.path != nil {
		_spec.Unique = true
	}
	if fields := obq.ctx.Fields; len(fields) > 0 {
		_spec.Node.Columns = make([]string, 0, len(fields))
		_spec.Node.Columns = append(_spec.Node.Columns, objectstoragebucket.FieldID)
		for i := range fields {
			if fields[i] != objectstoragebucket.FieldID {
				_spec.Node.Columns = append(_spec.Node.Columns, fields[i])
			}
		}
	}
	if ps := obq.predicates; len(ps) > 0 {
		_spec.Predicate = func(selector *sql.Selector) {
			for i := range ps {
				ps[i](selector)
			}
		}
	}
	if limit := obq.ctx.Limit; limit != nil {
		_spec.Limit = *limit
	}
	if offset := obq.ctx.Offset; offset != nil {
		_spec.Offset = *offset
	}
	if ps := obq.order; len(ps) > 0 {
		_spec.Order = func(selector *sql.Selector) {
			for i := range ps {
				ps[i](selector)
			}
		}
	}
	return _spec
}

func (obq *ObjectstorageBucketQuery) sqlQuery(ctx context.Context) *sql.Selector {
	builder := sql.Dialect(obq.driver.Dialect())
	t1 := builder.Table(objectstoragebucket.Table)
	columns := obq.ctx.Fields
	if len(columns) == 0 {
		columns = objectstoragebucket.Columns
	}
	selector := builder.Select(t1.Columns(columns...)...).From(t1)
	if obq.sql != nil {
		selector = obq.sql
		selector.Select(selector.Columns(columns...)...)
	}
	if obq.ctx.Unique != nil && *obq.ctx.Unique {
		selector.Distinct()
	}
	for _, p := range obq.predicates {
		p(selector)
	}
	for _, p := range obq.order {
		p(selector)
	}
	if offset := obq.ctx.Offset; offset != nil {
		// limit is mandatory for offset clause. We start
		// with default value, and override it below if needed.
		selector.Offset(*offset).Limit(math.MaxInt32)
	}
	if limit := obq.ctx.Limit; limit != nil {
		selector.Limit(*limit)
	}
	return selector
}

// ObjectstorageBucketGroupBy is the group-by builder for ObjectstorageBucket entities.
type ObjectstorageBucketGroupBy struct {
	selector
	build *ObjectstorageBucketQuery
}

// Aggregate adds the given aggregation functions to the group-by query.
func (obgb *ObjectstorageBucketGroupBy) Aggregate(fns ...AggregateFunc) *ObjectstorageBucketGroupBy {
	obgb.fns = append(obgb.fns, fns...)
	return obgb
}

// Scan applies the selector query and scans the result into the given value.
func (obgb *ObjectstorageBucketGroupBy) Scan(ctx context.Context, v any) error {
	ctx = setContextOp(ctx, obgb.build.ctx, "GroupBy")
	if err := obgb.build.prepareQuery(ctx); err != nil {
		return err
	}
	return scanWithInterceptors[*ObjectstorageBucketQuery, *ObjectstorageBucketGroupBy](ctx, obgb.build, obgb, obgb.build.inters, v)
}

func (obgb *ObjectstorageBucketGroupBy) sqlScan(ctx context.Context, root *ObjectstorageBucketQuery, v any) error {
	selector := root.sqlQuery(ctx).Select()
	aggregation := make([]string, 0, len(obgb.fns))
	for _, fn := range obgb.fns {
		aggregation = append(aggregation, fn(selector))
	}
	if len(selector.SelectedColumns()) == 0 {
		columns := make([]string, 0, len(*obgb.flds)+len(obgb.fns))
		for _, f := range *obgb.flds {
			columns = append(columns, selector.C(f))
		}
		columns = append(columns, aggregation...)
		selector.Select(columns...)
	}
	selector.GroupBy(selector.Columns(*obgb.flds...)...)
	if err := selector.Err(); err != nil {
		return err
	}
	rows := &sql.Rows{}
	query, args := selector.Query()
	if err := obgb.build.driver.Query(ctx, query, args, rows); err != nil {
		return err
	}
	defer rows.Close()
	return sql.ScanSlice(rows, v)
}

// ObjectstorageBucketSelect is the builder for selecting fields of ObjectstorageBucket entities.
type ObjectstorageBucketSelect struct {
	*ObjectstorageBucketQuery
	selector
}

// Aggregate adds the given aggregation functions to the selector query.
func (obs *ObjectstorageBucketSelect) Aggregate(fns ...AggregateFunc) *ObjectstorageBucketSelect {
	obs.fns = append(obs.fns, fns...)
	return obs
}

// Scan applies the selector query and scans the result into the given value.
func (obs *ObjectstorageBucketSelect) Scan(ctx context.Context, v any) error {
	ctx = setContextOp(ctx, obs.ctx, "Select")
	if err := obs.prepareQuery(ctx); err != nil {
		return err
	}
	return scanWithInterceptors[*ObjectstorageBucketQuery, *ObjectstorageBucketSelect](ctx, obs.ObjectstorageBucketQuery, obs, obs.inters, v)
}

func (obs *ObjectstorageBucketSelect) sqlScan(ctx context.Context, root *ObjectstorageBucketQuery, v any) error {
	selector := root.sqlQuery(ctx)
	aggregation := make([]string, 0, len(obs.fns))
	for _, fn := range obs.fns {
		aggregation = append(aggregation, fn(selector))
	}
	switch n := len(*obs.selector.flds); {
	case n == 0 && len(aggregation) > 0:
		selector.Select(aggregation...)
	case n != 0 && len(aggregation) > 0:
		selector.AppendSelect(aggregation...)
	}
	rows := &sql.Rows{}
	query, args := selector.Query()
	if err := obs.driver.Query(ctx, query, args, rows); err != nil {
		return err
	}
	defer rows.Close()
	return sql.ScanSlice(rows, v)
}

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/data/ent/predicate/predicate.go
```golang
// Code generated by ent, DO NOT EDIT.

package predicate

import (
	"entgo.io/ent/dialect/sql"
)

// BlockStorage is the predicate function for blockstorage builders.
type BlockStorage func(*sql.Selector)

// EbsVolume is the predicate function for ebsvolume builders.
type EbsVolume func(*sql.Selector)

// ObjectStorage is the predicate function for objectstorage builders.
type ObjectStorage func(*sql.Selector)

// ObjectstorageBucket is the predicate function for objectstoragebucket builders.
type ObjectstorageBucket func(*sql.Selector)

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/data/ent/objectstorage/objectstorage.go
```golang
// Code generated by ent, DO NOT EDIT.

package objectstorage

const (
	// Label holds the string label denoting the objectstorage type in the database.
	Label = "object_storage"
	// FieldID holds the string denoting the id field in the database.
	FieldID = "id"
	// FieldName holds the string denoting the name field in the database.
	FieldName = "name"
	// FieldSize holds the string denoting the size field in the database.
	FieldSize = "size"
	// FieldStorageType holds the string denoting the storage_type field in the database.
	FieldStorageType = "storage_type"
	// FieldRegion holds the string denoting the region field in the database.
	FieldRegion = "region"
	// FieldRegionCode holds the string denoting the region_code field in the database.
	FieldRegionCode = "region_code"
	// FieldAz holds the string denoting the az field in the database.
	FieldAz = "az"
	// FieldAzCode holds the string denoting the az_code field in the database.
	FieldAzCode = "az_code"
	// FieldTenantID holds the string denoting the tenant_id field in the database.
	FieldTenantID = "tenant_id"
	// FieldTenantName holds the string denoting the tenant_name field in the database.
	FieldTenantName = "tenant_name"
	// FieldInnerDomainName holds the string denoting the inner_domain_name field in the database.
	FieldInnerDomainName = "inner_domain_name"
	// FieldOuterDomainName holds the string denoting the outer_domain_name field in the database.
	FieldOuterDomainName = "outer_domain_name"
	// FieldCreateTime holds the string denoting the create_time field in the database.
	FieldCreateTime = "create_time"
	// FieldPolicy holds the string denoting the policy field in the database.
	FieldPolicy = "policy"
	// FieldBucketDomains holds the string denoting the bucket_domains field in the database.
	FieldBucketDomains = "bucket_domains"
	// FieldResourcePoolID holds the string denoting the resource_pool_id field in the database.
	FieldResourcePoolID = "resource_pool_id"
	// FieldResourcePoolName holds the string denoting the resource_pool_name field in the database.
	FieldResourcePoolName = "resource_pool_name"
	// FieldObjectCount holds the string denoting the object_count field in the database.
	FieldObjectCount = "object_count"
	// FieldCurrentSize holds the string denoting the current_size field in the database.
	FieldCurrentSize = "current_size"
	// FieldLast30DayDownload holds the string denoting the last30_day_download field in the database.
	FieldLast30DayDownload = "last30_day_download"
	// FieldLast30DayAPICallTimes holds the string denoting the last30_day_api_call_times field in the database.
	FieldLast30DayAPICallTimes = "last30_day_api_call_times"
	// FieldLastUpdateTime holds the string denoting the last_update_time field in the database.
	FieldLastUpdateTime = "last_update_time"
	// Table holds the table name of the objectstorage in the database.
	Table = "object_storage"
)

// Columns holds all SQL columns for objectstorage fields.
var Columns = []string{
	FieldID,
	FieldName,
	FieldSize,
	FieldStorageType,
	FieldRegion,
	FieldRegionCode,
	FieldAz,
	FieldAzCode,
	FieldTenantID,
	FieldTenantName,
	FieldInnerDomainName,
	FieldOuterDomainName,
	FieldCreateTime,
	FieldPolicy,
	FieldBucketDomains,
	FieldResourcePoolID,
	FieldResourcePoolName,
	FieldObjectCount,
	FieldCurrentSize,
	FieldLast30DayDownload,
	FieldLast30DayAPICallTimes,
	FieldLastUpdateTime,
}

// ValidColumn reports if the column name is valid (part of the table columns).
func ValidColumn(column string) bool {
	for i := range Columns {
		if column == Columns[i] {
			return true
		}
	}
	return false
}

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/data/ent/objectstorage/where.go
```golang
// Code generated by ent, DO NOT EDIT.

package objectstorage

import (
	"luban-cmdb-api/data/ent/predicate"
	"time"

	"entgo.io/ent/dialect/sql"
)

// ID filters vertices based on their ID field.
func ID(id string) predicate.ObjectStorage {
	return predicate.ObjectStorage(sql.FieldEQ(FieldID, id))
}

// IDEQ applies the EQ predicate on the ID field.
func IDEQ(id string) predicate.ObjectStorage {
	return predicate.ObjectStorage(sql.FieldEQ(FieldID, id))
}

// IDNEQ applies the NEQ predicate on the ID field.
func IDNEQ(id string) predicate.ObjectStorage {
	return predicate.ObjectStorage(sql.FieldNEQ(FieldID, id))
}

// IDIn applies the In predicate on the ID field.
func IDIn(ids ...string) predicate.ObjectStorage {
	return predicate.ObjectStorage(sql.FieldIn(FieldID, ids...))
}

// IDNotIn applies the NotIn predicate on the ID field.
func IDNotIn(ids ...string) predicate.ObjectStorage {
	return predicate.ObjectStorage(sql.FieldNotIn(FieldID, ids...))
}

// IDGT applies the GT predicate on the ID field.
func IDGT(id string) predicate.ObjectStorage {
	return predicate.ObjectStorage(sql.FieldGT(FieldID, id))
}

// IDGTE applies the GTE predicate on the ID field.
func IDGTE(id string) predicate.ObjectStorage {
	return predicate.ObjectStorage(sql.FieldGTE(FieldID, id))
}

// IDLT applies the LT predicate on the ID field.
func IDLT(id string) predicate.ObjectStorage {
	return predicate.ObjectStorage(sql.FieldLT(FieldID, id))
}

// IDLTE applies the LTE predicate on the ID field.
func IDLTE(id string) predicate.ObjectStorage {
	return predicate.ObjectStorage(sql.FieldLTE(FieldID, id))
}

// Name applies equality check predicate on the "name" field. It's identical to NameEQ.
func Name(v string) predicate.ObjectStorage {
	return predicate.ObjectStorage(sql.FieldEQ(FieldName, v))
}

// Size applies equality check predicate on the "size" field. It's identical to SizeEQ.
func Size(v int) predicate.ObjectStorage {
	return predicate.ObjectStorage(sql.FieldEQ(FieldSize, v))
}

// StorageType applies equality check predicate on the "storage_type" field. It's identical to StorageTypeEQ.
func StorageType(v string) predicate.ObjectStorage {
	return predicate.ObjectStorage(sql.FieldEQ(FieldStorageType, v))
}

// Region applies equality check predicate on the "region" field. It's identical to RegionEQ.
func Region(v string) predicate.ObjectStorage {
	return predicate.ObjectStorage(sql.FieldEQ(FieldRegion, v))
}

// RegionCode applies equality check predicate on the "region_code" field. It's identical to RegionCodeEQ.
func RegionCode(v string) predicate.ObjectStorage {
	return predicate.ObjectStorage(sql.FieldEQ(FieldRegionCode, v))
}

// Az applies equality check predicate on the "az" field. It's identical to AzEQ.
func Az(v string) predicate.ObjectStorage {
	return predicate.ObjectStorage(sql.FieldEQ(FieldAz, v))
}

// AzCode applies equality check predicate on the "az_code" field. It's identical to AzCodeEQ.
func AzCode(v string) predicate.ObjectStorage {
	return predicate.ObjectStorage(sql.FieldEQ(FieldAzCode, v))
}

// TenantID applies equality check predicate on the "tenant_id" field. It's identical to TenantIDEQ.
func TenantID(v string) predicate.ObjectStorage {
	return predicate.ObjectStorage(sql.FieldEQ(FieldTenantID, v))
}

// TenantName applies equality check predicate on the "tenant_name" field. It's identical to TenantNameEQ.
func TenantName(v string) predicate.ObjectStorage {
	return predicate.ObjectStorage(sql.FieldEQ(FieldTenantName, v))
}

// InnerDomainName applies equality check predicate on the "inner_domain_name" field. It's identical to InnerDomainNameEQ.
func InnerDomainName(v string) predicate.ObjectStorage {
	return predicate.ObjectStorage(sql.FieldEQ(FieldInnerDomainName, v))
}

// OuterDomainName applies equality check predicate on the "outer_domain_name" field. It's identical to OuterDomainNameEQ.
func OuterDomainName(v string) predicate.ObjectStorage {
	return predicate.ObjectStorage(sql.FieldEQ(FieldOuterDomainName, v))
}

// CreateTime applies equality check predicate on the "create_time" field. It's identical to CreateTimeEQ.
func CreateTime(v int) predicate.ObjectStorage {
	return predicate.ObjectStorage(sql.FieldEQ(FieldCreateTime, v))
}

// BucketDomains applies equality check predicate on the "bucket_domains" field. It's identical to BucketDomainsEQ.
func BucketDomains(v string) predicate.ObjectStorage {
	return predicate.ObjectStorage(sql.FieldEQ(FieldBucketDomains, v))
}

// ResourcePoolID applies equality check predicate on the "resource_pool_id" field. It's identical to ResourcePoolIDEQ.
func ResourcePoolID(v int) predicate.ObjectStorage {
	return predicate.ObjectStorage(sql.FieldEQ(FieldResourcePoolID, v))
}

// ResourcePoolName applies equality check predicate on the "resource_pool_name" field. It's identical to ResourcePoolNameEQ.
func ResourcePoolName(v string) predicate.ObjectStorage {
	return predicate.ObjectStorage(sql.FieldEQ(FieldResourcePoolName, v))
}

// ObjectCount applies equality check predicate on the "object_count" field. It's identical to ObjectCountEQ.
func ObjectCount(v int) predicate.ObjectStorage {
	return predicate.ObjectStorage(sql.FieldEQ(FieldObjectCount, v))
}

// CurrentSize applies equality check predicate on the "current_size" field. It's identical to CurrentSizeEQ.
func CurrentSize(v int) predicate.ObjectStorage {
	return predicate.ObjectStorage(sql.FieldEQ(FieldCurrentSize, v))
}

// Last30DayDownload applies equality check predicate on the "last30_day_download" field. It's identical to Last30DayDownloadEQ.
func Last30DayDownload(v int) predicate.ObjectStorage {
	return predicate.ObjectStorage(sql.FieldEQ(FieldLast30DayDownload, v))
}

// Last30DayAPICallTimes applies equality check predicate on the "last30_day_api_call_times" field. It's identical to Last30DayAPICallTimesEQ.
func Last30DayAPICallTimes(v int) predicate.ObjectStorage {
	return predicate.ObjectStorage(sql.FieldEQ(FieldLast30DayAPICallTimes, v))
}

// LastUpdateTime applies equality check predicate on the "last_update_time" field. It's identical to LastUpdateTimeEQ.
func LastUpdateTime(v time.Time) predicate.ObjectStorage {
	return predicate.ObjectStorage(sql.FieldEQ(FieldLastUpdateTime, v))
}

// NameEQ applies the EQ predicate on the "name" field.
func NameEQ(v string) predicate.ObjectStorage {
	return predicate.ObjectStorage(sql.FieldEQ(FieldName, v))
}

// NameNEQ applies the NEQ predicate on the "name" field.
func NameNEQ(v string) predicate.ObjectStorage {
	return predicate.ObjectStorage(sql.FieldNEQ(FieldName, v))
}

// NameIn applies the In predicate on the "name" field.
func NameIn(vs ...string) predicate.ObjectStorage {
	return predicate.ObjectStorage(sql.FieldIn(FieldName, vs...))
}

// NameNotIn applies the NotIn predicate on the "name" field.
func NameNotIn(vs ...string) predicate.ObjectStorage {
	return predicate.ObjectStorage(sql.FieldNotIn(FieldName, vs...))
}

// NameGT applies the GT predicate on the "name" field.
func NameGT(v string) predicate.ObjectStorage {
	return predicate.ObjectStorage(sql.FieldGT(FieldName, v))
}

// NameGTE applies the GTE predicate on the "name" field.
func NameGTE(v string) predicate.ObjectStorage {
	return predicate.ObjectStorage(sql.FieldGTE(FieldName, v))
}

// NameLT applies the LT predicate on the "name" field.
func NameLT(v string) predicate.ObjectStorage {
	return predicate.ObjectStorage(sql.FieldLT(FieldName, v))
}

// NameLTE applies the LTE predicate on the "name" field.
func NameLTE(v string) predicate.ObjectStorage {
	return predicate.ObjectStorage(sql.FieldLTE(FieldName, v))
}

// NameContains applies the Contains predicate on the "name" field.
func NameContains(v string) predicate.ObjectStorage {
	return predicate.ObjectStorage(sql.FieldContains(FieldName, v))
}

// NameHasPrefix applies the HasPrefix predicate on the "name" field.
func NameHasPrefix(v string) predicate.ObjectStorage {
	return predicate.ObjectStorage(sql.FieldHasPrefix(FieldName, v))
}

// NameHasSuffix applies the HasSuffix predicate on the "name" field.
func NameHasSuffix(v string) predicate.ObjectStorage {
	return predicate.ObjectStorage(sql.FieldHasSuffix(FieldName, v))
}

// NameIsNil applies the IsNil predicate on the "name" field.
func NameIsNil() predicate.ObjectStorage {
	return predicate.ObjectStorage(sql.FieldIsNull(FieldName))
}

// NameNotNil applies the NotNil predicate on the "name" field.
func NameNotNil() predicate.ObjectStorage {
	return predicate.ObjectStorage(sql.FieldNotNull(FieldName))
}

// NameEqualFold applies the EqualFold predicate on the "name" field.
func NameEqualFold(v string) predicate.ObjectStorage {
	return predicate.ObjectStorage(sql.FieldEqualFold(FieldName, v))
}

// NameContainsFold applies the ContainsFold predicate on the "name" field.
func NameContainsFold(v string) predicate.ObjectStorage {
	return predicate.ObjectStorage(sql.FieldContainsFold(FieldName, v))
}

// SizeEQ applies the EQ predicate on the "size" field.
func SizeEQ(v int) predicate.ObjectStorage {
	return predicate.ObjectStorage(sql.FieldEQ(FieldSize, v))
}

// SizeNEQ applies the NEQ predicate on the "size" field.
func SizeNEQ(v int) predicate.ObjectStorage {
	return predicate.ObjectStorage(sql.FieldNEQ(FieldSize, v))
}

// SizeIn applies the In predicate on the "size" field.
func SizeIn(vs ...int) predicate.ObjectStorage {
	return predicate.ObjectStorage(sql.FieldIn(FieldSize, vs...))
}

// SizeNotIn applies the NotIn predicate on the "size" field.
func SizeNotIn(vs ...int) predicate.ObjectStorage {
	return predicate.ObjectStorage(sql.FieldNotIn(FieldSize, vs...))
}

// SizeGT applies the GT predicate on the "size" field.
func SizeGT(v int) predicate.ObjectStorage {
	return predicate.ObjectStorage(sql.FieldGT(FieldSize, v))
}

// SizeGTE applies the GTE predicate on the "size" field.
func SizeGTE(v int) predicate.ObjectStorage {
	return predicate.ObjectStorage(sql.FieldGTE(FieldSize, v))
}

// SizeLT applies the LT predicate on the "size" field.
func SizeLT(v int) predicate.ObjectStorage {
	return predicate.ObjectStorage(sql.FieldLT(FieldSize, v))
}

// SizeLTE applies the LTE predicate on the "size" field.
func SizeLTE(v int) predicate.ObjectStorage {
	return predicate.ObjectStorage(sql.FieldLTE(FieldSize, v))
}

// SizeIsNil applies the IsNil predicate on the "size" field.
func SizeIsNil() predicate.ObjectStorage {
	return predicate.ObjectStorage(sql.FieldIsNull(FieldSize))
}

// SizeNotNil applies the NotNil predicate on the "size" field.
func SizeNotNil() predicate.ObjectStorage {
	return predicate.ObjectStorage(sql.FieldNotNull(FieldSize))
}

// StorageTypeEQ applies the EQ predicate on the "storage_type" field.
func StorageTypeEQ(v string) predicate.ObjectStorage {
	return predicate.ObjectStorage(sql.FieldEQ(FieldStorageType, v))
}

// StorageTypeNEQ applies the NEQ predicate on the "storage_type" field.
func StorageTypeNEQ(v string) predicate.ObjectStorage {
	return predicate.ObjectStorage(sql.FieldNEQ(FieldStorageType, v))
}

// StorageTypeIn applies the In predicate on the "storage_type" field.
func StorageTypeIn(vs ...string) predicate.ObjectStorage {
	return predicate.ObjectStorage(sql.FieldIn(FieldStorageType, vs...))
}

// StorageTypeNotIn applies the NotIn predicate on the "storage_type" field.
func StorageTypeNotIn(vs ...string) predicate.ObjectStorage {
	return predicate.ObjectStorage(sql.FieldNotIn(FieldStorageType, vs...))
}

// StorageTypeGT applies the GT predicate on the "storage_type" field.
func StorageTypeGT(v string) predicate.ObjectStorage {
	return predicate.ObjectStorage(sql.FieldGT(FieldStorageType, v))
}

// StorageTypeGTE applies the GTE predicate on the "storage_type" field.
func StorageTypeGTE(v string) predicate.ObjectStorage {
	return predicate.ObjectStorage(sql.FieldGTE(FieldStorageType, v))
}

// StorageTypeLT applies the LT predicate on the "storage_type" field.
func StorageTypeLT(v string) predicate.ObjectStorage {
	return predicate.ObjectStorage(sql.FieldLT(FieldStorageType, v))
}

// StorageTypeLTE applies the LTE predicate on the "storage_type" field.
func StorageTypeLTE(v string) predicate.ObjectStorage {
	return predicate.ObjectStorage(sql.FieldLTE(FieldStorageType, v))
}

// StorageTypeContains applies the Contains predicate on the "storage_type" field.
func StorageTypeContains(v string) predicate.ObjectStorage {
	return predicate.ObjectStorage(sql.FieldContains(FieldStorageType, v))
}

// StorageTypeHasPrefix applies the HasPrefix predicate on the "storage_type" field.
func StorageTypeHasPrefix(v string) predicate.ObjectStorage {
	return predicate.ObjectStorage(sql.FieldHasPrefix(FieldStorageType, v))
}

// StorageTypeHasSuffix applies the HasSuffix predicate on the "storage_type" field.
func StorageTypeHasSuffix(v string) predicate.ObjectStorage {
	return predicate.ObjectStorage(sql.FieldHasSuffix(FieldStorageType, v))
}

// StorageTypeIsNil applies the IsNil predicate on the "storage_type" field.
func StorageTypeIsNil() predicate.ObjectStorage {
	return predicate.ObjectStorage(sql.FieldIsNull(FieldStorageType))
}

// StorageTypeNotNil applies the NotNil predicate on the "storage_type" field.
func StorageTypeNotNil() predicate.ObjectStorage {
	return predicate.ObjectStorage(sql.FieldNotNull(FieldStorageType))
}

// StorageTypeEqualFold applies the EqualFold predicate on the "storage_type" field.
func StorageTypeEqualFold(v string) predicate.ObjectStorage {
	return predicate.ObjectStorage(sql.FieldEqualFold(FieldStorageType, v))
}

// StorageTypeContainsFold applies the ContainsFold predicate on the "storage_type" field.
func StorageTypeContainsFold(v string) predicate.ObjectStorage {
	return predicate.ObjectStorage(sql.FieldContainsFold(FieldStorageType, v))
}

// RegionEQ applies the EQ predicate on the "region" field.
func RegionEQ(v string) predicate.ObjectStorage {
	return predicate.ObjectStorage(sql.FieldEQ(FieldRegion, v))
}

// RegionNEQ applies the NEQ predicate on the "region" field.
func RegionNEQ(v string) predicate.ObjectStorage {
	return predicate.ObjectStorage(sql.FieldNEQ(FieldRegion, v))
}

// RegionIn applies the In predicate on the "region" field.
func RegionIn(vs ...string) predicate.ObjectStorage {
	return predicate.ObjectStorage(sql.FieldIn(FieldRegion, vs...))
}

// RegionNotIn applies the NotIn predicate on the "region" field.
func RegionNotIn(vs ...string) predicate.ObjectStorage {
	return predicate.ObjectStorage(sql.FieldNotIn(FieldRegion, vs...))
}

// RegionGT applies the GT predicate on the "region" field.
func RegionGT(v string) predicate.ObjectStorage {
	return predicate.ObjectStorage(sql.FieldGT(FieldRegion, v))
}

// RegionGTE applies the GTE predicate on the "region" field.
func RegionGTE(v string) predicate.ObjectStorage {
	return predicate.ObjectStorage(sql.FieldGTE(FieldRegion, v))
}

// RegionLT applies the LT predicate on the "region" field.
func RegionLT(v string) predicate.ObjectStorage {
	return predicate.ObjectStorage(sql.FieldLT(FieldRegion, v))
}

// RegionLTE applies the LTE predicate on the "region" field.
func RegionLTE(v string) predicate.ObjectStorage {
	return predicate.ObjectStorage(sql.FieldLTE(FieldRegion, v))
}

// RegionContains applies the Contains predicate on the "region" field.
func RegionContains(v string) predicate.ObjectStorage {
	return predicate.ObjectStorage(sql.FieldContains(FieldRegion, v))
}

// RegionHasPrefix applies the HasPrefix predicate on the "region" field.
func RegionHasPrefix(v string) predicate.ObjectStorage {
	return predicate.ObjectStorage(sql.FieldHasPrefix(FieldRegion, v))
}

// RegionHasSuffix applies the HasSuffix predicate on the "region" field.
func RegionHasSuffix(v string) predicate.ObjectStorage {
	return predicate.ObjectStorage(sql.FieldHasSuffix(FieldRegion, v))
}

// RegionIsNil applies the IsNil predicate on the "region" field.
func RegionIsNil() predicate.ObjectStorage {
	return predicate.ObjectStorage(sql.FieldIsNull(FieldRegion))
}

// RegionNotNil applies the NotNil predicate on the "region" field.
func RegionNotNil() predicate.ObjectStorage {
	return predicate.ObjectStorage(sql.FieldNotNull(FieldRegion))
}

// RegionEqualFold applies the EqualFold predicate on the "region" field.
func RegionEqualFold(v string) predicate.ObjectStorage {
	return predicate.ObjectStorage(sql.FieldEqualFold(FieldRegion, v))
}

// RegionContainsFold applies the ContainsFold predicate on the "region" field.
func RegionContainsFold(v string) predicate.ObjectStorage {
	return predicate.ObjectStorage(sql.FieldContainsFold(FieldRegion, v))
}

// RegionCodeEQ applies the EQ predicate on the "region_code" field.
func RegionCodeEQ(v string) predicate.ObjectStorage {
	return predicate.ObjectStorage(sql.FieldEQ(FieldRegionCode, v))
}

// RegionCodeNEQ applies the NEQ predicate on the "region_code" field.
func RegionCodeNEQ(v string) predicate.ObjectStorage {
	return predicate.ObjectStorage(sql.FieldNEQ(FieldRegionCode, v))
}

// RegionCodeIn applies the In predicate on the "region_code" field.
func RegionCodeIn(vs ...string) predicate.ObjectStorage {
	return predicate.ObjectStorage(sql.FieldIn(FieldRegionCode, vs...))
}

// RegionCodeNotIn applies the NotIn predicate on the "region_code" field.
func RegionCodeNotIn(vs ...string) predicate.ObjectStorage {
	return predicate.ObjectStorage(sql.FieldNotIn(FieldRegionCode, vs...))
}

// RegionCodeGT applies the GT predicate on the "region_code" field.
func RegionCodeGT(v string) predicate.ObjectStorage {
	return predicate.ObjectStorage(sql.FieldGT(FieldRegionCode, v))
}

// RegionCodeGTE applies the GTE predicate on the "region_code" field.
func RegionCodeGTE(v string) predicate.ObjectStorage {
	return predicate.ObjectStorage(sql.FieldGTE(FieldRegionCode, v))
}

// RegionCodeLT applies the LT predicate on the "region_code" field.
func RegionCodeLT(v string) predicate.ObjectStorage {
	return predicate.ObjectStorage(sql.FieldLT(FieldRegionCode, v))
}

// RegionCodeLTE applies the LTE predicate on the "region_code" field.
func RegionCodeLTE(v string) predicate.ObjectStorage {
	return predicate.ObjectStorage(sql.FieldLTE(FieldRegionCode, v))
}

// RegionCodeContains applies the Contains predicate on the "region_code" field.
func RegionCodeContains(v string) predicate.ObjectStorage {
	return predicate.ObjectStorage(sql.FieldContains(FieldRegionCode, v))
}

// RegionCodeHasPrefix applies the HasPrefix predicate on the "region_code" field.
func RegionCodeHasPrefix(v string) predicate.ObjectStorage {
	return predicate.ObjectStorage(sql.FieldHasPrefix(FieldRegionCode, v))
}

// RegionCodeHasSuffix applies the HasSuffix predicate on the "region_code" field.
func RegionCodeHasSuffix(v string) predicate.ObjectStorage {
	return predicate.ObjectStorage(sql.FieldHasSuffix(FieldRegionCode, v))
}

// RegionCodeIsNil applies the IsNil predicate on the "region_code" field.
func RegionCodeIsNil() predicate.ObjectStorage {
	return predicate.ObjectStorage(sql.FieldIsNull(FieldRegionCode))
}

// RegionCodeNotNil applies the NotNil predicate on the "region_code" field.
func RegionCodeNotNil() predicate.ObjectStorage {
	return predicate.ObjectStorage(sql.FieldNotNull(FieldRegionCode))
}

// RegionCodeEqualFold applies the EqualFold predicate on the "region_code" field.
func RegionCodeEqualFold(v string) predicate.ObjectStorage {
	return predicate.ObjectStorage(sql.FieldEqualFold(FieldRegionCode, v))
}

// RegionCodeContainsFold applies the ContainsFold predicate on the "region_code" field.
func RegionCodeContainsFold(v string) predicate.ObjectStorage {
	return predicate.ObjectStorage(sql.FieldContainsFold(FieldRegionCode, v))
}

// AzEQ applies the EQ predicate on the "az" field.
func AzEQ(v string) predicate.ObjectStorage {
	return predicate.ObjectStorage(sql.FieldEQ(FieldAz, v))
}

// AzNEQ applies the NEQ predicate on the "az" field.
func AzNEQ(v string) predicate.ObjectStorage {
	return predicate.ObjectStorage(sql.FieldNEQ(FieldAz, v))
}

// AzIn applies the In predicate on the "az" field.
func AzIn(vs ...string) predicate.ObjectStorage {
	return predicate.ObjectStorage(sql.FieldIn(FieldAz, vs...))
}

// AzNotIn applies the NotIn predicate on the "az" field.
func AzNotIn(vs ...string) predicate.ObjectStorage {
	return predicate.ObjectStorage(sql.FieldNotIn(FieldAz, vs...))
}

// AzGT applies the GT predicate on the "az" field.
func AzGT(v string) predicate.ObjectStorage {
	return predicate.ObjectStorage(sql.FieldGT(FieldAz, v))
}

// AzGTE applies the GTE predicate on the "az" field.
func AzGTE(v string) predicate.ObjectStorage {
	return predicate.ObjectStorage(sql.FieldGTE(FieldAz, v))
}

// AzLT applies the LT predicate on the "az" field.
func AzLT(v string) predicate.ObjectStorage {
	return predicate.ObjectStorage(sql.FieldLT(FieldAz, v))
}

// AzLTE applies the LTE predicate on the "az" field.
func AzLTE(v string) predicate.ObjectStorage {
	return predicate.ObjectStorage(sql.FieldLTE(FieldAz, v))
}

// AzContains applies the Contains predicate on the "az" field.
func AzContains(v string) predicate.ObjectStorage {
	return predicate.ObjectStorage(sql.FieldContains(FieldAz, v))
}

// AzHasPrefix applies the HasPrefix predicate on the "az" field.
func AzHasPrefix(v string) predicate.ObjectStorage {
	return predicate.ObjectStorage(sql.FieldHasPrefix(FieldAz, v))
}

// AzHasSuffix applies the HasSuffix predicate on the "az" field.
func AzHasSuffix(v string) predicate.ObjectStorage {
	return predicate.ObjectStorage(sql.FieldHasSuffix(FieldAz, v))
}

// AzIsNil applies the IsNil predicate on the "az" field.
func AzIsNil() predicate.ObjectStorage {
	return predicate.ObjectStorage(sql.FieldIsNull(FieldAz))
}

// AzNotNil applies the NotNil predicate on the "az" field.
func AzNotNil() predicate.ObjectStorage {
	return predicate.ObjectStorage(sql.FieldNotNull(FieldAz))
}

// AzEqualFold applies the EqualFold predicate on the "az" field.
func AzEqualFold(v string) predicate.ObjectStorage {
	return predicate.ObjectStorage(sql.FieldEqualFold(FieldAz, v))
}

// AzContainsFold applies the ContainsFold predicate on the "az" field.
func AzContainsFold(v string) predicate.ObjectStorage {
	return predicate.ObjectStorage(sql.FieldContainsFold(FieldAz, v))
}

// AzCodeEQ applies the EQ predicate on the "az_code" field.
func AzCodeEQ(v string) predicate.ObjectStorage {
	return predicate.ObjectStorage(sql.FieldEQ(FieldAzCode, v))
}

// AzCodeNEQ applies the NEQ predicate on the "az_code" field.
func AzCodeNEQ(v string) predicate.ObjectStorage {
	return predicate.ObjectStorage(sql.FieldNEQ(FieldAzCode, v))
}

// AzCodeIn applies the In predicate on the "az_code" field.
func AzCodeIn(vs ...string) predicate.ObjectStorage {
	return predicate.ObjectStorage(sql.FieldIn(FieldAzCode, vs...))
}

// AzCodeNotIn applies the NotIn predicate on the "az_code" field.
func AzCodeNotIn(vs ...string) predicate.ObjectStorage {
	return predicate.ObjectStorage(sql.FieldNotIn(FieldAzCode, vs...))
}

// AzCodeGT applies the GT predicate on the "az_code" field.
func AzCodeGT(v string) predicate.ObjectStorage {
	return predicate.ObjectStorage(sql.FieldGT(FieldAzCode, v))
}

// AzCodeGTE applies the GTE predicate on the "az_code" field.
func AzCodeGTE(v string) predicate.ObjectStorage {
	return predicate.ObjectStorage(sql.FieldGTE(FieldAzCode, v))
}

// AzCodeLT applies the LT predicate on the "az_code" field.
func AzCodeLT(v string) predicate.ObjectStorage {
	return predicate.ObjectStorage(sql.FieldLT(FieldAzCode, v))
}

// AzCodeLTE applies the LTE predicate on the "az_code" field.
func AzCodeLTE(v string) predicate.ObjectStorage {
	return predicate.ObjectStorage(sql.FieldLTE(FieldAzCode, v))
}

// AzCodeContains applies the Contains predicate on the "az_code" field.
func AzCodeContains(v string) predicate.ObjectStorage {
	return predicate.ObjectStorage(sql.FieldContains(FieldAzCode, v))
}

// AzCodeHasPrefix applies the HasPrefix predicate on the "az_code" field.
func AzCodeHasPrefix(v string) predicate.ObjectStorage {
	return predicate.ObjectStorage(sql.FieldHasPrefix(FieldAzCode, v))
}

// AzCodeHasSuffix applies the HasSuffix predicate on the "az_code" field.
func AzCodeHasSuffix(v string) predicate.ObjectStorage {
	return predicate.ObjectStorage(sql.FieldHasSuffix(FieldAzCode, v))
}

// AzCodeIsNil applies the IsNil predicate on the "az_code" field.
func AzCodeIsNil() predicate.ObjectStorage {
	return predicate.ObjectStorage(sql.FieldIsNull(FieldAzCode))
}

// AzCodeNotNil applies the NotNil predicate on the "az_code" field.
func AzCodeNotNil() predicate.ObjectStorage {
	return predicate.ObjectStorage(sql.FieldNotNull(FieldAzCode))
}

// AzCodeEqualFold applies the EqualFold predicate on the "az_code" field.
func AzCodeEqualFold(v string) predicate.ObjectStorage {
	return predicate.ObjectStorage(sql.FieldEqualFold(FieldAzCode, v))
}

// AzCodeContainsFold applies the ContainsFold predicate on the "az_code" field.
func AzCodeContainsFold(v string) predicate.ObjectStorage {
	return predicate.ObjectStorage(sql.FieldContainsFold(FieldAzCode, v))
}

// TenantIDEQ applies the EQ predicate on the "tenant_id" field.
func TenantIDEQ(v string) predicate.ObjectStorage {
	return predicate.ObjectStorage(sql.FieldEQ(FieldTenantID, v))
}

// TenantIDNEQ applies the NEQ predicate on the "tenant_id" field.
func TenantIDNEQ(v string) predicate.ObjectStorage {
	return predicate.ObjectStorage(sql.FieldNEQ(FieldTenantID, v))
}

// TenantIDIn applies the In predicate on the "tenant_id" field.
func TenantIDIn(vs ...string) predicate.ObjectStorage {
	return predicate.ObjectStorage(sql.FieldIn(FieldTenantID, vs...))
}

// TenantIDNotIn applies the NotIn predicate on the "tenant_id" field.
func TenantIDNotIn(vs ...string) predicate.ObjectStorage {
	return predicate.ObjectStorage(sql.FieldNotIn(FieldTenantID, vs...))
}

// TenantIDGT applies the GT predicate on the "tenant_id" field.
func TenantIDGT(v string) predicate.ObjectStorage {
	return predicate.ObjectStorage(sql.FieldGT(FieldTenantID, v))
}

// TenantIDGTE applies the GTE predicate on the "tenant_id" field.
func TenantIDGTE(v string) predicate.ObjectStorage {
	return predicate.ObjectStorage(sql.FieldGTE(FieldTenantID, v))
}

// TenantIDLT applies the LT predicate on the "tenant_id" field.
func TenantIDLT(v string) predicate.ObjectStorage {
	return predicate.ObjectStorage(sql.FieldLT(FieldTenantID, v))
}

// TenantIDLTE applies the LTE predicate on the "tenant_id" field.
func TenantIDLTE(v string) predicate.ObjectStorage {
	return predicate.ObjectStorage(sql.FieldLTE(FieldTenantID, v))
}

// TenantIDContains applies the Contains predicate on the "tenant_id" field.
func TenantIDContains(v string) predicate.ObjectStorage {
	return predicate.ObjectStorage(sql.FieldContains(FieldTenantID, v))
}

// TenantIDHasPrefix applies the HasPrefix predicate on the "tenant_id" field.
func TenantIDHasPrefix(v string) predicate.ObjectStorage {
	return predicate.ObjectStorage(sql.FieldHasPrefix(FieldTenantID, v))
}

// TenantIDHasSuffix applies the HasSuffix predicate on the "tenant_id" field.
func TenantIDHasSuffix(v string) predicate.ObjectStorage {
	return predicate.ObjectStorage(sql.FieldHasSuffix(FieldTenantID, v))
}

// TenantIDIsNil applies the IsNil predicate on the "tenant_id" field.
func TenantIDIsNil() predicate.ObjectStorage {
	return predicate.ObjectStorage(sql.FieldIsNull(FieldTenantID))
}

// TenantIDNotNil applies the NotNil predicate on the "tenant_id" field.
func TenantIDNotNil() predicate.ObjectStorage {
	return predicate.ObjectStorage(sql.FieldNotNull(FieldTenantID))
}

// TenantIDEqualFold applies the EqualFold predicate on the "tenant_id" field.
func TenantIDEqualFold(v string) predicate.ObjectStorage {
	return predicate.ObjectStorage(sql.FieldEqualFold(FieldTenantID, v))
}

// TenantIDContainsFold applies the ContainsFold predicate on the "tenant_id" field.
func TenantIDContainsFold(v string) predicate.ObjectStorage {
	return predicate.ObjectStorage(sql.FieldContainsFold(FieldTenantID, v))
}

// TenantNameEQ applies the EQ predicate on the "tenant_name" field.
func TenantNameEQ(v string) predicate.ObjectStorage {
	return predicate.ObjectStorage(sql.FieldEQ(FieldTenantName, v))
}

// TenantNameNEQ applies the NEQ predicate on the "tenant_name" field.
func TenantNameNEQ(v string) predicate.ObjectStorage {
	return predicate.ObjectStorage(sql.FieldNEQ(FieldTenantName, v))
}

// TenantNameIn applies the In predicate on the "tenant_name" field.
func TenantNameIn(vs ...string) predicate.ObjectStorage {
	return predicate.ObjectStorage(sql.FieldIn(FieldTenantName, vs...))
}

// TenantNameNotIn applies the NotIn predicate on the "tenant_name" field.
func TenantNameNotIn(vs ...string) predicate.ObjectStorage {
	return predicate.ObjectStorage(sql.FieldNotIn(FieldTenantName, vs...))
}

// TenantNameGT applies the GT predicate on the "tenant_name" field.
func TenantNameGT(v string) predicate.ObjectStorage {
	return predicate.ObjectStorage(sql.FieldGT(FieldTenantName, v))
}

// TenantNameGTE applies the GTE predicate on the "tenant_name" field.
func TenantNameGTE(v string) predicate.ObjectStorage {
	return predicate.ObjectStorage(sql.FieldGTE(FieldTenantName, v))
}

// TenantNameLT applies the LT predicate on the "tenant_name" field.
func TenantNameLT(v string) predicate.ObjectStorage {
	return predicate.ObjectStorage(sql.FieldLT(FieldTenantName, v))
}

// TenantNameLTE applies the LTE predicate on the "tenant_name" field.
func TenantNameLTE(v string) predicate.ObjectStorage {
	return predicate.ObjectStorage(sql.FieldLTE(FieldTenantName, v))
}

// TenantNameContains applies the Contains predicate on the "tenant_name" field.
func TenantNameContains(v string) predicate.ObjectStorage {
	return predicate.ObjectStorage(sql.FieldContains(FieldTenantName, v))
}

// TenantNameHasPrefix applies the HasPrefix predicate on the "tenant_name" field.
func TenantNameHasPrefix(v string) predicate.ObjectStorage {
	return predicate.ObjectStorage(sql.FieldHasPrefix(FieldTenantName, v))
}

// TenantNameHasSuffix applies the HasSuffix predicate on the "tenant_name" field.
func TenantNameHasSuffix(v string) predicate.ObjectStorage {
	return predicate.ObjectStorage(sql.FieldHasSuffix(FieldTenantName, v))
}

// TenantNameIsNil applies the IsNil predicate on the "tenant_name" field.
func TenantNameIsNil() predicate.ObjectStorage {
	return predicate.ObjectStorage(sql.FieldIsNull(FieldTenantName))
}

// TenantNameNotNil applies the NotNil predicate on the "tenant_name" field.
func TenantNameNotNil() predicate.ObjectStorage {
	return predicate.ObjectStorage(sql.FieldNotNull(FieldTenantName))
}

// TenantNameEqualFold applies the EqualFold predicate on the "tenant_name" field.
func TenantNameEqualFold(v string) predicate.ObjectStorage {
	return predicate.ObjectStorage(sql.FieldEqualFold(FieldTenantName, v))
}

// TenantNameContainsFold applies the ContainsFold predicate on the "tenant_name" field.
func TenantNameContainsFold(v string) predicate.ObjectStorage {
	return predicate.ObjectStorage(sql.FieldContainsFold(FieldTenantName, v))
}

// InnerDomainNameEQ applies the EQ predicate on the "inner_domain_name" field.
func InnerDomainNameEQ(v string) predicate.ObjectStorage {
	return predicate.ObjectStorage(sql.FieldEQ(FieldInnerDomainName, v))
}

// InnerDomainNameNEQ applies the NEQ predicate on the "inner_domain_name" field.
func InnerDomainNameNEQ(v string) predicate.ObjectStorage {
	return predicate.ObjectStorage(sql.FieldNEQ(FieldInnerDomainName, v))
}

// InnerDomainNameIn applies the In predicate on the "inner_domain_name" field.
func InnerDomainNameIn(vs ...string) predicate.ObjectStorage {
	return predicate.ObjectStorage(sql.FieldIn(FieldInnerDomainName, vs...))
}

// InnerDomainNameNotIn applies the NotIn predicate on the "inner_domain_name" field.
func InnerDomainNameNotIn(vs ...string) predicate.ObjectStorage {
	return predicate.ObjectStorage(sql.FieldNotIn(FieldInnerDomainName, vs...))
}

// InnerDomainNameGT applies the GT predicate on the "inner_domain_name" field.
func InnerDomainNameGT(v string) predicate.ObjectStorage {
	return predicate.ObjectStorage(sql.FieldGT(FieldInnerDomainName, v))
}

// InnerDomainNameGTE applies the GTE predicate on the "inner_domain_name" field.
func InnerDomainNameGTE(v string) predicate.ObjectStorage {
	return predicate.ObjectStorage(sql.FieldGTE(FieldInnerDomainName, v))
}

// InnerDomainNameLT applies the LT predicate on the "inner_domain_name" field.
func InnerDomainNameLT(v string) predicate.ObjectStorage {
	return predicate.ObjectStorage(sql.FieldLT(FieldInnerDomainName, v))
}

// InnerDomainNameLTE applies the LTE predicate on the "inner_domain_name" field.
func InnerDomainNameLTE(v string) predicate.ObjectStorage {
	return predicate.ObjectStorage(sql.FieldLTE(FieldInnerDomainName, v))
}

// InnerDomainNameContains applies the Contains predicate on the "inner_domain_name" field.
func InnerDomainNameContains(v string) predicate.ObjectStorage {
	return predicate.ObjectStorage(sql.FieldContains(FieldInnerDomainName, v))
}

// InnerDomainNameHasPrefix applies the HasPrefix predicate on the "inner_domain_name" field.
func InnerDomainNameHasPrefix(v string) predicate.ObjectStorage {
	return predicate.ObjectStorage(sql.FieldHasPrefix(FieldInnerDomainName, v))
}

// InnerDomainNameHasSuffix applies the HasSuffix predicate on the "inner_domain_name" field.
func InnerDomainNameHasSuffix(v string) predicate.ObjectStorage {
	return predicate.ObjectStorage(sql.FieldHasSuffix(FieldInnerDomainName, v))
}

// InnerDomainNameIsNil applies the IsNil predicate on the "inner_domain_name" field.
func InnerDomainNameIsNil() predicate.ObjectStorage {
	return predicate.ObjectStorage(sql.FieldIsNull(FieldInnerDomainName))
}

// InnerDomainNameNotNil applies the NotNil predicate on the "inner_domain_name" field.
func InnerDomainNameNotNil() predicate.ObjectStorage {
	return predicate.ObjectStorage(sql.FieldNotNull(FieldInnerDomainName))
}

// InnerDomainNameEqualFold applies the EqualFold predicate on the "inner_domain_name" field.
func InnerDomainNameEqualFold(v string) predicate.ObjectStorage {
	return predicate.ObjectStorage(sql.FieldEqualFold(FieldInnerDomainName, v))
}

// InnerDomainNameContainsFold applies the ContainsFold predicate on the "inner_domain_name" field.
func InnerDomainNameContainsFold(v string) predicate.ObjectStorage {
	return predicate.ObjectStorage(sql.FieldContainsFold(FieldInnerDomainName, v))
}

// OuterDomainNameEQ applies the EQ predicate on the "outer_domain_name" field.
func OuterDomainNameEQ(v string) predicate.ObjectStorage {
	return predicate.ObjectStorage(sql.FieldEQ(FieldOuterDomainName, v))
}

// OuterDomainNameNEQ applies the NEQ predicate on the "outer_domain_name" field.
func OuterDomainNameNEQ(v string) predicate.ObjectStorage {
	return predicate.ObjectStorage(sql.FieldNEQ(FieldOuterDomainName, v))
}

// OuterDomainNameIn applies the In predicate on the "outer_domain_name" field.
func OuterDomainNameIn(vs ...string) predicate.ObjectStorage {
	return predicate.ObjectStorage(sql.FieldIn(FieldOuterDomainName, vs...))
}

// OuterDomainNameNotIn applies the NotIn predicate on the "outer_domain_name" field.
func OuterDomainNameNotIn(vs ...string) predicate.ObjectStorage {
	return predicate.ObjectStorage(sql.FieldNotIn(FieldOuterDomainName, vs...))
}

// OuterDomainNameGT applies the GT predicate on the "outer_domain_name" field.
func OuterDomainNameGT(v string) predicate.ObjectStorage {
	return predicate.ObjectStorage(sql.FieldGT(FieldOuterDomainName, v))
}

// OuterDomainNameGTE applies the GTE predicate on the "outer_domain_name" field.
func OuterDomainNameGTE(v string) predicate.ObjectStorage {
	return predicate.ObjectStorage(sql.FieldGTE(FieldOuterDomainName, v))
}

// OuterDomainNameLT applies the LT predicate on the "outer_domain_name" field.
func OuterDomainNameLT(v string) predicate.ObjectStorage {
	return predicate.ObjectStorage(sql.FieldLT(FieldOuterDomainName, v))
}

// OuterDomainNameLTE applies the LTE predicate on the "outer_domain_name" field.
func OuterDomainNameLTE(v string) predicate.ObjectStorage {
	return predicate.ObjectStorage(sql.FieldLTE(FieldOuterDomainName, v))
}

// OuterDomainNameContains applies the Contains predicate on the "outer_domain_name" field.
func OuterDomainNameContains(v string) predicate.ObjectStorage {
	return predicate.ObjectStorage(sql.FieldContains(FieldOuterDomainName, v))
}

// OuterDomainNameHasPrefix applies the HasPrefix predicate on the "outer_domain_name" field.
func OuterDomainNameHasPrefix(v string) predicate.ObjectStorage {
	return predicate.ObjectStorage(sql.FieldHasPrefix(FieldOuterDomainName, v))
}

// OuterDomainNameHasSuffix applies the HasSuffix predicate on the "outer_domain_name" field.
func OuterDomainNameHasSuffix(v string) predicate.ObjectStorage {
	return predicate.ObjectStorage(sql.FieldHasSuffix(FieldOuterDomainName, v))
}

// OuterDomainNameIsNil applies the IsNil predicate on the "outer_domain_name" field.
func OuterDomainNameIsNil() predicate.ObjectStorage {
	return predicate.ObjectStorage(sql.FieldIsNull(FieldOuterDomainName))
}

// OuterDomainNameNotNil applies the NotNil predicate on the "outer_domain_name" field.
func OuterDomainNameNotNil() predicate.ObjectStorage {
	return predicate.ObjectStorage(sql.FieldNotNull(FieldOuterDomainName))
}

// OuterDomainNameEqualFold applies the EqualFold predicate on the "outer_domain_name" field.
func OuterDomainNameEqualFold(v string) predicate.ObjectStorage {
	return predicate.ObjectStorage(sql.FieldEqualFold(FieldOuterDomainName, v))
}

// OuterDomainNameContainsFold applies the ContainsFold predicate on the "outer_domain_name" field.
func OuterDomainNameContainsFold(v string) predicate.ObjectStorage {
	return predicate.ObjectStorage(sql.FieldContainsFold(FieldOuterDomainName, v))
}

// CreateTimeEQ applies the EQ predicate on the "create_time" field.
func CreateTimeEQ(v int) predicate.ObjectStorage {
	return predicate.ObjectStorage(sql.FieldEQ(FieldCreateTime, v))
}

// CreateTimeNEQ applies the NEQ predicate on the "create_time" field.
func CreateTimeNEQ(v int) predicate.ObjectStorage {
	return predicate.ObjectStorage(sql.FieldNEQ(FieldCreateTime, v))
}

// CreateTimeIn applies the In predicate on the "create_time" field.
func CreateTimeIn(vs ...int) predicate.ObjectStorage {
	return predicate.ObjectStorage(sql.FieldIn(FieldCreateTime, vs...))
}

// CreateTimeNotIn applies the NotIn predicate on the "create_time" field.
func CreateTimeNotIn(vs ...int) predicate.ObjectStorage {
	return predicate.ObjectStorage(sql.FieldNotIn(FieldCreateTime, vs...))
}

// CreateTimeGT applies the GT predicate on the "create_time" field.
func CreateTimeGT(v int) predicate.ObjectStorage {
	return predicate.ObjectStorage(sql.FieldGT(FieldCreateTime, v))
}

// CreateTimeGTE applies the GTE predicate on the "create_time" field.
func CreateTimeGTE(v int) predicate.ObjectStorage {
	return predicate.ObjectStorage(sql.FieldGTE(FieldCreateTime, v))
}

// CreateTimeLT applies the LT predicate on the "create_time" field.
func CreateTimeLT(v int) predicate.ObjectStorage {
	return predicate.ObjectStorage(sql.FieldLT(FieldCreateTime, v))
}

// CreateTimeLTE applies the LTE predicate on the "create_time" field.
func CreateTimeLTE(v int) predicate.ObjectStorage {
	return predicate.ObjectStorage(sql.FieldLTE(FieldCreateTime, v))
}

// CreateTimeIsNil applies the IsNil predicate on the "create_time" field.
func CreateTimeIsNil() predicate.ObjectStorage {
	return predicate.ObjectStorage(sql.FieldIsNull(FieldCreateTime))
}

// CreateTimeNotNil applies the NotNil predicate on the "create_time" field.
func CreateTimeNotNil() predicate.ObjectStorage {
	return predicate.ObjectStorage(sql.FieldNotNull(FieldCreateTime))
}

// PolicyEQ applies the EQ predicate on the "policy" field.
func PolicyEQ(v string) predicate.ObjectStorage {
	return predicate.ObjectStorage(sql.FieldEQ(FieldPolicy, v))
}

// PolicyNEQ applies the NEQ predicate on the "policy" field.
func PolicyNEQ(v string) predicate.ObjectStorage {
	return predicate.ObjectStorage(sql.FieldNEQ(FieldPolicy, v))
}

// PolicyIn applies the In predicate on the "policy" field.
func PolicyIn(vs ...string) predicate.ObjectStorage {
	return predicate.ObjectStorage(sql.FieldIn(FieldPolicy, vs...))
}

// PolicyNotIn applies the NotIn predicate on the "policy" field.
func PolicyNotIn(vs ...string) predicate.ObjectStorage {
	return predicate.ObjectStorage(sql.FieldNotIn(FieldPolicy, vs...))
}

// PolicyGT applies the GT predicate on the "policy" field.
func PolicyGT(v string) predicate.ObjectStorage {
	return predicate.ObjectStorage(sql.FieldGT(FieldPolicy, v))
}

// PolicyGTE applies the GTE predicate on the "policy" field.
func PolicyGTE(v string) predicate.ObjectStorage {
	return predicate.ObjectStorage(sql.FieldGTE(FieldPolicy, v))
}

// PolicyLT applies the LT predicate on the "policy" field.
func PolicyLT(v string) predicate.ObjectStorage {
	return predicate.ObjectStorage(sql.FieldLT(FieldPolicy, v))
}

// PolicyLTE applies the LTE predicate on the "policy" field.
func PolicyLTE(v string) predicate.ObjectStorage {
	return predicate.ObjectStorage(sql.FieldLTE(FieldPolicy, v))
}

// PolicyContains applies the Contains predicate on the "policy" field.
func PolicyContains(v string) predicate.ObjectStorage {
	return predicate.ObjectStorage(sql.FieldContains(FieldPolicy, v))
}

// PolicyHasPrefix applies the HasPrefix predicate on the "policy" field.
func PolicyHasPrefix(v string) predicate.ObjectStorage {
	return predicate.ObjectStorage(sql.FieldHasPrefix(FieldPolicy, v))
}

// PolicyHasSuffix applies the HasSuffix predicate on the "policy" field.
func PolicyHasSuffix(v string) predicate.ObjectStorage {
	return predicate.ObjectStorage(sql.FieldHasSuffix(FieldPolicy, v))
}

// PolicyIsNil applies the IsNil predicate on the "policy" field.
func PolicyIsNil() predicate.ObjectStorage {
	return predicate.ObjectStorage(sql.FieldIsNull(FieldPolicy))
}

// PolicyNotNil applies the NotNil predicate on the "policy" field.
func PolicyNotNil() predicate.ObjectStorage {
	return predicate.ObjectStorage(sql.FieldNotNull(FieldPolicy))
}

// PolicyEqualFold applies the EqualFold predicate on the "policy" field.
func PolicyEqualFold(v string) predicate.ObjectStorage {
	return predicate.ObjectStorage(sql.FieldEqualFold(FieldPolicy, v))
}

// PolicyContainsFold applies the ContainsFold predicate on the "policy" field.
func PolicyContainsFold(v string) predicate.ObjectStorage {
	return predicate.ObjectStorage(sql.FieldContainsFold(FieldPolicy, v))
}

// BucketDomainsEQ applies the EQ predicate on the "bucket_domains" field.
func BucketDomainsEQ(v string) predicate.ObjectStorage {
	return predicate.ObjectStorage(sql.FieldEQ(FieldBucketDomains, v))
}

// BucketDomainsNEQ applies the NEQ predicate on the "bucket_domains" field.
func BucketDomainsNEQ(v string) predicate.ObjectStorage {
	return predicate.ObjectStorage(sql.FieldNEQ(FieldBucketDomains, v))
}

// BucketDomainsIn applies the In predicate on the "bucket_domains" field.
func BucketDomainsIn(vs ...string) predicate.ObjectStorage {
	return predicate.ObjectStorage(sql.FieldIn(FieldBucketDomains, vs...))
}

// BucketDomainsNotIn applies the NotIn predicate on the "bucket_domains" field.
func BucketDomainsNotIn(vs ...string) predicate.ObjectStorage {
	return predicate.ObjectStorage(sql.FieldNotIn(FieldBucketDomains, vs...))
}

// BucketDomainsGT applies the GT predicate on the "bucket_domains" field.
func BucketDomainsGT(v string) predicate.ObjectStorage {
	return predicate.ObjectStorage(sql.FieldGT(FieldBucketDomains, v))
}

// BucketDomainsGTE applies the GTE predicate on the "bucket_domains" field.
func BucketDomainsGTE(v string) predicate.ObjectStorage {
	return predicate.ObjectStorage(sql.FieldGTE(FieldBucketDomains, v))
}

// BucketDomainsLT applies the LT predicate on the "bucket_domains" field.
func BucketDomainsLT(v string) predicate.ObjectStorage {
	return predicate.ObjectStorage(sql.FieldLT(FieldBucketDomains, v))
}

// BucketDomainsLTE applies the LTE predicate on the "bucket_domains" field.
func BucketDomainsLTE(v string) predicate.ObjectStorage {
	return predicate.ObjectStorage(sql.FieldLTE(FieldBucketDomains, v))
}

// BucketDomainsContains applies the Contains predicate on the "bucket_domains" field.
func BucketDomainsContains(v string) predicate.ObjectStorage {
	return predicate.ObjectStorage(sql.FieldContains(FieldBucketDomains, v))
}

// BucketDomainsHasPrefix applies the HasPrefix predicate on the "bucket_domains" field.
func BucketDomainsHasPrefix(v string) predicate.ObjectStorage {
	return predicate.ObjectStorage(sql.FieldHasPrefix(FieldBucketDomains, v))
}

// BucketDomainsHasSuffix applies the HasSuffix predicate on the "bucket_domains" field.
func BucketDomainsHasSuffix(v string) predicate.ObjectStorage {
	return predicate.ObjectStorage(sql.FieldHasSuffix(FieldBucketDomains, v))
}

// BucketDomainsIsNil applies the IsNil predicate on the "bucket_domains" field.
func BucketDomainsIsNil() predicate.ObjectStorage {
	return predicate.ObjectStorage(sql.FieldIsNull(FieldBucketDomains))
}

// BucketDomainsNotNil applies the NotNil predicate on the "bucket_domains" field.
func BucketDomainsNotNil() predicate.ObjectStorage {
	return predicate.ObjectStorage(sql.FieldNotNull(FieldBucketDomains))
}

// BucketDomainsEqualFold applies the EqualFold predicate on the "bucket_domains" field.
func BucketDomainsEqualFold(v string) predicate.ObjectStorage {
	return predicate.ObjectStorage(sql.FieldEqualFold(FieldBucketDomains, v))
}

// BucketDomainsContainsFold applies the ContainsFold predicate on the "bucket_domains" field.
func BucketDomainsContainsFold(v string) predicate.ObjectStorage {
	return predicate.ObjectStorage(sql.FieldContainsFold(FieldBucketDomains, v))
}

// ResourcePoolIDEQ applies the EQ predicate on the "resource_pool_id" field.
func ResourcePoolIDEQ(v int) predicate.ObjectStorage {
	return predicate.ObjectStorage(sql.FieldEQ(FieldResourcePoolID, v))
}

// ResourcePoolIDNEQ applies the NEQ predicate on the "resource_pool_id" field.
func ResourcePoolIDNEQ(v int) predicate.ObjectStorage {
	return predicate.ObjectStorage(sql.FieldNEQ(FieldResourcePoolID, v))
}

// ResourcePoolIDIn applies the In predicate on the "resource_pool_id" field.
func ResourcePoolIDIn(vs ...int) predicate.ObjectStorage {
	return predicate.ObjectStorage(sql.FieldIn(FieldResourcePoolID, vs...))
}

// ResourcePoolIDNotIn applies the NotIn predicate on the "resource_pool_id" field.
func ResourcePoolIDNotIn(vs ...int) predicate.ObjectStorage {
	return predicate.ObjectStorage(sql.FieldNotIn(FieldResourcePoolID, vs...))
}

// ResourcePoolIDGT applies the GT predicate on the "resource_pool_id" field.
func ResourcePoolIDGT(v int) predicate.ObjectStorage {
	return predicate.ObjectStorage(sql.FieldGT(FieldResourcePoolID, v))
}

// ResourcePoolIDGTE applies the GTE predicate on the "resource_pool_id" field.
func ResourcePoolIDGTE(v int) predicate.ObjectStorage {
	return predicate.ObjectStorage(sql.FieldGTE(FieldResourcePoolID, v))
}

// ResourcePoolIDLT applies the LT predicate on the "resource_pool_id" field.
func ResourcePoolIDLT(v int) predicate.ObjectStorage {
	return predicate.ObjectStorage(sql.FieldLT(FieldResourcePoolID, v))
}

// ResourcePoolIDLTE applies the LTE predicate on the "resource_pool_id" field.
func ResourcePoolIDLTE(v int) predicate.ObjectStorage {
	return predicate.ObjectStorage(sql.FieldLTE(FieldResourcePoolID, v))
}

// ResourcePoolIDIsNil applies the IsNil predicate on the "resource_pool_id" field.
func ResourcePoolIDIsNil() predicate.ObjectStorage {
	return predicate.ObjectStorage(sql.FieldIsNull(FieldResourcePoolID))
}

// ResourcePoolIDNotNil applies the NotNil predicate on the "resource_pool_id" field.
func ResourcePoolIDNotNil() predicate.ObjectStorage {
	return predicate.ObjectStorage(sql.FieldNotNull(FieldResourcePoolID))
}

// ResourcePoolNameEQ applies the EQ predicate on the "resource_pool_name" field.
func ResourcePoolNameEQ(v string) predicate.ObjectStorage {
	return predicate.ObjectStorage(sql.FieldEQ(FieldResourcePoolName, v))
}

// ResourcePoolNameNEQ applies the NEQ predicate on the "resource_pool_name" field.
func ResourcePoolNameNEQ(v string) predicate.ObjectStorage {
	return predicate.ObjectStorage(sql.FieldNEQ(FieldResourcePoolName, v))
}

// ResourcePoolNameIn applies the In predicate on the "resource_pool_name" field.
func ResourcePoolNameIn(vs ...string) predicate.ObjectStorage {
	return predicate.ObjectStorage(sql.FieldIn(FieldResourcePoolName, vs...))
}

// ResourcePoolNameNotIn applies the NotIn predicate on the "resource_pool_name" field.
func ResourcePoolNameNotIn(vs ...string) predicate.ObjectStorage {
	return predicate.ObjectStorage(sql.FieldNotIn(FieldResourcePoolName, vs...))
}

// ResourcePoolNameGT applies the GT predicate on the "resource_pool_name" field.
func ResourcePoolNameGT(v string) predicate.ObjectStorage {
	return predicate.ObjectStorage(sql.FieldGT(FieldResourcePoolName, v))
}

// ResourcePoolNameGTE applies the GTE predicate on the "resource_pool_name" field.
func ResourcePoolNameGTE(v string) predicate.ObjectStorage {
	return predicate.ObjectStorage(sql.FieldGTE(FieldResourcePoolName, v))
}

// ResourcePoolNameLT applies the LT predicate on the "resource_pool_name" field.
func ResourcePoolNameLT(v string) predicate.ObjectStorage {
	return predicate.ObjectStorage(sql.FieldLT(FieldResourcePoolName, v))
}

// ResourcePoolNameLTE applies the LTE predicate on the "resource_pool_name" field.
func ResourcePoolNameLTE(v string) predicate.ObjectStorage {
	return predicate.ObjectStorage(sql.FieldLTE(FieldResourcePoolName, v))
}

// ResourcePoolNameContains applies the Contains predicate on the "resource_pool_name" field.
func ResourcePoolNameContains(v string) predicate.ObjectStorage {
	return predicate.ObjectStorage(sql.FieldContains(FieldResourcePoolName, v))
}

// ResourcePoolNameHasPrefix applies the HasPrefix predicate on the "resource_pool_name" field.
func ResourcePoolNameHasPrefix(v string) predicate.ObjectStorage {
	return predicate.ObjectStorage(sql.FieldHasPrefix(FieldResourcePoolName, v))
}

// ResourcePoolNameHasSuffix applies the HasSuffix predicate on the "resource_pool_name" field.
func ResourcePoolNameHasSuffix(v string) predicate.ObjectStorage {
	return predicate.ObjectStorage(sql.FieldHasSuffix(FieldResourcePoolName, v))
}

// ResourcePoolNameIsNil applies the IsNil predicate on the "resource_pool_name" field.
func ResourcePoolNameIsNil() predicate.ObjectStorage {
	return predicate.ObjectStorage(sql.FieldIsNull(FieldResourcePoolName))
}

// ResourcePoolNameNotNil applies the NotNil predicate on the "resource_pool_name" field.
func ResourcePoolNameNotNil() predicate.ObjectStorage {
	return predicate.ObjectStorage(sql.FieldNotNull(FieldResourcePoolName))
}

// ResourcePoolNameEqualFold applies the EqualFold predicate on the "resource_pool_name" field.
func ResourcePoolNameEqualFold(v string) predicate.ObjectStorage {
	return predicate.ObjectStorage(sql.FieldEqualFold(FieldResourcePoolName, v))
}

// ResourcePoolNameContainsFold applies the ContainsFold predicate on the "resource_pool_name" field.
func ResourcePoolNameContainsFold(v string) predicate.ObjectStorage {
	return predicate.ObjectStorage(sql.FieldContainsFold(FieldResourcePoolName, v))
}

// ObjectCountEQ applies the EQ predicate on the "object_count" field.
func ObjectCountEQ(v int) predicate.ObjectStorage {
	return predicate.ObjectStorage(sql.FieldEQ(FieldObjectCount, v))
}

// ObjectCountNEQ applies the NEQ predicate on the "object_count" field.
func ObjectCountNEQ(v int) predicate.ObjectStorage {
	return predicate.ObjectStorage(sql.FieldNEQ(FieldObjectCount, v))
}

// ObjectCountIn applies the In predicate on the "object_count" field.
func ObjectCountIn(vs ...int) predicate.ObjectStorage {
	return predicate.ObjectStorage(sql.FieldIn(FieldObjectCount, vs...))
}

// ObjectCountNotIn applies the NotIn predicate on the "object_count" field.
func ObjectCountNotIn(vs ...int) predicate.ObjectStorage {
	return predicate.ObjectStorage(sql.FieldNotIn(FieldObjectCount, vs...))
}

// ObjectCountGT applies the GT predicate on the "object_count" field.
func ObjectCountGT(v int) predicate.ObjectStorage {
	return predicate.ObjectStorage(sql.FieldGT(FieldObjectCount, v))
}

// ObjectCountGTE applies the GTE predicate on the "object_count" field.
func ObjectCountGTE(v int) predicate.ObjectStorage {
	return predicate.ObjectStorage(sql.FieldGTE(FieldObjectCount, v))
}

// ObjectCountLT applies the LT predicate on the "object_count" field.
func ObjectCountLT(v int) predicate.ObjectStorage {
	return predicate.ObjectStorage(sql.FieldLT(FieldObjectCount, v))
}

// ObjectCountLTE applies the LTE predicate on the "object_count" field.
func ObjectCountLTE(v int) predicate.ObjectStorage {
	return predicate.ObjectStorage(sql.FieldLTE(FieldObjectCount, v))
}

// ObjectCountIsNil applies the IsNil predicate on the "object_count" field.
func ObjectCountIsNil() predicate.ObjectStorage {
	return predicate.ObjectStorage(sql.FieldIsNull(FieldObjectCount))
}

// ObjectCountNotNil applies the NotNil predicate on the "object_count" field.
func ObjectCountNotNil() predicate.ObjectStorage {
	return predicate.ObjectStorage(sql.FieldNotNull(FieldObjectCount))
}

// CurrentSizeEQ applies the EQ predicate on the "current_size" field.
func CurrentSizeEQ(v int) predicate.ObjectStorage {
	return predicate.ObjectStorage(sql.FieldEQ(FieldCurrentSize, v))
}

// CurrentSizeNEQ applies the NEQ predicate on the "current_size" field.
func CurrentSizeNEQ(v int) predicate.ObjectStorage {
	return predicate.ObjectStorage(sql.FieldNEQ(FieldCurrentSize, v))
}

// CurrentSizeIn applies the In predicate on the "current_size" field.
func CurrentSizeIn(vs ...int) predicate.ObjectStorage {
	return predicate.ObjectStorage(sql.FieldIn(FieldCurrentSize, vs...))
}

// CurrentSizeNotIn applies the NotIn predicate on the "current_size" field.
func CurrentSizeNotIn(vs ...int) predicate.ObjectStorage {
	return predicate.ObjectStorage(sql.FieldNotIn(FieldCurrentSize, vs...))
}

// CurrentSizeGT applies the GT predicate on the "current_size" field.
func CurrentSizeGT(v int) predicate.ObjectStorage {
	return predicate.ObjectStorage(sql.FieldGT(FieldCurrentSize, v))
}

// CurrentSizeGTE applies the GTE predicate on the "current_size" field.
func CurrentSizeGTE(v int) predicate.ObjectStorage {
	return predicate.ObjectStorage(sql.FieldGTE(FieldCurrentSize, v))
}

// CurrentSizeLT applies the LT predicate on the "current_size" field.
func CurrentSizeLT(v int) predicate.ObjectStorage {
	return predicate.ObjectStorage(sql.FieldLT(FieldCurrentSize, v))
}

// CurrentSizeLTE applies the LTE predicate on the "current_size" field.
func CurrentSizeLTE(v int) predicate.ObjectStorage {
	return predicate.ObjectStorage(sql.FieldLTE(FieldCurrentSize, v))
}

// CurrentSizeIsNil applies the IsNil predicate on the "current_size" field.
func CurrentSizeIsNil() predicate.ObjectStorage {
	return predicate.ObjectStorage(sql.FieldIsNull(FieldCurrentSize))
}

// CurrentSizeNotNil applies the NotNil predicate on the "current_size" field.
func CurrentSizeNotNil() predicate.ObjectStorage {
	return predicate.ObjectStorage(sql.FieldNotNull(FieldCurrentSize))
}

// Last30DayDownloadEQ applies the EQ predicate on the "last30_day_download" field.
func Last30DayDownloadEQ(v int) predicate.ObjectStorage {
	return predicate.ObjectStorage(sql.FieldEQ(FieldLast30DayDownload, v))
}

// Last30DayDownloadNEQ applies the NEQ predicate on the "last30_day_download" field.
func Last30DayDownloadNEQ(v int) predicate.ObjectStorage {
	return predicate.ObjectStorage(sql.FieldNEQ(FieldLast30DayDownload, v))
}

// Last30DayDownloadIn applies the In predicate on the "last30_day_download" field.
func Last30DayDownloadIn(vs ...int) predicate.ObjectStorage {
	return predicate.ObjectStorage(sql.FieldIn(FieldLast30DayDownload, vs...))
}

// Last30DayDownloadNotIn applies the NotIn predicate on the "last30_day_download" field.
func Last30DayDownloadNotIn(vs ...int) predicate.ObjectStorage {
	return predicate.ObjectStorage(sql.FieldNotIn(FieldLast30DayDownload, vs...))
}

// Last30DayDownloadGT applies the GT predicate on the "last30_day_download" field.
func Last30DayDownloadGT(v int) predicate.ObjectStorage {
	return predicate.ObjectStorage(sql.FieldGT(FieldLast30DayDownload, v))
}

// Last30DayDownloadGTE applies the GTE predicate on the "last30_day_download" field.
func Last30DayDownloadGTE(v int) predicate.ObjectStorage {
	return predicate.ObjectStorage(sql.FieldGTE(FieldLast30DayDownload, v))
}

// Last30DayDownloadLT applies the LT predicate on the "last30_day_download" field.
func Last30DayDownloadLT(v int) predicate.ObjectStorage {
	return predicate.ObjectStorage(sql.FieldLT(FieldLast30DayDownload, v))
}

// Last30DayDownloadLTE applies the LTE predicate on the "last30_day_download" field.
func Last30DayDownloadLTE(v int) predicate.ObjectStorage {
	return predicate.ObjectStorage(sql.FieldLTE(FieldLast30DayDownload, v))
}

// Last30DayDownloadIsNil applies the IsNil predicate on the "last30_day_download" field.
func Last30DayDownloadIsNil() predicate.ObjectStorage {
	return predicate.ObjectStorage(sql.FieldIsNull(FieldLast30DayDownload))
}

// Last30DayDownloadNotNil applies the NotNil predicate on the "last30_day_download" field.
func Last30DayDownloadNotNil() predicate.ObjectStorage {
	return predicate.ObjectStorage(sql.FieldNotNull(FieldLast30DayDownload))
}

// Last30DayAPICallTimesEQ applies the EQ predicate on the "last30_day_api_call_times" field.
func Last30DayAPICallTimesEQ(v int) predicate.ObjectStorage {
	return predicate.ObjectStorage(sql.FieldEQ(FieldLast30DayAPICallTimes, v))
}

// Last30DayAPICallTimesNEQ applies the NEQ predicate on the "last30_day_api_call_times" field.
func Last30DayAPICallTimesNEQ(v int) predicate.ObjectStorage {
	return predicate.ObjectStorage(sql.FieldNEQ(FieldLast30DayAPICallTimes, v))
}

// Last30DayAPICallTimesIn applies the In predicate on the "last30_day_api_call_times" field.
func Last30DayAPICallTimesIn(vs ...int) predicate.ObjectStorage {
	return predicate.ObjectStorage(sql.FieldIn(FieldLast30DayAPICallTimes, vs...))
}

// Last30DayAPICallTimesNotIn applies the NotIn predicate on the "last30_day_api_call_times" field.
func Last30DayAPICallTimesNotIn(vs ...int) predicate.ObjectStorage {
	return predicate.ObjectStorage(sql.FieldNotIn(FieldLast30DayAPICallTimes, vs...))
}

// Last30DayAPICallTimesGT applies the GT predicate on the "last30_day_api_call_times" field.
func Last30DayAPICallTimesGT(v int) predicate.ObjectStorage {
	return predicate.ObjectStorage(sql.FieldGT(FieldLast30DayAPICallTimes, v))
}

// Last30DayAPICallTimesGTE applies the GTE predicate on the "last30_day_api_call_times" field.
func Last30DayAPICallTimesGTE(v int) predicate.ObjectStorage {
	return predicate.ObjectStorage(sql.FieldGTE(FieldLast30DayAPICallTimes, v))
}

// Last30DayAPICallTimesLT applies the LT predicate on the "last30_day_api_call_times" field.
func Last30DayAPICallTimesLT(v int) predicate.ObjectStorage {
	return predicate.ObjectStorage(sql.FieldLT(FieldLast30DayAPICallTimes, v))
}

// Last30DayAPICallTimesLTE applies the LTE predicate on the "last30_day_api_call_times" field.
func Last30DayAPICallTimesLTE(v int) predicate.ObjectStorage {
	return predicate.ObjectStorage(sql.FieldLTE(FieldLast30DayAPICallTimes, v))
}

// Last30DayAPICallTimesIsNil applies the IsNil predicate on the "last30_day_api_call_times" field.
func Last30DayAPICallTimesIsNil() predicate.ObjectStorage {
	return predicate.ObjectStorage(sql.FieldIsNull(FieldLast30DayAPICallTimes))
}

// Last30DayAPICallTimesNotNil applies the NotNil predicate on the "last30_day_api_call_times" field.
func Last30DayAPICallTimesNotNil() predicate.ObjectStorage {
	return predicate.ObjectStorage(sql.FieldNotNull(FieldLast30DayAPICallTimes))
}

// LastUpdateTimeEQ applies the EQ predicate on the "last_update_time" field.
func LastUpdateTimeEQ(v time.Time) predicate.ObjectStorage {
	return predicate.ObjectStorage(sql.FieldEQ(FieldLastUpdateTime, v))
}

// LastUpdateTimeNEQ applies the NEQ predicate on the "last_update_time" field.
func LastUpdateTimeNEQ(v time.Time) predicate.ObjectStorage {
	return predicate.ObjectStorage(sql.FieldNEQ(FieldLastUpdateTime, v))
}

// LastUpdateTimeIn applies the In predicate on the "last_update_time" field.
func LastUpdateTimeIn(vs ...time.Time) predicate.ObjectStorage {
	return predicate.ObjectStorage(sql.FieldIn(FieldLastUpdateTime, vs...))
}

// LastUpdateTimeNotIn applies the NotIn predicate on the "last_update_time" field.
func LastUpdateTimeNotIn(vs ...time.Time) predicate.ObjectStorage {
	return predicate.ObjectStorage(sql.FieldNotIn(FieldLastUpdateTime, vs...))
}

// LastUpdateTimeGT applies the GT predicate on the "last_update_time" field.
func LastUpdateTimeGT(v time.Time) predicate.ObjectStorage {
	return predicate.ObjectStorage(sql.FieldGT(FieldLastUpdateTime, v))
}

// LastUpdateTimeGTE applies the GTE predicate on the "last_update_time" field.
func LastUpdateTimeGTE(v time.Time) predicate.ObjectStorage {
	return predicate.ObjectStorage(sql.FieldGTE(FieldLastUpdateTime, v))
}

// LastUpdateTimeLT applies the LT predicate on the "last_update_time" field.
func LastUpdateTimeLT(v time.Time) predicate.ObjectStorage {
	return predicate.ObjectStorage(sql.FieldLT(FieldLastUpdateTime, v))
}

// LastUpdateTimeLTE applies the LTE predicate on the "last_update_time" field.
func LastUpdateTimeLTE(v time.Time) predicate.ObjectStorage {
	return predicate.ObjectStorage(sql.FieldLTE(FieldLastUpdateTime, v))
}

// And groups predicates with the AND operator between them.
func And(predicates ...predicate.ObjectStorage) predicate.ObjectStorage {
	return predicate.ObjectStorage(func(s *sql.Selector) {
		s1 := s.Clone().SetP(nil)
		for _, p := range predicates {
			p(s1)
		}
		s.Where(s1.P())
	})
}

// Or groups predicates with the OR operator between them.
func Or(predicates ...predicate.ObjectStorage) predicate.ObjectStorage {
	return predicate.ObjectStorage(func(s *sql.Selector) {
		s1 := s.Clone().SetP(nil)
		for i, p := range predicates {
			if i > 0 {
				s1.Or()
			}
			p(s1)
		}
		s.Where(s1.P())
	})
}

// Not applies the not operator on the given predicate.
func Not(p predicate.ObjectStorage) predicate.ObjectStorage {
	return predicate.ObjectStorage(func(s *sql.Selector) {
		p(s.Not())
	})
}

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/data/ent/enttest/enttest.go
```golang
// Code generated by ent, DO NOT EDIT.

package enttest

import (
	"context"
	"luban-cmdb-api/data/ent"
	// required by schema hooks.
	_ "luban-cmdb-api/data/ent/runtime"

	"luban-cmdb-api/data/ent/migrate"

	"entgo.io/ent/dialect/sql/schema"
)

type (
	// TestingT is the interface that is shared between
	// testing.T and testing.B and used by enttest.
	TestingT interface {
		FailNow()
		Error(...any)
	}

	// Option configures client creation.
	Option func(*options)

	options struct {
		opts        []ent.Option
		migrateOpts []schema.MigrateOption
	}
)

// WithOptions forwards options to client creation.
func WithOptions(opts ...ent.Option) Option {
	return func(o *options) {
		o.opts = append(o.opts, opts...)
	}
}

// WithMigrateOptions forwards options to auto migration.
func WithMigrateOptions(opts ...schema.MigrateOption) Option {
	return func(o *options) {
		o.migrateOpts = append(o.migrateOpts, opts...)
	}
}

func newOptions(opts []Option) *options {
	o := &options{}
	for _, opt := range opts {
		opt(o)
	}
	return o
}

// Open calls ent.Open and auto-run migration.
func Open(t TestingT, driverName, dataSourceName string, opts ...Option) *ent.Client {
	o := newOptions(opts)
	c, err := ent.Open(driverName, dataSourceName, o.opts...)
	if err != nil {
		t.Error(err)
		t.FailNow()
	}
	migrateSchema(t, c, o)
	return c
}

// NewClient calls ent.NewClient and auto-run migration.
func NewClient(t TestingT, opts ...Option) *ent.Client {
	o := newOptions(opts)
	c := ent.NewClient(o.opts...)
	migrateSchema(t, c, o)
	return c
}
func migrateSchema(t TestingT, c *ent.Client, o *options) {
	tables, err := schema.CopyTables(migrate.Tables)
	if err != nil {
		t.Error(err)
		t.FailNow()
	}
	if err := migrate.Create(context.Background(), c.Schema, tables, o.migrateOpts...); err != nil {
		t.Error(err)
		t.FailNow()
	}
}

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/data/ent/blockstorage/blockstorage.go
```golang
// Code generated by ent, DO NOT EDIT.

package blockstorage

const (
	// Label holds the string label denoting the blockstorage type in the database.
	Label = "block_storage"
	// FieldID holds the string denoting the id field in the database.
	FieldID = "id"
	// FieldName holds the string denoting the name field in the database.
	FieldName = "name"
	// FieldInstanceID holds the string denoting the instance_id field in the database.
	FieldInstanceID = "instance_id"
	// FieldRegion holds the string denoting the region field in the database.
	FieldRegion = "region"
	// FieldRegionCode holds the string denoting the region_code field in the database.
	FieldRegionCode = "region_code"
	// FieldAz holds the string denoting the az field in the database.
	FieldAz = "az"
	// FieldAzCode holds the string denoting the az_code field in the database.
	FieldAzCode = "az_code"
	// FieldResourcePool holds the string denoting the resource_pool field in the database.
	FieldResourcePool = "resource_pool"
	// FieldResourcePoolType holds the string denoting the resource_pool_type field in the database.
	FieldResourcePoolType = "resource_pool_type"
	// FieldUseStatus holds the string denoting the use_status field in the database.
	FieldUseStatus = "use_status"
	// FieldTenantID holds the string denoting the tenant_id field in the database.
	FieldTenantID = "tenant_id"
	// FieldTenantName holds the string denoting the tenant_name field in the database.
	FieldTenantName = "tenant_name"
	// FieldVM holds the string denoting the vm field in the database.
	FieldVM = "vm"
	// FieldVMID holds the string denoting the vm_id field in the database.
	FieldVMID = "vm_id"
	// FieldCreateTime holds the string denoting the create_time field in the database.
	FieldCreateTime = "create_time"
	// FieldSize holds the string denoting the size field in the database.
	FieldSize = "size"
	// FieldMountPoint holds the string denoting the mount_point field in the database.
	FieldMountPoint = "mount_point"
	// FieldLastUpdateTime holds the string denoting the last_update_time field in the database.
	FieldLastUpdateTime = "last_update_time"
	// Table holds the table name of the blockstorage in the database.
	Table = "block_storage"
)

// Columns holds all SQL columns for blockstorage fields.
var Columns = []string{
	FieldID,
	FieldName,
	FieldInstanceID,
	FieldRegion,
	FieldRegionCode,
	FieldAz,
	FieldAzCode,
	FieldResourcePool,
	FieldResourcePoolType,
	FieldUseStatus,
	FieldTenantID,
	FieldTenantName,
	FieldVM,
	FieldVMID,
	FieldCreateTime,
	FieldSize,
	FieldMountPoint,
	FieldLastUpdateTime,
}

// ValidColumn reports if the column name is valid (part of the table columns).
func ValidColumn(column string) bool {
	for i := range Columns {
		if column == Columns[i] {
			return true
		}
	}
	return false
}

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/data/ent/blockstorage/where.go
```golang
// Code generated by ent, DO NOT EDIT.

package blockstorage

import (
	"luban-cmdb-api/data/ent/predicate"
	"time"

	"entgo.io/ent/dialect/sql"
)

// ID filters vertices based on their ID field.
func ID(id int) predicate.BlockStorage {
	return predicate.BlockStorage(sql.FieldEQ(FieldID, id))
}

// IDEQ applies the EQ predicate on the ID field.
func IDEQ(id int) predicate.BlockStorage {
	return predicate.BlockStorage(sql.FieldEQ(FieldID, id))
}

// IDNEQ applies the NEQ predicate on the ID field.
func IDNEQ(id int) predicate.BlockStorage {
	return predicate.BlockStorage(sql.FieldNEQ(FieldID, id))
}

// IDIn applies the In predicate on the ID field.
func IDIn(ids ...int) predicate.BlockStorage {
	return predicate.BlockStorage(sql.FieldIn(FieldID, ids...))
}

// IDNotIn applies the NotIn predicate on the ID field.
func IDNotIn(ids ...int) predicate.BlockStorage {
	return predicate.BlockStorage(sql.FieldNotIn(FieldID, ids...))
}

// IDGT applies the GT predicate on the ID field.
func IDGT(id int) predicate.BlockStorage {
	return predicate.BlockStorage(sql.FieldGT(FieldID, id))
}

// IDGTE applies the GTE predicate on the ID field.
func IDGTE(id int) predicate.BlockStorage {
	return predicate.BlockStorage(sql.FieldGTE(FieldID, id))
}

// IDLT applies the LT predicate on the ID field.
func IDLT(id int) predicate.BlockStorage {
	return predicate.BlockStorage(sql.FieldLT(FieldID, id))
}

// IDLTE applies the LTE predicate on the ID field.
func IDLTE(id int) predicate.BlockStorage {
	return predicate.BlockStorage(sql.FieldLTE(FieldID, id))
}

// Name applies equality check predicate on the "name" field. It's identical to NameEQ.
func Name(v string) predicate.BlockStorage {
	return predicate.BlockStorage(sql.FieldEQ(FieldName, v))
}

// InstanceID applies equality check predicate on the "instance_id" field. It's identical to InstanceIDEQ.
func InstanceID(v string) predicate.BlockStorage {
	return predicate.BlockStorage(sql.FieldEQ(FieldInstanceID, v))
}

// Region applies equality check predicate on the "region" field. It's identical to RegionEQ.
func Region(v string) predicate.BlockStorage {
	return predicate.BlockStorage(sql.FieldEQ(FieldRegion, v))
}

// RegionCode applies equality check predicate on the "region_code" field. It's identical to RegionCodeEQ.
func RegionCode(v string) predicate.BlockStorage {
	return predicate.BlockStorage(sql.FieldEQ(FieldRegionCode, v))
}

// Az applies equality check predicate on the "az" field. It's identical to AzEQ.
func Az(v string) predicate.BlockStorage {
	return predicate.BlockStorage(sql.FieldEQ(FieldAz, v))
}

// AzCode applies equality check predicate on the "az_code" field. It's identical to AzCodeEQ.
func AzCode(v string) predicate.BlockStorage {
	return predicate.BlockStorage(sql.FieldEQ(FieldAzCode, v))
}

// ResourcePool applies equality check predicate on the "resource_pool" field. It's identical to ResourcePoolEQ.
func ResourcePool(v string) predicate.BlockStorage {
	return predicate.BlockStorage(sql.FieldEQ(FieldResourcePool, v))
}

// ResourcePoolType applies equality check predicate on the "resource_pool_type" field. It's identical to ResourcePoolTypeEQ.
func ResourcePoolType(v string) predicate.BlockStorage {
	return predicate.BlockStorage(sql.FieldEQ(FieldResourcePoolType, v))
}

// UseStatus applies equality check predicate on the "use_status" field. It's identical to UseStatusEQ.
func UseStatus(v string) predicate.BlockStorage {
	return predicate.BlockStorage(sql.FieldEQ(FieldUseStatus, v))
}

// TenantID applies equality check predicate on the "tenant_id" field. It's identical to TenantIDEQ.
func TenantID(v string) predicate.BlockStorage {
	return predicate.BlockStorage(sql.FieldEQ(FieldTenantID, v))
}

// TenantName applies equality check predicate on the "tenant_name" field. It's identical to TenantNameEQ.
func TenantName(v string) predicate.BlockStorage {
	return predicate.BlockStorage(sql.FieldEQ(FieldTenantName, v))
}

// VM applies equality check predicate on the "vm" field. It's identical to VMEQ.
func VM(v string) predicate.BlockStorage {
	return predicate.BlockStorage(sql.FieldEQ(FieldVM, v))
}

// VMID applies equality check predicate on the "vm_id" field. It's identical to VMIDEQ.
func VMID(v string) predicate.BlockStorage {
	return predicate.BlockStorage(sql.FieldEQ(FieldVMID, v))
}

// CreateTime applies equality check predicate on the "create_time" field. It's identical to CreateTimeEQ.
func CreateTime(v int) predicate.BlockStorage {
	return predicate.BlockStorage(sql.FieldEQ(FieldCreateTime, v))
}

// Size applies equality check predicate on the "size" field. It's identical to SizeEQ.
func Size(v int32) predicate.BlockStorage {
	return predicate.BlockStorage(sql.FieldEQ(FieldSize, v))
}

// MountPoint applies equality check predicate on the "mount_point" field. It's identical to MountPointEQ.
func MountPoint(v string) predicate.BlockStorage {
	return predicate.BlockStorage(sql.FieldEQ(FieldMountPoint, v))
}

// LastUpdateTime applies equality check predicate on the "last_update_time" field. It's identical to LastUpdateTimeEQ.
func LastUpdateTime(v time.Time) predicate.BlockStorage {
	return predicate.BlockStorage(sql.FieldEQ(FieldLastUpdateTime, v))
}

// NameEQ applies the EQ predicate on the "name" field.
func NameEQ(v string) predicate.BlockStorage {
	return predicate.BlockStorage(sql.FieldEQ(FieldName, v))
}

// NameNEQ applies the NEQ predicate on the "name" field.
func NameNEQ(v string) predicate.BlockStorage {
	return predicate.BlockStorage(sql.FieldNEQ(FieldName, v))
}

// NameIn applies the In predicate on the "name" field.
func NameIn(vs ...string) predicate.BlockStorage {
	return predicate.BlockStorage(sql.FieldIn(FieldName, vs...))
}

// NameNotIn applies the NotIn predicate on the "name" field.
func NameNotIn(vs ...string) predicate.BlockStorage {
	return predicate.BlockStorage(sql.FieldNotIn(FieldName, vs...))
}

// NameGT applies the GT predicate on the "name" field.
func NameGT(v string) predicate.BlockStorage {
	return predicate.BlockStorage(sql.FieldGT(FieldName, v))
}

// NameGTE applies the GTE predicate on the "name" field.
func NameGTE(v string) predicate.BlockStorage {
	return predicate.BlockStorage(sql.FieldGTE(FieldName, v))
}

// NameLT applies the LT predicate on the "name" field.
func NameLT(v string) predicate.BlockStorage {
	return predicate.BlockStorage(sql.FieldLT(FieldName, v))
}

// NameLTE applies the LTE predicate on the "name" field.
func NameLTE(v string) predicate.BlockStorage {
	return predicate.BlockStorage(sql.FieldLTE(FieldName, v))
}

// NameContains applies the Contains predicate on the "name" field.
func NameContains(v string) predicate.BlockStorage {
	return predicate.BlockStorage(sql.FieldContains(FieldName, v))
}

// NameHasPrefix applies the HasPrefix predicate on the "name" field.
func NameHasPrefix(v string) predicate.BlockStorage {
	return predicate.BlockStorage(sql.FieldHasPrefix(FieldName, v))
}

// NameHasSuffix applies the HasSuffix predicate on the "name" field.
func NameHasSuffix(v string) predicate.BlockStorage {
	return predicate.BlockStorage(sql.FieldHasSuffix(FieldName, v))
}

// NameEqualFold applies the EqualFold predicate on the "name" field.
func NameEqualFold(v string) predicate.BlockStorage {
	return predicate.BlockStorage(sql.FieldEqualFold(FieldName, v))
}

// NameContainsFold applies the ContainsFold predicate on the "name" field.
func NameContainsFold(v string) predicate.BlockStorage {
	return predicate.BlockStorage(sql.FieldContainsFold(FieldName, v))
}

// InstanceIDEQ applies the EQ predicate on the "instance_id" field.
func InstanceIDEQ(v string) predicate.BlockStorage {
	return predicate.BlockStorage(sql.FieldEQ(FieldInstanceID, v))
}

// InstanceIDNEQ applies the NEQ predicate on the "instance_id" field.
func InstanceIDNEQ(v string) predicate.BlockStorage {
	return predicate.BlockStorage(sql.FieldNEQ(FieldInstanceID, v))
}

// InstanceIDIn applies the In predicate on the "instance_id" field.
func InstanceIDIn(vs ...string) predicate.BlockStorage {
	return predicate.BlockStorage(sql.FieldIn(FieldInstanceID, vs...))
}

// InstanceIDNotIn applies the NotIn predicate on the "instance_id" field.
func InstanceIDNotIn(vs ...string) predicate.BlockStorage {
	return predicate.BlockStorage(sql.FieldNotIn(FieldInstanceID, vs...))
}

// InstanceIDGT applies the GT predicate on the "instance_id" field.
func InstanceIDGT(v string) predicate.BlockStorage {
	return predicate.BlockStorage(sql.FieldGT(FieldInstanceID, v))
}

// InstanceIDGTE applies the GTE predicate on the "instance_id" field.
func InstanceIDGTE(v string) predicate.BlockStorage {
	return predicate.BlockStorage(sql.FieldGTE(FieldInstanceID, v))
}

// InstanceIDLT applies the LT predicate on the "instance_id" field.
func InstanceIDLT(v string) predicate.BlockStorage {
	return predicate.BlockStorage(sql.FieldLT(FieldInstanceID, v))
}

// InstanceIDLTE applies the LTE predicate on the "instance_id" field.
func InstanceIDLTE(v string) predicate.BlockStorage {
	return predicate.BlockStorage(sql.FieldLTE(FieldInstanceID, v))
}

// InstanceIDContains applies the Contains predicate on the "instance_id" field.
func InstanceIDContains(v string) predicate.BlockStorage {
	return predicate.BlockStorage(sql.FieldContains(FieldInstanceID, v))
}

// InstanceIDHasPrefix applies the HasPrefix predicate on the "instance_id" field.
func InstanceIDHasPrefix(v string) predicate.BlockStorage {
	return predicate.BlockStorage(sql.FieldHasPrefix(FieldInstanceID, v))
}

// InstanceIDHasSuffix applies the HasSuffix predicate on the "instance_id" field.
func InstanceIDHasSuffix(v string) predicate.BlockStorage {
	return predicate.BlockStorage(sql.FieldHasSuffix(FieldInstanceID, v))
}

// InstanceIDEqualFold applies the EqualFold predicate on the "instance_id" field.
func InstanceIDEqualFold(v string) predicate.BlockStorage {
	return predicate.BlockStorage(sql.FieldEqualFold(FieldInstanceID, v))
}

// InstanceIDContainsFold applies the ContainsFold predicate on the "instance_id" field.
func InstanceIDContainsFold(v string) predicate.BlockStorage {
	return predicate.BlockStorage(sql.FieldContainsFold(FieldInstanceID, v))
}

// RegionEQ applies the EQ predicate on the "region" field.
func RegionEQ(v string) predicate.BlockStorage {
	return predicate.BlockStorage(sql.FieldEQ(FieldRegion, v))
}

// RegionNEQ applies the NEQ predicate on the "region" field.
func RegionNEQ(v string) predicate.BlockStorage {
	return predicate.BlockStorage(sql.FieldNEQ(FieldRegion, v))
}

// RegionIn applies the In predicate on the "region" field.
func RegionIn(vs ...string) predicate.BlockStorage {
	return predicate.BlockStorage(sql.FieldIn(FieldRegion, vs...))
}

// RegionNotIn applies the NotIn predicate on the "region" field.
func RegionNotIn(vs ...string) predicate.BlockStorage {
	return predicate.BlockStorage(sql.FieldNotIn(FieldRegion, vs...))
}

// RegionGT applies the GT predicate on the "region" field.
func RegionGT(v string) predicate.BlockStorage {
	return predicate.BlockStorage(sql.FieldGT(FieldRegion, v))
}

// RegionGTE applies the GTE predicate on the "region" field.
func RegionGTE(v string) predicate.BlockStorage {
	return predicate.BlockStorage(sql.FieldGTE(FieldRegion, v))
}

// RegionLT applies the LT predicate on the "region" field.
func RegionLT(v string) predicate.BlockStorage {
	return predicate.BlockStorage(sql.FieldLT(FieldRegion, v))
}

// RegionLTE applies the LTE predicate on the "region" field.
func RegionLTE(v string) predicate.BlockStorage {
	return predicate.BlockStorage(sql.FieldLTE(FieldRegion, v))
}

// RegionContains applies the Contains predicate on the "region" field.
func RegionContains(v string) predicate.BlockStorage {
	return predicate.BlockStorage(sql.FieldContains(FieldRegion, v))
}

// RegionHasPrefix applies the HasPrefix predicate on the "region" field.
func RegionHasPrefix(v string) predicate.BlockStorage {
	return predicate.BlockStorage(sql.FieldHasPrefix(FieldRegion, v))
}

// RegionHasSuffix applies the HasSuffix predicate on the "region" field.
func RegionHasSuffix(v string) predicate.BlockStorage {
	return predicate.BlockStorage(sql.FieldHasSuffix(FieldRegion, v))
}

// RegionEqualFold applies the EqualFold predicate on the "region" field.
func RegionEqualFold(v string) predicate.BlockStorage {
	return predicate.BlockStorage(sql.FieldEqualFold(FieldRegion, v))
}

// RegionContainsFold applies the ContainsFold predicate on the "region" field.
func RegionContainsFold(v string) predicate.BlockStorage {
	return predicate.BlockStorage(sql.FieldContainsFold(FieldRegion, v))
}

// RegionCodeEQ applies the EQ predicate on the "region_code" field.
func RegionCodeEQ(v string) predicate.BlockStorage {
	return predicate.BlockStorage(sql.FieldEQ(FieldRegionCode, v))
}

// RegionCodeNEQ applies the NEQ predicate on the "region_code" field.
func RegionCodeNEQ(v string) predicate.BlockStorage {
	return predicate.BlockStorage(sql.FieldNEQ(FieldRegionCode, v))
}

// RegionCodeIn applies the In predicate on the "region_code" field.
func RegionCodeIn(vs ...string) predicate.BlockStorage {
	return predicate.BlockStorage(sql.FieldIn(FieldRegionCode, vs...))
}

// RegionCodeNotIn applies the NotIn predicate on the "region_code" field.
func RegionCodeNotIn(vs ...string) predicate.BlockStorage {
	return predicate.BlockStorage(sql.FieldNotIn(FieldRegionCode, vs...))
}

// RegionCodeGT applies the GT predicate on the "region_code" field.
func RegionCodeGT(v string) predicate.BlockStorage {
	return predicate.BlockStorage(sql.FieldGT(FieldRegionCode, v))
}

// RegionCodeGTE applies the GTE predicate on the "region_code" field.
func RegionCodeGTE(v string) predicate.BlockStorage {
	return predicate.BlockStorage(sql.FieldGTE(FieldRegionCode, v))
}

// RegionCodeLT applies the LT predicate on the "region_code" field.
func RegionCodeLT(v string) predicate.BlockStorage {
	return predicate.BlockStorage(sql.FieldLT(FieldRegionCode, v))
}

// RegionCodeLTE applies the LTE predicate on the "region_code" field.
func RegionCodeLTE(v string) predicate.BlockStorage {
	return predicate.BlockStorage(sql.FieldLTE(FieldRegionCode, v))
}

// RegionCodeContains applies the Contains predicate on the "region_code" field.
func RegionCodeContains(v string) predicate.BlockStorage {
	return predicate.BlockStorage(sql.FieldContains(FieldRegionCode, v))
}

// RegionCodeHasPrefix applies the HasPrefix predicate on the "region_code" field.
func RegionCodeHasPrefix(v string) predicate.BlockStorage {
	return predicate.BlockStorage(sql.FieldHasPrefix(FieldRegionCode, v))
}

// RegionCodeHasSuffix applies the HasSuffix predicate on the "region_code" field.
func RegionCodeHasSuffix(v string) predicate.BlockStorage {
	return predicate.BlockStorage(sql.FieldHasSuffix(FieldRegionCode, v))
}

// RegionCodeEqualFold applies the EqualFold predicate on the "region_code" field.
func RegionCodeEqualFold(v string) predicate.BlockStorage {
	return predicate.BlockStorage(sql.FieldEqualFold(FieldRegionCode, v))
}

// RegionCodeContainsFold applies the ContainsFold predicate on the "region_code" field.
func RegionCodeContainsFold(v string) predicate.BlockStorage {
	return predicate.BlockStorage(sql.FieldContainsFold(FieldRegionCode, v))
}

// AzEQ applies the EQ predicate on the "az" field.
func AzEQ(v string) predicate.BlockStorage {
	return predicate.BlockStorage(sql.FieldEQ(FieldAz, v))
}

// AzNEQ applies the NEQ predicate on the "az" field.
func AzNEQ(v string) predicate.BlockStorage {
	return predicate.BlockStorage(sql.FieldNEQ(FieldAz, v))
}

// AzIn applies the In predicate on the "az" field.
func AzIn(vs ...string) predicate.BlockStorage {
	return predicate.BlockStorage(sql.FieldIn(FieldAz, vs...))
}

// AzNotIn applies the NotIn predicate on the "az" field.
func AzNotIn(vs ...string) predicate.BlockStorage {
	return predicate.BlockStorage(sql.FieldNotIn(FieldAz, vs...))
}

// AzGT applies the GT predicate on the "az" field.
func AzGT(v string) predicate.BlockStorage {
	return predicate.BlockStorage(sql.FieldGT(FieldAz, v))
}

// AzGTE applies the GTE predicate on the "az" field.
func AzGTE(v string) predicate.BlockStorage {
	return predicate.BlockStorage(sql.FieldGTE(FieldAz, v))
}

// AzLT applies the LT predicate on the "az" field.
func AzLT(v string) predicate.BlockStorage {
	return predicate.BlockStorage(sql.FieldLT(FieldAz, v))
}

// AzLTE applies the LTE predicate on the "az" field.
func AzLTE(v string) predicate.BlockStorage {
	return predicate.BlockStorage(sql.FieldLTE(FieldAz, v))
}

// AzContains applies the Contains predicate on the "az" field.
func AzContains(v string) predicate.BlockStorage {
	return predicate.BlockStorage(sql.FieldContains(FieldAz, v))
}

// AzHasPrefix applies the HasPrefix predicate on the "az" field.
func AzHasPrefix(v string) predicate.BlockStorage {
	return predicate.BlockStorage(sql.FieldHasPrefix(FieldAz, v))
}

// AzHasSuffix applies the HasSuffix predicate on the "az" field.
func AzHasSuffix(v string) predicate.BlockStorage {
	return predicate.BlockStorage(sql.FieldHasSuffix(FieldAz, v))
}

// AzEqualFold applies the EqualFold predicate on the "az" field.
func AzEqualFold(v string) predicate.BlockStorage {
	return predicate.BlockStorage(sql.FieldEqualFold(FieldAz, v))
}

// AzContainsFold applies the ContainsFold predicate on the "az" field.
func AzContainsFold(v string) predicate.BlockStorage {
	return predicate.BlockStorage(sql.FieldContainsFold(FieldAz, v))
}

// AzCodeEQ applies the EQ predicate on the "az_code" field.
func AzCodeEQ(v string) predicate.BlockStorage {
	return predicate.BlockStorage(sql.FieldEQ(FieldAzCode, v))
}

// AzCodeNEQ applies the NEQ predicate on the "az_code" field.
func AzCodeNEQ(v string) predicate.BlockStorage {
	return predicate.BlockStorage(sql.FieldNEQ(FieldAzCode, v))
}

// AzCodeIn applies the In predicate on the "az_code" field.
func AzCodeIn(vs ...string) predicate.BlockStorage {
	return predicate.BlockStorage(sql.FieldIn(FieldAzCode, vs...))
}

// AzCodeNotIn applies the NotIn predicate on the "az_code" field.
func AzCodeNotIn(vs ...string) predicate.BlockStorage {
	return predicate.BlockStorage(sql.FieldNotIn(FieldAzCode, vs...))
}

// AzCodeGT applies the GT predicate on the "az_code" field.
func AzCodeGT(v string) predicate.BlockStorage {
	return predicate.BlockStorage(sql.FieldGT(FieldAzCode, v))
}

// AzCodeGTE applies the GTE predicate on the "az_code" field.
func AzCodeGTE(v string) predicate.BlockStorage {
	return predicate.BlockStorage(sql.FieldGTE(FieldAzCode, v))
}

// AzCodeLT applies the LT predicate on the "az_code" field.
func AzCodeLT(v string) predicate.BlockStorage {
	return predicate.BlockStorage(sql.FieldLT(FieldAzCode, v))
}

// AzCodeLTE applies the LTE predicate on the "az_code" field.
func AzCodeLTE(v string) predicate.BlockStorage {
	return predicate.BlockStorage(sql.FieldLTE(FieldAzCode, v))
}

// AzCodeContains applies the Contains predicate on the "az_code" field.
func AzCodeContains(v string) predicate.BlockStorage {
	return predicate.BlockStorage(sql.FieldContains(FieldAzCode, v))
}

// AzCodeHasPrefix applies the HasPrefix predicate on the "az_code" field.
func AzCodeHasPrefix(v string) predicate.BlockStorage {
	return predicate.BlockStorage(sql.FieldHasPrefix(FieldAzCode, v))
}

// AzCodeHasSuffix applies the HasSuffix predicate on the "az_code" field.
func AzCodeHasSuffix(v string) predicate.BlockStorage {
	return predicate.BlockStorage(sql.FieldHasSuffix(FieldAzCode, v))
}

// AzCodeEqualFold applies the EqualFold predicate on the "az_code" field.
func AzCodeEqualFold(v string) predicate.BlockStorage {
	return predicate.BlockStorage(sql.FieldEqualFold(FieldAzCode, v))
}

// AzCodeContainsFold applies the ContainsFold predicate on the "az_code" field.
func AzCodeContainsFold(v string) predicate.BlockStorage {
	return predicate.BlockStorage(sql.FieldContainsFold(FieldAzCode, v))
}

// ResourcePoolEQ applies the EQ predicate on the "resource_pool" field.
func ResourcePoolEQ(v string) predicate.BlockStorage {
	return predicate.BlockStorage(sql.FieldEQ(FieldResourcePool, v))
}

// ResourcePoolNEQ applies the NEQ predicate on the "resource_pool" field.
func ResourcePoolNEQ(v string) predicate.BlockStorage {
	return predicate.BlockStorage(sql.FieldNEQ(FieldResourcePool, v))
}

// ResourcePoolIn applies the In predicate on the "resource_pool" field.
func ResourcePoolIn(vs ...string) predicate.BlockStorage {
	return predicate.BlockStorage(sql.FieldIn(FieldResourcePool, vs...))
}

// ResourcePoolNotIn applies the NotIn predicate on the "resource_pool" field.
func ResourcePoolNotIn(vs ...string) predicate.BlockStorage {
	return predicate.BlockStorage(sql.FieldNotIn(FieldResourcePool, vs...))
}

// ResourcePoolGT applies the GT predicate on the "resource_pool" field.
func ResourcePoolGT(v string) predicate.BlockStorage {
	return predicate.BlockStorage(sql.FieldGT(FieldResourcePool, v))
}

// ResourcePoolGTE applies the GTE predicate on the "resource_pool" field.
func ResourcePoolGTE(v string) predicate.BlockStorage {
	return predicate.BlockStorage(sql.FieldGTE(FieldResourcePool, v))
}

// ResourcePoolLT applies the LT predicate on the "resource_pool" field.
func ResourcePoolLT(v string) predicate.BlockStorage {
	return predicate.BlockStorage(sql.FieldLT(FieldResourcePool, v))
}

// ResourcePoolLTE applies the LTE predicate on the "resource_pool" field.
func ResourcePoolLTE(v string) predicate.BlockStorage {
	return predicate.BlockStorage(sql.FieldLTE(FieldResourcePool, v))
}

// ResourcePoolContains applies the Contains predicate on the "resource_pool" field.
func ResourcePoolContains(v string) predicate.BlockStorage {
	return predicate.BlockStorage(sql.FieldContains(FieldResourcePool, v))
}

// ResourcePoolHasPrefix applies the HasPrefix predicate on the "resource_pool" field.
func ResourcePoolHasPrefix(v string) predicate.BlockStorage {
	return predicate.BlockStorage(sql.FieldHasPrefix(FieldResourcePool, v))
}

// ResourcePoolHasSuffix applies the HasSuffix predicate on the "resource_pool" field.
func ResourcePoolHasSuffix(v string) predicate.BlockStorage {
	return predicate.BlockStorage(sql.FieldHasSuffix(FieldResourcePool, v))
}

// ResourcePoolEqualFold applies the EqualFold predicate on the "resource_pool" field.
func ResourcePoolEqualFold(v string) predicate.BlockStorage {
	return predicate.BlockStorage(sql.FieldEqualFold(FieldResourcePool, v))
}

// ResourcePoolContainsFold applies the ContainsFold predicate on the "resource_pool" field.
func ResourcePoolContainsFold(v string) predicate.BlockStorage {
	return predicate.BlockStorage(sql.FieldContainsFold(FieldResourcePool, v))
}

// ResourcePoolTypeEQ applies the EQ predicate on the "resource_pool_type" field.
func ResourcePoolTypeEQ(v string) predicate.BlockStorage {
	return predicate.BlockStorage(sql.FieldEQ(FieldResourcePoolType, v))
}

// ResourcePoolTypeNEQ applies the NEQ predicate on the "resource_pool_type" field.
func ResourcePoolTypeNEQ(v string) predicate.BlockStorage {
	return predicate.BlockStorage(sql.FieldNEQ(FieldResourcePoolType, v))
}

// ResourcePoolTypeIn applies the In predicate on the "resource_pool_type" field.
func ResourcePoolTypeIn(vs ...string) predicate.BlockStorage {
	return predicate.BlockStorage(sql.FieldIn(FieldResourcePoolType, vs...))
}

// ResourcePoolTypeNotIn applies the NotIn predicate on the "resource_pool_type" field.
func ResourcePoolTypeNotIn(vs ...string) predicate.BlockStorage {
	return predicate.BlockStorage(sql.FieldNotIn(FieldResourcePoolType, vs...))
}

// ResourcePoolTypeGT applies the GT predicate on the "resource_pool_type" field.
func ResourcePoolTypeGT(v string) predicate.BlockStorage {
	return predicate.BlockStorage(sql.FieldGT(FieldResourcePoolType, v))
}

// ResourcePoolTypeGTE applies the GTE predicate on the "resource_pool_type" field.
func ResourcePoolTypeGTE(v string) predicate.BlockStorage {
	return predicate.BlockStorage(sql.FieldGTE(FieldResourcePoolType, v))
}

// ResourcePoolTypeLT applies the LT predicate on the "resource_pool_type" field.
func ResourcePoolTypeLT(v string) predicate.BlockStorage {
	return predicate.BlockStorage(sql.FieldLT(FieldResourcePoolType, v))
}

// ResourcePoolTypeLTE applies the LTE predicate on the "resource_pool_type" field.
func ResourcePoolTypeLTE(v string) predicate.BlockStorage {
	return predicate.BlockStorage(sql.FieldLTE(FieldResourcePoolType, v))
}

// ResourcePoolTypeContains applies the Contains predicate on the "resource_pool_type" field.
func ResourcePoolTypeContains(v string) predicate.BlockStorage {
	return predicate.BlockStorage(sql.FieldContains(FieldResourcePoolType, v))
}

// ResourcePoolTypeHasPrefix applies the HasPrefix predicate on the "resource_pool_type" field.
func ResourcePoolTypeHasPrefix(v string) predicate.BlockStorage {
	return predicate.BlockStorage(sql.FieldHasPrefix(FieldResourcePoolType, v))
}

// ResourcePoolTypeHasSuffix applies the HasSuffix predicate on the "resource_pool_type" field.
func ResourcePoolTypeHasSuffix(v string) predicate.BlockStorage {
	return predicate.BlockStorage(sql.FieldHasSuffix(FieldResourcePoolType, v))
}

// ResourcePoolTypeEqualFold applies the EqualFold predicate on the "resource_pool_type" field.
func ResourcePoolTypeEqualFold(v string) predicate.BlockStorage {
	return predicate.BlockStorage(sql.FieldEqualFold(FieldResourcePoolType, v))
}

// ResourcePoolTypeContainsFold applies the ContainsFold predicate on the "resource_pool_type" field.
func ResourcePoolTypeContainsFold(v string) predicate.BlockStorage {
	return predicate.BlockStorage(sql.FieldContainsFold(FieldResourcePoolType, v))
}

// UseStatusEQ applies the EQ predicate on the "use_status" field.
func UseStatusEQ(v string) predicate.BlockStorage {
	return predicate.BlockStorage(sql.FieldEQ(FieldUseStatus, v))
}

// UseStatusNEQ applies the NEQ predicate on the "use_status" field.
func UseStatusNEQ(v string) predicate.BlockStorage {
	return predicate.BlockStorage(sql.FieldNEQ(FieldUseStatus, v))
}

// UseStatusIn applies the In predicate on the "use_status" field.
func UseStatusIn(vs ...string) predicate.BlockStorage {
	return predicate.BlockStorage(sql.FieldIn(FieldUseStatus, vs...))
}

// UseStatusNotIn applies the NotIn predicate on the "use_status" field.
func UseStatusNotIn(vs ...string) predicate.BlockStorage {
	return predicate.BlockStorage(sql.FieldNotIn(FieldUseStatus, vs...))
}

// UseStatusGT applies the GT predicate on the "use_status" field.
func UseStatusGT(v string) predicate.BlockStorage {
	return predicate.BlockStorage(sql.FieldGT(FieldUseStatus, v))
}

// UseStatusGTE applies the GTE predicate on the "use_status" field.
func UseStatusGTE(v string) predicate.BlockStorage {
	return predicate.BlockStorage(sql.FieldGTE(FieldUseStatus, v))
}

// UseStatusLT applies the LT predicate on the "use_status" field.
func UseStatusLT(v string) predicate.BlockStorage {
	return predicate.BlockStorage(sql.FieldLT(FieldUseStatus, v))
}

// UseStatusLTE applies the LTE predicate on the "use_status" field.
func UseStatusLTE(v string) predicate.BlockStorage {
	return predicate.BlockStorage(sql.FieldLTE(FieldUseStatus, v))
}

// UseStatusContains applies the Contains predicate on the "use_status" field.
func UseStatusContains(v string) predicate.BlockStorage {
	return predicate.BlockStorage(sql.FieldContains(FieldUseStatus, v))
}

// UseStatusHasPrefix applies the HasPrefix predicate on the "use_status" field.
func UseStatusHasPrefix(v string) predicate.BlockStorage {
	return predicate.BlockStorage(sql.FieldHasPrefix(FieldUseStatus, v))
}

// UseStatusHasSuffix applies the HasSuffix predicate on the "use_status" field.
func UseStatusHasSuffix(v string) predicate.BlockStorage {
	return predicate.BlockStorage(sql.FieldHasSuffix(FieldUseStatus, v))
}

// UseStatusEqualFold applies the EqualFold predicate on the "use_status" field.
func UseStatusEqualFold(v string) predicate.BlockStorage {
	return predicate.BlockStorage(sql.FieldEqualFold(FieldUseStatus, v))
}

// UseStatusContainsFold applies the ContainsFold predicate on the "use_status" field.
func UseStatusContainsFold(v string) predicate.BlockStorage {
	return predicate.BlockStorage(sql.FieldContainsFold(FieldUseStatus, v))
}

// TenantIDEQ applies the EQ predicate on the "tenant_id" field.
func TenantIDEQ(v string) predicate.BlockStorage {
	return predicate.BlockStorage(sql.FieldEQ(FieldTenantID, v))
}

// TenantIDNEQ applies the NEQ predicate on the "tenant_id" field.
func TenantIDNEQ(v string) predicate.BlockStorage {
	return predicate.BlockStorage(sql.FieldNEQ(FieldTenantID, v))
}

// TenantIDIn applies the In predicate on the "tenant_id" field.
func TenantIDIn(vs ...string) predicate.BlockStorage {
	return predicate.BlockStorage(sql.FieldIn(FieldTenantID, vs...))
}

// TenantIDNotIn applies the NotIn predicate on the "tenant_id" field.
func TenantIDNotIn(vs ...string) predicate.BlockStorage {
	return predicate.BlockStorage(sql.FieldNotIn(FieldTenantID, vs...))
}

// TenantIDGT applies the GT predicate on the "tenant_id" field.
func TenantIDGT(v string) predicate.BlockStorage {
	return predicate.BlockStorage(sql.FieldGT(FieldTenantID, v))
}

// TenantIDGTE applies the GTE predicate on the "tenant_id" field.
func TenantIDGTE(v string) predicate.BlockStorage {
	return predicate.BlockStorage(sql.FieldGTE(FieldTenantID, v))
}

// TenantIDLT applies the LT predicate on the "tenant_id" field.
func TenantIDLT(v string) predicate.BlockStorage {
	return predicate.BlockStorage(sql.FieldLT(FieldTenantID, v))
}

// TenantIDLTE applies the LTE predicate on the "tenant_id" field.
func TenantIDLTE(v string) predicate.BlockStorage {
	return predicate.BlockStorage(sql.FieldLTE(FieldTenantID, v))
}

// TenantIDContains applies the Contains predicate on the "tenant_id" field.
func TenantIDContains(v string) predicate.BlockStorage {
	return predicate.BlockStorage(sql.FieldContains(FieldTenantID, v))
}

// TenantIDHasPrefix applies the HasPrefix predicate on the "tenant_id" field.
func TenantIDHasPrefix(v string) predicate.BlockStorage {
	return predicate.BlockStorage(sql.FieldHasPrefix(FieldTenantID, v))
}

// TenantIDHasSuffix applies the HasSuffix predicate on the "tenant_id" field.
func TenantIDHasSuffix(v string) predicate.BlockStorage {
	return predicate.BlockStorage(sql.FieldHasSuffix(FieldTenantID, v))
}

// TenantIDEqualFold applies the EqualFold predicate on the "tenant_id" field.
func TenantIDEqualFold(v string) predicate.BlockStorage {
	return predicate.BlockStorage(sql.FieldEqualFold(FieldTenantID, v))
}

// TenantIDContainsFold applies the ContainsFold predicate on the "tenant_id" field.
func TenantIDContainsFold(v string) predicate.BlockStorage {
	return predicate.BlockStorage(sql.FieldContainsFold(FieldTenantID, v))
}

// TenantNameEQ applies the EQ predicate on the "tenant_name" field.
func TenantNameEQ(v string) predicate.BlockStorage {
	return predicate.BlockStorage(sql.FieldEQ(FieldTenantName, v))
}

// TenantNameNEQ applies the NEQ predicate on the "tenant_name" field.
func TenantNameNEQ(v string) predicate.BlockStorage {
	return predicate.BlockStorage(sql.FieldNEQ(FieldTenantName, v))
}

// TenantNameIn applies the In predicate on the "tenant_name" field.
func TenantNameIn(vs ...string) predicate.BlockStorage {
	return predicate.BlockStorage(sql.FieldIn(FieldTenantName, vs...))
}

// TenantNameNotIn applies the NotIn predicate on the "tenant_name" field.
func TenantNameNotIn(vs ...string) predicate.BlockStorage {
	return predicate.BlockStorage(sql.FieldNotIn(FieldTenantName, vs...))
}

// TenantNameGT applies the GT predicate on the "tenant_name" field.
func TenantNameGT(v string) predicate.BlockStorage {
	return predicate.BlockStorage(sql.FieldGT(FieldTenantName, v))
}

// TenantNameGTE applies the GTE predicate on the "tenant_name" field.
func TenantNameGTE(v string) predicate.BlockStorage {
	return predicate.BlockStorage(sql.FieldGTE(FieldTenantName, v))
}

// TenantNameLT applies the LT predicate on the "tenant_name" field.
func TenantNameLT(v string) predicate.BlockStorage {
	return predicate.BlockStorage(sql.FieldLT(FieldTenantName, v))
}

// TenantNameLTE applies the LTE predicate on the "tenant_name" field.
func TenantNameLTE(v string) predicate.BlockStorage {
	return predicate.BlockStorage(sql.FieldLTE(FieldTenantName, v))
}

// TenantNameContains applies the Contains predicate on the "tenant_name" field.
func TenantNameContains(v string) predicate.BlockStorage {
	return predicate.BlockStorage(sql.FieldContains(FieldTenantName, v))
}

// TenantNameHasPrefix applies the HasPrefix predicate on the "tenant_name" field.
func TenantNameHasPrefix(v string) predicate.BlockStorage {
	return predicate.BlockStorage(sql.FieldHasPrefix(FieldTenantName, v))
}

// TenantNameHasSuffix applies the HasSuffix predicate on the "tenant_name" field.
func TenantNameHasSuffix(v string) predicate.BlockStorage {
	return predicate.BlockStorage(sql.FieldHasSuffix(FieldTenantName, v))
}

// TenantNameEqualFold applies the EqualFold predicate on the "tenant_name" field.
func TenantNameEqualFold(v string) predicate.BlockStorage {
	return predicate.BlockStorage(sql.FieldEqualFold(FieldTenantName, v))
}

// TenantNameContainsFold applies the ContainsFold predicate on the "tenant_name" field.
func TenantNameContainsFold(v string) predicate.BlockStorage {
	return predicate.BlockStorage(sql.FieldContainsFold(FieldTenantName, v))
}

// VMEQ applies the EQ predicate on the "vm" field.
func VMEQ(v string) predicate.BlockStorage {
	return predicate.BlockStorage(sql.FieldEQ(FieldVM, v))
}

// VMNEQ applies the NEQ predicate on the "vm" field.
func VMNEQ(v string) predicate.BlockStorage {
	return predicate.BlockStorage(sql.FieldNEQ(FieldVM, v))
}

// VMIn applies the In predicate on the "vm" field.
func VMIn(vs ...string) predicate.BlockStorage {
	return predicate.BlockStorage(sql.FieldIn(FieldVM, vs...))
}

// VMNotIn applies the NotIn predicate on the "vm" field.
func VMNotIn(vs ...string) predicate.BlockStorage {
	return predicate.BlockStorage(sql.FieldNotIn(FieldVM, vs...))
}

// VMGT applies the GT predicate on the "vm" field.
func VMGT(v string) predicate.BlockStorage {
	return predicate.BlockStorage(sql.FieldGT(FieldVM, v))
}

// VMGTE applies the GTE predicate on the "vm" field.
func VMGTE(v string) predicate.BlockStorage {
	return predicate.BlockStorage(sql.FieldGTE(FieldVM, v))
}

// VMLT applies the LT predicate on the "vm" field.
func VMLT(v string) predicate.BlockStorage {
	return predicate.BlockStorage(sql.FieldLT(FieldVM, v))
}

// VMLTE applies the LTE predicate on the "vm" field.
func VMLTE(v string) predicate.BlockStorage {
	return predicate.BlockStorage(sql.FieldLTE(FieldVM, v))
}

// VMContains applies the Contains predicate on the "vm" field.
func VMContains(v string) predicate.BlockStorage {
	return predicate.BlockStorage(sql.FieldContains(FieldVM, v))
}

// VMHasPrefix applies the HasPrefix predicate on the "vm" field.
func VMHasPrefix(v string) predicate.BlockStorage {
	return predicate.BlockStorage(sql.FieldHasPrefix(FieldVM, v))
}

// VMHasSuffix applies the HasSuffix predicate on the "vm" field.
func VMHasSuffix(v string) predicate.BlockStorage {
	return predicate.BlockStorage(sql.FieldHasSuffix(FieldVM, v))
}

// VMEqualFold applies the EqualFold predicate on the "vm" field.
func VMEqualFold(v string) predicate.BlockStorage {
	return predicate.BlockStorage(sql.FieldEqualFold(FieldVM, v))
}

// VMContainsFold applies the ContainsFold predicate on the "vm" field.
func VMContainsFold(v string) predicate.BlockStorage {
	return predicate.BlockStorage(sql.FieldContainsFold(FieldVM, v))
}

// VMIDEQ applies the EQ predicate on the "vm_id" field.
func VMIDEQ(v string) predicate.BlockStorage {
	return predicate.BlockStorage(sql.FieldEQ(FieldVMID, v))
}

// VMIDNEQ applies the NEQ predicate on the "vm_id" field.
func VMIDNEQ(v string) predicate.BlockStorage {
	return predicate.BlockStorage(sql.FieldNEQ(FieldVMID, v))
}

// VMIDIn applies the In predicate on the "vm_id" field.
func VMIDIn(vs ...string) predicate.BlockStorage {
	return predicate.BlockStorage(sql.FieldIn(FieldVMID, vs...))
}

// VMIDNotIn applies the NotIn predicate on the "vm_id" field.
func VMIDNotIn(vs ...string) predicate.BlockStorage {
	return predicate.BlockStorage(sql.FieldNotIn(FieldVMID, vs...))
}

// VMIDGT applies the GT predicate on the "vm_id" field.
func VMIDGT(v string) predicate.BlockStorage {
	return predicate.BlockStorage(sql.FieldGT(FieldVMID, v))
}

// VMIDGTE applies the GTE predicate on the "vm_id" field.
func VMIDGTE(v string) predicate.BlockStorage {
	return predicate.BlockStorage(sql.FieldGTE(FieldVMID, v))
}

// VMIDLT applies the LT predicate on the "vm_id" field.
func VMIDLT(v string) predicate.BlockStorage {
	return predicate.BlockStorage(sql.FieldLT(FieldVMID, v))
}

// VMIDLTE applies the LTE predicate on the "vm_id" field.
func VMIDLTE(v string) predicate.BlockStorage {
	return predicate.BlockStorage(sql.FieldLTE(FieldVMID, v))
}

// VMIDContains applies the Contains predicate on the "vm_id" field.
func VMIDContains(v string) predicate.BlockStorage {
	return predicate.BlockStorage(sql.FieldContains(FieldVMID, v))
}

// VMIDHasPrefix applies the HasPrefix predicate on the "vm_id" field.
func VMIDHasPrefix(v string) predicate.BlockStorage {
	return predicate.BlockStorage(sql.FieldHasPrefix(FieldVMID, v))
}

// VMIDHasSuffix applies the HasSuffix predicate on the "vm_id" field.
func VMIDHasSuffix(v string) predicate.BlockStorage {
	return predicate.BlockStorage(sql.FieldHasSuffix(FieldVMID, v))
}

// VMIDEqualFold applies the EqualFold predicate on the "vm_id" field.
func VMIDEqualFold(v string) predicate.BlockStorage {
	return predicate.BlockStorage(sql.FieldEqualFold(FieldVMID, v))
}

// VMIDContainsFold applies the ContainsFold predicate on the "vm_id" field.
func VMIDContainsFold(v string) predicate.BlockStorage {
	return predicate.BlockStorage(sql.FieldContainsFold(FieldVMID, v))
}

// CreateTimeEQ applies the EQ predicate on the "create_time" field.
func CreateTimeEQ(v int) predicate.BlockStorage {
	return predicate.BlockStorage(sql.FieldEQ(FieldCreateTime, v))
}

// CreateTimeNEQ applies the NEQ predicate on the "create_time" field.
func CreateTimeNEQ(v int) predicate.BlockStorage {
	return predicate.BlockStorage(sql.FieldNEQ(FieldCreateTime, v))
}

// CreateTimeIn applies the In predicate on the "create_time" field.
func CreateTimeIn(vs ...int) predicate.BlockStorage {
	return predicate.BlockStorage(sql.FieldIn(FieldCreateTime, vs...))
}

// CreateTimeNotIn applies the NotIn predicate on the "create_time" field.
func CreateTimeNotIn(vs ...int) predicate.BlockStorage {
	return predicate.BlockStorage(sql.FieldNotIn(FieldCreateTime, vs...))
}

// CreateTimeGT applies the GT predicate on the "create_time" field.
func CreateTimeGT(v int) predicate.BlockStorage {
	return predicate.BlockStorage(sql.FieldGT(FieldCreateTime, v))
}

// CreateTimeGTE applies the GTE predicate on the "create_time" field.
func CreateTimeGTE(v int) predicate.BlockStorage {
	return predicate.BlockStorage(sql.FieldGTE(FieldCreateTime, v))
}

// CreateTimeLT applies the LT predicate on the "create_time" field.
func CreateTimeLT(v int) predicate.BlockStorage {
	return predicate.BlockStorage(sql.FieldLT(FieldCreateTime, v))
}

// CreateTimeLTE applies the LTE predicate on the "create_time" field.
func CreateTimeLTE(v int) predicate.BlockStorage {
	return predicate.BlockStorage(sql.FieldLTE(FieldCreateTime, v))
}

// SizeEQ applies the EQ predicate on the "size" field.
func SizeEQ(v int32) predicate.BlockStorage {
	return predicate.BlockStorage(sql.FieldEQ(FieldSize, v))
}

// SizeNEQ applies the NEQ predicate on the "size" field.
func SizeNEQ(v int32) predicate.BlockStorage {
	return predicate.BlockStorage(sql.FieldNEQ(FieldSize, v))
}

// SizeIn applies the In predicate on the "size" field.
func SizeIn(vs ...int32) predicate.BlockStorage {
	return predicate.BlockStorage(sql.FieldIn(FieldSize, vs...))
}

// SizeNotIn applies the NotIn predicate on the "size" field.
func SizeNotIn(vs ...int32) predicate.BlockStorage {
	return predicate.BlockStorage(sql.FieldNotIn(FieldSize, vs...))
}

// SizeGT applies the GT predicate on the "size" field.
func SizeGT(v int32) predicate.BlockStorage {
	return predicate.BlockStorage(sql.FieldGT(FieldSize, v))
}

// SizeGTE applies the GTE predicate on the "size" field.
func SizeGTE(v int32) predicate.BlockStorage {
	return predicate.BlockStorage(sql.FieldGTE(FieldSize, v))
}

// SizeLT applies the LT predicate on the "size" field.
func SizeLT(v int32) predicate.BlockStorage {
	return predicate.BlockStorage(sql.FieldLT(FieldSize, v))
}

// SizeLTE applies the LTE predicate on the "size" field.
func SizeLTE(v int32) predicate.BlockStorage {
	return predicate.BlockStorage(sql.FieldLTE(FieldSize, v))
}

// MountPointEQ applies the EQ predicate on the "mount_point" field.
func MountPointEQ(v string) predicate.BlockStorage {
	return predicate.BlockStorage(sql.FieldEQ(FieldMountPoint, v))
}

// MountPointNEQ applies the NEQ predicate on the "mount_point" field.
func MountPointNEQ(v string) predicate.BlockStorage {
	return predicate.BlockStorage(sql.FieldNEQ(FieldMountPoint, v))
}

// MountPointIn applies the In predicate on the "mount_point" field.
func MountPointIn(vs ...string) predicate.BlockStorage {
	return predicate.BlockStorage(sql.FieldIn(FieldMountPoint, vs...))
}

// MountPointNotIn applies the NotIn predicate on the "mount_point" field.
func MountPointNotIn(vs ...string) predicate.BlockStorage {
	return predicate.BlockStorage(sql.FieldNotIn(FieldMountPoint, vs...))
}

// MountPointGT applies the GT predicate on the "mount_point" field.
func MountPointGT(v string) predicate.BlockStorage {
	return predicate.BlockStorage(sql.FieldGT(FieldMountPoint, v))
}

// MountPointGTE applies the GTE predicate on the "mount_point" field.
func MountPointGTE(v string) predicate.BlockStorage {
	return predicate.BlockStorage(sql.FieldGTE(FieldMountPoint, v))
}

// MountPointLT applies the LT predicate on the "mount_point" field.
func MountPointLT(v string) predicate.BlockStorage {
	return predicate.BlockStorage(sql.FieldLT(FieldMountPoint, v))
}

// MountPointLTE applies the LTE predicate on the "mount_point" field.
func MountPointLTE(v string) predicate.BlockStorage {
	return predicate.BlockStorage(sql.FieldLTE(FieldMountPoint, v))
}

// MountPointContains applies the Contains predicate on the "mount_point" field.
func MountPointContains(v string) predicate.BlockStorage {
	return predicate.BlockStorage(sql.FieldContains(FieldMountPoint, v))
}

// MountPointHasPrefix applies the HasPrefix predicate on the "mount_point" field.
func MountPointHasPrefix(v string) predicate.BlockStorage {
	return predicate.BlockStorage(sql.FieldHasPrefix(FieldMountPoint, v))
}

// MountPointHasSuffix applies the HasSuffix predicate on the "mount_point" field.
func MountPointHasSuffix(v string) predicate.BlockStorage {
	return predicate.BlockStorage(sql.FieldHasSuffix(FieldMountPoint, v))
}

// MountPointEqualFold applies the EqualFold predicate on the "mount_point" field.
func MountPointEqualFold(v string) predicate.BlockStorage {
	return predicate.BlockStorage(sql.FieldEqualFold(FieldMountPoint, v))
}

// MountPointContainsFold applies the ContainsFold predicate on the "mount_point" field.
func MountPointContainsFold(v string) predicate.BlockStorage {
	return predicate.BlockStorage(sql.FieldContainsFold(FieldMountPoint, v))
}

// LastUpdateTimeEQ applies the EQ predicate on the "last_update_time" field.
func LastUpdateTimeEQ(v time.Time) predicate.BlockStorage {
	return predicate.BlockStorage(sql.FieldEQ(FieldLastUpdateTime, v))
}

// LastUpdateTimeNEQ applies the NEQ predicate on the "last_update_time" field.
func LastUpdateTimeNEQ(v time.Time) predicate.BlockStorage {
	return predicate.BlockStorage(sql.FieldNEQ(FieldLastUpdateTime, v))
}

// LastUpdateTimeIn applies the In predicate on the "last_update_time" field.
func LastUpdateTimeIn(vs ...time.Time) predicate.BlockStorage {
	return predicate.BlockStorage(sql.FieldIn(FieldLastUpdateTime, vs...))
}

// LastUpdateTimeNotIn applies the NotIn predicate on the "last_update_time" field.
func LastUpdateTimeNotIn(vs ...time.Time) predicate.BlockStorage {
	return predicate.BlockStorage(sql.FieldNotIn(FieldLastUpdateTime, vs...))
}

// LastUpdateTimeGT applies the GT predicate on the "last_update_time" field.
func LastUpdateTimeGT(v time.Time) predicate.BlockStorage {
	return predicate.BlockStorage(sql.FieldGT(FieldLastUpdateTime, v))
}

// LastUpdateTimeGTE applies the GTE predicate on the "last_update_time" field.
func LastUpdateTimeGTE(v time.Time) predicate.BlockStorage {
	return predicate.BlockStorage(sql.FieldGTE(FieldLastUpdateTime, v))
}

// LastUpdateTimeLT applies the LT predicate on the "last_update_time" field.
func LastUpdateTimeLT(v time.Time) predicate.BlockStorage {
	return predicate.BlockStorage(sql.FieldLT(FieldLastUpdateTime, v))
}

// LastUpdateTimeLTE applies the LTE predicate on the "last_update_time" field.
func LastUpdateTimeLTE(v time.Time) predicate.BlockStorage {
	return predicate.BlockStorage(sql.FieldLTE(FieldLastUpdateTime, v))
}

// And groups predicates with the AND operator between them.
func And(predicates ...predicate.BlockStorage) predicate.BlockStorage {
	return predicate.BlockStorage(func(s *sql.Selector) {
		s1 := s.Clone().SetP(nil)
		for _, p := range predicates {
			p(s1)
		}
		s.Where(s1.P())
	})
}

// Or groups predicates with the OR operator between them.
func Or(predicates ...predicate.BlockStorage) predicate.BlockStorage {
	return predicate.BlockStorage(func(s *sql.Selector) {
		s1 := s.Clone().SetP(nil)
		for i, p := range predicates {
			if i > 0 {
				s1.Or()
			}
			p(s1)
		}
		s.Where(s1.P())
	})
}

// Not applies the not operator on the given predicate.
func Not(p predicate.BlockStorage) predicate.BlockStorage {
	return predicate.BlockStorage(func(s *sql.Selector) {
		p(s.Not())
	})
}

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/data/ent/objectstoragebucket/where.go
```golang
// Code generated by ent, DO NOT EDIT.

package objectstoragebucket

import (
	"luban-cmdb-api/data/ent/predicate"
	"time"

	"entgo.io/ent/dialect/sql"
)

// ID filters vertices based on their ID field.
func ID(id uint64) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldEQ(FieldID, id))
}

// IDEQ applies the EQ predicate on the ID field.
func IDEQ(id uint64) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldEQ(FieldID, id))
}

// IDNEQ applies the NEQ predicate on the ID field.
func IDNEQ(id uint64) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldNEQ(FieldID, id))
}

// IDIn applies the In predicate on the ID field.
func IDIn(ids ...uint64) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldIn(FieldID, ids...))
}

// IDNotIn applies the NotIn predicate on the ID field.
func IDNotIn(ids ...uint64) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldNotIn(FieldID, ids...))
}

// IDGT applies the GT predicate on the ID field.
func IDGT(id uint64) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldGT(FieldID, id))
}

// IDGTE applies the GTE predicate on the ID field.
func IDGTE(id uint64) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldGTE(FieldID, id))
}

// IDLT applies the LT predicate on the ID field.
func IDLT(id uint64) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldLT(FieldID, id))
}

// IDLTE applies the LTE predicate on the ID field.
func IDLTE(id uint64) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldLTE(FieldID, id))
}

// CreatedAt applies equality check predicate on the "created_at" field. It's identical to CreatedAtEQ.
func CreatedAt(v time.Time) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldEQ(FieldCreatedAt, v))
}

// UpdatedAt applies equality check predicate on the "updated_at" field. It's identical to UpdatedAtEQ.
func UpdatedAt(v time.Time) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldEQ(FieldUpdatedAt, v))
}

// Version applies equality check predicate on the "version" field. It's identical to VersionEQ.
func Version(v string) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldEQ(FieldVersion, v))
}

// Galaxy applies equality check predicate on the "galaxy" field. It's identical to GalaxyEQ.
func Galaxy(v string) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldEQ(FieldGalaxy, v))
}

// Region applies equality check predicate on the "region" field. It's identical to RegionEQ.
func Region(v string) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldEQ(FieldRegion, v))
}

// Deleted applies equality check predicate on the "deleted" field. It's identical to DeletedEQ.
func Deleted(v bool) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldEQ(FieldDeleted, v))
}

// BucketID applies equality check predicate on the "bucket_id" field. It's identical to BucketIDEQ.
func BucketID(v int) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldEQ(FieldBucketID, v))
}

// Name applies equality check predicate on the "name" field. It's identical to NameEQ.
func Name(v string) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldEQ(FieldName, v))
}

// TenantID applies equality check predicate on the "tenant_id" field. It's identical to TenantIDEQ.
func TenantID(v string) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldEQ(FieldTenantID, v))
}

// TenantName applies equality check predicate on the "tenant_name" field. It's identical to TenantNameEQ.
func TenantName(v string) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldEQ(FieldTenantName, v))
}

// ProjectID applies equality check predicate on the "project_id" field. It's identical to ProjectIDEQ.
func ProjectID(v string) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldEQ(FieldProjectID, v))
}

// ProjectName applies equality check predicate on the "project_name" field. It's identical to ProjectNameEQ.
func ProjectName(v string) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldEQ(FieldProjectName, v))
}

// Storageclass applies equality check predicate on the "storageclass" field. It's identical to StorageclassEQ.
func Storageclass(v string) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldEQ(FieldStorageclass, v))
}

// StorageclassName applies equality check predicate on the "storageclass_name" field. It's identical to StorageclassNameEQ.
func StorageclassName(v string) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldEQ(FieldStorageclassName, v))
}

// InnerEndpoint applies equality check predicate on the "inner_endpoint" field. It's identical to InnerEndpointEQ.
func InnerEndpoint(v string) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldEQ(FieldInnerEndpoint, v))
}

// OuterEndpoint applies equality check predicate on the "outer_endpoint" field. It's identical to OuterEndpointEQ.
func OuterEndpoint(v string) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldEQ(FieldOuterEndpoint, v))
}

// InnerDomain applies equality check predicate on the "inner_domain" field. It's identical to InnerDomainEQ.
func InnerDomain(v string) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldEQ(FieldInnerDomain, v))
}

// OuterDomain applies equality check predicate on the "outer_domain" field. It's identical to OuterDomainEQ.
func OuterDomain(v string) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldEQ(FieldOuterDomain, v))
}

// PoolID applies equality check predicate on the "pool_id" field. It's identical to PoolIDEQ.
func PoolID(v string) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldEQ(FieldPoolID, v))
}

// PoolName applies equality check predicate on the "pool_name" field. It's identical to PoolNameEQ.
func PoolName(v string) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldEQ(FieldPoolName, v))
}

// TotalStorage applies equality check predicate on the "total_storage" field. It's identical to TotalStorageEQ.
func TotalStorage(v int) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldEQ(FieldTotalStorage, v))
}

// AddStorage applies equality check predicate on the "add_storage" field. It's identical to AddStorageEQ.
func AddStorage(v int) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldEQ(FieldAddStorage, v))
}

// DeleteStorage applies equality check predicate on the "delete_storage" field. It's identical to DeleteStorageEQ.
func DeleteStorage(v int) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldEQ(FieldDeleteStorage, v))
}

// TotalObject applies equality check predicate on the "total_object" field. It's identical to TotalObjectEQ.
func TotalObject(v int) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldEQ(FieldTotalObject, v))
}

// AddObject applies equality check predicate on the "add_object" field. It's identical to AddObjectEQ.
func AddObject(v int) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldEQ(FieldAddObject, v))
}

// DeleteObject applies equality check predicate on the "delete_object" field. It's identical to DeleteObjectEQ.
func DeleteObject(v int) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldEQ(FieldDeleteObject, v))
}

// DownloadFlow applies equality check predicate on the "download_flow" field. It's identical to DownloadFlowEQ.
func DownloadFlow(v int) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldEQ(FieldDownloadFlow, v))
}

// UploadFlow applies equality check predicate on the "upload_flow" field. It's identical to UploadFlowEQ.
func UploadFlow(v int) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldEQ(FieldUploadFlow, v))
}

// RequestAmount applies equality check predicate on the "request_amount" field. It's identical to RequestAmountEQ.
func RequestAmount(v int) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldEQ(FieldRequestAmount, v))
}

// DownloadFlowMonth applies equality check predicate on the "download_flow_month" field. It's identical to DownloadFlowMonthEQ.
func DownloadFlowMonth(v int) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldEQ(FieldDownloadFlowMonth, v))
}

// UploadFlowMonth applies equality check predicate on the "upload_flow_month" field. It's identical to UploadFlowMonthEQ.
func UploadFlowMonth(v int) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldEQ(FieldUploadFlowMonth, v))
}

// RequestAmountMonth applies equality check predicate on the "request_amount_month" field. It's identical to RequestAmountMonthEQ.
func RequestAmountMonth(v int) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldEQ(FieldRequestAmountMonth, v))
}

// CreateTime applies equality check predicate on the "create_time" field. It's identical to CreateTimeEQ.
func CreateTime(v time.Time) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldEQ(FieldCreateTime, v))
}

// CreatedAtEQ applies the EQ predicate on the "created_at" field.
func CreatedAtEQ(v time.Time) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldEQ(FieldCreatedAt, v))
}

// CreatedAtNEQ applies the NEQ predicate on the "created_at" field.
func CreatedAtNEQ(v time.Time) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldNEQ(FieldCreatedAt, v))
}

// CreatedAtIn applies the In predicate on the "created_at" field.
func CreatedAtIn(vs ...time.Time) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldIn(FieldCreatedAt, vs...))
}

// CreatedAtNotIn applies the NotIn predicate on the "created_at" field.
func CreatedAtNotIn(vs ...time.Time) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldNotIn(FieldCreatedAt, vs...))
}

// CreatedAtGT applies the GT predicate on the "created_at" field.
func CreatedAtGT(v time.Time) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldGT(FieldCreatedAt, v))
}

// CreatedAtGTE applies the GTE predicate on the "created_at" field.
func CreatedAtGTE(v time.Time) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldGTE(FieldCreatedAt, v))
}

// CreatedAtLT applies the LT predicate on the "created_at" field.
func CreatedAtLT(v time.Time) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldLT(FieldCreatedAt, v))
}

// CreatedAtLTE applies the LTE predicate on the "created_at" field.
func CreatedAtLTE(v time.Time) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldLTE(FieldCreatedAt, v))
}

// CreatedAtIsNil applies the IsNil predicate on the "created_at" field.
func CreatedAtIsNil() predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldIsNull(FieldCreatedAt))
}

// CreatedAtNotNil applies the NotNil predicate on the "created_at" field.
func CreatedAtNotNil() predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldNotNull(FieldCreatedAt))
}

// UpdatedAtEQ applies the EQ predicate on the "updated_at" field.
func UpdatedAtEQ(v time.Time) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldEQ(FieldUpdatedAt, v))
}

// UpdatedAtNEQ applies the NEQ predicate on the "updated_at" field.
func UpdatedAtNEQ(v time.Time) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldNEQ(FieldUpdatedAt, v))
}

// UpdatedAtIn applies the In predicate on the "updated_at" field.
func UpdatedAtIn(vs ...time.Time) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldIn(FieldUpdatedAt, vs...))
}

// UpdatedAtNotIn applies the NotIn predicate on the "updated_at" field.
func UpdatedAtNotIn(vs ...time.Time) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldNotIn(FieldUpdatedAt, vs...))
}

// UpdatedAtGT applies the GT predicate on the "updated_at" field.
func UpdatedAtGT(v time.Time) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldGT(FieldUpdatedAt, v))
}

// UpdatedAtGTE applies the GTE predicate on the "updated_at" field.
func UpdatedAtGTE(v time.Time) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldGTE(FieldUpdatedAt, v))
}

// UpdatedAtLT applies the LT predicate on the "updated_at" field.
func UpdatedAtLT(v time.Time) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldLT(FieldUpdatedAt, v))
}

// UpdatedAtLTE applies the LTE predicate on the "updated_at" field.
func UpdatedAtLTE(v time.Time) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldLTE(FieldUpdatedAt, v))
}

// UpdatedAtIsNil applies the IsNil predicate on the "updated_at" field.
func UpdatedAtIsNil() predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldIsNull(FieldUpdatedAt))
}

// UpdatedAtNotNil applies the NotNil predicate on the "updated_at" field.
func UpdatedAtNotNil() predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldNotNull(FieldUpdatedAt))
}

// VersionEQ applies the EQ predicate on the "version" field.
func VersionEQ(v string) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldEQ(FieldVersion, v))
}

// VersionNEQ applies the NEQ predicate on the "version" field.
func VersionNEQ(v string) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldNEQ(FieldVersion, v))
}

// VersionIn applies the In predicate on the "version" field.
func VersionIn(vs ...string) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldIn(FieldVersion, vs...))
}

// VersionNotIn applies the NotIn predicate on the "version" field.
func VersionNotIn(vs ...string) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldNotIn(FieldVersion, vs...))
}

// VersionGT applies the GT predicate on the "version" field.
func VersionGT(v string) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldGT(FieldVersion, v))
}

// VersionGTE applies the GTE predicate on the "version" field.
func VersionGTE(v string) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldGTE(FieldVersion, v))
}

// VersionLT applies the LT predicate on the "version" field.
func VersionLT(v string) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldLT(FieldVersion, v))
}

// VersionLTE applies the LTE predicate on the "version" field.
func VersionLTE(v string) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldLTE(FieldVersion, v))
}

// VersionContains applies the Contains predicate on the "version" field.
func VersionContains(v string) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldContains(FieldVersion, v))
}

// VersionHasPrefix applies the HasPrefix predicate on the "version" field.
func VersionHasPrefix(v string) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldHasPrefix(FieldVersion, v))
}

// VersionHasSuffix applies the HasSuffix predicate on the "version" field.
func VersionHasSuffix(v string) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldHasSuffix(FieldVersion, v))
}

// VersionIsNil applies the IsNil predicate on the "version" field.
func VersionIsNil() predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldIsNull(FieldVersion))
}

// VersionNotNil applies the NotNil predicate on the "version" field.
func VersionNotNil() predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldNotNull(FieldVersion))
}

// VersionEqualFold applies the EqualFold predicate on the "version" field.
func VersionEqualFold(v string) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldEqualFold(FieldVersion, v))
}

// VersionContainsFold applies the ContainsFold predicate on the "version" field.
func VersionContainsFold(v string) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldContainsFold(FieldVersion, v))
}

// GalaxyEQ applies the EQ predicate on the "galaxy" field.
func GalaxyEQ(v string) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldEQ(FieldGalaxy, v))
}

// GalaxyNEQ applies the NEQ predicate on the "galaxy" field.
func GalaxyNEQ(v string) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldNEQ(FieldGalaxy, v))
}

// GalaxyIn applies the In predicate on the "galaxy" field.
func GalaxyIn(vs ...string) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldIn(FieldGalaxy, vs...))
}

// GalaxyNotIn applies the NotIn predicate on the "galaxy" field.
func GalaxyNotIn(vs ...string) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldNotIn(FieldGalaxy, vs...))
}

// GalaxyGT applies the GT predicate on the "galaxy" field.
func GalaxyGT(v string) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldGT(FieldGalaxy, v))
}

// GalaxyGTE applies the GTE predicate on the "galaxy" field.
func GalaxyGTE(v string) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldGTE(FieldGalaxy, v))
}

// GalaxyLT applies the LT predicate on the "galaxy" field.
func GalaxyLT(v string) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldLT(FieldGalaxy, v))
}

// GalaxyLTE applies the LTE predicate on the "galaxy" field.
func GalaxyLTE(v string) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldLTE(FieldGalaxy, v))
}

// GalaxyContains applies the Contains predicate on the "galaxy" field.
func GalaxyContains(v string) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldContains(FieldGalaxy, v))
}

// GalaxyHasPrefix applies the HasPrefix predicate on the "galaxy" field.
func GalaxyHasPrefix(v string) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldHasPrefix(FieldGalaxy, v))
}

// GalaxyHasSuffix applies the HasSuffix predicate on the "galaxy" field.
func GalaxyHasSuffix(v string) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldHasSuffix(FieldGalaxy, v))
}

// GalaxyIsNil applies the IsNil predicate on the "galaxy" field.
func GalaxyIsNil() predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldIsNull(FieldGalaxy))
}

// GalaxyNotNil applies the NotNil predicate on the "galaxy" field.
func GalaxyNotNil() predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldNotNull(FieldGalaxy))
}

// GalaxyEqualFold applies the EqualFold predicate on the "galaxy" field.
func GalaxyEqualFold(v string) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldEqualFold(FieldGalaxy, v))
}

// GalaxyContainsFold applies the ContainsFold predicate on the "galaxy" field.
func GalaxyContainsFold(v string) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldContainsFold(FieldGalaxy, v))
}

// RegionEQ applies the EQ predicate on the "region" field.
func RegionEQ(v string) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldEQ(FieldRegion, v))
}

// RegionNEQ applies the NEQ predicate on the "region" field.
func RegionNEQ(v string) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldNEQ(FieldRegion, v))
}

// RegionIn applies the In predicate on the "region" field.
func RegionIn(vs ...string) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldIn(FieldRegion, vs...))
}

// RegionNotIn applies the NotIn predicate on the "region" field.
func RegionNotIn(vs ...string) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldNotIn(FieldRegion, vs...))
}

// RegionGT applies the GT predicate on the "region" field.
func RegionGT(v string) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldGT(FieldRegion, v))
}

// RegionGTE applies the GTE predicate on the "region" field.
func RegionGTE(v string) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldGTE(FieldRegion, v))
}

// RegionLT applies the LT predicate on the "region" field.
func RegionLT(v string) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldLT(FieldRegion, v))
}

// RegionLTE applies the LTE predicate on the "region" field.
func RegionLTE(v string) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldLTE(FieldRegion, v))
}

// RegionContains applies the Contains predicate on the "region" field.
func RegionContains(v string) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldContains(FieldRegion, v))
}

// RegionHasPrefix applies the HasPrefix predicate on the "region" field.
func RegionHasPrefix(v string) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldHasPrefix(FieldRegion, v))
}

// RegionHasSuffix applies the HasSuffix predicate on the "region" field.
func RegionHasSuffix(v string) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldHasSuffix(FieldRegion, v))
}

// RegionIsNil applies the IsNil predicate on the "region" field.
func RegionIsNil() predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldIsNull(FieldRegion))
}

// RegionNotNil applies the NotNil predicate on the "region" field.
func RegionNotNil() predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldNotNull(FieldRegion))
}

// RegionEqualFold applies the EqualFold predicate on the "region" field.
func RegionEqualFold(v string) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldEqualFold(FieldRegion, v))
}

// RegionContainsFold applies the ContainsFold predicate on the "region" field.
func RegionContainsFold(v string) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldContainsFold(FieldRegion, v))
}

// DeletedEQ applies the EQ predicate on the "deleted" field.
func DeletedEQ(v bool) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldEQ(FieldDeleted, v))
}

// DeletedNEQ applies the NEQ predicate on the "deleted" field.
func DeletedNEQ(v bool) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldNEQ(FieldDeleted, v))
}

// DeletedIsNil applies the IsNil predicate on the "deleted" field.
func DeletedIsNil() predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldIsNull(FieldDeleted))
}

// DeletedNotNil applies the NotNil predicate on the "deleted" field.
func DeletedNotNil() predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldNotNull(FieldDeleted))
}

// BucketIDEQ applies the EQ predicate on the "bucket_id" field.
func BucketIDEQ(v int) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldEQ(FieldBucketID, v))
}

// BucketIDNEQ applies the NEQ predicate on the "bucket_id" field.
func BucketIDNEQ(v int) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldNEQ(FieldBucketID, v))
}

// BucketIDIn applies the In predicate on the "bucket_id" field.
func BucketIDIn(vs ...int) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldIn(FieldBucketID, vs...))
}

// BucketIDNotIn applies the NotIn predicate on the "bucket_id" field.
func BucketIDNotIn(vs ...int) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldNotIn(FieldBucketID, vs...))
}

// BucketIDGT applies the GT predicate on the "bucket_id" field.
func BucketIDGT(v int) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldGT(FieldBucketID, v))
}

// BucketIDGTE applies the GTE predicate on the "bucket_id" field.
func BucketIDGTE(v int) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldGTE(FieldBucketID, v))
}

// BucketIDLT applies the LT predicate on the "bucket_id" field.
func BucketIDLT(v int) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldLT(FieldBucketID, v))
}

// BucketIDLTE applies the LTE predicate on the "bucket_id" field.
func BucketIDLTE(v int) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldLTE(FieldBucketID, v))
}

// NameEQ applies the EQ predicate on the "name" field.
func NameEQ(v string) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldEQ(FieldName, v))
}

// NameNEQ applies the NEQ predicate on the "name" field.
func NameNEQ(v string) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldNEQ(FieldName, v))
}

// NameIn applies the In predicate on the "name" field.
func NameIn(vs ...string) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldIn(FieldName, vs...))
}

// NameNotIn applies the NotIn predicate on the "name" field.
func NameNotIn(vs ...string) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldNotIn(FieldName, vs...))
}

// NameGT applies the GT predicate on the "name" field.
func NameGT(v string) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldGT(FieldName, v))
}

// NameGTE applies the GTE predicate on the "name" field.
func NameGTE(v string) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldGTE(FieldName, v))
}

// NameLT applies the LT predicate on the "name" field.
func NameLT(v string) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldLT(FieldName, v))
}

// NameLTE applies the LTE predicate on the "name" field.
func NameLTE(v string) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldLTE(FieldName, v))
}

// NameContains applies the Contains predicate on the "name" field.
func NameContains(v string) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldContains(FieldName, v))
}

// NameHasPrefix applies the HasPrefix predicate on the "name" field.
func NameHasPrefix(v string) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldHasPrefix(FieldName, v))
}

// NameHasSuffix applies the HasSuffix predicate on the "name" field.
func NameHasSuffix(v string) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldHasSuffix(FieldName, v))
}

// NameEqualFold applies the EqualFold predicate on the "name" field.
func NameEqualFold(v string) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldEqualFold(FieldName, v))
}

// NameContainsFold applies the ContainsFold predicate on the "name" field.
func NameContainsFold(v string) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldContainsFold(FieldName, v))
}

// TenantIDEQ applies the EQ predicate on the "tenant_id" field.
func TenantIDEQ(v string) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldEQ(FieldTenantID, v))
}

// TenantIDNEQ applies the NEQ predicate on the "tenant_id" field.
func TenantIDNEQ(v string) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldNEQ(FieldTenantID, v))
}

// TenantIDIn applies the In predicate on the "tenant_id" field.
func TenantIDIn(vs ...string) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldIn(FieldTenantID, vs...))
}

// TenantIDNotIn applies the NotIn predicate on the "tenant_id" field.
func TenantIDNotIn(vs ...string) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldNotIn(FieldTenantID, vs...))
}

// TenantIDGT applies the GT predicate on the "tenant_id" field.
func TenantIDGT(v string) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldGT(FieldTenantID, v))
}

// TenantIDGTE applies the GTE predicate on the "tenant_id" field.
func TenantIDGTE(v string) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldGTE(FieldTenantID, v))
}

// TenantIDLT applies the LT predicate on the "tenant_id" field.
func TenantIDLT(v string) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldLT(FieldTenantID, v))
}

// TenantIDLTE applies the LTE predicate on the "tenant_id" field.
func TenantIDLTE(v string) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldLTE(FieldTenantID, v))
}

// TenantIDContains applies the Contains predicate on the "tenant_id" field.
func TenantIDContains(v string) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldContains(FieldTenantID, v))
}

// TenantIDHasPrefix applies the HasPrefix predicate on the "tenant_id" field.
func TenantIDHasPrefix(v string) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldHasPrefix(FieldTenantID, v))
}

// TenantIDHasSuffix applies the HasSuffix predicate on the "tenant_id" field.
func TenantIDHasSuffix(v string) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldHasSuffix(FieldTenantID, v))
}

// TenantIDEqualFold applies the EqualFold predicate on the "tenant_id" field.
func TenantIDEqualFold(v string) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldEqualFold(FieldTenantID, v))
}

// TenantIDContainsFold applies the ContainsFold predicate on the "tenant_id" field.
func TenantIDContainsFold(v string) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldContainsFold(FieldTenantID, v))
}

// TenantNameEQ applies the EQ predicate on the "tenant_name" field.
func TenantNameEQ(v string) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldEQ(FieldTenantName, v))
}

// TenantNameNEQ applies the NEQ predicate on the "tenant_name" field.
func TenantNameNEQ(v string) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldNEQ(FieldTenantName, v))
}

// TenantNameIn applies the In predicate on the "tenant_name" field.
func TenantNameIn(vs ...string) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldIn(FieldTenantName, vs...))
}

// TenantNameNotIn applies the NotIn predicate on the "tenant_name" field.
func TenantNameNotIn(vs ...string) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldNotIn(FieldTenantName, vs...))
}

// TenantNameGT applies the GT predicate on the "tenant_name" field.
func TenantNameGT(v string) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldGT(FieldTenantName, v))
}

// TenantNameGTE applies the GTE predicate on the "tenant_name" field.
func TenantNameGTE(v string) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldGTE(FieldTenantName, v))
}

// TenantNameLT applies the LT predicate on the "tenant_name" field.
func TenantNameLT(v string) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldLT(FieldTenantName, v))
}

// TenantNameLTE applies the LTE predicate on the "tenant_name" field.
func TenantNameLTE(v string) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldLTE(FieldTenantName, v))
}

// TenantNameContains applies the Contains predicate on the "tenant_name" field.
func TenantNameContains(v string) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldContains(FieldTenantName, v))
}

// TenantNameHasPrefix applies the HasPrefix predicate on the "tenant_name" field.
func TenantNameHasPrefix(v string) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldHasPrefix(FieldTenantName, v))
}

// TenantNameHasSuffix applies the HasSuffix predicate on the "tenant_name" field.
func TenantNameHasSuffix(v string) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldHasSuffix(FieldTenantName, v))
}

// TenantNameIsNil applies the IsNil predicate on the "tenant_name" field.
func TenantNameIsNil() predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldIsNull(FieldTenantName))
}

// TenantNameNotNil applies the NotNil predicate on the "tenant_name" field.
func TenantNameNotNil() predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldNotNull(FieldTenantName))
}

// TenantNameEqualFold applies the EqualFold predicate on the "tenant_name" field.
func TenantNameEqualFold(v string) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldEqualFold(FieldTenantName, v))
}

// TenantNameContainsFold applies the ContainsFold predicate on the "tenant_name" field.
func TenantNameContainsFold(v string) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldContainsFold(FieldTenantName, v))
}

// ProjectIDEQ applies the EQ predicate on the "project_id" field.
func ProjectIDEQ(v string) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldEQ(FieldProjectID, v))
}

// ProjectIDNEQ applies the NEQ predicate on the "project_id" field.
func ProjectIDNEQ(v string) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldNEQ(FieldProjectID, v))
}

// ProjectIDIn applies the In predicate on the "project_id" field.
func ProjectIDIn(vs ...string) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldIn(FieldProjectID, vs...))
}

// ProjectIDNotIn applies the NotIn predicate on the "project_id" field.
func ProjectIDNotIn(vs ...string) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldNotIn(FieldProjectID, vs...))
}

// ProjectIDGT applies the GT predicate on the "project_id" field.
func ProjectIDGT(v string) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldGT(FieldProjectID, v))
}

// ProjectIDGTE applies the GTE predicate on the "project_id" field.
func ProjectIDGTE(v string) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldGTE(FieldProjectID, v))
}

// ProjectIDLT applies the LT predicate on the "project_id" field.
func ProjectIDLT(v string) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldLT(FieldProjectID, v))
}

// ProjectIDLTE applies the LTE predicate on the "project_id" field.
func ProjectIDLTE(v string) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldLTE(FieldProjectID, v))
}

// ProjectIDContains applies the Contains predicate on the "project_id" field.
func ProjectIDContains(v string) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldContains(FieldProjectID, v))
}

// ProjectIDHasPrefix applies the HasPrefix predicate on the "project_id" field.
func ProjectIDHasPrefix(v string) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldHasPrefix(FieldProjectID, v))
}

// ProjectIDHasSuffix applies the HasSuffix predicate on the "project_id" field.
func ProjectIDHasSuffix(v string) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldHasSuffix(FieldProjectID, v))
}

// ProjectIDEqualFold applies the EqualFold predicate on the "project_id" field.
func ProjectIDEqualFold(v string) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldEqualFold(FieldProjectID, v))
}

// ProjectIDContainsFold applies the ContainsFold predicate on the "project_id" field.
func ProjectIDContainsFold(v string) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldContainsFold(FieldProjectID, v))
}

// ProjectNameEQ applies the EQ predicate on the "project_name" field.
func ProjectNameEQ(v string) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldEQ(FieldProjectName, v))
}

// ProjectNameNEQ applies the NEQ predicate on the "project_name" field.
func ProjectNameNEQ(v string) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldNEQ(FieldProjectName, v))
}

// ProjectNameIn applies the In predicate on the "project_name" field.
func ProjectNameIn(vs ...string) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldIn(FieldProjectName, vs...))
}

// ProjectNameNotIn applies the NotIn predicate on the "project_name" field.
func ProjectNameNotIn(vs ...string) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldNotIn(FieldProjectName, vs...))
}

// ProjectNameGT applies the GT predicate on the "project_name" field.
func ProjectNameGT(v string) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldGT(FieldProjectName, v))
}

// ProjectNameGTE applies the GTE predicate on the "project_name" field.
func ProjectNameGTE(v string) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldGTE(FieldProjectName, v))
}

// ProjectNameLT applies the LT predicate on the "project_name" field.
func ProjectNameLT(v string) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldLT(FieldProjectName, v))
}

// ProjectNameLTE applies the LTE predicate on the "project_name" field.
func ProjectNameLTE(v string) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldLTE(FieldProjectName, v))
}

// ProjectNameContains applies the Contains predicate on the "project_name" field.
func ProjectNameContains(v string) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldContains(FieldProjectName, v))
}

// ProjectNameHasPrefix applies the HasPrefix predicate on the "project_name" field.
func ProjectNameHasPrefix(v string) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldHasPrefix(FieldProjectName, v))
}

// ProjectNameHasSuffix applies the HasSuffix predicate on the "project_name" field.
func ProjectNameHasSuffix(v string) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldHasSuffix(FieldProjectName, v))
}

// ProjectNameEqualFold applies the EqualFold predicate on the "project_name" field.
func ProjectNameEqualFold(v string) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldEqualFold(FieldProjectName, v))
}

// ProjectNameContainsFold applies the ContainsFold predicate on the "project_name" field.
func ProjectNameContainsFold(v string) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldContainsFold(FieldProjectName, v))
}

// StorageclassEQ applies the EQ predicate on the "storageclass" field.
func StorageclassEQ(v string) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldEQ(FieldStorageclass, v))
}

// StorageclassNEQ applies the NEQ predicate on the "storageclass" field.
func StorageclassNEQ(v string) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldNEQ(FieldStorageclass, v))
}

// StorageclassIn applies the In predicate on the "storageclass" field.
func StorageclassIn(vs ...string) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldIn(FieldStorageclass, vs...))
}

// StorageclassNotIn applies the NotIn predicate on the "storageclass" field.
func StorageclassNotIn(vs ...string) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldNotIn(FieldStorageclass, vs...))
}

// StorageclassGT applies the GT predicate on the "storageclass" field.
func StorageclassGT(v string) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldGT(FieldStorageclass, v))
}

// StorageclassGTE applies the GTE predicate on the "storageclass" field.
func StorageclassGTE(v string) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldGTE(FieldStorageclass, v))
}

// StorageclassLT applies the LT predicate on the "storageclass" field.
func StorageclassLT(v string) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldLT(FieldStorageclass, v))
}

// StorageclassLTE applies the LTE predicate on the "storageclass" field.
func StorageclassLTE(v string) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldLTE(FieldStorageclass, v))
}

// StorageclassContains applies the Contains predicate on the "storageclass" field.
func StorageclassContains(v string) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldContains(FieldStorageclass, v))
}

// StorageclassHasPrefix applies the HasPrefix predicate on the "storageclass" field.
func StorageclassHasPrefix(v string) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldHasPrefix(FieldStorageclass, v))
}

// StorageclassHasSuffix applies the HasSuffix predicate on the "storageclass" field.
func StorageclassHasSuffix(v string) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldHasSuffix(FieldStorageclass, v))
}

// StorageclassIsNil applies the IsNil predicate on the "storageclass" field.
func StorageclassIsNil() predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldIsNull(FieldStorageclass))
}

// StorageclassNotNil applies the NotNil predicate on the "storageclass" field.
func StorageclassNotNil() predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldNotNull(FieldStorageclass))
}

// StorageclassEqualFold applies the EqualFold predicate on the "storageclass" field.
func StorageclassEqualFold(v string) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldEqualFold(FieldStorageclass, v))
}

// StorageclassContainsFold applies the ContainsFold predicate on the "storageclass" field.
func StorageclassContainsFold(v string) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldContainsFold(FieldStorageclass, v))
}

// StorageclassNameEQ applies the EQ predicate on the "storageclass_name" field.
func StorageclassNameEQ(v string) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldEQ(FieldStorageclassName, v))
}

// StorageclassNameNEQ applies the NEQ predicate on the "storageclass_name" field.
func StorageclassNameNEQ(v string) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldNEQ(FieldStorageclassName, v))
}

// StorageclassNameIn applies the In predicate on the "storageclass_name" field.
func StorageclassNameIn(vs ...string) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldIn(FieldStorageclassName, vs...))
}

// StorageclassNameNotIn applies the NotIn predicate on the "storageclass_name" field.
func StorageclassNameNotIn(vs ...string) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldNotIn(FieldStorageclassName, vs...))
}

// StorageclassNameGT applies the GT predicate on the "storageclass_name" field.
func StorageclassNameGT(v string) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldGT(FieldStorageclassName, v))
}

// StorageclassNameGTE applies the GTE predicate on the "storageclass_name" field.
func StorageclassNameGTE(v string) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldGTE(FieldStorageclassName, v))
}

// StorageclassNameLT applies the LT predicate on the "storageclass_name" field.
func StorageclassNameLT(v string) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldLT(FieldStorageclassName, v))
}

// StorageclassNameLTE applies the LTE predicate on the "storageclass_name" field.
func StorageclassNameLTE(v string) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldLTE(FieldStorageclassName, v))
}

// StorageclassNameContains applies the Contains predicate on the "storageclass_name" field.
func StorageclassNameContains(v string) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldContains(FieldStorageclassName, v))
}

// StorageclassNameHasPrefix applies the HasPrefix predicate on the "storageclass_name" field.
func StorageclassNameHasPrefix(v string) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldHasPrefix(FieldStorageclassName, v))
}

// StorageclassNameHasSuffix applies the HasSuffix predicate on the "storageclass_name" field.
func StorageclassNameHasSuffix(v string) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldHasSuffix(FieldStorageclassName, v))
}

// StorageclassNameIsNil applies the IsNil predicate on the "storageclass_name" field.
func StorageclassNameIsNil() predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldIsNull(FieldStorageclassName))
}

// StorageclassNameNotNil applies the NotNil predicate on the "storageclass_name" field.
func StorageclassNameNotNil() predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldNotNull(FieldStorageclassName))
}

// StorageclassNameEqualFold applies the EqualFold predicate on the "storageclass_name" field.
func StorageclassNameEqualFold(v string) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldEqualFold(FieldStorageclassName, v))
}

// StorageclassNameContainsFold applies the ContainsFold predicate on the "storageclass_name" field.
func StorageclassNameContainsFold(v string) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldContainsFold(FieldStorageclassName, v))
}

// InnerEndpointEQ applies the EQ predicate on the "inner_endpoint" field.
func InnerEndpointEQ(v string) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldEQ(FieldInnerEndpoint, v))
}

// InnerEndpointNEQ applies the NEQ predicate on the "inner_endpoint" field.
func InnerEndpointNEQ(v string) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldNEQ(FieldInnerEndpoint, v))
}

// InnerEndpointIn applies the In predicate on the "inner_endpoint" field.
func InnerEndpointIn(vs ...string) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldIn(FieldInnerEndpoint, vs...))
}

// InnerEndpointNotIn applies the NotIn predicate on the "inner_endpoint" field.
func InnerEndpointNotIn(vs ...string) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldNotIn(FieldInnerEndpoint, vs...))
}

// InnerEndpointGT applies the GT predicate on the "inner_endpoint" field.
func InnerEndpointGT(v string) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldGT(FieldInnerEndpoint, v))
}

// InnerEndpointGTE applies the GTE predicate on the "inner_endpoint" field.
func InnerEndpointGTE(v string) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldGTE(FieldInnerEndpoint, v))
}

// InnerEndpointLT applies the LT predicate on the "inner_endpoint" field.
func InnerEndpointLT(v string) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldLT(FieldInnerEndpoint, v))
}

// InnerEndpointLTE applies the LTE predicate on the "inner_endpoint" field.
func InnerEndpointLTE(v string) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldLTE(FieldInnerEndpoint, v))
}

// InnerEndpointContains applies the Contains predicate on the "inner_endpoint" field.
func InnerEndpointContains(v string) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldContains(FieldInnerEndpoint, v))
}

// InnerEndpointHasPrefix applies the HasPrefix predicate on the "inner_endpoint" field.
func InnerEndpointHasPrefix(v string) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldHasPrefix(FieldInnerEndpoint, v))
}

// InnerEndpointHasSuffix applies the HasSuffix predicate on the "inner_endpoint" field.
func InnerEndpointHasSuffix(v string) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldHasSuffix(FieldInnerEndpoint, v))
}

// InnerEndpointEqualFold applies the EqualFold predicate on the "inner_endpoint" field.
func InnerEndpointEqualFold(v string) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldEqualFold(FieldInnerEndpoint, v))
}

// InnerEndpointContainsFold applies the ContainsFold predicate on the "inner_endpoint" field.
func InnerEndpointContainsFold(v string) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldContainsFold(FieldInnerEndpoint, v))
}

// OuterEndpointEQ applies the EQ predicate on the "outer_endpoint" field.
func OuterEndpointEQ(v string) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldEQ(FieldOuterEndpoint, v))
}

// OuterEndpointNEQ applies the NEQ predicate on the "outer_endpoint" field.
func OuterEndpointNEQ(v string) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldNEQ(FieldOuterEndpoint, v))
}

// OuterEndpointIn applies the In predicate on the "outer_endpoint" field.
func OuterEndpointIn(vs ...string) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldIn(FieldOuterEndpoint, vs...))
}

// OuterEndpointNotIn applies the NotIn predicate on the "outer_endpoint" field.
func OuterEndpointNotIn(vs ...string) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldNotIn(FieldOuterEndpoint, vs...))
}

// OuterEndpointGT applies the GT predicate on the "outer_endpoint" field.
func OuterEndpointGT(v string) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldGT(FieldOuterEndpoint, v))
}

// OuterEndpointGTE applies the GTE predicate on the "outer_endpoint" field.
func OuterEndpointGTE(v string) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldGTE(FieldOuterEndpoint, v))
}

// OuterEndpointLT applies the LT predicate on the "outer_endpoint" field.
func OuterEndpointLT(v string) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldLT(FieldOuterEndpoint, v))
}

// OuterEndpointLTE applies the LTE predicate on the "outer_endpoint" field.
func OuterEndpointLTE(v string) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldLTE(FieldOuterEndpoint, v))
}

// OuterEndpointContains applies the Contains predicate on the "outer_endpoint" field.
func OuterEndpointContains(v string) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldContains(FieldOuterEndpoint, v))
}

// OuterEndpointHasPrefix applies the HasPrefix predicate on the "outer_endpoint" field.
func OuterEndpointHasPrefix(v string) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldHasPrefix(FieldOuterEndpoint, v))
}

// OuterEndpointHasSuffix applies the HasSuffix predicate on the "outer_endpoint" field.
func OuterEndpointHasSuffix(v string) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldHasSuffix(FieldOuterEndpoint, v))
}

// OuterEndpointEqualFold applies the EqualFold predicate on the "outer_endpoint" field.
func OuterEndpointEqualFold(v string) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldEqualFold(FieldOuterEndpoint, v))
}

// OuterEndpointContainsFold applies the ContainsFold predicate on the "outer_endpoint" field.
func OuterEndpointContainsFold(v string) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldContainsFold(FieldOuterEndpoint, v))
}

// InnerDomainEQ applies the EQ predicate on the "inner_domain" field.
func InnerDomainEQ(v string) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldEQ(FieldInnerDomain, v))
}

// InnerDomainNEQ applies the NEQ predicate on the "inner_domain" field.
func InnerDomainNEQ(v string) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldNEQ(FieldInnerDomain, v))
}

// InnerDomainIn applies the In predicate on the "inner_domain" field.
func InnerDomainIn(vs ...string) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldIn(FieldInnerDomain, vs...))
}

// InnerDomainNotIn applies the NotIn predicate on the "inner_domain" field.
func InnerDomainNotIn(vs ...string) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldNotIn(FieldInnerDomain, vs...))
}

// InnerDomainGT applies the GT predicate on the "inner_domain" field.
func InnerDomainGT(v string) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldGT(FieldInnerDomain, v))
}

// InnerDomainGTE applies the GTE predicate on the "inner_domain" field.
func InnerDomainGTE(v string) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldGTE(FieldInnerDomain, v))
}

// InnerDomainLT applies the LT predicate on the "inner_domain" field.
func InnerDomainLT(v string) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldLT(FieldInnerDomain, v))
}

// InnerDomainLTE applies the LTE predicate on the "inner_domain" field.
func InnerDomainLTE(v string) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldLTE(FieldInnerDomain, v))
}

// InnerDomainContains applies the Contains predicate on the "inner_domain" field.
func InnerDomainContains(v string) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldContains(FieldInnerDomain, v))
}

// InnerDomainHasPrefix applies the HasPrefix predicate on the "inner_domain" field.
func InnerDomainHasPrefix(v string) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldHasPrefix(FieldInnerDomain, v))
}

// InnerDomainHasSuffix applies the HasSuffix predicate on the "inner_domain" field.
func InnerDomainHasSuffix(v string) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldHasSuffix(FieldInnerDomain, v))
}

// InnerDomainIsNil applies the IsNil predicate on the "inner_domain" field.
func InnerDomainIsNil() predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldIsNull(FieldInnerDomain))
}

// InnerDomainNotNil applies the NotNil predicate on the "inner_domain" field.
func InnerDomainNotNil() predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldNotNull(FieldInnerDomain))
}

// InnerDomainEqualFold applies the EqualFold predicate on the "inner_domain" field.
func InnerDomainEqualFold(v string) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldEqualFold(FieldInnerDomain, v))
}

// InnerDomainContainsFold applies the ContainsFold predicate on the "inner_domain" field.
func InnerDomainContainsFold(v string) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldContainsFold(FieldInnerDomain, v))
}

// OuterDomainEQ applies the EQ predicate on the "outer_domain" field.
func OuterDomainEQ(v string) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldEQ(FieldOuterDomain, v))
}

// OuterDomainNEQ applies the NEQ predicate on the "outer_domain" field.
func OuterDomainNEQ(v string) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldNEQ(FieldOuterDomain, v))
}

// OuterDomainIn applies the In predicate on the "outer_domain" field.
func OuterDomainIn(vs ...string) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldIn(FieldOuterDomain, vs...))
}

// OuterDomainNotIn applies the NotIn predicate on the "outer_domain" field.
func OuterDomainNotIn(vs ...string) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldNotIn(FieldOuterDomain, vs...))
}

// OuterDomainGT applies the GT predicate on the "outer_domain" field.
func OuterDomainGT(v string) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldGT(FieldOuterDomain, v))
}

// OuterDomainGTE applies the GTE predicate on the "outer_domain" field.
func OuterDomainGTE(v string) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldGTE(FieldOuterDomain, v))
}

// OuterDomainLT applies the LT predicate on the "outer_domain" field.
func OuterDomainLT(v string) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldLT(FieldOuterDomain, v))
}

// OuterDomainLTE applies the LTE predicate on the "outer_domain" field.
func OuterDomainLTE(v string) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldLTE(FieldOuterDomain, v))
}

// OuterDomainContains applies the Contains predicate on the "outer_domain" field.
func OuterDomainContains(v string) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldContains(FieldOuterDomain, v))
}

// OuterDomainHasPrefix applies the HasPrefix predicate on the "outer_domain" field.
func OuterDomainHasPrefix(v string) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldHasPrefix(FieldOuterDomain, v))
}

// OuterDomainHasSuffix applies the HasSuffix predicate on the "outer_domain" field.
func OuterDomainHasSuffix(v string) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldHasSuffix(FieldOuterDomain, v))
}

// OuterDomainIsNil applies the IsNil predicate on the "outer_domain" field.
func OuterDomainIsNil() predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldIsNull(FieldOuterDomain))
}

// OuterDomainNotNil applies the NotNil predicate on the "outer_domain" field.
func OuterDomainNotNil() predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldNotNull(FieldOuterDomain))
}

// OuterDomainEqualFold applies the EqualFold predicate on the "outer_domain" field.
func OuterDomainEqualFold(v string) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldEqualFold(FieldOuterDomain, v))
}

// OuterDomainContainsFold applies the ContainsFold predicate on the "outer_domain" field.
func OuterDomainContainsFold(v string) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldContainsFold(FieldOuterDomain, v))
}

// PoolIDEQ applies the EQ predicate on the "pool_id" field.
func PoolIDEQ(v string) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldEQ(FieldPoolID, v))
}

// PoolIDNEQ applies the NEQ predicate on the "pool_id" field.
func PoolIDNEQ(v string) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldNEQ(FieldPoolID, v))
}

// PoolIDIn applies the In predicate on the "pool_id" field.
func PoolIDIn(vs ...string) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldIn(FieldPoolID, vs...))
}

// PoolIDNotIn applies the NotIn predicate on the "pool_id" field.
func PoolIDNotIn(vs ...string) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldNotIn(FieldPoolID, vs...))
}

// PoolIDGT applies the GT predicate on the "pool_id" field.
func PoolIDGT(v string) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldGT(FieldPoolID, v))
}

// PoolIDGTE applies the GTE predicate on the "pool_id" field.
func PoolIDGTE(v string) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldGTE(FieldPoolID, v))
}

// PoolIDLT applies the LT predicate on the "pool_id" field.
func PoolIDLT(v string) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldLT(FieldPoolID, v))
}

// PoolIDLTE applies the LTE predicate on the "pool_id" field.
func PoolIDLTE(v string) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldLTE(FieldPoolID, v))
}

// PoolIDContains applies the Contains predicate on the "pool_id" field.
func PoolIDContains(v string) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldContains(FieldPoolID, v))
}

// PoolIDHasPrefix applies the HasPrefix predicate on the "pool_id" field.
func PoolIDHasPrefix(v string) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldHasPrefix(FieldPoolID, v))
}

// PoolIDHasSuffix applies the HasSuffix predicate on the "pool_id" field.
func PoolIDHasSuffix(v string) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldHasSuffix(FieldPoolID, v))
}

// PoolIDIsNil applies the IsNil predicate on the "pool_id" field.
func PoolIDIsNil() predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldIsNull(FieldPoolID))
}

// PoolIDNotNil applies the NotNil predicate on the "pool_id" field.
func PoolIDNotNil() predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldNotNull(FieldPoolID))
}

// PoolIDEqualFold applies the EqualFold predicate on the "pool_id" field.
func PoolIDEqualFold(v string) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldEqualFold(FieldPoolID, v))
}

// PoolIDContainsFold applies the ContainsFold predicate on the "pool_id" field.
func PoolIDContainsFold(v string) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldContainsFold(FieldPoolID, v))
}

// PoolNameEQ applies the EQ predicate on the "pool_name" field.
func PoolNameEQ(v string) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldEQ(FieldPoolName, v))
}

// PoolNameNEQ applies the NEQ predicate on the "pool_name" field.
func PoolNameNEQ(v string) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldNEQ(FieldPoolName, v))
}

// PoolNameIn applies the In predicate on the "pool_name" field.
func PoolNameIn(vs ...string) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldIn(FieldPoolName, vs...))
}

// PoolNameNotIn applies the NotIn predicate on the "pool_name" field.
func PoolNameNotIn(vs ...string) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldNotIn(FieldPoolName, vs...))
}

// PoolNameGT applies the GT predicate on the "pool_name" field.
func PoolNameGT(v string) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldGT(FieldPoolName, v))
}

// PoolNameGTE applies the GTE predicate on the "pool_name" field.
func PoolNameGTE(v string) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldGTE(FieldPoolName, v))
}

// PoolNameLT applies the LT predicate on the "pool_name" field.
func PoolNameLT(v string) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldLT(FieldPoolName, v))
}

// PoolNameLTE applies the LTE predicate on the "pool_name" field.
func PoolNameLTE(v string) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldLTE(FieldPoolName, v))
}

// PoolNameContains applies the Contains predicate on the "pool_name" field.
func PoolNameContains(v string) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldContains(FieldPoolName, v))
}

// PoolNameHasPrefix applies the HasPrefix predicate on the "pool_name" field.
func PoolNameHasPrefix(v string) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldHasPrefix(FieldPoolName, v))
}

// PoolNameHasSuffix applies the HasSuffix predicate on the "pool_name" field.
func PoolNameHasSuffix(v string) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldHasSuffix(FieldPoolName, v))
}

// PoolNameIsNil applies the IsNil predicate on the "pool_name" field.
func PoolNameIsNil() predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldIsNull(FieldPoolName))
}

// PoolNameNotNil applies the NotNil predicate on the "pool_name" field.
func PoolNameNotNil() predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldNotNull(FieldPoolName))
}

// PoolNameEqualFold applies the EqualFold predicate on the "pool_name" field.
func PoolNameEqualFold(v string) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldEqualFold(FieldPoolName, v))
}

// PoolNameContainsFold applies the ContainsFold predicate on the "pool_name" field.
func PoolNameContainsFold(v string) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldContainsFold(FieldPoolName, v))
}

// TotalStorageEQ applies the EQ predicate on the "total_storage" field.
func TotalStorageEQ(v int) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldEQ(FieldTotalStorage, v))
}

// TotalStorageNEQ applies the NEQ predicate on the "total_storage" field.
func TotalStorageNEQ(v int) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldNEQ(FieldTotalStorage, v))
}

// TotalStorageIn applies the In predicate on the "total_storage" field.
func TotalStorageIn(vs ...int) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldIn(FieldTotalStorage, vs...))
}

// TotalStorageNotIn applies the NotIn predicate on the "total_storage" field.
func TotalStorageNotIn(vs ...int) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldNotIn(FieldTotalStorage, vs...))
}

// TotalStorageGT applies the GT predicate on the "total_storage" field.
func TotalStorageGT(v int) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldGT(FieldTotalStorage, v))
}

// TotalStorageGTE applies the GTE predicate on the "total_storage" field.
func TotalStorageGTE(v int) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldGTE(FieldTotalStorage, v))
}

// TotalStorageLT applies the LT predicate on the "total_storage" field.
func TotalStorageLT(v int) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldLT(FieldTotalStorage, v))
}

// TotalStorageLTE applies the LTE predicate on the "total_storage" field.
func TotalStorageLTE(v int) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldLTE(FieldTotalStorage, v))
}

// TotalStorageIsNil applies the IsNil predicate on the "total_storage" field.
func TotalStorageIsNil() predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldIsNull(FieldTotalStorage))
}

// TotalStorageNotNil applies the NotNil predicate on the "total_storage" field.
func TotalStorageNotNil() predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldNotNull(FieldTotalStorage))
}

// AddStorageEQ applies the EQ predicate on the "add_storage" field.
func AddStorageEQ(v int) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldEQ(FieldAddStorage, v))
}

// AddStorageNEQ applies the NEQ predicate on the "add_storage" field.
func AddStorageNEQ(v int) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldNEQ(FieldAddStorage, v))
}

// AddStorageIn applies the In predicate on the "add_storage" field.
func AddStorageIn(vs ...int) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldIn(FieldAddStorage, vs...))
}

// AddStorageNotIn applies the NotIn predicate on the "add_storage" field.
func AddStorageNotIn(vs ...int) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldNotIn(FieldAddStorage, vs...))
}

// AddStorageGT applies the GT predicate on the "add_storage" field.
func AddStorageGT(v int) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldGT(FieldAddStorage, v))
}

// AddStorageGTE applies the GTE predicate on the "add_storage" field.
func AddStorageGTE(v int) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldGTE(FieldAddStorage, v))
}

// AddStorageLT applies the LT predicate on the "add_storage" field.
func AddStorageLT(v int) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldLT(FieldAddStorage, v))
}

// AddStorageLTE applies the LTE predicate on the "add_storage" field.
func AddStorageLTE(v int) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldLTE(FieldAddStorage, v))
}

// AddStorageIsNil applies the IsNil predicate on the "add_storage" field.
func AddStorageIsNil() predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldIsNull(FieldAddStorage))
}

// AddStorageNotNil applies the NotNil predicate on the "add_storage" field.
func AddStorageNotNil() predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldNotNull(FieldAddStorage))
}

// DeleteStorageEQ applies the EQ predicate on the "delete_storage" field.
func DeleteStorageEQ(v int) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldEQ(FieldDeleteStorage, v))
}

// DeleteStorageNEQ applies the NEQ predicate on the "delete_storage" field.
func DeleteStorageNEQ(v int) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldNEQ(FieldDeleteStorage, v))
}

// DeleteStorageIn applies the In predicate on the "delete_storage" field.
func DeleteStorageIn(vs ...int) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldIn(FieldDeleteStorage, vs...))
}

// DeleteStorageNotIn applies the NotIn predicate on the "delete_storage" field.
func DeleteStorageNotIn(vs ...int) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldNotIn(FieldDeleteStorage, vs...))
}

// DeleteStorageGT applies the GT predicate on the "delete_storage" field.
func DeleteStorageGT(v int) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldGT(FieldDeleteStorage, v))
}

// DeleteStorageGTE applies the GTE predicate on the "delete_storage" field.
func DeleteStorageGTE(v int) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldGTE(FieldDeleteStorage, v))
}

// DeleteStorageLT applies the LT predicate on the "delete_storage" field.
func DeleteStorageLT(v int) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldLT(FieldDeleteStorage, v))
}

// DeleteStorageLTE applies the LTE predicate on the "delete_storage" field.
func DeleteStorageLTE(v int) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldLTE(FieldDeleteStorage, v))
}

// DeleteStorageIsNil applies the IsNil predicate on the "delete_storage" field.
func DeleteStorageIsNil() predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldIsNull(FieldDeleteStorage))
}

// DeleteStorageNotNil applies the NotNil predicate on the "delete_storage" field.
func DeleteStorageNotNil() predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldNotNull(FieldDeleteStorage))
}

// TotalObjectEQ applies the EQ predicate on the "total_object" field.
func TotalObjectEQ(v int) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldEQ(FieldTotalObject, v))
}

// TotalObjectNEQ applies the NEQ predicate on the "total_object" field.
func TotalObjectNEQ(v int) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldNEQ(FieldTotalObject, v))
}

// TotalObjectIn applies the In predicate on the "total_object" field.
func TotalObjectIn(vs ...int) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldIn(FieldTotalObject, vs...))
}

// TotalObjectNotIn applies the NotIn predicate on the "total_object" field.
func TotalObjectNotIn(vs ...int) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldNotIn(FieldTotalObject, vs...))
}

// TotalObjectGT applies the GT predicate on the "total_object" field.
func TotalObjectGT(v int) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldGT(FieldTotalObject, v))
}

// TotalObjectGTE applies the GTE predicate on the "total_object" field.
func TotalObjectGTE(v int) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldGTE(FieldTotalObject, v))
}

// TotalObjectLT applies the LT predicate on the "total_object" field.
func TotalObjectLT(v int) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldLT(FieldTotalObject, v))
}

// TotalObjectLTE applies the LTE predicate on the "total_object" field.
func TotalObjectLTE(v int) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldLTE(FieldTotalObject, v))
}

// TotalObjectIsNil applies the IsNil predicate on the "total_object" field.
func TotalObjectIsNil() predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldIsNull(FieldTotalObject))
}

// TotalObjectNotNil applies the NotNil predicate on the "total_object" field.
func TotalObjectNotNil() predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldNotNull(FieldTotalObject))
}

// AddObjectEQ applies the EQ predicate on the "add_object" field.
func AddObjectEQ(v int) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldEQ(FieldAddObject, v))
}

// AddObjectNEQ applies the NEQ predicate on the "add_object" field.
func AddObjectNEQ(v int) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldNEQ(FieldAddObject, v))
}

// AddObjectIn applies the In predicate on the "add_object" field.
func AddObjectIn(vs ...int) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldIn(FieldAddObject, vs...))
}

// AddObjectNotIn applies the NotIn predicate on the "add_object" field.
func AddObjectNotIn(vs ...int) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldNotIn(FieldAddObject, vs...))
}

// AddObjectGT applies the GT predicate on the "add_object" field.
func AddObjectGT(v int) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldGT(FieldAddObject, v))
}

// AddObjectGTE applies the GTE predicate on the "add_object" field.
func AddObjectGTE(v int) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldGTE(FieldAddObject, v))
}

// AddObjectLT applies the LT predicate on the "add_object" field.
func AddObjectLT(v int) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldLT(FieldAddObject, v))
}

// AddObjectLTE applies the LTE predicate on the "add_object" field.
func AddObjectLTE(v int) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldLTE(FieldAddObject, v))
}

// AddObjectIsNil applies the IsNil predicate on the "add_object" field.
func AddObjectIsNil() predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldIsNull(FieldAddObject))
}

// AddObjectNotNil applies the NotNil predicate on the "add_object" field.
func AddObjectNotNil() predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldNotNull(FieldAddObject))
}

// DeleteObjectEQ applies the EQ predicate on the "delete_object" field.
func DeleteObjectEQ(v int) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldEQ(FieldDeleteObject, v))
}

// DeleteObjectNEQ applies the NEQ predicate on the "delete_object" field.
func DeleteObjectNEQ(v int) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldNEQ(FieldDeleteObject, v))
}

// DeleteObjectIn applies the In predicate on the "delete_object" field.
func DeleteObjectIn(vs ...int) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldIn(FieldDeleteObject, vs...))
}

// DeleteObjectNotIn applies the NotIn predicate on the "delete_object" field.
func DeleteObjectNotIn(vs ...int) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldNotIn(FieldDeleteObject, vs...))
}

// DeleteObjectGT applies the GT predicate on the "delete_object" field.
func DeleteObjectGT(v int) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldGT(FieldDeleteObject, v))
}

// DeleteObjectGTE applies the GTE predicate on the "delete_object" field.
func DeleteObjectGTE(v int) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldGTE(FieldDeleteObject, v))
}

// DeleteObjectLT applies the LT predicate on the "delete_object" field.
func DeleteObjectLT(v int) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldLT(FieldDeleteObject, v))
}

// DeleteObjectLTE applies the LTE predicate on the "delete_object" field.
func DeleteObjectLTE(v int) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldLTE(FieldDeleteObject, v))
}

// DeleteObjectIsNil applies the IsNil predicate on the "delete_object" field.
func DeleteObjectIsNil() predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldIsNull(FieldDeleteObject))
}

// DeleteObjectNotNil applies the NotNil predicate on the "delete_object" field.
func DeleteObjectNotNil() predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldNotNull(FieldDeleteObject))
}

// DownloadFlowEQ applies the EQ predicate on the "download_flow" field.
func DownloadFlowEQ(v int) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldEQ(FieldDownloadFlow, v))
}

// DownloadFlowNEQ applies the NEQ predicate on the "download_flow" field.
func DownloadFlowNEQ(v int) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldNEQ(FieldDownloadFlow, v))
}

// DownloadFlowIn applies the In predicate on the "download_flow" field.
func DownloadFlowIn(vs ...int) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldIn(FieldDownloadFlow, vs...))
}

// DownloadFlowNotIn applies the NotIn predicate on the "download_flow" field.
func DownloadFlowNotIn(vs ...int) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldNotIn(FieldDownloadFlow, vs...))
}

// DownloadFlowGT applies the GT predicate on the "download_flow" field.
func DownloadFlowGT(v int) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldGT(FieldDownloadFlow, v))
}

// DownloadFlowGTE applies the GTE predicate on the "download_flow" field.
func DownloadFlowGTE(v int) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldGTE(FieldDownloadFlow, v))
}

// DownloadFlowLT applies the LT predicate on the "download_flow" field.
func DownloadFlowLT(v int) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldLT(FieldDownloadFlow, v))
}

// DownloadFlowLTE applies the LTE predicate on the "download_flow" field.
func DownloadFlowLTE(v int) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldLTE(FieldDownloadFlow, v))
}

// DownloadFlowIsNil applies the IsNil predicate on the "download_flow" field.
func DownloadFlowIsNil() predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldIsNull(FieldDownloadFlow))
}

// DownloadFlowNotNil applies the NotNil predicate on the "download_flow" field.
func DownloadFlowNotNil() predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldNotNull(FieldDownloadFlow))
}

// UploadFlowEQ applies the EQ predicate on the "upload_flow" field.
func UploadFlowEQ(v int) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldEQ(FieldUploadFlow, v))
}

// UploadFlowNEQ applies the NEQ predicate on the "upload_flow" field.
func UploadFlowNEQ(v int) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldNEQ(FieldUploadFlow, v))
}

// UploadFlowIn applies the In predicate on the "upload_flow" field.
func UploadFlowIn(vs ...int) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldIn(FieldUploadFlow, vs...))
}

// UploadFlowNotIn applies the NotIn predicate on the "upload_flow" field.
func UploadFlowNotIn(vs ...int) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldNotIn(FieldUploadFlow, vs...))
}

// UploadFlowGT applies the GT predicate on the "upload_flow" field.
func UploadFlowGT(v int) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldGT(FieldUploadFlow, v))
}

// UploadFlowGTE applies the GTE predicate on the "upload_flow" field.
func UploadFlowGTE(v int) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldGTE(FieldUploadFlow, v))
}

// UploadFlowLT applies the LT predicate on the "upload_flow" field.
func UploadFlowLT(v int) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldLT(FieldUploadFlow, v))
}

// UploadFlowLTE applies the LTE predicate on the "upload_flow" field.
func UploadFlowLTE(v int) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldLTE(FieldUploadFlow, v))
}

// UploadFlowIsNil applies the IsNil predicate on the "upload_flow" field.
func UploadFlowIsNil() predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldIsNull(FieldUploadFlow))
}

// UploadFlowNotNil applies the NotNil predicate on the "upload_flow" field.
func UploadFlowNotNil() predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldNotNull(FieldUploadFlow))
}

// RequestAmountEQ applies the EQ predicate on the "request_amount" field.
func RequestAmountEQ(v int) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldEQ(FieldRequestAmount, v))
}

// RequestAmountNEQ applies the NEQ predicate on the "request_amount" field.
func RequestAmountNEQ(v int) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldNEQ(FieldRequestAmount, v))
}

// RequestAmountIn applies the In predicate on the "request_amount" field.
func RequestAmountIn(vs ...int) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldIn(FieldRequestAmount, vs...))
}

// RequestAmountNotIn applies the NotIn predicate on the "request_amount" field.
func RequestAmountNotIn(vs ...int) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldNotIn(FieldRequestAmount, vs...))
}

// RequestAmountGT applies the GT predicate on the "request_amount" field.
func RequestAmountGT(v int) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldGT(FieldRequestAmount, v))
}

// RequestAmountGTE applies the GTE predicate on the "request_amount" field.
func RequestAmountGTE(v int) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldGTE(FieldRequestAmount, v))
}

// RequestAmountLT applies the LT predicate on the "request_amount" field.
func RequestAmountLT(v int) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldLT(FieldRequestAmount, v))
}

// RequestAmountLTE applies the LTE predicate on the "request_amount" field.
func RequestAmountLTE(v int) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldLTE(FieldRequestAmount, v))
}

// RequestAmountIsNil applies the IsNil predicate on the "request_amount" field.
func RequestAmountIsNil() predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldIsNull(FieldRequestAmount))
}

// RequestAmountNotNil applies the NotNil predicate on the "request_amount" field.
func RequestAmountNotNil() predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldNotNull(FieldRequestAmount))
}

// DownloadFlowMonthEQ applies the EQ predicate on the "download_flow_month" field.
func DownloadFlowMonthEQ(v int) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldEQ(FieldDownloadFlowMonth, v))
}

// DownloadFlowMonthNEQ applies the NEQ predicate on the "download_flow_month" field.
func DownloadFlowMonthNEQ(v int) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldNEQ(FieldDownloadFlowMonth, v))
}

// DownloadFlowMonthIn applies the In predicate on the "download_flow_month" field.
func DownloadFlowMonthIn(vs ...int) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldIn(FieldDownloadFlowMonth, vs...))
}

// DownloadFlowMonthNotIn applies the NotIn predicate on the "download_flow_month" field.
func DownloadFlowMonthNotIn(vs ...int) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldNotIn(FieldDownloadFlowMonth, vs...))
}

// DownloadFlowMonthGT applies the GT predicate on the "download_flow_month" field.
func DownloadFlowMonthGT(v int) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldGT(FieldDownloadFlowMonth, v))
}

// DownloadFlowMonthGTE applies the GTE predicate on the "download_flow_month" field.
func DownloadFlowMonthGTE(v int) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldGTE(FieldDownloadFlowMonth, v))
}

// DownloadFlowMonthLT applies the LT predicate on the "download_flow_month" field.
func DownloadFlowMonthLT(v int) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldLT(FieldDownloadFlowMonth, v))
}

// DownloadFlowMonthLTE applies the LTE predicate on the "download_flow_month" field.
func DownloadFlowMonthLTE(v int) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldLTE(FieldDownloadFlowMonth, v))
}

// UploadFlowMonthEQ applies the EQ predicate on the "upload_flow_month" field.
func UploadFlowMonthEQ(v int) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldEQ(FieldUploadFlowMonth, v))
}

// UploadFlowMonthNEQ applies the NEQ predicate on the "upload_flow_month" field.
func UploadFlowMonthNEQ(v int) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldNEQ(FieldUploadFlowMonth, v))
}

// UploadFlowMonthIn applies the In predicate on the "upload_flow_month" field.
func UploadFlowMonthIn(vs ...int) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldIn(FieldUploadFlowMonth, vs...))
}

// UploadFlowMonthNotIn applies the NotIn predicate on the "upload_flow_month" field.
func UploadFlowMonthNotIn(vs ...int) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldNotIn(FieldUploadFlowMonth, vs...))
}

// UploadFlowMonthGT applies the GT predicate on the "upload_flow_month" field.
func UploadFlowMonthGT(v int) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldGT(FieldUploadFlowMonth, v))
}

// UploadFlowMonthGTE applies the GTE predicate on the "upload_flow_month" field.
func UploadFlowMonthGTE(v int) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldGTE(FieldUploadFlowMonth, v))
}

// UploadFlowMonthLT applies the LT predicate on the "upload_flow_month" field.
func UploadFlowMonthLT(v int) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldLT(FieldUploadFlowMonth, v))
}

// UploadFlowMonthLTE applies the LTE predicate on the "upload_flow_month" field.
func UploadFlowMonthLTE(v int) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldLTE(FieldUploadFlowMonth, v))
}

// RequestAmountMonthEQ applies the EQ predicate on the "request_amount_month" field.
func RequestAmountMonthEQ(v int) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldEQ(FieldRequestAmountMonth, v))
}

// RequestAmountMonthNEQ applies the NEQ predicate on the "request_amount_month" field.
func RequestAmountMonthNEQ(v int) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldNEQ(FieldRequestAmountMonth, v))
}

// RequestAmountMonthIn applies the In predicate on the "request_amount_month" field.
func RequestAmountMonthIn(vs ...int) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldIn(FieldRequestAmountMonth, vs...))
}

// RequestAmountMonthNotIn applies the NotIn predicate on the "request_amount_month" field.
func RequestAmountMonthNotIn(vs ...int) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldNotIn(FieldRequestAmountMonth, vs...))
}

// RequestAmountMonthGT applies the GT predicate on the "request_amount_month" field.
func RequestAmountMonthGT(v int) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldGT(FieldRequestAmountMonth, v))
}

// RequestAmountMonthGTE applies the GTE predicate on the "request_amount_month" field.
func RequestAmountMonthGTE(v int) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldGTE(FieldRequestAmountMonth, v))
}

// RequestAmountMonthLT applies the LT predicate on the "request_amount_month" field.
func RequestAmountMonthLT(v int) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldLT(FieldRequestAmountMonth, v))
}

// RequestAmountMonthLTE applies the LTE predicate on the "request_amount_month" field.
func RequestAmountMonthLTE(v int) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldLTE(FieldRequestAmountMonth, v))
}

// CreateTimeEQ applies the EQ predicate on the "create_time" field.
func CreateTimeEQ(v time.Time) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldEQ(FieldCreateTime, v))
}

// CreateTimeNEQ applies the NEQ predicate on the "create_time" field.
func CreateTimeNEQ(v time.Time) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldNEQ(FieldCreateTime, v))
}

// CreateTimeIn applies the In predicate on the "create_time" field.
func CreateTimeIn(vs ...time.Time) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldIn(FieldCreateTime, vs...))
}

// CreateTimeNotIn applies the NotIn predicate on the "create_time" field.
func CreateTimeNotIn(vs ...time.Time) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldNotIn(FieldCreateTime, vs...))
}

// CreateTimeGT applies the GT predicate on the "create_time" field.
func CreateTimeGT(v time.Time) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldGT(FieldCreateTime, v))
}

// CreateTimeGTE applies the GTE predicate on the "create_time" field.
func CreateTimeGTE(v time.Time) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldGTE(FieldCreateTime, v))
}

// CreateTimeLT applies the LT predicate on the "create_time" field.
func CreateTimeLT(v time.Time) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldLT(FieldCreateTime, v))
}

// CreateTimeLTE applies the LTE predicate on the "create_time" field.
func CreateTimeLTE(v time.Time) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldLTE(FieldCreateTime, v))
}

// CreateTimeIsNil applies the IsNil predicate on the "create_time" field.
func CreateTimeIsNil() predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldIsNull(FieldCreateTime))
}

// CreateTimeNotNil applies the NotNil predicate on the "create_time" field.
func CreateTimeNotNil() predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(sql.FieldNotNull(FieldCreateTime))
}

// And groups predicates with the AND operator between them.
func And(predicates ...predicate.ObjectstorageBucket) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(func(s *sql.Selector) {
		s1 := s.Clone().SetP(nil)
		for _, p := range predicates {
			p(s1)
		}
		s.Where(s1.P())
	})
}

// Or groups predicates with the OR operator between them.
func Or(predicates ...predicate.ObjectstorageBucket) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(func(s *sql.Selector) {
		s1 := s.Clone().SetP(nil)
		for i, p := range predicates {
			if i > 0 {
				s1.Or()
			}
			p(s1)
		}
		s.Where(s1.P())
	})
}

// Not applies the not operator on the given predicate.
func Not(p predicate.ObjectstorageBucket) predicate.ObjectstorageBucket {
	return predicate.ObjectstorageBucket(func(s *sql.Selector) {
		p(s.Not())
	})
}

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/data/ent/objectstoragebucket/objectstoragebucket.go
```golang
// Code generated by ent, DO NOT EDIT.

package objectstoragebucket

const (
	// Label holds the string label denoting the objectstoragebucket type in the database.
	Label = "objectstorage_bucket"
	// FieldID holds the string denoting the id field in the database.
	FieldID = "id"
	// FieldCreatedAt holds the string denoting the created_at field in the database.
	FieldCreatedAt = "created_at"
	// FieldUpdatedAt holds the string denoting the updated_at field in the database.
	FieldUpdatedAt = "updated_at"
	// FieldVersion holds the string denoting the version field in the database.
	FieldVersion = "version"
	// FieldGalaxy holds the string denoting the galaxy field in the database.
	FieldGalaxy = "galaxy"
	// FieldRegion holds the string denoting the region field in the database.
	FieldRegion = "region"
	// FieldDeleted holds the string denoting the deleted field in the database.
	FieldDeleted = "deleted"
	// FieldBucketID holds the string denoting the bucket_id field in the database.
	FieldBucketID = "bucket_id"
	// FieldName holds the string denoting the name field in the database.
	FieldName = "name"
	// FieldTenantID holds the string denoting the tenant_id field in the database.
	FieldTenantID = "tenant_id"
	// FieldTenantName holds the string denoting the tenant_name field in the database.
	FieldTenantName = "tenant_name"
	// FieldProjectID holds the string denoting the project_id field in the database.
	FieldProjectID = "project_id"
	// FieldProjectName holds the string denoting the project_name field in the database.
	FieldProjectName = "project_name"
	// FieldStorageclass holds the string denoting the storageclass field in the database.
	FieldStorageclass = "storageclass"
	// FieldStorageclassName holds the string denoting the storageclass_name field in the database.
	FieldStorageclassName = "storageclass_name"
	// FieldInnerEndpoint holds the string denoting the inner_endpoint field in the database.
	FieldInnerEndpoint = "inner_endpoint"
	// FieldOuterEndpoint holds the string denoting the outer_endpoint field in the database.
	FieldOuterEndpoint = "outer_endpoint"
	// FieldInnerDomain holds the string denoting the inner_domain field in the database.
	FieldInnerDomain = "inner_domain"
	// FieldOuterDomain holds the string denoting the outer_domain field in the database.
	FieldOuterDomain = "outer_domain"
	// FieldPoolID holds the string denoting the pool_id field in the database.
	FieldPoolID = "pool_id"
	// FieldPoolName holds the string denoting the pool_name field in the database.
	FieldPoolName = "pool_name"
	// FieldTotalStorage holds the string denoting the total_storage field in the database.
	FieldTotalStorage = "total_storage"
	// FieldAddStorage holds the string denoting the add_storage field in the database.
	FieldAddStorage = "add_storage"
	// FieldDeleteStorage holds the string denoting the delete_storage field in the database.
	FieldDeleteStorage = "delete_storage"
	// FieldTotalObject holds the string denoting the total_object field in the database.
	FieldTotalObject = "total_object"
	// FieldAddObject holds the string denoting the add_object field in the database.
	FieldAddObject = "add_object"
	// FieldDeleteObject holds the string denoting the delete_object field in the database.
	FieldDeleteObject = "delete_object"
	// FieldDownloadFlow holds the string denoting the download_flow field in the database.
	FieldDownloadFlow = "download_flow"
	// FieldUploadFlow holds the string denoting the upload_flow field in the database.
	FieldUploadFlow = "upload_flow"
	// FieldRequestAmount holds the string denoting the request_amount field in the database.
	FieldRequestAmount = "request_amount"
	// FieldDownloadFlowMonth holds the string denoting the download_flow_month field in the database.
	FieldDownloadFlowMonth = "download_flow_month"
	// FieldUploadFlowMonth holds the string denoting the upload_flow_month field in the database.
	FieldUploadFlowMonth = "upload_flow_month"
	// FieldRequestAmountMonth holds the string denoting the request_amount_month field in the database.
	FieldRequestAmountMonth = "request_amount_month"
	// FieldCreateTime holds the string denoting the create_time field in the database.
	FieldCreateTime = "create_time"
	// Table holds the table name of the objectstoragebucket in the database.
	Table = "objectstorage_bucket"
)

// Columns holds all SQL columns for objectstoragebucket fields.
var Columns = []string{
	FieldID,
	FieldCreatedAt,
	FieldUpdatedAt,
	FieldVersion,
	FieldGalaxy,
	FieldRegion,
	FieldDeleted,
	FieldBucketID,
	FieldName,
	FieldTenantID,
	FieldTenantName,
	FieldProjectID,
	FieldProjectName,
	FieldStorageclass,
	FieldStorageclassName,
	FieldInnerEndpoint,
	FieldOuterEndpoint,
	FieldInnerDomain,
	FieldOuterDomain,
	FieldPoolID,
	FieldPoolName,
	FieldTotalStorage,
	FieldAddStorage,
	FieldDeleteStorage,
	FieldTotalObject,
	FieldAddObject,
	FieldDeleteObject,
	FieldDownloadFlow,
	FieldUploadFlow,
	FieldRequestAmount,
	FieldDownloadFlowMonth,
	FieldUploadFlowMonth,
	FieldRequestAmountMonth,
	FieldCreateTime,
}

// ValidColumn reports if the column name is valid (part of the table columns).
func ValidColumn(column string) bool {
	for i := range Columns {
		if column == Columns[i] {
			return true
		}
	}
	return false
}

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/data/ent/runtime/runtime.go
```golang
// Code generated by ent, DO NOT EDIT.

package runtime

// The schema-stitching logic is generated in luban-cmdb-api/data/ent/runtime.go

const (
	Version = "v0.11.9"                                         // Version of ent codegen.
	Sum     = "h1:dbbCkAiPVTRBIJwoZctiSYjB7zxQIBOzVSU5H9VYIQI=" // Sum of ent codegen.
)

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/data/ent/ebsvolume/where.go
```golang
// Code generated by ent, DO NOT EDIT.

package ebsvolume

import (
	"luban-cmdb-api/data/ent/predicate"
	"time"

	"entgo.io/ent/dialect/sql"
)

// ID filters vertices based on their ID field.
func ID(id int) predicate.EbsVolume {
	return predicate.EbsVolume(sql.FieldEQ(FieldID, id))
}

// IDEQ applies the EQ predicate on the ID field.
func IDEQ(id int) predicate.EbsVolume {
	return predicate.EbsVolume(sql.FieldEQ(FieldID, id))
}

// IDNEQ applies the NEQ predicate on the ID field.
func IDNEQ(id int) predicate.EbsVolume {
	return predicate.EbsVolume(sql.FieldNEQ(FieldID, id))
}

// IDIn applies the In predicate on the ID field.
func IDIn(ids ...int) predicate.EbsVolume {
	return predicate.EbsVolume(sql.FieldIn(FieldID, ids...))
}

// IDNotIn applies the NotIn predicate on the ID field.
func IDNotIn(ids ...int) predicate.EbsVolume {
	return predicate.EbsVolume(sql.FieldNotIn(FieldID, ids...))
}

// IDGT applies the GT predicate on the ID field.
func IDGT(id int) predicate.EbsVolume {
	return predicate.EbsVolume(sql.FieldGT(FieldID, id))
}

// IDGTE applies the GTE predicate on the ID field.
func IDGTE(id int) predicate.EbsVolume {
	return predicate.EbsVolume(sql.FieldGTE(FieldID, id))
}

// IDLT applies the LT predicate on the ID field.
func IDLT(id int) predicate.EbsVolume {
	return predicate.EbsVolume(sql.FieldLT(FieldID, id))
}

// IDLTE applies the LTE predicate on the ID field.
func IDLTE(id int) predicate.EbsVolume {
	return predicate.EbsVolume(sql.FieldLTE(FieldID, id))
}

// Galaxy applies equality check predicate on the "galaxy" field. It's identical to GalaxyEQ.
func Galaxy(v string) predicate.EbsVolume {
	return predicate.EbsVolume(sql.FieldEQ(FieldGalaxy, v))
}

// Region applies equality check predicate on the "region" field. It's identical to RegionEQ.
func Region(v string) predicate.EbsVolume {
	return predicate.EbsVolume(sql.FieldEQ(FieldRegion, v))
}

// Az applies equality check predicate on the "az" field. It's identical to AzEQ.
func Az(v string) predicate.EbsVolume {
	return predicate.EbsVolume(sql.FieldEQ(FieldAz, v))
}

// CreatedAt applies equality check predicate on the "created_at" field. It's identical to CreatedAtEQ.
func CreatedAt(v time.Time) predicate.EbsVolume {
	return predicate.EbsVolume(sql.FieldEQ(FieldCreatedAt, v))
}

// UpdatedAt applies equality check predicate on the "updated_at" field. It's identical to UpdatedAtEQ.
func UpdatedAt(v time.Time) predicate.EbsVolume {
	return predicate.EbsVolume(sql.FieldEQ(FieldUpdatedAt, v))
}

// Version applies equality check predicate on the "version" field. It's identical to VersionEQ.
func Version(v string) predicate.EbsVolume {
	return predicate.EbsVolume(sql.FieldEQ(FieldVersion, v))
}

// VolumeID applies equality check predicate on the "volume_id" field. It's identical to VolumeIDEQ.
func VolumeID(v string) predicate.EbsVolume {
	return predicate.EbsVolume(sql.FieldEQ(FieldVolumeID, v))
}

// Name applies equality check predicate on the "name" field. It's identical to NameEQ.
func Name(v string) predicate.EbsVolume {
	return predicate.EbsVolume(sql.FieldEQ(FieldName, v))
}

// PoolID applies equality check predicate on the "pool_id" field. It's identical to PoolIDEQ.
func PoolID(v string) predicate.EbsVolume {
	return predicate.EbsVolume(sql.FieldEQ(FieldPoolID, v))
}

// PoolName applies equality check predicate on the "pool_name" field. It's identical to PoolNameEQ.
func PoolName(v string) predicate.EbsVolume {
	return predicate.EbsVolume(sql.FieldEQ(FieldPoolName, v))
}

// Size applies equality check predicate on the "size" field. It's identical to SizeEQ.
func Size(v int32) predicate.EbsVolume {
	return predicate.EbsVolume(sql.FieldEQ(FieldSize, v))
}

// Status applies equality check predicate on the "status" field. It's identical to StatusEQ.
func Status(v string) predicate.EbsVolume {
	return predicate.EbsVolume(sql.FieldEQ(FieldStatus, v))
}

// StatusName applies equality check predicate on the "status_name" field. It's identical to StatusNameEQ.
func StatusName(v string) predicate.EbsVolume {
	return predicate.EbsVolume(sql.FieldEQ(FieldStatusName, v))
}

// VolumeType applies equality check predicate on the "volume_type" field. It's identical to VolumeTypeEQ.
func VolumeType(v string) predicate.EbsVolume {
	return predicate.EbsVolume(sql.FieldEQ(FieldVolumeType, v))
}

// VMID applies equality check predicate on the "vm_id" field. It's identical to VMIDEQ.
func VMID(v string) predicate.EbsVolume {
	return predicate.EbsVolume(sql.FieldEQ(FieldVMID, v))
}

// VMName applies equality check predicate on the "vm_name" field. It's identical to VMNameEQ.
func VMName(v string) predicate.EbsVolume {
	return predicate.EbsVolume(sql.FieldEQ(FieldVMName, v))
}

// TenantID applies equality check predicate on the "tenant_id" field. It's identical to TenantIDEQ.
func TenantID(v string) predicate.EbsVolume {
	return predicate.EbsVolume(sql.FieldEQ(FieldTenantID, v))
}

// TenantName applies equality check predicate on the "tenant_name" field. It's identical to TenantNameEQ.
func TenantName(v string) predicate.EbsVolume {
	return predicate.EbsVolume(sql.FieldEQ(FieldTenantName, v))
}

// ProjectID applies equality check predicate on the "project_id" field. It's identical to ProjectIDEQ.
func ProjectID(v string) predicate.EbsVolume {
	return predicate.EbsVolume(sql.FieldEQ(FieldProjectID, v))
}

// ProjectName applies equality check predicate on the "project_name" field. It's identical to ProjectNameEQ.
func ProjectName(v string) predicate.EbsVolume {
	return predicate.EbsVolume(sql.FieldEQ(FieldProjectName, v))
}

// CreateTime applies equality check predicate on the "create_time" field. It's identical to CreateTimeEQ.
func CreateTime(v time.Time) predicate.EbsVolume {
	return predicate.EbsVolume(sql.FieldEQ(FieldCreateTime, v))
}

// ServiceEndTime applies equality check predicate on the "service_end_time" field. It's identical to ServiceEndTimeEQ.
func ServiceEndTime(v time.Time) predicate.EbsVolume {
	return predicate.EbsVolume(sql.FieldEQ(FieldServiceEndTime, v))
}

// Deleted applies equality check predicate on the "deleted" field. It's identical to DeletedEQ.
func Deleted(v bool) predicate.EbsVolume {
	return predicate.EbsVolume(sql.FieldEQ(FieldDeleted, v))
}

// GalaxyEQ applies the EQ predicate on the "galaxy" field.
func GalaxyEQ(v string) predicate.EbsVolume {
	return predicate.EbsVolume(sql.FieldEQ(FieldGalaxy, v))
}

// GalaxyNEQ applies the NEQ predicate on the "galaxy" field.
func GalaxyNEQ(v string) predicate.EbsVolume {
	return predicate.EbsVolume(sql.FieldNEQ(FieldGalaxy, v))
}

// GalaxyIn applies the In predicate on the "galaxy" field.
func GalaxyIn(vs ...string) predicate.EbsVolume {
	return predicate.EbsVolume(sql.FieldIn(FieldGalaxy, vs...))
}

// GalaxyNotIn applies the NotIn predicate on the "galaxy" field.
func GalaxyNotIn(vs ...string) predicate.EbsVolume {
	return predicate.EbsVolume(sql.FieldNotIn(FieldGalaxy, vs...))
}

// GalaxyGT applies the GT predicate on the "galaxy" field.
func GalaxyGT(v string) predicate.EbsVolume {
	return predicate.EbsVolume(sql.FieldGT(FieldGalaxy, v))
}

// GalaxyGTE applies the GTE predicate on the "galaxy" field.
func GalaxyGTE(v string) predicate.EbsVolume {
	return predicate.EbsVolume(sql.FieldGTE(FieldGalaxy, v))
}

// GalaxyLT applies the LT predicate on the "galaxy" field.
func GalaxyLT(v string) predicate.EbsVolume {
	return predicate.EbsVolume(sql.FieldLT(FieldGalaxy, v))
}

// GalaxyLTE applies the LTE predicate on the "galaxy" field.
func GalaxyLTE(v string) predicate.EbsVolume {
	return predicate.EbsVolume(sql.FieldLTE(FieldGalaxy, v))
}

// GalaxyContains applies the Contains predicate on the "galaxy" field.
func GalaxyContains(v string) predicate.EbsVolume {
	return predicate.EbsVolume(sql.FieldContains(FieldGalaxy, v))
}

// GalaxyHasPrefix applies the HasPrefix predicate on the "galaxy" field.
func GalaxyHasPrefix(v string) predicate.EbsVolume {
	return predicate.EbsVolume(sql.FieldHasPrefix(FieldGalaxy, v))
}

// GalaxyHasSuffix applies the HasSuffix predicate on the "galaxy" field.
func GalaxyHasSuffix(v string) predicate.EbsVolume {
	return predicate.EbsVolume(sql.FieldHasSuffix(FieldGalaxy, v))
}

// GalaxyIsNil applies the IsNil predicate on the "galaxy" field.
func GalaxyIsNil() predicate.EbsVolume {
	return predicate.EbsVolume(sql.FieldIsNull(FieldGalaxy))
}

// GalaxyNotNil applies the NotNil predicate on the "galaxy" field.
func GalaxyNotNil() predicate.EbsVolume {
	return predicate.EbsVolume(sql.FieldNotNull(FieldGalaxy))
}

// GalaxyEqualFold applies the EqualFold predicate on the "galaxy" field.
func GalaxyEqualFold(v string) predicate.EbsVolume {
	return predicate.EbsVolume(sql.FieldEqualFold(FieldGalaxy, v))
}

// GalaxyContainsFold applies the ContainsFold predicate on the "galaxy" field.
func GalaxyContainsFold(v string) predicate.EbsVolume {
	return predicate.EbsVolume(sql.FieldContainsFold(FieldGalaxy, v))
}

// RegionEQ applies the EQ predicate on the "region" field.
func RegionEQ(v string) predicate.EbsVolume {
	return predicate.EbsVolume(sql.FieldEQ(FieldRegion, v))
}

// RegionNEQ applies the NEQ predicate on the "region" field.
func RegionNEQ(v string) predicate.EbsVolume {
	return predicate.EbsVolume(sql.FieldNEQ(FieldRegion, v))
}

// RegionIn applies the In predicate on the "region" field.
func RegionIn(vs ...string) predicate.EbsVolume {
	return predicate.EbsVolume(sql.FieldIn(FieldRegion, vs...))
}

// RegionNotIn applies the NotIn predicate on the "region" field.
func RegionNotIn(vs ...string) predicate.EbsVolume {
	return predicate.EbsVolume(sql.FieldNotIn(FieldRegion, vs...))
}

// RegionGT applies the GT predicate on the "region" field.
func RegionGT(v string) predicate.EbsVolume {
	return predicate.EbsVolume(sql.FieldGT(FieldRegion, v))
}

// RegionGTE applies the GTE predicate on the "region" field.
func RegionGTE(v string) predicate.EbsVolume {
	return predicate.EbsVolume(sql.FieldGTE(FieldRegion, v))
}

// RegionLT applies the LT predicate on the "region" field.
func RegionLT(v string) predicate.EbsVolume {
	return predicate.EbsVolume(sql.FieldLT(FieldRegion, v))
}

// RegionLTE applies the LTE predicate on the "region" field.
func RegionLTE(v string) predicate.EbsVolume {
	return predicate.EbsVolume(sql.FieldLTE(FieldRegion, v))
}

// RegionContains applies the Contains predicate on the "region" field.
func RegionContains(v string) predicate.EbsVolume {
	return predicate.EbsVolume(sql.FieldContains(FieldRegion, v))
}

// RegionHasPrefix applies the HasPrefix predicate on the "region" field.
func RegionHasPrefix(v string) predicate.EbsVolume {
	return predicate.EbsVolume(sql.FieldHasPrefix(FieldRegion, v))
}

// RegionHasSuffix applies the HasSuffix predicate on the "region" field.
func RegionHasSuffix(v string) predicate.EbsVolume {
	return predicate.EbsVolume(sql.FieldHasSuffix(FieldRegion, v))
}

// RegionEqualFold applies the EqualFold predicate on the "region" field.
func RegionEqualFold(v string) predicate.EbsVolume {
	return predicate.EbsVolume(sql.FieldEqualFold(FieldRegion, v))
}

// RegionContainsFold applies the ContainsFold predicate on the "region" field.
func RegionContainsFold(v string) predicate.EbsVolume {
	return predicate.EbsVolume(sql.FieldContainsFold(FieldRegion, v))
}

// AzEQ applies the EQ predicate on the "az" field.
func AzEQ(v string) predicate.EbsVolume {
	return predicate.EbsVolume(sql.FieldEQ(FieldAz, v))
}

// AzNEQ applies the NEQ predicate on the "az" field.
func AzNEQ(v string) predicate.EbsVolume {
	return predicate.EbsVolume(sql.FieldNEQ(FieldAz, v))
}

// AzIn applies the In predicate on the "az" field.
func AzIn(vs ...string) predicate.EbsVolume {
	return predicate.EbsVolume(sql.FieldIn(FieldAz, vs...))
}

// AzNotIn applies the NotIn predicate on the "az" field.
func AzNotIn(vs ...string) predicate.EbsVolume {
	return predicate.EbsVolume(sql.FieldNotIn(FieldAz, vs...))
}

// AzGT applies the GT predicate on the "az" field.
func AzGT(v string) predicate.EbsVolume {
	return predicate.EbsVolume(sql.FieldGT(FieldAz, v))
}

// AzGTE applies the GTE predicate on the "az" field.
func AzGTE(v string) predicate.EbsVolume {
	return predicate.EbsVolume(sql.FieldGTE(FieldAz, v))
}

// AzLT applies the LT predicate on the "az" field.
func AzLT(v string) predicate.EbsVolume {
	return predicate.EbsVolume(sql.FieldLT(FieldAz, v))
}

// AzLTE applies the LTE predicate on the "az" field.
func AzLTE(v string) predicate.EbsVolume {
	return predicate.EbsVolume(sql.FieldLTE(FieldAz, v))
}

// AzContains applies the Contains predicate on the "az" field.
func AzContains(v string) predicate.EbsVolume {
	return predicate.EbsVolume(sql.FieldContains(FieldAz, v))
}

// AzHasPrefix applies the HasPrefix predicate on the "az" field.
func AzHasPrefix(v string) predicate.EbsVolume {
	return predicate.EbsVolume(sql.FieldHasPrefix(FieldAz, v))
}

// AzHasSuffix applies the HasSuffix predicate on the "az" field.
func AzHasSuffix(v string) predicate.EbsVolume {
	return predicate.EbsVolume(sql.FieldHasSuffix(FieldAz, v))
}

// AzIsNil applies the IsNil predicate on the "az" field.
func AzIsNil() predicate.EbsVolume {
	return predicate.EbsVolume(sql.FieldIsNull(FieldAz))
}

// AzNotNil applies the NotNil predicate on the "az" field.
func AzNotNil() predicate.EbsVolume {
	return predicate.EbsVolume(sql.FieldNotNull(FieldAz))
}

// AzEqualFold applies the EqualFold predicate on the "az" field.
func AzEqualFold(v string) predicate.EbsVolume {
	return predicate.EbsVolume(sql.FieldEqualFold(FieldAz, v))
}

// AzContainsFold applies the ContainsFold predicate on the "az" field.
func AzContainsFold(v string) predicate.EbsVolume {
	return predicate.EbsVolume(sql.FieldContainsFold(FieldAz, v))
}

// CreatedAtEQ applies the EQ predicate on the "created_at" field.
func CreatedAtEQ(v time.Time) predicate.EbsVolume {
	return predicate.EbsVolume(sql.FieldEQ(FieldCreatedAt, v))
}

// CreatedAtNEQ applies the NEQ predicate on the "created_at" field.
func CreatedAtNEQ(v time.Time) predicate.EbsVolume {
	return predicate.EbsVolume(sql.FieldNEQ(FieldCreatedAt, v))
}

// CreatedAtIn applies the In predicate on the "created_at" field.
func CreatedAtIn(vs ...time.Time) predicate.EbsVolume {
	return predicate.EbsVolume(sql.FieldIn(FieldCreatedAt, vs...))
}

// CreatedAtNotIn applies the NotIn predicate on the "created_at" field.
func CreatedAtNotIn(vs ...time.Time) predicate.EbsVolume {
	return predicate.EbsVolume(sql.FieldNotIn(FieldCreatedAt, vs...))
}

// CreatedAtGT applies the GT predicate on the "created_at" field.
func CreatedAtGT(v time.Time) predicate.EbsVolume {
	return predicate.EbsVolume(sql.FieldGT(FieldCreatedAt, v))
}

// CreatedAtGTE applies the GTE predicate on the "created_at" field.
func CreatedAtGTE(v time.Time) predicate.EbsVolume {
	return predicate.EbsVolume(sql.FieldGTE(FieldCreatedAt, v))
}

// CreatedAtLT applies the LT predicate on the "created_at" field.
func CreatedAtLT(v time.Time) predicate.EbsVolume {
	return predicate.EbsVolume(sql.FieldLT(FieldCreatedAt, v))
}

// CreatedAtLTE applies the LTE predicate on the "created_at" field.
func CreatedAtLTE(v time.Time) predicate.EbsVolume {
	return predicate.EbsVolume(sql.FieldLTE(FieldCreatedAt, v))
}

// CreatedAtIsNil applies the IsNil predicate on the "created_at" field.
func CreatedAtIsNil() predicate.EbsVolume {
	return predicate.EbsVolume(sql.FieldIsNull(FieldCreatedAt))
}

// CreatedAtNotNil applies the NotNil predicate on the "created_at" field.
func CreatedAtNotNil() predicate.EbsVolume {
	return predicate.EbsVolume(sql.FieldNotNull(FieldCreatedAt))
}

// UpdatedAtEQ applies the EQ predicate on the "updated_at" field.
func UpdatedAtEQ(v time.Time) predicate.EbsVolume {
	return predicate.EbsVolume(sql.FieldEQ(FieldUpdatedAt, v))
}

// UpdatedAtNEQ applies the NEQ predicate on the "updated_at" field.
func UpdatedAtNEQ(v time.Time) predicate.EbsVolume {
	return predicate.EbsVolume(sql.FieldNEQ(FieldUpdatedAt, v))
}

// UpdatedAtIn applies the In predicate on the "updated_at" field.
func UpdatedAtIn(vs ...time.Time) predicate.EbsVolume {
	return predicate.EbsVolume(sql.FieldIn(FieldUpdatedAt, vs...))
}

// UpdatedAtNotIn applies the NotIn predicate on the "updated_at" field.
func UpdatedAtNotIn(vs ...time.Time) predicate.EbsVolume {
	return predicate.EbsVolume(sql.FieldNotIn(FieldUpdatedAt, vs...))
}

// UpdatedAtGT applies the GT predicate on the "updated_at" field.
func UpdatedAtGT(v time.Time) predicate.EbsVolume {
	return predicate.EbsVolume(sql.FieldGT(FieldUpdatedAt, v))
}

// UpdatedAtGTE applies the GTE predicate on the "updated_at" field.
func UpdatedAtGTE(v time.Time) predicate.EbsVolume {
	return predicate.EbsVolume(sql.FieldGTE(FieldUpdatedAt, v))
}

// UpdatedAtLT applies the LT predicate on the "updated_at" field.
func UpdatedAtLT(v time.Time) predicate.EbsVolume {
	return predicate.EbsVolume(sql.FieldLT(FieldUpdatedAt, v))
}

// UpdatedAtLTE applies the LTE predicate on the "updated_at" field.
func UpdatedAtLTE(v time.Time) predicate.EbsVolume {
	return predicate.EbsVolume(sql.FieldLTE(FieldUpdatedAt, v))
}

// VersionEQ applies the EQ predicate on the "version" field.
func VersionEQ(v string) predicate.EbsVolume {
	return predicate.EbsVolume(sql.FieldEQ(FieldVersion, v))
}

// VersionNEQ applies the NEQ predicate on the "version" field.
func VersionNEQ(v string) predicate.EbsVolume {
	return predicate.EbsVolume(sql.FieldNEQ(FieldVersion, v))
}

// VersionIn applies the In predicate on the "version" field.
func VersionIn(vs ...string) predicate.EbsVolume {
	return predicate.EbsVolume(sql.FieldIn(FieldVersion, vs...))
}

// VersionNotIn applies the NotIn predicate on the "version" field.
func VersionNotIn(vs ...string) predicate.EbsVolume {
	return predicate.EbsVolume(sql.FieldNotIn(FieldVersion, vs...))
}

// VersionGT applies the GT predicate on the "version" field.
func VersionGT(v string) predicate.EbsVolume {
	return predicate.EbsVolume(sql.FieldGT(FieldVersion, v))
}

// VersionGTE applies the GTE predicate on the "version" field.
func VersionGTE(v string) predicate.EbsVolume {
	return predicate.EbsVolume(sql.FieldGTE(FieldVersion, v))
}

// VersionLT applies the LT predicate on the "version" field.
func VersionLT(v string) predicate.EbsVolume {
	return predicate.EbsVolume(sql.FieldLT(FieldVersion, v))
}

// VersionLTE applies the LTE predicate on the "version" field.
func VersionLTE(v string) predicate.EbsVolume {
	return predicate.EbsVolume(sql.FieldLTE(FieldVersion, v))
}

// VersionContains applies the Contains predicate on the "version" field.
func VersionContains(v string) predicate.EbsVolume {
	return predicate.EbsVolume(sql.FieldContains(FieldVersion, v))
}

// VersionHasPrefix applies the HasPrefix predicate on the "version" field.
func VersionHasPrefix(v string) predicate.EbsVolume {
	return predicate.EbsVolume(sql.FieldHasPrefix(FieldVersion, v))
}

// VersionHasSuffix applies the HasSuffix predicate on the "version" field.
func VersionHasSuffix(v string) predicate.EbsVolume {
	return predicate.EbsVolume(sql.FieldHasSuffix(FieldVersion, v))
}

// VersionIsNil applies the IsNil predicate on the "version" field.
func VersionIsNil() predicate.EbsVolume {
	return predicate.EbsVolume(sql.FieldIsNull(FieldVersion))
}

// VersionNotNil applies the NotNil predicate on the "version" field.
func VersionNotNil() predicate.EbsVolume {
	return predicate.EbsVolume(sql.FieldNotNull(FieldVersion))
}

// VersionEqualFold applies the EqualFold predicate on the "version" field.
func VersionEqualFold(v string) predicate.EbsVolume {
	return predicate.EbsVolume(sql.FieldEqualFold(FieldVersion, v))
}

// VersionContainsFold applies the ContainsFold predicate on the "version" field.
func VersionContainsFold(v string) predicate.EbsVolume {
	return predicate.EbsVolume(sql.FieldContainsFold(FieldVersion, v))
}

// VolumeIDEQ applies the EQ predicate on the "volume_id" field.
func VolumeIDEQ(v string) predicate.EbsVolume {
	return predicate.EbsVolume(sql.FieldEQ(FieldVolumeID, v))
}

// VolumeIDNEQ applies the NEQ predicate on the "volume_id" field.
func VolumeIDNEQ(v string) predicate.EbsVolume {
	return predicate.EbsVolume(sql.FieldNEQ(FieldVolumeID, v))
}

// VolumeIDIn applies the In predicate on the "volume_id" field.
func VolumeIDIn(vs ...string) predicate.EbsVolume {
	return predicate.EbsVolume(sql.FieldIn(FieldVolumeID, vs...))
}

// VolumeIDNotIn applies the NotIn predicate on the "volume_id" field.
func VolumeIDNotIn(vs ...string) predicate.EbsVolume {
	return predicate.EbsVolume(sql.FieldNotIn(FieldVolumeID, vs...))
}

// VolumeIDGT applies the GT predicate on the "volume_id" field.
func VolumeIDGT(v string) predicate.EbsVolume {
	return predicate.EbsVolume(sql.FieldGT(FieldVolumeID, v))
}

// VolumeIDGTE applies the GTE predicate on the "volume_id" field.
func VolumeIDGTE(v string) predicate.EbsVolume {
	return predicate.EbsVolume(sql.FieldGTE(FieldVolumeID, v))
}

// VolumeIDLT applies the LT predicate on the "volume_id" field.
func VolumeIDLT(v string) predicate.EbsVolume {
	return predicate.EbsVolume(sql.FieldLT(FieldVolumeID, v))
}

// VolumeIDLTE applies the LTE predicate on the "volume_id" field.
func VolumeIDLTE(v string) predicate.EbsVolume {
	return predicate.EbsVolume(sql.FieldLTE(FieldVolumeID, v))
}

// VolumeIDContains applies the Contains predicate on the "volume_id" field.
func VolumeIDContains(v string) predicate.EbsVolume {
	return predicate.EbsVolume(sql.FieldContains(FieldVolumeID, v))
}

// VolumeIDHasPrefix applies the HasPrefix predicate on the "volume_id" field.
func VolumeIDHasPrefix(v string) predicate.EbsVolume {
	return predicate.EbsVolume(sql.FieldHasPrefix(FieldVolumeID, v))
}

// VolumeIDHasSuffix applies the HasSuffix predicate on the "volume_id" field.
func VolumeIDHasSuffix(v string) predicate.EbsVolume {
	return predicate.EbsVolume(sql.FieldHasSuffix(FieldVolumeID, v))
}

// VolumeIDIsNil applies the IsNil predicate on the "volume_id" field.
func VolumeIDIsNil() predicate.EbsVolume {
	return predicate.EbsVolume(sql.FieldIsNull(FieldVolumeID))
}

// VolumeIDNotNil applies the NotNil predicate on the "volume_id" field.
func VolumeIDNotNil() predicate.EbsVolume {
	return predicate.EbsVolume(sql.FieldNotNull(FieldVolumeID))
}

// VolumeIDEqualFold applies the EqualFold predicate on the "volume_id" field.
func VolumeIDEqualFold(v string) predicate.EbsVolume {
	return predicate.EbsVolume(sql.FieldEqualFold(FieldVolumeID, v))
}

// VolumeIDContainsFold applies the ContainsFold predicate on the "volume_id" field.
func VolumeIDContainsFold(v string) predicate.EbsVolume {
	return predicate.EbsVolume(sql.FieldContainsFold(FieldVolumeID, v))
}

// NameEQ applies the EQ predicate on the "name" field.
func NameEQ(v string) predicate.EbsVolume {
	return predicate.EbsVolume(sql.FieldEQ(FieldName, v))
}

// NameNEQ applies the NEQ predicate on the "name" field.
func NameNEQ(v string) predicate.EbsVolume {
	return predicate.EbsVolume(sql.FieldNEQ(FieldName, v))
}

// NameIn applies the In predicate on the "name" field.
func NameIn(vs ...string) predicate.EbsVolume {
	return predicate.EbsVolume(sql.FieldIn(FieldName, vs...))
}

// NameNotIn applies the NotIn predicate on the "name" field.
func NameNotIn(vs ...string) predicate.EbsVolume {
	return predicate.EbsVolume(sql.FieldNotIn(FieldName, vs...))
}

// NameGT applies the GT predicate on the "name" field.
func NameGT(v string) predicate.EbsVolume {
	return predicate.EbsVolume(sql.FieldGT(FieldName, v))
}

// NameGTE applies the GTE predicate on the "name" field.
func NameGTE(v string) predicate.EbsVolume {
	return predicate.EbsVolume(sql.FieldGTE(FieldName, v))
}

// NameLT applies the LT predicate on the "name" field.
func NameLT(v string) predicate.EbsVolume {
	return predicate.EbsVolume(sql.FieldLT(FieldName, v))
}

// NameLTE applies the LTE predicate on the "name" field.
func NameLTE(v string) predicate.EbsVolume {
	return predicate.EbsVolume(sql.FieldLTE(FieldName, v))
}

// NameContains applies the Contains predicate on the "name" field.
func NameContains(v string) predicate.EbsVolume {
	return predicate.EbsVolume(sql.FieldContains(FieldName, v))
}

// NameHasPrefix applies the HasPrefix predicate on the "name" field.
func NameHasPrefix(v string) predicate.EbsVolume {
	return predicate.EbsVolume(sql.FieldHasPrefix(FieldName, v))
}

// NameHasSuffix applies the HasSuffix predicate on the "name" field.
func NameHasSuffix(v string) predicate.EbsVolume {
	return predicate.EbsVolume(sql.FieldHasSuffix(FieldName, v))
}

// NameEqualFold applies the EqualFold predicate on the "name" field.
func NameEqualFold(v string) predicate.EbsVolume {
	return predicate.EbsVolume(sql.FieldEqualFold(FieldName, v))
}

// NameContainsFold applies the ContainsFold predicate on the "name" field.
func NameContainsFold(v string) predicate.EbsVolume {
	return predicate.EbsVolume(sql.FieldContainsFold(FieldName, v))
}

// PoolIDEQ applies the EQ predicate on the "pool_id" field.
func PoolIDEQ(v string) predicate.EbsVolume {
	return predicate.EbsVolume(sql.FieldEQ(FieldPoolID, v))
}

// PoolIDNEQ applies the NEQ predicate on the "pool_id" field.
func PoolIDNEQ(v string) predicate.EbsVolume {
	return predicate.EbsVolume(sql.FieldNEQ(FieldPoolID, v))
}

// PoolIDIn applies the In predicate on the "pool_id" field.
func PoolIDIn(vs ...string) predicate.EbsVolume {
	return predicate.EbsVolume(sql.FieldIn(FieldPoolID, vs...))
}

// PoolIDNotIn applies the NotIn predicate on the "pool_id" field.
func PoolIDNotIn(vs ...string) predicate.EbsVolume {
	return predicate.EbsVolume(sql.FieldNotIn(FieldPoolID, vs...))
}

// PoolIDGT applies the GT predicate on the "pool_id" field.
func PoolIDGT(v string) predicate.EbsVolume {
	return predicate.EbsVolume(sql.FieldGT(FieldPoolID, v))
}

// PoolIDGTE applies the GTE predicate on the "pool_id" field.
func PoolIDGTE(v string) predicate.EbsVolume {
	return predicate.EbsVolume(sql.FieldGTE(FieldPoolID, v))
}

// PoolIDLT applies the LT predicate on the "pool_id" field.
func PoolIDLT(v string) predicate.EbsVolume {
	return predicate.EbsVolume(sql.FieldLT(FieldPoolID, v))
}

// PoolIDLTE applies the LTE predicate on the "pool_id" field.
func PoolIDLTE(v string) predicate.EbsVolume {
	return predicate.EbsVolume(sql.FieldLTE(FieldPoolID, v))
}

// PoolIDContains applies the Contains predicate on the "pool_id" field.
func PoolIDContains(v string) predicate.EbsVolume {
	return predicate.EbsVolume(sql.FieldContains(FieldPoolID, v))
}

// PoolIDHasPrefix applies the HasPrefix predicate on the "pool_id" field.
func PoolIDHasPrefix(v string) predicate.EbsVolume {
	return predicate.EbsVolume(sql.FieldHasPrefix(FieldPoolID, v))
}

// PoolIDHasSuffix applies the HasSuffix predicate on the "pool_id" field.
func PoolIDHasSuffix(v string) predicate.EbsVolume {
	return predicate.EbsVolume(sql.FieldHasSuffix(FieldPoolID, v))
}

// PoolIDIsNil applies the IsNil predicate on the "pool_id" field.
func PoolIDIsNil() predicate.EbsVolume {
	return predicate.EbsVolume(sql.FieldIsNull(FieldPoolID))
}

// PoolIDNotNil applies the NotNil predicate on the "pool_id" field.
func PoolIDNotNil() predicate.EbsVolume {
	return predicate.EbsVolume(sql.FieldNotNull(FieldPoolID))
}

// PoolIDEqualFold applies the EqualFold predicate on the "pool_id" field.
func PoolIDEqualFold(v string) predicate.EbsVolume {
	return predicate.EbsVolume(sql.FieldEqualFold(FieldPoolID, v))
}

// PoolIDContainsFold applies the ContainsFold predicate on the "pool_id" field.
func PoolIDContainsFold(v string) predicate.EbsVolume {
	return predicate.EbsVolume(sql.FieldContainsFold(FieldPoolID, v))
}

// PoolNameEQ applies the EQ predicate on the "pool_name" field.
func PoolNameEQ(v string) predicate.EbsVolume {
	return predicate.EbsVolume(sql.FieldEQ(FieldPoolName, v))
}

// PoolNameNEQ applies the NEQ predicate on the "pool_name" field.
func PoolNameNEQ(v string) predicate.EbsVolume {
	return predicate.EbsVolume(sql.FieldNEQ(FieldPoolName, v))
}

// PoolNameIn applies the In predicate on the "pool_name" field.
func PoolNameIn(vs ...string) predicate.EbsVolume {
	return predicate.EbsVolume(sql.FieldIn(FieldPoolName, vs...))
}

// PoolNameNotIn applies the NotIn predicate on the "pool_name" field.
func PoolNameNotIn(vs ...string) predicate.EbsVolume {
	return predicate.EbsVolume(sql.FieldNotIn(FieldPoolName, vs...))
}

// PoolNameGT applies the GT predicate on the "pool_name" field.
func PoolNameGT(v string) predicate.EbsVolume {
	return predicate.EbsVolume(sql.FieldGT(FieldPoolName, v))
}

// PoolNameGTE applies the GTE predicate on the "pool_name" field.
func PoolNameGTE(v string) predicate.EbsVolume {
	return predicate.EbsVolume(sql.FieldGTE(FieldPoolName, v))
}

// PoolNameLT applies the LT predicate on the "pool_name" field.
func PoolNameLT(v string) predicate.EbsVolume {
	return predicate.EbsVolume(sql.FieldLT(FieldPoolName, v))
}

// PoolNameLTE applies the LTE predicate on the "pool_name" field.
func PoolNameLTE(v string) predicate.EbsVolume {
	return predicate.EbsVolume(sql.FieldLTE(FieldPoolName, v))
}

// PoolNameContains applies the Contains predicate on the "pool_name" field.
func PoolNameContains(v string) predicate.EbsVolume {
	return predicate.EbsVolume(sql.FieldContains(FieldPoolName, v))
}

// PoolNameHasPrefix applies the HasPrefix predicate on the "pool_name" field.
func PoolNameHasPrefix(v string) predicate.EbsVolume {
	return predicate.EbsVolume(sql.FieldHasPrefix(FieldPoolName, v))
}

// PoolNameHasSuffix applies the HasSuffix predicate on the "pool_name" field.
func PoolNameHasSuffix(v string) predicate.EbsVolume {
	return predicate.EbsVolume(sql.FieldHasSuffix(FieldPoolName, v))
}

// PoolNameIsNil applies the IsNil predicate on the "pool_name" field.
func PoolNameIsNil() predicate.EbsVolume {
	return predicate.EbsVolume(sql.FieldIsNull(FieldPoolName))
}

// PoolNameNotNil applies the NotNil predicate on the "pool_name" field.
func PoolNameNotNil() predicate.EbsVolume {
	return predicate.EbsVolume(sql.FieldNotNull(FieldPoolName))
}

// PoolNameEqualFold applies the EqualFold predicate on the "pool_name" field.
func PoolNameEqualFold(v string) predicate.EbsVolume {
	return predicate.EbsVolume(sql.FieldEqualFold(FieldPoolName, v))
}

// PoolNameContainsFold applies the ContainsFold predicate on the "pool_name" field.
func PoolNameContainsFold(v string) predicate.EbsVolume {
	return predicate.EbsVolume(sql.FieldContainsFold(FieldPoolName, v))
}

// SizeEQ applies the EQ predicate on the "size" field.
func SizeEQ(v int32) predicate.EbsVolume {
	return predicate.EbsVolume(sql.FieldEQ(FieldSize, v))
}

// SizeNEQ applies the NEQ predicate on the "size" field.
func SizeNEQ(v int32) predicate.EbsVolume {
	return predicate.EbsVolume(sql.FieldNEQ(FieldSize, v))
}

// SizeIn applies the In predicate on the "size" field.
func SizeIn(vs ...int32) predicate.EbsVolume {
	return predicate.EbsVolume(sql.FieldIn(FieldSize, vs...))
}

// SizeNotIn applies the NotIn predicate on the "size" field.
func SizeNotIn(vs ...int32) predicate.EbsVolume {
	return predicate.EbsVolume(sql.FieldNotIn(FieldSize, vs...))
}

// SizeGT applies the GT predicate on the "size" field.
func SizeGT(v int32) predicate.EbsVolume {
	return predicate.EbsVolume(sql.FieldGT(FieldSize, v))
}

// SizeGTE applies the GTE predicate on the "size" field.
func SizeGTE(v int32) predicate.EbsVolume {
	return predicate.EbsVolume(sql.FieldGTE(FieldSize, v))
}

// SizeLT applies the LT predicate on the "size" field.
func SizeLT(v int32) predicate.EbsVolume {
	return predicate.EbsVolume(sql.FieldLT(FieldSize, v))
}

// SizeLTE applies the LTE predicate on the "size" field.
func SizeLTE(v int32) predicate.EbsVolume {
	return predicate.EbsVolume(sql.FieldLTE(FieldSize, v))
}

// SizeIsNil applies the IsNil predicate on the "size" field.
func SizeIsNil() predicate.EbsVolume {
	return predicate.EbsVolume(sql.FieldIsNull(FieldSize))
}

// SizeNotNil applies the NotNil predicate on the "size" field.
func SizeNotNil() predicate.EbsVolume {
	return predicate.EbsVolume(sql.FieldNotNull(FieldSize))
}

// StatusEQ applies the EQ predicate on the "status" field.
func StatusEQ(v string) predicate.EbsVolume {
	return predicate.EbsVolume(sql.FieldEQ(FieldStatus, v))
}

// StatusNEQ applies the NEQ predicate on the "status" field.
func StatusNEQ(v string) predicate.EbsVolume {
	return predicate.EbsVolume(sql.FieldNEQ(FieldStatus, v))
}

// StatusIn applies the In predicate on the "status" field.
func StatusIn(vs ...string) predicate.EbsVolume {
	return predicate.EbsVolume(sql.FieldIn(FieldStatus, vs...))
}

// StatusNotIn applies the NotIn predicate on the "status" field.
func StatusNotIn(vs ...string) predicate.EbsVolume {
	return predicate.EbsVolume(sql.FieldNotIn(FieldStatus, vs...))
}

// StatusGT applies the GT predicate on the "status" field.
func StatusGT(v string) predicate.EbsVolume {
	return predicate.EbsVolume(sql.FieldGT(FieldStatus, v))
}

// StatusGTE applies the GTE predicate on the "status" field.
func StatusGTE(v string) predicate.EbsVolume {
	return predicate.EbsVolume(sql.FieldGTE(FieldStatus, v))
}

// StatusLT applies the LT predicate on the "status" field.
func StatusLT(v string) predicate.EbsVolume {
	return predicate.EbsVolume(sql.FieldLT(FieldStatus, v))
}

// StatusLTE applies the LTE predicate on the "status" field.
func StatusLTE(v string) predicate.EbsVolume {
	return predicate.EbsVolume(sql.FieldLTE(FieldStatus, v))
}

// StatusContains applies the Contains predicate on the "status" field.
func StatusContains(v string) predicate.EbsVolume {
	return predicate.EbsVolume(sql.FieldContains(FieldStatus, v))
}

// StatusHasPrefix applies the HasPrefix predicate on the "status" field.
func StatusHasPrefix(v string) predicate.EbsVolume {
	return predicate.EbsVolume(sql.FieldHasPrefix(FieldStatus, v))
}

// StatusHasSuffix applies the HasSuffix predicate on the "status" field.
func StatusHasSuffix(v string) predicate.EbsVolume {
	return predicate.EbsVolume(sql.FieldHasSuffix(FieldStatus, v))
}

// StatusIsNil applies the IsNil predicate on the "status" field.
func StatusIsNil() predicate.EbsVolume {
	return predicate.EbsVolume(sql.FieldIsNull(FieldStatus))
}

// StatusNotNil applies the NotNil predicate on the "status" field.
func StatusNotNil() predicate.EbsVolume {
	return predicate.EbsVolume(sql.FieldNotNull(FieldStatus))
}

// StatusEqualFold applies the EqualFold predicate on the "status" field.
func StatusEqualFold(v string) predicate.EbsVolume {
	return predicate.EbsVolume(sql.FieldEqualFold(FieldStatus, v))
}

// StatusContainsFold applies the ContainsFold predicate on the "status" field.
func StatusContainsFold(v string) predicate.EbsVolume {
	return predicate.EbsVolume(sql.FieldContainsFold(FieldStatus, v))
}

// StatusNameEQ applies the EQ predicate on the "status_name" field.
func StatusNameEQ(v string) predicate.EbsVolume {
	return predicate.EbsVolume(sql.FieldEQ(FieldStatusName, v))
}

// StatusNameNEQ applies the NEQ predicate on the "status_name" field.
func StatusNameNEQ(v string) predicate.EbsVolume {
	return predicate.EbsVolume(sql.FieldNEQ(FieldStatusName, v))
}

// StatusNameIn applies the In predicate on the "status_name" field.
func StatusNameIn(vs ...string) predicate.EbsVolume {
	return predicate.EbsVolume(sql.FieldIn(FieldStatusName, vs...))
}

// StatusNameNotIn applies the NotIn predicate on the "status_name" field.
func StatusNameNotIn(vs ...string) predicate.EbsVolume {
	return predicate.EbsVolume(sql.FieldNotIn(FieldStatusName, vs...))
}

// StatusNameGT applies the GT predicate on the "status_name" field.
func StatusNameGT(v string) predicate.EbsVolume {
	return predicate.EbsVolume(sql.FieldGT(FieldStatusName, v))
}

// StatusNameGTE applies the GTE predicate on the "status_name" field.
func StatusNameGTE(v string) predicate.EbsVolume {
	return predicate.EbsVolume(sql.FieldGTE(FieldStatusName, v))
}

// StatusNameLT applies the LT predicate on the "status_name" field.
func StatusNameLT(v string) predicate.EbsVolume {
	return predicate.EbsVolume(sql.FieldLT(FieldStatusName, v))
}

// StatusNameLTE applies the LTE predicate on the "status_name" field.
func StatusNameLTE(v string) predicate.EbsVolume {
	return predicate.EbsVolume(sql.FieldLTE(FieldStatusName, v))
}

// StatusNameContains applies the Contains predicate on the "status_name" field.
func StatusNameContains(v string) predicate.EbsVolume {
	return predicate.EbsVolume(sql.FieldContains(FieldStatusName, v))
}

// StatusNameHasPrefix applies the HasPrefix predicate on the "status_name" field.
func StatusNameHasPrefix(v string) predicate.EbsVolume {
	return predicate.EbsVolume(sql.FieldHasPrefix(FieldStatusName, v))
}

// StatusNameHasSuffix applies the HasSuffix predicate on the "status_name" field.
func StatusNameHasSuffix(v string) predicate.EbsVolume {
	return predicate.EbsVolume(sql.FieldHasSuffix(FieldStatusName, v))
}

// StatusNameIsNil applies the IsNil predicate on the "status_name" field.
func StatusNameIsNil() predicate.EbsVolume {
	return predicate.EbsVolume(sql.FieldIsNull(FieldStatusName))
}

// StatusNameNotNil applies the NotNil predicate on the "status_name" field.
func StatusNameNotNil() predicate.EbsVolume {
	return predicate.EbsVolume(sql.FieldNotNull(FieldStatusName))
}

// StatusNameEqualFold applies the EqualFold predicate on the "status_name" field.
func StatusNameEqualFold(v string) predicate.EbsVolume {
	return predicate.EbsVolume(sql.FieldEqualFold(FieldStatusName, v))
}

// StatusNameContainsFold applies the ContainsFold predicate on the "status_name" field.
func StatusNameContainsFold(v string) predicate.EbsVolume {
	return predicate.EbsVolume(sql.FieldContainsFold(FieldStatusName, v))
}

// VolumeTypeEQ applies the EQ predicate on the "volume_type" field.
func VolumeTypeEQ(v string) predicate.EbsVolume {
	return predicate.EbsVolume(sql.FieldEQ(FieldVolumeType, v))
}

// VolumeTypeNEQ applies the NEQ predicate on the "volume_type" field.
func VolumeTypeNEQ(v string) predicate.EbsVolume {
	return predicate.EbsVolume(sql.FieldNEQ(FieldVolumeType, v))
}

// VolumeTypeIn applies the In predicate on the "volume_type" field.
func VolumeTypeIn(vs ...string) predicate.EbsVolume {
	return predicate.EbsVolume(sql.FieldIn(FieldVolumeType, vs...))
}

// VolumeTypeNotIn applies the NotIn predicate on the "volume_type" field.
func VolumeTypeNotIn(vs ...string) predicate.EbsVolume {
	return predicate.EbsVolume(sql.FieldNotIn(FieldVolumeType, vs...))
}

// VolumeTypeGT applies the GT predicate on the "volume_type" field.
func VolumeTypeGT(v string) predicate.EbsVolume {
	return predicate.EbsVolume(sql.FieldGT(FieldVolumeType, v))
}

// VolumeTypeGTE applies the GTE predicate on the "volume_type" field.
func VolumeTypeGTE(v string) predicate.EbsVolume {
	return predicate.EbsVolume(sql.FieldGTE(FieldVolumeType, v))
}

// VolumeTypeLT applies the LT predicate on the "volume_type" field.
func VolumeTypeLT(v string) predicate.EbsVolume {
	return predicate.EbsVolume(sql.FieldLT(FieldVolumeType, v))
}

// VolumeTypeLTE applies the LTE predicate on the "volume_type" field.
func VolumeTypeLTE(v string) predicate.EbsVolume {
	return predicate.EbsVolume(sql.FieldLTE(FieldVolumeType, v))
}

// VolumeTypeContains applies the Contains predicate on the "volume_type" field.
func VolumeTypeContains(v string) predicate.EbsVolume {
	return predicate.EbsVolume(sql.FieldContains(FieldVolumeType, v))
}

// VolumeTypeHasPrefix applies the HasPrefix predicate on the "volume_type" field.
func VolumeTypeHasPrefix(v string) predicate.EbsVolume {
	return predicate.EbsVolume(sql.FieldHasPrefix(FieldVolumeType, v))
}

// VolumeTypeHasSuffix applies the HasSuffix predicate on the "volume_type" field.
func VolumeTypeHasSuffix(v string) predicate.EbsVolume {
	return predicate.EbsVolume(sql.FieldHasSuffix(FieldVolumeType, v))
}

// VolumeTypeIsNil applies the IsNil predicate on the "volume_type" field.
func VolumeTypeIsNil() predicate.EbsVolume {
	return predicate.EbsVolume(sql.FieldIsNull(FieldVolumeType))
}

// VolumeTypeNotNil applies the NotNil predicate on the "volume_type" field.
func VolumeTypeNotNil() predicate.EbsVolume {
	return predicate.EbsVolume(sql.FieldNotNull(FieldVolumeType))
}

// VolumeTypeEqualFold applies the EqualFold predicate on the "volume_type" field.
func VolumeTypeEqualFold(v string) predicate.EbsVolume {
	return predicate.EbsVolume(sql.FieldEqualFold(FieldVolumeType, v))
}

// VolumeTypeContainsFold applies the ContainsFold predicate on the "volume_type" field.
func VolumeTypeContainsFold(v string) predicate.EbsVolume {
	return predicate.EbsVolume(sql.FieldContainsFold(FieldVolumeType, v))
}

// VMIDEQ applies the EQ predicate on the "vm_id" field.
func VMIDEQ(v string) predicate.EbsVolume {
	return predicate.EbsVolume(sql.FieldEQ(FieldVMID, v))
}

// VMIDNEQ applies the NEQ predicate on the "vm_id" field.
func VMIDNEQ(v string) predicate.EbsVolume {
	return predicate.EbsVolume(sql.FieldNEQ(FieldVMID, v))
}

// VMIDIn applies the In predicate on the "vm_id" field.
func VMIDIn(vs ...string) predicate.EbsVolume {
	return predicate.EbsVolume(sql.FieldIn(FieldVMID, vs...))
}

// VMIDNotIn applies the NotIn predicate on the "vm_id" field.
func VMIDNotIn(vs ...string) predicate.EbsVolume {
	return predicate.EbsVolume(sql.FieldNotIn(FieldVMID, vs...))
}

// VMIDGT applies the GT predicate on the "vm_id" field.
func VMIDGT(v string) predicate.EbsVolume {
	return predicate.EbsVolume(sql.FieldGT(FieldVMID, v))
}

// VMIDGTE applies the GTE predicate on the "vm_id" field.
func VMIDGTE(v string) predicate.EbsVolume {
	return predicate.EbsVolume(sql.FieldGTE(FieldVMID, v))
}

// VMIDLT applies the LT predicate on the "vm_id" field.
func VMIDLT(v string) predicate.EbsVolume {
	return predicate.EbsVolume(sql.FieldLT(FieldVMID, v))
}

// VMIDLTE applies the LTE predicate on the "vm_id" field.
func VMIDLTE(v string) predicate.EbsVolume {
	return predicate.EbsVolume(sql.FieldLTE(FieldVMID, v))
}

// VMIDContains applies the Contains predicate on the "vm_id" field.
func VMIDContains(v string) predicate.EbsVolume {
	return predicate.EbsVolume(sql.FieldContains(FieldVMID, v))
}

// VMIDHasPrefix applies the HasPrefix predicate on the "vm_id" field.
func VMIDHasPrefix(v string) predicate.EbsVolume {
	return predicate.EbsVolume(sql.FieldHasPrefix(FieldVMID, v))
}

// VMIDHasSuffix applies the HasSuffix predicate on the "vm_id" field.
func VMIDHasSuffix(v string) predicate.EbsVolume {
	return predicate.EbsVolume(sql.FieldHasSuffix(FieldVMID, v))
}

// VMIDEqualFold applies the EqualFold predicate on the "vm_id" field.
func VMIDEqualFold(v string) predicate.EbsVolume {
	return predicate.EbsVolume(sql.FieldEqualFold(FieldVMID, v))
}

// VMIDContainsFold applies the ContainsFold predicate on the "vm_id" field.
func VMIDContainsFold(v string) predicate.EbsVolume {
	return predicate.EbsVolume(sql.FieldContainsFold(FieldVMID, v))
}

// VMNameEQ applies the EQ predicate on the "vm_name" field.
func VMNameEQ(v string) predicate.EbsVolume {
	return predicate.EbsVolume(sql.FieldEQ(FieldVMName, v))
}

// VMNameNEQ applies the NEQ predicate on the "vm_name" field.
func VMNameNEQ(v string) predicate.EbsVolume {
	return predicate.EbsVolume(sql.FieldNEQ(FieldVMName, v))
}

// VMNameIn applies the In predicate on the "vm_name" field.
func VMNameIn(vs ...string) predicate.EbsVolume {
	return predicate.EbsVolume(sql.FieldIn(FieldVMName, vs...))
}

// VMNameNotIn applies the NotIn predicate on the "vm_name" field.
func VMNameNotIn(vs ...string) predicate.EbsVolume {
	return predicate.EbsVolume(sql.FieldNotIn(FieldVMName, vs...))
}

// VMNameGT applies the GT predicate on the "vm_name" field.
func VMNameGT(v string) predicate.EbsVolume {
	return predicate.EbsVolume(sql.FieldGT(FieldVMName, v))
}

// VMNameGTE applies the GTE predicate on the "vm_name" field.
func VMNameGTE(v string) predicate.EbsVolume {
	return predicate.EbsVolume(sql.FieldGTE(FieldVMName, v))
}

// VMNameLT applies the LT predicate on the "vm_name" field.
func VMNameLT(v string) predicate.EbsVolume {
	return predicate.EbsVolume(sql.FieldLT(FieldVMName, v))
}

// VMNameLTE applies the LTE predicate on the "vm_name" field.
func VMNameLTE(v string) predicate.EbsVolume {
	return predicate.EbsVolume(sql.FieldLTE(FieldVMName, v))
}

// VMNameContains applies the Contains predicate on the "vm_name" field.
func VMNameContains(v string) predicate.EbsVolume {
	return predicate.EbsVolume(sql.FieldContains(FieldVMName, v))
}

// VMNameHasPrefix applies the HasPrefix predicate on the "vm_name" field.
func VMNameHasPrefix(v string) predicate.EbsVolume {
	return predicate.EbsVolume(sql.FieldHasPrefix(FieldVMName, v))
}

// VMNameHasSuffix applies the HasSuffix predicate on the "vm_name" field.
func VMNameHasSuffix(v string) predicate.EbsVolume {
	return predicate.EbsVolume(sql.FieldHasSuffix(FieldVMName, v))
}

// VMNameEqualFold applies the EqualFold predicate on the "vm_name" field.
func VMNameEqualFold(v string) predicate.EbsVolume {
	return predicate.EbsVolume(sql.FieldEqualFold(FieldVMName, v))
}

// VMNameContainsFold applies the ContainsFold predicate on the "vm_name" field.
func VMNameContainsFold(v string) predicate.EbsVolume {
	return predicate.EbsVolume(sql.FieldContainsFold(FieldVMName, v))
}

// TenantIDEQ applies the EQ predicate on the "tenant_id" field.
func TenantIDEQ(v string) predicate.EbsVolume {
	return predicate.EbsVolume(sql.FieldEQ(FieldTenantID, v))
}

// TenantIDNEQ applies the NEQ predicate on the "tenant_id" field.
func TenantIDNEQ(v string) predicate.EbsVolume {
	return predicate.EbsVolume(sql.FieldNEQ(FieldTenantID, v))
}

// TenantIDIn applies the In predicate on the "tenant_id" field.
func TenantIDIn(vs ...string) predicate.EbsVolume {
	return predicate.EbsVolume(sql.FieldIn(FieldTenantID, vs...))
}

// TenantIDNotIn applies the NotIn predicate on the "tenant_id" field.
func TenantIDNotIn(vs ...string) predicate.EbsVolume {
	return predicate.EbsVolume(sql.FieldNotIn(FieldTenantID, vs...))
}

// TenantIDGT applies the GT predicate on the "tenant_id" field.
func TenantIDGT(v string) predicate.EbsVolume {
	return predicate.EbsVolume(sql.FieldGT(FieldTenantID, v))
}

// TenantIDGTE applies the GTE predicate on the "tenant_id" field.
func TenantIDGTE(v string) predicate.EbsVolume {
	return predicate.EbsVolume(sql.FieldGTE(FieldTenantID, v))
}

// TenantIDLT applies the LT predicate on the "tenant_id" field.
func TenantIDLT(v string) predicate.EbsVolume {
	return predicate.EbsVolume(sql.FieldLT(FieldTenantID, v))
}

// TenantIDLTE applies the LTE predicate on the "tenant_id" field.
func TenantIDLTE(v string) predicate.EbsVolume {
	return predicate.EbsVolume(sql.FieldLTE(FieldTenantID, v))
}

// TenantIDContains applies the Contains predicate on the "tenant_id" field.
func TenantIDContains(v string) predicate.EbsVolume {
	return predicate.EbsVolume(sql.FieldContains(FieldTenantID, v))
}

// TenantIDHasPrefix applies the HasPrefix predicate on the "tenant_id" field.
func TenantIDHasPrefix(v string) predicate.EbsVolume {
	return predicate.EbsVolume(sql.FieldHasPrefix(FieldTenantID, v))
}

// TenantIDHasSuffix applies the HasSuffix predicate on the "tenant_id" field.
func TenantIDHasSuffix(v string) predicate.EbsVolume {
	return predicate.EbsVolume(sql.FieldHasSuffix(FieldTenantID, v))
}

// TenantIDIsNil applies the IsNil predicate on the "tenant_id" field.
func TenantIDIsNil() predicate.EbsVolume {
	return predicate.EbsVolume(sql.FieldIsNull(FieldTenantID))
}

// TenantIDNotNil applies the NotNil predicate on the "tenant_id" field.
func TenantIDNotNil() predicate.EbsVolume {
	return predicate.EbsVolume(sql.FieldNotNull(FieldTenantID))
}

// TenantIDEqualFold applies the EqualFold predicate on the "tenant_id" field.
func TenantIDEqualFold(v string) predicate.EbsVolume {
	return predicate.EbsVolume(sql.FieldEqualFold(FieldTenantID, v))
}

// TenantIDContainsFold applies the ContainsFold predicate on the "tenant_id" field.
func TenantIDContainsFold(v string) predicate.EbsVolume {
	return predicate.EbsVolume(sql.FieldContainsFold(FieldTenantID, v))
}

// TenantNameEQ applies the EQ predicate on the "tenant_name" field.
func TenantNameEQ(v string) predicate.EbsVolume {
	return predicate.EbsVolume(sql.FieldEQ(FieldTenantName, v))
}

// TenantNameNEQ applies the NEQ predicate on the "tenant_name" field.
func TenantNameNEQ(v string) predicate.EbsVolume {
	return predicate.EbsVolume(sql.FieldNEQ(FieldTenantName, v))
}

// TenantNameIn applies the In predicate on the "tenant_name" field.
func TenantNameIn(vs ...string) predicate.EbsVolume {
	return predicate.EbsVolume(sql.FieldIn(FieldTenantName, vs...))
}

// TenantNameNotIn applies the NotIn predicate on the "tenant_name" field.
func TenantNameNotIn(vs ...string) predicate.EbsVolume {
	return predicate.EbsVolume(sql.FieldNotIn(FieldTenantName, vs...))
}

// TenantNameGT applies the GT predicate on the "tenant_name" field.
func TenantNameGT(v string) predicate.EbsVolume {
	return predicate.EbsVolume(sql.FieldGT(FieldTenantName, v))
}

// TenantNameGTE applies the GTE predicate on the "tenant_name" field.
func TenantNameGTE(v string) predicate.EbsVolume {
	return predicate.EbsVolume(sql.FieldGTE(FieldTenantName, v))
}

// TenantNameLT applies the LT predicate on the "tenant_name" field.
func TenantNameLT(v string) predicate.EbsVolume {
	return predicate.EbsVolume(sql.FieldLT(FieldTenantName, v))
}

// TenantNameLTE applies the LTE predicate on the "tenant_name" field.
func TenantNameLTE(v string) predicate.EbsVolume {
	return predicate.EbsVolume(sql.FieldLTE(FieldTenantName, v))
}

// TenantNameContains applies the Contains predicate on the "tenant_name" field.
func TenantNameContains(v string) predicate.EbsVolume {
	return predicate.EbsVolume(sql.FieldContains(FieldTenantName, v))
}

// TenantNameHasPrefix applies the HasPrefix predicate on the "tenant_name" field.
func TenantNameHasPrefix(v string) predicate.EbsVolume {
	return predicate.EbsVolume(sql.FieldHasPrefix(FieldTenantName, v))
}

// TenantNameHasSuffix applies the HasSuffix predicate on the "tenant_name" field.
func TenantNameHasSuffix(v string) predicate.EbsVolume {
	return predicate.EbsVolume(sql.FieldHasSuffix(FieldTenantName, v))
}

// TenantNameIsNil applies the IsNil predicate on the "tenant_name" field.
func TenantNameIsNil() predicate.EbsVolume {
	return predicate.EbsVolume(sql.FieldIsNull(FieldTenantName))
}

// TenantNameNotNil applies the NotNil predicate on the "tenant_name" field.
func TenantNameNotNil() predicate.EbsVolume {
	return predicate.EbsVolume(sql.FieldNotNull(FieldTenantName))
}

// TenantNameEqualFold applies the EqualFold predicate on the "tenant_name" field.
func TenantNameEqualFold(v string) predicate.EbsVolume {
	return predicate.EbsVolume(sql.FieldEqualFold(FieldTenantName, v))
}

// TenantNameContainsFold applies the ContainsFold predicate on the "tenant_name" field.
func TenantNameContainsFold(v string) predicate.EbsVolume {
	return predicate.EbsVolume(sql.FieldContainsFold(FieldTenantName, v))
}

// ProjectIDEQ applies the EQ predicate on the "project_id" field.
func ProjectIDEQ(v string) predicate.EbsVolume {
	return predicate.EbsVolume(sql.FieldEQ(FieldProjectID, v))
}

// ProjectIDNEQ applies the NEQ predicate on the "project_id" field.
func ProjectIDNEQ(v string) predicate.EbsVolume {
	return predicate.EbsVolume(sql.FieldNEQ(FieldProjectID, v))
}

// ProjectIDIn applies the In predicate on the "project_id" field.
func ProjectIDIn(vs ...string) predicate.EbsVolume {
	return predicate.EbsVolume(sql.FieldIn(FieldProjectID, vs...))
}

// ProjectIDNotIn applies the NotIn predicate on the "project_id" field.
func ProjectIDNotIn(vs ...string) predicate.EbsVolume {
	return predicate.EbsVolume(sql.FieldNotIn(FieldProjectID, vs...))
}

// ProjectIDGT applies the GT predicate on the "project_id" field.
func ProjectIDGT(v string) predicate.EbsVolume {
	return predicate.EbsVolume(sql.FieldGT(FieldProjectID, v))
}

// ProjectIDGTE applies the GTE predicate on the "project_id" field.
func ProjectIDGTE(v string) predicate.EbsVolume {
	return predicate.EbsVolume(sql.FieldGTE(FieldProjectID, v))
}

// ProjectIDLT applies the LT predicate on the "project_id" field.
func ProjectIDLT(v string) predicate.EbsVolume {
	return predicate.EbsVolume(sql.FieldLT(FieldProjectID, v))
}

// ProjectIDLTE applies the LTE predicate on the "project_id" field.
func ProjectIDLTE(v string) predicate.EbsVolume {
	return predicate.EbsVolume(sql.FieldLTE(FieldProjectID, v))
}

// ProjectIDContains applies the Contains predicate on the "project_id" field.
func ProjectIDContains(v string) predicate.EbsVolume {
	return predicate.EbsVolume(sql.FieldContains(FieldProjectID, v))
}

// ProjectIDHasPrefix applies the HasPrefix predicate on the "project_id" field.
func ProjectIDHasPrefix(v string) predicate.EbsVolume {
	return predicate.EbsVolume(sql.FieldHasPrefix(FieldProjectID, v))
}

// ProjectIDHasSuffix applies the HasSuffix predicate on the "project_id" field.
func ProjectIDHasSuffix(v string) predicate.EbsVolume {
	return predicate.EbsVolume(sql.FieldHasSuffix(FieldProjectID, v))
}

// ProjectIDEqualFold applies the EqualFold predicate on the "project_id" field.
func ProjectIDEqualFold(v string) predicate.EbsVolume {
	return predicate.EbsVolume(sql.FieldEqualFold(FieldProjectID, v))
}

// ProjectIDContainsFold applies the ContainsFold predicate on the "project_id" field.
func ProjectIDContainsFold(v string) predicate.EbsVolume {
	return predicate.EbsVolume(sql.FieldContainsFold(FieldProjectID, v))
}

// ProjectNameEQ applies the EQ predicate on the "project_name" field.
func ProjectNameEQ(v string) predicate.EbsVolume {
	return predicate.EbsVolume(sql.FieldEQ(FieldProjectName, v))
}

// ProjectNameNEQ applies the NEQ predicate on the "project_name" field.
func ProjectNameNEQ(v string) predicate.EbsVolume {
	return predicate.EbsVolume(sql.FieldNEQ(FieldProjectName, v))
}

// ProjectNameIn applies the In predicate on the "project_name" field.
func ProjectNameIn(vs ...string) predicate.EbsVolume {
	return predicate.EbsVolume(sql.FieldIn(FieldProjectName, vs...))
}

// ProjectNameNotIn applies the NotIn predicate on the "project_name" field.
func ProjectNameNotIn(vs ...string) predicate.EbsVolume {
	return predicate.EbsVolume(sql.FieldNotIn(FieldProjectName, vs...))
}

// ProjectNameGT applies the GT predicate on the "project_name" field.
func ProjectNameGT(v string) predicate.EbsVolume {
	return predicate.EbsVolume(sql.FieldGT(FieldProjectName, v))
}

// ProjectNameGTE applies the GTE predicate on the "project_name" field.
func ProjectNameGTE(v string) predicate.EbsVolume {
	return predicate.EbsVolume(sql.FieldGTE(FieldProjectName, v))
}

// ProjectNameLT applies the LT predicate on the "project_name" field.
func ProjectNameLT(v string) predicate.EbsVolume {
	return predicate.EbsVolume(sql.FieldLT(FieldProjectName, v))
}

// ProjectNameLTE applies the LTE predicate on the "project_name" field.
func ProjectNameLTE(v string) predicate.EbsVolume {
	return predicate.EbsVolume(sql.FieldLTE(FieldProjectName, v))
}

// ProjectNameContains applies the Contains predicate on the "project_name" field.
func ProjectNameContains(v string) predicate.EbsVolume {
	return predicate.EbsVolume(sql.FieldContains(FieldProjectName, v))
}

// ProjectNameHasPrefix applies the HasPrefix predicate on the "project_name" field.
func ProjectNameHasPrefix(v string) predicate.EbsVolume {
	return predicate.EbsVolume(sql.FieldHasPrefix(FieldProjectName, v))
}

// ProjectNameHasSuffix applies the HasSuffix predicate on the "project_name" field.
func ProjectNameHasSuffix(v string) predicate.EbsVolume {
	return predicate.EbsVolume(sql.FieldHasSuffix(FieldProjectName, v))
}

// ProjectNameEqualFold applies the EqualFold predicate on the "project_name" field.
func ProjectNameEqualFold(v string) predicate.EbsVolume {
	return predicate.EbsVolume(sql.FieldEqualFold(FieldProjectName, v))
}

// ProjectNameContainsFold applies the ContainsFold predicate on the "project_name" field.
func ProjectNameContainsFold(v string) predicate.EbsVolume {
	return predicate.EbsVolume(sql.FieldContainsFold(FieldProjectName, v))
}

// CreateTimeEQ applies the EQ predicate on the "create_time" field.
func CreateTimeEQ(v time.Time) predicate.EbsVolume {
	return predicate.EbsVolume(sql.FieldEQ(FieldCreateTime, v))
}

// CreateTimeNEQ applies the NEQ predicate on the "create_time" field.
func CreateTimeNEQ(v time.Time) predicate.EbsVolume {
	return predicate.EbsVolume(sql.FieldNEQ(FieldCreateTime, v))
}

// CreateTimeIn applies the In predicate on the "create_time" field.
func CreateTimeIn(vs ...time.Time) predicate.EbsVolume {
	return predicate.EbsVolume(sql.FieldIn(FieldCreateTime, vs...))
}

// CreateTimeNotIn applies the NotIn predicate on the "create_time" field.
func CreateTimeNotIn(vs ...time.Time) predicate.EbsVolume {
	return predicate.EbsVolume(sql.FieldNotIn(FieldCreateTime, vs...))
}

// CreateTimeGT applies the GT predicate on the "create_time" field.
func CreateTimeGT(v time.Time) predicate.EbsVolume {
	return predicate.EbsVolume(sql.FieldGT(FieldCreateTime, v))
}

// CreateTimeGTE applies the GTE predicate on the "create_time" field.
func CreateTimeGTE(v time.Time) predicate.EbsVolume {
	return predicate.EbsVolume(sql.FieldGTE(FieldCreateTime, v))
}

// CreateTimeLT applies the LT predicate on the "create_time" field.
func CreateTimeLT(v time.Time) predicate.EbsVolume {
	return predicate.EbsVolume(sql.FieldLT(FieldCreateTime, v))
}

// CreateTimeLTE applies the LTE predicate on the "create_time" field.
func CreateTimeLTE(v time.Time) predicate.EbsVolume {
	return predicate.EbsVolume(sql.FieldLTE(FieldCreateTime, v))
}

// CreateTimeIsNil applies the IsNil predicate on the "create_time" field.
func CreateTimeIsNil() predicate.EbsVolume {
	return predicate.EbsVolume(sql.FieldIsNull(FieldCreateTime))
}

// CreateTimeNotNil applies the NotNil predicate on the "create_time" field.
func CreateTimeNotNil() predicate.EbsVolume {
	return predicate.EbsVolume(sql.FieldNotNull(FieldCreateTime))
}

// ServiceEndTimeEQ applies the EQ predicate on the "service_end_time" field.
func ServiceEndTimeEQ(v time.Time) predicate.EbsVolume {
	return predicate.EbsVolume(sql.FieldEQ(FieldServiceEndTime, v))
}

// ServiceEndTimeNEQ applies the NEQ predicate on the "service_end_time" field.
func ServiceEndTimeNEQ(v time.Time) predicate.EbsVolume {
	return predicate.EbsVolume(sql.FieldNEQ(FieldServiceEndTime, v))
}

// ServiceEndTimeIn applies the In predicate on the "service_end_time" field.
func ServiceEndTimeIn(vs ...time.Time) predicate.EbsVolume {
	return predicate.EbsVolume(sql.FieldIn(FieldServiceEndTime, vs...))
}

// ServiceEndTimeNotIn applies the NotIn predicate on the "service_end_time" field.
func ServiceEndTimeNotIn(vs ...time.Time) predicate.EbsVolume {
	return predicate.EbsVolume(sql.FieldNotIn(FieldServiceEndTime, vs...))
}

// ServiceEndTimeGT applies the GT predicate on the "service_end_time" field.
func ServiceEndTimeGT(v time.Time) predicate.EbsVolume {
	return predicate.EbsVolume(sql.FieldGT(FieldServiceEndTime, v))
}

// ServiceEndTimeGTE applies the GTE predicate on the "service_end_time" field.
func ServiceEndTimeGTE(v time.Time) predicate.EbsVolume {
	return predicate.EbsVolume(sql.FieldGTE(FieldServiceEndTime, v))
}

// ServiceEndTimeLT applies the LT predicate on the "service_end_time" field.
func ServiceEndTimeLT(v time.Time) predicate.EbsVolume {
	return predicate.EbsVolume(sql.FieldLT(FieldServiceEndTime, v))
}

// ServiceEndTimeLTE applies the LTE predicate on the "service_end_time" field.
func ServiceEndTimeLTE(v time.Time) predicate.EbsVolume {
	return predicate.EbsVolume(sql.FieldLTE(FieldServiceEndTime, v))
}

// ServiceEndTimeIsNil applies the IsNil predicate on the "service_end_time" field.
func ServiceEndTimeIsNil() predicate.EbsVolume {
	return predicate.EbsVolume(sql.FieldIsNull(FieldServiceEndTime))
}

// ServiceEndTimeNotNil applies the NotNil predicate on the "service_end_time" field.
func ServiceEndTimeNotNil() predicate.EbsVolume {
	return predicate.EbsVolume(sql.FieldNotNull(FieldServiceEndTime))
}

// DeletedEQ applies the EQ predicate on the "deleted" field.
func DeletedEQ(v bool) predicate.EbsVolume {
	return predicate.EbsVolume(sql.FieldEQ(FieldDeleted, v))
}

// DeletedNEQ applies the NEQ predicate on the "deleted" field.
func DeletedNEQ(v bool) predicate.EbsVolume {
	return predicate.EbsVolume(sql.FieldNEQ(FieldDeleted, v))
}

// DeletedIsNil applies the IsNil predicate on the "deleted" field.
func DeletedIsNil() predicate.EbsVolume {
	return predicate.EbsVolume(sql.FieldIsNull(FieldDeleted))
}

// DeletedNotNil applies the NotNil predicate on the "deleted" field.
func DeletedNotNil() predicate.EbsVolume {
	return predicate.EbsVolume(sql.FieldNotNull(FieldDeleted))
}

// And groups predicates with the AND operator between them.
func And(predicates ...predicate.EbsVolume) predicate.EbsVolume {
	return predicate.EbsVolume(func(s *sql.Selector) {
		s1 := s.Clone().SetP(nil)
		for _, p := range predicates {
			p(s1)
		}
		s.Where(s1.P())
	})
}

// Or groups predicates with the OR operator between them.
func Or(predicates ...predicate.EbsVolume) predicate.EbsVolume {
	return predicate.EbsVolume(func(s *sql.Selector) {
		s1 := s.Clone().SetP(nil)
		for i, p := range predicates {
			if i > 0 {
				s1.Or()
			}
			p(s1)
		}
		s.Where(s1.P())
	})
}

// Not applies the not operator on the given predicate.
func Not(p predicate.EbsVolume) predicate.EbsVolume {
	return predicate.EbsVolume(func(s *sql.Selector) {
		p(s.Not())
	})
}

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/data/ent/ebsvolume/ebsvolume.go
```golang
// Code generated by ent, DO NOT EDIT.

package ebsvolume

const (
	// Label holds the string label denoting the ebsvolume type in the database.
	Label = "ebs_volume"
	// FieldID holds the string denoting the id field in the database.
	FieldID = "id"
	// FieldGalaxy holds the string denoting the galaxy field in the database.
	FieldGalaxy = "galaxy"
	// FieldRegion holds the string denoting the region field in the database.
	FieldRegion = "region"
	// FieldAz holds the string denoting the az field in the database.
	FieldAz = "az"
	// FieldCreatedAt holds the string denoting the created_at field in the database.
	FieldCreatedAt = "created_at"
	// FieldUpdatedAt holds the string denoting the updated_at field in the database.
	FieldUpdatedAt = "updated_at"
	// FieldVersion holds the string denoting the version field in the database.
	FieldVersion = "version"
	// FieldVolumeID holds the string denoting the volume_id field in the database.
	FieldVolumeID = "volume_id"
	// FieldName holds the string denoting the name field in the database.
	FieldName = "name"
	// FieldPoolID holds the string denoting the pool_id field in the database.
	FieldPoolID = "pool_id"
	// FieldPoolName holds the string denoting the pool_name field in the database.
	FieldPoolName = "pool_name"
	// FieldSize holds the string denoting the size field in the database.
	FieldSize = "size"
	// FieldStatus holds the string denoting the status field in the database.
	FieldStatus = "status"
	// FieldStatusName holds the string denoting the status_name field in the database.
	FieldStatusName = "status_name"
	// FieldVolumeType holds the string denoting the volume_type field in the database.
	FieldVolumeType = "volume_type"
	// FieldVMID holds the string denoting the vm_id field in the database.
	FieldVMID = "vm_id"
	// FieldVMName holds the string denoting the vm_name field in the database.
	FieldVMName = "vm_name"
	// FieldTenantID holds the string denoting the tenant_id field in the database.
	FieldTenantID = "tenant_id"
	// FieldTenantName holds the string denoting the tenant_name field in the database.
	FieldTenantName = "tenant_name"
	// FieldProjectID holds the string denoting the project_id field in the database.
	FieldProjectID = "project_id"
	// FieldProjectName holds the string denoting the project_name field in the database.
	FieldProjectName = "project_name"
	// FieldCreateTime holds the string denoting the create_time field in the database.
	FieldCreateTime = "create_time"
	// FieldServiceEndTime holds the string denoting the service_end_time field in the database.
	FieldServiceEndTime = "service_end_time"
	// FieldDeleted holds the string denoting the deleted field in the database.
	FieldDeleted = "deleted"
	// Table holds the table name of the ebsvolume in the database.
	Table = "ebs_volume"
)

// Columns holds all SQL columns for ebsvolume fields.
var Columns = []string{
	FieldID,
	FieldGalaxy,
	FieldRegion,
	FieldAz,
	FieldCreatedAt,
	FieldUpdatedAt,
	FieldVersion,
	FieldVolumeID,
	FieldName,
	FieldPoolID,
	FieldPoolName,
	FieldSize,
	FieldStatus,
	FieldStatusName,
	FieldVolumeType,
	FieldVMID,
	FieldVMName,
	FieldTenantID,
	FieldTenantName,
	FieldProjectID,
	FieldProjectName,
	FieldCreateTime,
	FieldServiceEndTime,
	FieldDeleted,
}

// ValidColumn reports if the column name is valid (part of the table columns).
func ValidColumn(column string) bool {
	for i := range Columns {
		if column == Columns[i] {
			return true
		}
	}
	return false
}

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/data/ent/schema/objectstorage_bucket.go
```golang
// Code generated by entimport, DO NOT EDIT.

package schema

import (
	"entgo.io/ent"
	"entgo.io/ent/dialect/entsql"
	"entgo.io/ent/schema"
	"entgo.io/ent/schema/field"
)

type ObjectstorageBucket struct {
	ent.Schema
}

func (ObjectstorageBucket) Fields() []ent.Field {
	return []ent.Field{field.Uint64("id"), field.Time("created_at").Optional(), field.Time("updated_at").Optional(), field.String("version").Optional(), field.String("galaxy").Optional(), field.String("region").Optional(), field.Bool("deleted").Optional().Comment("是否删除"), field.Int("bucket_id"), field.String("name"), field.String("tenant_id").Comment("租户id"), field.String("tenant_name").Optional().Comment("租户名"), field.String("project_id").Comment("项目id"), field.String("project_name").Comment("项目名称"), field.String("storageclass").Optional().Comment("存储类型"), field.String("storageclass_name").Optional().Comment("存储类型名称"), field.String("inner_endpoint").Comment("内网Endpoint"), field.String("outer_endpoint").Comment("外网Endpoint"), field.String("inner_domain").Optional().Comment("内网域名"), field.String("outer_domain").Optional().Comment("外网域名"), field.String("pool_id").Optional().Comment("资源池id"), field.String("pool_name").Optional().Comment("资源池名称"), field.Int("total_storage").Optional().Comment("总存储量"), field.Int("add_storage").Optional().Comment("新增使用量"), field.Int("delete_storage").Optional().Comment("删除量"), field.Int("total_object").Optional().Comment("总文件数"), field.Int("add_object").Optional().Comment("新增上传文件数"), field.Int("delete_object").Optional().Comment("新增删除文件数"), field.Int("download_flow").Optional().Comment("下载量"), field.Int("upload_flow").Optional().Comment("上传量"), field.Int("request_amount").Optional().Comment("API请求次数"), field.Int("download_flow_month").Comment("近30天总下载量"), field.Int("upload_flow_month").Comment("近30天总上传量"), field.Int("request_amount_month").Comment("近30天总API请求次数"), field.Time("create_time").Optional().Comment("bucket的创建时间")}
}
func (ObjectstorageBucket) Edges() []ent.Edge {
	return nil
}
func (ObjectstorageBucket) Annotations() []schema.Annotation {
	return []schema.Annotation{entsql.Annotation{Table: "objectstorage_bucket"}}
}

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/data/ent/schema/object_storage.go
```golang
// Code generated by entimport, DO NOT EDIT.

package schema

import (
	"entgo.io/ent"
	"entgo.io/ent/dialect/entsql"
	"entgo.io/ent/schema"
	"entgo.io/ent/schema/field"
)

type ObjectStorage struct {
	ent.Schema
}

func (ObjectStorage) Fields() []ent.Field {
	return []ent.Field{field.String("id"), field.String("name").Optional(), field.Int("size").Optional(), field.String("storage_type").Optional(), field.String("region").Optional(), field.String("region_code").Optional(), field.String("az").Optional(), field.String("az_code").Optional(), field.String("tenant_id").Optional(), field.String("tenant_name").Optional(), field.String("inner_domain_name").Optional(), field.String("outer_domain_name").Optional(), field.Int("create_time").Optional(), field.String("policy").Optional(), field.String("bucket_domains").Optional(), field.Int("resource_pool_id").Optional(), field.String("resource_pool_name").Optional(), field.Int("object_count").Optional(), field.Int("current_size").Optional(), field.Int("last30_day_download").Optional(), field.Int("last30_day_api_call_times").Optional(), field.Time("last_update_time")}

}
func (ObjectStorage) Edges() []ent.Edge {
	return nil
}
func (ObjectStorage) Annotations() []schema.Annotation {
	return []schema.Annotation{entsql.Annotation{Table: "object_storage"}}
}

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/data/ent/schema/block_storage.go
```golang
// Code generated by entimport, DO NOT EDIT.

package schema

import (
	"entgo.io/ent"
	"entgo.io/ent/dialect/entsql"
	"entgo.io/ent/schema"
	"entgo.io/ent/schema/field"
)

type BlockStorage struct {
	ent.Schema
}

func (BlockStorage) Fields() []ent.Field {
	return []ent.Field{field.Int("id"), field.String("name"), field.String("instance_id").Unique(), field.String("region"), field.String("region_code"), field.String("az"), field.String("az_code"), field.String("resource_pool"), field.String("resource_pool_type"), field.String("use_status"), field.String("tenant_id"), field.String("tenant_name"), field.String("vm"), field.String("vm_id"), field.Int("create_time"), field.Int32("size"), field.String("mount_point"), field.Time("last_update_time")}
}
func (BlockStorage) Edges() []ent.Edge {
	return nil
}
func (BlockStorage) Annotations() []schema.Annotation {
	return []schema.Annotation{entsql.Annotation{Table: "block_storage"}}
}

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/data/ent/schema/ebs_volume.go
```golang
// Code generated by entimport, DO NOT EDIT.

package schema

import (
	"entgo.io/ent"
	"entgo.io/ent/dialect/entsql"
	"entgo.io/ent/schema"
	"entgo.io/ent/schema/field"
)

type EbsVolume struct {
	ent.Schema
}

func (EbsVolume) Fields() []ent.Field {
	return []ent.Field{field.Int("id"), field.String("galaxy").Optional(), field.String("region").Comment("区域编码"), field.String("az").Optional(), field.Time("created_at").Optional().Comment("数据创建时间"), field.Time("updated_at"), field.String("version").Optional(), field.String("volume_id").Optional(), field.String("name").Comment("云硬盘名称"), field.String("pool_id").Optional(), field.String("pool_name").Optional().Comment("资源池名称"), field.Int32("size").Optional(), field.String("status").Optional().Comment("使用状态"), field.String("status_name").Optional(), field.String("volume_type").Optional(), field.String("vm_id").Comment("虚机id"), field.String("vm_name").Comment("虚机名"), field.String("tenant_id").Optional().Comment("租户id"), field.String("tenant_name").Optional().Comment("租户名"), field.String("project_id").Comment("项目id"), field.String("project_name").Comment("项目名称"), field.Time("create_time").Optional().Comment("云硬盘创建时间"), field.Time("service_end_time").Optional(), field.Bool("deleted").Optional().Comment("0 正常 1 删除")}
}
func (EbsVolume) Edges() []ent.Edge {
	return nil
}
func (EbsVolume) Annotations() []schema.Annotation {
	return []schema.Annotation{entsql.Annotation{Table: "ebs_volume"}}
}

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/data/ent/migrate/schema.go
```golang
// Code generated by ent, DO NOT EDIT.

package migrate

import (
	"entgo.io/ent/dialect/entsql"
	"entgo.io/ent/dialect/sql/schema"
	"entgo.io/ent/schema/field"
)

var (
	// BlockStorageColumns holds the columns for the "block_storage" table.
	BlockStorageColumns = []*schema.Column{
		{Name: "id", Type: field.TypeInt, Increment: true},
		{Name: "name", Type: field.TypeString},
		{Name: "instance_id", Type: field.TypeString, Unique: true},
		{Name: "region", Type: field.TypeString},
		{Name: "region_code", Type: field.TypeString},
		{Name: "az", Type: field.TypeString},
		{Name: "az_code", Type: field.TypeString},
		{Name: "resource_pool", Type: field.TypeString},
		{Name: "resource_pool_type", Type: field.TypeString},
		{Name: "use_status", Type: field.TypeString},
		{Name: "tenant_id", Type: field.TypeString},
		{Name: "tenant_name", Type: field.TypeString},
		{Name: "vm", Type: field.TypeString},
		{Name: "vm_id", Type: field.TypeString},
		{Name: "create_time", Type: field.TypeInt},
		{Name: "size", Type: field.TypeInt32},
		{Name: "mount_point", Type: field.TypeString},
		{Name: "last_update_time", Type: field.TypeTime},
	}
	// BlockStorageTable holds the schema information for the "block_storage" table.
	BlockStorageTable = &schema.Table{
		Name:       "block_storage",
		Columns:    BlockStorageColumns,
		PrimaryKey: []*schema.Column{BlockStorageColumns[0]},
	}
	// EbsVolumeColumns holds the columns for the "ebs_volume" table.
	EbsVolumeColumns = []*schema.Column{
		{Name: "id", Type: field.TypeInt, Increment: true},
		{Name: "galaxy", Type: field.TypeString, Nullable: true},
		{Name: "region", Type: field.TypeString},
		{Name: "az", Type: field.TypeString, Nullable: true},
		{Name: "created_at", Type: field.TypeTime, Nullable: true},
		{Name: "updated_at", Type: field.TypeTime},
		{Name: "version", Type: field.TypeString, Nullable: true},
		{Name: "volume_id", Type: field.TypeString, Nullable: true},
		{Name: "name", Type: field.TypeString},
		{Name: "pool_id", Type: field.TypeString, Nullable: true},
		{Name: "pool_name", Type: field.TypeString, Nullable: true},
		{Name: "size", Type: field.TypeInt32, Nullable: true},
		{Name: "status", Type: field.TypeString, Nullable: true},
		{Name: "status_name", Type: field.TypeString, Nullable: true},
		{Name: "volume_type", Type: field.TypeString, Nullable: true},
		{Name: "vm_id", Type: field.TypeString},
		{Name: "vm_name", Type: field.TypeString},
		{Name: "tenant_id", Type: field.TypeString, Nullable: true},
		{Name: "tenant_name", Type: field.TypeString, Nullable: true},
		{Name: "project_id", Type: field.TypeString},
		{Name: "project_name", Type: field.TypeString},
		{Name: "create_time", Type: field.TypeTime, Nullable: true},
		{Name: "service_end_time", Type: field.TypeTime, Nullable: true},
		{Name: "deleted", Type: field.TypeBool, Nullable: true},
	}
	// EbsVolumeTable holds the schema information for the "ebs_volume" table.
	EbsVolumeTable = &schema.Table{
		Name:       "ebs_volume",
		Columns:    EbsVolumeColumns,
		PrimaryKey: []*schema.Column{EbsVolumeColumns[0]},
	}
	// ObjectStorageColumns holds the columns for the "object_storage" table.
	ObjectStorageColumns = []*schema.Column{
		{Name: "id", Type: field.TypeString},
		{Name: "name", Type: field.TypeString, Nullable: true},
		{Name: "size", Type: field.TypeInt, Nullable: true},
		{Name: "storage_type", Type: field.TypeString, Nullable: true},
		{Name: "region", Type: field.TypeString, Nullable: true},
		{Name: "region_code", Type: field.TypeString, Nullable: true},
		{Name: "az", Type: field.TypeString, Nullable: true},
		{Name: "az_code", Type: field.TypeString, Nullable: true},
		{Name: "tenant_id", Type: field.TypeString, Nullable: true},
		{Name: "tenant_name", Type: field.TypeString, Nullable: true},
		{Name: "inner_domain_name", Type: field.TypeString, Nullable: true},
		{Name: "outer_domain_name", Type: field.TypeString, Nullable: true},
		{Name: "create_time", Type: field.TypeInt, Nullable: true},
		{Name: "policy", Type: field.TypeString, Nullable: true},
		{Name: "bucket_domains", Type: field.TypeString, Nullable: true},
		{Name: "resource_pool_id", Type: field.TypeInt, Nullable: true},
		{Name: "resource_pool_name", Type: field.TypeString, Nullable: true},
		{Name: "object_count", Type: field.TypeInt, Nullable: true},
		{Name: "current_size", Type: field.TypeInt, Nullable: true},
		{Name: "last30_day_download", Type: field.TypeInt, Nullable: true},
		{Name: "last30_day_api_call_times", Type: field.TypeInt, Nullable: true},
		{Name: "last_update_time", Type: field.TypeTime},
	}
	// ObjectStorageTable holds the schema information for the "object_storage" table.
	ObjectStorageTable = &schema.Table{
		Name:       "object_storage",
		Columns:    ObjectStorageColumns,
		PrimaryKey: []*schema.Column{ObjectStorageColumns[0]},
	}
	// ObjectstorageBucketColumns holds the columns for the "objectstorage_bucket" table.
	ObjectstorageBucketColumns = []*schema.Column{
		{Name: "id", Type: field.TypeUint64, Increment: true},
		{Name: "created_at", Type: field.TypeTime, Nullable: true},
		{Name: "updated_at", Type: field.TypeTime, Nullable: true},
		{Name: "version", Type: field.TypeString, Nullable: true},
		{Name: "galaxy", Type: field.TypeString, Nullable: true},
		{Name: "region", Type: field.TypeString, Nullable: true},
		{Name: "deleted", Type: field.TypeBool, Nullable: true},
		{Name: "bucket_id", Type: field.TypeInt},
		{Name: "name", Type: field.TypeString},
		{Name: "tenant_id", Type: field.TypeString},
		{Name: "tenant_name", Type: field.TypeString, Nullable: true},
		{Name: "project_id", Type: field.TypeString},
		{Name: "project_name", Type: field.TypeString},
		{Name: "storageclass", Type: field.TypeString, Nullable: true},
		{Name: "storageclass_name", Type: field.TypeString, Nullable: true},
		{Name: "inner_endpoint", Type: field.TypeString},
		{Name: "outer_endpoint", Type: field.TypeString},
		{Name: "inner_domain", Type: field.TypeString, Nullable: true},
		{Name: "outer_domain", Type: field.TypeString, Nullable: true},
		{Name: "pool_id", Type: field.TypeString, Nullable: true},
		{Name: "pool_name", Type: field.TypeString, Nullable: true},
		{Name: "total_storage", Type: field.TypeInt, Nullable: true},
		{Name: "add_storage", Type: field.TypeInt, Nullable: true},
		{Name: "delete_storage", Type: field.TypeInt, Nullable: true},
		{Name: "total_object", Type: field.TypeInt, Nullable: true},
		{Name: "add_object", Type: field.TypeInt, Nullable: true},
		{Name: "delete_object", Type: field.TypeInt, Nullable: true},
		{Name: "download_flow", Type: field.TypeInt, Nullable: true},
		{Name: "upload_flow", Type: field.TypeInt, Nullable: true},
		{Name: "request_amount", Type: field.TypeInt, Nullable: true},
		{Name: "download_flow_month", Type: field.TypeInt},
		{Name: "upload_flow_month", Type: field.TypeInt},
		{Name: "request_amount_month", Type: field.TypeInt},
		{Name: "create_time", Type: field.TypeTime, Nullable: true},
	}
	// ObjectstorageBucketTable holds the schema information for the "objectstorage_bucket" table.
	ObjectstorageBucketTable = &schema.Table{
		Name:       "objectstorage_bucket",
		Columns:    ObjectstorageBucketColumns,
		PrimaryKey: []*schema.Column{ObjectstorageBucketColumns[0]},
	}
	// Tables holds all the tables in the schema.
	Tables = []*schema.Table{
		BlockStorageTable,
		EbsVolumeTable,
		ObjectStorageTable,
		ObjectstorageBucketTable,
	}
)

func init() {
	BlockStorageTable.Annotation = &entsql.Annotation{
		Table: "block_storage",
	}
	EbsVolumeTable.Annotation = &entsql.Annotation{
		Table: "ebs_volume",
	}
	ObjectStorageTable.Annotation = &entsql.Annotation{
		Table: "object_storage",
	}
	ObjectstorageBucketTable.Annotation = &entsql.Annotation{
		Table: "objectstorage_bucket",
	}
}

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/data/ent/migrate/migrate.go
```golang
// Code generated by ent, DO NOT EDIT.

package migrate

import (
	"context"
	"fmt"
	"io"

	"entgo.io/ent/dialect"
	"entgo.io/ent/dialect/sql/schema"
)

var (
	// WithGlobalUniqueID sets the universal ids options to the migration.
	// If this option is enabled, ent migration will allocate a 1<<32 range
	// for the ids of each entity (table).
	// Note that this option cannot be applied on tables that already exist.
	WithGlobalUniqueID = schema.WithGlobalUniqueID
	// WithDropColumn sets the drop column option to the migration.
	// If this option is enabled, ent migration will drop old columns
	// that were used for both fields and edges. This defaults to false.
	WithDropColumn = schema.WithDropColumn
	// WithDropIndex sets the drop index option to the migration.
	// If this option is enabled, ent migration will drop old indexes
	// that were defined in the schema. This defaults to false.
	// Note that unique constraints are defined using `UNIQUE INDEX`,
	// and therefore, it's recommended to enable this option to get more
	// flexibility in the schema changes.
	WithDropIndex = schema.WithDropIndex
	// WithForeignKeys enables creating foreign-key in schema DDL. This defaults to true.
	WithForeignKeys = schema.WithForeignKeys
)

// Schema is the API for creating, migrating and dropping a schema.
type Schema struct {
	drv dialect.Driver
}

// NewSchema creates a new schema client.
func NewSchema(drv dialect.Driver) *Schema { return &Schema{drv: drv} }

// Create creates all schema resources.
func (s *Schema) Create(ctx context.Context, opts ...schema.MigrateOption) error {
	return Create(ctx, s, Tables, opts...)
}

// Create creates all table resources using the given schema driver.
func Create(ctx context.Context, s *Schema, tables []*schema.Table, opts ...schema.MigrateOption) error {
	migrate, err := schema.NewMigrate(s.drv, opts...)
	if err != nil {
		return fmt.Errorf("ent/migrate: %w", err)
	}
	return migrate.Create(ctx, tables...)
}

// WriteTo writes the schema changes to w instead of running them against the database.
//
//	if err := client.Schema.WriteTo(context.Background(), os.Stdout); err != nil {
//		log.Fatal(err)
//	}
func (s *Schema) WriteTo(ctx context.Context, w io.Writer, opts ...schema.MigrateOption) error {
	return Create(ctx, &Schema{drv: &schema.WriteDriver{Writer: w, Driver: s.drv}}, Tables, opts...)
}

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/data/ent/hook/hook.go
```golang
// Code generated by ent, DO NOT EDIT.

package hook

import (
	"context"
	"fmt"
	"luban-cmdb-api/data/ent"
)

// The BlockStorageFunc type is an adapter to allow the use of ordinary
// function as BlockStorage mutator.
type BlockStorageFunc func(context.Context, *ent.BlockStorageMutation) (ent.Value, error)

// Mutate calls f(ctx, m).
func (f BlockStorageFunc) Mutate(ctx context.Context, m ent.Mutation) (ent.Value, error) {
	if mv, ok := m.(*ent.BlockStorageMutation); ok {
		return f(ctx, mv)
	}
	return nil, fmt.Errorf("unexpected mutation type %T. expect *ent.BlockStorageMutation", m)
}

// The EbsVolumeFunc type is an adapter to allow the use of ordinary
// function as EbsVolume mutator.
type EbsVolumeFunc func(context.Context, *ent.EbsVolumeMutation) (ent.Value, error)

// Mutate calls f(ctx, m).
func (f EbsVolumeFunc) Mutate(ctx context.Context, m ent.Mutation) (ent.Value, error) {
	if mv, ok := m.(*ent.EbsVolumeMutation); ok {
		return f(ctx, mv)
	}
	return nil, fmt.Errorf("unexpected mutation type %T. expect *ent.EbsVolumeMutation", m)
}

// The ObjectStorageFunc type is an adapter to allow the use of ordinary
// function as ObjectStorage mutator.
type ObjectStorageFunc func(context.Context, *ent.ObjectStorageMutation) (ent.Value, error)

// Mutate calls f(ctx, m).
func (f ObjectStorageFunc) Mutate(ctx context.Context, m ent.Mutation) (ent.Value, error) {
	if mv, ok := m.(*ent.ObjectStorageMutation); ok {
		return f(ctx, mv)
	}
	return nil, fmt.Errorf("unexpected mutation type %T. expect *ent.ObjectStorageMutation", m)
}

// The ObjectstorageBucketFunc type is an adapter to allow the use of ordinary
// function as ObjectstorageBucket mutator.
type ObjectstorageBucketFunc func(context.Context, *ent.ObjectstorageBucketMutation) (ent.Value, error)

// Mutate calls f(ctx, m).
func (f ObjectstorageBucketFunc) Mutate(ctx context.Context, m ent.Mutation) (ent.Value, error) {
	if mv, ok := m.(*ent.ObjectstorageBucketMutation); ok {
		return f(ctx, mv)
	}
	return nil, fmt.Errorf("unexpected mutation type %T. expect *ent.ObjectstorageBucketMutation", m)
}

// Condition is a hook condition function.
type Condition func(context.Context, ent.Mutation) bool

// And groups conditions with the AND operator.
func And(first, second Condition, rest ...Condition) Condition {
	return func(ctx context.Context, m ent.Mutation) bool {
		if !first(ctx, m) || !second(ctx, m) {
			return false
		}
		for _, cond := range rest {
			if !cond(ctx, m) {
				return false
			}
		}
		return true
	}
}

// Or groups conditions with the OR operator.
func Or(first, second Condition, rest ...Condition) Condition {
	return func(ctx context.Context, m ent.Mutation) bool {
		if first(ctx, m) || second(ctx, m) {
			return true
		}
		for _, cond := range rest {
			if cond(ctx, m) {
				return true
			}
		}
		return false
	}
}

// Not negates a given condition.
func Not(cond Condition) Condition {
	return func(ctx context.Context, m ent.Mutation) bool {
		return !cond(ctx, m)
	}
}

// HasOp is a condition testing mutation operation.
func HasOp(op ent.Op) Condition {
	return func(_ context.Context, m ent.Mutation) bool {
		return m.Op().Is(op)
	}
}

// HasAddedFields is a condition validating `.AddedField` on fields.
func HasAddedFields(field string, fields ...string) Condition {
	return func(_ context.Context, m ent.Mutation) bool {
		if _, exists := m.AddedField(field); !exists {
			return false
		}
		for _, field := range fields {
			if _, exists := m.AddedField(field); !exists {
				return false
			}
		}
		return true
	}
}

// HasClearedFields is a condition validating `.FieldCleared` on fields.
func HasClearedFields(field string, fields ...string) Condition {
	return func(_ context.Context, m ent.Mutation) bool {
		if exists := m.FieldCleared(field); !exists {
			return false
		}
		for _, field := range fields {
			if exists := m.FieldCleared(field); !exists {
				return false
			}
		}
		return true
	}
}

// HasFields is a condition validating `.Field` on fields.
func HasFields(field string, fields ...string) Condition {
	return func(_ context.Context, m ent.Mutation) bool {
		if _, exists := m.Field(field); !exists {
			return false
		}
		for _, field := range fields {
			if _, exists := m.Field(field); !exists {
				return false
			}
		}
		return true
	}
}

// If executes the given hook under condition.
//
//	hook.If(ComputeAverage, And(HasFields(...), HasAddedFields(...)))
func If(hk ent.Hook, cond Condition) ent.Hook {
	return func(next ent.Mutator) ent.Mutator {
		return ent.MutateFunc(func(ctx context.Context, m ent.Mutation) (ent.Value, error) {
			if cond(ctx, m) {
				return hk(next).Mutate(ctx, m)
			}
			return next.Mutate(ctx, m)
		})
	}
}

// On executes the given hook only for the given operation.
//
//	hook.On(Log, ent.Delete|ent.Create)
func On(hk ent.Hook, op ent.Op) ent.Hook {
	return If(hk, HasOp(op))
}

// Unless skips the given hook only for the given operation.
//
//	hook.Unless(Log, ent.Update|ent.UpdateOne)
func Unless(hk ent.Hook, op ent.Op) ent.Hook {
	return If(hk, Not(HasOp(op)))
}

// FixedError is a hook returning a fixed error.
func FixedError(err error) ent.Hook {
	return func(ent.Mutator) ent.Mutator {
		return ent.MutateFunc(func(context.Context, ent.Mutation) (ent.Value, error) {
			return nil, err
		})
	}
}

// Reject returns a hook that rejects all operations that match op.
//
//	func (T) Hooks() []ent.Hook {
//		return []ent.Hook{
//			Reject(ent.Delete|ent.Update),
//		}
//	}
func Reject(op ent.Op) ent.Hook {
	hk := FixedError(fmt.Errorf("%s operation is not allowed", op))
	return On(hk, op)
}

// Chain acts as a list of hooks and is effectively immutable.
// Once created, it will always hold the same set of hooks in the same order.
type Chain struct {
	hooks []ent.Hook
}

// NewChain creates a new chain of hooks.
func NewChain(hooks ...ent.Hook) Chain {
	return Chain{append([]ent.Hook(nil), hooks...)}
}

// Hook chains the list of hooks and returns the final hook.
func (c Chain) Hook() ent.Hook {
	return func(mutator ent.Mutator) ent.Mutator {
		for i := len(c.hooks) - 1; i >= 0; i-- {
			mutator = c.hooks[i](mutator)
		}
		return mutator
	}
}

// Append extends a chain, adding the specified hook
// as the last ones in the mutation flow.
func (c Chain) Append(hooks ...ent.Hook) Chain {
	newHooks := make([]ent.Hook, 0, len(c.hooks)+len(hooks))
	newHooks = append(newHooks, c.hooks...)
	newHooks = append(newHooks, hooks...)
	return Chain{newHooks}
}

// Extend extends a chain, adding the specified chain
// as the last ones in the mutation flow.
func (c Chain) Extend(chain Chain) Chain {
	return c.Append(chain.hooks...)
}

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/pkg/handler/objectstorage-handler.go
```golang
package handler

import (
	"github.com/emicklei/go-restful"

	"luban-cmdb-api/pkg/models/storage"
)

type ObjectStorageBucketService interface {
	GetBucketList(r storage.BucketRequest) (*storage.ObjectStoragePoolBucket, error)
	GetBucketDetail(insId string) (*storage.BucketDetail, error)
}

type ObjectBucketHandler struct {
	ObjectStorageBucketService ObjectStorageBucketService
}

func NewObjectBucketHandler(osBucketService ObjectStorageBucketService) *ObjectBucketHandler {
	return &ObjectBucketHandler{
		ObjectStorageBucketService: osBucketService,
	}
}

func (o *ObjectBucketHandler) getBucketDataList(req *restful.Request, resp *restful.Response) {
	bucketRequest := storage.BucketRequest{
		Pagination: CommonPagination(req),
		Region:     req.QueryParameter("region"),
		Az:         req.QueryParameter("az"),
		Name:       req.QueryParameter("name"),
		Id:         req.QueryParameter("id"),
		TenantId:   req.QueryParameter("tenantId"),
		//StorageType:       req.QueryParameter("storageType"),
	}
	data, err := o.ObjectStorageBucketService.GetBucketList(bucketRequest)
	if err != nil {
		CommonServerInternalErrorHandler(req, resp, err)
		return
	}
	resp.WriteAsJson(data)
}

func (o *ObjectBucketHandler) getBucketDataDetail(req *restful.Request, resp *restful.Response) {
	insId := req.PathParameter("instanceId")
	data, err := o.ObjectStorageBucketService.GetBucketDetail(insId)
	if err != nil {
		CommonServerInternalErrorHandler(req, resp, err)
		return
	}
	resp.WriteAsJson(data)
}

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/pkg/handler/server-handler.go
```golang
package handler

import (
	"time"

	"github.com/emicklei/go-restful"
)

type PhysicalHostDataResult struct {
	RequestId string `json:"requestId"`
	PageStruct
	DataList []PhysicalHostData `json:"dataList"`
}

type PhysicalHostData struct {
	Name              string    `json:"name"`
	Id                string    `json:"id"`
	Runstatus         string    `json:"runstatus"`
	AssignmentStatus  string    `json:"assignmentStatus"`
	ResourcePoolType  string    `json:"resourcePoolType"`
	ResourcePool      string    `json:"resourcePool"`
	Service           string    `json:"service"`
	Region            string    `json:"region"`
	Az                string    `json:"az"`
	Lab               string    `json:"lab"`
	Cabinet           string    `json:"cabinet"`
	Unit              string    `json:"unit"`
	Sn                string    `json:"sn"`
	ManagementIP      string    `json:"managementIP"`
	OutbandIP         string    `json:"outbandIP"`
	Power             string    `json:"power"`
	UplinkSwitch      string    `json:"uplinkSwitch"`
	MaintenanceDue    string    `json:"maintenanceDue"`
	MaintenanceStatus string    `json:"maintenanceStatus"`
	Assetsnumber      string    `json:"assetsnumber"`
	InputMethod       string    `json:"inputMethod"`
	Description       string    `json:"description"`
	CreateTime        time.Time `json:"createTime"`
}

type CpuMessage struct {
	CpuType string `json:"cpuType"`
	CpuCore int32  `json:"cpuCore"`
	CpuRate string `json:"cpuRate"`
}

type MemoryMessage struct {
	MemoryType    string `json:"memoryType"`
	TotalCapacity int64  `json:"totalCapacity"`
}

type DiskMessage struct {
	DiskType      string `json:"diskType"`
	TotalCapacity int64  `json:"totalCapacity"`
	Count         int32  `json:"count"`
}

type RAIDMessage struct {
	RaidType string `json:"raidType"`
	Count    int32  `json:"count"`
}

type NetworkCardMessage struct {
	NetworkCardType string `json:"networkCardType"`
	Count           int32  `json:"count"`
}

type GPUMessage struct {
	GpuType string `json:"gpuType"`
	Count   int32  `json:"count"`
}

type BasicMessage struct {
	Name              string    `json:"name"`
	Id                string    `json:"id"`
	Runstatus         string    `json:"runstatus"`
	AssignmentStatus  string    `json:"assignmentStatus"`
	ResourcePoolType  string    `json:"resourcePoolType"`
	ResourcePool      string    `json:"resourcePool"`
	Service           string    `json:"service"`
	Region            string    `json:"region"`
	Az                string    `json:"az"`
	Lab               string    `json:"lab"`
	Cabinet           string    `json:"cabinet"`
	ServerType        string    `json:"serverType"`
	Sn                string    `json:"sn"`
	ManagementIP      string    `json:"managementIP"`
	OutbandIP         string    `json:"outbandIP"`
	MainMaintainer    string    `json:"mainMaintainer"`
	Power             string    `json:"power"`
	UplinkSwitch      string    `json:"uplinkSwitch"`
	MaintenanceDue    string    `json:"maintenanceDue"`
	MaintenanceStatus string    `json:"maintenanceStatus"`
	Assetsnumber      string    `json:"assetsnumber"`
	InputTime         string    `json:"inputTime"`
	InputMethod       string    `json:"inputMethod"`
	MacAddress        string    `json:"macAddress"`
	SystemSales       string    `json:"systemSales"`
	Description       string    `json:"description"`
	CreateTime        time.Time `json:"createTime"`
}

type physicalHostDetail struct {
	BasicMessage       BasicMessage         `json:"basicMessage"`
	CpuMessage         []CpuMessage         `json:"cpuMessage"`
	MemoryMessage      []MemoryMessage      `json:"memoryMessage"`
	DiskMessage        []DiskMessage        `json:"diskMessage"`
	RAIDMessage        []RAIDMessage        `json:"raidMessage"`
	NetworkCardMessage []NetworkCardMessage `json:"networkCardMessage"`
	GPUMessage         []GPUMessage         `json:"gpuMessage"`
}

type PhysicalHostResourceData struct {
	Name             string    `json:"name"`
	InstanceId       string    `json:"instanceId"`
	Standards        string    `json:"standards"`
	AssignmentStatus string    `json:"assignmentStatus"`
	ResourcePool     string    `json:"resourcePool"`
	Region           string    `json:"region"`
	Az               string    `json:"az"`
	System           string    `json:"system"`
	TenantId         string    `json:"tenantId"`
	IPAddress        string    `json:"ipAddress"`
	CreateTime       time.Time `json:"createTime"`
}

type PageStruct struct {
	TotalCount int32 `json:"totalCount"`
	PageNo     int32 `json:"pageNo"`
	PageSize   int32 `json:"pageSize"`
}

type PhysicalHostResourceResult struct {
	PageStruct
	DataList []PhysicalHostResourceData `json:"dataList"`
}

type PhysicalHostUpdate struct {
	RequestId string `json:"requestId"`
	ReturnIf  bool   `json:"returnIf"`
}

func getPhysicalHost(request *restful.Request, response *restful.Response) {
}
func updatePhysicalHost(request *restful.Request, response *restful.Response) {
}
func getPhysicalHostDetail(request *restful.Request, response *restful.Response) {
}
func getPhysicalHostResourceList(request *restful.Request, response *restful.Response) {
}

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/pkg/handler/cloudServer-handler.go
```golang
package handler

type VmList struct {
	RequestId string `json:"requestId"`
	Returns   VmRe   `json:"returns"`
}

type VmRe struct {
	Name        string `json:"name"`
	Id          string `json:"id"`
	Region      string `json:"region"`
	Az          string `json:"az"`
	Type        string `json:"type"`
	TenantId    string `json:"tenantId"`
	Host        string `json:"host"`
	ComputePool string `json:"computePool"`
	InnerIp     string `json:"innerIp"`
	OuterIp     string `json:"outerIp"`
	CreateTime  string `json:"createTime"`
	ReturnIf    bool   `json:"return"`
}

type VmDetail struct {
	InstanceId            string `json:"instanceId"`
	TenantId              string `json:"tenantId"`
	Aggregate             string `json:"aggregate"`
	Region                string `json:"region"`
	Az                    string `json:"az"`
	Host                  string `json:"host"`
	Business              string `json:"business"`
	OpsLabel              string `json:"opsLabel"`
	Label                 string `json:"label"`
	ImageId               string `json:"imageId"`
	DisasterTolerantGroup string `json:"disasterTolerantGroup"`
	AdminPass             string `json:"adminPass"`
	CreateTime            string `json:"create_time"`
	EndTime               string `json:"endTime"`
	DeleteTime            string `json:"deleteTime"`
	Type                  string `json:"type"`
	Size                  string `json:"size"`
	Os                    string `json:"os"`
	SysDisk               string `json:"sys_disk"`
	DataDisk              string `json:"data_disk"`
	INCId                 string `json:"incId"`
	EIp                   string `json:"eIp"`
	DNS1                  string `json:"dns1"`
	DNS2                  string `json:"dns2"`
	InternetIpV4          string `json:"internetIpv4"`
	SecurityGroup         string `json:"securityGroup"`
	VPC                   string `json:"vpc"`
	SubNetwork            string `json:"subNetwork"`
	InnerIp               string `json:"innerIp"`
}

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/pkg/handler/blockStoragePool-handler.go
```golang
package handler

import (
	"github.com/emicklei/go-restful"
)

type BlockStoragePoolList struct {
	RequestId string    `json:"requestId"`
	Returns   []BlockRe `json:"returns"`
}

type BlockRe struct {
	Name            string `json:"name"`
	Id              string `json:"id"`
	Region          string `json:"region"`
	Az              string `json:"az"`
	Type            string `json:"type"`
	Attribute       string `json:"attribute"`
	HostNumber      int    `json:"hostNumber"`
	CloudDiskNumber int    `json:"cloudDiskNumber"`
	ReturnIf        bool   `json:"return"`
}

type BlockStoragePoolDetail struct {
	Region      string `json:"region"`
	Zone        string `json:"zone"`
	Property    string `json:"property"`
	StorageType string `json:"storageType"`
	HostNumber  int    `json:"hostNumber"`
}

type BlockStoragePoolHost struct {
	RequestId string       `json:"requestId"`
	Returns   []HostDetail `json:"returns"`
}

type HostDetail struct {
	Name       string `json:"name"`
	State      string `json:"state"`
	Allocation bool   `json:"allocation"`
	PoolType   string `json:"poolType"`
	Pool       string `json:"pool"`
	Business   string `json:"business"`
	Region     string `json:"region"`
	Zone       string `json:"zone"`
	Rome       string `json:"rome"`
	Rack       string `json:"rack"`
	U          string `json:"u"`
	Sn         string `json:"sn"`
}

func getBlockList(request *restful.Request, response *restful.Response) {

}
func getOne(request *restful.Request, response *restful.Response) {

}

func getPoolHostList(request *restful.Request, response *restful.Response) {

}

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/pkg/handler/computeresourcepool-handler.go
```golang
package handler

import (
	"time"

	"github.com/emicklei/go-restful"
)

type ComputePoolResult struct {
	PageStruct
	DataList []ComputePoolData `json:"dataList"`
}

type ComputePoolData struct {
	Name         string `json:"name"`
	Id           string `json:"Id"`
	Service      string `json:"service"`
	ResourcePool string `json:"resourcePool"`
	Region       string `json:"region"`
	Az           string `json:"az"`
	HostNumber   string `json:"hostNumber"`
	VmNumber     string `json:"vmNumber"`
}

type ComputePoolStockDetail struct {
	Name         string  `json:"name"`
	Id           string  `json:"Id"`
	ResourcePool string  `json:"resourcePool"`
	Region       string  `json:"region"`
	Az           string  `json:"az"`
	Type         string  `json:"type"`
	UsableCount  int32   `json:"usableCount"`
	CpuTotal     int32   `json:"cpuTotal"`
	CpuUsage     int32   `json:"cpuUsage"`
	CpuRate      float64 `json:"cpuRate"`
	MemoryTotal  int32   `json:"memoryTotal"`
	MemoryUsage  int32   `json:"memoryUsage"`
	MemoryRate   float64 `json:"memoryRate"`
}

type ComputePoolStockDetailResult struct {
	PageStruct
	DataList []ComputePoolStockDetail `json:"dataList"`
}

type ComputePoolHostDetail struct {
	Name             string `json:"name"`
	Id               string `json:"id"`
	Runstatus        string `json:"runstatus"`
	AssignmentStatus string `json:"assignmentStatus"`
	ResourcePoolType string `json:"resourcePoolType"`
	ResourcePool     string `json:"resourcePool"`
	Service          string `json:"service"`
	Region           string `json:"region"`
	Az               string `json:"az"`
	Lab              string `json:"lab"`
	Cabinet          string `json:"cabinet"`
	Unit             string `json:"unit"`
	Sn               string `json:"sn"`
}

type ComputePoolHostDetailResult struct {
	PageStruct
	DataList []ComputePoolHostDetail `json:"dataList"`
}

type ComputePoolVmDetailData struct {
	Name             string    `json:"name"`
	InstanceId       string    `json:"instanceId"`
	Standards        string    `json:"standards"`
	AssignmentStatus string    `json:"assignmentStatus"`
	ResourcePool     string    `json:"resourcePool"`
	Region           string    `json:"region"`
	Az               string    `json:"az"`
	System           string    `json:"system"`
	TenantId         string    `json:"tenantId"`
	IPAddress        string    `json:"ipAddress"`
	CreateTime       time.Time `json:"createTime"`
}

type ComputePoolVmDetailResult struct {
	PageStruct
	DataList []ComputePoolVmDetailData `json:"dataList"`
}

func GetComputePoolList(request *restful.Request, response *restful.Response) {
}

func GetComputePoolDetail(request *restful.Request, response *restful.Response) {
}
func GetComputePoolStockDetail(request *restful.Request, response *restful.Response) {
}
func GetComputePoolHostDetail(request *restful.Request, response *restful.Response) {
}
func GetComputePoolVmDetail(request *restful.Request, response *restful.Response) {
}

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/pkg/handler/k8s-handler.go
```golang
package handler

import "github.com/emicklei/go-restful/v3"

func NewK8sService() *restful.WebService {
	ws := new(restful.WebService)
	ws.
		Path("/k8s").
		Consumes(restful.MIME_XML, restful.MIME_JSON).
		Produces(restful.MIME_JSON, restful.MIME_XML)
	return ws
}

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/pkg/handler/helpers.go
```golang
package handler

import (
	"strconv"

	"github.com/emicklei/go-restful"
	"k8s.io/klog/v2"

	"luban-cmdb-api/pkg/models/storage"
)

type ServerInternalErrorResp struct {
	Code int    `json:"code"`
	Msg  string `json:"msg"`
}

func CommonPagination(req *restful.Request) storage.Pagination {
	pageNo, err := strconv.Atoi(req.QueryParameter("pageNo"))
	if err != nil {
		pageNo = 1
	}
	pageSize, err := strconv.Atoi(req.QueryParameter("pageSize"))
	if err != nil {
		pageSize = 10
	}
	return storage.Pagination{
		PageNo:   pageNo,
		PageSize: pageSize,
	}
}

func CommonServerInternalErrorHandler(req *restful.Request, response *restful.Response, serverError error) {
	klog.Errorf("500 Error for request: %s error: %s", req.Request.URL, serverError)
	e := ServerInternalErrorResp{
		Code: 500,
		Msg:  serverError.Error(),
	}
	response.WriteHeaderAndEntity(500, e)
}

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/pkg/handler/main-handler.go
```golang
package handler

import (
	"github.com/emicklei/go-restful"
)

func AddToContainer(c *restful.Container) error {
	ws := NewMainService()
	c.Add(ws)
	return nil
}

func NewMainService() *restful.WebService {
	ws := new(restful.WebService)
	ws.
		Path("rest/cmdb/v1/instance").
		Consumes(restful.MIME_XML, restful.MIME_JSON).
		Produces(restful.MIME_JSON, restful.MIME_XML)
	//服务器
	// tag1 := []string{"physicalHost"}
	// ws.Route(ws.GET("/physicalHost").To(getPhysicalHost).
	// 	Doc("获取所有服务器的列表。").
	// 	Metadata(restfulspec.KeyOpenAPITags, tag1).
	// 	Param(ws.QueryParameter("pageNo", "eg:1,页码，默认值1。").DataType("int32").Required(false).DefaultValue("1")).
	// 	Param(ws.QueryParameter("pageSize", "eg:10, 页大小，默认值10。").DataType("int32").Required(false).DefaultValue("10")).
	// 	Param(ws.QueryParameter("contentSelector", "要返回的字段，默认返回所有字段，格式：[`attr1`,`attr2`]。").DataType("[]string").Required(false)).
	// 	Param(ws.QueryParameter("count", "eg:true, 是否统计实例数量，默认值true。值域：true,false").DataType("bool").Required(true).DefaultValue("true")).
	// 	Param(ws.QueryParameter("region", "区域;默认值：全部").DataType("string").Required(true).DefaultValue("全部")).
	// 	Param(ws.QueryParameter("az", "可用区;默认值：全部").DataType("string").Required(true).DefaultValue("全部")).
	// 	Param(ws.QueryParameter("lab", "机房;默认值：全部").DataType("string").Required(true).DefaultValue("全部")).
	// 	Param(ws.QueryParameter("name", "服务器名称").DataType("string").Required(false)).
	// 	Param(ws.QueryParameter("id", "服务器ID").DataType("string").Required(false)).
	// 	Param(ws.QueryParameter("ip", "服务器IP").DataType("string").Required(true)).
	// 	Param(ws.QueryParameter("sn", "服务器SN号").DataType("string").Required(true)).
	// 	Returns(200, "ok", PhysicalHostDataResult{}))
	// ws.Route(ws.GET("/physicalHostDetail/{instanceId}").To(getPhysicalHostDetail).
	// 	Doc("查询单个服务器的详情").
	// 	Metadata(restfulspec.KeyOpenAPITags, tag1).
	// 	Param(ws.PathParameter("instanceId", "服务器的唯一ID。").DataType("string").Required(true)).
	// 	Returns(200, "ok", physicalHostDetail{}))
	// ws.Route(ws.PUT("/physicalHost/{instanceId}").To(updatePhysicalHost).
	// 	Doc("修改服务器的详情").
	// 	Metadata(restfulspec.KeyOpenAPITags, tag1).
	// 	Param(ws.PathParameter("instanceId", "服务器的唯一ID。").DataType("string").Required(true)).
	// 	Param(ws.BodyParameter("room", "服务器所属房间").DataType("string")).
	// 	Param(ws.BodyParameter("cabinet", "服务器所属机柜").DataType("string")).
	// 	Param(ws.BodyParameter("rack", "服务器所属机架").DataType("string")).
	// 	Param(ws.BodyParameter("unit", "服务器所属U位").DataType("string")).
	// 	Param(ws.BodyParameter("managementIP", "服务器管理IP").DataType("string")).
	// 	Param(ws.BodyParameter("outbandIP", "服务器带外IP").DataType("string")).
	// 	Param(ws.BodyParameter("assetsnumber", "服务器的固定资产编号").DataType("string")).
	// 	Param(ws.BodyParameter("maintenanceDue", "服务器的维保到期时间").DataType("string")).
	// 	Param(ws.BodyParameter("label", "服务器运维标签").DataType("string")).
	// 	Returns(200, "ok", PhysicalHostUpdate{}))
	// ws.Route(ws.GET("/physicalHostResourceList/{instanceId}").To(getPhysicalHostResourceList).
	// 	Doc("查询单个服务器的云资源列表").
	// 	Metadata(restfulspec.KeyOpenAPITags, tag1).
	// 	Param(ws.PathParameter("instanceId", "服务器的唯一ID。").DataType("string").Required(true)).
	// 	Returns(200, "ok", PhysicalHostResourceResult{}))
	//计算资源池
	// tag2 := []string{"computePool"}
	// ws.Route(ws.GET("/computePool").To(GetComputePoolList).
	// 	Doc("获取计算资源池列表.").
	// 	Metadata(restfulspec.KeyOpenAPITags, tag2).
	// 	Param(ws.QueryParameter("pageNo", "eg:1,页码，默认值1。").DataType("int32").Required(false).DefaultValue("1")).
	// 	Param(ws.QueryParameter("pageSize", "eg:10, 页大小，默认值10。").DataType("int32").Required(false).DefaultValue("10")).
	// 	Param(ws.QueryParameter("contentSelector", "要返回的字段，默认返回所有字段，格式：[`attr1`,`attr2`]。").DataType("[]string").Required(false)).
	// 	Param(ws.QueryParameter("count", "eg:true, 是否统计实例数量，默认值true。值域：true,false").DataType("bool").Required(true).DefaultValue("true")).
	// 	Param(ws.QueryParameter("region", "区域;默认值：全部").DataType("string").Required(true).DefaultValue("全部")).
	// 	Param(ws.QueryParameter("az", "可用区;默认值：全部").DataType("string").Required(true).DefaultValue("全部")).
	// 	Param(ws.QueryParameter("name", "服务器名称").DataType("string").Required(false)).
	// 	Returns(200, "ok", ComputePoolResult{}))
	// ws.Route(ws.GET("/computePoolDetail/{instanceId}").To(GetComputePoolDetail).
	// 	Doc("查询单个计算资源池的资源详情").
	// 	Metadata(restfulspec.KeyOpenAPITags, tag2).
	// 	Param(ws.PathParameter("instanceId", "计算资源池的唯一ID。").DataType("string").Required(true)).
	// 	Returns(200, "ok", ComputePoolData{}))
	// ws.Route(ws.GET("/computePoolStockDetail/{instanceId}").To(GetComputePoolStockDetail).
	// 	Doc("查询单个计算资源池的库存详情").
	// 	Metadata(restfulspec.KeyOpenAPITags, tag2).
	// 	Param(ws.PathParameter("instanceId", "计算资源池的唯一ID。").DataType("string").Required(true)).
	// 	Returns(200, "ok", ComputePoolStockDetailResult{}))
	// ws.Route(ws.GET("/computePoolHostDetail/{instanceId}").To(GetComputePoolHostDetail).
	// 	Doc("查询单个计算资源池的服务器列表").
	// 	Metadata(restfulspec.KeyOpenAPITags, tag2).
	// 	Param(ws.PathParameter("instanceId", "计算资源池的唯一ID。").DataType("string").Required(true)).
	// 	Returns(200, "ok", ComputePoolHostDetailResult{}))
	// ws.Route(ws.GET("/computePoolVmDetail/{instanceId}").To(GetComputePoolVmDetail).
	// 	Doc("查询单个计算资源池的云主机列表").
	// 	Metadata(restfulspec.KeyOpenAPITags, tag2).
	// 	Param(ws.PathParameter("instanceId", "计算资源池的唯一ID。").DataType("string").Required(true)).
	// 	Returns(200, "ok", ComputePoolVmDetailResult{}))
	//块存储资源池
	// ws.Route(ws.GET("blockStoragePool").To(getBlockList).Doc("Get block storage resource pool list.").
	// 	Param(ws.BodyParameter("pageNo", "Page number. eg:`1`, default value: `1`, mix value: `1`").DataType("int32").Required(true)).
	// 	Param(ws.BodyParameter("pageSize", "Page size. eg:`10`, default value: `10`,").DataType("int32").Required(true)).
	// 	Param(ws.BodyParameter("contentSelector", "Return strings").DataType("string").Required(true)).
	// 	Param(ws.BodyParameter("count", "Whether").DataType("boolean").Required(true)).
	// 	Param(ws.BodyParameter("region", "region").DataType("string").Required(true)).
	// 	Param(ws.BodyParameter("az", "Available zone").DataType("string").Required(true)).
	// 	Param(ws.BodyParameter("name", "Resource pool name").DataType("string")).
	// 	Param(ws.BodyParameter("type", "Resource pool type").DataType("string").Required(true)).
	// 	Returns(200, "OK", BlockStoragePoolList{}))
	// ws.Route(ws.GET("blockStoragePoolDetail/{instanceId}").To(getOne).Doc("Get one pool detail.").
	// 	Param(ws.PathParameter("instanceId", "The id of block storage pool").DataType("string").Required(true)).
	// 	Returns(200, "OK", BlockStoragePoolDetail{}))
	// ws.Route(ws.GET("blockStoragePoolHostList/{instanceId}").To(getPoolHostList).
	// 	Doc("Get one pool host list/查询单个计算资源池的服务器列表").
	// 	Param(ws.PathParameter("instanceId", "The id of block storage pool").DataType("string").Required(true)).
	// 	Returns(200, "OK", storage.BlockStoragePoolStock{}))
	//对象资源池
	// ws.Route(ws.GET("objectStoragePool").To(getObjectList).Doc("Get block storage resource pool list.").
	// 	Param(ws.BodyParameter("pageNo", "Page number. eg:`1`, default value: `1`, mix value: `1`").DataType("int32").Required(true)).
	// 	Param(ws.BodyParameter("pageSize", "Page size. eg:`10`, default value: `10`,").DataType("int32").Required(true)).
	// 	Param(ws.BodyParameter("contentSelector", "Return strings").DataType("string").Required(true)).
	// 	Param(ws.BodyParameter("count", "Whether").DataType("boolean").Required(true)).
	// 	Param(ws.BodyParameter("region", "region").DataType("string").Required(true)).
	// 	Param(ws.BodyParameter("az", "Available zone").DataType("string").Required(true)).
	// 	Param(ws.BodyParameter("name", "Resource pool name").DataType("string")).
	// 	Param(ws.BodyParameter("type", "Resource pool type").DataType("string").Required(true)).
	// 	Returns(200, "OK", ObjectStoragePoolList{}))
	// ws.Route(ws.GET("objectStoragePoolResource/{instanceId}").To(getOne).Doc("Get one pool detail.").
	// 	Param(ws.PathParameter("instanceId", "The id of object storage pool").DataType("string").Required(true)).
	// 	Returns(200, "OK", ObjectStoragePoolDetail{}))
	// ws.Route(ws.GET("objectStoragePoolHost/{instanceId}").To(getPoolHostList).Doc("Get one pool host list").
	// 	Param(ws.PathParameter("instanceId", "The id of block storage pool").DataType("string").Required(true)).
	// 	Returns(200, "OK", ObjectStoragePoolHost{}))
	//云主机
	// ws.Route(ws.GET("vm").To(getObjectList).Doc("Get block storage resource pool list.").
	// 	Param(ws.BodyParameter("pageNo", "Page number. eg:`1`, default value: `1`, mix value: `1`").DataType("int32").Required(true)).
	// 	Param(ws.BodyParameter("pageSize", "Page size. eg:`10`, default value: `10`,").DataType("int32").Required(true)).
	// 	Param(ws.BodyParameter("contentSelector", "Return strings").DataType("string").Required(true)).
	// 	Param(ws.BodyParameter("count", "Whether").DataType("boolean").Required(true)).
	// 	Param(ws.BodyParameter("region", "region").DataType("string").Required(true)).
	// 	Param(ws.BodyParameter("az", "Available zone").DataType("string").Required(true)).
	// 	Param(ws.BodyParameter("name", "Resource pool name").DataType("string")).
	// 	Param(ws.BodyParameter("id", "Resource pool type").DataType("string").Required(true)).
	// 	Param(ws.BodyParameter("tenantId", "The id of tenant")).
	// 	Returns(200, "OK", VmList{}))
	// ws.Route(ws.GET("vm/{instanceId}").To(getOne).Doc("Get vm detail.").
	// 	Param(ws.PathParameter("instanceId", "The id of cloud host.").DataType("string").Required(true)).
	// 	Returns(200, "ok", VmDetail{}))
	return ws
}

type Success struct {
	Code    int         `json:"code"`
	Message string      `json:"message"`
	Data    interface{} `json:"data"`
}

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/pkg/handler/objectStoragePool-handler.go
```golang
package handler

import (
	"github.com/emicklei/go-restful"
)

type ObjectStoragePoolHost struct {
	RequestId string       `json:"requestId"`
	Returns   []HostDetail `json:"returns"`
}

func getObjectList(request *restful.Request, response *restful.Response) {

}

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/pkg/restfulapi/apicontainer.go
```golang
package restfulapi

import (
	"encoding/json"
	"fmt"
	"github.com/dgraph-io/dgo/v200"
	"github.com/emicklei/go-restful"
	restfulspec "github.com/emicklei/go-restful-openapi"
	"github.com/go-playground/validator/v10"
	"github.com/gophercloud/gophercloud"
	"github.com/hashicorp/go-multierror"
	mapstruct "github.com/mitchellh/mapstructure"
	"github.com/spf13/cast"
	"k8s.io/klog/v2"
	"luban-cmdb-api/pkg/apiserver/config"
	"luban-cmdb-api/pkg/runtime"
	"reflect"
	"strconv"
	"strings"
	"sync"
	"time"
)

type RestfulApiMethod int

const (
	ApiMethodGet RestfulApiMethod = iota
	ApiMethodPost
	ApiMethodPut
	ApiMethodDelete
	ApiMethodPatch
)

type ArgumentType int

const (
	UnknownArgumentType ArgumentType = iota
	QueryArgumentType
	PathArgumentType
	FormArgumentType
	BodyArgumentType
	HeaderArgumentType
)

type GlobalResponseData struct {
	Code    int         `json:"code" argDoc:"状态码"`
	Message string      `json:"message,omitempty" argDoc:"提示信息"`
	Data    interface{} `json:"data,omitempty" argDoc:"返回的数据"`
}

type ApiError struct {
	ErrorCode int
	Message   string
	ErrorData interface{}
}

type CommonParameter struct {
	Authorization string `json:"Authorization" argType:"header" argDoc:"header中的校验token"`
}

type PageQuery struct {
	Page int `json:"pageNo,omitempty" argType:"query" argDoc:"当前页码" default:"1"`
	Size int `json:"pageSize,omitempty" argType:"query" argDoc:"当前页码条数" default:"10"`
}

type PageQueryResult struct {
	PageQuery
	Total int `json:"total" argDoc:"总条数"`
}

type HandlerRegister interface {
	Init(server *ServerContext) error
	Register() []*ApiDefinition
	GroupName() string
}

type ServerContext struct {
	NovaClient     *gophercloud.ServiceClient
	DgraphClient   *dgo.Dgraph
	IdentityClient *gophercloud.ServiceClient
	Config         *config.Config
}

type ReturnDefinition struct {
	Code     int
	Message  string
	DataType interface{}
}

type ApiDefinition struct {
	Path       string
	Method     RestfulApiMethod
	Doc        string
	Tags       []string
	ReturnData interface{}
	Parameter  interface{}
	Handler    func(input interface{}, request *restful.Request, response *restful.Response) (interface{}, error) `validate:"required"`
}

type ArgumentDescribe struct {
	Name     string `validate:"required"`
	Type     string `validate:"required"`
	DataType string `validate:"required"`
	Doc      string `validate:"required"`
	Default  string
	Required bool
	Validate bool
	Source   reflect.StructField
}

func (argDesc *ArgumentDescribe) FieldName() string {
	return argDesc.Source.Name
}

func (argDesc *ArgumentDescribe) ResolveArgumentType() ArgumentType {
	switch strings.ToLower(argDesc.Type) {
	case "query":
		return QueryArgumentType
	case "form":
		return FormArgumentType
	case "path":
		return PathArgumentType
	case "body":
		return BodyArgumentType
	case "header":
		return HeaderArgumentType
	default:
		return UnknownArgumentType
	}
}

func (argDesc *ArgumentDescribe) setupArgument(ws *restful.WebService, route *restful.RouteBuilder) error {
	argumentType := argDesc.ResolveArgumentType()
	var param *restful.Parameter
	switch argumentType {
	case QueryArgumentType:
		param = ws.QueryParameter(argDesc.Name, argDesc.Doc)
		route.Param(param.DataType(argDesc.DataType).Required(argDesc.Required))
	case PathArgumentType:
		param = ws.PathParameter(argDesc.Name, argDesc.Doc)
		route.Param(param.DataType(argDesc.DataType).Required(argDesc.Required))
	case FormArgumentType:
		param = ws.FormParameter(argDesc.Name, argDesc.Doc)
		route.Param(param.DataType(argDesc.DataType).Required(argDesc.Required))
	case BodyArgumentType:
		if argDesc.SourceType().Kind() == reflect.Struct {
			param = ws.BodyParameter(argDesc.Name, argDesc.SourceDocument())
			route.Reads(argDesc.SourceInterface(), argDesc.SourceDocument())
		} else {
			return fmt.Errorf("body parameter must be struct. invalid argument: %s", argDesc.Name)
		}
	case HeaderArgumentType:
		param = ws.HeaderParameter(argDesc.Name, argDesc.Doc)
		route.Param(param.DataType(argDesc.DataType).Required(argDesc.Required))
	default:
		return fmt.Errorf("unsupported parameter type: %#v", argDesc)
	}
	return nil
}

func (argDesc *ArgumentDescribe) SourceType() reflect.Type {
	sourceType := argDesc.Source.Type
	if sourceType.Kind() == reflect.Ptr {
		sourceType = sourceType.Elem()
	}
	return sourceType
}

func (argDesc *ArgumentDescribe) SourceInterface() interface{} {
	sourceType := argDesc.SourceType()
	if sourceType.Kind() == reflect.Struct {
		return reflect.New(sourceType).Elem().Interface()
	}
	return nil
}

func (argDesc *ArgumentDescribe) SourceDocument() string {
	sourceType := argDesc.SourceType()
	return describeTypeDoc(sourceType, argDesc.Name, argDesc.Doc)
}

func describeTypeDoc(targetType reflect.Type, name string, doc string) string {
	if targetType.Kind() == reflect.Ptr {
		targetType = targetType.Elem()
	}
	if targetType.Kind() == reflect.Slice {
		return describeTypeDoc(targetType.Elem(), name, doc)
	} else if targetType.Kind() == reflect.Map {
		keyType := targetType.Key()
		valueType := targetType.Elem()
		var sliceDocs []string
		for _, t := range []reflect.Type{
			keyType, valueType,
		} {
			switch t.Kind() {
			case reflect.Struct, reflect.Map, reflect.Slice:
				sliceDocs = append(sliceDocs, describeTypeDoc(t, "", ""))
			}
		}
		return strings.Join(sliceDocs, "\n")
	}
	if targetType.Kind() != reflect.Struct {
		return fmt.Sprintf("%s: %s\t%s", name, describeTypeName(targetType), doc)
	}
	if targetType.AssignableTo(reflect.TypeOf(time.Time{})) {
		return fmt.Sprintf("%s: %s\t%s", name, "time", doc)
	}
	var structDocs []string
	var maxNameLen, maxTypeLen int
	totalFieldDesc, _ := resolveStruct(targetType)
	for _, item := range totalFieldDesc {
		nameLen := len(item.Name)
		typeLen := len(item.DataType)
		if maxNameLen < nameLen {
			maxNameLen = nameLen
		}
		if maxTypeLen < typeLen {
			maxTypeLen = typeLen
		}
	}
	formatStr := "%-" + strconv.Itoa(maxNameLen+4) + "s: %-" + strconv.Itoa(maxTypeLen+4) + "s\t%s"
	var innerStructDocs []string
	for _, fieldDesc := range totalFieldDesc {
		structDocs = append(structDocs, fmt.Sprintf(formatStr, fieldDesc.Name, fieldDesc.DataType, fieldDesc.Doc))
		switch fieldDesc.SourceType().Kind() {
		case reflect.Struct:
			innerStructDoc := describeTypeDoc(fieldDesc.SourceType(), "", "")
			innerStructDocs = append(innerStructDocs, fieldDesc.DataType+"\n"+innerStructDoc)
		case reflect.Slice:
			sliceValueType := fieldDesc.SourceType().Elem()
			if sliceValueType.Kind() == reflect.Ptr {
				sliceValueType = sliceValueType.Elem()
			}
			if sliceValueType.Kind() == reflect.Struct {
				valueDoc := describeTypeDoc(sliceValueType, fieldDesc.Name+".Type", "")
				innerStructDocs = append(innerStructDocs, fieldDesc.DataType+"\n"+valueDoc)
			}
		}
	}
	currentDoc := strings.Join(structDocs, "\n")
	return currentDoc + "\n\n" + strings.Join(innerStructDocs, "\n")
}

func buildStructDoc(targetStruct reflect.Type) string {
	descList, err := resolveStruct(targetStruct)
	if err != nil {
		return ""
	}
	var docList []string
	for _, item := range descList {
		docList = append(docList, item.SourceDocument())
	}
	return strings.Join(docList, "\n")
}

func resolveStruct(targetStruct reflect.Type) ([]*ArgumentDescribe, error) {
	if targetStruct.Kind() == reflect.Ptr {
		targetStruct = targetStruct.Elem()
	}
	if targetStruct.Kind() != reflect.Struct {
		return nil, fmt.Errorf("can't resolve target type: %s", targetStruct.Name())
	}
	var total []*ArgumentDescribe
	for i := 0; i < targetStruct.NumField(); i++ {
		total = append(total, resolveStructField(targetStruct.Field(i))...)
	}
	return total, nil
}

func describeTypeName(targetType reflect.Type) string {
	if targetType.Kind() == reflect.Ptr {
		return describeTypeName(targetType.Elem())
	}
	var dataType string
	switch targetType.Kind() {
	case reflect.Slice:
		dataType = "[]" + targetType.Elem().Name()
	case reflect.Map:
		dataType = "map[" + targetType.Key().Name() + "]" + targetType.Elem().Name()
	case reflect.Struct:
		if targetType.AssignableTo(reflect.TypeOf(time.Time{})) {
			return "time"
		}
		fallthrough
	default:
		dataType = targetType.Name()
	}
	return dataType
}

func resolveStructField(targetField reflect.StructField) []*ArgumentDescribe {
	var result []*ArgumentDescribe
	if targetField.Type.Kind() == reflect.Struct && targetField.Anonymous {
		embeddedFieldType := targetField.Type
		for i := 0; i < embeddedFieldType.NumField(); i++ {
			result = append(result, resolveStructField(embeddedFieldType.Field(i))...)
		}
		return result
	}
	if targetField.PkgPath != "" {
		return result
	}
	fieldTag := targetField.Tag
	if len(fieldTag) == 0 {
		return result
	}
	argName := fieldTag.Get("json")
	if argName == "" {
		argName = targetField.Name
	} else {
		argName = strings.Split(argName, ",")[0]
	}
	desc := &ArgumentDescribe{
		Name:     argName,
		Type:     fieldTag.Get("argType"),
		DataType: describeTypeName(targetField.Type),
		Doc:      fieldTag.Get("argDoc"),
		Required: fieldTag.Get("required") == "true",
		Default:  fieldTag.Get("default"),
		Validate: fieldTag.Get("validate") != "",
		Source:   targetField,
	}
	result = append(result, desc)
	return result
}

func (argDef *ApiDefinition) Validate() error {
	return validator.New().Struct(argDef)
}

func (argDef *ApiDefinition) resolveArgumentType() reflect.Type {
	argType := reflect.TypeOf(argDef.Parameter)
	if argType.Kind() == reflect.Ptr {
		argType = argType.Elem()
	}
	return argType
}

func (argDef *ApiDefinition) describeArgument() ([]*ArgumentDescribe, error) {
	var totalArgs []*ArgumentDescribe
	if argDef.Parameter == nil {
		return totalArgs, nil
	}
	argType := argDef.resolveArgumentType()
	if argType.Kind() == reflect.Struct {
		for fi := 0; fi < argType.NumField(); fi++ {
			fieldDesc := resolveStructField(argType.Field(fi))
			if fieldDesc == nil || len(fieldDesc) == 0 {
				continue
			}
			totalArgs = append(totalArgs, fieldDesc...)
		}
	} else {
		return nil, fmt.Errorf("api argument must be struct: %s", argType.Name())
	}
	return totalArgs, nil
}

func (argDef *ApiDefinition) buildRoute(ws *restful.WebService) (*restful.RouteBuilder, error) {
	var routeBuilder *restful.RouteBuilder
	switch argDef.Method {
	case ApiMethodGet:
		routeBuilder = ws.GET(argDef.Path)
	case ApiMethodPost:
		routeBuilder = ws.POST(argDef.Path)
	case ApiMethodPut:
		routeBuilder = ws.PUT(argDef.Path)
	case ApiMethodDelete:
		routeBuilder = ws.DELETE(argDef.Path)
	case ApiMethodPatch:
		routeBuilder = ws.PATCH(argDef.Path)
	default:
		return nil, fmt.Errorf("unsupported api method for path %s", argDef.Path)
	}
	routeBuilder.Doc(argDef.Doc).
		Metadata(restfulspec.KeyOpenAPITags, argDef.Tags)
	return routeBuilder, nil
}

func (argDef *ApiDefinition) NewArgumentInstance() interface{} {
	argumentType := argDef.resolveArgumentType()
	return reflect.Indirect(reflect.New(argumentType)).Interface()
}

type restfulApiContainer struct {
	apiRegisters []HandlerRegister
	context      *ServerContext
	lock         sync.Mutex
}

type restfulHandler struct {
	apiDef     *ApiDefinition
	parameters []*ArgumentDescribe
}

func (rh *restfulHandler) RouteHandler(request *restful.Request, response *restful.Response) {
	responseData := GlobalResponseData{
		Code:    200,
		Message: "Success",
	}
	result, err := rh.Handler(request, response)
	if err != nil {
		klog.Errorf("can't handler request with error: %s", err)
		responseData.Code = 500
		responseData.Message = err.Error()
	}
	responseData.Data = result
	err = response.WriteAsJson(responseData)
	if err != nil {
		klog.Errorf("can't write response json, Error: %s", err)
	}
}

func getKind(val reflect.Type) reflect.Kind {
	kind := val.Kind()
	switch {
	case kind >= reflect.Int && kind <= reflect.Int64:
		return reflect.Int
	case kind >= reflect.Uint && kind <= reflect.Uint64:
		return reflect.Uint
	case kind >= reflect.Float32 && kind <= reflect.Float64:
		return reflect.Float32
	default:
		return kind
	}
}

func copyData(input interface{}, output interface{}, useTag string) error {
	outputType := reflect.TypeOf(output)
	if outputType.Kind() != reflect.Ptr {
		return fmt.Errorf("output must be pointer, but found %s", outputType.Name())
	}
	conf := &mapstruct.DecoderConfig{
		Result:   output,
		Metadata: nil,
		Squash:   true,
	}
	if useTag != "" {
		conf.TagName = useTag
	}
	decoder, err := mapstruct.NewDecoder(conf)

	if err != nil {
		return multierror.Append(fmt.Errorf("can't build decoder to conver type from %s to %s",
			reflect.TypeOf(input).Name(), outputType.Name()), err)
	}
	err = decoder.Decode(input)
	if err != nil {
		return multierror.Append(fmt.Errorf("can't set value from %s to %s",
			reflect.TypeOf(input).Name(), outputType.Name()), err)
	}
	return nil
}

func convert(value interface{}, targetType reflect.Type) (interface{}, error) {
	switch getKind(targetType) {
	case reflect.Int:
		return cast.ToInt(value), nil
	case reflect.Float32:
		return cast.ToFloat32(value), nil
	case reflect.Uint:
		return cast.ToUint64(value), nil
	case reflect.String:
		return cast.ToStringE(value)
	case reflect.Slice:
		valueType := targetType.Elem()
		switch getKind(valueType) {
		case reflect.Int:
			valueStrSlice := cast.ToStringSlice(value)
			return cast.ToIntSlice(valueStrSlice), nil
		case reflect.Bool:
			valueStrSlice := cast.ToStringSlice(value)
			return cast.ToBoolSlice(valueStrSlice), nil
		case reflect.String:
			return cast.ToStringSlice(value), nil
		default:
			return nil, fmt.Errorf("unsupported slice type: %s", valueType.Name())
		}
	case reflect.Struct:
		if targetType.AssignableTo(reflect.TypeOf(time.Time{})) {
			return cast.ToTime(value), nil
		}
		targetValue := reflect.Indirect(reflect.New(targetType))
		if !targetValue.CanInterface() {
			return nil, fmt.Errorf("can't conver from %s to %s",
				reflect.TypeOf(value).Name(), targetType.Name())
		}
		valueInstance := targetValue.Interface()
		var err error
		switch reflect.Indirect(reflect.ValueOf(value)).Kind() {
		case reflect.String:
			mapValue := make(map[string]interface{})
			err = json.Unmarshal([]byte(value.(string)), &mapValue)
			if err != nil {
				return nil, fmt.Errorf("can't convert string to map, invalid json: %s", value)
			}
			err = copyData(mapValue, &valueInstance, "json")
		case reflect.Struct, reflect.Map:
			err = copyData(value, &valueInstance, "")
		default:
			return nil, fmt.Errorf("can't conver from %s to %s", reflect.TypeOf(value).Name(), targetType.Name())
		}
		if err != nil {
			return nil, multierror.Append(fmt.Errorf("can't set data from %s to %s",
				reflect.TypeOf(value).Name(), targetType.Name()), err)
		}
		return valueInstance, nil
	default:
		return nil, fmt.Errorf("unsupported cast type from %s to %s",
			reflect.TypeOf(value).Name(), targetType.Name())
	}
}

func bindValidate(request *restful.Request, argInstance interface{}, bindParameters []*ArgumentDescribe) error {
	if reflect.ValueOf(argInstance).Kind() != reflect.Ptr {
		return fmt.Errorf("bind instance must be pointer")
	}
	paramMap := make(map[string]interface{})
	var totalCheckErrors error
	for _, arg := range bindParameters {
		argumentType := arg.ResolveArgumentType()
		var value interface{}
		var checkError error
		switch argumentType {
		case PathArgumentType:
			value = request.PathParameter(arg.Name)
			if arg.Required && value == "" {
				checkError = fmt.Errorf("can't find path parameter: %s", arg.Name)
			}
		case QueryArgumentType:
			valueArr := request.QueryParameters(arg.Name)
			if len(valueArr) > 0 {
				value = valueArr[0]
			}
			if arg.Required && value == nil {
				checkError = fmt.Errorf("can't find query parameter: %s", arg.Name)
				continue
			}
		case FormArgumentType:
			formValue, err := request.BodyParameter(arg.Name)
			if err != nil {
				checkError = fmt.Errorf("can't resolve form parameter while get %s", arg.Name)
				continue
			}
			if arg.Required && formValue == "" {
				checkError = fmt.Errorf("can't find form parameter: %s", arg.Name)
			}
			value = formValue
		case BodyArgumentType:
			value = arg.SourceInterface()
			if value == nil {
				checkError = fmt.Errorf("can't create body argument instance: %s", arg.Name)
				continue
			}
			tempMap := make(map[string]interface{})
			err := request.ReadEntity(&tempMap)
			if arg.Required && err != nil {
				checkError = fmt.Errorf("can't resolve body parameter: %s", arg.Name)
			}
			err = copyData(tempMap, &value, "json")
			if err != nil {
				checkError = fmt.Errorf("can't load data from body")
			}
		case HeaderArgumentType:
			value = request.HeaderParameter(arg.Name)
			if arg.Required && value == "" {
				checkError = fmt.Errorf("can't find header parameter: %s", arg.Name)
			}
		default:
			checkError = fmt.Errorf("unsupported parameter type : %s, name: %s", arg.Type, arg.Name)
		}
		if value == nil {
			if arg.Default == "" {
				continue
			}
			value = arg.Default
		}
		if checkError != nil {
			totalCheckErrors = multierror.Append(totalCheckErrors, checkError)
			continue
		}
		targetType := arg.SourceType()
		v, err := convert(value, targetType)
		if err != nil {
			totalCheckErrors = multierror.Append(totalCheckErrors, fmt.Errorf("cast parameter %s failed", arg.Name), err)
			continue
		}
		paramMap[arg.FieldName()] = v
	}
	if totalCheckErrors != nil {
		return totalCheckErrors
	}
	err := copyData(paramMap, &argInstance, "")
	if err != nil {
		return multierror.Append(fmt.Errorf("can't load parameter for request"), err)
	}
	//can't pass
	//err = validator.New().Struct(argInstance)
	//if err != nil {
	//	return multierror.Append(fmt.Errorf("request parameter check failed"), err)
	//}
	return nil
}

func (rh *restfulHandler) Handler(request *restful.Request, response *restful.Response) (interface{}, error) {
	response.AddHeader(restful.HEADER_AccessControlAllowOrigin, "*")
	apiDef := rh.apiDef
	var argInstance interface{}
	if apiDef.Parameter != nil {
		argInstance = apiDef.NewArgumentInstance()
		err := bindValidate(request, &argInstance, rh.parameters)
		if err != nil {
			return nil, err
		}
	}
	result, err := apiDef.Handler(argInstance, request, response)
	if err != nil {
		return nil, err
	}
	return result, nil
}

func (rsc *restfulApiContainer) Register(apiRegister HandlerRegister) {
	rsc.apiRegisters = append(rsc.apiRegisters, apiRegister)
}

func (rsc *restfulApiContainer) Setup(serverContainer *restful.Container) error {
	rsc.lock.Lock()
	defer rsc.lock.Unlock()
	klog.Info("Init registry restfulapi api")
	for i := range rsc.apiRegisters {
		serviceRegister := rsc.apiRegisters[i]
		err := serviceRegister.Init(rsc.context)
		if err != nil {
			return multierror.Append(fmt.Errorf("init api service %s failed",
				reflect.TypeOf(serviceRegister).Name()), err)
		}
	}
	for i := range rsc.apiRegisters {
		serviceRegister := rsc.apiRegisters[i]
		ws := runtime.NewWebService(serviceRegister.GroupName())
		for _, apiDefine := range serviceRegister.Register() {
			routeBuilder, err := apiDefine.buildRoute(ws)
			if err != nil {
				return multierror.Append(fmt.Errorf("can't resolve route information for path %s",
					apiDefine.Path), err)
			}
			totalArguments, err := apiDefine.describeArgument()
			if err != nil {
				return multierror.Append(fmt.Errorf("can't resolve request argument for path %s",
					apiDefine.Path), err)
			}
			var argCheckErrors error
			for _, argItem := range totalArguments {
				err := argItem.setupArgument(ws, routeBuilder)
				if err != nil {
					argCheckErrors = multierror.Append(argCheckErrors, err)
					continue
				}
			}
			if argCheckErrors != nil {
				return argCheckErrors
			}
			wrapperHandler := &restfulHandler{
				apiDef:     apiDefine,
				parameters: totalArguments,
			}
			routeBuilder.To(wrapperHandler.RouteHandler)
			var returnDefList []ReturnDefinition
			if apiDefine.ReturnData != nil {
				returnType := reflect.TypeOf(apiDefine.ReturnData)
				if returnType.Kind() == reflect.Ptr {
					returnType = returnType.Elem()
				}
				if returnType.Kind() == reflect.Struct {
					returnDefList = append(returnDefList, ReturnDefinition{
						Code:     200,
						Message:  "返回数据中data结构详情：\n" + describeTypeDoc(returnType, "", ""),
						DataType: apiDefine.ReturnData,
					})
				}
			}
			for _, v := range returnDefList {
				routeBuilder.Returns(v.Code, v.Message, v.DataType)
			}
			routeBuilder.Returns(500, "Error", GlobalResponseData{})
			routeBuilder.DefaultReturns("通用返回格式，所有的返回通过这个结构包装：\n"+
				describeTypeDoc(reflect.TypeOf(GlobalResponseData{}), "", ""), GlobalResponseData{})
			ws.Route(routeBuilder)
		}
		serverContainer.Add(ws)
	}
	return nil
}

func NewContainer(context *ServerContext) *restfulApiContainer {
	return &restfulApiContainer{
		apiRegisters: []HandlerRegister{},
		context:      context,
	}
}

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/pkg/tasks/monitor.go
```golang
package tasks

import (
	"luban-cmdb-api/pkg/service/monitor"
	"time"

	"github.com/dgraph-io/dgo/v200"
)

func initMonitorTask(dgraphclient *dgo.Dgraph) {
	for {

		//task
		monitor.RegisterRun(dgraphclient)
		//每隔十分钟
		time.Sleep(10 * time.Minute)
	}
}

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/pkg/tasks/task.go
```golang
package tasks

import (
	"luban-cmdb-api/pkg/apiserver/config"
	bmTask "luban-cmdb-api/pkg/tasks/bm-task"
	eiptask "luban-cmdb-api/pkg/tasks/eip-task"
	lbTask "luban-cmdb-api/pkg/tasks/lb-task"
	natTask "luban-cmdb-api/pkg/tasks/nat-task"
	"luban-cmdb-api/pkg/tasks/networkTask"
	novaTask "luban-cmdb-api/pkg/tasks/nova-task"
	sdn_exporter_task "luban-cmdb-api/pkg/tasks/sdn-exporter-task"
	slTask "luban-cmdb-api/pkg/tasks/sl-task"
	snmptask "luban-cmdb-api/pkg/tasks/snmp-task"
	"luban-cmdb-api/pkg/tasks/svcinstanceTask"
	"luban-cmdb-api/pkg/utils"
	"time"

	"github.com/gophercloud/gophercloud"
	"k8s.io/klog/v2"

	"github.com/dgraph-io/dgo/v200"
)

func InitTasks(dgraphclient *dgo.Dgraph, config *config.Config, novaclient *gophercloud.ServiceClient, identityClient *gophercloud.ServiceClient) {

	klog.Infoln("自动任务开始")
	//初始化监控任务
	utils.GoSafe(func() { initMonitorTask(dgraphclient) })
	utils.GoSafe(func() { serialTask(dgraphclient, config, novaclient, identityClient) })
	//每小时更新一次交换机接口细节数据
	utils.GoSafe(snmptask.IfTaskScheduler)
	//每刻钟更新一次交换机硬件监控数据
	utils.GoSafe(snmptask.PartsTaskScheduler)
	//todo  去除端口状态更新 每刻钟更新一次交换机端口状态
	//utils.GoSafe(snmptask.IfStateTaskScheduler)
	// 每半个小时监听一下sdn-exporter的ip地址是否改变
	utils.GoSafe(sdn_exporter_task.InitSdnCronTask)
	klog.Infoln("自动任务结束")
}

func serialTask(dgraphclient *dgo.Dgraph, config *config.Config, novaclient *gophercloud.ServiceClient, identityClient *gophercloud.ServiceClient) {
	for {
		now := time.Now()
		klog.Infoln("serial - cloud products task start time:", now)

		//time.Sleep(time.Second * 5)
		klog.Infof("Resource refreshing start time %v", time.Now())
		//task c *restful.Container, dgraphclient *dgo.Dgraph, config *config.Config
		//云主机
		klog.Infoln("serial - cloud products vm start")
		utils.RunSafe(func() { AggregatesVmTask(novaclient, identityClient, *config) })
		klog.Infoln("serial - cloud products vm end")

		//云硬盘
		klog.Infoln("serial - cloud products disk start")
		utils.RunSafe(func() { CloudDiskStorageTask(dgraphclient, config) })
		klog.Infoln("serial - cloud products disk end")

		//存储资源池
		klog.Infoln("serial - cloud products StoragePool start")
		utils.RunSafe(func() { StoragePoolListTask(dgraphclient, config) })
		klog.Infoln("serial - cloud products StoragePool end")

		//计算资源池
		klog.Infoln("serial - cloud products Aggregate start")
		utils.RunSafe(func() { GetAggregateList(novaclient, identityClient, *config) })
		klog.Infoln("serial - cloud products Aggregate end")

		//计算资源池库存
		klog.Infoln("serial - cloud products AggregateUsage start")
		utils.RunSafe(func() { GetAggregateUsageList(novaclient, identityClient, *config) })
		klog.Infoln("serial - cloud products AggregateUsage end")

		//eip
		klog.Infoln("serial - cloud products eip start")
		utils.RunSafe(eiptask.Scheduler)
		klog.Infoln("serial - cloud products eip end")

		//snmp
		klog.Infoln("serial - cloud products snmp start")
		utils.RunSafe(snmptask.Scheduler)
		klog.Infoln("serial - cloud products snmp end")

		//网络资源池
		klog.Infoln("serial - cloud products network pool start")
		utils.RunSafe(networkTask.Scheduler)
		klog.Infoln("serial - cloud products network pool end")

		//lb
		klog.Infoln("serial - cloud products lb start")
		utils.RunSafe(lbTask.Scheduler)
		klog.Infoln("serial - cloud products lb end")

		//nat
		klog.Infoln("serial - cloud products nat start")
		utils.RunSafe(natTask.Scheduler)
		klog.Infoln("serial - cloud products nat end")
		//bm
		klog.Infoln("serial - cloud products bm start")
		utils.RunSafe(bmTask.Scheduler)
		klog.Infoln("serial - cloud products bm end")
		//sl
		klog.Infoln("serial - cloud products sl start")
		utils.RunSafe(slTask.Scheduler)
		klog.Infoln("serial - cloud products sl end")

		//服务实例Pod持久化
		klog.Infoln("serial - cloud products svcinstance start")
		utils.RunSafe(svcinstanceTask.Scheduler)
		klog.Infoln("serial - cloud products svcinstance end")

		//nova
		klog.Infoln("serial - cloud products novaTask start")
		utils.RunSafe(novaTask.SchedulerOnce)
		klog.Infoln("serial - cloud products novaTask end")

		klog.Infoln("serial - cloud products task end time:", time.Since(now))
		//每隔一天
		time.Sleep(time.Duration(config.RedisTaskHours) * time.Hour)
	}
}

func goTask(dgraphclient *dgo.Dgraph, config *config.Config, novaclient *gophercloud.ServiceClient, identityClient *gophercloud.ServiceClient) {
	for {
		now := time.Now()
		klog.Infoln("parallel - cloud products task start time:", now)

		//time.Sleep(time.Second * 5)
		klog.Infof("Resource refreshing start time %v", time.Now())
		//task c *restful.Container, dgraphclient *dgo.Dgraph, config *config.Config
		//云主机
		utils.GoSafe(func() { AggregatesVmTask(novaclient, identityClient, *config) })
		//云硬盘
		utils.GoSafe(func() { CloudDiskStorageTask(dgraphclient, config) })
		//存储资源池
		utils.GoSafe(func() { StoragePoolListTask(dgraphclient, config) })
		//计算资源池
		utils.GoSafe(func() { GetAggregateList(novaclient, identityClient, *config) })
		//计算资源池库存
		utils.GoSafe(func() { GetAggregateUsageList(novaclient, identityClient, *config) })
		//eip
		utils.GoSafe(eiptask.Scheduler)
		//snmp
		utils.GoSafe(snmptask.Scheduler)

		//网络资源池
		utils.GoSafe(networkTask.Scheduler)
		//lb
		utils.GoSafe(lbTask.Scheduler)
		//nat
		utils.GoSafe(natTask.Scheduler)
		//bm
		utils.GoSafe(bmTask.Scheduler)
		//sl
		utils.GoSafe(slTask.Scheduler)

		//服务实例Pod持久化
		utils.GoSafe(svcinstanceTask.Scheduler)

		klog.Infoln("parallel - cloud products task end time:", time.Since(now))

		//每隔一天
		time.Sleep(time.Duration(config.RedisTaskHours) * time.Hour)
	}
}

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/pkg/tasks/clouddisktask.go
```golang
package tasks

import (
	"context"
	"encoding/json"
	"luban-cmdb-api/data/ent"
	"luban-cmdb-api/pkg/apiserver/config"
	"luban-cmdb-api/pkg/dao/blockstorage"
	"luban-cmdb-api/pkg/gredis"
	"luban-cmdb-api/pkg/models/storage"
	"luban-cmdb-api/pkg/service"
	"time"

	"github.com/dgraph-io/dgo/v200"
	"k8s.io/klog/v2"
)

func CloudDiskStorageTask(dgraphclient *dgo.Dgraph, config *config.Config) {
	klog.Info("cloudDisk task start ...")
	//blockStoragePoolService := service.NewBlockStoragePoolService(config.EBSAddr, config.StorageStateAddr, dgraphclient)
	cloudDiskReq := storage.CloudDiskRequest{
		Region: "all",
		//Az:     "all",
	}
	//cloudDiskReq.PageNo = 1
	//cloudDiskReq.PageSize = 100
	cloudDiskList := []storage.CloudDiskData{}
	var cloudDiskInterfaceMap = make(map[string]interface{})
	var (
		//cloudDiskMap []storage.CloudDiskData
		err error
	)

	cloudDiskList, _, err = GetCloudDiskList(dgraphclient, config, cloudDiskReq)
	if err != nil {
		klog.Errorf("cloudDisk get list err %v:", err)
		return
	}
	//cloudDiskList = append(cloudDiskList, cloudDiskMap...)

	//清理数据库数据
	err = blockstorage.DeleteALLData(context.Background())
	if err != nil {
		klog.Error("blockstorage DeleteALLData failure:", err.Error())
	}

	for _, data := range cloudDiskList {
		//if _, ok := azCode2Map[data.AzCode]; !ok {
		//	continue
		//}
		//cloudDiskInterfaceList = append(cloudDiskInterfaceList, data)
		tenant, err := service.GetRedisTenantMessage(data.TenantId)
		if err != nil {
			continue
		}
		data.TenantName = tenant.Name
		dataByte, err := json.Marshal(data)
		if err != nil {
			continue
		}
		cloudDiskInterfaceMap[data.InstanceId] = dataByte

		//写入Mysql
		ebs := ent.BlockStorage{
			Name:             data.Name,
			InstanceID:       data.InstanceId,
			Region:           data.Region,
			RegionCode:       data.RegionCode,
			Az:               data.Az,
			AzCode:           data.AzCode,
			ResourcePool:     data.ResourcePool,
			ResourcePoolType: data.ResourcePoolType,
			UseStatus:        data.UseStatus,
			TenantID:         data.TenantId,
			TenantName:       data.TenantName,
			VM:               data.Vm,
			VMID:             data.VmId,
			CreateTime:       int(data.CreateTime),
			Size:             int32(data.Size),
			MountPoint:       data.MountPoint,
		}

		err = blockstorage.InsertOrUpdate(context.Background(), ebs)
		if err != nil {
			klog.Error("blockstorage  InsertOrUpdate err:", err)
		}
	}

	storage.ClouddiskMap = cloudDiskList

	ctx, cefl := context.WithTimeout(context.Background(), 5*time.Second)
	defer cefl()
	_, err = gredis.Del(ctx, gredis.ClouddiskMapKey)
	if err != nil {
		klog.Error("cloudDiskList cache failure:", err.Error())
	}
	//_, err := gredis.SAdd(ctx, gredis.ClouddiskMapKey, cloudDiskInterfaceList)
	_, err = gredis.HMSet(ctx, gredis.ClouddiskMapKey, cloudDiskInterfaceMap)
	if err != nil {
		klog.Error("cloudDiskList cache failure:", err.Error())
	}

	klog.Info("cloudDisk task end ...")
}

func GetCloudDiskList(dgraphclient *dgo.Dgraph, config *config.Config, cloudDiskReq storage.CloudDiskRequest) ([]storage.CloudDiskData, int, error) {
	cloudDiskList := []storage.CloudDiskData{}
	blockStoragePoolService := service.NewBlockStoragePoolService(config.EBSAddr, config.StorageStateAddr, dgraphclient)
	//totalCount:=0
	cloudDiskCount, err := blockStoragePoolService.GetCloudDiskListForStorage(cloudDiskReq)
	if err != nil {
		klog.Info("err:", err)
		return cloudDiskList, 0, err
	}
	cloudDiskList = cloudDiskCount.DataList
	//return cloudDiskList, cloudDiskCount.DataTotal, err
	return cloudDiskList, len(cloudDiskList), err
}

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/pkg/tasks/bucketTask.go
```golang
package tasks

import (
	"fmt"
	"io"
	"luban-cmdb-api/pkg/apiserver/config"
	"net/http"
)

func GetBucketListFromAPI(config *config.Config) {
	url := fmt.Sprintf("http://%s/kss/bucketListNoCache", config.Ks3ServiceAPI)
	c := http.Client{}
	resp, err := c.Get(url)
	if err != nil {
		return
	}
	b, er := io.ReadAll(resp.Body)
	if er != nil {
		fmt.Println(er.Error())
	}
	fmt.Println(b)
}

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/pkg/tasks/switchStatusFetch.go
```golang
package tasks

import (
	"encoding/json"
	"fmt"
	"io"
	"luban-cmdb-api/pkg/apiserver/config"
	"luban-cmdb-api/pkg/dao"
	"luban-cmdb-api/pkg/tasks/prom"
	"math/rand"
	"net/http"
	"net/url"
	"strconv"
	"strings"
	"time"

	"k8s.io/klog/v2"
)

type IpidMap struct {
	Id     int
	Ip     string
	Status string
}

func fetchOutIp() (map[int]string, []bool, []interface{}) {
	var (
		ipids   = make([]IpidMap, 0)
		ipidMap = make(map[int]string)
	)
	_ = dao.AssetDB.Table("asset_switch").Where(" run_status is null or run_status = '' ").UpdateColumn("run_status", "down").Error
	_ = dao.AssetDB.Table("asset_switch").Select("id,out_band_ip as ip,run_status as status").Where("deleted = ?", dao.DELETED_N).Order("id").Scan(&ipids)
	if len(ipids) == 0 {
		return ipidMap, nil, nil
	}
	lastId := ipids[len(ipids)-1].Id
	status := make([]bool, lastId)
	allIps := make([]interface{}, 0)
	for _, ipid := range ipids {
		id := ipid.Id
		ip := ipid.Ip
		ip = strings.Trim(ip, " ")
		state := ipid.Status
		ipidMap[id] = ip
		if ip != "" {
			allIps = append(allIps, ip)
		}
		//状态为空的按运行状态缓存，会在后续逻辑中根据实际情况更改
		if state == "up" || state == "" {
			status[id-1] = true
		}
	}
	return ipidMap, status, allIps
}

func fetchServerOutIp() (map[int]string, []bool, []interface{}) {
	var (
		ipids   = make([]IpidMap, 0)
		ipidMap = make(map[int]string)
	)
	_ = dao.AssetDB.Table("asset_switch").Where(" run_status is null or run_status = '' ").UpdateColumn("run_status", "down").Error
	_ = dao.AssetDB.Table("asset_switch").Select("id,out_band_ip as ip,run_status as status").Where("deleted = ?", dao.DELETED_N).Order("id").Scan(&ipids)
	if len(ipids) == 0 {
		return ipidMap, nil, nil
	}
	lastId := ipids[len(ipids)-1].Id
	status := make([]bool, lastId)
	allIps := make([]interface{}, 0)
	for _, ipid := range ipids {
		id := ipid.Id
		ip := ipid.Ip
		ip = strings.Trim(ip, " ")
		state := ipid.Status
		ipidMap[id] = ip
		if ip != "" {
			allIps = append(allIps, ip)
		}
		//状态为空的按运行状态缓存，会在后续逻辑中根据实际情况更改
		if state == "up" || state == "" {
			status[id-1] = true
		}
	}
	return ipidMap, status, allIps
}

func searchProme(param string, gTime time.Time) map[string]bool {
	var (
		data  map[string]interface{}
		resp  *http.Response
		bytes []byte
		err   error
		state = make(map[string]bool)
	)
	api := "http://" + config.GetDefaultUrl(config.PrometheusService) + "/api/v1/query?query="
	pTime := "&time=" + fmt.Sprintf("%v", gTime.Unix())
	client := http.Client{}
	resp, err = client.Get(api + url.QueryEscape(param) + pTime)
	if err != nil {
		return nil
	}
	defer resp.Body.Close()
	bytes, err = io.ReadAll(resp.Body)
	if err != nil {
		return nil
	}
	err = json.Unmarshal(bytes, &data)
	if err != nil {
		return nil
	}
	if vCw, ok := data["data"]; ok {
		rateData := vCw.(map[string]interface{})
		if resultData, ok := rateData["result"]; ok {
			re := resultData.([]interface{})
			if len(re) > 0 {
				for _, resultD := range re {
					valu := resultD.(map[string]interface{})
					if valueData, ok := valu["value"]; ok {
						value := valueData.([]interface{})
						if status, ok := value[1].(string); ok {
							v, _ := strconv.Atoi(status)
							if metricData, ok := valu["metric"]; ok {
								metric := metricData.(map[string]interface{})
								if instance, ok := metric["instance"]; ok {
									if k, ok := instance.(string); ok {
										state[k] = v == 1
									}
								}
							}
						}
					}
				}
			}
		}
	}
	return state
}

func concatParam(indexies []interface{}) string {
	if len(indexies) == 0 {
		return ""
	}
	format := ""
	for i, _ := range indexies {
		if i == len(indexies)-1 {
			format += "%v"
			break
		}
		format += "%v|"
	}
	return fmt.Sprintf(format, indexies...)
}

func updateStatus(ups, downs []int) (err error) {
	tx := dao.AssetDB.Begin()
	upTx := tx.Table("asset_switch")
	if len(ups) > 0 {
		err = upTx.Where("id in (?)", ups).UpdateColumn("run_status", "up").Error
		if err != nil {
			tx.Rollback()
			return
		}
	}
	downTx := tx.Table("asset_switch")
	if len(downs) > 0 {
		err = downTx.Where("id in (?)", downs).UpdateColumn("run_status", "down").Error
		if err != nil {
			tx.Rollback()
			return
		}
	}
	tx.Commit()
	return
}

func worker() {
	idipMap, oldStatus, allIps := fetchOutIp()
	concat := concatParam(allIps)
	params := fmt.Sprintf("up{instance=~'%s'}", concat)
	newStatus := searchProme(params, time.Now())
	var (
		ups   = make([]int, 0)
		downs = make([]int, 0)
	)
	for id, ip := range idipMap {
		if ip == "" && oldStatus[id-1] {
			downs = append(downs, id)
			continue
		}
		if newStatus[ip] == oldStatus[id-1] {
			continue
		}
		if newStatus[ip] {
			ups = append(ups, id)
		} else {
			downs = append(downs, id)
		}
	}
	err := updateStatus(ups, downs)
	logTIme := time.Now().Format("2006-01-02 15:04:05")
	if err != nil {
		klog.Error(fmt.Sprintf("Failed to synchronize switch running status. time: %s error: %s", logTIme, err.Error()))
	}
}

func FetchSwitchStatus() {
	scheduler()
}

func scheduler() {
	//worker()
	rand.Seed(time.Now().UnixNano())
	//interval := rand.Intn(10) + rand.Intn(5) + 5 - rand.Intn(5) + rand.Intn(5)
	interval := 60 - rand.Intn(20) - rand.Intn(10) - rand.Intn(5)
	ticker := time.NewTicker(time.Second * time.Duration(interval))
	for range ticker.C {
		worker()
	}
}

//FetchServerStatus 服务器状态更新
func FetchServerStatus() {
	serverscheduler()
}

func serverscheduler() {
	rand.Seed(time.Now().UnixNano())
	interval := 60 - rand.Intn(20) - rand.Intn(10) - rand.Intn(5)
	ticker := time.NewTicker(time.Second * time.Duration(interval))
	for range ticker.C {
		serverWorker()
	}
}

func serverWorker() {

	var (
		ipids   = make([]IpidMap, 0)
		ips     []string
		upIps   []string
		downIps []string
	)
	err := dao.AssetDB.Table("asset_physical_server").Select("ip").Where("is_vm = ? and deleted = ?", 0, dao.DELETED_N).Scan(&ipids).Error
	if err != nil {
		klog.Error("更改服务器状态获取服务器列表失败", err)
		return
	}
	for _, v := range ipids {
		ips = append(ips, v.Ip)
	}
	fmt.Println("ips", ips)

	serverIplist, err := prom.GetServerMonitoringStatus("server", ips)
	if err != nil {
		klog.Error("更改服务器状态获取服务器监控状态失败", err)
		return
	}

	for _, v := range serverIplist {
		if v.Status == "up" {
			upIps = append(upIps, v.Ip)
		} else {
			downIps = append(downIps, v.Ip)
		}
	}
	if len(upIps) != 0 {
		err1 := dao.AssetDB.Table("asset_physical_server").Where("ip in (?)", upIps).UpdateColumn("run_status", "up").Error
		if err1 != nil {
			klog.Error("更改服务器up状态失败", err)
			return
		}
	}
	if len(downIps) != 0 {
		err2 := dao.AssetDB.Table("asset_physical_server").Where("ip in (?)", downIps).UpdateColumn("run_status", "down").Error
		if err2 != nil {
			klog.Error("更改服务器down状态失败", err)
			return
		}
	}

}

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/pkg/tasks/aggregatesVmTask.go
```golang
package tasks

import (
	"context"
	"encoding/json"
	"luban-cmdb-api/pkg/apiserver/config"
	clientidentity "luban-cmdb-api/pkg/client/identity"
	clientnova "luban-cmdb-api/pkg/client/nova"
	"luban-cmdb-api/pkg/gredis"
	"luban-cmdb-api/pkg/service"
	"time"

	"github.com/gophercloud/gophercloud"
	"k8s.io/klog/v2"
)

func AggregatesVmTask(novaclient *gophercloud.ServiceClient, identityClient *gophercloud.ServiceClient, apiServerConfig config.Config) {
	klog.Infoln("DEBUG - cloud products vm start  - 1")
	GetAggregateList(novaclient, identityClient, apiServerConfig)
	klog.Infoln("DEBUG - cloud products vm start  - 2")

	//判断nova原始数据是否存在
	var (
		ctx    context.Context
		cancel context.CancelFunc
	)
	for {
		ctx, cancel = context.WithTimeout(context.Background(), 2*time.Second)
		exist := gredis.Exists(ctx, gredis.NovaCloudServerHashKey)
		cancel()
		if exist {
			break
		}
		time.Sleep(10 * time.Second)
	}
	klog.Infoln("DEBUG - cloud products vm start  - 3")

	klog.Infoln("aggregatesVmList cache start:")
	//opt := options.NewServerRunOptions()
	if novaclient == nil {
		novaclient, _ = clientnova.NewClient(apiServerConfig)
	}
	if identityClient == nil {
		identityClient, _ = clientidentity.NewClient(apiServerConfig)
	}
	//if novaclient == nil {
	//	klog.Infoln("novaclient is nil")
	//	return
	//}
	//blockStoragePoolService := service.NewBlockStoragePoolService(config.EBSAddr, config.StorageStateAddr, dgraphclient)
	aggregateService := service.NewAggregateService(novaclient, identityClient, apiServerConfig)
	klog.Infoln("DEBUG - cloud products vm start  - 4")

	vmL, err := aggregateService.StorageAggregateVm()
	klog.Infoln("DEBUG - cloud products vm start  - 5")

	if err != nil {
		klog.Errorf("get aggregateService list err:%v", err)
		return
	}
	aggregatesVmInterfaceMap := make(map[string]interface{})
	for _, vm := range vmL {
		vmByte, err := json.Marshal(vm)
		if err != nil {
			continue
		}

		aggregatesVmInterfaceMap[vm.Id] = vmByte
	}
	if len(aggregatesVmInterfaceMap) > 0 {
		tmpKey := gredis.AggregatesVmMapKey + "_tmp"
		ctx, cancel = context.WithTimeout(context.Background(), 5*time.Second)
		defer cancel()
		_, err = gredis.HMSet(ctx, tmpKey, aggregatesVmInterfaceMap)
		if err != nil {
			klog.Error("aggregatesVmList cache failure:", err.Error())
			return
		}
		_, err = gredis.Rename(ctx, tmpKey, gredis.AggregatesVmMapKey) //将临时key改为正式key，覆盖掉旧数据
		if err != nil {
			_, _ = gredis.Del(ctx, tmpKey) //清除临时缓存
			klog.Errorf("rename %s to %s failure: ", tmpKey, gredis.AggregatesVmMapKey, err.Error())
			return
		}
	}
	klog.Infoln("DEBUG - cloud products vm start  - 6")
	klog.Infoln("aggregatesVmList cache success:")
	// vmListQuery := aggregate.VMListQuery{
	// 	Region: "all",
	// 	//Az:     "all",
	// }
	// vmListQuery.PageNo = 1
	// vmListQuery.PageSize = 100
	// aggregatesVmList := []aggregate.AggregatesVm{}
	// //aggregatesVmInterfaceList := []interface{}{}
	// aggregatesVmInterfaceMap := make(map[string]interface{})
	// for {
	// 	aggregatesVmMap, err := GetAggregatesVmList(aggregateService, vmListQuery)
	// 	aggregatesVmList = append(aggregatesVmList, aggregatesVmMap...)
	// 	for _, vm := range aggregatesVmMap {

	// 		vmByte, err := json.Marshal(vm)
	// 		if err != nil {
	// 			continue
	// 		}

	// 		aggregatesVmInterfaceMap[vm.ID] = vmByte
	// 	}

	// 	if err != nil {
	// 		klog.Info("get aggregateService list err:%v", err)
	// 		return
	// 	}
	// 	if len(aggregatesVmMap) < vmListQuery.PageSize {
	// 		break
	// 	}
	// 	vmListQuery.PageNo++
	// }

	// aggregate.AggregatesVmMap = aggregatesVmList

	// ctx, cefl := context.WithTimeout(context.Background(), 5*time.Second)
	// defer cefl()
	// _, err := gredis.Del(ctx, gredis.AggregatesVmMapKey)
	// if err != nil {
	// 	klog.Error("aggregatesVmList cache failure:", err.Error())
	// }
	// //_, err := gredis.SAdd(ctx, gredis.AggregatesVmMapKey, aggregatesVmInterfaceList)
	// _, err = gredis.HMSet(ctx, gredis.AggregatesVmMapKey, aggregatesVmInterfaceMap)
	// if err != nil {
	// 	klog.Error("aggregatesVmList cache failure:", err.Error())
	// }
	// klog.Infoln("aggregatesVmList cache success:")
}

// func GetAggregatesVmList(aggregateService *service.AggregateService, vmListQuery aggregate.VMListQuery) ([]aggregate.AggregatesVm, error) {
// 	aggregatesVmList := []aggregate.AggregatesVm{}

// 	//totalCount:=0
// 	aggregatesVmCount, err := aggregateService.GetVMsListForStorage(vmListQuery)
// 	if err != nil {
// 		klog.Info("err:", err)
// 		return aggregatesVmList, err
// 	}
// 	aggregatesVmList = aggregatesVmCount.DataList
// 	return aggregatesVmList, err
// }

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/pkg/tasks/aggregateTask.go
```golang
package tasks

import (
	"context"
	"encoding/json"
	"fmt"
	"luban-cmdb-api/pkg/apiserver/config"
	"luban-cmdb-api/pkg/dao/server"
	"luban-cmdb-api/pkg/gredis"
	serverModel "luban-cmdb-api/pkg/models/server"
	"luban-cmdb-api/pkg/service"
	"strconv"
	"time"

	"github.com/gophercloud/gophercloud"
	"k8s.io/klog/v2"
)

func GetAggregateList(novaclient *gophercloud.ServiceClient, identityClient *gophercloud.ServiceClient, apiServerConfig config.Config) {
	klog.Infoln("DEBUG - cloud products vm start  - 1.1")

	klog.Infoln("aggregatesMap cache start---------------------------------------------------------")
	if novaclient == nil {
		return
	}
	//totalCount:=0
	aggregateService := service.NewAggregateService(novaclient, identityClient, apiServerConfig)
	klog.Infoln("DEBUG - cloud products vm start  - 1.2")
	aggregates, err := aggregateService.GetAggregateAll()
	klog.Infoln("DEBUG - cloud products vm start  - 1.3")

	if err != nil {
		klog.Info("err:", err)
		return
	}
	if len(aggregates.DataList) <= 0 {
		return
	}
	aggregatesMap := make(map[string]interface{})
	hosts := serverModel.PoolHostUpdate{}
	serverMap := make(map[string]interface{})
	aggregatelen := len(aggregates.DataList)
	for i := 0; i < aggregatelen; i++ {
		aggregate, err := json.Marshal(aggregates.DataList[i])
		if err != nil {
			continue
		}
		aggregatesMap[strconv.Itoa(aggregates.DataList[i].Id)] = aggregate
		//aggregatesMap[string(rune(aggregates.DataList[i].Id))] = aggregate
		//serverMap["ip"] = aggregates.DataList[i].Hosts
		hosts.NameList = aggregates.DataList[i].Hosts
		serverMap["resource_pool_type"] = "kec"
		serverMap["resource_pool"] = aggregates.DataList[i].Name
		err = server.UpdateStorage(hosts, serverMap)
		if err != nil {
			klog.Error("aggregatesMap cache failure:", err.Error())
			err = nil
			continue
		}
	}
	if len(aggregatesMap) > 0 {
		ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
		defer cancel()
		tempKey := fmt.Sprintf("%s_temp", gredis.AggregatesMapKey)
		_, err = gredis.HMSet(ctx, tempKey, aggregatesMap)
		if err != nil {
			klog.Error("aggregatesMap cache failure:", err.Error())
			_, _ = gredis.Del(ctx, tempKey)
			return
		}
		_, err = gredis.Rename(ctx, tempKey, gredis.AggregatesMapKey)
		if err != nil {
			klog.Error("aggregatesMap cache failure:", err.Error())
			_, _ = gredis.Del(ctx, tempKey)
			return
		}
	}

	klog.Infoln("aggregatesMap cache success-------------------------------------------")

}
func GetAggregateUsageList(novaclient *gophercloud.ServiceClient, identityClient *gophercloud.ServiceClient, apiServerConfig config.Config) {
	klog.Infoln("aggregatesUsageMap cache start---------------------------------------------------------")
	if novaclient == nil {
		return
	}
	//totalCount:=0
	aggregateService := service.NewAggregateService(novaclient, identityClient, apiServerConfig)
	aggregatesUsage, err := aggregateService.GetAggregateUsageAllNew()
	if err != nil {
		klog.Info("err:", err)
		return
	}
	if len(aggregatesUsage) <= 0 {
		return
	}
	aggregatesMap := make(map[string]interface{})
	aggregatelen := len(aggregatesUsage)
	for i := 0; i < aggregatelen; i++ {
		aggregate, err := json.Marshal(aggregatesUsage[i])
		if err != nil {
			continue
		}
		aggregatesMap[string(rune(aggregatesUsage[i].Id))] = aggregate
	}
	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
	defer cancel()
	_, err = gredis.Del(ctx, gredis.AggregatesUsageMapKey)
	if err != nil {
		klog.Error("aggregatesUsageList cache failure:", err.Error())
		return
	}
	//_, err := gredis.SAdd(ctx, gredis.AggregatesMapKey, aggregatesMap)
	_, err = gredis.HMSet(ctx, gredis.AggregatesUsageMapKey, aggregatesMap)
	if err != nil {
		klog.Error("aggregatesUsageMap cache failure:", err.Error())
		return
	}
	klog.Infoln("aggregatesUsageMap cache success:")

}

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/pkg/tasks/storagePoolTask.go
```golang
package tasks

import (
	"luban-cmdb-api/pkg/apiserver/config"
	"luban-cmdb-api/pkg/service"

	"github.com/dgraph-io/dgo/v200"
	"k8s.io/klog/v2"
)

func StoragePoolListTask(dgraphclient *dgo.Dgraph, config *config.Config) {
	// 更新asset_storage_pool addresss字段和slice信息
	// asset_storage_pool 表中的原始数据是通过写死sql直接写入的,详情查asset_data.sql文件
	err := service.UpdateStoragePool()
	if err != nil {
		klog.Error("StoragePoolListTask cache failure:", err.Error())
	}
	klog.Infoln("StoragePoolListTask cache success:")
	//GetBucketList(dgraphclient, config)
}

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/pkg/tasks/prom/prom-client_test.go
```golang
package prom

import (
	"fmt"
	"math"
	"strings"
	"testing"
)

//服务器监控状态
func ServerMonitoringStatus(ipList []string) {
	newIpList := []string{}
	for _, ip := range ipList {
		newIpList = append(newIpList, ip+":9100")
	}
	ipListStr := strings.Join(newIpList, "|")
	query := fmt.Sprintf(`up{instance=~"%s",namespace="monitoring"}`, ipListStr)
	up, err := VectorQuery(query)
	if err != nil {
		return
	}

	ipUpMap := make(map[string]string)
	flag := "down"
	if len(up) > 0 {
		for _, v := range up {
			if math.IsNaN(float64(v.Value)) {
				v.Value = 0
			}
			if float64(v.Value) == 1 {
				flag = "up"
			} else {
				flag = "down"
			}
			instance := v.Metric["instance"]
			ip := strings.Split(string(instance), ":")[0]
			ipUpMap[ip] = flag
		}
	}
	fmt.Println(ipUpMap)
}

func SwitchMonitoringStatus(ipList []string) {
	ipListStr := strings.Join(ipList, "|")
	query := fmt.Sprintf(`up{instance=~"%s",namespace="monitoring"}`, ipListStr)
	up, err := VectorQuery(query)
	if err != nil {
		return
	}

	ipUpMap := make(map[string]string)
	flag := "down"
	if len(up) > 0 {
		for _, v := range up {
			if math.IsNaN(float64(v.Value)) {
				v.Value = 0
			}
			if float64(v.Value) == 1 {
				flag = "up"
			} else {
				flag = "down"
			}
			instance := v.Metric["instance"]
			ip := strings.Split(string(instance), ":")[0]
			ipUpMap[ip] = flag
		}
	}
	fmt.Println(ipUpMap)
}

func TestPromClient_VectorQuery(t *testing.T) {

	ServerMonitoringStatus([]string{"10.178.177.4"})

	SwitchMonitoringStatus([]string{"10.177.60.21", "10.177.60.9"})
}

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/pkg/tasks/prom/prom.go
```golang
package prom

import (
	"fmt"
	"math"
	"strings"
)

type MonitorUpStatus struct {
	Ip     string
	Status string
}

// GetServerMonitoringStatus 服务器/交换机 监控状态
func GetServerMonitoringStatus(serverType string, ipList []string) ([]MonitorUpStatus, error) {
	newIpList := []string{}
	if serverType == "server" {
		for _, ip := range ipList {
			newIpList = append(newIpList, ip+":9100")
		}
	} else {
		newIpList = ipList
	}

	ipListStr := strings.Join(newIpList, "|")
	query := fmt.Sprintf(`avg by (instance)(up{instance=~"%s",namespace="monitoring"})`, ipListStr)
	up, err := VectorQuery(query)
	if err != nil {
		return nil, err
	}

	var ipUpMap []MonitorUpStatus
	flag := "down"
	if len(up) > 0 {
		for _, v := range up {
			if math.IsNaN(float64(v.Value)) {
				v.Value = 0
			}
			if float64(v.Value) == 1 {
				flag = "up"
			} else {
				flag = "down"
			}
			instance := v.Metric["instance"]
			ip := strings.Split(string(instance), ":")[0]
			ipUpMap = append(ipUpMap, MonitorUpStatus{ip, flag})
		}
	}
	return ipUpMap, nil
}

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/pkg/tasks/prom/prom-client.go
```golang
package prom

import (
	"context"
	"fmt"
	"github.com/prometheus/client_golang/api"
	"github.com/prometheus/client_golang/api/prometheus/v1"
	"github.com/prometheus/common/model"
	"time"
)

const (
	TimeOut = 1 * time.Second
)

type PromClient struct {
	apiClient v1.API
}

var defaultClient = NewPromClient()

func NewPromClient() *PromClient {
	return &PromClient{
		apiClient: defaultPromQueryApi(),
	}
}

func defaultPromQueryApi() v1.API {
	promConfig := api.Config{}
	promConfig.Address = "http://pm-kube-prometheus-stack-prometheus.monitoring:9090"
	//promConfig.Address = "http://prometheus.luban.galaxy.cloud/"
	client, err := api.NewClient(promConfig)
	if err == nil {
		return v1.NewAPI(client)
	}
	fmt.Printf("init prometheus client error : %s", err.Error())
	return nil
}

func (c *PromClient) Query(query string, ts time.Time) (model.Value, v1.Warnings, error) {
	fmt.Printf("prometheus query sql: %s", query)
	ctx, cancel := context.WithTimeout(context.TODO(), TimeOut)
	defer cancel()
	return c.apiClient.Query(ctx, query, ts)
}

func (c *PromClient) QueryRange(query string, r v1.Range) (model.Value, v1.Warnings, error) {
	fmt.Printf("prometheus query sql: %s", query)
	ctx, cancel := context.WithTimeout(context.TODO(), TimeOut)
	defer cancel()
	fmt.Printf("prometheus range: %s", r)
	return c.apiClient.QueryRange(ctx, query, r)
}

func (c *PromClient) VectorQuery(query string) (v model.Vector, err error) {

	t := time.Now().Add(time.Second * -1)
	//time.Now()
	value, warnings, err := c.Query(query, t)
	if err != nil {
		fmt.Printf("prometheus query sql: %s, error: %v", query, err)
		return
	}
	if len(warnings) > 0 {
		fmt.Printf("prometheus query sql: %s, warnings: %v", query, warnings)
	}
	v, _ = value.(model.Vector)
	return
}

func (c *PromClient) VectorQuerySpecifiedTime(query string, ts time.Time) (v model.Vector, err error) {

	value, warnings, err := c.Query(query, ts)
	if err != nil {
		fmt.Printf("prometheus query sql: %s, error: %v", query, err)
		return
	}
	if len(warnings) > 0 {
		fmt.Printf("prometheus query sql: %s, warnings: %v", query, warnings)
	}
	v, _ = value.(model.Vector)
	return
}

func (c *PromClient) MatrixQuery(query string, r v1.Range) (v model.Matrix, err error) {
	value, warnings, err := c.QueryRange(query, r)
	if err != nil {
		fmt.Printf("prometheus query sql: %s, error: %v", query, err)
		return
	}
	if len(warnings) > 0 {
		fmt.Printf("prometheus query sql: %s, warnings: %v", query, warnings)
	}
	v, _ = value.(model.Matrix)
	return
}

func VectorQuery(query string) (model.Vector, error) {
	return defaultClient.VectorQuery(query)
}

func VectorQuerySpecifiedTime(query string, ts time.Time) (model.Vector, error) {
	return defaultClient.VectorQuerySpecifiedTime(query, ts)
}

func MatrixQuery(query string, r v1.Range) (model.Matrix, error) {
	return defaultClient.MatrixQuery(query, r)
}

//	// Query performs a query for the given time.
//	Query(ctx context.Context, query string, ts time.Time) (model.Value, Warnings, error)
//	// QueryRange performs a query for the given range.
//	QueryRange(ctx context.Context, query string, r Range) (model.Value, Warnings, error)

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/pkg/tasks/networkTask/models.go
```golang
package networkTask

type (
	PhysicalServer struct {
		Name             string `gorm:"column:name"`
		ResourcePool     string `gorm:"column:resource_pool"`
		ResourcePoolType string `gorm:"column:resource_pool_type"`
		RegionCode       string `gorm:"column:region_code"`
		RegionName       string `gorm:"column:region_name"`
		CpuTotal         int    `gorm:"column:cpu_total"`
		MemTotal         int    `gorm:"column:memory_total"`
	}

	IpCidrPoolName struct {
		Cidr      string   `gorm:"column:cidr"`
		Ip        string   `gorm:"column:ip"`
		PoolNames []string `gorm:"column:pool_names"`
	}
)

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/pkg/tasks/networkTask/netTask.go
```golang
package networkTask

import (
	"context"
	"encoding/json"
	"fmt"
	"luban-cmdb-api/pkg/dao"
	"luban-cmdb-api/pkg/dao/basic"
	"luban-cmdb-api/pkg/gredis"
	"luban-cmdb-api/pkg/models/netPoolModel"
	"luban-cmdb-api/pkg/utils"
	"net"
	"strings"
	"time"

	"github.com/zeromicro/go-zero/core/logx"

	bmmodel "luban-cmdb-api/pkg/models/bm"
	bmservice "luban-cmdb-api/pkg/service/bm"

	"k8s.io/klog/v2"
)

var poolHostMap = make(map[string][]netPoolModel.NetWorkResource)
var bmService = bmservice.NewService()

func FetchNetWorkPool() (results []netPoolModel.NetWorkResource, err error) {
	var sqlStr = netPoolSqlStr
	////常州和昆山 没有neutron_lb库，特殊处理
	//if os.Getenv("COMMUNITY") == "nhdc" || os.Getenv("COMMUNITY") == "cloud.lakala.com" || os.Getenv("COMMUNITY") == "yun.chibi.gov.cn" {
	//	sqlStr = strings.ReplaceAll(sqlStr, "neutron_lb.", "neutron.")
	//}
	//只有yunyin环境为neutron_lb,其他环境为neutron
	sqlStr = strings.ReplaceAll(sqlStr, "neutron_lb.", "neutron.")

	err = dao.NeutronDB.Raw(sqlStr).Scan(&results).Error
	if err != nil {
		logx.Error("获取网络资源池信息失败：", err)
	}

	var pgws []netPoolModel.NetWorkResource
	err = dao.NeutronDB.Raw(netPoolpgwSqlStr).Scan(&pgws).Error
	if err != nil {
		logx.Error("获取PGW网络资源池信息失败：", err)
	} else {
		results = append(results, pgws...)
	}

	var tgws []netPoolModel.NetWorkResource
	var tgwResource = []string{"SL", "P2P", "VPN"}
	err = dao.NeutronDB.Raw(netPooltgwSqlStr).Scan(&tgws).Error
	if err != nil {
		logx.Error("获取TGW网络资源池信息失败：", err)
	} else {
		for _, tgw := range tgws {
			for _, tr := range tgwResource {
				newTgw := tgw
				newTgw.PoolName = newTgw.PoolName + tr //TGW- + SL = TGW-SL
				results = append(results, newTgw)
			}
		}
	}

	//KGW是手动添加的，需特殊处理
	var kgws []netPoolModel.NetWorkResource
	err = dao.AssetDB.Raw(netPoolSqlStrForKgw).Scan(&kgws).Error
	if err != nil {
		logx.Error("获取KGW资源池信息失败：", err)
	} else {
		results = append(results, kgws...)
	}
	return
}

func FetchInventory() (results []netPoolModel.NetWorkInventory, err error) {
	err = dao.NeutronDB.Raw(inventorySqlStr).Scan(&results).Error
	if err != nil {
		klog.Error("获取网络资源池库存信息失败：", err)
	}
	return
}

func FetchNetWorkCluster() (results []netPoolModel.Cluster, err error) {
	err = dao.NeutronDB.Raw(`SELECT * FROM neutron.clusters`).Scan(&results).Error
	if err != nil {
		klog.Error("获取网络资源池集群信息失败：", err)
	}
	return
}

func StoreNetWorkPool() {
	logx.Debugf("updateCMDBServers DEBUG -0: start ..... ")

	netPools, err := FetchNetWorkPool()
	if err != nil {
		logx.Error("获取网络资源池信息失败：", err)
		//return
	}
	logx.Debugf("updateCMDBServers DEBUG -0 - 1")

	var (
		//netPoolMap = make(map[string]map[string]interface{})
		//netTypeMap = make(map[string]map[string]interface{})
		netPoolMap = make(map[string]interface{})
		netTypeMap = map[string]interface{}{
			"LB":  make([]string, 0),
			"EIP": make([]string, 0),
			"NAT": make([]string, 0),
			"BM":  make([]string, 0), //裸金属
			"SL":  make([]string, 0), //专线
			"P2P": make([]string, 0), // peer to peer  对等连接，p2p
			"VPN": make([]string, 0), // VPN
		}
		hosts []string
	)
	for _, pool := range netPools {
		hosts = append(hosts, pool.Hosts...)
	}
	psMap := getServersWithRegion(hosts)

	clusters, err := FetchNetWorkCluster()
	if err != nil {
		klog.Errorf("FetchNetWorkCluster error: %v", err)
	}

	//pgw:2
	type2ClusterCountMap := make(map[string]int)
	for _, c := range clusters {
		count, ok := type2ClusterCountMap[c.Type]
		if ok {
			type2ClusterCountMap[c.Type] = count + 1
		} else {
			type2ClusterCountMap[c.Type] = 1
		}
	}

	for _, pool := range netPools {
		slowType := strings.ToLower(pool.PoolType)
		clusterCount, ok := type2ClusterCountMap[slowType]
		if ok {
			pool.ClusterCount = clusterCount
		} else {
			pool.ClusterCount = 1
		}
		if svr, ok := psMap[pool.Hosts[0]]; ok {
			pool.RegionCode = svr.RegionCode
			pool.RegionName = svr.RegionName
		} else {
			pool.RegionCode = "cn-shanghai-2"
			pool.RegionName = "上海二区"
		}
		//添加裸金属数量 - 因为数据不在同一个数据库中，使用sql无法直接获取
		if pool.PoolType == "PGW" {
			bmList, err := bmService.GetBmResourceList(bmmodel.ListReq{Region: pool.RegionCode, ResourcePoolName: pool.PoolName})
			if err != nil {
				klog.Errorf("GetBmResourceList error: %v", err)
				pool.BMCount = 0
			}
			pool.BMCount = bmList.TotalCount
		}

		if pool.PoolType == "TGW" {
			switch pool.PoolName {
			case "TGW-SL":
				pool.SLCount = GetSLCount()
				pool.P2PCount = getP2PCount()
				pool.VPNCount = getVPNCount()
			case "TGW-P2P":
				pool.SLCount = GetSLCount()
				pool.P2PCount = getP2PCount()
				pool.VPNCount = getVPNCount()
			case "TGW-VPN":
				pool.SLCount = GetSLCount()
				pool.P2PCount = getP2PCount()
				pool.VPNCount = getVPNCount()
			}
		}

		var poolBytes []byte
		if poolBytes, err = json.Marshal(pool); err == nil {
			key := pool.PoolName + "_" + pool.RegionCode
			netPoolMap[key] = string(poolBytes)
			for _, host := range pool.Hosts {
				//if _, ok := poolHostMap[host]; !ok {
				//	poolHostMap[host] = make([]string, 0)
				//}
				//poolHostMap[host] = append(poolHostMap[host].([]string), key)
				poolHostMap[host] = append(poolHostMap[host], pool)
			}
		}
		for typeK := range netTypeMap {
			if strings.Contains(pool.PoolName, typeK) {
				netTypeMap[typeK] = append(netTypeMap[typeK].([]string), pool.PoolName+"_"+pool.RegionCode)
			}
		}
	}
	for typeK, typeV := range netTypeMap {
		if vbates, er := json.Marshal(typeV); er == nil {
			netTypeMap[typeK] = string(vbates)
		} else {
			netTypeMap[typeK] = "[]"
		}
	}

	logx.Debugf("updateCMDBServers DEBUG cmdb_network_pool_hash :  %v ", utils.StructToJsonString(netPoolMap["TGW-P2P_cn-shanghai-2"]))

	if len(netPoolMap) > 0 {
		keyTmp := gredis.NetWorkPoolKey + "_tmp"
		ctx, celf := context.WithTimeout(context.Background(), 5*time.Second)
		defer celf()
		_, err = gredis.HMSet(ctx, keyTmp, netPoolMap)
		if err != nil {
			klog.Error("网络池列表存入redis失败：", err)
		}
		_, err = gredis.Rename(ctx, keyTmp, gredis.NetWorkPoolKey)
		if err != nil {
			gredis.Del(ctx, keyTmp)
			klog.Error("网络池列表key名称更改失败：", err)
		}
	}
	if len(netTypeMap) > 0 {
		keyTmp := gredis.NetWorkTypeMapKey + "_tmp"
		ctx, celf := context.WithTimeout(context.Background(), 5*time.Second)
		defer celf()
		_, err = gredis.HMSet(ctx, keyTmp, netTypeMap)
		if err != nil {
			klog.Error("网络池类型映射存入redis失败：", err)
		}
		_, err = gredis.Rename(ctx, keyTmp, gredis.NetWorkTypeMapKey)
		if err != nil {
			gredis.Del(ctx, keyTmp)
			klog.Error("网络池类型映射key名称更改失败：", err)
		}
	}
	logx.Debugf("updateCMDBServers DEBUG -0 - 2")
	updateCMDBServers(poolHostMap)
	poolHostMap = make(map[string][]netPoolModel.NetWorkResource)
}

func StoreInventory() {
	logx.Debugf("StoreInventory start ....")
	var (
		resourceTypes []string
		inventories   []netPoolModel.NetWorkInventory
		inventoryMap  = make(map[string]interface{})
		err           error
	)

	//TODO 暂未支持多region
	regionCode2Map, err := basic.QueryAllRegionCode2Map()
	if err != nil {
		klog.Errorf("QueryAllRegionCode2Map error: %v", err)
		return
	}
	regionCode := "cn-shanghai-2"
	var regionName string
	region, ok := regionCode2Map[regionCode]
	if ok {
		regionName = region.RegionName
	}

	logx.Debugf("StoreInventory 1 %s", regionName)

	inventories, err = FetchInventory()
	if err != nil {
		klog.Errorf("读取CMDB物理服务器资源字段失败, err:%v", err)
		return
	}
	for _, inventory := range inventories {
		resourceTypes = append(resourceTypes, inventory.PoolType)
	}
	//psMap := getResourceHardInfo(resourceTypes)
	psMap := GetResourceHardInfo()
	for i := 0; i < len(inventories); i++ {
		inventories[i].IpCount = cirdIpCount(inventories[i].Cidr) //临时补丁，中台已全部重写
		inventories[i].RegionCode = regionCode
		inventories[i].RegionName = regionName
		if svr, ok := psMap[inventories[i].PoolType]; ok {
			inventories[i].CpuTotal = svr.CpuTotal
			inventories[i].MemTotal = svr.MemTotal
		}
		if _, ok := inventoryMap[inventories[i].RegionCode]; !ok {
			inventoryMap[inventories[i].RegionCode] = make([]netPoolModel.NetWorkInventory, 0)
		}
		inventoryMap[inventories[i].RegionCode] = append(inventoryMap[inventories[i].RegionCode].([]netPoolModel.NetWorkInventory), inventories[i])
	}
	for k, v := range inventoryMap {
		var inventoryBytes []byte
		if inventoryBytes, err = json.Marshal(v); err != nil {
			delete(inventoryMap, k)
			continue
		}
		inventoryMap[k] = string(inventoryBytes)
	}
	if len(inventoryMap) > 0 {
		logx.Debugf("StoreInventory 3 %+v", inventoryMap)

		tempKey := gredis.NetWorkInventoryMapKey + "_temp"
		ctx, celf := context.WithTimeout(context.Background(), 5*time.Second)
		defer celf()
		_, err = gredis.HMSet(ctx, tempKey, inventoryMap)
		if err != nil {
			klog.Error("网络池列表存入redis失败：", err)
			return
		}
		_, err = gredis.Rename(ctx, tempKey, gredis.NetWorkInventoryMapKey)
		if err != nil {
			_, _ = gredis.Del(ctx, tempKey)
		}
		logx.Debug("StoreInventory 4 END")

	}

}

func updateCMDBServers(poolHostMap map[string][]netPoolModel.NetWorkResource) {
	logx.Debugf("updateCMDBServers DEBUG -1: %v", utils.StructToJsonString(poolHostMap))

	if len(poolHostMap) == 0 {
		return
	}
	var hosts []string
	for host := range poolHostMap {
		hosts = append(hosts, host)
	}
	servers := getUpdataRows(hosts)
	if len(servers) == 0 {
		return
	}
	logx.Debugf("updateCMDBServers DEBUG -2  getUpdataRows : %v", utils.StructToJsonString(servers))
	var resourcePoolCache = make(map[string]map[string][]string)
	for _, server := range servers {
		var (
			pools []netPoolModel.NetWorkResource
			ok    bool
		)
		//if pools, ok = poolHostMap[server.Name]; ok {
		//	for _, pool := range pools {
		//		var updateColl = make(map[string]interface{})
		//		var resourcePoolCache []string
		//		if pool.PoolName != "" && (server.ResourcePool != pool.PoolName && (len(strings.Split(server.ResourcePool, ",")) < 2 || !strings.Contains(server.ResourcePool, pool.PoolName))) { //此处代码逻辑主要是为了兼容一台服务器混布
		//			if server.ResourcePool != "" {
		//				updateColl["resource_pool"] = server.ResourcePool + "," + pool.PoolName
		//			} else {
		//				updateColl["resource_pool"] = pool.PoolName
		//			}
		//		}
		//		if server.ResourcePoolType != pool.PoolType {
		//			updateColl["resource_pool_type"] = pool.PoolType
		//		}
		//		if len(updateColl) == 0 {
		//			continue
		//		}
		//		err := dao.AssetDB.Table("asset_physical_server").
		//			Where("name = ? ", server.Name).Updates(updateColl).Error
		//		if err != nil {
		//			klog.Errorf("更新CMDB物理服务器资源字段失败：[ hostName = %v ], err:%v", server.Name, err)
		//		}
		//	}
		//}
		if resourcePoolCache[server.Name] == nil {
			resourcePoolCache[server.Name] = make(map[string][]string)
		}
		if pools, ok = poolHostMap[server.Name]; ok {
			//var updateColl = make(map[string]interface{})
			for _, pool := range pools {
				if pool.PoolName != "" { //此处代码逻辑主要是为了兼容一台服务器混布
					resourcePoolCache[server.Name]["resource_pool"] = append(resourcePoolCache[server.Name]["resource_pool"], pool.PoolName)
				}
				if pool.PoolType != "" {
					if len(resourcePoolCache[server.Name]["resource_pool_type"]) == 0 {
						resourcePoolCache[server.Name]["resource_pool_type"] = []string{pool.PoolType}
					} else {
						var b bool
						for _, s := range resourcePoolCache[server.Name]["resource_pool_type"] {
							b = s == pool.PoolType
							if b {
								break
							}
						}
						if !b {
							resourcePoolCache[server.Name]["resource_pool_type"] = append(resourcePoolCache[server.Name]["resource_pool_type"], pool.PoolType)
						}
					}
				}
			}
		}
		if len(resourcePoolCache[server.Name]) == 0 {
			delete(resourcePoolCache, server.Name)
			continue
		}
		//kgw需要单独添加
		kgw := "KGW"
		if strings.Contains(server.ResourcePool, kgw) && !utils.In(resourcePoolCache[server.Name]["resource_pool"], kgw) {
			resourcePoolCache[server.Name]["resource_pool"] = append(resourcePoolCache[server.Name]["resource_pool"], kgw)
		}
		if strings.Contains(server.ResourcePoolType, kgw) && !utils.In(resourcePoolCache[server.Name]["resource_pool_type"], kgw) {
			resourcePoolCache[server.Name]["resource_pool_type"] = append(resourcePoolCache[server.Name]["resource_pool_type"], kgw)
		}
	}
	for sname, cache := range resourcePoolCache {
		var updateColl = make(map[string]interface{})
		if len(cache["resource_pool"]) > 0 {
			updateColl["resource_pool"] = strings.Join(cache["resource_pool"], ",")
		}
		if len(cache["resource_pool_type"]) > 0 {
			updateColl["resource_pool_type"] = strings.Join(cache["resource_pool_type"], ",")
		}
		logx.Debugf("updateCMDBServers DEBUG -3  getUpdataRows : %v", utils.StructToJsonString(updateColl))
		err := dao.AssetDB.Debug().Table("asset_physical_server").
			Where("name = ? ", sname).Updates(updateColl).Error
		if err != nil {
			klog.Errorf("更新CMDB物理服务器资源字段失败：[ hostName = %v ], err:%v", sname, err)
		}
	}
	//for host, pool := range poolHostMap {
	//	updateColl["resource_pool"] = pool.PoolName
	//	updateColl["resource_pool_type"] = pool.PoolType
	//	err := dao.AssetDB.Debug().Table("asset_physical_server").
	//		Where("name = ? and (resource_pool != ? or resource_pool is null or resource_pool_type != ? or resource_pool_type is null)", host, pool.PoolName, pool.PoolType).
	//		//Where("name = ?", host).
	//		Updates(updateColl).Error
	//	if err != nil {
	//		klog.Errorf("更新CMDB物理服务器资源字段失败：[ hostName = %v ], err:%v", host, err)
	//	}
	//}
}

//func getShortHosts(hosts []string) (shortHosts []string) {
//	shortHosts = make([]string, len(hosts))
//	for i, host := range hosts {
//		sh := strings.Split(host, ".")[0]
//		shortHosts[i] = sh
//	}
//	return shortHosts
//}

func getUpdataRows(hosts []string) []PhysicalServer {
	var servers []PhysicalServer
	var err error
	err = dao.AssetDB.Table("asset_physical_server").Select("name,resource_pool,resource_pool_type").
		Where("deleted = ?", dao.DELETED_N).
		Where("name in ? ", hosts).Scan(&servers).Error
	if err != nil {
		klog.Errorf("读取CMDB物理服务器资源字段失败：[ hostName = %v ], err:%v", hosts, err)
	}
	return servers
}

func getServersWithRegion(hosts []string) map[string]PhysicalServer {
	var err error
	var servers []PhysicalServer
	var psMap = make(map[string]PhysicalServer)
	err = dao.AssetDB.
		Table("(select name,region_id from asset_physical_server where deleted = ? and name in ? ) as s", dao.DELETED_N, hosts).
		Joins("left join asset_region as r on s.region_id = r.id").
		Select("s.name, r.region_code, r.region_name").Scan(&servers).Error
	if err != nil {
		klog.Errorf("读取CMDB物理服务器资源字段失败：[ hostName = %v ], err:%v", hosts, err)
		return psMap
	}
	for _, server := range servers {
		psMap[server.Name] = server
	}
	return psMap
}

func getResourceHardInfo(resourceTypes []string) map[string]PhysicalServer {
	var err error
	var servers []PhysicalServer
	var psMap = make(map[string]PhysicalServer)
	err = dao.AssetDB.
		Table("(select region_id,resource_pool_type,cpu_total, memory_total from asset_physical_server where deleted = ? and resource_pool_type in ? ) as s", dao.DELETED_N, resourceTypes).
		Joins("left join asset_region as r on s.region_id = r.id").
		Select("r.region_code,r.region_name,s.resource_pool_type,sum(s.cpu_total) cpu_total, sum(s.memory_total) memory_total").
		Group("s.resource_pool_type,r.region_code,r.region_name").
		Scan(&servers).Error
	if err != nil {
		klog.Errorf("读取CMDB物理服务器资源字段失败：[ resourcePoolType = %v ], err:%v", resourceTypes, err)
		return psMap
	}
	for _, server := range servers {
		psMap[server.ResourcePoolType] = server
	}
	return psMap
}

func GetResourceHardInfo() map[string]PhysicalServer {
	var err error
	var servers []PhysicalServer
	var psMap = make(map[string]PhysicalServer)
	err = dao.AssetDB.Debug().
		Table("(select region_id,resource_pool_type,cpu_total, memory_total from asset_physical_server where deleted = ? ) as s", dao.DELETED_N).
		Joins("left join asset_region as r on s.region_id = r.id").
		Select("r.region_code,r.region_name,s.resource_pool_type,sum(s.cpu_total) cpu_total, sum(s.memory_total) memory_total").
		Group("s.resource_pool_type,r.region_code,r.region_name").
		Scan(&servers).Error
	if err != nil {
		klog.Errorf("读取CMDB物理服务器资源字段失败： err:%v", err)
		return psMap
	}
	for _, server := range servers {
		//XGW,SGW 特殊处理，混合部署情况
		if strings.Contains(server.ResourcePoolType, ",") {
			poolTypes := strings.Split(server.ResourcePoolType, ",")
			for _, poolType := range poolTypes {
				psMap[poolType] = server
			}
		} else {
			psMap[server.ResourcePoolType] = server
		}
	}
	return psMap
}

//func taggingEips() {
//	var (
//		ipCidrPoolNames []IpCidrPoolName
//		cidrMap         = make(map[string][]IpCidrPoolName)
//		err             error
//		result          []string
//	)
//	err = dao.NeutronDB.Raw(inventorySqlStr).Scan(&ipCidrPoolNames).Error
//	if err != nil {
//		klog.Error("tagging eips is failure. read data from mysql err: ", err.Error())
//		return
//	}
//	for _, value := range ipCidrPoolNames {
//		cidrMap[value.Cidr] = append(cidrMap[value.Cidr], value)
//	}
//	for cidr, values := range cidrMap {
//		var key = gredis.SegEipKeyPrefix + cidr
//		var ipPoolNameMap = make(map[string][]string)
//		var eips []eip.Eip
//		ctx, celf := context.WithTimeout(context.Background(), 5*time.Second)
//		result, err = gredis.ZRange(ctx, key, 0, -1)
//		celf()
//		if err != nil {
//			klog.Error(key, "read data is failure. err: ", err.Error())
//			continue
//		}
//		rsBytes := []byte("[" + strings.Join(result, ",") + "]")
//		err = json.Unmarshal(rsBytes, &eips)
//		if err != nil {
//			klog.Error(key, "unmarshal data is failure. err: ", err.Error())
//			continue
//		}
//
//	}
//}

func Scheduler() {
	if dao.NeutronDB == nil {
		klog.Info("neutron db is invalid.")
		return
	}
	StoreNetWorkPool()
	StoreInventory()
}

func GetSLCount() int {
	sql := `SELECT count(1) FROM switchphyinterfaces`
	var count int
	err := dao.NeutronDB.Raw(sql).Scan(&count).Error
	if err != nil {
		klog.Errorf("GetSLCount : %s , error: %v", sql, err)
	}
	return count
}

func getP2PCount() int {
	sql := `SELECT count(1) FROM peerings WHERE deleted = 0`
	var count int
	err := dao.NeutronDB.Raw(sql).Scan(&count).Error
	if err != nil {
		klog.Errorf("getP2PCount : %s , error: %v", sql, err)
	}
	return count
}

func getVPNCount() int {
	sql := `SELECT count(1) FROM vpntunnels WHERE deleted = 0`
	var count int
	err := dao.NeutronDB.Raw(sql).Scan(&count).Error
	if err != nil {
		klog.Errorf("getVPNCount : %s , error: %v", sql, err)
	}
	return count
}

// 网段IP数量
func cirdIpCount(cird string) int {
	_, ipv4Net, err := net.ParseCIDR(cird)
	if err != nil {
		klog.Errorf("无法解析CIDR: %s", cird)
		return 0
	}

	// 计算可用的IP数量
	mask := ipv4Net.Mask
	maskSize, _ := mask.Size()
	if maskSize >= 0 && maskSize <= 32 {
		totalIPs := 1 << (32 - maskSize) // 计算子网中的总IP数
		usableIPs := totalIPs - 2        // 计算可用的IP地址数，排除网络地址和广播地址
		// 使用 totalIPs 和 usableIPs
		return usableIPs
	} else {
		// 处理 maskSize 超出范围的情况
		fmt.Println("Error: mask size is out of range for an IPv4 address:"+cird, maskSize)
		return 0
	}
}

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/pkg/tasks/networkTask/get_test.go
```golang
package networkTask

import "testing"

func Test_1(t *testing.T) {
	r, err := FetchNetWorkCluster()
	if err != nil {
		t.Error(err)
	}
	t.Log(r)

	type2ClusterCountMap := make(map[string]int)
	for _, c := range r {
		count, ok := type2ClusterCountMap[c.Type]
		if ok {
			type2ClusterCountMap[c.Type] = count + 1
		} else {
			type2ClusterCountMap[c.Type] = 1
		}
	}

	t.Log(type2ClusterCountMap)
}

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/pkg/tasks/networkTask/sqlStr.go
```golang
package networkTask

const netPoolSqlStr = `
	select
	   agent_type,
		concat('[',group_concat(host separator ','),']') hosts,
	   case when agent_type = 'l3_agent' then 'XGW'
			when agent_type = 'neutron_ksc_lvs_agent' then 'XGW'
			when agent_type = 'neutron_ksc_nat_agent' then 'NAT'
			when agent_type = 'neutron_ksc_tengine_agent' then 'Tengine'
			when agent_type like '%QoS%' then 'SGW'
		end pool_type,
	   case when agent_type = 'l3_agent' then 'XGW-EIP'
			when agent_type = 'neutron_ksc_lvs_agent' then 'XGW-LB'
			when agent_type = 'neutron_ksc_nat_agent' then 'NAT'
			when agent_type = 'neutron_ksc_tengine_agent' then 'Tengine-LB'
	        when agent_type = 'QoS agent' then 'SGW-EIP'
		end pool_name,
	   count(1) server_count,
	   case when agent_type = 'neutron_ksc_nat_agent' then (select count(1) from neutron.natpools where deleted = 0 and type != 'direct_conn')
			else 0
		end nat_count,
	   case when agent_type = 'neutron_ksc_lvs_agent'
				then (select count(1) from neutron_lb.pools where deleted_at is null and user_tag = 'console' and id not in (select pool_id from neutron_lb.vips where tengine_cluster is not null and neutron_lb.vips.deleted_at is null))
			when agent_type = 'neutron_ksc_tengine_agent'
				then (select count(1) from neutron_lb.pools where deleted_at is null and user_tag = 'console' and id in (select pool_id from neutron_lb.vips where tengine_cluster is not null and neutron_lb.vips.deleted_at is null))
		   else 0
		end lb_count,
	   case when agent_type = 'l3_agent'
				then (select count(1) from neutron.floatingips where ifnull(xgw_cluster,default_xgw_cluster) is not null and user_tag = 'console')
	       when agent_type = 'QoS agent'
	            then (select count(1) from neutron.floatingips where ifnull(xgw_cluster,default_xgw_cluster) is not null and user_tag = 'console')
		   when agent_type = 'neutron_ksc_lvs_agent'
				then (select count(lb_pool_id) from neutron.floatingips where ifnull(xgw_cluster,default_xgw_cluster) is not null and user_tag = 'console')
		   when agent_type = 'neutron_ksc_tengine_agent'
				then (select count(1) from neutron.floatingips where ifnull(xgw_cluster,default_xgw_cluster) is not null and user_tag = 'console' and floating_ip_address in (select address from neutron_lb.vips where protocol like '%HTTP%' and deleted_at is null ))
		   else 0 end eip_count,
	   min(created_at) created_at
	from neutron.agents where admin_state_up != 0 group by agent_type having pool_type is not null
`

const netPoolpgwSqlStr = `
	select
	   agent_type,
		concat('[',group_concat(host separator ','),']') hosts,
	   case 
			when agent_type like '%Pgw%' then 'PGW'
		end pool_type,
	   case 
			when agent_type = 'Pgw agent' then 'PGW-BM'
		end pool_name,
	   count(1) server_count,
	   min(created_at) created_at
	from neutron.agents where admin_state_up != 0 and agent_type = "Pgw agent" group by agent_type having pool_type is not null
`

const netPooltgwSqlStr = `
	select
	   agent_type,
		concat('[',group_concat(host separator ','),']') hosts,
	   case 
			when agent_type like '%Tgw%' then 'TGW'
		end pool_type,
	   case 
			when agent_type = 'Tgw agent v2' then 'TGW-'
		end pool_name,
	   count(1) server_count,
	   min(created_at) created_at
	from neutron.agents where admin_state_up != 0 and agent_type = "Tgw agent v2" group by agent_type having pool_type is not null
`

const inventorySqlStr = `
	select
       'NAT' pool_type,
       nw.id network_id,
       nw.name network_name,
       nw.isp way_type,
       ns.id subnet_id,
       ns.name subnet_name,
       ns.cidr,
       ip_sum,
       ip_used,
       reserved_sum,
       ip_available,
       round(ip_used/ip_sum,2) ip_used_ratio,
       #round(ip_available/ip_sum,2) ip_available_ratio
       1 - round(ip_used/ip_sum,2) ip_available_ratio
    from neutron.natnetworks nw
    left join neutron.natsubnets ns on nw.id = ns.natnetwork_id
    left join (select
                   natnetwork_id,
                   count(1) ip_sum,
                   count(tenant_id) ip_used,
                   sum(reserved) reserved_sum,
                   count(1)-count(tenant_id)-sum(reserved) ip_available
                from neutron.natipallocations group by natnetwork_id) as x on nw.id = x.natnetwork_id
	union all
	select
		'XGW' pool_type,
		network_id,
		network_name,
		isp way_type,
		subnet_id,
		subnet_name,
		cidr,
		count(1) ip_sum,
		count(ifnull(f.device_id,f.lb_pool_id)) ip_used,
		sum(ifnull(reserved,0)) reserved_sum,
		count(1)-count(ifnull(f.device_id,f.lb_pool_id))-sum(ifnull(reserved,0)) ip_available,
		round(count(ifnull(f.device_id,f.lb_pool_id))/count(1),2) ip_used_ratio,
		#round(count(1)-count(ifnull(f.device_id,f.lb_pool_id))-sum(ifnull(reserved,0))/count(1),2) ip_available_ratio
		1 - round(count(ifnull(f.device_id,f.lb_pool_id))/count(1),2) ip_available_ratio
	from
	(select nw.id network_id,
		   nw.name network_name,
		   nw.type,
		   nw.isp,
		   sn.id subnet_id,
		   sn.name subnet_name,
		   sn.cidr,
		   sn.xgw_cluster
	from neutron.subnets sn
		left join neutron.networks nw on sn.network_id = nw.id) x
		left join neutron.floatingips f on x.network_id = f.floating_network_id and x.subnet_id = f.floating_subnet_id and (SUBSTRING_INDEX(x.cidr,'.',3) = SUBSTRING_INDEX(f.floating_ip_address,'.',3) or SUBSTRING_INDEX(x.cidr,':',3) = SUBSTRING_INDEX(f.floating_ip_address,':',3))
		left join (select floating_ip,vni,xgw_cluster from neutron.xgweips where deleted_at is null) xe
		on xe.xgw_cluster = x.xgw_cluster and xe.floating_ip = f.floating_ip_address
		left join (select vni,reserved from neutron.vnis) vni
		on xe.vni = vni.vni
	group by network_id,
			network_name,
			type,isp,
			subnet_id,
			subnet_name,
			cidr
`

const physicalServerSql = `
	select region_code,region_name,resource_pool_type,sum(cpu_total) cpu_total, sum(memory_total) memory_total
       from asset_physical_server svr left join asset_region rg on svr.region_id = rg.id
	where resource_pool_type in ('XGW','NAT') group by resource_pool_type,region_code,region_name
`

const ipCidrPoolNameSql = `
	select
		   cidr,
		   ip,
		   concat('[',group_concat(pool_name separator ','),']') pool_names
	from
	(select 'XGW-EIP' pool_name,nsub.cidr,floating_ip_address ip from neutron.floatingips nfip left join  neutron.subnets as nsub on nfip.floating_subnet_id = nsub.id where ifnull(nfip.xgw_cluster,nfip.default_xgw_cluster) is not null
	union all
	select 'XGW-LB' pool_name,nsub.cidr,floating_ip_address ip from neutron.floatingips nfip left join  neutron.subnets as nsub on nfip.floating_subnet_id = nsub.id where nfip.lb_pool_id is not null
	union all
	select 'Tengine-LB' pool_name,nsub.cidr,floating_ip_address ip from neutron.floatingips nfip left join  neutron.subnets as nsub on nfip.floating_subnet_id = nsub.id where nfip.lb_pool_id is not null and nfip.lb_pool_id in (select pool_id from neutron.vips where protocol like '%HTTP%')) x
	group by cidr, ip
`

//KGW是手动添加的，需特殊处理
const netPoolSqlStrForKgw = `
	select
		concat('[',group_concat(name separator ','),']') hosts,
		'KGW' pool_type,
		'KGW-LB' pool_name,
		count(name) server_count,
		0 nat_count,
		0 lb_count,
		0 eip_count,
		from_unixtime(create_time) created_at
	from cmdb.asset_physical_server WHERE resource_pool LIKE '%KGW%' GROUP BY pool_type,pool_name
`

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/pkg/tasks/sl-task/slTask.go
```golang
package sltask

import (
	"context"
	"encoding/json"
	"luban-cmdb-api/pkg/dao"
	"luban-cmdb-api/pkg/gredis"
	"luban-cmdb-api/pkg/models/sl"
	"luban-cmdb-api/pkg/tasks/commen"
	"luban-cmdb-api/pkg/utils"
	"time"

	"k8s.io/klog/v2"
)

func Scheduler() {
	klog.Info("sltask start ...")
	err := FetchAndCacheSlInfo()
	if err != nil {
		klog.Errorf("sltask - FetchAndCacheSlInfo error: %v", err)
		return
	}
	klog.Info("sltask end ...")
}

func FetchAndCacheSlInfo() error {
	slList, err := GetSLListFromDb()
	if err != nil {
		klog.Errorf("sltask GetSLListFromDb error: %v", err)
		return err
	}
	klog.Infof("GetSLListFromDb : %v", utils.StructToJsonString(slList))
	uuidToSlMap := make(map[string]interface{}, len(slList))
	//var cloudSlList []sl.SlInfo
	for _, v := range slList {
		cloudSl := sl.SlInfo{
			ID:             v.ID,
			Name:           v.InterfaceName,
			Status:         v.Status,
			Type:           v.ConstructionMode,
			AccessPoint:    v.IdcLocation,
			ExpirationTime: 0,
			CreateTime:     v.CreatedDate.Unix(),
			IsVlan:         v.Multiplex,
			Region:         "", //一个region一套openstack,调用的数据库部署在哪个所属区域就属于哪个所属区域  - by - by 闫耀华
			Az:             "", //因为专线属于vpc,vpc跨az   - by 闫耀华
			TenantId:       commen.GetUserIdByTenantId(v.TenantId),
			TenantName:     commen.GetUserNameByTenantId(v.TenantId),
			ProjectId:      "",
			ProjectName:    "",
		}
		//cloudSlList =  append(cloudSlList, cloudSl)
		slByte, _ := json.Marshal(v)
		uuidToSlMap[cloudSl.ID] = slByte
	}
	klog.Infof("uuidToSlMap : %v", utils.StructToJsonString(uuidToSlMap))

	hashKey := gredis.SLCloudHashKey
	_, err = gredis.Del(context.Background(), hashKey)
	if err != nil {
		klog.Errorf("sltask del error : %v", err)
		return err
	}
	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
	_, err = gredis.HMSet(ctx, hashKey, uuidToSlMap)
	defer cancel()
	if err != nil {
		klog.Errorf("sltask set error : %v", err)
		return err
	}
	return nil
}

func GetSLListFromDb() ([]Switchphyinterfaces, error) {
	sql := `SELECT * FROM switchphyinterfaces`
	var slList []Switchphyinterfaces
	err := dao.NeutronDB.Raw(sql).Scan(&slList).Error
	if err != nil {
		klog.Errorf("GetSLListFromDb : %s , error: %v", sql, err)
		return nil, err
	}
	return slList, nil
}

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/pkg/tasks/sl-task/type.go
```golang
package sltask

import "time"

//网络组数据库-专线对应表
type Switchphyinterfaces struct {
	ID               string    `gorm:"column:id"`
	TenantId         string    `gorm:"column:tenant_id"`
	InterfaceName    string    `gorm:"column:interface_name"`
	SwitchId         string    `gorm:"column:switch_id"`
	Bdi              int64     `gorm:"column:bdi"`
	DcType           string    `gorm:"column:dc_type"`
	ConstructionMode string    `gorm:"column:construction_mode"`
	Status           string    `gorm:"column:status"`
	Multiplex        int64     `gorm:"column:multiplex"`
	Bandwidth        int64     `gorm:"column:bandwidth"`
	Isp              string    `gorm:"column:isp"`
	DcName           string    `gorm:"column:dc_name"`
	IdcLocation      string    `gorm:"column:idc_location"`
	CreatedDate      time.Time `gorm:"column:created_date"`
	UpdatedDate      time.Time `gorm:"column:updated_date"`
	PopLocation      string    `gorm:"column:pop_location"`
	GroupId          string    `gorm:"column:group_id"`
	DeviceTag        string    `gorm:"column:device_tag"`
	Distance         int64     `gorm:"column:distance"`
	NocId            string    `gorm:"column:noc_id"`
	Bond             int64     `gorm:"column:bond"`
	Shared           int64     `gorm:"column:shared"`
}

func (Switchphyinterfaces) TableName() string {
	return "switchphyinterfaces"
}

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/pkg/tasks/svcinstanceTask/serviceInstanceTask.go
```golang
package svcinstanceTask

import (
	"luban-cmdb-api/pkg/dao"
	"luban-cmdb-api/pkg/models/businessManagement"
	"luban-cmdb-api/pkg/service"
	"time"

	"k8s.io/klog/v2"
)

func Scheduler() {
	klog.Infof("PersistPodInstance Task start")

	err := PersistPodInstance()
	if err != nil {
		klog.Infof("PersistPodInstance Task err:", err)
		return
	}
	klog.Infof("PersistPodInstance Task end")
}

//TODO 实时性问题后面通过k8s api watch pod event来解决
func PersistPodInstance() error {
	logTag := "PersistPodInstance"

	svcInstancesAll := []businessManagement.ServiceInstance{}
	s := service.NewBusinessManagementService()
	start := time.Now()
	podInstances, err := s.GetAllPodsByNSandDeploy(businessManagement.QueryServiceInstanceListParams{})
	if err != nil {
		klog.Errorf(logTag+"GetAllPodsByNSandDeploy error: %v", err)
		return err
	}
	//klog.Infof("podInstances: %+v", podInstances)
	svcInstancesAll = append(svcInstancesAll, podInstances...)
	klog.Infof(logTag+" - GetAllPodsByNSandDeploy time is %v", time.Since(start).Seconds())
	klog.Infof(logTag+" - GetAllPodsByNSandDeploy len is %v", len(podInstances))

	svcInsDao := dao.AssetDB.Model(&businessManagement.ServiceInstance{})

	//klog.Infof(logTag+" - svcInstancesAll  is %+v", svcInstancesAll)

	// update built_in = 1 , set deleted = 1
	err = svcInsDao.Where("built_in = ?", businessManagement.BUILT_IN_YES).Update("deleted", businessManagement.DELETED_YES).Error
	if err != nil {
		klog.Errorf(logTag+"update built_in, set deleted error: %v", err)
	}

	//insert new
	for _, ins := range svcInstancesAll {
		result := svcInsDao.Create(&ins)
		if result.Error != nil {
			klog.Errorf(logTag+"Create error: %v", err)
		}
	}

	// delete built_in = 1 , deleted = 1
	err = svcInsDao.Where("built_in = ? AND deleted = ?", businessManagement.BUILT_IN_YES, businessManagement.DELETED_YES).Delete(&businessManagement.ServiceInstance{}).Error
	if err != nil {
		klog.Errorf(logTag+"delete built_in, deleted error: %v", err)
	}

	//
	//// query by name
	//// if exit, update
	//// if !exit , insert
	//for _, ins := range svcInstancesAll {
	//	ins.BuiltIn = businessManagement.BUILT_IN_YES
	//	var insRow businessManagement.ServiceInstance
	//	if err := svcInsDao.Where("name = ?", ins.Name).First(&insRow).Error; err != nil {
	//		if errors.Is(err, gorm.ErrRecordNotFound) {
	//			//klog.Infof(logTag+"  insert V %+v", ins)
	//			result := svcInsDao.Create(&ins)
	//			if result.Error != nil {
	//				klog.Errorf(logTag+"Create error: %v", err)
	//			}
	//		} else {
	//			klog.Errorf(logTag+"Query error: %v", err)
	//			continue
	//		}
	//	} else {
	//		//klog.Infof(logTag+" update V %+v", ins)
	//		err := svcInsDao.Where("name = ?", ins.Name).Updates(&ins).Error
	//		if err != nil {
	//			klog.Errorf(logTag+"Update error: %v", err)
	//		}
	//	}
	//}
	return nil
}

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/pkg/tasks/eip-task/models.go
```golang
package eiptask

import (
	"luban-cmdb-api/pkg/utils/unixtime"
	"strconv"
	"strings"
)

type (
	EipRegion struct {
		ApiUrl        string
		AggregateCode string
		Name          string
		Code          string
	}
	NetWork struct {
		State     string
		IpVersion string
		Id        string
		Name      string
		Isp       string
		TenantId  string
		CreateAt  string
	}
	Clusters struct {
		Id   string
		Name string
	}
	SubNet struct {
		Id               string
		NetWorkId        string
		UserTag          string
		IpVersion        string
		XgwCluster       string
		Name             string
		TenantId         string
		UserId           string
		UserName         string
		CreateAt         string
		RetainedPools    []string //此字段含义为：保留位
		Cidr             string
		IpCount          int
		RetainedCount    int
		AllocatedCount   int
		UnallocatedCount int
		Eips             []*FloatingIp
	}
	FloatingIp struct {
		Id                  string
		XgwCluster          string
		RegionName          string
		RegionAggregateCode string
		NetWorkId           string
		SubNetId            string
		SubNetName          string
		IpAddress           string
		IpVersion           string
		TenantId            string
		TenantName          string
		CreateAt            unixtime.UnixTime
		UsageType           string
		UsageTag            string
		DeviceId            string
		DeviceName          string
		DeviceMac           string
		VifType             string
		LineType            string
		FixedIpAddress      string
		Ingress             int
		Egress              int
		BoundState          int //0:保留；1:未分配；2：已分配未绑定；3已绑定
		PoolNames           []string
		RowNum              float64
	}
	Vif struct {
		Ip         string
		DeviceId   string
		DeviceName string
		DeviceMac  string
		VifType    string
	}
	User struct {
		// ID is the UUID for this user.
		ID string `json:"id"`

		// Name is the human name for this user.
		Name string `json:"name"`

		// Username is the username for this user.
		Username string `json:"username"`

		// Enabled indicates whether the user is enabled (true) or disabled (false).
		Enabled bool `json:"enabled"`

		// Email is the email address for this user.
		Email string `json:"email"`

		// TenantID is the ID of the tenant to which this user belongs.
		TenantID string `json:"tenant_id"`
	}

	NeutronEip struct {
		Ingress           int               `json:"ingress"`
		IgwId             string            `json:"igw_id"`
		Egress            int               `json:"egress"`
		FloatingIpAddress string            `json:"floating_ip_address"`
		Id                string            `json:"id"`
		BindingType       string            `json:"binding_type"`
		ProjectId         string            `json:"project_id"`
		Type              string            `json:"type"`
		XgwCluster        string            `json:"xgw_cluster"`
		LbPoolId          string            `json:"lb_pool_id"`
		FloatingNetworkId string            `json:"floating_network_id"`
		UsageType         string            `json:"usage_type"`
		DeviceId          string            `json:"device_id"`
		BwpId             string            `json:"bwp_id"`
		AdminStateUp      bool              `json:"admin_state_up"`
		TenantId          string            `json:"tenant_id"`
		CreatedAt         unixtime.UnixTime `json:"created_at"`
		FixedIpAddress    string            `json:"fixed_ip_address"`
		IpVersion         int               `json:"ip_version"`
		UserTag           string            `json:"user_tag"`
	}

	Vip struct {
		Protocol       string `json:"protocol"`
		SlbType        string `json:"slb_type"`
		Id             string `json:"id"`
		LocalVipIndex  int    `json:"local_vip_index"`
		Type           string `json:"type"`
		XgwCluster     string `json:"xgw_cluster"`
		LbMethod       string `json:"lb_method"`
		TengineCluster string `json:"tengine_cluster"`
		Address        string `json:"address"`
		ProtocolPort   int    `json:"protocol_port"`
		Name           string `json:"name"`
		IpVersion      string `json:"ip_version"`
	}

	IpSubnCargo struct {
		Subn   *SubNet
		RowNum float64
	}

	IpStrSlice []string
	//MysqlEip struct {
	//	Id                string            `gorm:"column:id" json:"id"`
	//	UserTag           string            `gorm:"column:user_tag" json:"userTag"`
	//	TenantId          string            `gorm:"column:tenant_id" json:"tenantId"`
	//	FloatingIpAddress string            `gorm:"column:floating_ip_address" json:"floatingIpAddress"`
	//	FloatingNetworkId string            `gorm:"column:floating_network_id" json:"floatingNetworkId"`
	//	FloatingSubnetId  string            `gorm:"column:floating_subnet_id" json:"floatingSubnetId"`
	//	FloatingPortId    string            `gorm:"column:floating_port_id" json:"floatingPortId"`
	//	FixedPortId       string            `gorm:"column:fixed_port_id" json:"fixedPortId"`
	//	FixedIpAddress    string            `gorm:"column:fixed_ip_address" json:"fixedIpAddress"`
	//	RouterId          string            `gorm:"column:router_id" json:"routerId"`
	//	Egress            int               `gorm:"column:egress" json:"egress"`
	//	Ingress           int               `gorm:"column:ingress" json:"ingress"`
	//	DeviceId          string            `gorm:"column:device_id" json:"deviceId"`
	//	CreatedAt         unixtime.UnixTime `gorm:"column:created_at" json:"createdAt"`
	//	UpdatedAt         unixtime.UnixTime `gorm:"column:updated_at" json:"updatedAt"`
	//	UsageType         string            `gorm:"column:usage_type" json:"usageType"`
	//	BindingType       string            `gorm:"column:binding_type" json:"bindingType"`
	//	LbPoolId          string            `gorm:"column:lb_pool_id" json:"lbPoolId"`
	//	IgwId             string            `gorm:"column:igw_id" json:"igwId"`
	//	BwpId             string            `gorm:"column:bwp_id" json:"bwpId"`
	//	AdminStateUp      int               `gorm:"column:admin_state_up" json:"adminStateUp"`
	//	IpVersion         int               `gorm:"column:ip_version" json:"ipVersion"`
	//	DefaultXgwCluster string            `gorm:"column:default_xgw_cluster" json:"defaultXgwCluster"`
	//	XgwCluster        string            `gorm:"column:xgw_cluster" json:"xgwCluster"`
	//	ConfigClusters    string            `gorm:"column:config_clusters" json:"configClusters"`
	//}
)

func (ips IpStrSlice) Len() int {
	return len(ips)
}

func (ips IpStrSlice) Less(i, j int) bool {
	var (
		carries []string
		ipi     int64
		ipj     int64
	)
	if strings.Contains(ips[i], "::") {
		carries = strings.Split(ips[i], "::")
		ipi, _ = strconv.ParseInt(carries[len(carries)-1], 16, 64)
		carries = strings.Split(ips[j], "::")
		ipj, _ = strconv.ParseInt(carries[len(carries)-1], 16, 64)
	} else {
		carries = strings.Split(ips[i], ".")
		ipi, _ = strconv.ParseInt(carries[len(carries)-1], 16, 64)
		carries = strings.Split(ips[j], ".")
		ipj, _ = strconv.ParseInt(carries[len(carries)-1], 16, 64)
	}
	if ipi == 0 && ipj == 0 {
		return ips[i] < ips[j]
	}
	return ipi < ipj
}

func (ips IpStrSlice) Swap(i, j int) {
	ips[i], ips[j] = ips[j], ips[i]
}

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/pkg/tasks/eip-task/eipTool.go
```golang
package eiptask

import (
	"context"
	"encoding/json"
	"fmt"
	"github.com/google/uuid"
	"github.com/gophercloud/gophercloud"
	"io"
	"k8s.io/klog/v2"
	"luban-cmdb-api/pkg/apiserver/config"
	"luban-cmdb-api/pkg/gredis"
	"luban-cmdb-api/pkg/service"
	"luban-cmdb-api/pkg/utils/keyStone"
	"net/http"
	"regexp"
	"sort"
	"strconv"
	"strings"
	"time"
)

var (
	//TenantAccountMapping = map[string]*users.User{
	//	"7a5e0892c33d4fbeaf2bdc1e0b8d9b2b": {ID: "180000000"},
	//}
	AggregateService *service.AggregateService
)

func addHeaders(request *http.Request, headers map[string]string) *http.Request {
	token := keyStone.GetAdminToken()
	if token == "" {
		token = "d92195c970e64359acd5b8bbd24fe67c:6262a999044a4e2fa0e97aef96a53b17"
	}
	var heads = map[string]string{
		"X-Auth-Token":  token,
		"X-Auth-User":   "admin",
		"Conetent-Type": "application/json",
	}
	for k, v := range heads {
		request.Header.Add(k, v)
	}
	if headers == nil || len(headers) == 0 {
		return request
	}
	for k, v := range headers {
		request.Header.Add(k, v)
	}
	return request
}

func checkIpVersion(ipv int) string {
	switch ipv {
	case 4:
		return "IPV4"
	case 6:
		return "IPV6"
	}
	return ""
}

func ipList(netWorkId string) (ips []NeutronEip, err error) {
	resourceKey := "floatingips"
	apiUrl := NeutronBasicApi + NeutronVersion + "/" + resourceKey
	args := map[string][]string{
		"floating_network_id": {netWorkId},
	}
	resMap, err := getNetResourceList(apiUrl, args, resourceKey)
	if err != nil {
		return
	}
	bytes, err := json.Marshal(resMap)
	if err != nil {
		return
	}
	err = json.Unmarshal(bytes, &ips)
	if err != nil {
		return
	}
	return
}

func parseTime(layout, tm string) int {
	timeInt := 0
	if createAt, err := time.Parse(layout, tm); err == nil {
		timeInt = int(createAt.Unix())
	}
	return timeInt
}

func checkIpContains(ip string, ips []string) bool {
	for _, v := range ips {
		if ip == v {
			return true
		}
	}
	return false
}

func initFloatingIp(snet *SubNet, ip string, rownum float64) *FloatingIp {
	eip := &FloatingIp{}
	eip.NetWorkId = snet.NetWorkId
	eip.XgwCluster = snet.XgwCluster
	eip.SubNetId = snet.Id
	eip.SubNetName = snet.Name
	eip.IpAddress = ip
	eip.IpVersion = snet.IpVersion
	eip.TenantId = snet.TenantId
	if user, ok := TidUserMap[snet.TenantId]; ok {
		eip.TenantId = user.ID
		eip.TenantName = user.Name
	}
	eip.UsageTag = snet.UserTag
	//eip.FixedIpAddress = ip.FixedIpAddress
	//eip.CreateAt = ip.CreatedAt
	//eip.Id = ip.Id
	//eip.DeviceId = ip.DeviceId
	//eip.Ingress = ip.Ingress
	//eip.Egress = ip.Egress
	//eip.UsageType = ip.UsageType
	if checkIpContains(ip, snet.RetainedPools) {
		eip.BoundState = 0
	} else {
		eip.BoundState = 1
	}
	eip.RowNum = rownum
	return eip
}

//func parseSubNet(snet *SubNet, ipSubnMapping map[string]*[2]interface{}) map[string]*[2]interface{} {
//func parseSubNet(snet *SubNet) map[string][2]interface{} {
func parseSubNet(snet *SubNet) map[string]IpSubnCargo {
	//func parseSubNet(snet *SubNet) {
	//ipSubnMapping := make(map[string][2]interface{})
	ipSubnMapping := make(map[string]IpSubnCargo)
	var ips IpStrSlice
	c, err := ParseCIDR(snet.Cidr)
	if err != nil {
		klog.Error("cidr is invalid: ", err)
		return nil
	}
	if c.IPCount().Int64() >= 2 {
		snet.IpCount = int(c.IPCount().Int64() - 2)
		ips = IPList(c)
	} else {
		klog.Infoln(c.CIDR(), " : 网段不符合标准，计算Ip容量为空。调用neutron接口，直接取人工创建的测试ip")
		neips, err := ipList(snet.NetWorkId)
		if err != nil {
			klog.Error("调用neutron接口失败：", err)
			return nil
		}
		snet.IpCount = len(neips)
		ips = make([]string, len(neips))
		for i, neip := range neips {
			ips[i] = neip.FloatingIpAddress
		}
	}
	//if user, err := getUserByTid(snet.TenantId); err == nil {
	//	snet.UserId = user.ID
	//	snet.UserName = user.Name
	//}
	//ips, _ := ipList(snet.NetWorkId)
	sort.Sort(ips)
	index := 1
	for _, ip := range ips {
		if ip == c.Network() || ip == c.Broadcast() {
			continue
		}
		//var (
		//	carries []string
		//	endnum  int64
		//)
		//if c.IsIPv6() {
		//	carries = strings.Split(ip, "::")
		//	endnum, _ = strconv.ParseInt(carries[len(carries)-1], 16, 64)
		//} else {
		//	carries = strings.Split(ip, ".")
		//	endnum, _ = strconv.ParseInt(carries[len(carries)-1], 10, 64)
		//}
		//rowNum := float64(endnum)
		//if c.IPCount().Int64() <= 0 {
		//	rowNum = float64(i)
		//}
		rowNum := float64(index)
		eip := initFloatingIp(snet, ip, rowNum)
		snet.Eips = append(snet.Eips, eip)
		//ipSubnMapping[ip.FloatingIpAddress] = [2]interface{}{snet, rowNum}
		ipSubnMapping[ip] = IpSubnCargo{snet, rowNum}
		index++
	}
	return ipSubnMapping
}

func InitNovaClient(config *config.Config, novaclient *gophercloud.ServiceClient, identityClient *gophercloud.ServiceClient) {
	AggregateService = service.NewAggregateService(novaclient, identityClient, *config)
	klog.Info("nova.NewClient() at InitNovaClient")
	//opt := options.NewServerRunOptions()
	//var err error
	//if !opt.DisableOpenstackAPI {
	//	NovaClient, err = clientnova.NewClient(opt.Config)
	//	if err != nil {
	//		klog.Error(errors.Wrap(err, "nova.NewClient()"))
	//	}
	//	IdClient, err = clientidentity.NewClient(opt.Config)
	//	if err != nil {
	//		klog.Error(errors.Wrap(err, "nova.NewClient()"))
	//	}
	//}
	return
}

//func getUserDetailFromIdentity(userId string) (*users.User, error) {
//	if AggregateService.IdentityClient == nil {
//		return nil, nil
//	}
//	AggregateService.IdentityClient.Endpoint = "http://keystone.galaxy.cloud:35357/v2.0/"
//	var user *users.User
//	user, err := users.Get(AggregateService.IdentityClient, userId).Extract() //userid
//	if err != nil {
//		return user, err
//	}
//	klog.Info("vmDetailQuery:", userId)
//	klog.Info("user:", user)
//	return user, err
//}

func getUserIds() (uids []string) {
	var (
		result   = make(map[string]interface{})
		request  *http.Request
		resp     *http.Response
		client   = &http.Client{}
		bytes    []byte
		err      error
		uidMap   = make(map[string]struct{})
		pageSize = 1000
		pageNo   = 1
		//total    = 0
	)
	for {
		apiUrl := UserIdApiUrl + fmt.Sprintf("page=%d&per_page=%d", pageNo, pageSize)
		request, err = http.NewRequest("GET", apiUrl, nil)
		if err != nil {
			return
		}
		request = addHeaders(request, UserInfoHeader)
		resp, err = client.Do(request)
		if err != nil {
			klog.Error("fetch userInfo from "+apiUrl+"failure: ", err.Error())
			return
		}
		bytes, err = io.ReadAll(resp.Body)
		resp.Body.Close()
		if err != nil {
			return
		}
		err = json.Unmarshal(bytes, &result)
		if err != nil {
			return
		}
		if _, ok := result["errno"]; ok {
			break
		}
		if dataMap, ok := result["data"]; ok {
			if data, ok := dataMap.(map[string]interface{}); ok {
				if items, ok := data["items"]; ok {
					if itemList, ok := items.([]interface{}); ok {
						for _, item := range itemList {
							if m, ok := item.(map[string]interface{}); ok {
								if id, ok := m["user_id"]; ok {
									if idif, ok := id.(float64); ok {
										uid := strconv.Itoa(int(idif))
										uidMap[uid] = struct{}{}
									}
								}
							}
						}
					}
				}
			}
		}
		pageNo += 1
	}
	//180000000 该接口获取不到，此处手动补上
	uidMap["180000000"] = struct{}{}
	for uid := range uidMap {
		uids = append(uids, uid)
	}
	return
}

func initUserList() {
	var (
		result         = make(map[string]interface{})
		request        *http.Request
		resp           *http.Response
		client         = &http.Client{}
		bytes          []byte
		err            error
		userMap        = make(map[string]interface{})
		uids           []string
		step           = 500
		sindex, eindex = 0, step
	)
	uids = getUserIds()
	if eindex > len(uids) {
		eindex = len(uids)
	}
	for sindex < len(uids) {
		ids := uids[sindex:eindex]
		apiUrl := UserInfoApiUrl + fmt.Sprintf("ids=%s", strings.Join(ids, ","))
		request, err = http.NewRequest("GET", apiUrl, nil)
		if err != nil {
			//return userMap
			return
		}
		request = addHeaders(request, UserInfoHeader)
		resp, err = client.Do(request)
		if err != nil {
			//return userMap
			klog.Error("fetch userInfo from "+apiUrl+"failure: ", err.Error())
			return
		}
		bytes, err = io.ReadAll(resp.Body)
		resp.Body.Close()
		if err != nil {
			//return userMap
			return
		}
		err = json.Unmarshal(bytes, &result)
		if err != nil {
			//return userMap
			return
		}
		userMap = parseUserDetail(result, ids)
		if len(userMap) > 0 {
			ctx, celf := context.WithTimeout(context.Background(), 5*time.Second)
			_, err = gredis.HMSet(ctx, gredis.UserInfoKey, userMap)
			celf()
			if err != nil {
				klog.Error("userInfo data set into "+gredis.UserInfoKey+" failure: ", err.Error())
			}
		}
		sindex, eindex = sindex+step, eindex+step
		if eindex > len(uids) {
			eindex = len(uids)
		}
	}
}

func parseUserDetail(result map[string]interface{}, ids []string) map[string]interface{} {
	var (
		userMap = make(map[string]interface{})
	)
	if dataMap, ok := result["data"]; ok {
		if data, ok := dataMap.(map[string]interface{}); ok {
			for _, id := range ids {
				if b, _ := regexp.MatchString("(\\w){9}", id); !b {
					continue
				}
				if item, ok := data[id]; ok {
					if im, ok := item.(map[string]interface{}); ok {
						if basic, ok := im["basic"]; ok {
							if bm, ok := basic.(map[string]interface{}); ok {
								var user = &User{ID: id}
								if name, ok := bm["username"]; ok && name != "" {
									user.Name, _ = name.(string)
								} else {
									continue
								}
								if email, ok := bm["secure_email"]; ok {
									user.Email, _ = email.(string)
								}
								if person, ok := im["person"]; ok {
									if pm, ok := person.(map[string]interface{}); ok {
										if userName, ok := pm["name"]; ok {
											user.Username, _ = userName.(string)
										}
									}
								}
								if userByte, err := json.Marshal(user); err == nil {
									userMap[user.ID] = userByte
								}
							}
						}
					}
				}
			}
		}
	}
	return userMap
}

func getVMInstanceByHttp(userId, regionCode, boundId string) (deviceName string, err error) {
	var (
		result  = make(map[string]interface{})
		request *http.Request
		resp    *http.Response
		client  = &http.Client{}
		bytes   []byte
		//instanceMap = make(map[string]interface{})
	)
	apiUrl := vmApiUrl + "?Action=DescribeInstances&Version=2016-03-04" + "&InstanceId.1=" + boundId
	request, err = http.NewRequest("GET", apiUrl, nil)
	if err != nil {
		//return userMap
		return
	}
	header := map[string]string{
		"X-KSC-ACCOUNT-ID": userId,
		"X-KSC-REGION":     regionCode,
		"Accept":           "application/json",
		"X-KSC-REQUEST-ID": uuid.NewString(),
	}
	request = addHeaders(request, header)
	resp, err = client.Do(request)
	if err != nil {
		//return userMap
		klog.Error("fetch deviceInfo from "+apiUrl+"failure: ", err.Error())
		return
	}
	bytes, err = io.ReadAll(resp.Body)
	resp.Body.Close()
	if err != nil {
		//return userMap
		return
	}
	err = json.Unmarshal(bytes, &result)
	if err != nil {
		return
	}
	if instancesSet, ok := result["InstancesSet"]; ok {
		if instances, ok := instancesSet.([]interface{}); ok {
			if len(instances) > 0 {
				if instance, ok := instances[0].(map[string]interface{}); ok {
					if instanceName, ok := instance["InstanceName"]; ok {
						if name, ok := instanceName.(string); ok {
							deviceName = name
						}
					}
				}
			}
		}
	}
	return
}

func initTidUidMapping(client *gophercloud.ServiceClient) {
	var (
		result       gophercloud.Result
		s            = make(map[string]interface{})
		intoRedisMap = make(map[string]interface{})
		//returnMap    = make(map[string]string)
	)
	//client.Endpoint = TidUidMappingApiUrl
	resp, err := client.Get(TidUidMappingApiUrl, &result.Body, nil)
	_, result.Header, result.Err = gophercloud.ParseResponse(resp, err)
	if result.Err != nil {
		klog.Error("fetch data from "+TidUidMappingApiUrl+" failure: ", err.Error())
		//return returnMap
		return
	}
	err = result.ExtractInto(&s)
	if err != nil {
		klog.Error("Extract data for "+TidUidMappingApiUrl+" failure: ", err.Error())
		//return returnMap
		return
	}
	//klog.Info("fetch data from "+TidUidMappingApiUrl+" successful: ", s)
	if tenants, ok := s["tenants"]; ok {
		if tenantList, ok := tenants.([]interface{}); ok {
			for _, item := range tenantList {
				if tenant, ok := item.(map[string]interface{}); ok {
					if ifTid, ok := tenant["id"]; ok {
						if tid, ok := ifTid.(string); ok {
							if ifUid, ok := tenant["name"]; ok {
								if uid, ok := ifUid.(string); ok {
									intoRedisMap[tid] = uid
								}
							}
						}
					}
				}
			}
		}
	}
	if len(intoRedisMap) > 0 {
		tmpKey := gredis.TidUidMappingKey + "_tmp"
		ctx, celf := context.WithTimeout(context.Background(), 5*time.Second)
		defer celf()
		_, err = gredis.HMSet(ctx, tmpKey, intoRedisMap)
		if err != nil {
			klog.Error("set TidUidMapping data failure: ", err.Error())
			return
		}
		_, err = gredis.Rename(ctx, tmpKey, gredis.TidUidMappingKey)
		if err != nil {
			_, _ = gredis.Del(ctx, tmpKey) //清除临时缓存
			klog.Errorf("rename %s to %s failure: ", tmpKey, gredis.TidUidMappingKey, err.Error())
			return
		}
	}

}

//func initTenantAccountMapping() {
//	var intoRedisMap = make(map[string]interface{})
//	tidUidMap := initTidUidMapping(AggregateService.IdentityClient)
//	userMap := initUserList()
//	for id, uid := range tidUidMap {
//		if item, ok := userMap[uid]; ok {
//			intoRedisMap[id] = item
//		}
//	}
//	if len(intoRedisMap) > 0 {
//		ctx, celf := context.WithTimeout(context.Background(), 5*time.Second)
//		_, err := gredis.HMSet(ctx, gredis.TenantUserMappingKey, intoRedisMap)
//		celf()
//		if err != nil {
//			klog.Error("set TenantUserMapping data failure: ", err.Error())
//		}
//	}
//}

func getUserByTid(tid string) (*User, error) {
	var user = &User{}
	ctx, celf := context.WithTimeout(context.Background(), 5*time.Second)
	//rs, err := gredis.HGet(ctx, gredis.TenantUserMappingKey, tid)
	uid, err := gredis.HGet(ctx, gredis.TidUidMappingKey, tid)
	celf()
	if err != nil {
		//klog.Error("read data of "+gredis.TidUidMappingKey+" from redis failure. err: ", err.Error(), "tenantId: ", tid)
		return nil, err
	}
	//所有未分配的eip暂归admin所有
	if b, _ := regexp.MatchString("(\\w){9}", uid); !b {
		user.ID = uid
		user.Name = uid
		return user, nil
	}
	ctx, celf = context.WithTimeout(context.Background(), 5*time.Second)
	//rs, err := gredis.HGet(ctx, gredis.TenantUserMappingKey, tid)
	rs, err := gredis.HGet(ctx, gredis.UserInfoKey, uid)
	celf()
	if err != nil {
		//klog.Error("rade data of "+gredis.TenantUserMappingKey+" from redis failure. err: ", err.Error(), "tenantId: ", tid)
		klog.Error("rade data of "+gredis.UserInfoKey+" from redis failure. err: ", err.Error(), " tenantId: ", tid, uid)
		return nil, err
	}
	err = json.Unmarshal([]byte(rs), user)
	if err != nil {
		return nil, err
	}
	return user, err
}

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/pkg/tasks/eip-task/eipTask.go
```golang
package eiptask

import (
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"io"
	"luban-cmdb-api/pkg/dao/basic"
	"luban-cmdb-api/pkg/gredis"
	"luban-cmdb-api/pkg/models/aggregate"
	"luban-cmdb-api/pkg/models/eip"
	"net/http"
	"regexp"
	"strconv"
	"strings"
	"time"

	"k8s.io/klog/v2"
)

//func getEipRegions() ([]map[string]string,error) {
//	var (
//		regions = make([]map[string]string,0)
//		apiUrl = "http://neutron.galaxy.cloud:9696/v2.0/vpc/regions"
//		data = make(map[string][]map[string]string)
//		request *http.Request
//		resp *http.Response
//		client = &http.Client{}
//		bytes []byte
//		err error
//	)
//
//	request,err = http.NewRequest("GET",apiUrl,nil)
//	if err != nil {
//		return regions,err
//	}
//	request = addHeaders(request,nil)
//	resp,err = client.Do(request)
//	if err != nil {
//		return regions,err
//	}
//	defer resp.Body.Close()
//	bytes, err = io.ReadAll(resp.Body)
//	if err != nil {
//		return regions,err
//	}
//	err = json.Unmarshal(bytes, &data)
//	if err != nil {
//		return regions,err
//	}
//	regions = data["regions"]
//	return regions, err
//}

func initTidUserMap() {
	var (
		err         error
		ctx         context.Context
		celf        context.CancelFunc
		tidUidMap   map[string]string
		uidInfo     map[string]string
		tidUserInfo map[string]User
	)

	ctx, celf = context.WithTimeout(context.Background(), 5*time.Second)
	tidUidMap, err = gredis.HGetAll(ctx, gredis.TidUidMappingKey)
	defer celf()
	if err != nil {
		klog.Error("read data of "+gredis.TidUidMappingKey+" from redis failure. err: ", err.Error())
		return
	}
	uidInfo, err = gredis.HGetAll(ctx, gredis.UserInfoKey)
	if err != nil {
		klog.Error("read data of "+gredis.UserInfoKey+" from redis failure. err: ", err.Error())
		return
	}
	tidUserInfo = make(map[string]User)
	for tid, uid := range tidUidMap {
		var user = User{}
		//非业务用户(admin,service,test) 特殊处理
		if b, _ := regexp.MatchString("(\\w){9}", uid); !b {
			user.ID = uid
			user.Name = uid
			tidUserInfo[tid] = user
			continue
		}
		if ustr, ok := uidInfo[uid]; ok {
			err = json.Unmarshal([]byte(ustr), &user)
			if err != nil {
				klog.Error("unmarshal user info failure. err: ", err.Error())
				continue
			}
		}
		tidUserInfo[tid] = user
	}
	if TidUserMap == nil {
		TidUserMap = make(map[string]User)
	}
	TidUserMap = tidUserInfo
}

func dealClusters(clustersMap []map[string]interface{}) []Clusters {

	clustersList := []Clusters{}
	for _, nm := range clustersMap {
		if !strings.Contains(nm["name"].(string), "xgw_eip") {
			continue

		} else {
			clustersInfo := Clusters{}
			clustersInfo.Id, _ = nm["id"].(string)
			clustersInfo.Name, _ = nm["name"].(string)
			clustersList = append(clustersList, clustersInfo)

		}
	}
	return clustersList
}

func getNetResourceList(apiUrl string, args map[string][]string, resourceKey string) ([]map[string]interface{}, error) {
	if resourceKey == "" {
		return nil, errors.New("resourceKey must not be empty")
	}
	var (
		data    = make(map[string][]map[string]interface{})
		request *http.Request
		resp    *http.Response
		client  = &http.Client{}
		bytes   []byte
		err     error
		argStr  = ""
	)
	if args != nil && len(args) > 0 {
		argStr = "?"
		for k, vs := range args {
			for _, v := range vs {
				argStr = argStr + k + "=" + v + "&"
			}
		}
	}
	apiUrl = apiUrl + argStr
	request, err = http.NewRequest("GET", apiUrl, nil)
	if err != nil {
		return nil, err
	}
	request = addHeaders(request, nil)
	resp, err = client.Do(request)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	bytes, err = io.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	err = json.Unmarshal(bytes, &data)
	if err != nil {
		return nil, err
	}
	return data[resourceKey], err
}

func dealRegions(regionMap []map[string]interface{}) []*EipRegion {
	var (
		//result = make([]map[string]string,len(regionMap))
		result = make([]*EipRegion, len(regionMap))
	)
	for i, rgm := range regionMap {
		reg := &EipRegion{
			ApiUrl:        rgm["api_url"].(string),
			AggregateCode: rgm["name"].(string),
		}
		breg, err := basic.GetRegion(basic.Region{RegionCodeAggregate: reg.AggregateCode})
		if err == nil {
			reg.Name = breg.RegionName
			reg.Code = breg.RegionCode
		}
		result[i] = reg
	}
	return result
}

//func dealNetWorks(netMap []map[string]interface{}) ([]*NetWork, []string) {
func dealNetWorks(netMap []map[string]interface{}) []*NetWork {
	var (
		netWorks = make([]*NetWork, len(netMap))
		//tenantIdList = make([]string, 0)
		//tenantIdMap  = make(map[string]struct{})
	)
	for i, nm := range netMap {
		nwk := &NetWork{}
		nwk.State, _ = nm["status"].(string)
		//nwk.IpVersion = checkIpVersion(int(nm["ip_version"].(float64)))
		nwk.IpVersion = strconv.Itoa(int(nm["ip_version"].(float64)))
		nwk.Id, _ = nm["id"].(string)
		nwk.Isp, _ = nm["isp"].(string)
		nwk.Name, _ = nm["name"].(string)
		nwk.TenantId, _ = nm["tenant_id"].(string)
		nwk.CreateAt, _ = nm["created_at"].(string)
		netWorks[i] = nwk
		//tenantIdMap[nwk.TenantId] = struct{}{}
	}
	//for k := range tenantIdMap {
	//	tenantIdList = append(tenantIdList, k)
	//}
	//return netWorks, tenantIdList
	return netWorks
}

//func dealSubNets(subMap []map[string]interface{}) ([]*SubNet, []interface{}, map[string][2]interface{}) {
func dealSubNets(subMap []map[string]interface{}) ([]*SubNet, []interface{}, map[string]IpSubnCargo) {
	var (
		subNets   = make([]*SubNet, len(subMap))
		subnCidrs = make([]interface{}, len(subMap))
		//ipSubnMapping = make(map[string][2]interface{})
		ipSubnMapping = make(map[string]IpSubnCargo)
	)
	for i, sm := range subMap {
		subn := &SubNet{}
		subn.Id, _ = sm["id"].(string)
		subn.NetWorkId, _ = sm["network_id"].(string)
		subn.UserTag, _ = sm["user_tag"].(string)
		//subn.IpVersion = checkIpVersion(int(sm["ip_version"].(float64)))
		subn.IpVersion = strconv.Itoa(int(sm["ip_version"].(float64)))
		subn.XgwCluster, _ = sm["xgw_cluster"].(string)
		subn.Name, _ = sm["name"].(string)
		subn.TenantId, _ = sm["tenant_id"].(string)
		subn.CreateAt, _ = sm["created_at"].(string)
		pools := make([]string, 0)
		for _, v := range sm["allocation_pools"].([]interface{}) {
			pool, _ := v.(string)
			pools = append(pools, pool)
		}
		subn.RetainedPools = pools //因历史遗留为题，allocation_pools代表保留ip
		subn.Cidr, _ = sm["cidr"].(string)
		subn.RetainedCount = len(subn.RetainedPools)
		//ipSubnMappingSbu := parseSubNet(subn, ipSubnMapping)
		ipSubnMappingSbu := parseSubNet(subn)
		for k, v := range ipSubnMappingSbu {
			ipSubnMapping[k] = v
		}
		//parseSubNet(subn)
		subNets[i] = subn
		subnCidrs[i] = subn.Cidr
	}
	return subNets, subnCidrs, ipSubnMapping
}

func dealVifs(vifMap []map[string]interface{}) (map[string]*Vif, []string) {
	var (
		//vifs = make([]map[string]string,len(vifMap))
		fipVifMapping = make(map[string]*Vif)
		deviceIds     = make([]string, 0)
	)
	for _, vm := range vifMap {
		vif := &Vif{}
		vif.Ip, _ = vm["ip"].(string)
		vif.DeviceId, _ = vm["vm_id"].(string)
		vif.DeviceName, _ = vm["dev_name"].(string)
		vif.DeviceMac, _ = vm["vif_mac"].(string)
		vif.VifType, _ = vm["vif_type"].(string)
		if vif.Ip != "" {
			fipVifMapping[vif.Ip] = vif
		}
		deviceIds = append(deviceIds, vif.DeviceId)
	}
	return fipVifMapping, deviceIds

}

type Vm struct {
	aggregate.AggregatesVm
	VmName string `json:"vmName"`
}

func dealVmAndCloudDisk(deviceIds []string) map[string]string {
	var (
		idNameMap = make(map[string]string)
	)
	ctx, cefl := context.WithTimeout(context.Background(), 5*time.Second)
	defer cefl()
	rs, _ := gredis.HMGet(ctx, gredis.AggregatesVmMapKey, deviceIds)
	strRsList := make([]string, 0)
	//vmList := make([]aggregate.AggregatesVm, 0)
	vmList := make([]Vm, 0)
	for _, r := range rs {
		if str, ok := r.(string); ok {
			strRsList = append(strRsList, str)
		}
	}
	rsStr := "[" + strings.Join(strRsList, ",") + "]"
	if err := json.Unmarshal([]byte(rsStr), &vmList); err == nil {
		for _, vm := range vmList {
			//idNameMap[vm.ID] = vm.Name
			idNameMap[vm.ID] = vm.VmName
		}
	}
	return idNameMap
}

func getNeutronVips(apiUrl string) (result map[string]Vip) {
	var (
		bytes []byte
	)
	args := map[string][]string{
		"protocol": {"HTTP", "HTTPS"},
	}
	vipMap, err := getNetResourceList(apiUrl+"/v2.0/lb/vips", args, "vips")
	if err != nil {
		klog.Error(err)
	}
	bytes, err = json.Marshal(vipMap)
	if err != nil {
		return
	}
	var vips []Vip
	err = json.Unmarshal(bytes, &vips)
	if err != nil {
		return
	}
	result = make(map[string]Vip)
	for _, vip := range vips {
		if vip.Address != "" {
			result[vip.Address] = vip
		}
	}
	return
}

//func dealFloatingIps(ipMap []map[string]interface{}, reg *EipRegion, ipSubnMapping map[string][2]interface{}, apiUrl string, nwkIdMapping map[string]*NetWork) {
//func dealFloatingIps(ipMap []map[string]interface{}, reg *EipRegion, ipSubnMapping map[string]IpSubnCargo, apiUrl string, nwkIdMapping map[string]*NetWork) {
func dealFloatingIps(ipMap []map[string]interface{}, reg *EipRegion, ipSubnMapping map[string]IpSubnCargo, apiUrl string, nwkIdMapping map[string]*NetWork) (err error) {
	var (
		vifIp      = make([]string, 0)
		vifMapping = make(map[string][]*FloatingIp)
		neips      []NeutronEip
		bytes      []byte
		vipMap     map[string]Vip
	)
	bytes, err = json.Marshal(ipMap)
	if err != nil {
		return
	}
	err = json.Unmarshal(bytes, &neips)
	if err != nil {
		return
	}
	vipMap = getNeutronVips(apiUrl)
	//for _, im := range ipMap {
	for _, im := range neips {
		touple, ok := ipSubnMapping[im.FloatingIpAddress]
		if !ok {
			continue
		}
		leip := &FloatingIp{}
		//leip.Id, _ = im["id"].(string)
		//leip.NetWorkId, _ = im["floating_network_id"].(string)
		//leip.IpAddress, _ = im["floating_ip_address"].(string)
		//leip.TenantId, _ = im["tenant_id"].(string)
		//if user, err := getUserByTid(leip.TenantId); err == nil {
		//	leip.TenantId = user.ID
		//	leip.TenantName = user.Name
		//} else {
		//	leip.TenantId = ""
		//}
		//leip.CreateAt, _ = im["created_at"].(string)
		//leip.UsageType, _ = im["usage_type"].(string)
		//leip.UsageTag, _ = im["user_tag"].(string)
		////eip.DeviceId = im["device_id"].(string)
		//leip.FixedIpAddress, _ = im["fixed_ip_address"].(string)
		//ingress, _ := im["ingress"].(float64)
		//egress, _ := im["egress"].(float64)
		//leip.Ingress = int(ingress)
		//leip.Egress = int(egress)

		leip.Id = im.Id
		leip.NetWorkId = im.FloatingNetworkId
		leip.IpAddress = im.FloatingIpAddress
		if user, ok := TidUserMap[im.TenantId]; ok {
			leip.TenantId = user.ID
			leip.TenantName = user.Name
		}
		leip.CreateAt = im.CreatedAt
		leip.UsageType = im.UsageType
		leip.UsageTag = im.UserTag
		leip.FixedIpAddress = im.FixedIpAddress
		leip.Ingress = im.Ingress
		leip.Egress = im.Egress
		var poolNames = []string{"XGW-EIP"}
		if _, ture := vipMap[leip.IpAddress]; ture {
			poolNames = []string{"XGW-EIP", "XGW-LB", "Tengine-LB"}
		} else if leip.UsageType == "lb" {
			poolNames = []string{"XGW-EIP", "XGW-LB"}
		}
		leip.PoolNames = poolNames
		subn := touple.Subn
		rownumf := touple.RowNum
		leip.RowNum = rownumf
		rownum := int(rownumf)
		leip.SubNetId = subn.Id
		leip.SubNetName = subn.Name
		leip.IpVersion = subn.IpVersion

		nwk := nwkIdMapping[leip.NetWorkId]
		if nwk != nil {
			leip.LineType = nwk.Name
		}
		leip.RegionName = reg.Name
		leip.RegionAggregateCode = reg.AggregateCode
		leip.BoundState = 2
		subn.Eips[rownum-1] = leip
		subn.AllocatedCount++

		if leip.FixedIpAddress != "" {
			//leip.BoundState = 3
			vifIp = append(vifIp, leip.FixedIpAddress)
			vifMapping[leip.FixedIpAddress] = append(vifMapping[leip.FixedIpAddress], leip)
			//vif := fipVifMapping[leip.FixedIpAddress]
			//if vif != nil {
			//	leip.DeviceId = vif.DeviceId
			//	leip.DeviceMac = vif.DeviceMac
			//	leip.DeviceName = vif.DeviceName
			//	leip.VifType = vif.VifType
			//}
		}
	}
	//args := map[string][]string{
	//	"ip": vifIp,
	//}
	//vifMap, err := getNetResourceList(apiUrl+"/v2.0/vpc/vifs", args, "vifs")
	//if err != nil {
	//	klog.Errorf("read data from %s failure. err: %+v", apiUrl+"/v2.0/vpc/vifs", err)
	//	err = nil
	//}
	//防止请求参数过多，分批次请求
	for step := 0; step < len(vifIp); step += 50 {
		limit := step + 50
		if limit > len(vifIp) {
			limit = len(vifIp)
		}
		args := map[string][]string{
			"ip": vifIp[step:limit],
		}
		var vifMap []map[string]interface{}
		vifMap, err = getNetResourceList(apiUrl+"/v2.0/vpc/vifs", args, "vifs")
		if err != nil {
			klog.Errorf("read data from %s failure. err: %+v", apiUrl+"/v2.0/vpc/vifs", err)
			err = nil
			continue
		}
		if len(vifMap) > 0 {
			fipVifMapping, deviceIds := dealVifs(vifMap)
			idNameMap := dealVmAndCloudDisk(deviceIds)
			for fip, vif := range fipVifMapping {
				eipls := vifMapping[fip]
				for i := 0; i < len(eipls); i++ {
					eipls[i].DeviceId = vif.DeviceId
					eipls[i].DeviceMac = vif.DeviceMac
					eipls[i].VifType = vif.VifType
					eipls[i].BoundState = 3
					if name, ok := idNameMap[vif.DeviceId]; ok {
						eipls[i].DeviceName = name
					} else {
						if deviceName, err := getVMInstanceByHttp(eipls[i].TenantId, reg.Code, eipls[i].DeviceId); err == nil && deviceName != "" {
							eipls[i].DeviceName = deviceName
						} else {
							eipls[i].DeviceName = vif.DeviceName
						}
					}
				}
			}
		}
	}
	return
}

func fetchData() error {
	var (
		ctx        context.Context
		celf       context.CancelFunc
		segEipKeys []string
	)

	//若分布式部署，此处加分布式锁可以防止重复工作
	ctx, celf = context.WithTimeout(context.Background(), 5*time.Second)
	ok, _ := gredis.SetNX(ctx, gredis.CMDBEipTaskLock, 1, 30)
	celf()
	if !ok {
		return nil
	}
	klog.Info(fmt.Sprintf("begin to fetch eip data. time: %s...", time.Now().Format("2006-01-02 15:03:04")))
	//regionMap, err := getNetResourceList("http://neutron.galaxy.cloud:9696/v2.0/vpc/regions", nil, "regions")

	// 获取资源池分类 写入reids缓存
	clustersMap, err := getNetResourceList(NeutronClustersApiUrl, nil, "clusters")
	klog.Infof("clustersMap", clustersMap)

	clustersList := dealClusters(clustersMap)
	ctx, celf = context.WithTimeout(context.Background(), 5*time.Second)
	valueJson, _ := json.Marshal(clustersList)
	_, clustersRrr := gredis.Set(ctx, "cmdb_eip_clusters_list", valueJson, 86400)
	celf()
	if clustersRrr != nil {
		klog.Error("eip cmdb_eip_clusters_list set err ", clustersRrr)
	}

	//初始化用户信息缓存
	initUserList()
	//初始化用户id与租户id映射关系
	if AggregateService != nil && AggregateService.IdentityClient != nil {
		initTidUidMapping(AggregateService.IdentityClient)
	}
	//缓存租户id与用户信息到本地
	initTidUserMap()
	//initTenantAccountMapping()
	regionMap, err := getNetResourceList(NeutronFirstApiUrl, nil, "regions")
	if err != nil {
		return err
	}
	regions := dealRegions(regionMap)
	klog.Infof("eip regions len ", len(regions))
	ipEntityMapping := make(map[string]interface{})
	wayTypeSet := make([]interface{}, 0)
	for _, reg := range regions {
		apiUrl := reg.ApiUrl
		klog.Infof("===reg===", reg)
		args := map[string][]string{
			//"type": {"public"},
		}
		nwkMap, err := getNetResourceList(apiUrl+NeutronVersion+"/networks", args, "networks")
		if err != nil {
			return err
		}
		//nwks, tenantIdList := dealNetWorks(nwkMap)
		nwks := dealNetWorks(nwkMap)
		nwkIdMapping := make(map[string]*NetWork)
		nwkIds := make([]string, len(nwks))
		for i, nwk := range nwks {
			if user, err := getUserByTid(nwk.TenantId); err == nil {
				nwk.TenantId = user.ID
			}
			nwkIds[i] = nwk.Id
			nwkIdMapping[nwk.Id] = nwk
		}
		args = map[string][]string{
			"network_id": nwkIds,
		}
		subnMap, err := getNetResourceList(apiUrl+NeutronVersion+"/subnets", args, "subnets")
		klog.Infof("eip subnMap req url %s ", apiUrl+NeutronVersion+"/subnets")
		klog.Infof("eip subnMap %+v", subnMap)
		if err != nil {
			return err
		}
		subns, subnCidrs, ipSubnMapping := dealSubNets(subnMap)
		//var regSegMappingKey = "cmdb_eip_region_segment_mapping_" + reg.AggregateCode
		if len(subnCidrs) > 0 {
			var regSegMappingKey = gredis.RegSegMappingKeyPrefix + reg.AggregateCode
			var regSegMappingTmpKey = regSegMappingKey + "_tmp"
			ctx, celf = context.WithTimeout(context.Background(), 10*time.Second)
			_, err = gredis.SAdd(ctx, regSegMappingTmpKey, subnCidrs)
			if err != nil {
				klog.Error(regSegMappingKey, "write data to redis failed. err: ", err)
				_, _ = gredis.Del(ctx, regSegMappingTmpKey)
				celf()
				continue
			}
			_, err = gredis.Rename(ctx, regSegMappingTmpKey, regSegMappingKey)
			_, _ = gredis.Del(ctx, regSegMappingTmpKey)
			if err != nil {
				klog.Error(regSegMappingKey, "update failed. err: ", err)
				celf()
				continue
			}
			celf()
		}
		args = map[string][]string{
			"floating_network_id": nwkIds,
			//"type":                {"public"},
		}
		floatiogIpMap, err := getNetResourceList(apiUrl+NeutronVersion+"/floatingips", args, "floatingips")
		if err != nil {
			klog.Errorf("region: %s. request floatingips from url: %s,is failed. err: %+v", reg.Name, apiUrl+NeutronVersion+"/floatingips", err)
			continue
		}
		if err = dealFloatingIps(floatiogIpMap, reg, ipSubnMapping, apiUrl, nwkIdMapping); err != nil {
			klog.Errorf("region: %s. dealFloatingIps function err: %+v", reg.Name, err)
			continue
		}
		var (
			//segsRegKey     = "cmdb_eip_region_" + reg.AggregateCode
			segsRegKey     = gredis.SegsRegKeyPrefix + reg.AggregateCode
			segsToRedisMap = make(map[string]interface{})
		)
		for _, subn := range subns {
			klog.Infof("eip subn.Cidr", gredis.SegEipKeyPrefix+subn.Cidr)
			subn.UnallocatedCount = subn.IpCount - subn.RetainedCount - subn.AllocatedCount
			segment := &eip.Segment{
				Id:                  subn.Id,
				Cidr:                subn.Cidr,
				NetSegName:          subn.Name,
				RegionCode:          reg.Code,
				RegionName:          reg.Name,
				RegionAggregateCode: reg.AggregateCode,
				IpVersion:           subn.IpVersion,
				IpCount:             subn.IpCount,
				UsedIpCount:         subn.AllocatedCount,
				RemainingIpCount:    subn.UnallocatedCount,
				RetainedIpCount:     subn.RetainedCount,
				CreateTime:          parseTime("2006-01-02 15:04:05", subn.CreateAt),
			}
			var availableRatio float64
			var usedRatio float64
			if segment.IpCount != 0 {
				availableRatio = float64(segment.RemainingIpCount) / float64(segment.IpCount)
				usedRatio = float64(segment.UsedIpCount) / float64(segment.IpCount)
			}
			segment.AvailableRatio = availableRatio
			segment.UsedRatio = usedRatio
			segmByte, _ := json.Marshal(segment)
			segsToRedisMap[subn.Cidr] = segmByte

			eipList := make([]interface{}, len(subn.Eips))
			scores := make([]float64, len(subn.Eips))
			//segTrendMap := make(map[string]*eip.Segment)
			for i, elasticIp := range subn.Eips {
				var xgwCluster = elasticIp.XgwCluster
				if xgwCluster == "" {
					xgwCluster = subn.XgwCluster
				}
				if elasticIp.UsageType != "" && elasticIp.BoundState == 2 {
					elasticIp.BoundState = 3
				}
				reip := &eip.Eip{
					Id:                  elasticIp.Id,
					XgwCluster:          xgwCluster,
					IpAddr:              elasticIp.IpAddress,
					BoundState:          elasticIp.BoundState,
					NetSegName:          elasticIp.SubNetName,
					Cidr:                subn.Cidr,
					RegionCode:          reg.Code,
					RegionAggregateCode: reg.AggregateCode,
					RegionName:          reg.Name,
					IpVersion:           elasticIp.IpVersion,
					WayType:             elasticIp.LineType,
					TenantId:            elasticIp.TenantId,
					TenantName:          elasticIp.TenantName,
					BoundType:           elasticIp.UsageType,
					BoundName:           elasticIp.DeviceName,
					BoundId:             elasticIp.DeviceId,
					NetCard:             elasticIp.FixedIpAddress,
					CardType:            elasticIp.VifType,
					Bandwidth:           strconv.Itoa(elasticIp.Egress),
					RowNum:              int(elasticIp.RowNum),
					//CreateTime:          parseTime("2006-01-02 15:04:05", elasticIp.CreateAt),
					PoolNames:  elasticIp.PoolNames,
					CreateTime: elasticIp.CreateAt,
				}
				eipByte, _ := json.Marshal(reip)
				eipList[i] = eipByte
				scores[i] = elasticIp.RowNum
				ipEntityMapping[elasticIp.IpAddress] = eipByte
				wayType := strings.Trim(elasticIp.LineType, " ")
				if wayType != "" {
					wayTypeSet = append(wayTypeSet, wayType)
				}
				//segTrend
				//createDate := elasticIp.CreateAt[0:10]
				//trandSeg := segTrendMap[createDate]
				//if trandSeg != nil {
				//	trandSeg.UsedIpCount ++
				//	trandSeg.RemainingIpCount --
				//} else {
				//	segEntity := *segment
				//	segEntity.AvailableRatio = 0
				//	segEntity.UsedIpCount = 1
				//	segEntity.RemainingIpCount = segEntity.IpCount - segEntity.UsedIpCount
				//	segEntity.CreateTime = parseTime("2006-01-02",createDate)
				//}
			}
			if len(eipList) > 0 {
				segEipKey := gredis.SegEipKeyPrefix + subn.Cidr
				segEipKeyTmp := segEipKey + "_tmp"
				skip := 1024
				if len(eipList) > skip {
					remainder := 0
					if len(eipList)%skip > 0 {
						remainder = 1
					}
					stepNum := len(eipList)/skip + remainder
					ctx, celf = context.WithTimeout(context.Background(), time.Duration(stepNum*2)*time.Second)
					for i := 0; i < len(eipList); i += skip {
						limit := i + skip
						if limit > len(eipList) {
							limit = len(eipList)
						}
						_, err = gredis.ZAdd(ctx, segEipKeyTmp, scores[i:limit], eipList[i:limit])
						if err != nil {
							klog.Error(segEipKey, " eip write to redis by split failed: ", err)
							break
						}
					}
				} else {
					ctx, celf = context.WithTimeout(context.Background(), 5*time.Second)
					_, err = gredis.ZAdd(ctx, segEipKeyTmp, scores, eipList)
				}
				if err != nil {
					klog.Error(segEipKey, " eip write to redis failed: ", err)
					_, _ = gredis.Del(ctx, segEipKeyTmp)
					celf()
					continue
				}
				_, err = gredis.Rename(ctx, segEipKeyTmp, segEipKey)
				if err != nil {
					klog.Error(segEipKey, " data update failed: ", err)
					_, _ = gredis.Del(ctx, segEipKeyTmp)
					celf()
					continue
				}
				celf()
				segEipKeys = append(segEipKeys, segEipKey)
			}
		}
		segsRegKeyTmp := segsRegKey + "_tmp"
		ctx, celf = context.WithTimeout(context.Background(), 5*time.Second)
		_, err = gredis.HMSet(ctx, segsRegKeyTmp, segsToRedisMap)
		if err != nil {
			klog.Error(segsRegKey, " data write to redis failed: ", err)
			_, _ = gredis.Del(ctx, segsRegKeyTmp)
			celf()
			continue
			//return err
		}
		_, err = gredis.Rename(ctx, segsRegKeyTmp, segsRegKey)
		if err != nil {
			klog.Error(segsRegKey, " data update failed: ", err)
			_, _ = gredis.Del(ctx, segsRegKeyTmp)
			celf()
			continue
			//return err
		}
		celf()
	}
	//删除旧的segEipKeys
	if len(segEipKeys) > 0 {
		var cidrKeys []string
		ctx, celf = context.WithTimeout(context.Background(), 5*time.Second)
		cidrKeys, _ = gredis.Keys(ctx, gredis.SegEipKeyPrefix+"*")
		if len(cidrKeys) > len(segEipKeys) {
			segEipMap := make(map[string]struct{})
			for _, key := range segEipKeys {
				segEipMap[key] = struct{}{}
			}
			for _, key := range cidrKeys {
				if _, ok = segEipMap[key]; !ok {
					_, _ = gredis.Del(ctx, key)
				}
			}
		}
		celf()
	}
	//所有eip
	allIpEntityKey := gredis.AllIpEntityKey
	allIpEntityKeyTemp := allIpEntityKey + "_temp"
	ctx, celf = context.WithTimeout(context.Background(), 5*time.Second)
	_, err = gredis.HMSet(ctx, allIpEntityKeyTemp, ipEntityMapping)
	if err == nil {
		_, err = gredis.Rename(ctx, allIpEntityKeyTemp, allIpEntityKey)
		if err != nil {
			_, _ = gredis.Del(ctx, allIpEntityKeyTemp)
		}
	}
	celf()

	//eip线路类型
	wayTypeSetKey := gredis.WayTypeSetKey
	wayTypeSetKeyTmp := wayTypeSetKey + "_tmp"
	ctx, celf = context.WithTimeout(context.Background(), 5*time.Second)
	_, err = gredis.SAdd(ctx, wayTypeSetKeyTmp, wayTypeSet)
	if err == nil {
		_, err = gredis.Rename(ctx, wayTypeSetKeyTmp, wayTypeSetKey)
		if err != nil {
			_, _ = gredis.Del(ctx, wayTypeSetKeyTmp)
		}
	}
	celf()

	//释放分布式锁
	ctx, celf = context.WithTimeout(context.Background(), 5*time.Second)
	_, _ = gredis.Del(ctx, gredis.CMDBEipTaskLock)
	celf()

	klog.Info(fmt.Sprintf("fetch eip data finished. time: %s...", time.Now().Format("2006-01-02 15:03:04")))
	return err
}

func Scheduler() {
	_ = fetchData()
	// time.Sleep(10 * time.Second)
	// _ = fetchData()
	// ticker := time.NewTicker(time.Hour)
	// //ticker := time.NewTicker(1 * time.Minute)
	// for range ticker.C {
	// 	_ = fetchData()
	// }
}

// func init() {
// 	go Scheduler()
// }

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/pkg/tasks/eip-task/utils.go
```golang
package eiptask

import (
	"math/big"
	"net"
)

type CIDR struct {
	ip    net.IP
	ipnet *net.IPNet
}

// 解析CIDR网段
func ParseCIDR(s string) (*CIDR, error) {
	i, n, err := net.ParseCIDR(s)
	if err != nil {
		return nil, err
	}
	return &CIDR{ip: i, ipnet: n}, nil
}

// 判断是否IPv4
func (c CIDR) IsIPv4() bool {
	_, bits := c.ipnet.Mask.Size()
	return bits/8 == net.IPv4len
}

// 判断是否IPv6
func (c CIDR) IsIPv6() bool {
	_, bits := c.ipnet.Mask.Size()
	return bits/8 == net.IPv6len
}

// 判断IP是否包含在网段中
func (c CIDR) Contains(ip string) bool {
	return c.ipnet.Contains(net.ParseIP(ip))
}

// 根据子网掩码长度校准后的CIDR
func (c CIDR) CIDR() string {
	return c.ipnet.String()
}

// 网络号
func (c CIDR) Network() string {
	return c.ipnet.IP.String()
}

// 广播地址(网段最后一个IP)
func (c CIDR) Broadcast() string {
	mask := c.ipnet.Mask
	bcst := make(net.IP, len(c.ipnet.IP))
	copy(bcst, c.ipnet.IP)
	for i := 0; i < len(mask); i++ {
		ipIdx := len(bcst) - i - 1
		bcst[ipIdx] = c.ipnet.IP[ipIdx] | ^mask[len(mask)-i-1]
	}
	return bcst.String()
}

// IP数量
func (c CIDR) IPCount() *big.Int {
	ones, bits := c.ipnet.Mask.Size()
	return big.NewInt(0).Lsh(big.NewInt(1), uint(bits-ones))
}

func IPList(c *CIDR) []string {
	var ips = make([]string, c.IPCount().Int64())
	index := 0
	next := make(net.IP, len(c.ipnet.IP))
	copy(next, c.ipnet.IP)
	for c.ipnet.Contains(next) {
		//ip := make(net.IP, len(next))
		//copy(ip, next)
		ips[index] = next.String()
		index++
		next = IncrIP(next)
	}
	return ips
}

// IP地址自增
func IncrIP(ip net.IP) net.IP {
	for i := len(ip) - 1; i >= 0; i-- {
		ip[i]++
		if ip[i] > 0 {
			break
		}
	}
	return ip
}

// IP地址自减
func DecrIP(ip net.IP) {
	length := len(ip)
	for i := length - 1; i >= 0; i-- {
		ip[length-1]--
		if ip[length-1] < 0xFF {
			break
		}
		for j := 1; j < length; j++ {
			ip[length-j-1]--
			if ip[length-j-1] < 0xFF {
				return
			}
		}
	}
}

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/pkg/tasks/eip-task/constant.go
```golang
package eiptask

import (
	"fmt"
	"os"
)

var (
	NeutronVersion        = "/v2.0"
	NeutronBasicApi       = "http://neutron.galaxy.cloud:9696"
	NeutronFirstApiUrl    = NeutronBasicApi + NeutronVersion + "/vpc/regions"
	NeutronClustersApiUrl = NeutronBasicApi + NeutronVersion + "/vpc/clusters"

	//用户信息url
	UserApiUrl     = fmt.Sprintf("http://profile.inner.%s/admin/users?type=1", os.Getenv("GALAXY_SUB_DOMAIN")) //sdns.cqpcloud.cn
	UserInfoApiUrl = fmt.Sprintf("http://profile.inner.%s/basic_info/users?", os.Getenv("GALAXY_SUB_DOMAIN"))
	UserIdApiUrl   = fmt.Sprintf("http://profile.inner.%s/admin/brief/users?", os.Getenv("GALAXY_SUB_DOMAIN"))

	//openStack tenantId-UserId url
	NovaVersion         = "/v2.0"
	TidUidMappingApiUrl = "http://keystone.galaxy.cloud:35357" + NovaVersion + "/tenants"
	//TidUidMappingApiUrl = "http://keystone.galaxy.cloud:35357" + NovaVersion

	//虚拟实例url
	vmApiUrl = fmt.Sprintf("http://ecs.inner.%s/", os.Getenv("GALAXY_SUB_DOMAIN"))
)

var (
	UserInfoHeader = map[string]string{
		"Authorization": "Basic a2VjOjUxNTViZDczZTJiZDI1ZGViNzRmMjk4MDk4ODRiNGM4",
	}
	TidUserMap map[string]User
)

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/pkg/tasks/commen/neutron.go
```golang
package commen

import (
	"context"
	"encoding/json"
	"io"
	"luban-cmdb-api/pkg/gredis"
	"luban-cmdb-api/pkg/utils/keyStone"
	"net/http"
	"regexp"
	"time"

	"k8s.io/klog/v2"
)

func GetVpcDomainsFromNeutronApi(host string) ([]VPCDomain, error) {
	apiUrl := host + "/v2.0/vpc/domains"
	request, err := http.NewRequest("GET", apiUrl, nil)
	if err != nil {
		return nil, err
	}
	request = AddHeaders(request, nil)

	client := &http.Client{}
	resp, err := client.Do(request)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	bytes, err := io.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var data VPCDomains
	err = json.Unmarshal(bytes, &data)
	if err != nil {
		return nil, err
	}
	return data.Domains, nil
}

func GetUserNameByTenantId(tid string) string {
	if tid == "" {
		return ""
	}
	u, err := GetUserByTenantId(tid)
	if err != nil {
		return ""
	}
	return u.Name
}

func GetUserNameByUserId(uid string) string {
	if uid == "0" {
		return ""
	}
	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
	defer cancel()
	rs, err := gredis.HGet(ctx, gredis.UserInfoKey, uid)
	if err != nil {
		klog.Error("rade data of "+gredis.UserInfoKey+" from redis failure. err: ", err.Error(), " uid: ", uid)
		return ""
	}
	var user = &User{}
	err = json.Unmarshal([]byte(rs), user)
	if err != nil {
		return ""
	}
	return user.Name
}

func GetUserIdByTenantId(tid string) string {
	if tid == "" {
		return ""
	}
	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
	defer cancel()
	uid, err := gredis.HGet(ctx, gredis.TidUidMappingKey, tid)
	if err != nil {
		return ""
	}
	return uid
}

func GetUserByTenantId(tid string) (*User, error) {
	var user = &User{}
	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
	defer cancel()
	uid, err := gredis.HGet(ctx, gredis.TidUidMappingKey, tid)
	if err != nil {
		//klog.Error("read data of "+gredis.TidUidMappingKey+" from redis failure. err: ", err.Error(), "tenantId: ", tid)
		return nil, err
	}
	//所有未分配的eip暂归admin所有
	if b, _ := regexp.MatchString("(\\w){9}", uid); !b {
		user.ID = uid
		user.Name = uid
		return user, nil
	}
	ctx, cancel = context.WithTimeout(context.Background(), 5*time.Second)
	defer cancel()
	rs, err := gredis.HGet(ctx, gredis.UserInfoKey, uid)
	if err != nil {
		klog.Error("rade data of "+gredis.UserInfoKey+" from redis failure. err: ", err.Error(), " tenantId: ", tid, uid)
		return nil, err
	}
	err = json.Unmarshal([]byte(rs), user)
	if err != nil {
		return nil, err
	}
	return user, err
}

func AddHeaders(request *http.Request, headers map[string]string) *http.Request {
	token := keyStone.GetAdminToken()
	if token == "" {
		token = "d92195c970e64359acd5b8bbd24fe67c:6262a999044a4e2fa0e97aef96a53b17"
	}
	//token := "d92195c970e64359acd5b8bbd24fe67c:6262a999044a4e2fa0e97aef96a53b17"

	var heads = map[string]string{
		"X-Auth-Token": token,
		"X-Auth-User":  "admin",
		"Content-Type": "application/json",
	}
	for k, v := range heads {
		request.Header.Add(k, v)
	}
	if headers == nil || len(headers) == 0 {
		return request
	}
	for k, v := range headers {
		request.Header.Add(k, v)
	}
	return request
}

func ParseTime(layout, tm string) int {
	timeInt := 0
	if createAt, err := time.Parse(layout, tm); err == nil {
		timeInt = int(createAt.Unix())
	}
	return timeInt
}

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/pkg/tasks/commen/type.go
```golang
package commen

//http://{{neutron_host}}:9696/v2.0/vpc/domains
type VPCDomains struct {
	Domains []VPCDomain `json:"domains"`
}

type VPCDomain struct {
	UpdatedDate  interface{} `json:"updated_date"`
	Name         string      `json:"name"`
	Deleted      bool        `json:"deleted"`
	TenantID     string      `json:"tenant_id"`
	CreatedDate  string      `json:"created_date"`
	Mask         int         `json:"mask"`
	L3GwOn       bool        `json:"l3gw_on"`
	IP           string      `json:"ip"`
	EnableIpv6   bool        `json:"enable_ipv6"`
	Ipv6Cidr     interface{} `json:"ipv6_cidr"`
	Type         interface{} `json:"type"`
	SipDrop      bool        `json:"sip_drop"`
	CenID        interface{} `json:"cen_id"`
	CenTenantID  interface{} `json:"cen_tenant_id"`
	ID           string      `json:"id"`
	RegionIpv6ID string      `json:"region_ipv6_id"`
}

type User struct {
	// ID is the UUID for this user.
	ID string `json:"id"`

	// Name is the human name for this user.
	Name string `json:"name"`

	// Username is the username for this user.
	Username string `json:"username"`

	// Enabled indicates whether the user is enabled (true) or disabled (false).
	Enabled bool `json:"enabled"`

	// Email is the email address for this user.
	Email string `json:"email"`

	// TenantID is the ID of the tenant to which this user belongs.
	TenantID string `json:"tenant_id"`
}

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/pkg/tasks/sdn-exporter-task/sdnTask.go
```golang
package sdn_exporter_task

import (
	"context"
	"k8s.io/klog/v2"
	"luban-cmdb-api/pkg/models/netPoolModel"
	"luban-cmdb-api/pkg/service/networkPool"
	"luban-cmdb-api/pkg/service/sdn"
	"sort"
	"time"
)

func getResourcePoolEip(poolNameSlice []string) []string {
	reqParam := netPoolModel.PhyIpListQuery{
		PoolNameSlice: poolNameSlice,
	}
	svc := networkPool.NewService()
	rest, err := svc.GetPoolManagementIps(reqParam)
	if err != nil {
		return nil
	}
	return rest
}

func InitSdnCronTask() {
	for {
		sdnIpList := getResourcePoolEip([]string{"XGW", "NAT", "TENGINE", "KGW", "TGW", "SGW"})
		klog.Info("sdnIpList", sdnIpList)
		sort.Strings(sdnIpList)
		if len(sdnIpList) > 0 {
			var sdnList = make([]sdn.SdnAddressInfo, 0)
			for i := range sdnIpList {
				sdnList = append(sdnList, sdn.SdnAddressInfo{Ip: sdnIpList[i]})
			}
			var rp = sdn.NewRegisterPmService(sdnList)
			rp.RegisterPmSvcMonitor(sdn.SdnNodes, []string{}, context.TODO())
			rp.SdnAddressList = sdnList
			rp.RegisterPmSdnEndpoint(context.TODO())
		}
		time.Sleep(30 * time.Minute)
	}
}

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/pkg/tasks/lb-task/lbTask_test.go
```golang
package lb_task

import (
	"testing"

	"k8s.io/klog/v2"
)

func Test1(t *testing.T) {
	host := "http://10.178.224.72:9696"

	vips, err := GetVipsFromNeutronApi(host)
	if err != nil {
		klog.Error(err)
		return
	}

	tengineCount := 0

	//pool_id: [XGW,Tengine]
	poolIdToTypeMap := make(map[string]ResourcePoolType)
	for _, vip := range vips {
		if vip.TengineCluster != "" {
			klog.Info(vip.PoolID)
			tengineCount++
			poolIdToTypeMap[vip.PoolID] = ResourcePoolType{PoolId: vip.PoolID, Type: "Tengine", Name: "Tengine-LB", Region: "cn-shanghai-2"}
		} else {
			if _, ok := poolIdToTypeMap[vip.PoolID]; !ok {
				poolIdToTypeMap[vip.PoolID] = ResourcePoolType{PoolId: vip.PoolID, Type: "XGW", Name: "XGW-LB", Region: "cn-shanghai-2"}
			}
		}
	}

	klog.Info(tengineCount)

	list, err := GetLbListFromNeutronApi(host)
	if err != nil {
		klog.Error(err)
		return
	}

	klog.Info(len(list))

	tCount := 0

	for _, v := range list {
		if v.ID == "b1f1dc52-7e83-48ae-96a0-341fc3adc591" {
			klog.Info("找到 b1f1dc52-7e83-48ae-96a0-341fc3adc591")
			t, ok := poolIdToTypeMap[v.ID]
			klog.Info(ok)
			klog.Infof("%+v", t)
		}

		t, ok := poolIdToTypeMap[v.ID]
		if ok && t.Type == "Tengine" {
			klog.Info(v.ID)
			tCount++
		}

	}

	klog.Info(tCount)

}

// print test1

func Test2(t *testing.T) {
	host := "http://10.178.224.72:9696"
	err := FetchAndCacheLbInfo(host)
	if err != nil {
		t.Logf("%v", err)
		return
	}
}

func Test3(t *testing.T) {
	ids := []string{"fd1409d1-afbf-4bb7-8271-4c9f3c216009"}
	result, err := QueryProjectNameByInstanceIds(ids)
	if err != nil {
		return
	}

	t.Logf("%+v", result)
}

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/pkg/tasks/lb-task/type.go
```golang
package lb_task

//http://{{neutron_host}}:9696/v2.0/lb/pools
type LB struct {
	Pools []Pool `json:"pools"`
}

type Pool struct {
	Description   string      `json:"description"`
	VipNum        int         `json:"vip_num"`
	UpdatedAt     interface{} `json:"updated_at"`
	Address       string      `json:"address"`
	SlbType       string      `json:"slb_type"`
	ID            string      `json:"id"`
	Name          string      `json:"name"`
	AdminStateUp  bool        `json:"admin_state_up"`
	EnabledLog    bool        `json:"enabled_log"`
	TenantID      string      `json:"tenant_id"`
	CreatedAt     string      `json:"created_at"`
	UserTag       string      `json:"user_tag"`
	DomainID      string      `json:"domain_id"`
	VnetID        interface{} `json:"vnet_id"`
	ProjectID     string      `json:"project_id"`
	Type          string      `json:"type"`
	IPVersion     string      `json:"ip_version"`
	IsPerformance bool        `json:"is_performance"`
	LbflavorID    interface{} `json:"lbflavor_id"`
	Status        string      `json:"status"`
	XgwCluster    string      `json:"xgw_cluster"`
}

//http://{{neutron_url}}:9696/v2.0/lb/vips
type Vips struct {
	Vips []Vip `json:"vips"`
}

// Vip 监听器
type Vip struct {
	Protocol           string             `json:"protocol"`
	UpdatedAt          string             `json:"updated_at"`
	Servers            []interface{}      `json:"servers"`
	SlbType            string             `json:"slb_type"`
	LbKind             interface{}        `json:"lb_kind"`
	SynProxy           bool               `json:"syn_proxy"`
	ID                 string             `json:"id"`
	Emode              interface{}        `json:"emode"`
	ProjectID          string             `json:"project_id"`
	Type               string             `json:"type"`
	XgwCluster         interface{}        `json:"xgw_cluster"`
	LbMethod           string             `json:"lb_method"`
	Description        string             `json:"description"`
	CertificateID      interface{}        `json:"certificate_id"`
	TengineCluster     string             `json:"tengine_cluster"`
	RsIPVersion        interface{}        `json:"rs_ip_version"`
	SlbaclID           string             `json:"slbacl_id"`
	Members            []interface{}      `json:"members"`
	Address            interface{}        `json:"address"`
	ProtocolPort       int                `json:"protocol_port"`
	MemberNum          int                `json:"member_num"`
	Name               string             `json:"name"`
	AdminStateUp       bool               `json:"admin_state_up"`
	TenantID           string             `json:"tenant_id"`
	Mgroups            []interface{}      `json:"mgroups"`
	PoolID             string             `json:"pool_id"`
	SessionPersistence SessionPersistence `json:"session_persistence"`
}

type SessionPersistence struct {
	CookieType   interface{} `json:"cookie_type"`
	CookieName   interface{} `json:"cookie_name"`
	Timeout      int         `json:"timeout"`
	AdminStateUp bool        `json:"admin_state_up"`
}

type HealthMonitors struct {
	HealthMonitors []HealthMonitor `json:"health_monitors"`
}
type HealthMonitor struct {
	CheckBind    interface{} `json:"check_bind"`
	URLPath      interface{} `json:"url_path"`
	Protocol     string      `json:"protocol"`
	VipID        string      `json:"vip_id"`
	ServerName   interface{} `json:"server_name"`
	AdminStateUp bool        `json:"admin_state_up"`
	TenantID     string      `json:"tenant_id"`
	Rise         int         `json:"rise"`
	CheckData    interface{} `json:"check_data"`
	Delay        int         `json:"delay"`
	ProjectID    string      `json:"project_id"`
	HTTPMethod   interface{} `json:"http_method"`
	CheckRet     interface{} `json:"check_ret"`
	Timeout      int         `json:"timeout"`
	Fall         int         `json:"fall"`
	ProtocolPort interface{} `json:"protocol_port"`
	UserTag      string      `json:"user_tag"`
	ID           string      `json:"id"`
}

type Slbacls struct {
	Slbacls []Slbacl `json:"slbacls"`
}
type Slbaclrules struct {
	Description interface{} `json:"description"`
	UpdatedAt   interface{} `json:"updated_at"`
	SlbaclID    string      `json:"slbacl_id"`
	Cidr        string      `json:"cidr"`
	ID          string      `json:"id"`
	TenantID    string      `json:"tenant_id"`
	CreatedAt   string      `json:"created_at"`
	Priority    int         `json:"priority"`
	Action      string      `json:"action"`
	ProjectID   string      `json:"project_id"`
	UserTag     string      `json:"user_tag"`
}
type Slbacl struct {
	Name        string        `json:"name"`
	TenantID    string        `json:"tenant_id"`
	CreatedAt   string        `json:"created_at"`
	UpdatedAt   string        `json:"updated_at"`
	Slbaclrules []Slbaclrules `json:"slbaclrules"`
	IPVersion   string        `json:"ip_version"`
	ProjectID   string        `json:"project_id"`
	UserTag     string        `json:"user_tag"`
	ID          string        `json:"id"`
}

type ResourcePoolType struct {
	PoolId string //lb的id,不是资源池
	Type   string
	Name   string
	Region string
}

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/pkg/tasks/lb-task/lbTask.go
```golang
package lb_task

import (
	"context"
	"encoding/json"
	"errors"
	"io"
	"luban-cmdb-api/pkg/dao"
	"luban-cmdb-api/pkg/gredis"
	"luban-cmdb-api/pkg/models/lb"
	"luban-cmdb-api/pkg/tasks/commen"
	"luban-cmdb-api/pkg/utils/collection"
	"net/http"
	"time"

	"k8s.io/klog/v2"
)

func Scheduler() {
	klog.Info("lbtask start ...")
	host := "http://neutron.galaxy.cloud:9696"
	err := FetchAndCacheLbInfo(host)
	if err != nil {
		klog.Errorf("FetchAndCacheLbInfo error: %v", err)
		return
	}
	klog.Info("lbtask end ...")
}

// 相关api文档地址:http://10.178.224.72/neutron/slb.html#704
func FetchAndCacheLbInfo(host string) error {
	list, err := GetLbListFromNeutronApi(host)
	if err != nil {
		klog.Error(err)
		return err
	}
	klog.Info("lbtask getlbList 1")
	klog.Info(len(list))
	klog.Info("lbtask getlbList 2")

	lbNetTypeList, err := queryLbNetTypeFromNeutronDB()
	if err != nil {
		klog.Error(err)
		return err
	}

	ipToRqMap := make(map[string]LbNetType, len(*lbNetTypeList))
	for _, r := range *lbNetTypeList {
		ipToRqMap[r.FloatingIpAddress] = r
	}

	vpcdomains, err := commen.GetVpcDomainsFromNeutronApi(host)
	if err != nil {
		klog.Error(err)
		return err
	}
	klog.Info(len(vpcdomains))
	domainIdToDomainMap := make(map[string]commen.VPCDomain, len(vpcdomains))
	for _, d := range vpcdomains {
		domainIdToDomainMap[d.ID] = d
	}

	vips, err := GetVipsFromNeutronApi(host)
	if err != nil {
		klog.Error(err)
		return err
	}
	poolIdToVipsMap := make(map[string][]Vip, len(vips))
	for _, v := range vips {
		poolIdToVipsMap[v.PoolID] = append(poolIdToVipsMap[v.PoolID], v)
	}

	healthMonitors, err := GetHealthMonitorsFromNeutronApi(host)
	if err != nil {
		klog.Error(err)
		return err
	}
	vipIdToHealthMonitorMap := make(map[string]HealthMonitor, len(healthMonitors))
	for _, h := range healthMonitors {
		vipIdToHealthMonitorMap[h.VipID] = h
	}

	lbacls, err := GetSlbaclsFromNeutronApi(host)
	if err != nil {
		klog.Error(err)
		return err
	}
	aclIdToAclMap := make(map[string]Slbacl, len(lbacls))
	for _, acl := range lbacls {
		aclIdToAclMap[acl.ID] = acl
	}

	//pool_id: [XGW,Tengine]
	poolIdToTypeMap := make(map[string]ResourcePoolType)
	for _, vip := range vips {
		if vip.TengineCluster != "" {
			poolIdToTypeMap[vip.PoolID] = ResourcePoolType{PoolId: vip.PoolID, Type: "Tengine", Name: "Tengine-LB", Region: "cn-shanghai-2"}
		} else {
			if _, ok := poolIdToTypeMap[vip.PoolID]; !ok { // 即是Tengine又是XGW，则取Tengine
				poolIdToTypeMap[vip.PoolID] = ResourcePoolType{PoolId: vip.PoolID, Type: "XGW", Name: "XGW-LB", Region: "cn-shanghai-2"}
			}
		}
	}

	//TODO type 和 region 目前只有两种，暂时写死，后期有增加再解析
	//
	//ctx, celf := context.WithTimeout(context.Background(), 5*time.Second)
	//networkTypeStr, err := gredis.HGet(ctx, gredis.NetWorkTypeMapKey, "LB")
	//celf()
	//if err != nil {
	//	klog.Error(fmt.Sprintf("redis read data from hash:%s field:%s error. err: %+v", gredis.NetWorkTypeMapKey, "LB", err))
	//	return
	//}
	//var networkType []string
	//err = json.Unmarshal([]byte(networkTypeStr), &networkType)
	//if err != nil {
	//	klog.Error(fmt.Sprintf("unmarshal %s to []string error. err: %+v", networkTypeStr, err))
	//	return
	//}

	ids := collection.NewSet()
	for _, v := range list {
		ids.AddStr(v.ID)
	}
	instanceProjectList, err := QueryProjectNameByInstanceIds(ids.KeysStr())
	if err != nil {
		return err
	}
	instanceIdToProjectNameMap := make(map[string]string)
	for _, p := range instanceProjectList {
		if _, ok := instanceIdToProjectNameMap[p.InstanceId]; !ok {
			instanceIdToProjectNameMap[p.InstanceId] = p.ProjectName
		}
	}

	lbList := make([]interface{}, len(list))
	scores := make([]float64, len(list))
	lbMap := make(map[string]interface{}, len(list))
	for i, v := range list {

		listeners := make([]lb.Listener, 0)
		for _, l := range poolIdToVipsMap[v.ID] {
			listener := lb.Listener{
				Name:            l.Name,
				ID:              l.ID,
				State:           l.AdminStateUp,
				NetworkProtocol: l.Protocol,
				Port:            l.ProtocolPort,
				ForwardType:     l.LbMethod,
				KeepAlive:       l.SessionPersistence.AdminStateUp,
				HealthCheck:     vipIdToHealthMonitorMap[l.ID].AdminStateUp,
				ACL:             aclIdToAclMap[l.SlbaclID].Name,
				BackgroundNum:   l.MemberNum,
			}
			listeners = append(listeners, listener)
		}

		state := ""
		if v.AdminStateUp {
			state = "active"
		} else {
			state = "stop"
		}

		resourcePoolType, ok := poolIdToTypeMap[v.ID]
		var poolType, poolName string
		if !ok {
			poolType = "XGW"
			poolName = "XGW-LB"
		} else {
			poolType = resourcePoolType.Type
			poolName = resourcePoolType.Name
		}

		lbInfo := lb.LbInfo{
			ResourcePoolType: poolType,
			ResourcePoolName: poolName,
			Region:           "cn-shanghai-2",
			InstanceName:     v.Name,
			InstanceId:       v.ID,
			State:            state,
			InstanceType:     v.SlbType,
			IpVersion:        v.IPVersion,
			NetType:          ipToRqMap[v.Address].Type,
			//TenantId:         v.TenantID,
			TenantId:        commen.GetUserIdByTenantId(v.TenantID), //页面显示的租户id，实际内容应为用户id
			TenantName:      commen.GetUserNameByTenantId(v.TenantID),
			ProjectId:       v.ProjectID,
			ProjectName:     instanceIdToProjectNameMap[v.ID],
			VPCInstanceName: domainIdToDomainMap[v.DomainID].Name,
			Eip:             v.Address,
			LineType:        ipToRqMap[v.Address].Isp,
			ListenerNum:     v.VipNum,
			CreateTime:      commen.ParseTime("2006-01-02 15:04:05", v.CreatedAt),

			Listeners: listeners,
		}

		lbByte, _ := json.Marshal(lbInfo)
		lbList[i] = lbByte
		scores[i] = float64(lbInfo.CreateTime)
		lbMap[lbInfo.InstanceId] = lbByte
	}

	klog.Info("lbtask set redis start  1")

	//Set
	setKey := gredis.LBSetKey
	_, err = gredis.Del(context.Background(), setKey)
	if err != nil {
		klog.Error(err)
		return err
	}
	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
	_, err = gredis.ZAdd(ctx, setKey, scores, lbList)
	defer cancel()
	if err != nil {
		klog.Error(err)
		return err
	}

	//hash
	hashKey := gredis.LBHashKey
	_, err = gredis.Del(context.Background(), hashKey)
	if err != nil {
		klog.Error(err)
		return err
	}
	ctx, cancel = context.WithTimeout(context.Background(), 5*time.Second)
	_, err = gredis.HMSet(ctx, hashKey, lbMap)
	defer cancel()
	if err != nil {
		klog.Error(err)
		return err
	}

	klog.Info("lbtask set redis end  1")

	return nil
}

func GetLbListFromNeutronApi(host string) ([]Pool, error) {
	apiUrl := host + "/v2.0/lb/pools"
	request, err := http.NewRequest("GET", apiUrl, nil)
	if err != nil {
		return nil, err
	}
	request = commen.AddHeaders(request, nil)

	client := &http.Client{}
	resp, err := client.Do(request)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	bytes, err := io.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var data LB
	err = json.Unmarshal(bytes, &data)
	if err != nil {
		return nil, err
	}
	return data.Pools, nil
}

func GetVipsFromNeutronApi(host string) ([]Vip, error) {
	apiUrl := host + "/v2.0/lb/vips"
	request, err := http.NewRequest("GET", apiUrl, nil)
	if err != nil {
		return nil, err
	}
	request = commen.AddHeaders(request, nil)

	client := &http.Client{}
	resp, err := client.Do(request)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	bytes, err := io.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var data Vips
	err = json.Unmarshal(bytes, &data)
	if err != nil {
		return nil, err
	}
	return data.Vips, nil
}

func GetHealthMonitorsFromNeutronApi(host string) ([]HealthMonitor, error) {
	apiUrl := host + "/v2.0/lb/health_monitors"
	request, err := http.NewRequest("GET", apiUrl, nil)
	if err != nil {
		return nil, err
	}
	request = commen.AddHeaders(request, nil)

	client := &http.Client{}
	resp, err := client.Do(request)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	bytes, err := io.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var data HealthMonitors
	err = json.Unmarshal(bytes, &data)
	if err != nil {
		return nil, err
	}
	return data.HealthMonitors, nil
}

func GetSlbaclsFromNeutronApi(host string) ([]Slbacl, error) {
	apiUrl := host + "/v2.0/lb/slbacls"
	request, err := http.NewRequest("GET", apiUrl, nil)
	if err != nil {
		return nil, err
	}
	request = commen.AddHeaders(request, nil)

	client := &http.Client{}
	resp, err := client.Do(request)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	bytes, err := io.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var data Slbacls
	err = json.Unmarshal(bytes, &data)
	if err != nil {
		return nil, err
	}
	return data.Slbacls, nil
}

type LbNetType struct {
	FloatingIpAddress string
	Type              string //public,private
	Isp               string //bgp, private
}

func queryLbNetTypeFromNeutronDB() (*[]LbNetType, error) {
	if dao.NeutronDB == nil {
		msg := "neutron db is invalid."
		klog.Info(msg)
		return nil, errors.New(msg)
	}
	var results []LbNetType
	sql := `SELECT f.floating_ip_address, n.type, n.isp FROM floatingips f left JOIN networks n 
			ON f.floating_network_id = n.id`
	//WHERE   f.floating_ip_address in ("10.178.80.178", "10.178.80.215")`

	err := dao.NeutronDB.Raw(sql).Scan(&results).Error
	if err != nil {
		msg := "获取lb网络信息失败："
		klog.Error(msg, err)
		return nil, errors.New(msg)
	}
	//klog.Infof("%+v", results)
	return &results, nil
}

type InstanceProject struct {
	InstanceId  string `gorm:"column:instance_id"`
	ProjectName string `gorm:"column:project_name"`
}

func QueryProjectNameByInstanceIds(ids []string) ([]InstanceProject, error) {
	errTag := "QueryProjectNameByInstanceIds - "
	var results []InstanceProject
	type Instance struct {
		InstanceId string `gorm:"column:instance_id"`
		ProjectId  int64  `gorm:"column:iam_project_id"`
	}
	var instances []Instance
	if dao.InstanceDB == nil {
		msg := errTag + "InstanceDB is invalid."
		klog.Error(msg)
		return results, errors.New(msg)
	}
	instanceSql := `SELECT instance_id, iam_project_id FROM instance_es_backup where instance_id IN (?)`
	err := dao.InstanceDB.Raw(instanceSql, ids).Scan(&instances).Error
	if err != nil {
		msg := errTag + "查询 instance_es_backup 失败"
		klog.Error(msg, err)
		return results, errors.New(msg)
	}
	projectIdSet := collection.NewSet()
	for _, instance := range instances {
		projectIdSet.AddInt64(instance.ProjectId)
	}
	projectIds := projectIdSet.KeysInt64()

	type Project struct {
		ProjectId   int64  `gorm:"column:project_id"`
		ProjectName string `gorm:"column:project_name"`
	}
	var projectes []Project
	if dao.IamDao == nil {
		msg := errTag + "IamDao is invalid."
		klog.Error(msg)
		return results, errors.New(msg)
	}
	projectSql := `SELECT project_id,project_name FROM iam_project where project_id in (?);`
	err = dao.IamDao.Raw(projectSql, projectIds).Scan(&projectes).Error
	if err != nil {
		msg := errTag + "查询 iam_project 失败"
		klog.Error(msg, err)
		return results, errors.New(msg)
	}

	projectMap := make(map[int64]string)
	for _, project := range projectes {
		projectMap[project.ProjectId] = project.ProjectName
	}
	for _, instance := range instances {
		projectName, ok := projectMap[instance.ProjectId]
		if ok {
			results = append(results, InstanceProject{InstanceId: instance.InstanceId, ProjectName: projectName})
		} else {
			results = append(results, InstanceProject{InstanceId: instance.InstanceId, ProjectName: ""})
		}
	}
	return results, nil
}

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/pkg/tasks/bm-task/type.go
```golang
package bmtask

import (
	"time"
)

//联表查询结果
type BmAll struct {
	Bm
	BmInfo
	BmType
}

//bm库存表
type Bm struct {
	Id                 int64     `gorm:"column:id"`
	ProductType        int       `gorm:"column:product_type"`      //1:CAL,2:DB???ն???????????
	Type               string    `gorm:"column:type"`              //??????????
	Region             string    `gorm:"column:region"`            //??????????region
	AvailabilityZone   string    `gorm:"column:availability_zone"` //ÎïÀí»úAZ
	ImageId            string    `gorm:"column:image_id"`          //ÏµÍ³¾µÏñID
	Sn                 string    `gorm:"column:sn"`                //?????????к?
	Rack               string    `gorm:"column:rack"`              //?????????ڻ???λ
	IpmiIp             string    `gorm:"column:ipmi_ip"`           //IPMI????IP
	IpmiUser           string    `gorm:"column:ipmi_user"`
	IpmiPassword       string    `gorm:"column:ipmi_password"`
	IpmiUserName       string    `gorm:"column:ipmi_user_name"`
	IpmiUserId         int8      `gorm:"column:ipmi_user_id"` //ilo用户ID
	IpmiUserPassword   string    `gorm:"column:ipmi_user_password"`
	IpmiRootPassword   string    `gorm:"column:ipmi_root_password"`
	PxeIp              string    `gorm:"column:pxe_ip"`
	TorMangerIp        string    `gorm:"column:tor_manger_ip"`
	TorMangerIp2       string    `gorm:"column:tor_manger_ip2"`
	TorIndex           int       `gorm:"column:tor_index"`
	TorIndex2          int       `gorm:"column:tor_index2"`
	TorIndexName       string    `gorm:"column:tor_index_name"`
	TorIndexName2      string    `gorm:"column:tor_index_name2"`
	BasicIp            string    `gorm:"column:basic_ip"`
	Mac                string    `gorm:"column:mac"`
	Mac2               string    `gorm:"column:mac2"` //mac2
	IsDel              int8      `gorm:"column:is_del"`
	IsSale             int8      `gorm:"column:is_sale"`
	Bond               int8      `gorm:"column:bond"`               //是否支持bond: 0 不支持bond 1支持bond
	IsHyperThreading   int8      `gorm:"column:is_hyper_threading"` //是否支持超线程 0:不支持;1:支持
	CreateTime         time.Time `gorm:"column:create_time"`
	UpdateTime         time.Time `gorm:"column:update_time"`
	Name               string    `gorm:"column:name"`
	CabinetUuid        string    `gorm:"column:cabinet_uuid"`          //机柜UUID
	Brand              string    `gorm:"column:brand"`                 //品牌（托管）
	Model              string    `gorm:"column:model"`                 //型号（托管）
	Unit               int       `gorm:"column:unit"`                  //所占U位（托管）
	Remarks            string    `gorm:"column:remarks"`               //备注（托管）
	Status             int8      `gorm:"column:status"`                //其他状态,1:改配服务器
	IfPass             int8      `gorm:"column:if_pass"`               //是否通过自检
	SmartNetworkCardSn string    `gorm:"column:smart_network_card_sn"` //智能网卡SN
	SmartNetworkCardIp string    `gorm:"column:smart_network_card_ip"` //智能网卡ip
	SupportEbs         string    `gorm:"column:support_ebs"`           //是否支持挂载云盘
}

//bm实例表
type BmInfo struct {
	Id                          int64     `gorm:"column:id"`
	Uuid                        string    `gorm:"column:uuid"`
	VifUuid                     string    `gorm:"column:vif_uuid"`
	UserId                      int64     `gorm:"column:user_id"`
	UserEmail                   string    `gorm:"column:user_email"`
	BmSn                        string    `gorm:"column:bm_sn"`
	BmType                      string    `gorm:"column:bm_type"`
	BmName                      string    `gorm:"column:bm_name"`
	ImageId                     string    `gorm:"column:image_id"`
	IsDel                       int8      `gorm:"column:is_del"`
	Raid                        string    `gorm:"column:raid"`
	Description                 string    `gorm:"column:description"`
	CreateTime                  time.Time `gorm:"column:create_time"`
	UpdateTime                  time.Time `gorm:"column:update_time"`
	Status                      int       `gorm:"column:status"`
	Action                      int       `gorm:"column:action"`
	ProductType                 int       `gorm:"column:product_type"`
	Bond                        int       `gorm:"column:bond"`                            //是否bond 0:否 1:是
	Kcm                         int8      `gorm:"column:kcm"`                             //是否安装云监控 0:否 1:是
	Khs                         int8      `gorm:"column:khs"`                             //是否安装安全组件 0:否 1:是
	KeyUuid                     string    `gorm:"column:key_uuid"`                        //秘钥ID
	IsInner                     int       `gorm:"column:is_inner"`                        //是否内部验证，0:不是,1:是;
	ClusterUuid                 string    `gorm:"column:cluster_uuid"`                    //容器集群ID
	ReleasableTime              time.Time `gorm:"column:releasable_time"`                 //可释放时间
	SystemFileType              string    `gorm:"column:system_file_type"`                //系统盘文件格式:EXT4,XFS
	DataFileType                string    `gorm:"column:data_file_type"`                  //数据盘文件格式:EXT4,XFS
	DataDiskCatalogue           string    `gorm:"column:data_disk_catalogue"`             //数据盘目录:/DATA/disk,/data
	DataDiskCatalogueSuffix     string    `gorm:"column:data_disk_catalogue_suffix"`      //数据盘目录后缀属性 NoSuffix,NaturalNumber
	HyperThreading              string    `gorm:"column:hyper_threading"`                 //对超线程的变更 Open,Close,NoChange
	NvmeDataFileType            string    `gorm:"column:nvme_data_file_type"`             //NVME数据盘类型 EXT4,XFS
	NvmeDataDiskCatalogue       string    `gorm:"column:nvme_data_disk_catalogue"`        //NVME数据盘目录 /disks/nvme-ssd/disk：在系统的/disks/nvme-ssd/disk目录下
	NvmeDataDiskCatalogueSuffix string    `gorm:"column:nvme_data_disk_catalogue_suffix"` //NVME数据盘目录后缀属性  NoSuffix,NaturalNumber,NaturalNumberFromZero
	BondAttribute               string    `gorm:"column:bond_attribute"`                  //网卡bond的属性，只有在bond4的模式下才生效 bond0,bond1
	ContainerAgent              string    `gorm:"column:container_agent"`                 //容器引擎组件类型 有效值：supported,unsupported
	KesAgent                    string    `gorm:"column:kes_agent"`                       //Kes组件类型
	RackUuid                    string    `gorm:"column:rack_uuid"`                       //机架位id
	AZ                          string    `gorm:"column:availability_zone"`
}

// bm 类型表
type BmType struct {
	Id              int64     `gorm:"column:id"`
	ProductType     int       `gorm:"column:product_type"` //1:CAL,2:DB¶ÔÍâÊÛÂôµÄ²úÆ·Ãû³Æ
	Type            string    `gorm:"column:type"`         //ÎïÀí»úÀàÐÍ
	Cpu             string    `gorm:"column:cpu"`          //cpu型号
	Memory          string    `gorm:"column:memory"`       //内存大小（G）
	Gpu             string    `gorm:"column:gpu"`
	SystemDiskType  string    `gorm:"column:system_disk_type"` //系统盘类型（sas、sata、ssd）
	SystemDiskSize  string    `gorm:"column:system_disk_size"` //系统盘大小（G）
	DataDiskType    string    `gorm:"column:data_disk_type"`   //数据盘类型（sas、sata、ssd）
	DataDiskSize    string    `gorm:"column:data_disk_size"`   //数据盘大小（G）
	NicType         int       `gorm:"column:nic_type"`         //网卡类型
	NicNum          int       `gorm:"column:nic_num"`          //网卡数量
	IsDel           int8      `gorm:"column:is_del"`           //ÊÇ·ñÉ¾³ý(0:Î´É¾³ý,1-ÒÑÉ¾³ý)
	CreateTime      time.Time `gorm:"column:create_time"`
	UpdateTime      time.Time `gorm:"column:update_time"`
	CpuFreq         string    `gorm:"column:cpu_freq"`
	CpuCount        int       `gorm:"column:cpu_count"`
	CpuCorecount    int       `gorm:"column:cpu_corecount"`
	GpuFreq         string    `gorm:"column:gpu_freq"`      //显存大小
	GpuCount        int       `gorm:"column:gpu_count"`     //CUDA核心数
	GpuCorecount    int       `gorm:"column:gpu_corecount"` //计算能力
	SystemDiskRaid  string    `gorm:"column:system_disk_raid"`
	SystemDiskIocap string    `gorm:"column:system_disk_iocap"`
	SystemDiskCount int       `gorm:"column:system_disk_count"` //系统盘数量
	DataDiskRaid    string    `gorm:"column:data_disk_raid"`
	DataDiskIocap   string    `gorm:"column:data_disk_iocap"`
	DataDiskCount   int       `gorm:"column:data_disk_count"`
	Name            string    `gorm:"column:name"`
	ColType         int       `gorm:"column:col_type"`         //机柜类型，1为普通；2为小米
	NetworkCard1    string    `gorm:"column:network_card1"`    //网卡1
	NetworkCard2    string    `gorm:"column:network_card2"`    //网卡2
	ExtendName      string    `gorm:"column:extend_name"`      //扩展套餐名称，多个使用，分隔
	HostType        string    `gorm:"column:host_type"`        //主机类型
	ProductCategory int       `gorm:"column:product_category"` //订单定义商品类型,47:REALVM 真实主机 111，物理主机 ,76：EPCRACK 物理主机机柜 132,84：EPCGPU 133
	ProductGroup    int       `gorm:"column:product_group"`    //商品组:111:物理主机组 （EPC）,132:物理主机机柜（EPC）,133:物理主机GPU（EPC）
	IsStandard      int8      `gorm:"column:is_standard"`      //标准化：0：非标准化，1：标准化
	HostName        string    `gorm:"column:host_name"`        //标准名称
}

type Bmtype struct {
	Id       int64  `gorm:"column:id"`
	HostType string `gorm:"column:host_type"`
}

type BmList struct {
	BmSn string `gorm:"column:sn"`
	Type int    `gorm:"column:type"`
	//Uuid            string `gorm:"column:uuid"`
	Region          string `gorm:"column:region"`
	AZ              string `gorm:"column:availability_zone"`
	InventoryStatus int    `gorm:"column:is_sale"` // ???
	UserID          int64  `gorm:"column:user_id"`
	UserName        string `gorm:"column:user_name"`
	MachinePackage  string `gorm:"column:name"`
	InstanceType    string `gorm:"column:host_name"`
	CPU             string `gorm:"column:cpu"`
	CPUCount        string `gorm:"column:cpu_count"`
	Memory          string `gorm:"column:memory"`
	SystemDiskType  string `gorm:"column:system_disk_type"`
	SystemDiskSize  string `gorm:"column:system_disk_size"`
	SystemDiskCount int32  `gorm:"column:system_disk_count"`
	DataDiskType    string `gorm:"column:data_disk_type"`
	DataDiskSize    string `gorm:"column:data_disk_size"`
	DataDiskCount   int32  `gorm:"column:data_disk_count"`
	// 存储后续补上

	// 预留状态
	ReservationStatus string
	// 预留租户ID
	ReservedUserID int
	// 预留租户名称
	ReservedUserName string
	// 预留天数
	ReservedTime int

	OutIp       string    `gorm:"column:ipmi_ip"`
	Room        string    `gorm:"column:region"`
	Rack        string    `gorm:"column:rack"`
	Ip          string    `gorm:"column:tor_manger_ip"`
	Port        int       `gorm:"column:tor_index"`
	Mac         string    `gorm:"column:mac"`
	InboundTime time.Time `gorm:"column:create_time"`
}

type EpcType struct {
	Type            int    `gorm:"column:type"`
	HostType        string `gorm:"column:host_type"`
	InstanceType    string `json:"TypeName"`
	Cpu             string `json:"Cpu"`
	Memory          string `json:"Memory"`
	SystemDiskType  string `json:"SystemDiskType"`
	SystemDiskSize  string `json:"SystemDiskSize"`
	SystemDiskCount int32  `json:"SystemDiskCount"`
	DataDiskType    string `json:"DataDiskType"`
	DataDiskSize    string `json:"DataDiskSize"`
	DataDiskCount   int32  `json:"DataDiskCount"`
}

// http://epc-center.inner.sdns.nhdc.cn?Action=QueryEpcTypeConfig
type BmConfig struct {
	TypeId          int    `json:"TypeId"`
	Type            string `json:"Type"`
	InstanceType    string `json:"TypeName"`
	Cpu             string `json:"Cpu"`
	Memory          string `json:"Memory"`
	SystemDiskType  string `json:"SystemDiskType"`
	SystemDiskSize  string `json:"SystemDiskSize"`
	SystemDiskCount int32  `json:"SystemDiskCount"`
	DataDiskType    string `json:"DataDiskType"`
	DataDiskSize    string `json:"DataDiskSize"`
	DataDiskCount   int32  `json:"DataDiskCount"`
}
type Config struct {
	BmTypeConfSet []BmConfig `json:"BmTypeConfSet"`
}

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/pkg/tasks/bm-task/bmTask.go
```golang
package bmtask

import (
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"io/ioutil"
	"luban-cmdb-api/pkg/dao"
	"luban-cmdb-api/pkg/gredis"
	"luban-cmdb-api/pkg/models/basic"
	Basic "luban-cmdb-api/pkg/service"
	"luban-cmdb-api/pkg/utils/keyStone"
	"net/http"
	"strconv"
	"time"

	"k8s.io/klog/v2"
)

func Scheduler() {
	klog.Info("bmtask start ...")
	err := FetchAndCacheBmInfo()
	if err != nil {
		klog.Errorf("FetchAndCacheBmInfo error: %v", err)
		return
	}
	klog.Info("bmtask end ...")
}

func FetchAndCacheBmInfo() error {
	//BmInventory
	bmInventoryList, err := queryBmInventoryFromBmDB()
	if err != nil {
		klog.Errorf("queryBmInventoryFromBmDB error: %v", err)
		return err
	}
	if len(bmInventoryList) > 0 {
		bmInventoryMap := make(map[string]interface{}, len(bmInventoryList))
		for _, bmi := range bmInventoryList {
			bmiByte, _ := json.Marshal(bmi)
			bmInventoryMap[bmi.Sn] = bmiByte
		}
		hashKey := gredis.BMInventoryKey
		_, err = gredis.Del(context.Background(), hashKey)
		if err != nil {
			klog.Error(err)
			return err
		}
		ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
		_, err = gredis.HMSet(ctx, hashKey, bmInventoryMap)
		defer cancel()
		if err != nil {
			klog.Error(err)
			return err
		}
	}

	//BmInstance
	bmInstanceList, err := queryBmInstanceFromBmDB()
	if err != nil {
		klog.Errorf("queryBmInstanceFromBmDB error: %v", err)
		return err
	}
	if len(bmInstanceList) > 0 {
		bmInstanceMap := make(map[string]interface{}, len(bmInstanceList))
		for _, bmi := range bmInstanceList {
			bmiByte, _ := json.Marshal(bmi)
			bmInstanceMap[bmi.Uuid] = bmiByte
		}
		hashKey1 := gredis.BMInstanceKey
		_, err = gredis.Del(context.Background(), hashKey1)
		if err != nil {
			klog.Error(err)
			return err
		}
		ctx1, cancel1 := context.WithTimeout(context.Background(), 5*time.Second)
		//klog.Errorf("%+v, %+v,%+v", ctx1, hashKey1, bmInstanceMap)
		_, err = gredis.HMSet(ctx1, hashKey1, bmInstanceMap)
		defer cancel1()
		if err != nil {
			klog.Error(err)
			return err
		}
	}

	//BmType
	bmTypeList, err := queryBmTypeFromBmDB()
	if err != nil {
		klog.Errorf("queryBmTypeFromBmDB error: %v", err)
		return err
	}
	if len(bmTypeList) > 0 {
		bmTypeMap := make(map[string]interface{}, len(bmTypeList))
		for _, bmt := range bmTypeList {
			bmtByte, _ := json.Marshal(bmt)
			bmTypeMap[bmt.Type] = bmtByte
		}
		hashKey2 := gredis.BMTypeKey
		_, err = gredis.Del(context.Background(), hashKey2)
		if err != nil {
			klog.Error(err)
			return err
		}
		ctx2, cancel2 := context.WithTimeout(context.Background(), 5*time.Second)
		_, err = gredis.HMSet(ctx2, hashKey2, bmTypeMap)
		defer cancel2()
		if err != nil {
			klog.Error(err)
			return err
		}
	}

	bmtypeList, err := queryBmtypeFromBmDB() // map[typeId]bmConfig
	if err != nil {
		klog.Errorf("queryBmTypeFromBmDB error: %v", err)
		return err
	}
	if len(bmtypeList) > 0 {
		bmtypeMap := make(map[string]interface{}, len(bmtypeList))
		for _, bmt := range bmtypeList {
			bmtByte, _ := json.Marshal(bmt)
			Id := strconv.Itoa(bmt.TypeId)
			bmtypeMap[Id] = bmtByte
		}
		hashKey5 := gredis.BMtypeKey
		_, err = gredis.Del(context.Background(), hashKey5)
		if err != nil {
			klog.Error(err)
			return err
		}
		ctx2, cancel2 := context.WithTimeout(context.Background(), 5*time.Second)
		_, err = gredis.HMSet(ctx2, hashKey5, bmtypeMap)
		defer cancel2()
		if err != nil {
			klog.Error(err)
			return err
		}
	}
	//BmList
	bmList, err := queryBmInstanceListFromBmDB1()
	if err != nil {
		klog.Errorf("queryBmInstanceListFromBmDB1 error: %v", err)
		//TODO epc host不同环境值不同，后期改为环境变量
		//return err

	}
	if len(bmList) > 0 {
		bmTypeMap := make(map[string]interface{}, len(bmTypeList))
		for _, bmt := range bmList {
			bmtByte, _ := json.Marshal(bmt)
			bmTypeMap[bmt.BmSn] = bmtByte
		}
		hashKey3 := gredis.BMListKey
		_, err = gredis.Del(context.Background(), hashKey3)
		if err != nil {
			klog.Error(err)
			return err
		}
		ctx3, cancel3 := context.WithTimeout(context.Background(), 5*time.Second)

		_, err = gredis.HMSet(ctx3, hashKey3, bmTypeMap)
		defer cancel3()
		if err != nil {
			klog.Error(err)
			return err
		}
	}

	//CloudBm
	cloudBmList, err := cloudBmList()
	if err != nil {
		klog.Errorf("cloudBmList error: %v", err)
		return err
	}
	if len(cloudBmList) > 0 {
		uuidToBmMap := make(map[string]interface{}, len(cloudBmList))
		for _, cb := range cloudBmList {
			bmtByte, _ := json.Marshal(cb)
			uuidToBmMap[cb.Uuid] = bmtByte
		}
		hashKey4 := gredis.BMCloudHashKey
		_, err = gredis.Del(context.Background(), hashKey4)
		if err != nil {
			klog.Error(err)
			return err
		}
		ctx4, cancel4 := context.WithTimeout(context.Background(), 5*time.Second)
		_, err = gredis.HMSet(ctx4, hashKey4, uuidToBmMap)
		defer cancel4()
		if err != nil {
			klog.Error(err)
			return err
		}
	}

	return nil
}

func queryBmInventoryFromBmDB() ([]Bm, error) {
	if dao.BmDB == nil {
		msg := "bm db is invalid."
		klog.Error(msg)
		return nil, errors.New(msg)
	}
	var results []Bm
	sql := `SELECT * FROM bm WHERE is_del = 0`
	err := dao.BmDB.Debug().Raw(sql).Scan(&results).Error
	if err != nil {
		msg := "获取Bm库存失败"
		klog.Error(msg, err)
		return nil, errors.New(msg)
	}
	klog.Infof("%+v", results)
	return results, nil
}

func queryBmInstanceFromBmDB() ([]BmInfo, error) {
	if dao.BmDB == nil {
		msg := "bm db is invalid."
		klog.Error(msg)
		return nil, errors.New(msg)
	}
	var results []BmInfo
	sql := `SELECT b1.*, b2.availability_zone FROM bm_info b1, bm b2 WHERE b1.is_del = 0 AND b1.bm_sn=b2.sn`
	err := dao.BmDB.Raw(sql).Scan(&results).Error
	if err != nil {
		msg := "获取Bm实例失败"
		klog.Error(msg, err)
		return nil, errors.New(msg)
	}
	//klog.Infof("%+v", results)
	return results, nil
}

//func queryBmInstanceListFromBmDB() ([]BmList, error) {
//	if dao.BmDB == nil {
//		msg := "bm db is invalid."
//		klog.Error(msg)
//		return nil, errors.New(msg)
//	}
//	var results []BmList
//	sql := `SELECT b1.bm_sn, b1.uuid, b2.region, b2.availability_zone, b2.is_sale, b3.user_id, b3.user_name, b2.name, b4.host_name, b4.cpu, b4.cpu_count, b4.memory, b4.system_disk_type, b4.system_disk_size, b4.system_disk_count, b4.data_disk_type, b4.data_disk_size, b4.data_disk_count, b2.ipmi_ip, b2.rack, b2.tor_manger_ip,b2.tor_index, b2.mac, b1.create_time
//			FROM bm_info b1 LEFT JOIN bm b2 on  b1.bm_sn = b2.sn
//			LEFT JOIN bm_remotemng b3 on b1.user_id = b3.user_id
//			LEFT JOIN bm_type b4 on b1.bm_type = b4.type`
//	err := dao.BmDB.Debug().Raw(sql).Scan(&results).Error
//	if err != nil {
//		msg := "获取Bm实例失败"
//		klog.Error(msg, err)
//		return nil, errors.New(msg)
//	}
//	//klog.Infof("%+v", results)
//	return results, nil
//}

func queryBmInstanceListFromBmDB1() ([]BmList, error) {
	if dao.BmDB == nil {
		msg := "bm db is invalid."
		klog.Error(msg)
		return nil, errors.New(msg)
	}
	var results []BmList
	// 查询bm表下不为空的实例
	sql := `SELECT b2.ipmi_ip, b2.rack, b2.name, b2.id, b2.tor_manger_ip,b2.tor_index, b2.mac, b2.create_time, b2.type, b2.sn, b2.region, b2.availability_zone, b2.is_sale
			FROM bm b2 
			WHERE b2.is_del = 0`
	err := dao.BmDB.Debug().Raw(sql).Scan(&results).Error
	if err != nil {
		msg := "获取Bm实例失败"
		klog.Error(msg, err)
		return nil, errors.New(msg)
	}

	host := keyStone.EpcCenterUrl
	bmTypeConfSet, err := queryEpcType(host)
	if err != nil {
		klog.Error(err)
		return nil, errors.New("queryEpcType error")
	}
	// 1:Bmconfig{}
	bmTypeIdMap := make(map[int]BmConfig)
	for _, b := range bmTypeConfSet {
		bmTypeIdMap[b.TypeId] = b
	}
	//klog.Infof("%+v", bmTypeIdMap)

	for i := 0; i < len(results); i++ {
		results[i].CPU = bmTypeIdMap[results[i].Type].Cpu
		results[i].Memory = bmTypeIdMap[results[i].Type].Memory
		results[i].InstanceType = bmTypeIdMap[results[i].Type].InstanceType
		results[i].SystemDiskType = bmTypeIdMap[results[i].Type].SystemDiskType
		results[i].SystemDiskCount = bmTypeIdMap[results[i].Type].SystemDiskCount
		results[i].DataDiskCount = bmTypeIdMap[results[i].Type].DataDiskCount
		results[i].DataDiskType = bmTypeIdMap[results[i].Type].DataDiskType
		results[i].DataDiskSize = bmTypeIdMap[results[i].Type].DataDiskSize
		results[i].SystemDiskSize = bmTypeIdMap[results[i].Type].SystemDiskSize
	}
	//klog.Info(results)

	type User struct {
		UserID   int64  `gorm:"column:user_id"`
		UserName string `gorm:"column:user_name"`
	}
	for i, b := range results {
		//只有已出售的才需要查询售卖用户
		if b.InventoryStatus == 1 {
			var user User
			// sql = `select  b1.bm_sn ,b2.user_id, b2.user_name from bm_info b1
			// LEFT JOIN  bm_remotemng b2 on b1.user_id = b2.user_id
			// WHERE b1.bm_sn = "%s" and b1.is_del = 0 ORDER BY b1.create_time DESC limit 1`

			sql = `select user_id from bm_info WHERE bm_sn="%s" and is_del = 0  ORDER BY create_time DESC limit 1`
			sql = fmt.Sprintf(sql, b.BmSn)
			err = dao.BmDB.Debug().Raw(sql).Scan(&user).Error
			if err != nil {
				msg := "获取用户失败"
				klog.Error(msg, err)
				return nil, errors.New(msg)
			}
			userId := user.UserID
			var tenant basic.Tenant
			tenant, _ = Basic.GetRedisTenantMessage(strconv.FormatInt(userId, 10))
			results[i].UserID = userId
			results[i].UserName = tenant.Name
		}
	}
	// klog.Infof("%+v", results)
	return results, nil
}

func queryEpcType(host string) ([]BmConfig, error) {
	config := Config{}
	epcUrl := host + "?Action=QueryEpcTypeConfig"
	rsp, err := http.Get(epcUrl)
	if err != nil {
		return nil, err
	}
	body, _ := ioutil.ReadAll(rsp.Body)
	klog.Infof("%s", string(body))
	err = json.Unmarshal([]byte(string(body)), &config)
	if err != nil {
		klog.Info("json parse error", err)
		return nil, err
	}

	// 查询epc_type
	var epcResults []EpcType
	sql := `SELECT type, host_type FROM epc_center_info.epc_type WHERE is_del=0`
	err = dao.BmDB.Debug().Raw(sql).Scan(&epcResults).Error
	if err != nil {
		msg := "获取Epc实例失败"
		klog.Error(msg, err)
		return nil, errors.New(msg)
	}

	bmTypeConfSet := config.BmTypeConfSet
	//klog.Infof("%+v", epcResults)
	for i, b := range bmTypeConfSet {
		for _, e := range epcResults {
			if b.Type == e.HostType {
				bmTypeConfSet[i].TypeId = e.Type
			}
		}
	}
	klog.Infof("%+v", bmTypeConfSet)
	return config.BmTypeConfSet, nil
}

func queryBmTypeFromBmDB() ([]BmType, error) {
	if dao.BmDB == nil {
		msg := "bm db is invalid."
		klog.Error(msg)
		return nil, errors.New(msg)
	}
	var results []BmType
	sql := `SELECT * FROM bm_type WHERE is_del = 0`
	err := dao.BmDB.Debug().Raw(sql).Scan(&results).Error
	if err != nil {
		msg := "获取Bm类型失败"
		klog.Error(msg, err)
		return nil, errors.New(msg)
	}
	//klog.Infof("%+v", results)
	return results, nil
}

func queryBmtypeFromBmDB() (map[int]BmConfig, error) {
	host := keyStone.EpcCenterUrl
	bmTypeConfSet, err := queryEpcType(host)
	bmTypeIdMap := make(map[int]BmConfig)
	for _, b := range bmTypeConfSet {
		bmTypeIdMap[b.TypeId] = b
	}
	// var results []Bmtype
	// sql := `SELECT * FROM bm_type WHERE is_del = 0`
	// err := dao.BmDB.Debug().Raw(sql).Scan(&results).Error
	if err != nil {
		msg := "获取Bm类型失败"
		klog.Error(msg, err)
		return nil, errors.New(msg)
	}
	//klog.Infof("%+v", results)
	return bmTypeIdMap, nil
}

func cloudBmList() ([]BmAll, error) {
	if dao.BmDB == nil {
		msg := "bm db is invalid."
		klog.Error(msg)
		return nil, errors.New(msg)
	}
	var results []BmAll
	sql := `SELECT * FROM bm_info  bi 
				LEFT JOIN bm b ON bi.bm_sn = b.sn 
				LEFT JOIN bm_type bt ON bi.bm_type = bt.type  
				WHERE bi.is_del = 0`
	err := dao.BmDB.Raw(sql).Scan(&results).Error
	if err != nil {
		msg := "获取Bm实例失败"
		klog.Error(msg, err)
		return nil, errors.New(msg)
	}

	return results, nil
}

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/pkg/tasks/bm-task/bmTask_test.go
```golang
package bmtask

import (
	"testing"
)

func TestSq(t *testing.T) {
	db1, err := queryBmInstanceListFromBmDB1()
	if err != nil {
		return
	}

	t.Logf("db1: %+v", db1)

}

func TestQueryEpcType(t *testing.T) {
	host := "http://epc-center.inner.sdns.yunyan.com"
	db1, err := queryEpcType(host)
	if err != nil {
		t.Logf("err: %+v", err)
		return
	}

	t.Logf("db1: %+v", db1)
}

func Test1(t *testing.T) {
	err := FetchAndCacheBmInfo()
	if err != nil {
		t.Logf("err: %+v", err)
		return
	}

}

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/pkg/tasks/nova-task/types.go
```golang
package novaTask

import (
	"github.com/gophercloud/gophercloud/openstack/compute/v2/servers"
	"luban-cmdb-api/pkg/utils/unixtime"
	"time"
)

type (
	NovaAggregatesResult struct {
		NovaAggregates []NovaAggregate `json:"aggregates"`
	}
	NovaAggregate struct {
		Name             string            `json:"name"`
		AvailabilityZone string            `json:"availability_zone"`
		Deleted          bool              `json:"deleted"`
		CreatedAt        unixtime.UnixTime `json:"created_at"`
		Metadetails      Metadetails       `json:"metadetails"`
		UpdatedAt        unixtime.UnixTime `json:"updated_at"`
		Hosts            []string          `json:"hosts"`
		DeletedAt        unixtime.UnixTime `json:"deleted_at"`
		Id               int               `json:"id"`
		//Metadata         Metadata    `json:"metadata"`
		Metadata map[string]string `json:"metadata"`
	}
	Metadetails struct {
		VmAttr                         string `json:"vm_attr,omitempty"`
		Reserved                       string `json:"reserved,omitempty"`
		CpuAllocationRatio             string `json:"cpu_allocation_ratio,omitempty"`
		CustomResizeCpuAllocationRatio string `json:"custom_resize_cpu_allocation_ratio,omitempty"`
		Cluster                        string `json:"cluster,omitempty"`
		StorageType                    string `json:"storage_type,omitempty"`
		User                           string `json:"user,omitempty"`
		ForceDelete                    string `json:"force_delete,omitempty"`
		KSCUser                        string `json:"KSC_user,omitempty"`
	}
	Metadata struct {
		VmAttr                         string `json:"vm_attr,omitempty"`
		Reserved                       string `json:"reserved,omitempty"`
		CpuAllocationRatio             string `json:"cpu_allocation_ratio,omitempty"`
		CustomResizeCpuAllocationRatio string `json:"custom_resize_cpu_allocation_ratio,omitempty"`
		Cluster                        string `json:"cluster,omitempty"`
		StorageType                    string `json:"storage_type,omitempty"`
		User                           string `json:"user,omitempty"`
		ForceDelete                    string `json:"force_delete,omitempty"`
		KSCUser                        string `json:"KSC_user,omitempty"`
	}
)

type (
	NovaServiceResult struct {
		NovaServices []NovaService `json:"services"`
	}
	NovaService struct {
		Binary           string            `json:"binary"`
		AvailabilityZone string            `json:"availability_zone"`
		Deleted          bool              `json:"deleted"`
		CreatedAt        unixtime.UnixTime `json:"created_at"`
		//Describe         string            `json:"describe"`
		UpdatedAt   unixtime.UnixTime `json:"updated_at"`
		ReportCount int               `json:"report_count"`
		Topic       string            `json:"topic"`
		//Cluster          interface{} `json:"cluster"`
		Host     string `json:"host"`
		Disabled bool   `json:"disabled"`
		//DeletedAt unixtime.UnixTime `json:"deleted_at"`
		Id int `json:"id"`
	}
)

type (
	NovaServersHrefResult struct {
		NovaServersHrefs []NovaServersHref `json:"servers"`
	}
	NovaServersHref struct {
		Id                    string             `json:"id"`
		Name                  string             `json:"name"`
		DisasterRecoveryGroup []DisasterRecovery `json:"disaster_recovery_group"`
		Links                 []Link             `json:"links"`
	}
	DisasterRecovery struct {
		InstanceUuid string      `json:"instance_uuid"`
		UserId       string      `json:"user_id"`
		Name         string      `json:"name"`
		Level        string      `json:"level"`
		Deleted      bool        `json:"deleted"`
		TenantId     string      `json:"tenant_id"`
		CreatedAt    string      `json:"created_at"`
		SameHostNum  int         `json:"same_host_num"`
		UpdatedAt    interface{} `json:"updated_at"`
		Visible      bool        `json:"visible"`
		DeletedAt    interface{} `json:"deleted_at"`
		Id           int         `json:"id"`
		Uuid         string      `json:"uuid"`
	}
	Link struct {
		Href string `json:"href"`
		Rel  string `json:"rel"`
	}
)

type (
	NovaServer struct {
		ID                 string                   `json:"id"`
		TenantID           string                   `json:"tenant_id"`
		UserID             string                   `json:"user_id"`
		Name               string                   `json:"name"`
		Updated            time.Time                `json:"updated"`
		Created            time.Time                `json:"created"`
		HostID             string                   `json:"OS-EXT-SRV-ATTR:host"`
		HypervisorHostname string                   `json:"OS-EXT-SRV-ATTR:hypervisor_hostname"`
		Status             string                   `json:"status"`
		Progress           int                      `json:"progress"`
		AccessIPv4         string                   `json:"accessIPv4"`
		AccessIPv6         string                   `json:"accessIPv6"`
		Image              map[string]interface{}   `json:"image"`
		Flavor             map[string]interface{}   `json:"flavor"`
		Addresses          map[string]interface{}   `json:"addresses"`
		Metadata           map[string]string        `json:"metadata"`
		Links              []interface{}            `json:"links"`
		KeyName            string                   `json:"key_name"`
		AdminPass          string                   `json:"adminPass"`
		SecurityGroups     []map[string]interface{} `json:"security_groups"`
		AttachedVolumes    []servers.AttachedVolume `json:"os-extended-volumes:volumes_attached"`
		Fault              servers.Fault            `json:"fault"`
		Tags               *[]string                `json:"tags"`
	}
)

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/pkg/tasks/nova-task/constants.go
```golang
package novaTask

const (
	NovaDomain          = "nova.galaxy.cloud"
	NovaPort            = 8774
	NovaVersion         = "v2"
	NovaAggregateSuffix = "os-aggregates"
	NovaServicesSuffix  = "os-services"
	NovaServersSuffix   = "servers"
)

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/pkg/tasks/nova-task/execute.go
```golang
package novaTask

import (
	"k8s.io/klog/v2"
	"time"
)

func execute() {
	fetchNovaAggregates()
	fetchCloudPhysicalServers()
	fetchCloudServers()
}

func SchedulerOnce() {
	start := time.Now()
	execute()
	end := time.Now()
	spend := end.Sub(start).Seconds()
	klog.Infof("nova information fetched. spend time %ds. wait 15 Minutes to refetch \n", int64(spend))
}

func Scheduler() {
	for {
		start := time.Now()
		execute()
		end := time.Now()
		spend := end.Sub(start).Seconds()
		klog.Infof("nova information fetched. spend time %ds. wait 15 Minutes to refetch \n", int64(spend))
		time.Sleep(15 * time.Minute)
	}

}

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/pkg/tasks/nova-task/cloudPhysicalServiceTask.go
```golang
package novaTask

import (
	"context"
	"encoding/json"
	"fmt"
	"k8s.io/klog/v2"
	"luban-cmdb-api/pkg/gredis"
	"time"
)

func fetchCloudPhysicalServers() {
	token, tokenKey := GetTokenAndKey()
	if token == "" || tokenKey == "" {
		klog.Error("fetch nova token failed.")
		return
	}
	apiUrl := fmt.Sprintf("http://%s:%d/%s/%s/%s", NovaDomain, NovaPort, NovaVersion, tokenKey, NovaServicesSuffix)
	headers := map[string]string{
		"X-Auth-Token":      token,
		"X-Auth-Project-Id": "admin",
		"Accept":            "application/json",
	}
	var result NovaServiceResult
	err := GetNovaResult(apiUrl, headers, &result)
	if err != nil {
		klog.Errorf("fetch cloudPhysicalServers from: %s,failed. err: %+v", apiUrl, err)
		return
	}

	var PhysicalServerList = make(map[string][]NovaService)
	for _, service := range result.NovaServices {
		PhysicalServerList[service.Host] = append(PhysicalServerList[service.Host], service)
	}
	var allPhysicalServers = make(map[string]interface{})
	for host, service := range PhysicalServerList {
		serviceStr, e := json.Marshal(service)
		if e != nil {
			klog.Errorf("marshal physicalService failed. host: %s, err: %+v", host, e)
			continue
		}
		allPhysicalServers[host] = serviceStr
	}
	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
	defer cancel()
	err = writeToRedisHash(ctx, gredis.NovaPhysicalServiceHashKey, allPhysicalServers)
	if err != nil {
		klog.Errorf("write cloudPhysicalServers to redis failed. err: %+v", err)
	}
	return
}

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/pkg/tasks/nova-task/aggregateTask.go
```golang
package novaTask

import (
	"context"
	"encoding/json"
	"fmt"
	"k8s.io/klog/v2"
	"luban-cmdb-api/pkg/gredis"
	"time"
)

func fetchNovaAggregates() {
	token, tokenKey := GetTokenAndKey()
	if token == "" || tokenKey == "" {
		klog.Error("fetch nova token failed.")
		return
	}
	apiUrl := fmt.Sprintf("http://%s:%d/%s/%s/%s", NovaDomain, NovaPort, NovaVersion, tokenKey, NovaAggregateSuffix)
	headers := map[string]string{
		"X-Auth-Token":      token,
		"X-Auth-Project-Id": "admin",
		"Accept":            "application/json",
	}
	var result NovaAggregatesResult
	err := GetNovaResult(apiUrl, headers, &result)
	if err != nil {
		klog.Errorf("fetch novaAggregates from: %s,failed. err: %+v", apiUrl, err)
		return
	}
	var allNovaAggregates = make(map[string]interface{})
	var NovaAggregateAndPhysicalServiceMapping = make(map[string]interface{})
	for _, aggregate := range result.NovaAggregates {
		aggregateStr, e := json.Marshal(aggregate)
		if e != nil {
			klog.Errorf("marshal novaAggregates failed. name: %s, err: %+v", aggregate.Name, e)
			continue
		}
		allNovaAggregates[aggregate.Name] = aggregateStr
		for _, host := range aggregate.Hosts {
			NovaAggregateAndPhysicalServiceMapping[host] = aggregate.Name
		}
	}
	if len(allNovaAggregates) > 0 {
		ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
		err = writeToRedisHash(ctx, gredis.NovaAggregateHashKey, allNovaAggregates)
		cancel()
		if err != nil {
			klog.Errorf("write novaAggregates to redis failed. err: %+v", err)
			return
		}
	}
	if len(NovaAggregateAndPhysicalServiceMapping) > 0 {
		ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
		err = writeToRedisHash(ctx, gredis.NovaAggregateAndPhysicalServiceMappingKey, NovaAggregateAndPhysicalServiceMapping)
		cancel()
		if err != nil {
			klog.Errorf("write novaAggregatesAndPhysicalServiceMapping to redis failed. err: %+v", err)
			return
		}
	}
	return
}

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/pkg/tasks/nova-task/common.go
```golang
package novaTask

import (
	"context"
	"encoding/json"
	"io"
	"k8s.io/klog/v2"
	"luban-cmdb-api/pkg/gredis"
	"luban-cmdb-api/pkg/utils/keyStone"
	"net/http"
	"strings"
)

func GetNovaResult(apiUrl string, headers map[string]string, result interface{}) (err error) {
	var (
		request *http.Request
		resp    *http.Response
		client  = &http.Client{}
		bytes   []byte
	)

	klog.Infoln("DEBUG - cloud products vm api  - ", apiUrl)
	request, err = http.NewRequest("GET", apiUrl, nil)
	if err != nil {
		return
	}
	request = keyStone.AddHeaders(request, headers)
	resp, err = client.Do(request)
	if err != nil {
		return
	}
	bytes, err = io.ReadAll(resp.Body)
	resp.Body.Close()
	if err != nil {
		return
	}
	//result = make(map[string]interface{})
	err = json.Unmarshal(bytes, &result)
	return
}

func GetTokenAndKey() (token, key string) {
	var (
		tokenSlice []string
	)
	token = keyStone.GetAdminToken()
	if token == "" {
		return
	}
	if tokenSlice = strings.Split(token, ":"); len(tokenSlice) < 2 {
		return
	}
	key = tokenSlice[1]
	return
}

func writeToRedisHash(ctx context.Context, key string, value map[string]interface{}) (err error) {
	tempKey := key + "_temp"
	_, err = gredis.HMSet(ctx, tempKey, value)
	if err != nil {
		_, _ = gredis.Del(ctx, tempKey)
		return
	}
	_, err = gredis.Rename(ctx, tempKey, key)
	if err != nil {
		_, _ = gredis.Del(ctx, tempKey)
		return
	}
	return
}

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/pkg/tasks/nova-task/cloudServerTask.go
```golang
package novaTask

import (
	"context"
	"encoding/json"
	"fmt"
	"k8s.io/klog/v2"
	"luban-cmdb-api/pkg/gredis"
	"time"
)

func fetchCloudServers() {
	token, tokenKey := GetTokenAndKey()
	if token == "" || tokenKey == "" {
		klog.Error("fetch nova token failed.")
		return
	}
	apiUrl := fmt.Sprintf("http://%s:%d/%s/%s/%s?all_tenants", NovaDomain, NovaPort, NovaVersion, tokenKey, NovaServersSuffix)
	headers := map[string]string{
		"X-Auth-Token":      token,
		"X-Auth-Project-Id": "admin",
		"Accept":            "application/json",
	}
	var result NovaServersHrefResult
	err := GetNovaResult(apiUrl, headers, &result)
	if err != nil {
		klog.Errorf("fetch href of cloudServers from: %s,failed. err: %+v", apiUrl, err)
		return
	}
	var allInstances = make(map[string]interface{})
	for _, href := range result.NovaServersHrefs {
		var (
			//serverMap map[string]servers.Server
			serverMap map[string]NovaServer
		)
		err = GetNovaResult(href.Links[0].Href, headers, &serverMap)
		if err != nil {
			klog.Errorf("fetch detail of cloudServer from: %s,failed. err: %+v", href.Links[0].Href, err)
			continue
		}
		if server, ok := serverMap["server"]; ok {
			serverStr, e := json.Marshal(server)
			if e != nil {
				klog.Errorf("marshal cloudServer failed. id: %s, err: %+v", server.ID, e)
				continue
			}
			allInstances[server.ID] = serverStr
		}
	}
	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
	err = writeToRedisHash(ctx, gredis.NovaCloudServerHashKey, allInstances)
	cancel()
	if err != nil {
		klog.Errorf("write cloudServers to redis failed. err: %+v", err)
		return
	}
	return
}

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/pkg/tasks/snmp-task/models.go
```golang
package snmptask

type (
	SnmpMeta struct {
		Sn    string `gorm:"column:sn"`
		Ip    string `gorm:"column:ip"`
		Group string `gorm:"column:community"`
		Sales string `gorm:"column:sales"`
	}

	Result struct {
		Code    int         `json:"code"`
		Message string      `json:"message"`
		Data    interface{} `json:"data"`
	}
)

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/pkg/tasks/snmp-task/ifStateTask.go
```golang
package snmptask

import (
	"fmt"
	"luban-cmdb-api/pkg/dao"
	"sync"
	"time"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"k8s.io/klog/v2"
)

type switchIfInitState struct {
	Sn         string `gorm:"column:sn"`
	Name       string `gorm:"column:if_name"`
	Index      string `gorm:"column:if_index"`
	AdminState int    `gorm:"column:admin_state"`
	OperState  int    `gorm:"column:oper_state"`
	PortState  int    `gorm:"column:port_state"`
}

func InitSwichInterfaceStatus() {
	sqlStr := `
		create table if not exists asset_switch_interface_initial_status
		(
			id                  int           auto_increment comment 'ID' primary key,
			sn                  varchar(50)   not null comment '交换机SN',
			if_name             varchar(50)   not null comment '接口名称',
			if_index            varchar(20)   not null comment '接口索引',
			admin_state         int           not null comment '接口管理状态(1:运行中;2:关闭)',
			oper_state          int           not null comment '接口操作状态(1:运行中;2:关闭)',
			port_state          int           not null comment '逻辑端口状态(1:运行中;2:关闭;3:未连接;4:故障)',
			unique index sn_if_index(sn, if_index)
		) comment '交换机接口初始状态表' charset = utf8mb4;
`
	if !checkTableExists(dao.AssetDB, "cmdb", "asset_switch_interface_initial_status") {
		err := dao.AssetDB.Exec(sqlStr).Error
		if err != nil {
			klog.Error(fmt.Sprintf("create table asset_switch_interface_initial_status failed. err: %+v", err))
			return
		}
	}
	err := initializeIfStates()
	if err != nil {
		klog.Error(fmt.Sprintf("initialize asset_switch_interface_initial_status failed. err: %v", err))
	}
}

func initializeIfStates() (err error) {
	var (
		metas  []SnmpMeta
		snMap  map[string]struct{}
		sns    []string
		states []switchIfInitState
		mutex  sync.Mutex
	)
	metas = getValidSnmpMetas()
	err = dao.AssetDB.Table("asset_switch_interface_initial_status").Select("distinct sn").Scan(&sns).Error
	if err != nil {
		return
	}
	snMap = make(map[string]struct{})
	for _, sn := range sns {
		snMap[sn] = struct{}{}
	}
	wg := new(sync.WaitGroup)
	for _, meta := range metas {
		if _, ok := snMap[meta.Sn]; !ok {
			wg.Add(1)
			go func(meta SnmpMeta) {
				defer wg.Done()
				status, er := getIfStates(meta)
				if er != nil {
					klog.Error(fmt.Sprintf("switch sn: %s initialize interfaces failed. err: %+v", meta.Sn, er))
					return
				}
				mutex.Lock()
				states = append(states, status...)
				mutex.Unlock()
			}(meta)
		}
	}
	wg.Wait()
	if len(states) > 0 {
		err = dao.AssetDB.Table("asset_switch_interface_initial_status").Clauses(clause.OnConflict{
			Columns:   []clause.Column{{Name: "sn"}, {Name: "if_index"}},
			UpdateAll: true,
		}).Create(&states).Error
	}
	return
}

func synchronizeIfStates() (err error) {
	var (
		metas         []SnmpMeta
		syncMap       = new(sync.Map)
		states        []switchIfInitState
		updateInitial []switchIfInitState
	)
	metas = getValidSnmpMetas()
	wg := new(sync.WaitGroup)
	for _, meta := range metas {
		wg.Add(1)
		go func(meta SnmpMeta) {
			defer wg.Done()
			status, er := getIfStates(meta)
			if er != nil {
				klog.Error(fmt.Sprintf("switch sn: %s synchronize interfaces failed. err: %+v", meta.Sn, er))
				return
			}
			for _, state := range status {
				key := fmt.Sprintf("%s_%s", state.Sn, state.Index)
				syncMap.Store(key, state)
			}
		}(meta)
	}
	wg.Wait()
	err = dao.AssetDB.Table("asset_switch_interface_initial_status").Select("sn,if_name,if_index,admin_state,oper_state").Scan(&states).Error
	if err != nil {
		return
	}
	for _, state := range states {
		key := fmt.Sprintf("%s_%s", state.Sn, state.Index)
		if interF, ok := syncMap.Load(key); ok {
			if newState, ok1 := interF.(switchIfInitState); ok1 {
				if state.AdminState != newState.AdminState || state.OperState != newState.OperState {
					if newState.AdminState == 1 && newState.OperState == 2 && state.OperState == 1 {
						newState.PortState = 4
					}
					updateInitial = append(updateInitial, newState)
				}
			}
		}
	}
	if len(updateInitial) > 0 {
		err = dao.AssetDB.Table("asset_switch_interface_initial_status").Clauses(clause.OnConflict{
			Columns:   []clause.Column{{Name: "sn"}, {Name: "if_index"}},
			DoUpdates: clause.AssignmentColumns([]string{"admin_state", "oper_state", "port_state"}),
			//UpdateAll: true,
		}).Create(&updateInitial).Error
	}
	return
}

func checkTableExists(db *gorm.DB, dbName, tableName string) bool {
	var (
		result int
	)
	_ = db.Table("INFORMATION_SCHEMA.TABLES").Select("1").Where("TABLE_SCHEMA=? and TABLE_NAME=?", dbName, tableName).Find(&result).Error
	return result == 1
}

func getIfStates(meta SnmpMeta) (states []switchIfInitState, err error) {
	var (
		descrs           map[string]string
		astatus, ostatus map[string]int
	)
	descrs, err = snmpFetchIfDescrs(meta, ifDescrOidStandard)
	if err != nil {
		return
	}
	astatus, err = snmpFetchIfStatus(meta, ifAdminStatusStandard)
	if err != nil {
		return
	}
	ostatus, err = snmpFetchIfStatus(meta, ifOperStatusStandard)
	if err != nil {
		return
	}
	for k, name := range descrs {
		state := switchIfInitState{
			Sn:         meta.Sn,
			Name:       name,
			Index:      k,
			AdminState: disposeState(astatus[k]),
			OperState:  disposeState(ostatus[k]),
		}
		state.PortState = judgeStatus(state.AdminState, state.OperState)
		states = append(states, state)
	}
	return
}

func disposeState(sta int) int {
	var state int
	switch sta {
	case 1:
		state = 1
	default:
		state = 2
	}
	return state
}

//todo 正常：ifOperStatus up
//todo 故障：ifadminstatus up, ifOperStatus down
//todo 关闭：ifadminstatus down, ifOperStatus down
//1:运行中;2:关闭;3:故障;
func judgeStatus(adminSta, operSta int) int {
	var state = 2
	switch {
	case adminSta == 1 && operSta == 1:
		state = 1
	case adminSta == 1 && operSta == 2:
		state = 3
	case adminSta == 2 && operSta == 2:
		state = 2
	}
	return state
}

func IfStateTaskScheduler() {
	for {
		time.Sleep(15 * time.Minute)
		klog.Info("snmp switch parts information beging...")
		err := synchronizeIfStates()
		if err != nil {
			klog.Error(fmt.Sprintf("synchronize switch interfaces state failed. err: %+v", err))
		}
		klog.Info("snmp switch parts information over...")
	}
}

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/pkg/tasks/snmp-task/snTask.go
```golang
package snmptask

import (
	"fmt"
	g "github.com/gosnmp/gosnmp"
	"k8s.io/klog/v2"
	"luban-cmdb-api/pkg/dao"
	"strconv"
	"strings"
)

func updateAssetSwitch(ipSnMapping map[string]string) {
	for ip, sn := range ipSnMapping {
		err := dao.AssetDB.Table("asset_switch").Where("ip = ?", ip).Update("sn", sn).Error
		if err != nil {
			klog.Error(fmt.Sprintf("update sn: %s for ip: %s faliure. err: %v", sn, ip, err))
		}
	}
}

func parseSn(smList []SnmpMeta) map[string]string {
	var (
		ipSnMapping = make(map[string]string)
	)
	for _, meta := range smList {
		pdus := snmpFetchSn(meta)
		for _, v := range pdus {
			var sn string
			switch v.Type {
			case g.OctetString:
				bytes := v.Value.([]byte)
				if bytes[len(bytes)-1] == uint8(0) {
					bytes = bytes[:len(bytes)-1]
				}
				sn = string(bytes)
				if sn != "" {
					sn = strings.Trim(sn, " ")
					ipSnMapping[meta.Ip] = sn
				}
			default:
				var val int
				switch value := v.Value.(type) {
				case int:
					val = value
				case int8:
					val = int(value)
				case int16:
					val = int(value)
				case int32:
					val = int(value)
				case int64:
					val = int(value)
				case uint:
					val = int(value)
				case uint8:
					val = int(value)
				case uint16:
					val = int(value)
				case uint32:
					val = int(value)
				case uint64:
					val = int(value)
				case string:
					sn = string(v.Value.([]byte))
					if sn != "" {
						ipSnMapping[meta.Ip] = sn
					}
					continue
				default:
					val = 0
				}
				if val > 0 {
					ipSnMapping[meta.Ip] = strconv.Itoa(val)
				}
			}
		}
	}
	return ipSnMapping
}

func snmpFetchSn(meta SnmpMeta) []g.SnmpPDU {
	var (
		defaultSnmp = g.Default
		pdus        []g.SnmpPDU
		err         error
	)
	defaultSnmp.Target = meta.Ip
	defaultSnmp.Community = meta.Group
	defaultSnmp.Version = g.Version2c
	err = g.Default.Connect()
	if err != nil {
		klog.Error(fmt.Sprintf("snmp Connect err: %v", err))
		return nil
	}
	defer g.Default.Conn.Close()
	for _, oid := range snOidList {
		pdus = snmpWalk(defaultSnmp, oid)
		if len(pdus) > 0 {
			return pdus
		}
	}
	hwIndex := hwEntPhysicalClassIndex(defaultSnmp, entPhysicalClass)
	if hwIndex != "" {
		snOid := snOidHuawei + "." + hwIndex
		pdus = snmpWalk(defaultSnmp, snOid)
		if len(pdus) > 0 {
			return pdus
		}
	}
	return pdus
}

func execute() {
	snmpMetaList := getValidIps()
	if len(snmpMetaList) == 0 {
		return
	}
	ipSnMapping := parseSn(snmpMetaList)
	updateAssetSwitch(ipSnMapping)
}

func Scheduler() {
	execute()
	// time.Sleep(30 * time.Second)
	// execute()
	// ticker := time.NewTicker(1 * time.Hour)
	// for range ticker.C {
	// 	execute()
	// }
}

// func init() {
// 	go Scheduler()
// }

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/pkg/tasks/snmp-task/memTask.go
```golang
package snmptask

import (
	"encoding/json"
	"errors"
	"fmt"
	g "github.com/gosnmp/gosnmp"
	switchMachine "luban-cmdb-api/pkg/models/switch"
)

func getSwitchMemInfo(meta SnmpMeta) (result string, err error) {
	var (
		mems  []switchMachine.SwitchMemory
		bytes []byte
	)
	switch meta.Sales {
	case "锐捷":
		mems, err = getRijieMemInfo(meta)
	case "华为":
		mems, err = getHuaweiMemInfo(meta)
	case "华三":
		mems, err = getH3cMemInfo(meta)
	default:
		err = errors.New("请指定交换机信息")
	}
	if err == nil {
		if bytes, err = json.Marshal(mems); err == nil {
			result = string(bytes)
		}
	}
	return
}

func getRijieMemInfo(meta SnmpMeta) (mems []switchMachine.SwitchMemory, err error) {
	var (
		pdus  []g.SnmpPDU
		mtype string
		names map[int]string
		//health     map[int]int
		utilization map[int]int
		//exist      map[int]bool
		//loction    map[int]string
		//tunnel     map[int]string
		//slotNum    map[int]string
		memType map[int]string
		//ranks      map[int]string
		//bitWide     map[int]int
		//maxHertz    map[int]float64
		capacity map[int]int
		//technology map[int]string
		//mfgName    map[int]string
		//serialNum  map[int]string
		//partNum    map[int]string
	)

	snmpClient := selfV2Client(meta)
	err = snmpClient.Connect()
	if err != nil {
		return nil, err
	}
	defer snmpClient.Conn.Close()
	pdus = snmpWalk(snmpClient, nodeMemoryPoolNameRuijie)
	if len(pdus) == 0 {
		err = errors.New("交换机内存列表为空")
		return
	}
	names = parsePartsStrValues(pdus)
	pdus = snmpWalk(snmpClient, nodeMemoryPoolCurrentUtilizationRuijie)
	utilization = parsePartsIntValues(pdus)
	pdus = snmpWalk(snmpClient, systemMemoryTypeRuijie)
	memType = parsePartsStrValues(pdus)
	pdus = snmpWalk(snmpClient, nodeMemoryPoolSizeRuijie)
	capacity = parsePartsIntValues(pdus)
	mems = make([]switchMachine.SwitchMemory, len(names))
	for i, name := range names {
		mem := switchMachine.SwitchMemory{
			Name:     name,
			Exist:    true,
			BitWide:  4,
			Location: fmt.Sprintf("board %d", i),
		}
		if mtype = memType[i]; mtype == "" {
			mtype = memType[1]
		}
		mem.Capacity = capacity[i] / 1024
		mem.Utilization = float64(utilization[i]) / 100
		mem.Exist = true
		mem.BitWide = 4
		mem.SlotNum = fmt.Sprintf("%d", i)
		mem.MemType = mtype
		//mems = append(mems, mem)
		mems[i-1] = mem
	}
	return
}

func getHuaweiMemInfo(meta SnmpMeta) (mems []switchMachine.SwitchMemory, err error) {
	var (
		pdus []g.SnmpPDU
		//mtype string
		deviceNums []string
		//names map[int]string
		//health     map[int]int
		utilization map[int]int
		//exist      map[int]bool
		//loction    map[int]string
		//tunnel     map[int]string
		//slotNum    map[int]string
		//memType map[int]string
		//ranks      map[int]string
		//bitWide     map[int]int
		//maxHertz    map[int]float64
		capacity map[int]int
		//technology map[int]string
		//mfgName    map[int]string
		//serialNum  map[int]string
		//partNum    map[int]string
	)

	snmpClient := selfV2Client(meta)
	err = snmpClient.Connect()
	if err != nil {
		return nil, err
	}
	defer snmpClient.Conn.Close()
	pdus = snmpWalk(snmpClient, hwMemoryDevSize)
	if len(pdus) == 0 {
		err = errors.New("交换机内存列表为空")
		return
	}
	capacity = parsePartsIntValues(pdus)
	deviceNums = getDeviceNum(snmpClient, 9)
	utilization = parseDeviceIntValues(snmpClient, deviceNums, hwEntityMemUsage)
	mems = make([]switchMachine.SwitchMemory, len(capacity))
	for i, value := range capacity {
		mem := switchMachine.SwitchMemory{
			Capacity: value / 1024 / 1000,
			Name:     fmt.Sprintf("Memory %d", i),
			BitWide:  4,
			Location: fmt.Sprintf("Board %d", i),
		}
		mem.Utilization = float64(utilization[i]) / 100
		mem.Exist = true
		mem.BitWide = 4
		mem.SlotNum = fmt.Sprintf("%d", i)
		//mem.MemType = mtype
		//mems = append(mems, mem)
		mems[i-1] = mem
	}
	return
}

func getH3cMemInfo(meta SnmpMeta) (mems []switchMachine.SwitchMemory, err error) {
	var (
		//pdus []g.SnmpPDU
		//mtype string
		deviceNums []string
		//names map[int]string
		//health     map[int]int
		utilization map[int]int
		//exist      map[int]bool
		//loction    map[int]string
		//tunnel     map[int]string
		//slotNum    map[int]string
		//memType map[int]string
		//ranks      map[int]string
		//bitWide     map[int]int
		//maxHertz    map[int]float64
		capacity map[int]int
		//technology map[int]string
		//mfgName    map[int]string
		//serialNum  map[int]string
		//partNum    map[int]string
	)

	snmpClient := selfV2Client(meta)
	err = snmpClient.Connect()
	if err != nil {
		return nil, err
	}
	defer snmpClient.Conn.Close()
	deviceNums = getDeviceNum(snmpClient, 9)
	capacity = parseDeviceIntValues(snmpClient, deviceNums, hh3cEntityExtMemSize)
	capacity = filterH3cCapacity(capacity)
	if len(capacity) == 0 {
		err = errors.New("交换机内存列表为空")
		return
	}
	utilization = parseDeviceIntValues(snmpClient, deviceNums, hh3cEntityExtMemUsage)
	mems = make([]switchMachine.SwitchMemory, len(capacity))
	for i, value := range capacity {
		mem := switchMachine.SwitchMemory{
			Capacity: value / 1024 / 1000,
			Name:     fmt.Sprintf("Memory %d", i),
			BitWide:  4,
			Location: fmt.Sprintf("Board %d", i),
		}
		mem.Utilization = float64(utilization[i]) / 100
		mem.Exist = true
		mem.BitWide = 4
		mem.SlotNum = fmt.Sprintf("%d", i)
		//mem.MemType = mtype
		//mems = append(mems, mem)
		mems[i-1] = mem
	}
	return
}

func filterH3cCapacity(capacity map[int]int) map[int]int {
	for i, value := range capacity {
		if value == 0 {
			delete(capacity, i)
		}
	}
	return capacity
}

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/pkg/tasks/snmp-task/partsTask.go
```golang
package snmptask

import (
	"context"
	"fmt"
	"luban-cmdb-api/pkg/gredis"
	"luban-cmdb-api/pkg/utils"
	"reflect"
	"sync"
	"time"

	"k8s.io/klog/v2"
)

type switchPartsFetcher func(meta SnmpMeta) (result string, err error)

func fetchSwitchPartsInfo(meta SnmpMeta, fn switchPartsFetcher, wg *sync.WaitGroup, redisKey string) {
	if wg != nil {
		//wg.Add(1)
		defer wg.Done()
	}
	result, err := fn(meta)
	if err != nil {
		klog.Error(fmt.Sprintf("sn %s %s get err: %v", meta.Sn, reflect.TypeOf(fn).Name(), err))
		return
	}
	ctx, celf := context.WithTimeout(context.Background(), 5*time.Second)
	_, err = gredis.HSet(ctx, redisKey, meta.Sn, result)
	celf()
	if err != nil {
		klog.Error(fmt.Sprintf("%s:%s:%s parts into redis err: %v", meta.Sales, meta.Sn, meta.Ip, err))
		return
	}
	klog.Info(fmt.Sprintf("%s:%s:%s:%s parts into redis successful", meta.Sales, meta.Sn, meta.Ip, redisKey))
}

func storeSwitchPartsInfo(meta SnmpMeta) {
	klog.Info("storeSwitchPartsInfo")
	var localWg = new(sync.WaitGroup)
	localWg.Add(5)
	utils.GoSafe(func() { fetchSwitchPartsInfo(meta, getSwitchFanInfo, localWg, gredis.SnmpSwitchFansKey) })
	utils.GoSafe(func() { fetchSwitchPartsInfo(meta, getSwitchPowerInfo, localWg, gredis.SnmpSwitchPowersKey) })
	utils.GoSafe(func() { fetchSwitchPartsInfo(meta, getSwitchMemInfo, localWg, gredis.SnmpSwitchMemsKey) })
	utils.GoSafe(func() { fetchSwitchPartsInfo(meta, getSwitchCpuInfo, localWg, gredis.SnmpSwitchCpusKey) })
	utils.GoSafe(func() { fetchSwitchPartsInfo(meta, getSwitchBoardInfo, localWg, gredis.SnmpSwitchBoardsKey) })
	localWg.Wait()
	fetchSwitchPartsInfo(meta, getSwitchView, nil, gredis.SnmpSwitchViewsKey)
}

func scheduleSwitchPartsInfo() {
	klog.Info("snmp_switch_hardware")
	metas := getValidSnmpMetas()
	klog.Info("scheduleSwitchPartsInfometas", metas)

	for i := 0; i < len(metas); i++ {
		storeSwitchPartsInfo(metas[i])
	}

	//var wg = new(sync.WaitGroup)
	//for i := 0; i < len(metas); i++ {
	//	if (i+1)%10 != 0 {
	//		wg.Add(1)
	//	} else {
	//		wg.Wait()
	//		wg.Add(1)
	//	}
	//
	//	utils.GoSafe(
	//		func() {
	//			func(meta SnmpMeta) {
	//				storeSwitchPartsInfo(meta)
	//				wg.Done()
	//			}(metas[i])
	//		})
	//	//storeSwitchPartsInfo(metas[i])
	//	//wg.Done()
	//}
	//wg.Wait()
}

func PartsTaskScheduler() {
	time.Sleep(40 * time.Second)
	//scheduleSwitchPartsInfo()
	//ticker := time.NewTicker(15 * time.Minute)
	//for range ticker.C {
	for {
		klog.Info("snmp switch parts information beging...")
		scheduleSwitchPartsInfo()
		klog.Info("snmp switch parts information over...")
		time.Sleep(15 * time.Minute)
	}
}

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/pkg/tasks/snmp-task/boardTask.go
```golang
package snmptask

import (
	"encoding/json"
	"errors"
	switchMachine "luban-cmdb-api/pkg/models/switch"
)

//func getSwitchBoardInfo(meta SnmpMeta) (boards []switchMachine.SwitchBoard, err error) {
func getSwitchBoardInfo(meta SnmpMeta) (result string, err error) {
	var (
		boards []switchMachine.SwitchBoard
		bytes  []byte
	)
	switch meta.Sales {
	case "锐捷":
		boards, err = getRijieBoardInfo(meta)
	case "华为":
		boards, err = getHuaweiBoardInfo(meta)
	case "华三":
		boards, err = getH3cBoardInfo(meta)
	default:
		err = errors.New("请指定交换机信息")
	}
	if err == nil {
		if bytes, err = json.Marshal(boards); err == nil {
			result = string(bytes)
		}
	}
	return
}

func getRijieBoardInfo(meta SnmpMeta) (boards []switchMachine.SwitchBoard, err error) {
	defer func() {
		if e := recover(); e != nil {
			err, _ = e.(error)
		}
	}()
	var (
		deviceNums []string
		names      map[int]string
		//health          map[int]int
		//manufaturedDate map[int]string
		mfgName   map[int]string
		serialNum map[int]string
		partNum   map[int]string
	)
	snmpClient := selfV2Client(meta)
	err = snmpClient.Connect()
	if err != nil {
		return nil, err
	}
	defer snmpClient.Conn.Close()
	deviceNums = getDeviceNum(snmpClient, 9)
	if len(deviceNums) == 0 {
		err = errors.New("交换机主板列表为空")
		return
	}
	names = parseDeviceStrValues(snmpClient, deviceNums, entPhysicalName)
	//names = parseDeviceStrValues(snmpClient, deviceNums, hwEntityBoardType)
	//manufaturedDate = parseDeviceStrValues(snmpClient, deviceNums, hwEntityManufacturedDate)
	//manufaturedDate = parseSnmpTime(snmpClient, deviceNums, hwEntityManufacturedDate)
	mfgName = parseDeviceStrValues(snmpClient, deviceNums, entPhysicalMfgName)
	serialNum = parseDeviceStrValues(snmpClient, deviceNums, entPhysicalSerialNum)
	partNum = parseDevicePartNum(snmpClient, 9)
	boards = make([]switchMachine.SwitchBoard, len(names))
	for i, name := range names {
		board := switchMachine.SwitchBoard{
			Name: name,
		}
		//board.ManufacturedDate = manufaturedDate[i]
		board.Health = 1
		board.MfgName = mfgName[i]
		board.SerialNum = serialNum[i]
		board.PartNum = partNum[i]
		//boards = append(boards, board)
		boards[i-1] = board
	}
	return
}

func getHuaweiBoardInfo(meta SnmpMeta) (boards []switchMachine.SwitchBoard, err error) {
	defer func() {
		if e := recover(); e != nil {
			err, _ = e.(error)
		}
	}()
	var (
		deviceNums []string
		names      map[int]string
		//health          map[int]int
		manufaturedDate map[int]string
		mfgName         map[int]string
		serialNum       map[int]string
		partNum         map[int]string
	)
	snmpClient := selfV2Client(meta)
	err = snmpClient.Connect()
	if err != nil {
		return nil, err
	}
	defer snmpClient.Conn.Close()
	deviceNums = getDeviceNum(snmpClient, 9)
	if len(deviceNums) == 0 {
		err = errors.New("交换机主板列表为空")
		return
	}
	names = parseDeviceStrValues(snmpClient, deviceNums, entPhysicalName)
	//names = parseDeviceStrValues(snmpClient, deviceNums, hwEntityBoardType)
	//manufaturedDate = parseDeviceStrValues(snmpClient, deviceNums, hwEntityManufacturedDate)
	manufaturedDate = parseSnmpTime(snmpClient, deviceNums, hwEntityManufacturedDate)
	mfgName = parseDeviceStrValues(snmpClient, deviceNums, entPhysicalMfgName)
	serialNum = parseDeviceStrValues(snmpClient, deviceNums, entPhysicalSerialNum)
	partNum = parseDevicePartNum(snmpClient, 9)
	boards = make([]switchMachine.SwitchBoard, len(names))
	for i, name := range names {
		board := switchMachine.SwitchBoard{
			Name: name,
		}
		board.ManufacturedDate = manufaturedDate[i]
		board.Health = 1
		board.MfgName = mfgName[i]
		board.SerialNum = serialNum[i]
		board.PartNum = partNum[i]
		//boards = append(boards, board)
		boards[i-1] = board
	}
	return
}

func getH3cBoardInfo(meta SnmpMeta) (boards []switchMachine.SwitchBoard, err error) {
	defer func() {
		if e := recover(); e != nil {
			err, _ = e.(error)
		}
	}()
	var (
		deviceNums []string
		names      map[int]string
		//health          map[int]int
		manufaturedDate map[int]string
		mfgName         map[int]string
		serialNum       map[int]string
		partNum         map[int]string
	)
	snmpClient := selfV2Client(meta)
	err = snmpClient.Connect()
	if err != nil {
		return nil, err
	}
	defer snmpClient.Conn.Close()
	deviceNums = getDeviceNum(snmpClient, 9)
	if len(deviceNums) == 0 {
		err = errors.New("交换机主板列表为空")
		return
	}
	names = parseDeviceStrValues(snmpClient, deviceNums, entPhysicalName)
	//manufaturedDate = parseDeviceStrValues(snmpClient, deviceNums, hwEntityManufacturedDate)
	manufaturedDate = parseSnmpTime(snmpClient, deviceNums, entPhysicalMfgDate)
	mfgName = parseDeviceStrValues(snmpClient, deviceNums, entPhysicalMfgName)
	serialNum = parseDeviceStrValues(snmpClient, deviceNums, entPhysicalSerialNum)
	partNum = parseDevicePartNum(snmpClient, 9)
	boards = make([]switchMachine.SwitchBoard, len(names))
	for i, name := range names {
		board := switchMachine.SwitchBoard{
			Name: name,
		}
		board.ManufacturedDate = manufaturedDate[i]
		board.Health = 1
		board.MfgName = mfgName[i]
		board.SerialNum = serialNum[i]
		board.PartNum = partNum[i]
		//boards = append(boards, board)
		boards[i-1] = board
	}
	return
}

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/pkg/tasks/snmp-task/common.go
```golang
package snmptask

import (
	"encoding/hex"
	"fmt"
	g "github.com/gosnmp/gosnmp"
	"k8s.io/klog/v2"
	"luban-cmdb-api/pkg/dao"
	"regexp"
	"strings"
	"time"
)

func defaultV2Client(meta SnmpMeta) *g.GoSNMP {
	var (
		defaultSnmp = g.Default
		//err         error
	)
	defaultSnmp.Target = meta.Ip
	defaultSnmp.Community = meta.Group
	defaultSnmp.Version = g.Version2c
	//err = defaultSnmp.Connect()
	//if err != nil {
	//	//klog.Error(fmt.Sprintf("snmp Connect err: %v", err))
	//	return nil,err
	//}
	return defaultSnmp
}

/*
	此函数新建一个独立的snmp客户端，谁链接谁关闭；用于并发请求场景
*/
func selfV2Client(meta SnmpMeta) *g.GoSNMP {
	var (
		snmpClient = &g.GoSNMP{
			Port:               161,
			Transport:          "udp",
			Community:          "public",
			Version:            g.Version2c,
			Timeout:            time.Duration(2) * time.Second,
			Retries:            3,
			ExponentialTimeout: true,
			MaxOids:            g.MaxOids,
		}
		//err         error
	)
	snmpClient.Target = meta.Ip
	snmpClient.Community = meta.Group
	return snmpClient
}

func getValidIps() []SnmpMeta {
	var ips []string
	var snmpMetaList []SnmpMeta
	_ = dao.AssetDB.Table("asset_switch").Select("ip").Where("deleted = ?", dao.DELETED_N).Where("sn IS NULL or sn = ''").Find(&ips)
	if len(ips) > 0 {
		_ = dao.AssetDB.Table("asset_switch_snmp_meta").Where("deleted = ? and ip in (?)", dao.DELETED_N, ips).Scan(&snmpMetaList)
	}
	return snmpMetaList
}

func getValidSnmpMetas() []SnmpMeta {
	//var ips []string
	var snmpMetaList []SnmpMeta
	_ = dao.AssetDB.Table("(select sn,ip,system_sales sales from asset_switch where deleted = ? and run_status = 'up' and (sn is not null or sn != '')) as sw", dao.DELETED_N).
		Joins("left join (select ip,community from asset_switch_snmp_meta where deleted = ?) as meta on sw.ip = meta.ip", dao.DELETED_N).
		Select("sw.sn,sw.ip ip,meta.community,sw.sales").
		Scan(&snmpMetaList)
	return snmpMetaList
}

//更改snmp状态
func updateSnmpState(ip string, snmpStatus int) {
	err := dao.AssetDB.Table("asset_switch").Where("ip = ?", ip).Update("snmp_status", snmpStatus).Error
	if err != nil {
		klog.Error(fmt.Sprintf("update ip: %s  faliure. err: %v", ip, err))
	}
}

func snmpWalk(snmpClient *g.GoSNMP, oid string) []g.SnmpPDU {
	var pdus []g.SnmpPDU
	var err error
	pdus, err = snmpClient.WalkAll(oid)
	if err != nil {
		errStr := fmt.Sprintf("snmp Get err: %v", err)
		klog.Error(errStr)
		if strings.Contains(errStr, "timeout") {
			//更改snmp状态 异常
			updateSnmpState(snmpClient.Target, 1)
		}
		return nil
	} else {
		updateSnmpState(snmpClient.Target, 0)
		//更改snmp状态 异常
	}
	return pdus
}

func snmpGet(snmpClient *g.GoSNMP, oids []string) []g.SnmpPDU {
	var pdus []g.SnmpPDU
	var packet *g.SnmpPacket
	var err error
	packet, err = snmpClient.Get(oids)
	bs, _ := packet.MarshalMsg()
	packet = snmpClient.UnmarshalTrap(bs, false)
	//packet = snmpClient
	if err != nil {
		klog.Error(fmt.Sprintf("snmp Get err: %v", err))
		return nil
	}
	pdus = packet.Variables
	return pdus
}

func hwEntPhysicalClassIndex(snmpClient *g.GoSNMP, indexOid string) (index string) {
	var (
		pdus []g.SnmpPDU
	)
	pdus = snmpWalk(snmpClient, indexOid)
	for _, pdu := range pdus {
		if value, ok := pdu.Value.(int); ok && value == 9 {
			nameSlice := strings.Split(pdu.Name, ".")
			index = nameSlice[len(nameSlice)-1]
			return
		}
	}
	return
}

func getDeviceNum(snmpClient *g.GoSNMP, classNum int) (deviceNums []string) {
	var (
		pdus  []g.SnmpPDU
		class int
	)
	if pdus = snmpWalk(snmpClient, entPhysicalClass); len(pdus) > 0 {
		for _, pdu := range pdus {
			if class, _ = pdu.Value.(int); class == classNum {
				if num := regexp.MustCompile("\\.[0-9]+$").FindString(pdu.Name); num != "" {
					deviceNums = append(deviceNums, num)
				}
			}
		}
	}
	return
}

func parsePartsIntValues(pdus []g.SnmpPDU) (values map[int]int) {
	if len(pdus) > 0 {
		values = make(map[int]int)
		var (
			index int
			value int
		)
		for i, pdu := range pdus {
			index = i + 1
			switch pdu.Value.(type) {
			case uint:
				x, _ := pdu.Value.(uint)
				value = int(x)
			default:
				value, _ = pdu.Value.(int)
			}

			values[index] = value
		}
	}
	return
}
func parsePartsStrValues(pdus []g.SnmpPDU) (values map[int]string) {
	if len(pdus) > 0 {
		values = make(map[int]string)
		var (
			index int
			ok    bool
			bytes []byte
		)
		for i, pdu := range pdus {
			index = i + 1
			if bytes, ok = pdu.Value.([]byte); ok {
				values[index] = string(bytes)
			}
		}
	}
	return
}

func parseDeviceStrValues(snmpClient *g.GoSNMP, deviceNums []string, oid string) (values map[int]string) {
	var (
		pdus []g.SnmpPDU
		//deviceNums []string
	)
	values = make(map[int]string)
	//deviceNums = getDeviceNum(snmpClient, classNum) //编号6为电源
	if len(deviceNums) > 0 {
		for i, num := range deviceNums {
			if pdus = snmpWalk(snmpClient, oid+num); len(pdus) > 0 {
				bytes, ok := pdus[0].Value.([]byte)
				if !ok {
					continue
				}
				var value string
				if regexp.MustCompile("^.*[^\\x{00}-\\x{00FF}]+.*$").Match(bytes) {
					//value = parseOctet(bytes)
					value = hex.EncodeToString(bytes)
				} else {
					value = string(bytes)
				}
				if value != "" {
					values[i+1] = value
				}
			}
		}
	}
	return
}
func parseDeviceIntValues(snmpClient *g.GoSNMP, deviceNums []string, oid string) (values map[int]int) {
	var (
		pdus []g.SnmpPDU
		//deviceNums []string
	)
	//deviceNums = getDeviceNum(snmpClient, classNum)
	values = make(map[int]int)
	if len(deviceNums) > 0 {
		for i, num := range deviceNums {
			if pdus = snmpWalk(snmpClient, oid+num); len(pdus) > 0 {
				var (
					x     uint
					value int
				)
				switch pdus[0].Value.(type) {
				case uint:
					x, _ = pdus[0].Value.(uint)
					value = int(x)
				default:
					value, _ = pdus[0].Value.(int)
				}
				values[i+1] = value
			}
		}
	}
	return
}

func parseSnmpTime(snmpClient *g.GoSNMP, deviceNums []string, oid string) (values map[int]string) {
	var (
		pdus []g.SnmpPDU
	)
	values = make(map[int]string)
	if len(deviceNums) > 0 {
		for i, num := range deviceNums {
			if pdus = snmpWalk(snmpClient, oid+num); len(pdus) > 0 {
				bytes, ok := pdus[0].Value.([]byte)
				if !ok {
					continue
				}
				var value string
				if regexp.MustCompile("^.*[^\\x{00}-\\x{00FF}]+.*$").Match(bytes) {
					year := (int(bytes[0]) << 8) | int(bytes[1])
					value = fmt.Sprintf("%d-%d-%d %02d:%02d:%02d.%d", year, bytes[2], bytes[3], bytes[4], bytes[5], bytes[6], bytes[7])
				} else {
					value = string(bytes)
				}
				if value != "" {
					values[i+1] = value
				}
			}
		}
	}
	return
}

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/pkg/tasks/snmp-task/powersTask.go
```golang
package snmptask

import (
	"encoding/json"
	"errors"
	"fmt"
	switchMachine "luban-cmdb-api/pkg/models/switch"
	"strings"

	g "github.com/gosnmp/gosnmp"
)

func getSwitchPowerInfo(meta SnmpMeta) (result string, err error) {
	var (
		powers []switchMachine.SwitchPower
		bytes  []byte
	)

	switch meta.Sales {
	case "锐捷":
		powers, err = getRijiePowerInfo(meta)
	case "华为":
		powers, err = getHuaweiPowerInfo(meta)
	case "华三":
		powers, err = getH3cPowerInfo(meta)
	default:
		err = errors.New("请指定交换机厂商信息")
	}
	if err == nil {
		if bytes, err = json.Marshal(powers); err == nil {
			result = string(bytes)
		}
	}
	return
}

func getRijiePowerInfo(meta SnmpMeta) (powers []switchMachine.SwitchPower, err error) {
	var (
		pdus        []g.SnmpPDU
		deviceNums  []string
		names       map[int]string
		health      map[int]int
		exists      map[int]bool
		temperature map[int]int
		ratedPower  map[int]int
		inPower     map[int]int
		//inModel         map[int]string
		powerType       map[int]string
		firmwareVersion map[int]string
		mfgName         map[int]string
		serialNum       map[int]string
		partNum         map[int]string
	)

	snmpClient := selfV2Client(meta)
	err = snmpClient.Connect()
	if err != nil {
		return nil, err
	}
	defer snmpClient.Conn.Close()
	pdus = snmpWalk(snmpClient, systemPowerNameRuijie)
	if len(pdus) == 0 {
		err = errors.New("交换机电源名称列表为空")
		return
	}
	names = parseRuijiePartsName(pdus)
	pdus = snmpWalk(snmpClient, systemElectricalSourceNumRuijie)
	maxPowerNum := parseMaxPowerNum(pdus)
	names = reBuildNames(names, maxPowerNum)
	pdus = snmpWalk(snmpClient, systemPowerIsNormalRuijie)
	health = parseRuijiePartsHealth(pdus)
	exists = parseRuijiePartsExist(pdus)
	pdus = snmpWalk(snmpClient, systemPowerTemperatureRuijie)
	temperature = parsePartsIntValues(pdus)
	pdus = snmpWalk(snmpClient, systemRatedPowerRuijie)
	ratedPower = parsePartsIntValues(pdus)
	inPower = parseRuijiePartsInPower(snmpClient)
	pdus = snmpWalk(snmpClient, systemPowerTypeRuijie)
	powerType = parsePartsStrValues(pdus)
	pdus = snmpWalk(snmpClient, systemPowerFirmwareVersionRuijie)
	firmwareVersion = parsePartsStrValues(pdus)
	deviceNums = getDeviceNum(snmpClient, 6)
	mfgName = parseDeviceStrValues(snmpClient, deviceNums, entPhysicalMfgName)
	pdus = snmpWalk(snmpClient, systemPowerSerialRuijie)
	serialNum = parsePartsStrValues(pdus)
	//partNum = parseDeviceStrValues(snmpClient, entPhysicalSerialNum)
	partNum = parseDevicePartNum(snmpClient, 6)
	powers = make([]switchMachine.SwitchPower, len(names))
	for i, name := range names {
		power := switchMachine.SwitchPower{
			Name: name,
		}
		power.Health = health[i]
		power.Exist = exists[i]
		power.Temperature = temperature[i]
		power.RatedPower = ratedPower[i]
		power.InPower = inPower[i]
		power.PowerType = powerType[i]
		power.FirmwareVersion = firmwareVersion[i]
		power.MfgName = mfgName[i]
		power.SerialNum = serialNum[i]
		power.PartNum = partNum[i]
		//powers = append(powers, power)
		powers[i-1] = power
	}
	return
}

func getHuaweiPowerInfo(meta SnmpMeta) (powers []switchMachine.SwitchPower, err error) {
	var (
		pdus        []g.SnmpPDU
		deviceNums  []string
		names       map[int]string
		health      map[int]int
		exists      map[int]bool
		temperature map[int]int
		ratedPower  map[int]int
		//inPower map[int]int
		inModel         map[int]string
		powerType       map[int]string
		firmwareVersion map[int]string
		mfgName         map[int]string
		serialNum       map[int]string
		partNum         map[int]string
	)
	snmpClient := selfV2Client(meta)
	err = snmpClient.Connect()
	if err != nil {
		return nil, err
	}
	defer snmpClient.Conn.Close()
	pdus = snmpWalk(snmpClient, hwEntityPwrSn)
	maxPowerNum := parseMaxPowerNum(pdus)
	deviceNums = getDeviceNum(snmpClient, 6) // 6代表电源
	names = parseDeviceStrValues(snmpClient, deviceNums, entPhysicalName)
	names = reBuildNames(names, maxPowerNum)
	if len(names) == 0 {
		err = errors.New("交换机电源名称列表为空")
		return
	}
	pdus = snmpWalk(snmpClient, hwEntityPwrState)
	health = parseHwPartsHealth(pdus)
	pdus = snmpWalk(snmpClient, hwEntityPwrPresent)
	exists = parseHwPartsExist(pdus)
	temperature = parseDeviceIntValues(snmpClient, deviceNums, hwEntityTemperature) //编号6为电源
	ratedPower = parseHwRatedPower(snmpClient)
	pdus = snmpWalk(snmpClient, hwEntityPwrMode)
	inModel = parseHwPowerInMode(pdus)
	//powerType = parseDeviceStrValues(snmpClient, deviceNums, entPhysicalModelName)
	powerType = parseDeviceStrValues(snmpClient, deviceNums, hwEntityBoardType)
	firmwareVersion = parseDeviceStrValues(snmpClient, deviceNums, hwEntityArchivesInfoVersion)
	mfgName = parseDeviceStrValues(snmpClient, deviceNums, entPhysicalMfgName)
	serialNum = parseDeviceStrValues(snmpClient, deviceNums, entPhysicalSerialNum)
	//pdus = snmpWalk(snmpClient, hwEntityPwrSn)
	partNum = parseDevicePartNum(snmpClient, 6)
	powers = make([]switchMachine.SwitchPower, len(names))
	for i, name := range names {
		power := switchMachine.SwitchPower{
			Name: name,
		}
		power.Health = health[i]
		power.Exist = exists[i]
		power.Temperature = temperature[i]
		power.RatedPower = ratedPower[i]
		power.InModel = inModel[i]
		power.PowerType = powerType[i]
		power.FirmwareVersion = firmwareVersion[i]
		power.MfgName = mfgName[i]
		power.SerialNum = serialNum[i]
		power.PartNum = partNum[i]
		//powers = append(powers, power)
		powers[i-1] = power
	}
	return
}
func getH3cPowerInfo(meta SnmpMeta) (powers []switchMachine.SwitchPower, err error) {
	var (
		pdus        []g.SnmpPDU
		deviceNums  []string
		names       map[int]string
		health      map[int]int
		exists      map[int]bool
		temperature map[int]int
		//ratedPower  map[int]int
		inPower map[int]int
		//inModel map[int]string
		powerType map[int]string
		//firmwareVersion map[int]string
		mfgName   map[int]string
		serialNum map[int]string
		partNum   map[int]string
	)

	snmpClient := selfV2Client(meta)
	err = snmpClient.Connect()
	if err != nil {
		return nil, err
	}
	defer snmpClient.Conn.Close()
	pdus = snmpWalk(snmpClient, hh3cDevMPowerNum)
	maxPowerNum := parseMaxPowerNum(pdus)
	deviceNums = getDeviceNum(snmpClient, 6) //6代表电源
	names = parseDeviceStrValues(snmpClient, deviceNums, entPhysicalName)
	names = reBuildNames(names, maxPowerNum)
	if len(names) == 0 {
		err = errors.New("交换机电源名称列表为空")
		return
	}
	pdus = snmpWalk(snmpClient, hh3cDevMPowerStatus)
	health = parseH3cPartsHealth(pdus)
	exists = parseH3cPartsExist(pdus)
	temperature = parseDeviceIntValues(snmpClient, deviceNums, hh3cEntityExtTemperature)
	inPower = parseH3cInPower(snmpClient, deviceNums)
	powerType = parseDeviceStrValues(snmpClient, deviceNums, entPhysicalModelName)
	mfgName = parseDeviceStrValues(snmpClient, deviceNums, entPhysicalMfgName)
	serialNum = parseDeviceStrValues(snmpClient, deviceNums, entPhysicalSerialNum)
	partNum = parseDevicePartNum(snmpClient, 6)
	powers = make([]switchMachine.SwitchPower, len(names))
	for i, name := range names {
		power := switchMachine.SwitchPower{
			Name: name,
		}
		power.Health = health[i]
		power.Exist = exists[i]
		power.Temperature = temperature[i]
		power.InPower = inPower[i]
		power.PowerType = powerType[i]
		power.MfgName = mfgName[i]
		power.SerialNum = serialNum[i]
		power.PartNum = partNum[i]
		//powers = append(powers, power)
		powers[i-1] = power
	}
	return
}

func parseRuijiePartsInPower(snmpClient *g.GoSNMP) (values map[int]int) {
	var (
		pduVoltages []g.SnmpPDU
		pduCurrents []g.SnmpPDU
		inVoltages  map[int]int
		inCurrents  map[int]int
	)
	pduVoltages = snmpWalk(snmpClient, systemPowerInVoltageRuijie)
	inVoltages = parsePartsIntValues(pduVoltages)
	pduCurrents = snmpWalk(snmpClient, systemPowerInCurrentRuijie)
	inCurrents = parsePartsIntValues(pduCurrents)
	values = make(map[int]int)
	for i, volt := range inVoltages {
		values[i] = volt * inCurrents[i]
	}
	return
}

func parseHwRatedPower(snmpClient *g.GoSNMP) (values map[int]int) {
	var (
		pduVoltages []g.SnmpPDU
		pduCurrents []g.SnmpPDU
		inVoltages  map[int]int
		inCurrents  map[int]int
	)
	pduVoltages = snmpWalk(snmpClient, hwEntityPwrVoltage)
	inVoltages = parsePartsIntValues(pduVoltages)
	pduCurrents = snmpWalk(snmpClient, hwEntityPwrCurrent)
	inCurrents = parsePartsIntValues(pduCurrents)
	values = make(map[int]int)
	for i, volt := range inVoltages {
		values[i] = (volt / 1000) * (inCurrents[i] / 1000)
	}
	return
}

func parseHwPartsHealth(pdus []g.SnmpPDU) (health map[int]int) {
	if len(pdus) > 0 {
		health = make(map[int]int)
		var (
			value int
		)
		for i, pdu := range pdus {
			value, _ = pdu.Value.(int)
			switch value {
			case 1:
				value = 1
			case 2, 3: //不供电或电源休眠
				value = 2
			case 4:
				value = 4
			default:
				value = 3
			}
			health[i+1] = value
		}
	}
	return
}

func parseHwPowerInMode(pdus []g.SnmpPDU) (modes map[int]string) {
	if len(pdus) > 0 {
		modes = make(map[int]string)
		var value string
		for i, pdu := range pdus {
			if num, ok := pdu.Value.(int); ok {
				switch num {
				case 1:
					value = "unknown"
				case 2:
					value = "dc"
				case 3:
					value = "ac"
				default:
					value = ""
				}
				modes[i+1] = value
			}
		}
	}
	return
}

func parseDevicePartNum(snmpClient *g.GoSNMP, classNum int) (partNums map[int]string) {
	deviceNums := getDeviceNum(snmpClient, classNum) //编号6为电源
	if len(deviceNums) > 0 {
		partNums = make(map[int]string)
		for i, num := range deviceNums {
			partNums[i+1] = strings.Trim(num, ".")
		}
	}
	return
}

func parseMaxPowerNum(pdus []g.SnmpPDU) (maxNum int) {
	if len(pdus) > 0 {
		pdu := pdus[len(pdus)-1]
		maxNum, _ = pdu.Value.(int)
	}
	return
}

func reBuildNames(names map[int]string, maxNum int) map[int]string {
	if names == nil || len(names) == 0 {
		return names
	}
	if len(names) < maxNum {
		for i := 1; i <= maxNum; i++ {
			names[i] = fmt.Sprintf("Power Supply %d", i)
		}
	}
	return names
}

func parseH3cPartsHealth(pdus []g.SnmpPDU) (health map[int]int) {
	if len(pdus) > 0 {
		health = make(map[int]int)
		var (
			value int
		)
		for i, pdu := range pdus {
			value, _ = pdu.Value.(int)
			switch value {
			case 1:
				value = 1
			case 2:
				value = 3
			case 3, 4:
				value = 2
			default:
				value = 4
			}
			health[i+1] = value
		}
	}
	return
}

func parseH3cInPower(snmpClient *g.GoSNMP, deviceNums []string) (values map[int]int) {
	values = parseDeviceIntValues(snmpClient, deviceNums, hh3cEntityExtCurrentPower)
	for i, value := range values {
		values[i] = value / 1000
	}
	return
}

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/pkg/tasks/snmp-task/viewTask.go
```golang
package snmptask

import (
	"context"
	"encoding/json"
	"errors"
	"fmt"
	g "github.com/gosnmp/gosnmp"
	"k8s.io/klog/v2"
	"luban-cmdb-api/pkg/dao"
	"luban-cmdb-api/pkg/gredis"
	switchMachine "luban-cmdb-api/pkg/models/switch"
	"time"
)

func checkHealth(cs []switchMachine.HealthChecker) (result switchMachine.SwitchHealth) {
	for _, c := range cs {
		switch c.GetHealth() {
		case 0:
			result.UnKnown++
		case 1:
			result.Normal++
		case 2:
			result.Alarm++
		case 3:
			result.AbNormal++
		}
	}
	result.Total = len(cs)
	return
}

func getMaxTemperature(tempes map[int]int) (value int) {
	for _, tempe := range tempes {
		if tempe > value {
			value = tempe
		}
	}
	return
}

func getSwitchPartsHealth(redisKey, sn string) (health switchMachine.SwitchHealth) {
	ctx, celf := context.WithTimeout(context.Background(), 5*time.Second)
	strJson, err := gredis.HGet(ctx, redisKey, sn)
	celf()
	if err != nil {
		klog.Error(fmt.Sprintf("read data from redis key: %s field: %s err: %v", redisKey, sn, err))
		return
	}
	var cs []switchMachine.HealthChecker
	switch redisKey {
	case gredis.SnmpSwitchFansKey:
		var values []switchMachine.SwitchFan
		err = json.Unmarshal([]byte(strJson), &values)
		if err != nil {
			klog.Error(fmt.Sprintf("Unmarshal fans json: %s err: %v", strJson, err))
			return
		}
		for _, value := range values {
			cs = append(cs, value)
		}
	case gredis.SnmpSwitchPowersKey:
		var values []switchMachine.SwitchPower
		err = json.Unmarshal([]byte(strJson), &values)
		if err != nil {
			klog.Error(fmt.Sprintf("Unmarshal powers json: %s err: %v", strJson, err))
			return
		}
		for _, value := range values {
			cs = append(cs, value)
		}
	case gredis.SnmpSwitchCpusKey:
		var values []switchMachine.SwitchCpu
		err = json.Unmarshal([]byte(strJson), &values)
		if err != nil {
			klog.Error(fmt.Sprintf("Unmarshal cpus json: %s err: %v", strJson, err))
			return
		}
		for _, value := range values {
			cs = append(cs, value)
		}
	case gredis.SnmpSwitchMemsKey:
		var values []switchMachine.SwitchMemory
		err = json.Unmarshal([]byte(strJson), &values)
		if err != nil {
			klog.Error(fmt.Sprintf("Unmarshal memories json: %s err: %v", strJson, err))
			return
		}
		for _, value := range values {
			cs = append(cs, value)
		}
	case gredis.SnmpSwitchBoardsKey:
		var values []switchMachine.SwitchBoard
		err = json.Unmarshal([]byte(strJson), &values)
		if err != nil {
			klog.Error(fmt.Sprintf("Unmarshal boards json: %s err: %v", strJson, err))
			return
		}
		for _, value := range values {
			cs = append(cs, value)
		}
	}
	return checkHealth(cs)
}

//func getSwitchIfHealth(sn string) (health switchMachine.SwitchHealth) {
//	err := dao.AssetDB.Table("asset_switch_interface_details").
//		Select("sum(case when if_status = 1 then 1 else 0 end) normal,sum(case when if_status = 2 then 1 else 0 end) ab_normal,sum(case when if_status != 2 and if_status != 1 then 1 else 0 end) unknown,count(1) total").
//		Where("sn = ?", sn).Scan(&health).Error
//	if err != nil {
//		klog.Error("statistics the status of switch interfaces got err: %v", err)
//	}
//	return
//}
//todo 去除历史状态查询问题
//func getSwitchIfHealth(sn string) (health switchMachine.SwitchHealth) {
//	err := dao.AssetDB.Table("asset_switch_interface_initial_status").
//		Select("sum(case when port_state = 1 then 1 else 0 end) normal,sum(case when port_state = 2 then 1 else 0 end) ab_normal,sum(case when port_state = 3 then 1 else 0 end) alarm, sum(case when port_state = 4 then 1 else 0 end) unKnown,count(1) total").
//		Where("sn = ?", sn).Scan(&health).Error
//	if err != nil {
//		klog.Error("statistics the status of switch interfaces got err: %v", err)
//	}
//	return
//}

// normal 正常
// ab_normal 关闭
// unKnown 故障
func getSwitchIfHealth(sn string) (health switchMachine.SwitchHealth) {
	err := dao.AssetDB.Table("asset_switch_interface_details").
		Select("sum( CASE WHEN port_state = 1 THEN 1 ELSE 0 END ) normal,"+
			"sum( CASE WHEN port_state = 2 THEN 1 ELSE 0 END ) ab_normal,"+
			"sum( CASE WHEN port_state = 3 THEN 1 ELSE 0 END ) unKnown,"+
			"count( 1 ) total ").
		Where("sn = ?", sn).Scan(&health).Error
	if err != nil {
		klog.Error("statistics the status of switch interfaces got err: %v", err)
	}
	return
}

func getSwitchView(meta SnmpMeta) (result string, err error) {
	var (
		view  switchMachine.SwitchView
		bytes []byte
	)
	switch meta.Sales {
	case "锐捷":
		view, err = getRijieViewInfo(meta)
	case "华为":
		view, err = getHuaweiViewInfo(meta)
	case "华三":
		view, err = getH3cViewInfo(meta)
	default:
		err = errors.New("请指定交换机信息")
	}
	if err == nil {
		if bytes, err = json.Marshal(view); err == nil {
			result = string(bytes)
		}
	}
	return
}

func getRijieViewInfo(meta SnmpMeta) (view switchMachine.SwitchView, err error) {
	var (
		pdus []g.SnmpPDU
	)
	snmpClient := selfV2Client(meta)
	err = snmpClient.Connect()
	if err != nil {
		return
	}
	defer snmpClient.Conn.Close()
	pdus = snmpWalk(snmpClient, systemMultipleTemperatureCurrentRuijie)
	view.AirInLet = getMaxTemperature(parseRuijieMultipleTemperature(pdus, 2))
	view.AirOutLet = getMaxTemperature(parseRuijieMultipleTemperature(pdus, 1))
	view.IfHealth = getSwitchIfHealth(meta.Sn)
	view.CpuHealth = getSwitchPartsHealth(gredis.SnmpSwitchCpusKey, meta.Sn)
	view.MemHealth = getSwitchPartsHealth(gredis.SnmpSwitchMemsKey, meta.Sn)
	view.PowerHealth = getSwitchPartsHealth(gredis.SnmpSwitchPowersKey, meta.Sn)
	view.FanHealth = getSwitchPartsHealth(gredis.SnmpSwitchFansKey, meta.Sn)
	return
}

func getHuaweiViewInfo(meta SnmpMeta) (view switchMachine.SwitchView, err error) {
	snmpClient := selfV2Client(meta)
	err = snmpClient.Connect()
	if err != nil {
		return
	}
	defer snmpClient.Conn.Close()
	//pdus = snmpWalk(snmpClient, systemMultipleTemperatureCurrentRuijie)
	deviceNums := getDeviceNum(snmpClient, 9)
	//view.AirInLet = getMaxTemperature(parseDeviceIntValues(snmpClient, deviceNums, hwEntityTemperature))
	view.AirOutLet = getMaxTemperature(parseDeviceIntValues(snmpClient, deviceNums, hwEntityTemperature))
	if view.AirOutLet > 300 {
		view.AirOutLet = 0
	}
	view.IfHealth = getSwitchIfHealth(meta.Sn)
	view.CpuHealth = getSwitchPartsHealth(gredis.SnmpSwitchCpusKey, meta.Sn)
	view.MemHealth = getSwitchPartsHealth(gredis.SnmpSwitchMemsKey, meta.Sn)
	view.PowerHealth = getSwitchPartsHealth(gredis.SnmpSwitchPowersKey, meta.Sn)
	view.FanHealth = getSwitchPartsHealth(gredis.SnmpSwitchFansKey, meta.Sn)
	return
}

func getH3cViewInfo(meta SnmpMeta) (view switchMachine.SwitchView, err error) {
	snmpClient := selfV2Client(meta)
	err = snmpClient.Connect()
	if err != nil {
		return
	}
	defer snmpClient.Conn.Close()
	deviceNums := getDeviceNum(snmpClient, 9)
	//view.AirInLet = getMaxTemperature(parseDeviceIntValues(snmpClient, deviceNums, hwEntityTemperature))
	view.AirOutLet = getMaxTemperature(parseDeviceIntValues(snmpClient, deviceNums, hh3cEntityExtTemperature))
	if view.AirOutLet > 300 {
		view.AirOutLet = 0
	}
	view.IfHealth = getSwitchIfHealth(meta.Sn)
	view.CpuHealth = getSwitchPartsHealth(gredis.SnmpSwitchCpusKey, meta.Sn)
	view.MemHealth = getSwitchPartsHealth(gredis.SnmpSwitchMemsKey, meta.Sn)
	view.PowerHealth = getSwitchPartsHealth(gredis.SnmpSwitchPowersKey, meta.Sn)
	view.FanHealth = getSwitchPartsHealth(gredis.SnmpSwitchFansKey, meta.Sn)
	return
}

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/pkg/tasks/snmp-task/oids.go
```golang
package snmptask

const (
	//standard
	snOidStandard = "1.0.8802.1.1.2.1.5.4795.1.2.5"

	ifDescrOidStandard    = "1.3.6.1.2.1.2.2.1.2"
	ifPhysAddressStandard = "1.3.6.1.2.1.2.2.1.6"
	ifAdminStatusStandard = "1.3.6.1.2.1.2.2.1.7"
	ifOperStatusStandard  = "1.3.6.1.2.1.2.2.1.8"
	//ifSpeed               = "1.3.6.1.2.1.2.2.1.5"
	ifSpeed = "1.3.6.1.2.1.31.1.1.1.15"

	ipAdEntIfIndexStandard = "1.3.6.1.2.1.4.20.1.2"
	lldpLocalPortId        = "1.0.8802.1.1.2.1.3.7.1.3"  //本端接口
	lldpRemPortId          = "1.0.8802.1.1.2.1.4.1.1.7"  //对端接口名称
	lldpRemSysName         = "1.0.8802.1.1.2.1.4.1.1.9"  //对端设备名称
	lldpRemSysDesc         = "1.0.8802.1.1.2.1.4.1.1.10" //对端接口描述

	entPhysicalClass     = "1.3.6.1.2.1.47.1.1.1.1.5"
	entPhysicalName      = "1.3.6.1.2.1.47.1.1.1.1.7"
	entPhysicalSerialNum = "1.3.6.1.2.1.47.1.1.1.1.11" //物理实体序列号
	entPhysicalMfgName   = "1.3.6.1.2.1.47.1.1.1.1.12" //物理实体制造商
	entPhysicalModelName = "1.3.6.1.2.1.47.1.1.1.1.13" //与该物理实体相关联的供应商特定的型号名称

	//ruijie
	snOidRuijie = "1.3.6.1.4.1.4881.1.1.10.2.1.1.24"
	//systemFanNUMRuijie      = "1.3.6.1.4.1.4881.1.1.10.2.1.1.20"
	//systemFanExistRuijie       = "1.3.6.1.4.1.4881.1.1.10.2.1.1.42.1.3"
	systemFanIsNormalRuijie          = "1.3.6.1.4.1.4881.1.1.10.2.1.1.21.1.2"  //风扇状态oid
	systemFanNameRuijie              = "1.3.6.1.4.1.4881.1.1.10.2.1.1.21.1.3"  //风扇名称oid
	systemFanStatusSpeedRuijie       = "1.3.6.1.4.1.4881.1.1.10.2.1.1.43.1.6"  //风扇转速oid
	systemElectricalSourceNumRuijie  = "1.3.6.1.4.1.4881.1.1.10.2.1.1.17"      //电源个数
	systemPowerIsNormalRuijie        = "1.3.6.1.4.1.4881.1.1.10.2.1.1.18.1.2"  //电源状态oid
	systemPowerNameRuijie            = "1.3.6.1.4.1.4881.1.1.10.2.1.1.18.1.3"  //电源名称oid
	systemRatedPowerRuijie           = "1.3.6.1.4.1.4881.1.1.10.2.1.1.41.1.10" //电源额定功率
	systemPowerInVoltageRuijie       = "1.3.6.1.4.1.4881.1.1.10.2.1.1.41.1.11" //电源输入电压
	systemPowerInCurrentRuijie       = "1.3.6.1.4.1.4881.1.1.10.2.1.1.41.1.12" //电源输入电流
	systemPowerTypeRuijie            = "1.3.6.1.4.1.4881.1.1.10.2.1.1.41.1.4"  //电源型号
	systemPowerFirmwareVersionRuijie = "1.3.6.1.4.1.4881.1.1.10.2.1.1.41.1.7"  //电源固件版本
	systemPowerSerialRuijie          = "1.3.6.1.4.1.4881.1.1.10.2.1.1.41.1.8"  //电源系列号
	systemPowerTemperatureRuijie     = "1.3.6.1.4.1.4881.1.1.10.2.1.1.41.1.16" //电源温度

	systemMultipleTemperatureCurrentRuijie = "1.3.6.1.4.1.4881.1.1.10.2.1.1.44.1.5" //当前温度 - 只包含出口温度:1；出口温度：2；主板温度：3；cpu温度：4；主机温度：5
	//cpuUtilization5SecRuijie               = "1.3.6.1.4.1.4881.1.1.10.2.36.1.1.1.0" //系统cpu 5秒内使用率
	nodeCPUTotal5sec = "1.3.6.1.4.1.4881.1.1.10.2.36.1.2.1.3" //节点cpu 5秒内使用率
	systemCpuType    = "1.3.6.1.4.1.4881.1.1.10.2.1.1.35"     //cpu类型
	nodeCPUTotalName = "1.3.6.1.4.1.4881.1.1.10.2.36.1.2.1.2" //节点cpu名称

	nodeMemoryPoolNameRuijie               = "1.3.6.1.4.1.4881.1.1.10.2.35.1.2.1.2" //内存名称
	nodeMemoryPoolCurrentUtilizationRuijie = "1.3.6.1.4.1.4881.1.1.10.2.35.1.2.1.3" //内存的使用率
	nodeMemoryPoolSizeRuijie               = "1.3.6.1.4.1.4881.1.1.10.2.35.1.2.1.6" //内存容量
	systemMemoryTypeRuijie                 = "1.3.6.1.4.1.4881.1.1.10.2.1.1.36"     //内存卡类型

	//h3c
	snOidH3C                  = "1.3.6.1.2.1.47.1.1.1.1.11.2"
	hh3cDevMFanStatus         = "1.3.6.1.4.1.25506.8.35.9.1.1.1.2"
	hh3cDevMPowerNum          = "1.3.6.1.4.1.25506.8.35.9.1.2.1.1" //电源数目
	hh3cDevMPowerStatus       = "1.3.6.1.4.1.25506.8.35.9.1.2.1.2" //电源状态oid
	hh3cEntityExtCurrentPower = "1.3.6.1.4.1.25506.2.6.1.3.1.1.3"  //电源输入功率
	hh3cEntityExtTemperature  = "1.3.6.1.4.1.25506.2.6.1.1.1.1.12" //模块当前温度
	hh3cEntityExtCpuUsage     = "1.3.6.1.4.1.25506.2.6.1.1.1.1.6"  //CPU使用率
	hh3cEntityExtMemSize      = "1.3.6.1.4.1.25506.2.6.1.1.1.1.10" //内存容量
	hh3cEntityExtMemUsage     = "1.3.6.1.4.1.25506.2.6.1.1.1.1.8"  //内存的使用率
	entPhysicalMfgDate        = "1.3.6.1.2.1.47.1.1.1.1.17"        //模块的生产日期

	//huawei
	snOidHuawei           = "1.3.6.1.2.1.47.1.1.1.1.11"
	hwEntityFanState      = "1.3.6.1.4.1.2011.5.25.31.1.1.10.1.7" //风扇状态oid
	hwEntityFanPresent    = "1.3.6.1.4.1.2011.5.25.31.1.1.10.1.6" //风扇在位状态oid
	hwEntityFanSpeedRatio = "1.3.6.1.4.1.2011.5.25.31.1.1.10.1.5" //风扇速率
	hwEntityPwrSn         = "1.3.6.1.4.1.2011.5.25.31.1.1.18.1.2" //电源编号

	hwEntityPwrMode    = "1.3.6.1.4.1.2011.5.25.31.1.1.18.1.4" //电源模式
	hwEntityPwrPresent = "1.3.6.1.4.1.2011.5.25.31.1.1.18.1.5" //电源在位状态
	hwEntityPwrState   = "1.3.6.1.4.1.2011.5.25.31.1.1.18.1.6" //电源状态
	hwEntityPwrCurrent = "1.3.6.1.4.1.2011.5.25.31.1.1.18.1.7" //电源电流mA
	hwEntityPwrVoltage = "1.3.6.1.4.1.2011.5.25.31.1.1.18.1.8" //电源电压mV

	hwEntityTemperature         = "1.3.6.1.4.1.2011.5.25.31.1.1.1.1.11" //物理实体温度
	hwMultiCpuDuty              = "1.3.6.1.4.1.2011.6.3.33.1.2"         //当前的CPU使用率
	hwEntityArchivesInfoVersion = "1.3.6.1.4.1.2011.5.25.31.1.1.2.1.8"  //档案版本
	hwEntityBoardType           = "1.3.6.1.4.1.2011.5.25.31.1.1.2.1.11"
	hwMemoryDevSize             = "1.3.6.1.4.1.2011.6.3.5.1.1.2"       //内存容量
	hwEntityMemUsage            = "1.3.6.1.4.1.2011.5.25.31.1.1.1.1.7" //内存的使用率
	hwEntityManufacturedDate    = "1.3.6.1.4.1.2011.5.25.31.1.1.2.1.4"
)

var (
	snOidList = []string{snOidStandard, snOidRuijie, snOidH3C}
)

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/pkg/tasks/snmp-task/ifTask.go
```golang
package snmptask

import (
	"bytes"
	"encoding/hex"
	"fmt"
	g "github.com/gosnmp/gosnmp"
	"gorm.io/gorm/clause"
	"k8s.io/klog/v2"
	"luban-cmdb-api/pkg/dao"
	switchMachine "luban-cmdb-api/pkg/models/switch"
	"regexp"
	"strconv"
	"strings"
	"time"
)

func snmpFetcher(meta SnmpMeta, oid string) (pdus []g.SnmpPDU, err error) {
	var (
		defaultSnmp *g.GoSNMP
	)
	//defaultSnmp = defaultV2Client(meta)
	defaultSnmp = selfV2Client(meta)
	err = defaultSnmp.Connect()
	if err != nil {
		//klog.Error(fmt.Sprintf("snmp Connect err: %v", err))
		return
	}
	defer defaultSnmp.Conn.Close()
	pdus = snmpWalk(defaultSnmp, oid)
	return
}

func snmpFetchIfDescrs(meta SnmpMeta, oid string) (descrs map[string]string, err error) {
	if oid == "" {
		oid = ifDescrOidStandard
	}
	var (
		pdus []g.SnmpPDU
	)
	pdus, err = snmpFetcher(meta, oid)
	if err != nil {
		//klog.Error(fmt.Sprintf("snmp Connect err: %v", err))
		return
	}
	descrs = make(map[string]string)
	for _, pdu := range pdus {
		if val, ok := pdu.Value.([]byte); ok {
			//re1 := regexp.MustCompile("\\d+/\\d+/\\d+$")
			//re2 := regexp.MustCompile("0/0/0$")
			//&& !re2.Match(val)
			re1 := regexp.MustCompile(`(\d+/)?\d+/(\d+)$`)
			if re1.Match(val) {
				nameS := strings.Split(pdu.Name, ".")
				lens := len(nameS)
				if lens > 0 {
					descrs[nameS[lens-1]] = string(val)
				}
			}
		}
	}
	return
}

func formatMacAddress(mac string) string {
	// 插入冒号分隔符
	mac = strings.ToUpper(mac) // 转成大写
	parts := make([]string, 6)
	for i := 0; i < 6; i++ {
		parts[i] = mac[i*2 : i*2+2]
	}
	return strings.Join(parts, ":")
}

func formatMacAddressX(mac string) string {
	// 插入冒号分隔符
	mac = strings.ToLower(mac) // 转成小写
	parts := make([]string, 6)
	for i := 0; i < 6; i++ {
		parts[i] = mac[i*2 : i*2+2]
	}
	return strings.Join(parts, ":")
}

func snmpFetchIfPhysAddress(meta SnmpMeta, oid string) (mac map[string]string, err error) {
	if oid == "" {
		oid = ifPhysAddressStandard
	}
	var (
		pdus []g.SnmpPDU
	)
	pdus, err = snmpFetcher(meta, oid)
	if err != nil {
		//klog.Error(fmt.Sprintf("snmp Connect err: %v", err))
		return
	}
	mac = make(map[string]string)
	zeroB := []byte("")
	for _, pdu := range pdus {
		if val, ok := pdu.Value.([]byte); ok && !bytes.Equal(val, zeroB) {
			nameS := strings.Split(pdu.Name, ".")
			lens := len(nameS)
			if lens > 0 && pdu.Type == g.OctetString {
				// 将 []uint8 类型的 MAC 地址数据转换为十六进制字符串
				macHex := hex.EncodeToString(pdu.Value.([]uint8))
				// 将十六进制字符串格式化为 MAC 地址格式
				macAddr := formatMacAddress(macHex)
				// 输出 MAC 地址
				mac[nameS[lens-1]] = macAddr
			}
		}

		//if val, ok := pdu.Value.([]byte); ok && !bytes.Equal(val, zeroB) {
		//	nameS := strings.Split(pdu.Name, ".")
		//	lens := len(nameS)
		//	if lens > 0 {
		//		//value := hex.EncodeToString(pdu.Value.([]uint8))
		//		value := ""
		//		if regexp.MustCompile("^.*[^\\x{00}-\\x{00FF}]+.*$").Match(pdu.Value.([]byte)) {
		//			value = parseOctet(val)
		//			if len(value) < 12 {
		//				continue
		//			}
		//
		//		} else {
		//			value = string(val)
		//			if meta.Ip == "10.158.24.250" {
		//				klog.Info("string: ", string(val), fmt.Sprintf(" bytes: %v", val))
		//				value = ""
		//			}
		//			if meta.Sn == "210235A3EUH21B0C006M" || meta.Sn == "210235A3EUH21B0C008H" {
		//				klog.Infof("switch debug: branch 2 value is %s", value)
		//			}
		//		}
		//		mac[nameS[lens-1]] = value
		//	}
		//}
	}
	return
}

func snmpFetchIfStatus(meta SnmpMeta, oid string) (status map[string]int, err error) {
	if oid == "" {
		oid = ifAdminStatusStandard
	}
	var (
		pdus []g.SnmpPDU
	)

	pdus, err = snmpFetcher(meta, oid)
	if err != nil {
		//klog.Error(fmt.Sprintf("snmp Connect err: %v", err))
		return
	}
	status = make(map[string]int)
	for _, pdu := range pdus {
		nameS := strings.Split(pdu.Name, ".")
		lens := len(nameS)
		value, _ := pdu.Value.(int)
		if lens > 0 {
			status[nameS[lens-1]] = value
		}
	}
	return
}

func snmpFetchIpSpeed(meta SnmpMeta, oid string) (speeds map[string]int, err error) {
	if oid == "" {
		oid = ifSpeed
	}
	var (
		pdus []g.SnmpPDU
	)

	pdus, err = snmpFetcher(meta, oid)
	if err != nil {
		//klog.Error(fmt.Sprintf("snmp Connect err: %v", err))
		return
	}
	speeds = make(map[string]int)
	for _, pdu := range pdus {
		nameS := strings.Split(pdu.Name, ".")
		lens := len(nameS)
		if lens > 0 {
			value := 0
			valueF := float64(pdu.Value.(uint))
			if valueF > 0 {
				//value = int(math.Ceil(valueF / 1000))
				value = int(valueF)
			}
			speeds[nameS[lens-1]] = value
		}
	}
	return
}

func formatDataRate(bitRate float64) string {
	units := []string{"bps", "Kbps", "Mbps", "Gbps", "Tbps", "Pbps", "Ebps"}

	unitIndex := 0
	for bitRate >= 1000 && unitIndex < len(units)-1 {
		bitRate /= 1000
		unitIndex++
	}

	return fmt.Sprintf("%.2f %s", bitRate, units[unitIndex])
}

func snmpFetchLldpRemPort(meta SnmpMeta, oid string) (result map[string]string, err error) {
	if oid == "" {
		oid = lldpRemPortId
	}
	var (
		pdus []g.SnmpPDU
	)

	pdus, err = snmpFetcher(meta, oid)
	if err != nil {
		//klog.Error(fmt.Sprintf("snmp Connect err: %v", err))
		return
	}
	result = make(map[string]string)
	for _, pdu := range pdus {
		nameS := strings.Split(pdu.Name, ".")
		lens := len(nameS)
		if lens > 0 {
			value := ""
			//if pdu.Type == g.OctetString && !regexp.MustCompile("^\\w+").Match(pdu.Value.([]byte)) {
			//0894EF7C84A1
			if regexp.MustCompile("^.*[^\\x{00}-\\x{00FF}]+.*$").Match(pdu.Value.([]byte)) {
				//value = parseOctet(pdu.Value.([]byte))
				// 将 []uint8 类型的 MAC 地址数据转换为十六进制字符串
				macHex := hex.EncodeToString(pdu.Value.([]uint8))
				// 将十六进制字符串格式化为 MAC 地址格式
				value = formatMacAddressX(macHex)
			} else {
				value = string(pdu.Value.([]byte))
			}
			//strings.ReplaceAll(value, "\\n", " ")  //strings.ReplaceAll 毫无用处的渣渣函数
			value = regexp.MustCompile("\\n").ReplaceAllString(value, " ")
			if oid != lldpLocalPortId {
				result[nameS[lens-2]] = value
			} else {
				result[nameS[lens-1]] = value
			}

		}
	}
	return
}

func snmpFetchIpAdEntIfIndex(meta SnmpMeta, oid string) (ips map[string]string, err error) {
	if oid == "" {
		oid = ipAdEntIfIndexStandard
	}
	var (
		pdus []g.SnmpPDU
	)

	pdus, err = snmpFetcher(meta, oid)
	if err != nil {
		//klog.Error(fmt.Sprintf("snmp Connect err: %v", err))
		return
	}
	ips = make(map[string]string)
	for _, pdu := range pdus {
		re := regexp.MustCompile("\\d+\\.\\d+\\.\\d+\\.\\d+$")
		ip := re.FindString(pdu.Name)
		if ip != "" {
			index := strconv.Itoa(pdu.Value.(int))
			ips[index] = ip
		}
	}
	return
}

func splitOid(oid []int, count int) ([]int, []int) {
	head := make([]int, count)
	tail := []int{}
	for i, v := range oid {
		if i < count {
			head[i] = v
		} else {
			tail = append(tail, v)
		}
	}
	return head, tail
}
func indexOidsAsString(indexOids []int) string {
	var subOid []int
	length := 0
	subOid, indexOids = splitOid(indexOids, 1)
	length = subOid[0]
	content, indexOids := splitOid(indexOids, length)
	subOid = append(subOid, content...)
	parts := make([]byte, length)
	for i, o := range content {
		parts[i] = byte(o)
	}
	if len(parts) == 0 {
		return ""
	} else {
		return fmt.Sprintf("%X", string(parts))
	}
}

func parseOctet(val []byte) string {
	parts := make([]int, len(val)+1)
	parts[0] = len(val)
	for i, o := range val {
		parts[i+1] = int(o)
	}
	str := indexOidsAsString(parts)
	return str
}

//	func judgeStatus(aSta, oSta int) int {
//		var state int
//		if oSta == 2 || aSta == 2 {
//			state = 2
//		} else if oSta == 1 && aSta == 1 {
//			state = 1
//		} else if oSta == 0 && aSta > 0 {
//			state = aSta
//		} else if aSta == 0 && oSta > 0 {
//			state = oSta
//		} else {
//			state = 4
//		}
//		return state
//	}
type dType struct {
	Name string `gorm:"column:name"`
	Type string `gorm:"column:type"`
}

func fetchDeviceType() (dMaps map[string]string) {
	sqlStr := `
	select name,'server' type from asset_physical_server where deleted = ?
	union all
	select name,'switch' type from asset_switch where deleted = ?
`
	var dTypes []dType
	err := dao.AssetDB.Raw(sqlStr, dao.DELETED_N, dao.DELETED_N).Scan(&dTypes).Error
	if err != nil {
		klog.Errorf("fetchDeviceType err: %+v", err)
	}
	dMaps = make(map[string]string)
	for _, d := range dTypes {
		dMaps[d.Name] = d.Type
	}
	return
}

func switchInterfaceFetch(meta SnmpMeta) []switchMachine.SwitchInterfaceDetail {
	klog.Info(fmt.Sprintf("switch sn:%s ip:%s snmpWalk start...", meta.Sn, meta.Ip))
	var (
		details []switchMachine.SwitchInterfaceDetail
		err     error
	)
	//获取交换机接口
	ifDescr, err := snmpFetchIfDescrs(meta, ifDescrOidStandard)
	klog.Info(fmt.Sprintf("snmp_fetch_ifDescr_sn%v: %v", meta.Sn, ifDescr))

	if err != nil {
		klog.Error(fmt.Sprintf("snmp_fetch_ifDescr_err: %v", err))
		return nil
	}
	//获取交换机接口mac地址
	ifMacAddress, err := snmpFetchIfPhysAddress(meta, ifPhysAddressStandard) // 获取mac地址
	if err != nil {
		klog.Error(fmt.Sprintf("snmp_fetch_ifMacAddress_err: %v", err))
	}
	//获取接口管理状态
	ifAdminStatus, err := snmpFetchIfStatus(meta, ifAdminStatusStandard)
	if err != nil {
		klog.Error(fmt.Sprintf("snmp_fetch_ifAdminStatus_err: %v", err))
	}
	//获取接口操作状态
	ifOperStatus, err := snmpFetchIfStatus(meta, ifOperStatusStandard)
	if err != nil {
		klog.Error(fmt.Sprintf("snmp_fetch_ifOperStatus_err: %v", err))
	}
	ips, err := snmpFetchIpAdEntIfIndex(meta, ipAdEntIfIndexStandard)
	if err != nil {
		klog.Error(fmt.Sprintf("snmp_fetch_ipAdEntIfIndex_err: %v", err))
	}
	//获取接口速率
	speed, err := snmpFetchIpSpeed(meta, ifSpeed)
	if err != nil {
		klog.Error(fmt.Sprintf("snmp_fetch_speed_err: %v", err))
	}

	//获取本端接口名称
	localName, err := snmpFetchLldpRemPort(meta, lldpLocalPortId)
	if err != nil {
		klog.Error(fmt.Sprintf("snmp_fetch_remNam_err: %v", err))
	}
	//获取对端接口名称
	remName, err := snmpFetchLldpRemPort(meta, lldpRemSysName)
	if err != nil {
		klog.Error(fmt.Sprintf("snmp_fetch_remNam_err: %v", err))
	}
	//获取对端接口mac与接口名称
	remPort, err := snmpFetchLldpRemPort(meta, lldpRemPortId)
	if err != nil {
		klog.Error(fmt.Sprintf("snmp_fetch_remPort_err: %v", err))
	}
	//获取对端接口描述
	remDesc, err := snmpFetchLldpRemPort(meta, lldpRemSysDesc)
	if err != nil {
		klog.Error(fmt.Sprintf("snmp_fetch_remDesc_err: %v", err))
	}
	//对端设备匹配
	remList := make(map[string][]string, len(localName))
	for key, name := range localName {
		rName, _ := remName[key]
		rMac, _ := remPort[key]
		rDesc, _ := remDesc[key]
		remList[name] = []string{rName, rMac, rDesc}
	}
	//获取所有纳管的服务器与交换机
	dtypes := fetchDeviceType()

	for index, descr := range ifDescr {
		indexI, er := strconv.Atoi(index)
		if er != nil {
			continue
		}
		var (
			name string
			port string
			desc string
		)
		if remInfo, ok := remList[descr]; ok {
			name = remInfo[0]
			port = remInfo[1]
			desc = remInfo[2]
		}
		var detail = switchMachine.SwitchInterfaceDetail{
			Sn:              meta.Sn,
			IfName:          descr,
			IfIndex:         indexI,
			IfIp:            ips[index],
			IfMac:           ifMacAddress[index],
			IfSpeed:         speed[index],
			OrtherEndDevice: name,
			OrtherEndIf:     port,
			OrtherEndDescr:  desc,
			//OrtherEndDevice: remName[index],
			//OrtherEndIf:     remPort[index],
			//OrtherEndDescr:  remDesc[index],
			AdminState:   disposeState(ifAdminStatus[index]),
			OperState:    disposeState(ifOperStatus[index]),
			LastUpdateAt: time.Unix(time.Now().Unix(), 0),
		}
		detail.PortState = judgeStatus(detail.AdminState, detail.OperState)
		detail.OrtherEndType, _ = dtypes[detail.OrtherEndDevice]
		details = append(details, detail)
	}

	klog.Info(fmt.Sprintf("switch_details%s", details))

	klog.Info(fmt.Sprintf("switch sn:%s ip:%s snmpWalk over...", meta.Sn, meta.Ip))
	return details
}

func fetchSwitchInterfaceDetails() {
	metas := getValidSnmpMetas()
	//meta := SnmpMeta{
	//	Sn:    "210235A0QCH146000462",
	//	Ip:    "10.177.60.21",
	//	Group: "Ksyunpublic",
	//}
	//var metas []SnmpMeta
	//metas = append(metas, meta)
	klog.Info("fetchSwitchInterfaceDetails", metas)
	for i := 0; i < len(metas); i++ {
		details := switchInterfaceFetch(metas[i])
		err := dao.AssetDB.Debug().Table("asset_switch_interface_details").Clauses(clause.OnConflict{
			Columns: []clause.Column{{Name: "sn"}, {Name: "if_index"}},
			//DoUpdates: clause.AssignmentColumns([]string{"if_name", "if_index", "if_status", "if_ip", "if_mac", "if_speed",
			//	"orther_end_device", "orther_end_if", "orther_end_type", "orther_end_descr", "admin_state", "oper_state", "port_state"}),
			UpdateAll: true,
		}).Create(&details).Error

		if err != nil {
			klog.Error(fmt.Sprintf("upsert asset_switch_interface_details sn:%s err: %v", metas[i].Sn, err))
		}
	}
}

func IfTaskScheduler() {
	time.Sleep(30 * time.Second)
	for {
		klog.Info("snmp switch interface details beging...")
		fetchSwitchInterfaceDetails()
		klog.Info("snmp switch interface details over...")
		time.Sleep(15 * time.Minute)
	}
}

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/pkg/tasks/snmp-task/fansTask.go
```golang
package snmptask

import (
	"encoding/json"
	"errors"
	g "github.com/gosnmp/gosnmp"
	"k8s.io/klog/v2"
	switchMachine "luban-cmdb-api/pkg/models/switch"
	"strconv"
	"strings"
)

func getSwitchFanInfo(meta SnmpMeta) (result string, err error) {
	var (
		fans  []switchMachine.SwitchFan
		bytes []byte
	)
	switch meta.Sales {
	case "锐捷":
		fans, err = getRijieFansInfo(meta)
	case "华为":
		fans, err = getHuaweiFansInfo(meta)
	case "华三":
		klog.Info("机器类型", meta.Sales)
		fans, err = getH3cFansInfo(meta)
		klog.Info("fensghan", fans)
	default:
		err = errors.New("请指定交换机信息")
	}
	if err == nil {
		if bytes, err = json.Marshal(fans); err == nil {
			result = string(bytes)
		}
	}
	return
}

func getRijieFansInfo(meta SnmpMeta) (fans []switchMachine.SwitchFan, err error) {
	defer func() {
		if e := recover(); e != nil {
			err, _ = e.(error)
		}
	}()
	var (
		pdus   []g.SnmpPDU
		names  map[int]string
		health map[int]int
		exists map[int]bool
		speed  map[int]int
	)

	snmpClient := selfV2Client(meta)
	err = snmpClient.Connect()
	if err != nil {
		return nil, err
	}
	defer snmpClient.Conn.Close()
	pdus = snmpWalk(snmpClient, systemFanNameRuijie)
	if len(pdus) == 0 {
		err = errors.New("交换机风扇名称列表为空")
		return
	}
	names = parseRuijiePartsName(pdus)
	pdus = snmpWalk(snmpClient, systemFanIsNormalRuijie)
	health = parseRuijiePartsHealth(pdus)
	exists = parseRuijiePartsExist(pdus)
	pdus = snmpWalk(snmpClient, systemFanStatusSpeedRuijie)
	speed = parseRuijieFansSpeed(pdus)
	fans = make([]switchMachine.SwitchFan, len(names))
	for i, name := range names {
		fan := switchMachine.SwitchFan{
			Name: name,
		}
		fan.Health = health[i]
		fan.Exist = exists[i]
		fan.Speed = speed[i]
		//fans = append(fans, fan)
		fans[i-1] = fan
	}
	return
}

func getHuaweiFansInfo(meta SnmpMeta) (fans []switchMachine.SwitchFan, err error) {
	defer func() {
		if e := recover(); e != nil {
			err, _ = e.(error)
		}
	}()
	var (
		pdus       []g.SnmpPDU
		names      map[int]string
		health     map[int]int
		exists     map[int]bool
		speedRatio map[int]float64
	)

	snmpClient := selfV2Client(meta)
	err = snmpClient.Connect()
	if err != nil {
		return nil, err
	}
	defer snmpClient.Conn.Close()
	names = parseHwFansName(snmpClient)
	pdus = snmpWalk(snmpClient, hwEntityFanState)
	health = parseHwFansHealth(pdus)
	pdus = snmpWalk(snmpClient, hwEntityFanPresent)
	exists = parseHwPartsExist(pdus)
	pdus = snmpWalk(snmpClient, hwEntityFanSpeedRatio)
	speedRatio = parseHwFansSpeed(pdus)
	fans = make([]switchMachine.SwitchFan, len(names))
	for i, name := range names {
		fan := switchMachine.SwitchFan{
			Name: name,
		}
		fan.Health = health[i]
		fan.Exist = exists[i]
		fan.SpeedRatio = speedRatio[i]
		//fans = append(fans, fan)
		fans[i-1] = fan
	}
	return
}
func getH3cFansInfo(meta SnmpMeta) (fans []switchMachine.SwitchFan, err error) {
	defer func() {
		if e := recover(); e != nil {
			err, _ = e.(error)
		}
	}()
	var (
		pdus   []g.SnmpPDU
		names  map[int]string
		health map[int]int
		exists map[int]bool
	)
	snmpClient := selfV2Client(meta)
	err = snmpClient.Connect()
	if err != nil {
		return nil, err
	}
	defer snmpClient.Conn.Close()
	names = parseHwFansName(snmpClient)
	pdus = snmpWalk(snmpClient, hh3cDevMFanStatus)
	health = parseHwFansHealth(pdus)
	exists = parseH3cPartsExist(pdus)
	fans = make([]switchMachine.SwitchFan, len(names))
	for i, name := range names {
		fan := switchMachine.SwitchFan{
			Name: name,
		}
		fan.Health = health[i]
		fan.Exist = exists[i]
		//fans = append(fans, fan)
		fans[i-1] = fan
	}
	return
}

func parseRuijiePartsName(pdus []g.SnmpPDU) (names map[int]string) {
	names = make(map[int]string)
	if len(pdus) > 0 {
		var (
			index int
			bytes []byte
			value string
		)
		for _, pdu := range pdus {
			strs := strings.Split(pdu.Name, ".")
			if len(strs) < 1 {
				continue
			}
			if index, _ = strconv.Atoi(strs[len(strs)-1]); index == 0 {
				continue
			}
			if bytes, _ = pdu.Value.([]byte); len(bytes) == 0 {
				continue
			}
			value = string(bytes)
			names[index] = value
		}
	}
	return
}

func parseRuijiePartsHealth(pdus []g.SnmpPDU) (health map[int]int) {
	if len(pdus) > 0 {
		health = make(map[int]int)
		var (
			index int
			value int
		)
		for _, pdu := range pdus {
			strs := strings.Split(pdu.Name, ".")
			if len(strs) < 1 {
				continue
			}
			if index, _ = strconv.Atoi(strs[len(strs)-1]); index == 0 {
				continue
			}
			value, _ = pdu.Value.(int)
			switch value {
			case 4:
				value = 1
			case 2, 3:
				value = 2
			case 5:
				value = 3
			default:
				value = 0
			}
			health[index] = value
		}
	}
	return
}

func parseRuijiePartsExist(pdus []g.SnmpPDU) (exists map[int]bool) {
	if len(pdus) > 0 {
		exists = make(map[int]bool)
		var (
			index int
			value int
		)
		for _, pdu := range pdus {
			strs := strings.Split(pdu.Name, ".")
			if len(strs) < 1 {
				continue
			}
			if index, _ = strconv.Atoi(strs[len(strs)-1]); index == 0 {
				continue
			}
			value, _ = pdu.Value.(int)
			exists[index] = value != 1 //1表示不存在；其他都默认为存在
		}
	}
	return
}
func parseRuijieFansSpeed(pdus []g.SnmpPDU) (speed map[int]int) {
	if len(pdus) > 0 {
		speed = make(map[int]int)
		var (
			index int
			value int
		)
		for i, pdu := range pdus {
			strs := strings.Split(pdu.Name, ".")
			if len(strs) < 3 {
				continue
			}
			index = i + 1
			value, _ = pdu.Value.(int)
			speed[index] = value
		}
	}
	return
}

func parseHwFansName(snmpClient *g.GoSNMP) (names map[int]string) {
	var (
		pdus       []g.SnmpPDU
		deviceNums []string
	)
	deviceNums = getDeviceNum(snmpClient, 7) //编号7为风扇
	if len(deviceNums) > 0 {
		names = make(map[int]string)
		for i, num := range deviceNums {
			if pdus = snmpWalk(snmpClient, entPhysicalName+num); len(pdus) > 0 {
				bytes, ok := pdus[0].Value.([]byte)
				if !ok {
					continue
				}
				if name := string(bytes); name != "" {
					names[i+1] = name
				}
			}
		}
	}
	return
}

func parseHwFansHealth(pdus []g.SnmpPDU) (health map[int]int) {
	if len(pdus) > 0 {
		health = make(map[int]int)
		var (
			value int
		)
		for i, pdu := range pdus {
			value, _ = pdu.Value.(int)
			switch value {
			case 1:
				value = 1
			case 2:
				value = 3
			default:
				value = 0
			}
			health[i+1] = value
		}
	}
	return
}

func parseHwPartsExist(pdus []g.SnmpPDU) (exists map[int]bool) {
	if len(pdus) > 0 {
		exists = make(map[int]bool)
		var (
			value int
		)
		for i, pdu := range pdus {
			value, _ = pdu.Value.(int)
			exists[i+1] = value == 1 //1表示存在；其他都默认为不存在
		}
	}
	return
}

func parseHwFansSpeed(pdus []g.SnmpPDU) (speed map[int]float64) {
	if len(pdus) > 0 {
		speed = make(map[int]float64)
		var (
			index int
			value int
		)
		for i, pdu := range pdus {
			index = i + 1
			value, _ = pdu.Value.(int)
			speed[index] = float64(value) / 100
		}
	}
	return
}

func parseH3cPartsExist(pdus []g.SnmpPDU) (exists map[int]bool) {
	if len(pdus) > 0 {
		exists = make(map[int]bool)
		var (
			value int
			exist bool
		)
		for i, pdu := range pdus {
			value, _ = pdu.Value.(int)
			switch value {
			case 1, 2:
				exist = true
			default:
				exist = false
			}
			exists[i+1] = exist
		}
	}
	return
}

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/pkg/tasks/snmp-task/cpuTask.go
```golang
package snmptask

import (
	"encoding/json"
	"errors"
	"fmt"
	g "github.com/gosnmp/gosnmp"
	"k8s.io/klog/v2"
	switchMachine "luban-cmdb-api/pkg/models/switch"
	"regexp"
	"strings"
)

func getSwitchCpuInfo(meta SnmpMeta) (result string, err error) {
	var (
		cpus  []switchMachine.SwitchCpu
		bytes []byte
	)
	klog.Info("getSwitchCpuInfo", meta)
	switch meta.Sales {
	case "锐捷":
		klog.Info("getSwitchCpuInfoSales", meta.Sales)
		cpus, err = getRijieCpuInfo(meta)
	case "华为":
		klog.Info("getSwitchCpuInfoSales", meta.Sales)
		cpus, err = getHuaweiCpuInfo(meta)
	case "华三":
		klog.Info("getSwitchCpuInfoSales", meta.Sales)
		cpus, err = getH3cCpuInfo(meta)
	default:
		err = errors.New("请指定交换机信息")
	}
	if err == nil {
		if bytes, err = json.Marshal(cpus); err == nil {
			result = string(bytes)
		}
	}
	return
}

func getRijieCpuInfo(meta SnmpMeta) (cpus []switchMachine.SwitchCpu, err error) {
	klog.Info("getRijieCpuInfo%s_%s", meta.Sn, meta.Sales)
	defer func() {
		if e := recover(); e != nil {
			err, _ = e.(error)
		}
	}()
	var (
		pdus        []g.SnmpPDU
		names       map[int]string
		utilization map[int]int
		temperature map[int]int
		cpuType     map[int]string
		ctype       string
	)

	snmpClient := selfV2Client(meta)
	err = snmpClient.Connect()
	if err != nil {
		return nil, err
	}
	defer snmpClient.Conn.Close()
	pdus = snmpWalk(snmpClient, nodeCPUTotalName)
	if len(pdus) == 0 {
		err = errors.New("交换机CPU列表为空")
		return
	}
	names = parsePartsStrValues(pdus)
	pdus = snmpWalk(snmpClient, nodeCPUTotal5sec)
	utilization = parsePartsIntValues(pdus)
	pdus = snmpWalk(snmpClient, systemMultipleTemperatureCurrentRuijie)
	temperature = parseRuijieMultipleTemperature(pdus, 4)
	pdus = snmpWalk(snmpClient, systemCpuType)
	cpuType = parsePartsStrValues(pdus)
	cpus = make([]switchMachine.SwitchCpu, len(names))
	for i, name := range names {
		cpu := switchMachine.SwitchCpu{
			Name: name,
		}
		if ctype = cpuType[i]; ctype == "" {
			ctype = cpuType[1]
		}
		cpu.Temperature = temperature[i]
		cpu.Utilization = float64(utilization[i]) / 100
		cpu.CpuType = ctype
		//cpus = append(cpus, cpu)
		cpus[i-1] = cpu
	}
	return
}

func getHuaweiCpuInfo(meta SnmpMeta) (cpus []switchMachine.SwitchCpu, err error) {
	klog.Info("getHuaweiCpuInfo%s_%s", meta.Sn, meta.Sales)
	defer func() {
		if e := recover(); e != nil {
			err, _ = e.(error)
		}
	}()
	var (
		pdus        []g.SnmpPDU
		deviceNums  []string
		names       map[int]string
		utilization map[int]int
		temperature map[int]int
		cpuType     map[int]string
		ctype       string
	)

	snmpClient := selfV2Client(meta)
	err = snmpClient.Connect()
	if err != nil {
		return nil, err
	}
	defer snmpClient.Conn.Close()
	deviceNums = getDeviceNum(snmpClient, 5)                                                //5代表CPU
	names = filterHwCpuNames(parseDeviceStrValues(snmpClient, deviceNums, entPhysicalName)) //编号5为CPU
	if len(names) == 0 {
		err = errors.New("交换机CPU名称列表为空")
		return
	}
	pdus = snmpWalk(snmpClient, hwMultiCpuDuty)
	utilization = parsePartsIntValues(pdus)
	temperature = parseDeviceIntValues(snmpClient, deviceNums, hwEntityTemperature) //编号5为CPU
	cpuType = parseDeviceStrValues(snmpClient, deviceNums, entPhysicalModelName)
	//cpus = make([]switchMachine.SwitchCpu, len(names))
	cpus = make([]switchMachine.SwitchCpu, 0)
	for i, name := range names {
		cpu := switchMachine.SwitchCpu{
			Name: name,
		}
		if ctype = cpuType[i]; ctype == "" {
			ctype = cpuType[1]
		}
		cpu.Temperature = temperature[i]
		cpu.Utilization = float64(utilization[i]) / 100
		cpu.CpuType = ctype
		cpus = append(cpus, cpu)
		//cpus[i-1] = cpu
	}
	return
}

func getH3cCpuInfo(meta SnmpMeta) (cpus []switchMachine.SwitchCpu, err error) {
	klog.Info("getH3cCpuInfo_%s_%s", meta.Sn, meta.Sales)
	defer func() {
		if e := recover(); e != nil {
			err, _ = e.(error)
		}
	}()
	var (
		//pdus        []g.SnmpPDU
		deviceNums  []string
		names       map[int]string
		utilization map[int]int
		temperature map[int]int
		cpuType     map[int]string
		ctype       string
	)

	snmpClient := selfV2Client(meta)
	err = snmpClient.Connect()
	if err != nil {
		klog.Error("snmpClientErr", err)
		return nil, err
	}
	defer snmpClient.Conn.Close()
	deviceNums = getDeviceNum(snmpClient, 5)
	klog.Info("deviceNums", deviceNums)
	names = filterHwCpuNames(parseDeviceStrValues(snmpClient, deviceNums, entPhysicalName)) //编号5为CPU
	if len(names) == 0 {
		err = errors.New("交换机CPU名称列表为空")
		return
	}
	klog.Info("filterHwCpuNames")
	utilization = parseDeviceIntValues(snmpClient, deviceNums, hh3cEntityExtCpuUsage)
	temperature = parseDeviceIntValues(snmpClient, deviceNums, hwEntityTemperature) //编号5为CPU
	cpuType = parseDeviceStrValues(snmpClient, deviceNums, entPhysicalModelName)
	//cpus = make([]switchMachine.SwitchCpu, len(names))
	cpus = make([]switchMachine.SwitchCpu, 0)
	for i, name := range names {
		cpu := switchMachine.SwitchCpu{
			Name: name,
		}
		if ctype = cpuType[i]; ctype == "" {
			ctype = cpuType[1]
		}
		cpu.Temperature = temperature[i]
		cpu.Utilization = float64(utilization[i]) / 100
		cpu.CpuType = ctype
		cpus = append(cpus, cpu)
		//cpus[i-1] = cpu
	}
	klog.Info("cpus_name%s_%s", meta.Sn, cpus)
	return
}

func parseRuijieMultipleTemperature(pdus []g.SnmpPDU, num int) (tempes map[int]int) {
	index := 1
	tempes = make(map[int]int)
	for _, pdu := range pdus {
		if regexp.MustCompile(fmt.Sprintf("%d$", num)).MatchString(pdu.Name) {
			value, _ := pdu.Value.(int)
			tempes[index] = value
			index++
		}
	}
	return
}

func filterHwCpuNames(values map[int]string) map[int]string {
	for i, value := range values {
		if strings.Contains(strings.ToLower(value), "fan") || strings.Contains(strings.ToLower(value), "power") || strings.Contains(strings.ToLower(value), "psu") {
			delete(values, i)
		}
	}
	return values
}

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/pkg/tasks/nat-task/type.go
```golang
package natTask

//http://{{neutron_host}}:9696/v2.0/vpc/natpools
type Nat struct {
	Natpools []NatPool `json:"natpools"`
}

type NatPool struct {
	DomainId    string `json:"domain_id"`
	Name        string `json:"name"`
	NatPoolId   int    `json:"nat_pool_id"`
	ID          string `json:"id"`
	Type        string `json:"type"` //['public', 'private']
	Mode        string `json:"mode"` //['custom', 'classic']
	TenantID    string `json:"tenant_id"`
	Egress      int    `json:"egress"`
	IPNum       int    `json:"ip_num"`
	CreatedDate string `json:"created_date"`

	Natipallocations []Natipallocation `json:"natipallocations"`
	Dnatrules        []Dnatrules       `json:"dnatrules"`

	Vnets interface{} `json:"vnets"`
}

type Natipallocation struct {
	IPAddress string `json:"ip_address"`
	ID        string `json:"id"`
}

type Dnatrules struct {
	TransferVgwip string      `json:"transfer_vgwip"`
	DeletedAt     interface{} `json:"deleted_at"`
	Protocol      string      `json:"protocol"`
	Name          string      `json:"name"`
	Deleted       bool        `json:"deleted"`
	TenantID      string      `json:"tenant_id"`
	InternalPort  int         `json:"internal_port"`
	Description   string      `json:"description"`
	VifMac        string      `json:"vif_mac"`
	VgwIP         string      `json:"vgw_ip"`
	Vni           int         `json:"vni"`
	UpdatedAt     string      `json:"updated_at"`
	CreatedAt     string      `json:"created_at"`
	ProjectID     string      `json:"project_id"`
	InternalIP    string      `json:"internal_ip"`
	NatipPort     int         `json:"natip_port"`
	Natip         string      `json:"natip"`
	NatipID       string      `json:"natip_id"`
	NatpoolID     string      `json:"natpool_id"`
	ID            string      `json:"id"`
	NovaVifID     string      `json:"nova_vif_id"`
}

type Vifs struct {
	Vifs []Vif `json:"vifs"`
}

type Vif struct {
	VifType       string        `json:"vif_type"`
	SgUUIDList    []string      `json:"sg_uuid_list"`
	IP            string        `json:"ip"`
	VifMac        string        `json:"vif_mac"`
	Ingress       int           `json:"ingress"`
	VfID          interface{}   `json:"vf_id"`
	Egress        int           `json:"egress"`
	ArpRate       int           `json:"arp_rate"`
	AzName        string        `json:"az_name"`
	Gateway       string        `json:"gateway"`
	BcRate        int           `json:"bc_rate"`
	SubnetID      string        `json:"subnet_id"`
	ID            string        `json:"id"`
	Boot          interface{}   `json:"boot"`
	DomainID      string        `json:"domain_id"`
	VnetID        string        `json:"vnet_id"`
	Ipv6          interface{}   `json:"ipv6"`
	ProjectID     string        `json:"project_id"`
	VgwHost       string        `json:"vgw_host"`
	NovaVifID     string        `json:"nova_vif_id"`
	Status        string        `json:"status"`
	RecvPps       int           `json:"recv_pps"`
	DhcpDomain    interface{}   `json:"dhcp_domain"`
	CreatedDate   string        `json:"created_date"`
	DevName       string        `json:"dev_name"`
	Remark        interface{}   `json:"remark"`
	Eips          []interface{} `json:"eips"`
	VMID          string        `json:"vm_id"`
	NextSvr       interface{}   `json:"next_svr"`
	SendPps       int           `json:"send_pps"`
	Deny          bool          `json:"deny"`
	Name          interface{}   `json:"name"`
	Fixips        []interface{} `json:"fixips"`
	DNS2          string        `json:"dns2"`
	DNS1          string        `json:"dns1"`
	Mask          int           `json:"mask"`
	HostType      string        `json:"host_type"`
	TenantID      string        `json:"tenant_id"`
	SgUserTagList []interface{} `json:"sg_user_tag_list"`
}

type VMRatelimits struct {
	VMRatelimits []VMRatelimit `json:"vm_ratelimits"`
}
type VMRatelimit struct {
	VMID    string `json:"vm_id"`
	Ingress int    `json:"ingress"`
	Egress  int    `json:"egress"`
	SendPps int    `json:"send_pps"`
	RecvPps int    `json:"recv_pps"`
	BcRate  int    `json:"bc_rate"`
	ArpRate int    `json:"arp_rate"`
}

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/pkg/tasks/nat-task/natTask_test.go
```golang
package natTask

import (
	"testing"
)

func Test1(t *testing.T) {
	host := "http://10.178.224.72:9696"
	l, err := GetVmRateLimitListFromNeutronApi(host)
	if err != nil {
		t.Error(err)
	}

	t.Log(l)

	err = GetDiffData(host)
	if err != nil {
		t.Error(err)
	}
}

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/pkg/tasks/nat-task/natTask.go
```golang
package natTask

import (
	"context"
	"encoding/json"
	"errors"
	"io"
	"luban-cmdb-api/pkg/dao"
	"luban-cmdb-api/pkg/gredis"
	"luban-cmdb-api/pkg/models/nat"
	"luban-cmdb-api/pkg/tasks/commen"
	"net/http"
	"time"

	"github.com/jinzhu/copier"
	"k8s.io/klog/v2"
)

func Scheduler() {
	klog.Info("nattask start ...")
	host := "http://neutron.galaxy.cloud:9696"

	err := GetDiffData(host)
	if err != nil {
		klog.Errorf("nattask natdiff error: %v", err)
	}

	err = FetchAndCacheNatInfo(host)
	if err != nil {
		klog.Errorf("nattask error: %v", err)
		return
	}

	klog.Info("nattask end ...")

}

// 相关api接口文档: http://10.178.224.72/neutron/common_api.html#12
func FetchAndCacheNatInfo(host string) error {
	list, err := GetNatListFromNeutronApi(host)
	if err != nil {
		klog.Error(err)
		return err
	}
	klog.Info("nattask natlist 1 ...")
	klog.Info(len(list))
	klog.Info("nattask natlist 2 ...")

	vpcdomains, err := commen.GetVpcDomainsFromNeutronApi(host)
	if err != nil {
		klog.Error(err)
		return err
	}
	klog.Info(len(vpcdomains))
	domainIdToDomainMap := make(map[string]commen.VPCDomain, len(vpcdomains))
	for _, d := range vpcdomains {
		domainIdToDomainMap[d.ID] = d
	}

	vifs, err := GetVifListFromNeutronApi(host)
	if err != nil {
		klog.Error(err)
		return err
	}
	domainIdToVifMap := make(map[string][]Vif)
	for _, v := range vifs {
		domainIdToVifMap[v.DomainID] = append(domainIdToVifMap[v.DomainID], v)
	}

	vmLimitList, err := GetVmRateLimitListFromNeutronApi(host)
	if err != nil {
		klog.Error(err)
		return err
	}
	vmIdToVmLimitMap := make(map[string]VMRatelimit)
	for _, v := range vmLimitList {
		vmIdToVmLimitMap[v.VMID] = v
	}

	natList := make([]interface{}, len(list))
	scores := make([]float64, len(list))
	natMap := make(map[string]interface{}, len(list))
	for i, v := range list {

		dnatrules := make([]nat.Dnatrule, 0, len(v.Dnatrules))
		for _, d := range v.Dnatrules {
			var dnatrule nat.Dnatrule
			err := copier.Copy(&dnatrule, &d)
			if err != nil {
				klog.Error(err)
				continue
			}
			dnatrules = append(dnatrules, dnatrule)
		}

		natipallocations := make([]nat.Natipallocation, 0, len(v.Natipallocations))
		for _, n := range v.Natipallocations {
			var natipallocation nat.Natipallocation
			err := copier.Copy(&natipallocation, &n)
			if err != nil {
				klog.Error(err)
				continue
			}
			natipallocations = append(natipallocations, natipallocation)
		}

		snats := make([]nat.Snat, 0)
		for _, s := range domainIdToVifMap[v.DomainId] {
			snats = append(snats, nat.Snat{
				ServerName: "",
				ServerIp:   s.IP,
				VifId:      s.ID,
				VifType:    s.VifType,
			})
		}

		serverLimits := make([]nat.ServerLimit, 0)
		for _, sl := range domainIdToVifMap[v.DomainId] {
			egressType := 0 //1 已限速，0 未限速
			egress := 0
			vmLimit, ok := vmIdToVmLimitMap[sl.VMID]
			if ok {
				egressType = 1
				egress = vmLimit.Egress
			}

			serverLimits = append(serverLimits, nat.ServerLimit{
				ServerIp:   sl.IP,
				ServerType: sl.HostType,
				ServerName: "",
				VifId:      sl.ID,
				EgressType: egressType,
				Egress:     egress,
			})
		}

		natInfo := nat.NatInfo{
			PoolId:           v.NatPoolId,
			ResourcePoolName: "NAT",
			InstanceName:     v.Name,
			InstanceId:       v.ID,
			VpcName:          domainIdToDomainMap[v.DomainId].Name,
			Scope:            v.Mode,
			NatType:          v.Type,
			Region:           "cn-shanghai-2",
			RegionName:       "上海二区",
			TenantId:         commen.GetUserIdByTenantId(v.TenantID),
			TenantName:       commen.GetUserNameByTenantId(v.TenantID),
			ProjectName:      "默认项目",
			Bandwidth:        v.Egress,
			BoundSubNetNum:   v.IPNum,
			CreateTime:       commen.ParseTime("2006-01-02 15:04:05", v.CreatedDate),

			Natipallocations: natipallocations,
			Snats:            snats,
			Dnatrules:        dnatrules,
			ServerLimits:     serverLimits,
		}

		natByte, _ := json.Marshal(natInfo)
		natList[i] = natByte
		scores[i] = float64(natInfo.CreateTime)
		natMap[natInfo.InstanceId] = natByte
	}

	//set
	setKey := gredis.NATSetKey
	_, err = gredis.Del(context.Background(), setKey)
	if err != nil {
		klog.Error(err)
		return err
	}

	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
	_, err = gredis.ZAdd(ctx, setKey, scores, natList)
	defer cancel()
	if err != nil {
		klog.Error(err)
		return err
	}

	//hash
	hashKey := gredis.NATHashKey
	_, err = gredis.Del(context.Background(), hashKey)
	if err != nil {
		klog.Error(err)
		return err
	}
	ctx, cancel = context.WithTimeout(context.Background(), 5*time.Second)
	_, err = gredis.HMSet(ctx, hashKey, natMap)
	defer cancel()
	if err != nil {
		klog.Error(err)
		return err
	}

	return nil
}

func GetNatListFromNeutronApi(host string) ([]NatPool, error) {
	apiUrl := host + "/v2.0/vpc/natpools"
	request, err := http.NewRequest("GET", apiUrl, nil)
	if err != nil {
		return nil, err
	}
	request = commen.AddHeaders(request, nil)

	client := &http.Client{}
	resp, err := client.Do(request)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	bytes, err := io.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var data Nat
	err = json.Unmarshal(bytes, &data)
	if err != nil {
		return nil, err
	}
	return data.Natpools, nil
}

//vif 网卡
func GetVifListFromNeutronApi(host string) ([]Vif, error) {
	apiUrl := host + "/v2.0/vpc/vifs"
	request, err := http.NewRequest("GET", apiUrl, nil)
	if err != nil {
		return nil, err
	}
	request = commen.AddHeaders(request, nil)

	client := &http.Client{}
	resp, err := client.Do(request)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	bytes, err := io.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	var data Vifs
	err = json.Unmarshal(bytes, &data)
	if err != nil {
		return nil, err
	}
	return data.Vifs, nil
}

//虚拟机限速列表
func GetVmRateLimitListFromNeutronApi(host string) ([]VMRatelimit, error) {
	//TODO 常州环境 neutron版本不支持此接口，线上环境不能升级  by 闫耀华
	//apiUrl := host + "/v2.0/vpc/vm_ratelimits"
	//request, err := http.NewRequest("GET", apiUrl, nil)
	//if err != nil {
	//	return nil, err
	//}
	//request = commen.AddHeaders(request, nil)
	//
	//client := &http.Client{}
	//resp, err := client.Do(request)
	//if err != nil {
	//	return nil, err
	//}
	//defer resp.Body.Close()
	//bytes, err := io.ReadAll(resp.Body)
	//if err != nil {
	//	return nil, err
	//}
	//var data VMRatelimits
	//err = json.Unmarshal(bytes, &data)
	//if err != nil {
	//	klog.Errorf("GetVmRateLimitListFromNeutronApi unmarshal error: %v , %+v", err, string(bytes))
	//	return nil, err
	//}
	//return data.VMRatelimits, nil
	//TODO 直接返回空列表,待后续接口升级后再打开上面注释
	return []VMRatelimit{}, nil
}

//不同数据源数据对比
func GetDiffData(host string) error {
	klog.Info("start get natdiff data")

	//数据库
	if dao.NeutronDB == nil {
		msg := "natdiff - neutron db is invalid."
		klog.Info(msg)
		return errors.New(msg)
	}

	type Natpools struct {
		Id           string    `gorm:"column:id;type:varchar(36);primary_key" json:"id"`
		TenantId     string    `gorm:"column:tenant_id;type:varchar(255)" json:"tenant_id"`
		NatPoolId    int       `gorm:"column:nat_pool_id;type:int(11);AUTO_INCREMENT;NOT NULL" json:"nat_pool_id"`
		Name         string    `gorm:"column:name;type:varchar(128);NOT NULL" json:"name"`
		DomainId     string    `gorm:"column:domain_id;type:varchar(36);NOT NULL" json:"domain_id"`
		Mode         string    `gorm:"column:mode;type:enum('classic','custom','direct_conn');NOT NULL" json:"mode"`
		Type         string    `gorm:"column:type;type:enum('private','public','direct_conn');NOT NULL" json:"type"`
		Quota        int       `gorm:"column:quota;type:smallint(6)" json:"quota"`
		IpNum        int       `gorm:"column:ip_num;type:smallint(6)" json:"ip_num"`
		Egress       int       `gorm:"column:egress;type:int(11);NOT NULL" json:"egress"`
		Portranges   string    `gorm:"column:portranges;type:varchar(128)" json:"portranges"`
		AdminStateUp int       `gorm:"column:admin_state_up;type:tinyint(1);NOT NULL" json:"admin_state_up"`
		CreatedDate  time.Time `gorm:"column:created_date;type:datetime;NOT NULL" json:"created_date"`
		UpdatedDate  time.Time `gorm:"column:updated_date;type:datetime" json:"updated_date"`
		Deleted      int       `gorm:"column:deleted;type:tinyint(1)" json:"deleted"`
	}

	var dbresult []Natpools
	sql := `select * from neutron.natpools where deleted = 0 and type != 'direct_conn'`

	err := dao.NeutronDB.Raw(sql).Scan(&dbresult).Error
	if err != nil {
		msg := "natdiff - 获取NAT信息失败："
		klog.Error(msg, err)
		return errors.New(msg)
	}

	//接口
	apiresult, err := GetNatListFromNeutronApi(host)
	if err != nil {
		return err
	}

	//对比
	klog.Infof("natdiff - db count : %v", len(dbresult))
	klog.Infof("natdiff - api count : %v", len(apiresult))

	//取差集
	var diffList []Natpools
	for _, d := range dbresult {
		var find bool
		for _, a := range apiresult {
			if d.Id == a.ID {
				find = true
				break
			}
		}
		if !find {
			diffList = append(diffList, d)
		}
	}

	klog.Infof("natdiff - diff count : %v", len(diffList))
	klog.Infof("natdiff - diff list : %+v", diffList)
	return nil
}

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/pkg/svcctx/serviceContext.go
```golang
package svcctx

import (
	"fmt"
	"log"
	"luban-cmdb-api/data/ent"
	"luban-cmdb-api/pkg/apiserver/config"
	"luban-cmdb-api/pkg/dao"
	"luban-cmdb-api/pkg/gredis"
	"luban-cmdb-api/pkg/utils"

	"github.com/go-redis/redis/v8"

	"github.com/zeromicro/go-zero/core/logx"

	"gorm.io/gorm"
)

type ServiceContext struct {
	Config config.Config
	//数据库依赖
	CmdbAsset       *gorm.DB
	GalaxyIamGlobal *gorm.DB
	GalaxyNeutron   *gorm.DB
	Galaxy2Bm       *gorm.DB
	Galaxy2Instance *gorm.DB

	//Redis
	CmdbRedis *redis.Client

	//其他客户端依赖
}

func NewServiceContext(c config.Config) *ServiceContext {
	logx.Info("服务上下文初始化开始")

	str := "%s:%s@tcp(%s)/%s?charset=utf8mb4&parseTime=True&loc=Local&timeout=10s"

	//cmdb库任需要的表，全部迁到business库中
	dsn := fmt.Sprintf(str, c.CmdbMysql.UserName, c.CmdbMysql.Password, c.CmdbMysql.Host, "business")
	log.Println("debug ---- 1")
	cmdbAsset, err := utils.ConnectOrmDB(dsn, "asset_")
	if err != nil {
		log.Printf("connect cmdbAsset %s error: %v", dsn, err)
	}
	log.Println("debug ---- 2")
	client, err := ent.Open("mysql", dsn)
	if err != nil {
		log.Printf("failed opening connection to mysql: %v", err)
	}
	log.Println("debug ---- 3")

	businessStr := fmt.Sprintf(str, c.CmdbMysql.UserName, c.CmdbMysql.Password, c.CmdbMysql.Host, "business")
	log.Println("debug ---- 4")

	log.Println("debug ---- 5")
	businessDB, err := ent.Open("mysql", businessStr)
	if err != nil {
		log.Printf("failed opening connection to mysql: %v", err)
	}

	dao.InitAssetDB(cmdbAsset, client, businessDB)
	log.Println("debug ---- 6")

	galaxyIamGlobal, err := utils.ConnectOrmDB(fmt.Sprintf(str, c.GalaxyMysql.UserName, c.GalaxyMysql.Password, c.GalaxyMysql.Host, "iam_global"), "")
	if err != nil {
		log.Printf("connect galaxyIamGlobal error: %v", err)
	}
	log.Println("debug ---- 7")

	dao.InitIamDB(galaxyIamGlobal)
	log.Println("debug ---- 8")

	galaxyNeutron, err := utils.ConnectOrmDB(fmt.Sprintf(str, c.GalaxyMysql.UserName, c.GalaxyMysql.Password, c.GalaxyMysql.Host, "neutron"), "")
	if err != nil {
		log.Printf("connect galaxyNeutron error: %v", err)
	}
	log.Println("debug ---- 9")

	dao.InitNeutronDB(galaxyNeutron)
	log.Println("debug ---- 10")

	galaxy2Bm, err := utils.ConnectOrmDB(fmt.Sprintf(str, c.GalaxyMysql2.UserName, c.GalaxyMysql2.Password, c.GalaxyMysql2.Host, "bm"), "")
	if err != nil {
		log.Printf("connect galaxy2Bm error: %v", err)
	}
	log.Println("debug ---- 11")
	dao.InitBmDB(galaxy2Bm)
	log.Println("debug ---- 12")

	galaxy2Instance, err := utils.ConnectOrmDB(fmt.Sprintf(str, c.GalaxyMysql2.UserName, c.GalaxyMysql2.Password, c.GalaxyMysql2.Host, "instance"), "")
	if err != nil {
		log.Printf("connect galaxy2Instance error: %v", err)
	}
	log.Println("debug ---- 13")
	dao.InitInstanceDB(galaxy2Instance)
	log.Println("debug ---- 14")

	cmdbRedis, err := gredis.Connect(c.CmdbRedis.Host, c.CmdbRedis.Password, c.CmdbRedis.Db)
	if err != nil {
		log.Fatalf("connect cmdbRedis error: %v", err)
	}
	log.Println("debug ---- 15")
	gredis.InitRedis(cmdbRedis)
	log.Println("debug ---- 16")

	logx.Info("服务上下文初始化结束")

	return &ServiceContext{
		Config:          c,
		CmdbAsset:       cmdbAsset,
		GalaxyIamGlobal: galaxyIamGlobal,
		GalaxyNeutron:   galaxyNeutron,
		Galaxy2Bm:       galaxy2Bm,
		Galaxy2Instance: galaxy2Instance,
		CmdbRedis:       cmdbRedis,
	}
}

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/pkg/dao/instanceDao.go
```golang
package dao

import (
	logging "log"
	"time"

	"gorm.io/driver/mysql"
	"gorm.io/gorm"
	"gorm.io/gorm/logger"
	"gorm.io/gorm/schema"
	"k8s.io/klog/v2"
)

var (
	InstanceDB *gorm.DB
)

func InitInstanceDB(db *gorm.DB) {
	InstanceDB = db
}

//func init() {
//	var err error
//	//dsn := fmt.Sprintf("%s:%s@tcp(%s)/bm?charset=utf8mb4&parseTime=True&loc=Local", dbUser, dbPasswd, dbHost)
//	gconn := GetGalaxyDBForBmAndInstanceConnInfo()
//	dsn := fmt.Sprintf("%s:%s@tcp(%s)/instance?charset=utf8mb4&parseTime=True&loc=Local", gconn.User, gconn.Password, gconn.Host)
//	InstanceDB, err = getInstanceDB(dsn)
//	if err != nil {
//		panic(err.Error())
//	}
//	if gconn.Mode == Mode_DEV {
//		InstanceDB = InstanceDB.Debug()
//	}
//}

func getInstanceDB(dsn string) (*gorm.DB, error) {
	db, err := gorm.Open(mysql.Open(dsn), &gorm.Config{
		NamingStrategy: schema.NamingStrategy{
			SingularTable: true, // 使用单数表名
		},
	})
	if err != nil {
		klog.Infoln("logger.Error:", logger.Error)
		return db, err
	}
	// db.Logger = db.Logger.LogMode(logger.Error)
	newLogger := logger.New(
		logging.Default(),
		logger.Config{
			SlowThreshold:             time.Second,
			LogLevel:                  logger.Silent,
			IgnoreRecordNotFoundError: true,
			Colorful:                  false,
		},
	)
	db.Logger = newLogger
	return db, err
}

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/pkg/dao/assetDao.go
```golang
package dao

import (
	logging "log"
	"luban-cmdb-api/data/ent"
	"os"
	"time"

	"gorm.io/driver/mysql"
	"gorm.io/gorm"
	"gorm.io/gorm/logger"
	"gorm.io/gorm/schema"
	"k8s.io/klog/v2"
)

var (
	AssetDB *gorm.DB

	EntDB      *ent.Client
	BusinessDB *ent.Client

	//err     error
)

const (
	DELETED_N = 0 //正常
	DELETED_Y = 1 //已经删除
)

//用这种low的方式是因为上面全局变量用的地方太多，太难改
func InitAssetDB(db *gorm.DB, client *ent.Client, businessClient *ent.Client) {
	AssetDB = db
	EntDB = client
	BusinessDB = businessClient
}

//func init() {
//	var err error
//	aconn := GetAssetDBConnInfo()
//	dsn := fmt.Sprintf("%s:%s@tcp(%s)/cmdb?charset=utf8mb4&parseTime=True&loc=Local", aconn.User, aconn.Password, aconn.Host)
//	AssetDB, err = getAssetDB(dsn, "asset_")
//	if err != nil {
//		panic(err.Error())
//	}
//	if aconn.Mode == Mode_DEV {
//		AssetDB = AssetDB.Debug()
//	}
//
//	//
//	client, err := ent.Open("mysql", dsn)
//	if err != nil {
//		logging.Fatalf("failed opening connection to mysql: %v", err)
//	}
//	EntDB = client
//	if aconn.Mode == Mode_DEV {
//		EntDB = client.Debug()
//	}
//}

func getAssetDB(dsn, tablePrefix string) (db *gorm.DB, err error) {
	db, err = gorm.Open(mysql.Open(dsn), &gorm.Config{
		NamingStrategy: schema.NamingStrategy{
			TablePrefix:   tablePrefix, // 表名前缀: 资产表前缀 asset_
			SingularTable: true,        // 使用单数表名
		},
	})
	if err != nil {
		klog.Infoln("logger.Error:", logger.Error)
		return db, err
	}
	// db.Logger = db.Logger.LogMode(logger.Error)
	newLogger := logger.New(
		//&logging.Logger{}, //此行代码有问题，会导致db在debug模式下回调输出sql语句时出现空指针！！！
		logging.Default(),
		logger.Config{
			SlowThreshold:             time.Second,
			LogLevel:                  logger.Silent,
			IgnoreRecordNotFoundError: true,
			Colorful:                  false,
		},
	)
	db.Logger = newLogger
	return db, err
}

//判断是否在k8s内
func inK8s() bool {
	return len(os.Getenv("KUBERNETES_SERVICE_HOST")) > 0
}

type WhereOpt struct {
	Query string
	Args  []interface{}
}

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/pkg/dao/initDatabase.go
```golang
package dao

func Construct() {
	//construct()
}

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/pkg/dao/neutronDao.go
```golang
package dao

import (
	logging "log"
	"time"

	"gorm.io/driver/mysql"
	"gorm.io/gorm"
	"gorm.io/gorm/logger"
	"gorm.io/gorm/schema"
	"k8s.io/klog/v2"
)

var (
	NeutronDB *gorm.DB
)

func InitNeutronDB(db *gorm.DB) {
	NeutronDB = db
}

//func init() {
//	var err error
//	gconn := GetGalaxyDBConnInfo()
//	//dsn := fmt.Sprintf("root:Qud6XH+DGu6J@tcp(%s)/neutron?charset=utf8mb4&parseTime=True&loc=Local", dbHost)
//	dsn := fmt.Sprintf("%s:%s@tcp(%s)/neutron?charset=utf8mb4&parseTime=True&loc=Local", gconn.User, gconn.Password, gconn.Host)
//	NeutronDB, err = getNeutronDB(dsn)
//	if err != nil {
//		panic(err.Error())
//	}
//	if gconn.Mode == Mode_DEV {
//		NeutronDB = NeutronDB.Debug()
//	}
//}

func getNeutronDB(dsn string) (*gorm.DB, error) {
	db, err := gorm.Open(mysql.Open(dsn), &gorm.Config{
		NamingStrategy: schema.NamingStrategy{
			SingularTable: true, // 使用单数表名
		},
	})
	if err != nil {
		klog.Infoln("logger.Error:", logger.Error)
		return db, err
	}
	// db.Logger = db.Logger.LogMode(logger.Error)
	newLogger := logger.New(
		logging.Default(),
		logger.Config{
			SlowThreshold:             time.Second,
			LogLevel:                  logger.Silent,
			IgnoreRecordNotFoundError: true,
			Colorful:                  false,
		},
	)
	db.Logger = newLogger
	return db, err
}

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/pkg/dao/iamDao.go
```golang
package dao

import (
	logging "log"
	"time"

	"gorm.io/driver/mysql"
	"gorm.io/gorm"
	"gorm.io/gorm/logger"
	"gorm.io/gorm/schema"
	"k8s.io/klog/v2"
)

var (
	IamDao *gorm.DB
)

func InitIamDB(db *gorm.DB) {
	IamDao = db
}

//func init() {
//	var err error
//	//dsn := fmt.Sprintf("root:Qud6XH+DGu6J@tcp(%s)/neutron?charset=utf8mb4&parseTime=True&loc=Local", dbHost)
//	gconn := GetGalaxyDBConnInfo()
//	dsn := fmt.Sprintf("%s:%s@tcp(%s)/iam_global?charset=utf8mb4&parseTime=True&loc=Local", gconn.User, gconn.Password, gconn.Host)
//	IamDao, err = getIamDB(dsn)
//	if err != nil {
//		panic(err.Error())
//	}
//	if gconn.Mode == Mode_DEV {
//		IamDao = IamDao.Debug()
//	}
//}

func getIamDB(dsn string) (*gorm.DB, error) {
	db, err := gorm.Open(mysql.Open(dsn), &gorm.Config{
		NamingStrategy: schema.NamingStrategy{
			SingularTable: true, // 使用单数表名
		},
	})
	if err != nil {
		klog.Infoln("logger.Error:", logger.Error)
		return db, err
	}
	// db.Logger = db.Logger.LogMode(logger.Error)
	newLogger := logger.New(
		logging.Default(),
		logger.Config{
			SlowThreshold:             time.Second,
			LogLevel:                  logger.Silent,
			IgnoreRecordNotFoundError: true,
			Colorful:                  false,
		},
	)
	db.Logger = newLogger
	return db, err
}

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/pkg/dao/bmDao.go
```golang
package dao

import (
	logging "log"
	"time"

	"gorm.io/driver/mysql"
	"gorm.io/gorm"
	"gorm.io/gorm/logger"
	"gorm.io/gorm/schema"
	"k8s.io/klog/v2"
)

var (
	BmDB *gorm.DB
)

func InitBmDB(db *gorm.DB) {
	BmDB = db
}

//func init() {
//	var err error
//	//dsn := fmt.Sprintf("root:Qud6XH+DGu6J@tcp(%s)/bm?charset=utf8mb4&parseTime=True&loc=Local", dbHost)
//	gconn := GetGalaxyDBForBmAndInstanceConnInfo()
//	dsn := fmt.Sprintf("%s:%s@tcp(%s)/bm?charset=utf8mb4&parseTime=True&loc=Local", gconn.User, gconn.Password, gconn.Host)
//	BmDB, err = getBmDB(dsn)
//	if err != nil {
//		panic(err.Error())
//	}
//	if gconn.Mode == Mode_DEV {
//		BmDB = BmDB.Debug()
//	}
//}

func getBmDB(dsn string) (*gorm.DB, error) {
	db, err := gorm.Open(mysql.Open(dsn), &gorm.Config{
		NamingStrategy: schema.NamingStrategy{
			SingularTable: true, // 使用单数表名
		},
	})
	if err != nil {
		klog.Infoln("logger.Error:", logger.Error)
		return db, err
	}
	// db.Logger = db.Logger.LogMode(logger.Error)
	newLogger := logger.New(
		logging.Default(),
		logger.Config{
			SlowThreshold:             time.Second,
			LogLevel:                  logger.Silent,
			IgnoreRecordNotFoundError: true,
			Colorful:                  false,
		},
	)
	db.Logger = newLogger
	return db, err
}

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/pkg/dao/dbEnv.go
```golang
package dao

import (
	"os"
)

const (
	//POC 和 RDS 常州环境为不同HOST，相同USER和PASSWD，昆山环境全部相同
	ENV_POC_MYSQL_HOST = "POC_MYSQL_HOST" //银河底层库  用于bm和instance表连接

	ENV_RDS_MYSQL_HOST   = "RDS_MYSQL_HOST"   //银河底层库
	ENV_RDS_MYSQL_USER   = "RDS_MYSQL_USER"   //银河底层库
	ENV_RDS_MYSQL_PASSWD = "RDS_MYSQL_PASSWD" //银河底层库

	//TODO 本地地址自己改
	LOCAL_MYSQL_HOST   = "127.0.0.1:32583"
	LOCAL_MYSQL_USER   = "gms_db_user"
	Local_MYSQL_PASSWD = "sEc#5CrFNPNq"

	//--------------------------------------------------
	//cmdb自己的数据库
	ENV_CMDB_MYSQL_HOST   = "CMDB_MYSQL_HOST"
	ENV_CMDB_MYSQL_USER   = "CMDB_MYSQL_USER"
	ENV_CMDB_MYSQL_PASSWD = "CMDB_MYSQL_PASSWD"

	//TODO 本地地址自己改
	LOCAL_CMDB_MYSQL_HOST   = "127.0.0.1:32582"
	LOCAL_CMDB_MYSQL_USER   = "luban"
	Local_CMDB_MYSQL_PASSWD = "Kingsoft123"

	Mode_DEV = "dev"
)

type DBConnInfo struct {
	Host     string
	User     string
	Password string

	Mode string
}

// cmdb自己的数据库
func GetAssetDBConnInfo() *DBConnInfo {
	var host, user, passwd, mode string
	if inK8s() {
		//TODO 常州环境未加环境变量
		host = os.Getenv(ENV_CMDB_MYSQL_HOST)
		user = os.Getenv(ENV_CMDB_MYSQL_USER)
		passwd = os.Getenv(ENV_CMDB_MYSQL_PASSWD)
		//host = "mysql-cluster-mysql-master.mysql:3306"
		//user = "luban"
		//passwd = "Kingsoft123"

	} else {
		host = LOCAL_CMDB_MYSQL_HOST
		user = LOCAL_CMDB_MYSQL_USER
		passwd = Local_CMDB_MYSQL_PASSWD
		mode = Mode_DEV
	}

	return &DBConnInfo{
		Host:     host,
		User:     user,
		Password: passwd,
		Mode:     mode,
	}
}

// 银河底层库
func GetGalaxyDBConnInfo() *DBConnInfo {
	var host, user, passwd, mode string
	if inK8s() {
		host = os.Getenv(ENV_RDS_MYSQL_HOST)
		user = os.Getenv(ENV_RDS_MYSQL_USER)
		passwd = os.Getenv(ENV_RDS_MYSQL_PASSWD)
	} else {
		host = LOCAL_MYSQL_HOST
		user = LOCAL_MYSQL_USER
		passwd = Local_MYSQL_PASSWD
		mode = Mode_DEV
	}

	return &DBConnInfo{
		Host:     host,
		User:     user,
		Password: passwd,
		Mode:     mode,
	}
}

// 银河底层库-BM和Instance
func GetGalaxyDBForBmAndInstanceConnInfo() *DBConnInfo {
	var host, user, passwd, mode string
	if inK8s() {
		host = os.Getenv(ENV_POC_MYSQL_HOST)
		user = os.Getenv(ENV_RDS_MYSQL_USER)
		passwd = os.Getenv(ENV_RDS_MYSQL_PASSWD)
	} else {
		host = LOCAL_MYSQL_HOST
		user = LOCAL_MYSQL_USER
		passwd = Local_MYSQL_PASSWD
		mode = Mode_DEV
	}

	return &DBConnInfo{
		Host:     host,
		User:     user,
		Password: passwd,
		Mode:     mode,
	}
}

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/pkg/dao/dao.go
```golang
package dao

//
//import (
//	logging "log"
//	"time"
//
//	"gorm.io/driver/mysql"
//	"gorm.io/gorm"
//	"gorm.io/gorm/logger"
//	"gorm.io/gorm/schema"
//	"k8s.io/klog/v2"
//)
//
//func ConnectDB(dsn, tablePrefix string) (db *gorm.DB, err error) {
//	db, err = gorm.Open(mysql.Open(dsn), &gorm.Config{
//		NamingStrategy: schema.NamingStrategy{
//			TablePrefix:   tablePrefix, // 表名前缀: 资产表前缀 asset_
//			SingularTable: true,        // 使用单数表名
//		},
//	})
//	if err != nil {
//		klog.Infoln("logger.Error:", logger.Error)
//		return db, err
//	}
//	// db.Logger = db.Logger.LogMode(logger.Error)
//	newLogger := logger.New(
//		//&logging.Logger{}, //此行代码有问题，会导致db在debug模式下回调输出sql语句时出现空指针！！！
//		logging.Default(),
//		logger.Config{
//			SlowThreshold:             time.Second,
//			LogLevel:                  logger.Silent,
//			IgnoreRecordNotFoundError: true,
//			Colorful:                  false,
//		},
//	)
//	db.Logger = newLogger
//	return db, err
//}

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/pkg/dao/storagePool/storagePoolSliceDao.go
```golang
package storagepool

import (
	"gorm.io/gorm"
	"luban-cmdb-api/pkg/dao"
	"luban-cmdb-api/pkg/models/storagePool"
)

func SliceList(poolId ,pageNo,pageSize int) (list []storagePool.StoragePoolSlice,err error) {
	offset := (pageNo - 1) * pageSize
	err=dao.AssetDB.Where("pool_id",poolId).Offset(offset).Limit(pageSize).Find(&list).Error

	if err == gorm.ErrRecordNotFound {
		return list,nil
	}
	return
}

func SliceUpdate(sp storagePool.StoragePoolSlice)error  {
	err :=dao.AssetDB.Model(&storagePool.StoragePoolSlice{}).Where("pool_id",sp.PoolId).Where("tablet_name",sp.TabletName).Updates(sp).Error
	return err
}

func SliceInsert(sp []storagePool.StoragePoolSlice)error  {
	err :=dao.AssetDB.Model(&storagePool.StoragePoolSlice{}).Create(&sp).Error
	return err
}


func SliceDelete(sp []storagePool.StoragePoolSlice)error  {
	err :=dao.AssetDB.Model(&storagePool.StoragePoolSlice{}).Delete(&sp).Error
	return err
}


func SliceFirst(sp storagePool.StoragePoolSlice) (info storagePool.StoragePoolSlice,err error) {
	err = dao.AssetDB.Where("pool_id",sp.PoolId).Where("tablet_name",sp.TabletName).First(&info).Error
	if err == gorm.ErrRecordNotFound {
		return info,nil
	}
	return
}


//基于事务批量更改数据
func UpdatePoolSliceTransaction(slices []storagePool.StoragePoolSlice, poolId int) (err error) {
	err = dao.AssetDB.Transaction(func(tx *gorm.DB) error {
		if err = tx.Model(&storagePool.StoragePoolSlice{}).Where("pool_id",poolId).Delete(&storagePool.StoragePoolSlice{}).Error; err != nil {
			return err
		}
		if err = tx.Model(&storagePool.StoragePoolSlice{}).Create(&slices).Error; err != nil {
			return err
		}
		// 返回 nil 提交事务
		return nil
	})
	return err
}
```

File path: /Users/mac/Desktop/woker_code/cmdb-api/pkg/dao/storagePool/storagePoolDao.go
```golang
package storagepool

import (
	"luban-cmdb-api/pkg/dao"
	"luban-cmdb-api/pkg/models/storagePool"
)

func List() (pl []storagePool.StoragePool,err error) {
	err=dao.AssetDB.Where("").Find(&pl).Error
	return
}
func Update(sp map[string]interface{})error  {
	err :=dao.AssetDB.Model(&storagePool.StoragePool{}).Where("id",sp["id"]).Updates(sp).Error
	return err
}

func Info(id int) (pl storagePool.StoragePool,err error) {
	err=dao.AssetDB.Where("id",id).First(&pl).Error
	return
}
```

File path: /Users/mac/Desktop/woker_code/cmdb-api/pkg/dao/objectstorage/objectStorage.go
```golang
package objectstorage

import (
	"context"
	"k8s.io/klog/v2"
	"luban-cmdb-api/data/ent/objectstorage"
	"luban-cmdb-api/pkg/dao"
	"luban-cmdb-api/pkg/models/storage"
	"luban-cmdb-api/pkg/utils"
	"time"
)

func DeleteExpiredData(ctx context.Context, updateTime time.Time) error {
	// lastupdateTime < time.Now()
	_, err := dao.EntDB.ObjectStorage.Delete().Where(objectstorage.LastUpdateTimeLT(updateTime)).Exec(ctx)
	if err != nil {
		klog.Errorf("ObjectStorage delete expired data error: %s", err)
		return err
	}
	return nil
}

func DeleteALLData(ctx context.Context) error {
	_, err := dao.EntDB.ObjectStorage.Delete().Exec(ctx)
	if err != nil {
		klog.Errorf("ObjectStorage delete all data error: %s", err)
		return err
	}
	return nil
}

func InsertOrUpdate(ctx context.Context, objSto storage.BucketDetail) error {
	exist, err := dao.EntDB.ObjectStorage.Query().Where(objectstorage.ID(objSto.Id)).Exist(ctx)
	if err != nil {
		klog.Errorf("ObjectStorage query exist error: %s", err)
		return err
	}
	if exist {
		_, err = dao.EntDB.ObjectStorage.
			UpdateOneID(objSto.Id).
			SetName(objSto.Name).
			SetSize(objSto.Size).
			SetStorageType(objSto.StorageType).
			SetRegion(objSto.Region).
			SetRegionCode(objSto.RegionCode).
			SetAz(objSto.AzName).
			SetAzCode(objSto.AzCode).
			SetTenantID(objSto.TenantId).
			SetTenantName(objSto.TenantName).
			SetInnerDomainName(objSto.InnerDomainName).
			SetOuterDomainName(objSto.OuterDomainName).
			SetCreateTime(int(objSto.CreateTime)).
			SetPolicy(objSto.Policy).
			SetBucketDomains(utils.StructToJsonString(objSto.Domains)).
			SetResourcePoolID(objSto.ResourcePoolId).
			SetResourcePoolName(objSto.ResourcePoolName).
			SetObjectCount(int(objSto.ObjectCount)).
			SetCurrentSize(objSto.CurrentSize).
			SetLast30DayDownload(objSto.Last30DayDownload).
			SetLast30DayAPICallTimes(objSto.Last30DayAPICallTimes).
			SetLastUpdateTime(time.Now()).
			Save(ctx)

		if err != nil {
			klog.Error("ObjectStorage update mysql  failure:", err.Error())
		}
	} else {
		_, err = dao.EntDB.ObjectStorage.
			Create().
			SetID(objSto.Id).
			SetName(objSto.Name).
			SetSize(objSto.Size).
			SetStorageType(objSto.StorageType).
			SetRegion(objSto.Region).
			SetRegionCode(objSto.RegionCode).
			SetAz(objSto.AzName).
			SetAzCode(objSto.AzCode).
			SetTenantID(objSto.TenantId).
			SetTenantName(objSto.TenantName).
			SetInnerDomainName(objSto.InnerDomainName).
			SetOuterDomainName(objSto.OuterDomainName).
			SetCreateTime(int(objSto.CreateTime)).
			SetPolicy(objSto.Policy).
			SetBucketDomains(utils.StructToJsonString(objSto.Domains)).
			SetResourcePoolID(objSto.ResourcePoolId).
			SetResourcePoolName(objSto.ResourcePoolName).
			SetObjectCount(int(objSto.ObjectCount)).
			SetCurrentSize(objSto.CurrentSize).
			SetLast30DayDownload(objSto.Last30DayDownload).
			SetLast30DayAPICallTimes(objSto.Last30DayAPICallTimes).
			SetLastUpdateTime(time.Now()).
			Save(ctx)

		if err != nil {
			klog.Error("ObjectStorage insert mysql  failure:", err.Error())
		}
	}
	return nil
}

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/pkg/dao/contact/contact.go
```golang
package contact

import (
	"gorm.io/gorm"
	"luban-cmdb-api/pkg/dao"
	"time"
)

const (
	//联系人 级别
	CONTACT_MAIN  int8 = 1
	CONTACT_OTHER int8 = 2 //普通联系人

	//负责类别
	TYPE_LAB    int8 = 1 //机房
	TYPE_DEVICE int8 = 2 //房间
)

type Contact struct {
	Id         int
	Name       string
	Phone      string
	TypeId     int
	TypeName   int8
	Level      int8
	Creator    string
	Updater    string
	CreateTime time.Time `gorm:"autoCreateTime"`
	UpdateTime time.Time `gorm:"autoUpdateTime"`
	Deleted    int8
}

//根据房间或者机房信息查询联系人信息
func GetContactByType(typeId int, typeName int8) (cs []Contact, err error) {
	ret := dao.AssetDB.
		Where("type_id = ? AND type_name =? AND deleted=?", typeId, typeName, dao.DELETED_N).
		Find(&cs)
	if ret.Error != gorm.ErrRecordNotFound {
		err = ret.Error
	}
	return
}

//根据房间/机房批量获取联系人信息
func FindContactByType(typeIds []int, typeName int8) (cs []Contact, err error) {
	ret := dao.AssetDB.
		Where("type_id in ? AND type_name =? AND deleted=?", typeIds, typeName, dao.DELETED_N).Find(&cs)
	if ret.Error != gorm.ErrRecordNotFound {
		err = ret.Error
	}
	return
}

//插入多个联系人
func BatchAddContact(cs []Contact) error {
	return dao.AssetDB.CreateInBatches(cs, len(cs)).Error
}

func UpdateContact(c Contact) error {
	return dao.AssetDB.Model(&Contact{}).Where(Contact{Id: c.Id}).Updates(c).Error
}

//删除时修改状态为已经删除
func DelContactByType(typeIds []int, typeName int8, updater string) error {
	return dao.AssetDB.Model(&Contact{}).
		Where("type_id in ? AND type_name=?", typeIds, typeName).Updates(Contact{
		Updater: updater,
		Deleted: dao.DELETED_Y,
	}).Error
}

//删除时修改状态为已经删除
func BatchDelContact(ids []int, updater string) error {
	return dao.AssetDB.Model(&Contact{}).Where("id IN ?", ids).Updates(Contact{
		Updater: updater,
		Deleted: dao.DELETED_Y,
	}).Error
}

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/pkg/dao/hardware/hardwareModel.go
```golang
package hardware

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/pkg/dao/hardware/hardwareDao.go
```golang
package hardware

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/pkg/dao/ks3/ks3api.go
```golang
package ks3

import (
	"database/sql/driver"
	"errors"
	"log"
	"luban-cmdb-api/pkg/utils"
	"strings"
	"time"

	"gorm.io/gorm"
)

// BitBool is an implementation of a bool for the MySQL type BIT(1).
// This type allows you to avoid wasting an entire byte for MySQL's boolean type TINYINT.
type BitBool bool

// Value implements the driver.Valuer interface,
// and turns the BitBool into a bitfield (BIT(1)) for MySQL storage.
func (b BitBool) Value() (driver.Value, error) {
	if b {
		return []byte{1}, nil
	} else {
		return []byte{0}, nil
	}
}

// Scan implements the sql.Scanner interface,
// and turns the bitfield incoming from MySQL into a BitBool
func (b *BitBool) Scan(src interface{}) error {
	v, ok := src.([]byte)
	if !ok {
		return errors.New("bad []byte type assertion")
	}
	*b = v[0] == 1
	return nil
}

//这是ks3的底层库，不是我们自己的
type Bucket struct {
	Id         int64
	Acls       string    `gorm:"column:acls"`
	CreateTime time.Time `gorm:"column:created_time"`
	// FIXME bool type can't convert
	Deleted          BitBool `gorm:"type:bit(1)"`
	EnableLogging    BitBool `gorm:"type:bit(1)"`
	LastModifiedTime time.Time
	LoggingConfig    string
	Name             string
	Region           string
	UserId           string
	ImgProtect       BitBool `gorm:"type:bit(1)"`
	IsNoKey          BitBool `gorm:"column:isnokey,type:bit(1)"`
	KeyFormat        string
	Policy           string
	Type             string
}

func (b *Bucket) TableName() string {
	return "bucket"
}

type Ks3APIDao struct {
	db *gorm.DB
}

func NewKs3APIDao(dsn string) *Ks3APIDao {
	//kss:Kingsoft123@tcp(ks3charge.luban.sdns.galaxy.cloud:3306)/ks3api
	db, err := utils.ConnectOrmDB(dsn, "")
	if err != nil {
		log.Printf("connect ks3 db:  %s err %v :", dsn, err)
	}
	return &Ks3APIDao{
		db: db,
	}
}

type BucketsResult struct {
	Buckets []Bucket
	Total   int64
}

// func (b *Ks3APIDao) FindBuckets(page, pageSize int) (*BucketsResult, error) {
// 	var buckets []Bucket
// 	var count int64
// 	b.db.Find(&[]Bucket{}).Count(&count)
// 	result := b.db.Limit(pageSize).Offset((page - 1) * pageSize).Find(&buckets)
// 	return &BucketsResult{
// 		Buckets: buckets,
// 		Total:   count,
// 	}, result.Error
// }

func (b *Ks3APIDao) FindBucketsWithOptions(page, pageSize int, region, name, id, userId string, bucketType []string) (*BucketsResult, error) {
	var buckets []Bucket
	var count int64
	var query []string
	var values []interface{}
	query = append(query, "deleted=?")
	values = append(values, "0")
	if region != "" {
		query = append(query, "region like ?")
		values = append(values, "%"+region+"%")
	}
	if name != "" {
		query = append(query, "name like ?")
		values = append(values, "%"+name+"%")
	}
	if id != "" {
		query = append(query, "id = ?")
		values = append(values, id)
	}
	if userId != "" {
		query = append(query, "user_id = ?")
		values = append(values, userId)
	}
	if len(bucketType) > 0 {
		if BoolTagInArray(bucketType, "STANDARD") { //确认如果type是null 那么就是NORMAL状态，使用STANDARD是为了适应银河3.0版本
			query = append(query, "(type in (?) or type is null)")
			//klog.Infof("bucketType: %s", bucketType)
			//bucketType := []string{"STANDARD", "ARCHIVE", "NORMAL"} //"(" + strings.Join(bucketType, ",") + ")"
			values = append(values, bucketType)
		} else {
			query = append(query, "type in (?)")
			//klog.Infof("bucketType: %s", bucketType)
			//bucketType := []string{"STANDARD", "ARCHIVE", "NORMAL"} //"(" + strings.Join(bucketType, ",") + ")"
			values = append(values, bucketType)
		}

	}
	//klog.Infof("query: %s, values: %s", query, values)
	var result *gorm.DB
	if len(query) != 0 && len(values) != 0 {
		b.db.Where(strings.Join(query, " and "), values...).Find(&[]Bucket{}).Count(&count)                                       //or  不应该是or吧应该是and吧
		result = b.db.Where(strings.Join(query, " and "), values...).Limit(pageSize).Offset((page - 1) * pageSize).Find(&buckets) //or
	} else {
		b.db.Find(&[]Bucket{}).Count(&count)
		result = b.db.Limit(pageSize).Offset((page - 1) * pageSize).Find(&buckets)
	}
	//klog.Infoln("buckets:", buckets)
	return &BucketsResult{
		Buckets: buckets,
		Total:   count,
	}, result.Error
}

//从ks3数据库中读取数据存到redis中
func (b *Ks3APIDao) Buckets() (*BucketsResult, error) {
	var buckets []Bucket
	var count int64
	var query []string
	var values []interface{}
	query = append(query, "deleted=?")
	//values = append(values, "0")
	values = append(values, "")
	//klog.Infof("query: %s, values: %s", query, values)
	var result *gorm.DB
	b.db.Where(strings.Join(query, " and "), values...).Find(&[]Bucket{}).Count(&count) //or  不应该是or吧应该是and吧
	result = b.db.Where(strings.Join(query, " and "), values...).Find(&buckets)         //or
	//klog.Infoln("buckets:", buckets)
	return &BucketsResult{
		Buckets: buckets,
		Total:   count,
	}, result.Error
}

func (b *Ks3APIDao) FindBucketById(id string) (*Bucket, error) {
	var bucket Bucket
	result := b.db.Where("id = ?", id).First(&bucket)
	return &bucket, result.Error
}
func BoolTagInArray(slice []string, tag string) bool {
	for _, item := range slice {
		if item == tag {
			return true
		}
	}
	return false
}

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/pkg/dao/rackdao/rackDao.go
```golang
package rackdao

import (
	"errors"
	"fmt"
	"luban-cmdb-api/pkg/dao"
	"luban-cmdb-api/pkg/models/rack"
	"strings"

	"gorm.io/gorm"
)

//插入单条数据
func InsertRack(rack *Rack) (int64, error) {
	result := dao.AssetDB.Create(rack)
	return result.RowsAffected, result.Error
}

//批量插入数据
func InsertRacks(racks *[]Rack) (int64, error) {
	result := dao.AssetDB.Create(racks)
	return result.RowsAffected, result.Error
}

//根据条件批量查询
func SelectRackByConds(query interface{}, args ...interface{}) (racks []Rack, err error) {
	result := dao.AssetDB.Model(&Rack{}).Where("deleted = ?", dao.DELETED_N).Where(query, args...).Find(&racks)
	return racks, result.Error
}

//根据条件批量查询符合条件的rackId
func SelectRackIdaByConds(fields string, query interface{}, args ...interface{}) (racks []interface{}, err error) {
	result := dao.AssetDB.Model(&Rack{}).Select(fields).Where("deleted = ?", dao.DELETED_N).Where(query, args...).Find(&racks)
	return racks, result.Error
}

//根据条件批量查询CabinetId
func SelectCabinetIdByConds(query interface{}, args ...interface{}) (ids []int, err error) {
	result := dao.AssetDB.Model(&Rack{}).Distinct("cabinet_id").Where(query, args...).Find(&ids)
	return ids, result.Error
}

var (
	selectRackInfoSql = `
				rack.id as id,
				ar.region_code as rack_region_code,
				az.az_code as rack_az_code,
				ar.region_name as rack_region_name,
				az.az_name as rack_az_name,
				rack.rack_name as rack_name,
				al.lab_name as rack_lab,
				al.lab_code as rack_lab_code,
				adr.room_name as rack_room,
				adr.room_code as rack_room_code,
				ac.cabinet_name as rack_cabinet_name,
				rack.rack_status as rack_status,
				rack.rack_resource_type as rack_resource_type,
				rack.rack_resource_name as rack_resource_name,
				rack.rack_create_time as rack_create_time,
				rack.rack_update_time as rack_update_time,
				rack.rack_creator as rack_creator,
				count(1) as rack_count
				`
	joinRackInfoSql = `
				left join asset_region as ar on rack.region_id = ar.id
				left join asset_az as az on rack.az_id = az.id
				left join asset_lab as al on al.id = rack.lab_id
				left join asset_device_room as adr on adr.id = rack.room_id
				left join asset_cabinet as ac on ac.id = rack.cabinet_id
				`
	groupRackInfoSql = `
				rack.id,
				ar.region_code,
				az.az_code,
				ar.region_name,
				az.az_name,
				rack.rack_name,
				al.lab_name,
				al.lab_code,
				adr.room_name,
				adr.room_code,
				ac.cabinet_name,
				rack.rack_status,
				rack.rack_resource_type,
				rack.rack_resource_name,
				rack.rack_create_time,
				rack.rack_update_time,
				rack.rack_creator
				`
)

func SelectRackByCabinetId(cabinetIds []int) (racks []rack.Rack, err error) {
	err = dao.AssetDB.Where("cabinet_id IN ?", cabinetIds).Find(&racks).Error
	return racks, err
}

//根据条件查询机架位、机柜、房间、机房、区域等信息
//func SelectRackInfoByCons(opts []dao.WhereOpt, offset, limit int) ([]rack.RackInfo, error) {
func SelectRackInfoByCons(params rack.QueryRackParam) ([]rack.RackInfo, error) {
	rackInfoList := make([]rack.RackInfo, 0)
	tx := dao.AssetDB.Table(fmt.Sprintf("(select * from asset_rack where deleted = %d) as rack", dao.DELETED_N)).
		Joins(joinRackInfoSql).
		Group(groupRackInfoSql)
	//是否有Region条件
	if params.Region != "all" && params.Region != "" {
		tx = tx.Where("ar.region_code = ?", params.Region)
	}
	//是否有机架位名称
	if params.RackName != "" {
		rackName := `%` + params.RackName + `%`
		tx = tx.Where("rack.rack_name like ?", rackName)
	}
	//是否有可用区列表
	if len(params.Azs) > 0 {
		azArgs := make([]interface{}, len(params.Azs))
		for i, az := range params.Azs {
			azArgs[i] = az
		}
		tx = tx.Where("az.az_code in (?)", azArgs)
	}
	//是否有所属机房列表
	if len(params.RackLabs) > 0 {
		labArgs := make([]interface{}, len(params.RackLabs))
		for i, lab := range params.RackLabs {
			labArgs[i] = lab
		}
		tx = tx.Where("al.lab_name in (?)", labArgs)
	}
	//是否有所属机房代号列表
	if len(params.RackLabCodes) > 0 {
		labCodeArgs := make([]interface{}, len(params.RackLabCodes))
		for i, code := range params.RackLabCodes {
			labCodeArgs[i] = code
		}
		tx = tx.Where("al.lab_code in (?)", labCodeArgs)
	}
	//是否所属房间列表
	if len(params.RackRoomCodes) > 0 {
		roomCodeArgs := make([]interface{}, len(params.RackRoomCodes))
		for i, code := range params.RackRoomCodes {
			roomCodeArgs[i] = code
		}
		tx = tx.Where("adr.room_code in (?)", roomCodeArgs)
	}
	//是否有所属机柜列表
	if len(params.RackCabinetCodes) > 0 {
		cabinetNameArgs := make([]interface{}, len(params.RackCabinetCodes))
		for i, name := range params.RackCabinetCodes {
			cabinetNameArgs[i] = name
		}
		tx = tx.Where("ac.cabinet_name in (?)", cabinetNameArgs)
	}
	//是否有机架位状态列表
	if len(params.RackStatus) > 0 {
		rackStatusArgs := make([]interface{}, len(params.RackStatus))
		for i, status := range params.RackStatus {
			rackStatusArgs[i] = status
		}
		tx = tx.Where("rack.rack_status in (?)", rackStatusArgs)
	}
	//for _, opt := range opts {
	//	tx = tx.Where(opt.Query, opt.Args...)
	//}
	var total int64
	err := tx.Count(&total).Error
	if err != nil {
		return rackInfoList, err
	}
	result := tx.Select(selectRackInfoSql).Order("rack.id").Offset(params.PageNo * params.PageSize).Limit(params.PageSize).
		Scan(&rackInfoList)
	if result.Error == nil && total > 0 {
		rackInfoList[0].RackCount = total
	}
	return rackInfoList, result.Error
}

func SelectRackListByRackId(rackIdStart, hostUnitNumber int, rackStatus int) (rackInfoList []rack.RackEntity, err error) {
	seletcSql := `
				rack.id as id
				rack.name as rack_name
				al.lab_name as rack_lab
				al.lab_code as rack_lab_code
				adr.room_code as rack_room_code
				ac.cabinet_name as rack_cabinet_code
				rack.rack_status as rack_status
				rack.rack_resource_type as rack_resource_type
				rack.rack_resource_name as rack_resource_name
				rack.rack_resource_sn as rack_resource_sn
				rack.rack_update_time as rack_update_time
				rack.rack_creator as rack_creator
				`
	joinSql := `
				left join asset_lab as al on al.id = rack.lab_id
				left join asset_device_room as adr on adr.id = rack.room_id
				left join asset_cabinet as ac on ac.id = rack.cabinet_id
				`
	tx := dao.AssetDB.Table(fmt.Sprintf("(select * from asset_rack where deleted = %d) as rack", dao.DELETED_N)).
		Select(seletcSql).Joins(joinSql).
		Where("rack.id >= ? ", rackIdStart)
	if rackStatus > -1 {
		tx = tx.Where("rack.rack_status = ? ", rackStatus)
	}
	result := tx.Order("rack.id").Limit(hostUnitNumber).Scan(&rackInfoList)
	err = result.Error
	return
}

func SelectRackListById(rackId, size int) (occupites, idles []Rack, err error) {
	var cabinetId int
	err = dao.AssetDB.Model(&Rack{}).Select("cabinet_id").Where("id = ? and deleted = ?", rackId, dao.DELETED_N).Scan(&cabinetId).Error
	if err != nil {
		return
	}
	err = dao.AssetDB.Model(&Rack{}).Where("id >= ? and cabinet_id = ? and deleted = ? ", rackId, cabinetId, dao.DELETED_N).Order("id").Limit(size).Scan(&occupites).Error
	if err != nil {
		return
	}
	err = dao.AssetDB.Model(&Rack{}).Where("cabinet_id = ? and deleted = ?", cabinetId, dao.DELETED_N).Scan(&occupites).Error
	if err != nil {
		return
	}
	return
}

func SelectRackInfoByObj(rack Rack) (Rack, error) {
	result := dao.AssetDB.Model(&Rack{}).Where(&rack).Where("deleted = ?", dao.DELETED_N).First(&rack)
	return rack, result.Error
}

//更新单条数据
func UpdateRackById(rack *Rack) (int64, error) {
	result := dao.AssetDB.Model(rack).Updates(rack)
	return result.RowsAffected, result.Error
}

//基于事务批量更改数据
func UpdateRackByTransaction(racks []Rack, fields string, query interface{}, args []interface{}) (err error) {
	err = dao.AssetDB.Transaction(func(tx *gorm.DB) error {
		// 在事务中执行一些 db 操作（从这里开始，您应该使用 'tx' 而不是 'db'）
		tempRacks := make([]interface{}, 0)
		result := tx.Model(&Rack{}).Select(fields).Where(query, args...).Find(&tempRacks)
		err = result.Error
		if err != nil {
			return err
		}
		if len(fields) > 0 {
			return errors.New(fmt.Sprintf("these racks were occupied. names: %+v", fields))
		}
		for _, r := range racks {
			if err = tx.Model(&Rack{}).Updates(r).Error; err != nil {
				return err
			}
		}
		// 返回 nil 提交事务
		return nil
	})
	return err
}

//基于事务批量更改数据
func UpdateRackStatusByTransaction(racks []Rack, sn string) (err error) {
	err = dao.AssetDB.Transaction(func(tx *gorm.DB) error {
		// 在事务中执行一些 db 操作（从这里开始，您应该使用 'tx' 而不是 'db'）
		result := tx.Model(&Rack{}).Where("rack_resource_sn = ? and deleted = ?", sn, dao.DELETED_N).UpdateColumn("rack_status", 0)
		err = result.Error
		if err != nil {
			return err
		}
		for _, r := range racks {
			if err = tx.Model(&Rack{}).Updates(r).Error; err != nil {
				return err
			}
		}
		// 返回 nil 提交事务
		return nil
	})
	return err
}
func UpdateRackStatusByTransactionNew(idStart, size int, rackResourceType, rackResourceName, sn string, CabinetId int, tx *gorm.DB) (err error) {

	// 在事务中执行一些 db 操作（从这里开始，您应该使用 'tx' 而不是 'db'）
	result := tx.Model(&Rack{}).Select("rack_resource_type", "rack_resource_name", "rack_resource_sn", "rack_status").Where("rack_resource_sn = ? and deleted = ?", sn, dao.DELETED_N).Updates(Rack{RackResourceType: "", RackResourceName: "", RackResourceSn: "", RackStatus: 0})
	err = result.Error
	if err != nil {
		return err
	}
	var rackList []Rack
	err = tx.Model(&Rack{}).Where("id BETWEEN ? and ? and rack_status=?  and deleted = ? and cabinet_id=?", idStart, idStart+size-1, 0, dao.DELETED_N, CabinetId).Order("id").Limit(size).Scan(&rackList).Error
	if err != nil {
		return err
	}
	if len(rackList) <= 0 {
		return fmt.Errorf("没有对应的机架位！")
	}
	if len(rackList) != size {
		var rackInuseString string = "只能占用以下机架位："
		for i, _ := range rackList {
			rackInuseString = fmt.Sprintf("%s%s;", rackInuseString, rackList[i].RackName)
		}

		return fmt.Errorf(strings.TrimRight(rackInuseString, ";"))
	}

	if err = tx.Model(&Rack{}).Where("id BETWEEN ? and ? and rack_status=?  and deleted = ? ", idStart, idStart+size-1, 0, dao.DELETED_N).
		Updates(Rack{RackResourceName: rackResourceName, RackResourceType: rackResourceType, RackResourceSn: sn, RackStatus: 1}).Error; err != nil {
		return err
	}
	// 返回 nil 提交事务
	return nil
}

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/pkg/dao/rackdao/rackMysql.go
```golang
package rackdao

import "time"

type Rack struct {
	RackResourceType string
	RackResourceName string
	RackResourceSn string
	RackName         string
	RackCreator     string
	RackUpdater     string
	Uid              int `gorm:"primaryKey;column:id"`
	AzId             int
	RegionId         int
	LabId            int
	RoomId           int
	CabinetId        int
	RackStatus       int
	Deleted          int `gorm:"default:0"`
	RackCreateTime  time.Time `gorm:"autoCreateTime"`
	RackUpdateTime  time.Time `gorm:"autoUpdateTime"`
}

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/pkg/dao/cabidao/cabinetMysql.go
```golang
package cabidao

import "time"

/**
mysql结构
*/

type (
	Cabinet struct {
		CabinetElectricity float64
		CabinetPower       float64
		CabinetName        string
		CabinetBrand       string
		CabinetType        string
		CabinetCreator     string
		CabinetUpdater     string
		CabinetDesc string
		Uid                int `gorm:"primaryKey;column:id"`
		AzId               int
		RegionId           int
		LabId              int
		RoomId             int
		CabinetCapacity    int
		PDUJackNum         int     `gorm:"column:pdu_jack_num"`
		PDUJackType         string     `gorm:"column:pdu_jack_type"`
		Deleted            int     `gorm:"default:0"`
		CabinetCreateTime  time.Time `gorm:"autoCreateTime"`
		CabinetUpdateTime  time.Time `gorm:"autoUpdateTime"`
	}
)

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/pkg/dao/cabidao/chimeraStruct.go
```golang
package cabidao

type (
	Chimera struct {
		Lab    `gorm:"embedded"`
		Az     `gorm:"embedded"`
		Room   `gorm:"embedded"`
		Region `gorm:"embedded"`
	}

	Room struct {
		DeviceRoomCode string `json:"deviceRoomCode,omitempty" gorm:"column:room_code"`
		DeviceRoomName string `json:"deviceRoomName,omitempty" gorm:"column:room_name"`
		RoomId         int    `json:"uid,omitempty" gorm:"column:room_id"`
	}

	Lab struct {
		LabCode         string `json:"labCode" gorm:"column:lab_code"`
		LabName         string `json:"labName" gorm:"column:lab_name"`
		Address         string `json:"address" gorm:"column:address"`
		ServiceProvider string `json:"serviceProvider" gorm:"column:service_provider"`
		Power           string `json:"power" gorm:"column:power"`
		SparePower      string `json:"sparePower" gorm:"column:spare_power"`
		LabId           int    `json:"labid,omitempty" gorm:"column:lab_id"`
	}

	Az struct {
		AzCode string `json:"azCode" gorm:"column:az_code"`
		AzName string `json:"azName" gorm:"column:az_name"`
		AzId   int    `json:"azId" gorm:"column:az_id"`
	}

	Region struct {
		RegionCode string `json:"regionCode" gorm:"column:region_code"`
		RegionName string `json:"regionName" gorm:"column:region_name"`
		RegionId   int    `json:"regionId" gorm:"column:region_id"`
	}

	//机房和房间所含机柜、机架统计信息结构体
	CabinetsCounter struct {
		LabId           int
		RoomId          int
		CobinetsTotal   int
		RacksTotal      int
		UsedUnitCount   int
		UnusedUnitCount int
	}
)

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/pkg/dao/cabidao/cabinetDao.go
```golang
package cabidao

import (
	"errors"
	"fmt"
	"luban-cmdb-api/pkg/dao"
	"luban-cmdb-api/pkg/dao/deviceroom"
	"luban-cmdb-api/pkg/dao/rackdao"
	"luban-cmdb-api/pkg/models/basic"
	"luban-cmdb-api/pkg/models/cabinet"

	"gorm.io/gorm"
)

//插入单条数据
func InsertCabinet(cabinet *Cabinet) (int64, error) {
	result := dao.AssetDB.Create(cabinet)
	return result.RowsAffected, result.Error
}

//批量插入数据
func InsertCabinets(cabinets *[]Cabinet) (int64, error) {
	result := dao.AssetDB.Create(cabinets)
	return result.RowsAffected, result.Error
}

//基于事务插入机柜和机架位
func InsertCabinetAndRacksByTransaction(cabinet *Cabinet, racks []*rackdao.Rack) error {
	//tx := dao.AssetDB.Begin()
	//tx.Create(&racks)
	return dao.AssetDB.Transaction(func(tx *gorm.DB) error {
		// 在事务中执行一些 db 操作（从这里开始，您应该使用 'tx' 而不是 'db'）
		if err := tx.Create(cabinet).Error; err != nil {
			return err
		}
		if cabinet.Uid == 0 {
			return errors.New("机柜信息插入失败")
		}

		//给rack.CabinetId字段赋值
		for _, rack := range racks {
			rack.CabinetId = cabinet.Uid
		}
		if err := tx.Create(&racks).Error; err != nil {
			// 返回任何错误都会回滚事务
			return err
		}
		// 返回 nil 提交事务
		return nil
	})
}

//删除单条数据
func DeleteCabinetById(id int64) (int64, error) {
	result := dao.AssetDB.Delete(&Cabinet{}, id)
	return result.RowsAffected, result.Error
}

//批量删除数据
func DeleteCabinets(ids []int64) (int64, error) {
	result := dao.AssetDB.Delete(&Cabinet{}, ids)
	return result.RowsAffected, result.Error
}

//基于事务批量删除数据
func DeleteCabinetsAndRacksByTransaction(ids []int) (rowsAffected int64, err error) {
	err = dao.AssetDB.Transaction(func(tx *gorm.DB) error {
		// 在事务中执行一些 db 操作（从这里开始，您应该使用 'tx' 而不是 'db'）
		if err = tx.Model(&rackdao.Rack{}).Where("cabinet_id in (?)", ids).Update("deleted", dao.DELETED_Y).Error; err != nil {
			return err
		}
		result := tx.Model(&Cabinet{}).Where("id in (?)", ids).Update("deleted", dao.DELETED_Y)
		err = result.Error
		if err != nil {
			return err
		}
		rowsAffected = result.RowsAffected
		if rowsAffected == 0 {
			return errors.New("invalid cabinet ids")
		}
		// 返回 nil 提交事务
		return nil
	})
	return
}

//更新单条数据
func UpdateCabinetById(cabinet *Cabinet) (int64, error) {
	result := dao.AssetDB.Model(cabinet).Updates(cabinet)
	return result.RowsAffected, result.Error
}

//根据条件批量更新
func UpdateCabinetByConds(cabinet *Cabinet, query interface{}, args ...interface{}) (int64, error) {
	result := dao.AssetDB.Model(Cabinet{}).Where(query, args...).Updates(cabinet)
	return result.RowsAffected, result.Error
}

//根据主键查询单条数据
func SelectCabinetById(id int) (*Cabinet, error) {
	cabinet := &Cabinet{}
	result := dao.AssetDB.Where("deleted = ?", dao.DELETED_N).First(cabinet, id)
	return cabinet, result.Error
}

//根据条件批量查询
func SelectCabinetByConds(query interface{}, args ...interface{}) (cabinets []Cabinet, err error) {
	result := dao.AssetDB.Debug().Where("deleted = ?", dao.DELETED_N).Where(query, args...).Find(&cabinets)
	return cabinets, result.Error
}

func SelectCabinetNameByIds(ids []int) (names []string, err error) {
	err = dao.AssetDB.Select("cabinet_name").Table("asset_cabinet").Where("id IN (?)", ids).Pluck("cabinet_name", &names).Error

	//result := dao.AssetDB.Model(&Cabinet{}).Debug().Where("deleted = ?", dao.DELETED_N).Where("id in (?)", ids).Find(&names)
	return names, err
}

func SelectCabinetMapById(id int64) (map[string]interface{}, error) {
	cabinet := make(map[string]interface{})
	result := dao.AssetDB.Model(&Cabinet{}).Where("deleted = ?", dao.DELETED_N).First(cabinet, id)
	return cabinet, result.Error
}

//根据roomId或roomCode查询房间、机房、区域等信息
func chimeraQuery() (tx *gorm.DB) {
	return dao.AssetDB.Debug().Model(&deviceroom.DeviceRoom{}).Select(`asset_device_room.id as room_id,
								asset_device_room.room_code as room_code,
								asset_device_room.room_name as room_name,
								asset_device_room.lab_id as lab_id,
								asset_device_room.az_id as az_id,
								asset_device_room.region_id as region_id,
								asset_lab.lab_code as lab_code,
								asset_lab.lab_name as lab_name,
								asset_lab.address as address,
								asset_lab.service_provider as service_provider,
								asset_lab.power as power,
								asset_lab.spare_power as spare_power,
								asset_region.region_code as region_code,
								asset_region.region_name as region_name,
								asset_az.az_code as az_code,
								asset_az.az_name as az_name
								`).
		Joins("left join asset_lab on asset_device_room.lab_id = asset_lab.id").
		Joins("left join asset_region on asset_device_room.region_id = asset_region.id").
		Joins("left join asset_az on asset_device_room.az_id = asset_az.id")
}

//var (
//	chimeraQuery = dao.AssetDB.Debug().Model(&deviceroom.DeviceRoom{}).Select(`asset_device_room.id as room_id,
//								asset_device_room.room_code as room_code,
//								asset_device_room.room_name as room_name,
//								asset_device_room.lab_id as lab_id,
//								asset_device_room.az_id as az_id,
//								asset_device_room.region_id as region_id,
//								asset_lab.lab_code as lab_code,
//								asset_lab.lab_name as lab_name,
//								asset_lab.address as address,
//								asset_lab.service_provider as service_provider,
//								asset_lab.power as power,
//								asset_lab.spare_power as spare_power,
//								asset_region.region_code as region_code,
//								asset_region.region_name as region_name,
//								asset_az.az_code as az_code,
//								asset_az.az_name as az_name
//								`).
//		Joins("left join asset_lab on asset_device_room.lab_id = asset_lab.id").
//		Joins("left join asset_region on asset_device_room.region_id = asset_region.id").
//		Joins("left join asset_az on asset_device_room.az_id = asset_az.id")
//)

func SelectChimeraByRoomCode(roomCode string) (Chimera, error) {
	chimera := Chimera{}
	localQuery := chimeraQuery()
	result := localQuery.
		Where("asset_device_room.deleted = ? and asset_device_room.room_code = ?", dao.DELETED_N, roomCode).
		Scan(&chimera)
	return chimera, result.Error
}

func SelectChimeraByRoomId(roomId int) (Chimera, error) {
	chimera := Chimera{}
	localQuery := chimeraQuery()
	result := localQuery.
		Where("asset_device_room.deleted = ? and asset_device_room.id = ?", dao.DELETED_N, roomId).
		Scan(&chimera)
	return chimera, result.Error
}

//根据cabinetId查询机柜、房间、机房、区域等信息
var (
	selectCabinetInfoSql = `
				ac.id as id,
				ac.cabinet_name as cabinet_name,
				adr.room_name as cabinet_room,
				ar.region_code as cabinet_region_code,
				az.az_code as cabinet_az_code,
				ar.region_name as cabinet_region_name,
				az.az_name as cabinet_az_name,
				adr.room_code as cabinet_room_code,
				al.lab_name as cabinet_lab_name,
				ac.cabinet_capacity as cabinet_capacity,
				ac.cabinet_electricity as cabinet_electricity,
				ac.cabinet_power as cabinet_power,
				ac.pdu_jack_num as pdu_jack_num,
				ac.pdu_jack_type as pdu_jack_type,
				ac.cabinet_desc as cabinet_desc,
				ac.cabinet_brand as cabinet_brand,
				ac.cabinet_type as cabinet_type,
				sum(rack.rack_status) as used_unit_count,
				count(rack.rack_status) - sum(rack.rack_status) as unused_unit_count,
				ac.cabinet_create_time as cabinet_create_time,
				ac.cabinet_update_time as cabinet_update_time,
				ac.cabinet_creator as cabinet_creator
				`
	joinCabinetInfoSql = `
				left join asset_device_room as adr on adr.id = ac.room_id
				left join asset_lab as al on al.id = ac.lab_id
				left join asset_region as ar on ac.region_id = ar.id
				left join asset_az as az on ac.az_id = az.id
				left join asset_rack as rack on ac.id = rack.cabinet_id
				`
	groupCabinetInfoSql = `
				ac.id,
				ac.cabinet_name,
				adr.room_name,
				ar.region_code,
				az.az_code,
				ar.region_code,
				az.az_name,
				adr.room_code,
				al.lab_name,
				ac.cabinet_capacity,
				ac.cabinet_create_time,
				ac.cabinet_update_time,
				ac.cabinet_creator
				`
)

func SelectCabinetInfo(id int) (cabinet.CabinetInfo, error) {
	cabinetInfo := cabinet.CabinetInfo{}
	result := dao.AssetDB.Table(fmt.Sprintf("(select * from asset_cabinet where id = %d and deleted = %d) as ac", id, dao.DELETED_N)).
		Select(selectCabinetInfoSql).
		Joins(joinCabinetInfoSql).
		Group(groupCabinetInfoSql).
		Scan(&cabinetInfo)
	return cabinetInfo, result.Error
}

//func SelectCabinetInfoByCons(opts []dao.WhereOpt, offset, limit int) ([]cabinet.CabinetInfo, error) {
func SelectCabinetInfoByCons(params cabinet.QueryCabinetParam) ([]cabinet.CabinetInfo, error) {
	cabinetInfoList := make([]cabinet.CabinetInfo, 0)
	tx := dao.AssetDB.Table(fmt.Sprintf("(select * from asset_cabinet where deleted = %d) as ac", dao.DELETED_N)).
		Joins(joinCabinetInfoSql).
		Group(groupCabinetInfoSql)
	//是否有Region条件
	if params.Region != "all" && params.Region != "" {
		tx = tx.Where("ar.region_code = ?", params.Region)
	}
	//是否有下拉列表选择
	id, _ := params.ID.(int)
	if id > 0 {
		tx = tx.Where("ac.id = ?", params.ID)
	}
	if params.CabinetName != "" {
		tx = tx.Where("ac.cabinet_name like ?", `%`+params.CabinetName+`%`)
	}
	if params.CabinetRoom != "" {
		tx = tx.Where("adr.room_name like ?", `%`+params.CabinetRoom+`%`)
	}
	if params.CabinetRoomCode != "" {
		tx = tx.Where("adr.room_code like ?", `%`+params.CabinetRoomCode+`%`)
	}
	if params.CabinetRoomUid > 0 {
		tx = tx.Where("ac.room_id", params.CabinetRoomUid)
	}
	//是否有可用区列表
	if len(params.Azs) > 0 {
		azArgs := make([]interface{}, len(params.Azs))
		for i, az := range params.Azs {
			azArgs[i] = az
		}
		tx = tx.Where("az.az_code in (?)", azArgs)
	}
	//是否有机房列表
	if len(params.CabinetLabNames) > 0 {
		labArgs := make([]interface{}, len(params.CabinetLabNames))
		for i, name := range params.CabinetLabNames {
			labArgs[i] = name
		}
		tx = tx.Where("al.lab_name in (?)", labArgs)
	}
	//是否有房间列表
	roomArgs := make([]interface{}, len(params.CabinetRooms))
	if len(params.CabinetRooms) > 0 {
		for i, name := range params.CabinetRooms {
			roomArgs[i] = name
		}
		tx = tx.Where("adr.room_name in (?)", roomArgs)
	}
	var total int64
	err := tx.Count(&total).Error
	if err != nil {
		return nil, err
	}
	offset := params.PageNo * params.PageSize
	result := tx.Select(selectCabinetInfoSql).Order("ac.id").Offset(offset).Limit(params.PageSize).
		Scan(&cabinetInfoList)
	if result.Error == nil && total > 0 {
		cabinetInfoList[0].CabinetCount = total
	}
	return cabinetInfoList, result.Error
}

func SelectBasicCabinetInfoByCons(params basic.CabinetQueryParam) ([]basic.CabinetInfo, error) {
	cabinetInfoList := make([]basic.CabinetInfo, 0)
	tx := dao.AssetDB.Table(fmt.Sprintf("(select id,cabinet_name,region_id,az_id,lab_id,room_id from asset_cabinet where deleted = %d) as ac", dao.DELETED_N)).
		Select("ac.id,ac.cabinet_name").
		Joins(`
								left join asset_region as ar on ac.region_id = ar.id
								left join asset_az as az on ac.az_id = az.id
								left join asset_lab as al on al.id = ac.lab_id
								left join asset_device_room as adr on adr.id = ac.room_id
						`)
	//是否有region条件
	if params.Region != "all" && params.Region != "" {
		tx = tx.Where("ar.region_code = ?", params.Region)
	}
	//是否有az条件
	if len(params.Azs) > 0 {
		azArgs := make([]interface{}, len(params.Azs))
		for i, az := range params.Azs {
			azArgs[i] = az
		}
		tx = tx.Where("az.az_code in (?)", azArgs)
	}
	//是否有labCode条件
	if len(params.LabCode) > 0 {
		LabCodeArgs := make([]interface{}, len(params.LabCode))
		for i, lcode := range params.LabCode {
			LabCodeArgs[i] = lcode
		}
		tx = tx.Where("al.lab_code in (?)", LabCodeArgs)
	}
	//是否有roomCode条件
	if len(params.RoomCode) > 0 {
		roomCodeArgs := make([]interface{}, len(params.RoomCode))
		for i, rcode := range params.RoomCode {
			roomCodeArgs[i] = rcode
		}
		tx = tx.Where("adr.room_code in (?)", roomCodeArgs)
	}
	//是否有roomUid条件
	if params.RoomUid > 0 {
		tx = tx.Where("adr.id = ?", params.RoomUid)
	}
	result := tx.Scan(&cabinetInfoList)
	return cabinetInfoList, result.Error
}

//计算未删除的机柜数量
func CountAliveCabinets() (int, error) {
	var alive int
	result := dao.AssetDB.Table("asset_cabinet").Select("count(1) - sum(deleted) as alive").Scan(&alive)
	return alive, result.Error
}

//根据机房ID或房间ID统计机柜数量、机架位数量、已使用U位、未使用U位
func CountCabinetsByRoomIds(roomIds []int) ([]CabinetsCounter, error) {
	cabinetsCounters := make([]CabinetsCounter, 0)
	result := dao.AssetDB.Model(&Cabinet{}).
		Select(`
					asset_cabinet.lab_id,
					asset_cabinet.room_id,
					count(asset_cabinet.id) as cobinets_total,
					count(asset_rack.id) as racks_total,
					sum(asset_rack.rack_status) as used_unit_count,
					count(asset_rack.rack_status) - sum(asset_rack.rack_status) as unused_unit_count
					`).
		Joins(`left join asset_rack 
					on asset_cabinet.lab_id = asset_rack.lab_id 
					and asset_cabinet.room_id = asset_rack.room_id 
					and asset_cabinet.id = asset_rack.cabinet_id`).
		Where("asset_cabinet.room_id in (?) and asset_cabinet.deleted = ?", roomIds, dao.DELETED_N).
		Group("asset_cabinet.lab_id,asset_cabinet.room_id").
		Scan(&cabinetsCounters)
	return cabinetsCounters, result.Error
}

func CountCabinetsByLabIds(labIds []int) ([]CabinetsCounter, error) {
	cabinetsCounters := make([]CabinetsCounter, 0)
	result := dao.AssetDB.Model(&Cabinet{}).
		Select(`
					asset_cabinet.lab_id,
					count(asset_cabinet.id) as cobinets_total,
					count(asset_rack.id) as racks_total,
					sum(asset_rack.rack_status) as used_unit_count,
					count(asset_rack.rack_status) - sum(asset_rack.rack_status) as unused_unit_count
					`).
		Joins(`left join asset_rack 
					on asset_cabinet.id = asset_rack.cabinet_id`).
		Where("asset_cabinet.lab_id in (?) and asset_cabinet.deleted = ?", labIds, dao.DELETED_N).
		Group("asset_cabinet.lab_id").
		Scan(&cabinetsCounters)
	return cabinetsCounters, result.Error
}

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/pkg/dao/blockstorage/blockStorage.go
```golang
package blockstorage

import (
	"context"
	"k8s.io/klog/v2"
	"luban-cmdb-api/data/ent"
	"luban-cmdb-api/data/ent/blockstorage"
	"luban-cmdb-api/pkg/dao"
	"luban-cmdb-api/pkg/models/storage"
	"time"
)

func ListPage(ctx context.Context, req storage.CloudDiskRequest) ([]*ent.BlockStorage, int, error) {
	query := dao.EntDB.BlockStorage.Query()

	if req.Region != "" && req.Region != "all" {
		query = query.Where(blockstorage.RegionCode(req.Region))
	}
	if len(req.Az) > 0 {
		query = query.Where(blockstorage.AzCodeIn(req.Az...))
	}
	if req.Name != "" {
		query = query.Where(blockstorage.NameContains(req.Name))
	}
	if req.ResourcePool != "" {
		query = query.Where(blockstorage.ResourcePool(req.ResourcePool))
	}
	if req.InstanceId != "" {
		query = query.Where(blockstorage.InstanceID(req.InstanceId))
	}
	if req.TenantId != "" {
		query = query.Where(blockstorage.TenantID(req.TenantId))
	}
	if len(req.UseStatus) > 0 {
		query = query.Where(blockstorage.UseStatusIn(req.UseStatus...))
	}
	if len(req.ResourcePoolType) > 0 {
		query = query.Where(blockstorage.ResourcePoolTypeIn(req.ResourcePoolType...))
	}

	if req.SearchType != "" && req.SearchValue != "" {
		switch req.SearchType {
		case "name":
			query = query.Where(blockstorage.NameContains(req.SearchValue))
		case "instanceId":
			query = query.Where(blockstorage.InstanceIDContains(req.SearchValue))
		case "tenantId":
			query = query.Where(blockstorage.TenantIDContains(req.SearchValue))
		}
	}

	//total count
	totalCount, err := query.Count(context.Background())

	//sort
	//默认时间倒序
	query = query.Order(ent.Desc(blockstorage.FieldCreateTime))
	//page
	if req.PageNo > 0 && req.PageSize > 0 {
		query = query.Offset((req.PageNo - 1) * req.PageSize).Limit(req.PageSize)
	}

	list, err := query.All(ctx)
	if err != nil {
		return nil, totalCount, err
	}

	return list, totalCount, nil
}

func DeleteALLData(ctx context.Context) error {
	_, err := dao.EntDB.BlockStorage.Delete().Exec(ctx)
	if err != nil {
		klog.Errorf("BlockStorage delete all data error: %s", err)
		return err
	}
	return nil
}

func InsertOrUpdate(ctx context.Context, objSto ent.BlockStorage) error {
	exist, err := dao.EntDB.BlockStorage.Query().Where(blockstorage.InstanceID(objSto.InstanceID)).Exist(ctx)
	if err != nil {
		klog.Errorf("BlockStorage query exist error: %s", err)
		return err
	}
	objSto.LastUpdateTime = time.Now()
	if exist {
		_, err = dao.EntDB.BlockStorage.
			Update().
			Where(blockstorage.InstanceID(objSto.InstanceID)).
			SetName(objSto.Name).
			//SetInstanceID(objSto.InstanceID).
			SetRegion(objSto.Region).
			SetRegionCode(objSto.RegionCode).
			SetAz(objSto.Az).
			SetAzCode(objSto.AzCode).
			SetResourcePool(objSto.ResourcePool).
			SetResourcePoolType(objSto.ResourcePoolType).
			SetUseStatus(objSto.UseStatus).
			SetTenantID(objSto.TenantID).
			SetTenantName(objSto.TenantName).
			SetVM(objSto.VM).
			SetVMID(objSto.VMID).
			SetCreateTime(objSto.CreateTime).
			SetSize(objSto.Size).
			SetMountPoint(objSto.MountPoint).
			SetLastUpdateTime(objSto.LastUpdateTime).
			Save(ctx)
		if err != nil {
			klog.Error("BlockStorage update mysql  failure:", err.Error())
		}
	} else {
		_, err = dao.EntDB.BlockStorage.
			Create().
			SetName(objSto.Name).
			SetInstanceID(objSto.InstanceID).
			SetRegion(objSto.Region).
			SetRegionCode(objSto.RegionCode).
			SetAz(objSto.Az).
			SetAzCode(objSto.AzCode).
			SetResourcePool(objSto.ResourcePool).
			SetResourcePoolType(objSto.ResourcePoolType).
			SetUseStatus(objSto.UseStatus).
			SetTenantID(objSto.TenantID).
			SetTenantName(objSto.TenantName).
			SetVM(objSto.VM).
			SetVMID(objSto.VMID).
			SetCreateTime(objSto.CreateTime).
			SetSize(objSto.Size).
			SetMountPoint(objSto.MountPoint).
			SetLastUpdateTime(objSto.LastUpdateTime).
			Save(ctx)

		if err != nil {
			klog.Error("BlockStorage insert mysql  failure:", err.Error())
		}
	}
	return nil
}

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/pkg/dao/switchdao/switchDao.go
```golang
package switchdao

import (
	"errors"
	"fmt"
	"luban-cmdb-api/pkg/dao"
	"luban-cmdb-api/pkg/dao/rackdao"
	switchMachine "luban-cmdb-api/pkg/models/switch"
	"time"

	"k8s.io/klog/v2"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
)

type (
	SwitchRole struct {
		EnName string `json:"enName" gorm:"column:en_name"`
		ZhName string `json:"zhName" gorm:"column:zh_name"`
	}
)

var SwitchRoles []SwitchRole

func FetchSwitchRoles() {
	fetchSwitchRoles()
}

func fetchSwitchRoles() {
	SwitchRoles = getSwitchRoles()
	ticker := time.NewTicker(time.Hour * 2)
	for range ticker.C {
		SwitchRoles = getSwitchRoles()
	}
}

func getSwitchRoles() []SwitchRole {
	var temp = make([]SwitchRole, 0)
	e := dao.AssetDB.Table("asset_switch_role").Scan(&temp).Error
	if e != nil || len(temp) == 0 {
		temp = []SwitchRole{
			{EnName: "TC-ROUTER", ZhName: "传输-路由器/交换机"},
			{EnName: "TC-CORE", ZhName: "传输核心交换机"},
			{EnName: "AZ-CORE", ZhName: "内网核心交换机"},
			{EnName: "GSWXGW", ZhName: "接入交换机"},
			{EnName: "AZ-TOR", ZhName: "接入层交换机"},
			{EnName: "TC-DP", ZhName: "万兆专线接入交换机"},
			{EnName: "MG-TOR", ZhName: "管理接入交换机"},
			{EnName: "MG-AGG", ZhName: "管理汇聚交换机"},
			{EnName: "MG-CORE", ZhName: "管理核心交换机"},
			{EnName: "temp", ZhName: "true"},
		}
	}
	return temp
}

var (
	switchSelectSql = `
		asset_switch.id as id,
		asset_switch.name as name,
		asset_switch.run_status as run_status,
		asset_switch.sn as sn,
		asset_switch.switch_role as switch_role,
		asset_switch_role.zh_name as switch_role_zh,
		(select rack_name from asset_rack where id = asset_switch.rack_id) as Switch_rack_name,
		asset_switch.switch_unit_number as switch_unit_number,
		asset_switch.switch_type as switch_type,
		asset_switch.ip as management_ip,
		asset_switch.out_band_ip as out_band_ip,
		asset_switch.system_sales as switch_manufacturer,
		asset_switch.cpu_model as cpu_model,
		asset_switch.mem_model as mem_model,
		UNIX_TIMESTAMP(asset_switch.maintenance_due) as maintenance_due,
		asset_switch.main_maintainer as main_maintainer,
		case 
			when asset_switch.maintenance_due is null or asset_switch.maintenance_due = 0 then 'N/A'
			when asset_switch.maintenance_due <= now() then 'insured'
			when asset_switch.maintenance_due > now() and asset_switch.maintenance_due <= date_add(now(),interval 1 month) then 'insured1m'
			when asset_switch.maintenance_due > now() and asset_switch.maintenance_due <= date_add(now(),interval 3 month) then 'insured3m'
			else 'uninsured'
    	end as maintenance_status,
		(select sum(x*y) from asset_switch_interface_layout where switch_type = asset_switch.switch_type) as interface_count,
		asset_switch.os_version as os_version,
		asset_switch.hardware_version as hardware_version,
		asset_switch.assets_number as assets_number,
		asset_switch.label as label,
		asset_switch.description as description,
		asset_switch.creator as creator,
		UNIX_TIMESTAMP(asset_switch.input_time) as input_time,
		UNIX_TIMESTAMP(asset_switch.create_time) as create_time,
		asset_switch.updater as updater,
		UNIX_TIMESTAMP(asset_switch.update_time) as update_time,
		asset_region.region_name as region_name,
		asset_region.region_code as region_code,
		asset_az.id as az_id,
		asset_az.az_name as az_name,
		asset_az.az_code as az_code,
		asset_lab.lab_name as lab_name,
		asset_lab.lab_code as lab_code,
		asset_switch.room_id as room_id,
		asset_device_room.room_code as room_code,
		asset_device_room.room_name as room_name,
		#asset_cabinet.cabinet_code as cabinet_code,
		asset_switch.cabinet_id as cabinet_id,
		asset_cabinet.cabinet_name as cabinet_name,
		asset_switch.rack_id as rack_id
		`
	switchJoinSql = `
		left join asset_region on asset_region.id = asset_switch.region_id
		left join asset_az on asset_az.id = asset_switch.az_id
		left join asset_lab on asset_lab.id = asset_switch.lab_id
		left join asset_device_room on asset_device_room.id = asset_switch.room_id
		left join asset_cabinet on asset_cabinet.id = asset_switch.cabinet_id
		left join asset_switch_role on asset_switch_role.en_name = asset_switch.switch_role
		`
)

func SelectSwitchInfoById(switchId int) (switchInfo switchMachine.SwitchNew, err error) {
	subSelectSql := fmt.Sprintf(`(select * from asset_switch where id = %d and deleted = %d) as asset_switch`, switchId, dao.DELETED_N)
	if err = dao.AssetDB.Debug().Table(subSelectSql).Joins(switchJoinSql).Select(switchSelectSql).Find(&switchInfo).Error; err != nil {
		return
	}
	tx := dao.AssetDB.Debug().Table("asset_switch_component").Where("switch_type = ? and deleted = ?", switchInfo.SwitchType, dao.DELETED_N)
	if err = tx.Select("concat(mem_capacity*mem_slot,mem_unit) as memory_cap_total,mem_slot as slot").Scan(&switchInfo.Memory).Error; err != nil {
		return
	}
	if err = tx.Select("voltage, power").Scan(&switchInfo.Power).Error; err != nil {
		return
	}
	return
}
func SelectSwitchInfoByName(switchName string) (switchInfo switchMachine.SwitchNew, err error) {
	subSelectSql := fmt.Sprintf(`(select * from asset_switch where name = '%s' and deleted = %d) as asset_switch`, switchName, dao.DELETED_N)
	if err = dao.AssetDB.Table(subSelectSql).Joins(switchJoinSql).Select(switchSelectSql).Find(&switchInfo).Error; err != nil {
		return
	}
	tx := dao.AssetDB.Table("asset_switch_component").Where("switch_type = ? and deleted = ?", switchInfo.SwitchType, dao.DELETED_N)
	if err = tx.Select("concat(mem_capacity*mem_slot,mem_unit) as memory_cap_total,mem_slot as slot").Scan(&switchInfo.Memory).Error; err != nil {
		return
	}
	if err = tx.Select("voltage, power").Scan(&switchInfo.Power).Error; err != nil {
		return
	}
	return
}

func SelectSwitchListByCons(params switchMachine.SwitchListParams) (switchList []switchMachine.SwitchNew, totalCount int64, err error) {
	var subClause string
	var whereExprs []clause.Expression
	whereExprs = append(whereExprs, clause.Expr{SQL: "deleted = ?", Vars: []interface{}{dao.DELETED_N}})
	if params.Name != "" {
		//whereExprs = append(whereExprs, clause.Expr{SQL: "name = ?", Vars: []interface{}{params.Name}})
		whereExprs = append(whereExprs, clause.Expr{SQL: "name like ?", Vars: []interface{}{"%" + params.Name + "%"}})
	}
	if params.Sn != "" {
		//whereExprs = append(whereExprs, clause.Expr{SQL: "sn = ?", Vars: []interface{}{params.Sn}})
		whereExprs = append(whereExprs, clause.Expr{SQL: "sn like ?", Vars: []interface{}{"%" + params.Sn + "%"}})
	}
	if params.Vendor != "" {
		whereExprs = append(whereExprs, clause.Expr{SQL: "system_sales like ?", Vars: []interface{}{"%" + params.Vendor + "%"}})
	}
	if len(params.Manufacturer) > 0 {
		whereExprs = append(whereExprs, clause.Expr{SQL: "system_sales in (?)", Vars: []interface{}{params.Manufacturer}})
	}
	if len(params.Role) > 0 {
		whereExprs = append(whereExprs, clause.Expr{SQL: "switch_role in (?)", Vars: []interface{}{params.Role}})
	}
	if params.ManagementIp != "" {
		//whereExprs = append(whereExprs, clause.Expr{SQL: "ip = ?", Vars: []interface{}{params.ManagementIp}})
		whereExprs = append(whereExprs, clause.Expr{SQL: "ip like ?", Vars: []interface{}{"%" + params.ManagementIp + "%"}})
	}
	if params.SwitchType != "" {
		//whereExprs = append(whereExprs, clause.Expr{SQL: "switch_type = ?", Vars: []interface{}{params.SwitchType}})
		whereExprs = append(whereExprs, clause.Expr{SQL: "switch_type like ?", Vars: []interface{}{"%" + params.SwitchType + "%"}})
	}
	var mainTable = dao.AssetDB.Clauses(clause.Select{Columns: []clause.Column{}}, clause.From{Tables: []clause.Table{{Name: "asset_switch"}}}, clause.Where{Exprs: whereExprs})
	mainTable.Statement.Build("SELECT", "FROM", "WHERE", "GROUP BY", "ORDER BY", "LIMIT", "FOR")
	subClause = mainTable.Dialector.Explain(mainTable.Statement.SQL.String(), mainTable.Statement.Vars...)
	tx := dao.AssetDB.Table(fmt.Sprintf("(%s) as asset_switch", subClause)).Joins(switchJoinSql)
	if params.RegionCode != "all" && params.RegionCode != "" {
		tx = tx.Where("asset_region.region_code = ?", params.RegionCode)
	}
	if len(params.AzCode) > 0 {
		tx = tx.Where("asset_az.az_code in (?)", params.AzCode)
	}
	if len(params.LabCode) > 0 {
		tx = tx.Where("asset_lab.lab_code in (?)", params.LabCode)
	}
	if len(params.RunStatus) != 0 {
		//runStatus := make([]interface{}, len(params.RunStatus))
		//for i, status := range params.RunStatus {
		//	runStatus[i] = status
		//}
		tx = tx.Where("asset_switch.run_status in (?)", params.RunStatus)
	}

	if len(params.MaintenanceStatus) > 0 {
		whereClause := ""
		for i, status := range params.MaintenanceStatus {
			switch status {
			case "insured":
				//tx = tx.Where("maintenance_due <= ?", time.Now().Format("2006-01-02 15:04:05"))
				insured := fmt.Sprintf("(maintenance_due > 0 and maintenance_due <= '%s')", time.Now().Format("2006-01-02 15:04:05"))
				if i > 0 {
					insured = "or " + insured
				}
				whereClause += insured
			case "insured1m":
				//tx = tx.Where("maintenance_due > ? and maintenance_due <= ?", time.Now(), time.Now().AddDate(0, 1, 0))
				start := time.Now().Format("2006-01-02 15:04:05")
				end := time.Now().AddDate(0, 1, 0).Format("2006-01-02 15:04:05")
				insured1m := fmt.Sprintf("maintenance_due > '%s' and maintenance_due <= '%s'", start, end)
				if i > 0 {
					insured1m = "or " + insured1m
				}
				whereClause += insured1m
			case "insured3m":
				//tx = tx.Where("maintenance_due > ? and maintenance_due <= ?", time.Now(), time.Now().AddDate(0, 3, 0))
				start := time.Now().Format("2006-01-02 15:04:05")
				end := time.Now().AddDate(0, 3, 0).Format("2006-01-02 15:04:05")
				insured3m := fmt.Sprintf("maintenance_due > '%s' and maintenance_due <= '%s'", start, end)
				if i > 0 {
					insured3m = "or " + insured3m
				}
				whereClause += insured3m
			case "uninsured":
				//tx = tx.Where("maintenance_due > ?", time.Now().AddDate(0, 3, 0))
				end := time.Now().AddDate(0, 3, 0).Format("2006-01-02 15:04:05")
				uninsured := fmt.Sprintf("maintenance_due > '%s'", end)
				if i > 0 {
					uninsured = "or " + uninsured
				}
				whereClause += uninsured
			case "N/A":
				n_a := "(maintenance_due = 0 or maintenance_due is null)"
				if i > 0 {
					n_a = "or " + n_a
				}
				whereClause += n_a
			case "":
				n_a := "(maintenance_due = 0 or maintenance_due is null)"
				if i > 0 {
					n_a = "or " + n_a
				}
				whereClause += n_a
			}
		}
		whereClause = "(" + whereClause + ")"
		tx = tx.Where(whereClause)
	}
	//var count int64
	totalTx := tx
	err = totalTx.Count(&totalCount).Error
	if err != nil {
		return
	}
	//totalCount = int(count)
	if params.PageNo != 0 || params.PageSize != 0 {
		tx = tx.Limit(params.PageSize).Offset(params.PageNo * params.PageSize)
	}
	scanTx := tx.Select(switchSelectSql).Order("asset_switch.id")
	err = scanTx.Scan(&switchList).Error
	if err != nil {
		return
	}
	return
}

func DeleteSwitchInfoByIds(ids []int) (rowsAffected int, err error) {
	err = dao.AssetDB.Transaction(func(tx *gorm.DB) error {
		// 在事务中执行一些 db 操作（从这里开始，您应该使用 'tx' 而不是 'db'）
		if err = tx.Table("asset_switch_interface").Where("switch_id in (?)", ids).Update("deleted", dao.DELETED_Y).Error; err != nil {
			return err
		}
		result := tx.Table("asset_switch").Where("id in (?)", ids).Update("deleted", dao.DELETED_Y)
		err = result.Error
		if err != nil {
			return err
		}
		rowsAffected = int(result.RowsAffected)
		// 返回 nil 提交事务
		return nil
	})
	return
}

func InsertSwitchList(switchList []switchMachine.MysqlSwitch) (err error) {
	err = dao.AssetDB.Transaction(func(tx *gorm.DB) error {
		if err = tx.Table("asset_switch").Create(&switchList).Error; err != nil {
			return err
		}
		return nil
	})
	return err
}

func SelectMysqlSwitchByCoreKey(key interface{}) (*switchMachine.MysqlSwitch, error) {
	var (
		result = &switchMachine.MysqlSwitch{}
		err    error
		id     int
		sn     string
		ok     bool
	)
	tx := dao.AssetDB.Table("asset_switch")
	if id, ok = key.(int); ok {
		tx = tx.Where("id = ?", id)
	} else if sn, ok = key.(string); ok {
		tx = tx.Where("sn = ?", sn)
	} else {
		return nil, errors.New("invalid parameter. core key must be id or sn")
	}
	err = tx.First(result).Error
	return result, err

}

func UpdateSwitchInfo(params switchMachine.MysqlSwitch) error {
	tx := dao.AssetDB.Table("asset_switch")
	if params.Sn != "" {
		tx = tx.Where("sn = ?", params.Sn)
	}
	err := tx.Updates(params).Error
	return err
}
func UpdateSwitchInfoByTransaction(params switchMachine.MysqlSwitch) error {
	klog.Info("debug-switch")
	tx := dao.AssetDB.Begin()
	switchTx := tx.Table("asset_switch").Debug()
	if params.Sn != "" {
		switchTx = switchTx.Where("sn = ?", params.Sn)
	}
	err := switchTx.Updates(params).Error
	if err != nil {
		tx.Rollback()
		return err
	}
	//err = switchTx.First(&params).Error
	//if err != nil {
	//	tx.Rollback()
	//	return err
	//}

	if params.RackId > 0 {
		switchInfo, err1 := SelectSwitchInfoByName(params.Name)
		if err1 != nil {
			tx.Rollback()
			return err
		}
		if switchInfo.RackId == params.RackId || switchInfo.SwitchUnitNumber == params.SwitchUnitNumber {
			return nil
		}
		err = rackdao.UpdateRackStatusByTransactionNew(params.RackId, params.SwitchUnitNumber, "交换机", params.Name, params.Sn, params.CabinetId, tx)
		if err != nil {
			tx.Rollback()
			return err
		}
	}
	tx.Commit()
	return err
}

func CountStateOverview(params switchMachine.MysqlSwitch) (int64, error) {
	tx := dao.AssetDB.Table("asset_switch").Where(params).Where("deleted = ?", dao.DELETED_N)
	//countList := make([]int64,3)
	var total int64
	err := tx.Count(&total).Error
	return total, err
	//countList[0] = total
	//var runCount int64
	//if err := tx.Where("run_status = ?","up").Count(&runCount).Error;err != nil {return nil, err}
	//countList[1] = runCount
	//var crashCount int64
	//if err := tx.Where("run_status != ?","up").Count(&crashCount).Error;err != nil {return nil, err}
	//countList[2] = crashCount
	//return countList,nil
}

func CountMaintenanceDueOverview(params switchMachine.MysqlSwitch, dueType string) (int64, error) {
	tx := dao.AssetDB.Table("asset_switch").Where("deleted = ?", dao.DELETED_N)
	var total int64
	if params.MaintenanceDue.Unix() > 0 || !params.MaintenanceDue.IsZero() {
		switch dueType {
		case "insured":
			tx = tx.Where("maintenance_due > 0 and maintenance_due <= ?", params.MaintenanceDue)
		case "insured1m":
			//tx = tx.Where("maintenance_due > ? and maintenance_due <= ?", time.Now(), time.Now().AddDate(0, 1, 0))
			start := params.MaintenanceDue.Format("2006-01-02 15:04:05")
			end := params.MaintenanceDue.AddDate(0, 1, 0).Format("2006-01-02 15:04:05")
			tx = tx.Where("maintenance_due > ? and maintenance_due <= ?", start, end)
		case "insured3m":
			//tx = tx.Where("maintenance_due > ? and maintenance_due <= ?", time.Now(), time.Now().AddDate(0, 3, 0))
			start := params.MaintenanceDue.Format("2006-01-02 15:04:05")
			end := params.MaintenanceDue.AddDate(0, 3, 0).Format("2006-01-02 15:04:05")
			tx = tx.Where("maintenance_due > ? and maintenance_due <= ?", start, end)
		case "uninsured":
			//tx = tx.Where("maintenance_due > ?", time.Now().AddDate(0, 3, 0))
			end := params.MaintenanceDue.AddDate(0, 3, 0).Format("2006-01-02 15:04:05")
			tx = tx.Where("maintenance_due > ?", end)
		case "N/A":
			n_a := "maintenance_due = 0 or maintenance_due is null"
			tx = tx.Where(n_a)
		}
	}
	params.MaintenanceDue = time.Time{}
	err := tx.Where(params).Count(&total).Error
	return total, err
}

func CountLocationOverview(regionCode, azCode string) ([]switchMachine.OverviewSlot, error) {
	var (
		regWhere string
		azWhere  string
		viewList = make([]switchMachine.OverviewSlot, 0)
		err      error
	)
	if regionCode != "all" && regionCode != "" {
		regWhere = fmt.Sprintf("where region_code = '%s'", regionCode)
	}
	if azCode != "all" && azCode != "" {
		azWhere = fmt.Sprintf("where az_code = '%s'", azCode)
	}
	sql := fmt.Sprintf(`(
		select
			count(1) as total,
			concat(reg.region_name,az.az_name) as name,
			reg.region_code as region_code,
			az.az_code as az_code,
			'个' as unit
		from (select id,az_id from asset_switch where deleted = %d) as asw 
		inner join (select id,az_code,az_name,region_id from asset_az %s) as az on az.id = asw.az_id
		inner join (select id,region_code,region_name from asset_region %s) as reg on reg.id = az.region_id
		group by reg.region_code, az.az_code, concat(reg.region_name,az.az_name)) as over_view
	`, dao.DELETED_N, azWhere, regWhere)
	err = dao.AssetDB.Table(sql).Scan(&viewList).Error
	return viewList, err
}

func SelectSwitchLayoutListByCons(sn string) (total int64, layouts []switchMachine.SwitchInterfaceLayout, err error) {
	tx := dao.AssetDB.Table("asset_switch_interface_layout").
		Where(`switch_type = (select switch_type from asset_switch where sn = ? and deleted = ?)`, sn, dao.DELETED_N)
	if err = tx.Count(&total).Error; err != nil {
		return
	}
	if err = tx.Scan(&layouts).Error; err != nil {
		return
	}
	return
}

func SelectSwitchInterfaceInfoListBySn(param switchMachine.SwitchInterfaceLayoutListParams) (totalCount int64, details []switchMachine.SwitchInterfaceInfo, err error) {
	tx := dao.AssetDB.Debug().Table("asset_switch_interface_layout as asil").
		Joins(`
			inner join asset_switch on asset_switch.sn = ? and asset_switch.deleted = ? and asil.switch_type = asset_switch.switch_type
			left join
				(SELECT @xi:=@xi+1 as xc from
				(SELECT 1 UNION SELECT 2 UNION SELECT 3 UNION SELECT 4 UNION SELECT 5 UNION SELECT 6 UNION SELECT 7 UNION SELECT 8 UNION SELECT 9 UNION SELECT 10) xc1,
				(SELECT 1 UNION SELECT 2 UNION SELECT 3 UNION SELECT 4 UNION SELECT 5 UNION SELECT 6 UNION SELECT 7 UNION SELECT 8 UNION SELECT 9 UNION SELECT 10) xc2,
				(SELECT 1 UNION SELECT 2 UNION SELECT 3 UNION SELECT 4 UNION SELECT 5 UNION SELECT 6 UNION SELECT 7 UNION SELECT 8 UNION SELECT 9 UNION SELECT 10) xc3,
				(SELECT @xi:=0) xc0) as seq on 1=1
			`, param.Sn, dao.DELETED_N).
		Select("asset_switch.ip as management_ip,asset_switch.out_band_ip,asil.switch_type,asil.interface_type,xc").
		Where("seq.xc >= asil.start_index and seq.xc < asil.start_index+(asil.x * asil.y)")
	if err = tx.Count(&totalCount).Error; err != nil {
		return
	}
	if param.PageSize > 0 {
		tx = tx.Offset(param.PageNo * param.PageSize).Limit(param.PageSize)
	}
	err = tx.Order("xc").Scan(&details).Error
	if err != nil {
		klog.Error("getInterfaceLayoutErr", err)
	}
	return
}

//func SelectSwitchInterfaceInfoListBySn(param switchMachine.SwitchInterfaceLayoutListParams) (totalCount int64, details []switchMachine.SwitchInterfaceInfo, err error) {
//	tx := dao.AssetDB.Table("asset_switch_interface_details as asid").
//		Joins("left join asset_switch on asset_switch.sn = asid.sn and asset_switch.deleted = ?", dao.DELETED_N).
//		Joins("left join asset_switch_interface_layout as asil on asil.switch_type = asset_switch.switch_type and (substring_index(asid.if_name,'/',-1) >= asil.start_index and substring_index(asid.if_name,'/',-1) < x*y+asil.start_index)").
//		Select("asset_switch.ip as management_ip,asset_switch.out_band_ip,asil.switch_type,asil.interface_type,asid.if_index xc").
//		Where("asid.if_index >= asil.start_index and asid.if_index < asil.start_index+(asil.x * asil.y) and asid.sn = ?", param.Sn)
//	if err = tx.Count(&totalCount).Error; err != nil {
//		return
//	}
//	if param.PageSize > 0 {
//		tx = tx.Offset((param.PageNo - 1) * param.PageSize).Limit(param.PageSize)
//	}
//	err = tx.Order("asid.if_index").Scan(&details).Error
//	return
//}

func SelectSwitchInterfaceDetailListBySn(sn, index string) (details []switchMachine.SwitchInterfaceDetail, err error) {

	//tx := dao.AssetDB.Debug().Table("asset_switch_interface_details as asid").
	//	Joins("left join asset_switch_interface_initial_status as asiis on asid.sn = asiis.sn and asid.if_index = asiis.if_index").
	//	Joins("left join asset_switch on asset_switch.sn = asid.sn and asset_switch.deleted = ?", dao.DELETED_N).
	//	Joins("left join (select id device_id,name device_name from asset_physical_server where deleted = ? union all select id device_id,name device_name from asset_switch where deleted = ?) as device on asid.orther_end_device = device.device_name", dao.DELETED_N, dao.DELETED_N).
	//	Joins("left join asset_switch_interface_layout as asil on asil.switch_type = asset_switch.switch_type and (substring_index(asid.if_name,'/',-1) >= asil.start_index and substring_index(asid.if_name,'/',-1) < x*y+asil.start_index)").
	//	Select("asid.sn, asid.if_name, asid.if_index, asiis.port_state if_status, if_ip, if_mac, if_speed, asil.interface_type if_type, orther_end_device, orther_end_if, orther_end_descr,orther_end_type, device.device_id orther_end_id").
	//	Where("asid.sn = ?", sn)

	tx := dao.AssetDB.Table("asset_switch_interface_details as asid").
		Joins("left join asset_switch on asset_switch.sn = asid.sn and asset_switch.deleted = ?", dao.DELETED_N).
		Joins("left join (select id device_id,name device_name from asset_physical_server where deleted = ? union all select id device_id,name device_name from asset_switch where deleted = ?) as device on asid.orther_end_device = device.device_name", dao.DELETED_N, dao.DELETED_N).
		Joins("LEFT JOIN asset_physical_server_network AS network ON asid.orther_end_if = network.mac ").
		Joins("left join asset_switch_interface_layout as asil on asil.switch_type = asset_switch.switch_type and (substring_index(asid.if_name,'/',-1) >= asil.start_index and substring_index(asid.if_name,'/',-1) < x*y+asil.start_index)").
		Select("asid.sn, asid.if_name, asid.if_index, asid.port_state if_status, if_ip, if_mac, if_speed, asil.interface_type if_type, orther_end_device, CASE WHEN net_work IS NOT NULL THEN CONCAT(net_work, '/', orther_end_if) ELSE orther_end_if END AS orther_end_if , orther_end_descr,orther_end_type, device.device_id orther_end_id").
		Where("asid.sn = ?", sn)
	if index != "" {
		tx = tx.Where("asid.if_index = ?", index)
	}
	tx = tx.Order("sn,if_index")
	err = tx.Scan(&details).Error
	if err != nil {
		klog.Error("getInterfaceDetailsErr", err)
	}
	//tx := dao.AssetDB.Table("asset_switch_interface_details as asid").
	//	Select(`sn, if_name, if_index, if_status, if_ip, if_mac, if_speed,
	//					(select asil.interface_type from asset_switch as asw
	//						left join asset_switch_interface_layout as asil
	//						on asil.switch_type = asw.switch_type
	//					where asw.sn = sn
	//						and (substring_index(if_name,'/',-1) >= asil.start_index and substring_index(if_name,'/',-1) < x*y+asil.start_index)) if_type,
	//				orther_end_device, orther_end_if, orther_end_descr`).
	//	Where("asid.sn = ?", sn)
	//err = tx.Scan(&details).Error
	return
}

// 获取所有交换机ip和name
func GetAllSwitchList() (physicalSwitch []switchMachine.PhysicalSwitch, err error) {
	err = dao.AssetDB.Table("asset_switch").
		Select("name,out_band_ip as ip,'物理交换机' as physical_type,id,region_id,az_id,mib,interval_time,scrape_timeout").
		Where("deleted = 0").Scan(&physicalSwitch).Error
	return
}

func GetAllSystemSales() []string {
	var sales = make([]string, 0)
	_ = dao.AssetDB.Table("asset_switch").Where("system_sales IS NOT NULL and system_sales != ''").Select("distinct system_sales").Scan(&sales)
	return sales
}

// 获取交换机mib
func GetAllSwitchMIbList() (physicalSwitch []switchMachine.PhysicalSwitchMib, err error) {
	err = dao.AssetDB.Table("asset_switch_mib").
		Select("mib_type,name ,oid ,type,help,indexes,lookups").
		Where("deleted = 0").Scan(&physicalSwitch).Error
	return
}

// GetUplinkSwitchList 根据服务器名称获取上联交换机列表
func GetUplinkSwitchList(serverName string) (uplinkSwitchList []string, err error) {
	err = dao.AssetDB.Table("asset_switch_interface_details as  details ").
		Joins("left join asset_switch  as switch  on  switch.sn = details.sn").
		Select("switch.name as name ").
		Where("orther_end_device = ?", serverName).
		Group("details.sn").
		Scan(&uplinkSwitchList).Error
	return
}

func GetSwitchRoleInfo(enName string) (uplinkSwitchList SwitchRole, err error) {
	err = dao.AssetDB.Debug().Table("asset_switch_role").
		Where("en_name = ?", enName).
		First(&uplinkSwitchList).Error
	return
}

type SwitchInterfaceNum struct {
	Sn             string `json:"sn"`
	InterfaceCount int64  `json:"interfaceCount"`
}

// GetSwitchInterfaceCount 获取交换机接口列表
func GetSwitchInterfaceCount() (res []SwitchInterfaceNum, err error) {

	err = dao.AssetDB.Table("asset_switch_interface_details").Select("sn,COUNT(*) AS interface_count").Group("sn").Scan(&res).Error

	if err != nil {
		return nil, err
	}
	return res, nil
}

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/pkg/dao/lab/labModel.go
```golang
package lab

import "time"

type Lab struct {
	Id              int
	LabName         string
	LabCode         string
	AzId            int
	RegionId        int
	Address         string
	ServiceProvider string
	Description     string
	Power           string
	SparePower      string
	Updater         string
	Creator         string
	CreateTime      time.Time `gorm:"autoCreateTime"`
	UpdateTime      time.Time `gorm:"autoUpdateTime"`
	Deleted         uint8
}

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/pkg/dao/lab/labDao.go
```golang
package lab

import (
	"database/sql"
	"fmt"
	"luban-cmdb-api/pkg/dao"
	labmodel "luban-cmdb-api/pkg/models/lab"
	"strings"

	"gorm.io/gorm"
)

//分页获取机房列表数据
func GetLabPageList(params labmodel.LabQueryParams) (rows *sql.Rows, count int, err error) {
	var where []string
	var values []interface{}
	where = append(where, "lab.deleted=?")
	values = append(values, dao.DELETED_N)
	if params.RegionCode != "" && params.RegionCode != "all" {
		where = append(where, "region.region_code = ?")
		values = append(values, params.RegionCode)
	}
	if len(params.AzCode) > 0 {
		where = append(where, "az.az_code in (?)")
		values = append(values, params.AzCode)
	}
	if params.SearchValue != "" {
		if params.SearchType == "ID" {
			where = append(where, "lab.id = ?")
			//idInt, _ := strconv.Atoi(params.SearchValue)
			values = append(values, params.SearchValue)
		} else if params.SearchType == "labName" {
			where = append(where, "lab.lab_name like ?")
			values = append(values, "%"+fmt.Sprintf("%s", params.SearchValue)+"%")
		} else if params.SearchType == "labCode" {
			where = append(where, "lab.lab_code like ?")
			values = append(values, "%"+fmt.Sprintf("%s", params.SearchValue)+"%")
		} else if params.SearchType == "serviceProvider" {
			where = append(where, "lab.service_provider like ?")
			values = append(values, "%"+fmt.Sprintf("%s", params.SearchValue)+"%")
		}
	}
	sql := "FROM asset_lab lab LEFT JOIN asset_az az ON lab.az_id=az.id" +
		" LEFT JOIN asset_region region ON lab.region_id=region.id " +
		" WHERE  " + strings.Join(where, " and ")

	//count
	dao.AssetDB.Raw("SELECT COUNT(1) "+sql, values...).Scan(&count)
	if count <= 0 {
		return
	}
	start := (params.PageNo - 1) * params.PageSize
	sql += fmt.Sprintf(" ORDER BY id DESC LIMIT %d,%d ", start, params.PageSize)
	sql = "SELECT lab.id,lab.lab_name,lab.lab_code,az.az_code,az.az_name,region.region_code,region.region_name,lab.address,lab.description," +
		"lab.power,lab.spare_power,lab.service_provider,lab.creator,lab.create_time, " +
		"(select count(1) from asset_device_room where lab_id=lab.id and deleted=0) as room_count," +
		"(select count(1) from asset_cabinet where lab_id=lab.id and deleted=0) as cabinet_count," +
		"(select count(1) from asset_rack where lab_id=lab.id and deleted=0) as rack_count," +
		"(select count(1) from asset_rack where lab_id=lab.id and deleted=0 and rack_status=1) as used_unit_count," +
		"(select count(1) from asset_rack where lab_id=lab.id and deleted=0 and rack_status=0) as unused_unit_count " +
		sql
	rows, err = dao.AssetDB.Raw(sql, values...).Rows()
	if err != nil {
		return
	}

	return
}

//获取所有的lab
func GetLabList(lab Lab) ([]Lab, error) {
	dc := []Lab{}
	lab.Deleted = 0
	ret := dao.AssetDB.Where(lab).Find(&dc)
	if ret.Error != nil {
		return nil, ret.Error
	}
	return dc, nil
}

//获取所有的lab
func GetLabListByLabMap(labMap map[string]interface{}) ([]Lab, error) {
	dc := []Lab{}
	//lab.Deleted = 0
	labMap["deleted"] = dao.DELETED_N
	ret := dao.AssetDB.Model(&Lab{}).Where(labMap).Find(&dc)
	if ret.Error != nil {
		return nil, ret.Error
	}
	return dc, nil
}

//根据code和name判断是否存在lab
func GetLabByCodeOrName(code string, name string) (dr Lab, err error) {
	dr = Lab{}
	tx := dao.AssetDB
	if code == "" && name == "" {
		err = fmt.Errorf("机房code和机房名称必须提供其中一个")
		return
	}

	//if code == "" {
	//	tx = tx.Where("lab_name=? AND deleted = ?", name, dao.DELETED_N)
	//} else {
	//	tx = tx.Where("lab_code=? AND deleted = ?", code, dao.DELETED_N)
	//}
	tx = tx.Where("(lab_code = ? OR lab_name = ?) AND deleted = ?", code, name, dao.DELETED_N)
	err = tx.First(&dr).Error
	if err == gorm.ErrRecordNotFound {
		return
	}
	return
}

//添加数据
func AddLab(dr Lab) (int, error) {
	err := dao.AssetDB.Create(&dr).Error
	return dr.Id, err
}

//修改数据
func UpdateLab(dr Lab) error {
	return dao.AssetDB.Updates(dr).Where("id=?", dr.Id).Error
}

//fake delete
func DeleteLab(ids []int, updater string) error {
	dr := Lab{
		Updater: updater,
		Deleted: dao.DELETED_Y,
	}
	return dao.AssetDB.Where("id in (?)", ids).Updates(dr).Error
}

//查询一条
func GetLab(id int) (Lab, error) {
	dr := Lab{}
	ret := dao.AssetDB.Where("id=? AND deleted=?", id, dao.DELETED_N).First(&dr)
	if ret.Error == gorm.ErrRecordNotFound {
		return dr, ret.Error
	}
	return dr, nil
}

//查询一条
func GetLabByCode(code string) (Lab, error) {
	dr := Lab{}
	ret := dao.AssetDB.Where("lab_code=? AND deleted=?", code, dao.DELETED_N).First(&dr)
	fmt.Println("ret.Error:", ret.Error)
	if ret.Error == gorm.ErrRecordNotFound {
		return dr, fmt.Errorf("没有找到机房信息！")
	}
	return dr, nil
}

//根据AzCode list 查询机房列表
func GetLabByAzs(azCodes []string) (labCascade []labmodel.BasicLab, err error) {
	err = dao.AssetDB.Model(&Lab{}).
		Select(`asset_lab.lab_code,
		asset_lab.lab_name,
		asset_lab.id `).
		Joins(`left join asset_az  on asset_az.id = asset_lab.az_id`).
		Where("asset_az.az_code in ? and asset_lab.deleted = ?", azCodes, dao.DELETED_N).
		Scan(&labCascade).Error
	return
}

//根据roomCode list 查询机房列表
func GetLabByRooms(roomCodes []string) (labCascade []labmodel.BasicLab, err error) {
	err = dao.AssetDB.Table("asset_device_room").
		Select(`room_code,
		room_name `).
		//Joins(`left join asset_device_room  on asset_device_room.id = asset_lab.az_id`).
		Where("id in (select id from asset_device_room where room_code in ? and asset_lab.deleted = ?) and asset_lab.deleted = ?", roomCodes, dao.DELETED_N, dao.DELETED_N).
		Scan(&labCascade).Error
	return
}

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/pkg/dao/basic/regionDao.go
```golang
package basic

import (
	"luban-cmdb-api/pkg/dao"
)

//根据条件获取所有的region数据，目前暂定适用于级联获取所有region数据
func GetRegionList(region Region) ([]Region, error) {
	var dc []Region
	ret := dao.AssetDB.Where(region).Find(&dc)
	if ret.Error != nil {
		return nil, ret.Error
	}
	return dc, nil
}

func GetRegionMap(region Region) (map[string]Region, error) {
	var rmp = make(map[string]Region)
	rlist, err := GetRegionList(region)
	if err != nil {
		return nil, err
	}
	for _, r := range rlist {
		rmp[r.RegionCode] = r
	}
	return rmp, nil
}

//根据条件获取单条数据
func GetRegion(region Region) (Region, error) {
	dc := Region{}
	ret := dao.AssetDB.Where(region).First(&dc)
	// if ret.Error == gorm.ErrRecordNotFound {
	// 	return dc, ret.Error
	// }
	return dc, ret.Error
}

//根据条件Map获取所有的region数据，
func GetRegionListByRegionMap(regionMap map[string]interface{}) ([]Region, error) {
	var dc []Region
	ret := dao.AssetDB.Model(&Region{}).Where(regionMap).Find(&dc)
	if ret.Error != nil {
		return nil, ret.Error
	}
	return dc, nil
}

func GetRegionListByRegionCodes(codes []string) ([]Region, error) {
	var dc []Region
	ret := dao.AssetDB.Model(&Region{}).Where("region_code IN ?", codes).Find(&dc)
	if ret.Error != nil {
		return nil, ret.Error
	}
	return dc, nil
}

//查询到regionIds下对应的region
func QueryRegionListByIds(ids []int) (ls []Region, err error) {
	err = dao.AssetDB.Where("id in ?", ids).Find(&ls).Error
	if err != nil {
		return
	}
	return
}

//region_code_aggregate
func GetAllRegionAggregateCode() ([]string, error) {
	var (
		AggregateCode = make([]string, 0)
		err           error
	)
	err = dao.AssetDB.Model(&Region{}).Select("region_code_aggregate").Find(&AggregateCode).Error
	return AggregateCode, err
}

//获取到所有的region，返回id=>Region{}格式的map
func QueryAllRegion2Map() (m map[int]Region, err error) {
	m = make(map[int]Region)
	regions, err := GetRegionList(Region{})
	if err != nil {
		return
	}
	for _, v := range regions {
		m[v.Id] = v
	}
	return
}

//返回RegionCode=>Region{}格式的map
func QueryAllRegionCode2Map() (m map[string]Region, err error) {
	m = make(map[string]Region)
	regions, err := GetRegionList(Region{})
	if err != nil {
		return
	}
	for _, v := range regions {
		m[v.RegionCode] = v
	}
	return
}

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/pkg/dao/basic/dynamiccolumn.go
```golang
package basic

import (
	"luban-cmdb-api/pkg/dao"
	"time"
)

type DynamicColumn struct {
	Id         int       `gorm:"column:id"`
	UserName   string    `gorm:"column:username"`
	Url        string    `gorm:"column:url"`
	ColumnData string    `gorm:"column:column_data"`
	CreateTime time.Time `gorm:"autoCreateTime"`
	UpdateTime time.Time `gorm:"autoCreateTime"`
}

func GetDynamicColumn(username, url string) (DynamicColumn, error) {
	dc := DynamicColumn{}
	ret := dao.AssetDB.Where("username=? AND url=?", username, url).Find(&dc)
	return dc, ret.Error
}

func SetDynamicColumn(id int, columnData string) error {
	return dao.AssetDB.Model(&DynamicColumn{}).Where("id=?", id).Update("column_data", columnData).Error
}

func AddDynamicColumn(username, url, columnData string) (DynamicColumn, error) {
	dc := DynamicColumn{
		UserName:   username,
		Url:        url,
		ColumnData: columnData,
	}
	ret := dao.AssetDB.Omit("create_time,update_time").Create(&dc)
	return dc, ret.Error
}

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/pkg/dao/basic/resource.go
```golang
package basic

import (
	"gorm.io/gorm"
	"luban-cmdb-api/pkg/dao"
	"time"
)

type Resource struct {
	Id         int
	Name       string    `gorm:"column:name"`
	Code       string    `gorm:"column:code"`
	ParentId   int       `gorm:"column:parent_id"`
	Creator    string    `gorm:"column:creator"`
	Updater    string    `gorm:"column:updater"`
	CreateTime time.Time `gorm:"autoCreateTime"`
	UpdateTime time.Time `gorm:"autoUpdateTime"`
	DeleteTime time.Time `gorm:"deleteTime"`
}

//根据code 查询单条数据
func GetResourceByCode(code string) (r Resource, err error) {
	ret := dao.AssetDB.Model(&Resource{}).Where("code = ?", code).
		Find(&r)
	if ret.Error != gorm.ErrRecordNotFound {
		err = ret.Error
	}
	return
}

//根据parentId查询资源(子)类型
//资源类型1级表示为parentId=0
func QueryResourceList(parentId int) (rs []Resource, err error) {
	ret := dao.AssetDB.Model(&Resource{}).Where("parent_id = ?", parentId).
		Find(&rs)
	if ret.Error != gorm.ErrRecordNotFound {
		err = ret.Error
	}
	return
}

//获取所有resource信息
func QueryAllResource() (rs []Resource, err error) {
	ret := dao.AssetDB.Model(&Resource{}).Where("delete_time = ?",0).Find(&rs)
	if ret.Error != gorm.ErrRecordNotFound {
		err = ret.Error
	}
	return
}

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/pkg/dao/basic/regionDao_test.go
```golang
package basic

import (
	"fmt"
	"testing"
)

//测试
func TestGetRegionList(t *testing.T) {
	region := Region{}
	users, err := GetRegionList(region)
	if err != nil {
		fmt.Println(err)
	}
	for _, v := range users {
		fmt.Println(v)
	}
}

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/pkg/dao/basic/azDao.go
```golang
package basic

import (
	"luban-cmdb-api/pkg/dao"
)

//根据条件获取所有的region数据，目前暂定适用于级联获取所有region数据
func GetAzList(az Az) ([]Az, error) {
	dc := []Az{}
	ret := dao.AssetDB.Model(&Az{}).Where(az).Find(&dc)
	if ret.Error != nil {
		return nil, ret.Error
	}
	return dc, nil
}

type AzAndRegion struct {
	Az
	RegionCode string `gorm:"column:region_code" json:"regionCode"`
	RegionName string `gorm:"column:region_name" json:"regionName"`
}

func GetAzList1(az Az) ([]AzAndRegion, error) {
	list := []AzAndRegion{}
	ret := dao.AssetDB.Model(&Az{}).Select("asset_az.*, region.region_code, region.region_name").
		Joins("left join asset_region as region on asset_az.region_id = region.id").Where(az).Find(&list)

	if ret.Error != nil {
		return nil, ret.Error
	}
	return list, nil
}

func GetAzMap(az Az) (map[string]Az, error) {
	var azMp = make(map[string]Az)
	azList, err := GetAzList(az)
	if err != nil {
		return nil, err
	}
	for _, a := range azList {
		azMp[a.AzCode] = a
	}
	return azMp, nil
}

func GetAzCodeAggregateMap(az Az) (map[string]Az, error) {
	var azMp = make(map[string]Az)
	azList, err := GetAzList(az)
	if err != nil {
		return nil, err
	}
	for _, a := range azList {
		azMp[a.AzCodeAggregate] = a
	}
	return azMp, nil
}

func GetAzCodeMap(az Az) (map[string]AzAndRegion, error) {
	var azMp = make(map[string]AzAndRegion)
	azList, err := GetAzList1(az)
	if err != nil {
		return nil, err
	}
	for _, a := range azList {
		azMp[a.AzCode] = a
	}
	return azMp, nil
}

//根据条件获取单条数据
func GetAz(az Az) (Az, error) {
	dc := Az{}
	ret := dao.AssetDB.Debug().Where(az).First(&dc)
	// if ret.Error == gorm.ErrRecordNotFound {
	// 	return dc, ret.Error
	// }
	//if ret.Error != nil && ret.Error != gorm.ErrRecordNotFound {
	//	return dc, ret.Error
	//}
	//err = nil
	return dc, ret.Error
}

//根据条件获取所有的region数据，目前暂定适用于级联获取所有region数据
func GetAzListByMap(azMap map[string]interface{}) ([]Az, error) {
	dc := []Az{}
	ret := dao.AssetDB.Model(&Az{}).Where(azMap).Find(&dc)
	if ret.Error != nil {
		return nil, ret.Error
	}
	return dc, nil
}

//查询到azIds下对应的az
func QueryAzListByIds(ids []int) (ls []Az, err error) {
	err = dao.AssetDB.Where("id in ?", ids).Find(&ls).Error
	if err != nil {
		return
	}
	return
}

//根据AzCode查询Az
func QueryAzByAzCode(azCode string) (Az, error) {
	dc := Az{}
	ret := dao.AssetDB.Where("az_code = ?", azCode).Find(&dc)
	return dc, ret.Error
}

//根据azCodeAggregate查询Az
func QueryAzByAzCodeAggregate(azCodeAggregate string) (Az, error) {
	dc := Az{}
	ret := dao.AssetDB.Where("az_code_aggregate = ?", azCodeAggregate).Find(&dc)
	return dc, ret.Error
}

//获取到所有的az，返回id=>Az{}格式的map
func QueryAllAz2Map() (m map[int]Az, err error) {
	m = make(map[int]Az)
	azs, err := GetAzList(Az{})
	if err != nil {
		return
	}
	for _, v := range azs {
		m[v.Id] = v
	}
	return
}

//获取到所有的az，返回azCode=>Az{}格式的map
func QueryAllAzCode2Map() (m map[string]Az, err error) {
	m = make(map[string]Az)
	azs, err := GetAzList(Az{})
	if err != nil {
		return
	}
	for _, v := range azs {
		m[v.AzCode] = v
	}
	return
}

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/pkg/dao/basic/baiscDao.go
```golang
package basic

import (
	"luban-cmdb-api/pkg/dao"
	"strings"
)

//获取单个服务器详情的cpu,disk,memary等信息
// func (s *ServerService) GetPhysicalHostHardwareEntity(hostsn string) (physicalHostDetail, error) {

// 	q := `{

//     cpuMessage(func:eq(cpuSn,"` + hostsn + `")){
//       cpuInfo
//       }
//     diskMessage(func:eq(diskSn,"` + hostsn + `")){
//         device
//       }
//       memoryMessage(func:eq(memSn,"` + hostsn + `")){
//         device
//       }
//       networkCardMessage(func:eq(netSn,"` + hostsn + `")){
//         netInfo
//       }
//       raidMessage(func:eq(raidSn,"` + hostsn + `")){
//         raidInfo
//       }
//     }`
// 	//fmt.Println(q)

// 	var physicalHostDetailFromDgraph physicalHostDetail
// 	resp, err := h.dgraphClient.NewTxn().Query(context.Background(), q)
// 	err = json.Unmarshal(resp.Json, &physicalHostDetailFromDgraph)
// 	//fmt.Println(*resp)
// 	return physicalHostDetailFromDgraph, err
// }

func GetCpuMessage(cpu Cpu) (cpuList []Cpu, err error) {
	ret := dao.AssetDB.Where(cpu).Find(&cpuList)
	err = ret.Error
	return
}
func InsertCpuMessage(cpu Cpu) (err error) {
	ret := dao.AssetDB.Model(&Cpu{}).Create(cpu)
	err = ret.Error
	return
}
func UpdateCpuMessage(cpu Cpu) (err error) {
	ret := dao.AssetDB.Model(&Cpu{}).Where("sn", cpu.Sn).Updates(cpu)
	err = ret.Error
	return
}
func GetMemMessage(mem Mem) (memList []Mem, err error) {
	ret := dao.AssetDB.Where(mem).Find(&memList)
	err = ret.Error
	return
}
func InsertMemMessage(mem Mem) (err error) {
	ret := dao.AssetDB.Model(&Mem{}).Create(mem)
	err = ret.Error
	return
}
func UpdateMemMessage(mem Mem) (err error) {
	ret := dao.AssetDB.Model(&Mem{}).Where("sn", mem.Sn).Updates(mem)
	err = ret.Error
	return
}
func GetDiskMessage(disk Disk) (diskList []Disk, err error) {
	ret := dao.AssetDB.Where(disk).Find(&diskList)
	err = ret.Error
	return
}
func InsertDiskMessage(disk Disk) (err error) {
	ret := dao.AssetDB.Model(&Disk{}).Create(disk)
	err = ret.Error
	return
}
func UpdateDiskMessage(disk Disk) (err error) {
	ret := dao.AssetDB.Model(&Disk{}).Where("sn", disk.Sn).Updates(disk)
	err = ret.Error
	return
}
func GetRaidMessage(raid Raid) (raidList []Raid, err error) {
	ret := dao.AssetDB.Where(raid).Find(&raidList)
	err = ret.Error
	return
}
func InsertRaidMessage(raid Raid) (err error) {
	ret := dao.AssetDB.Model(&Raid{}).Create(raid)
	err = ret.Error
	return
}
func UpdateRaidMessage(raid Raid) (err error) {
	ret := dao.AssetDB.Model(&Raid{}).Where("sn", raid.Sn).Updates(raid)
	err = ret.Error
	return
}
func GetNetMessage(net Net) (netList []Net, err error) {
	ret := dao.AssetDB.Where(net).Find(&netList)
	err = ret.Error
	return
}
func InsertNetMessage(net Net) (err error) {
	ret := dao.AssetDB.Model(&Net{}).Create(net)
	err = ret.Error
	return
}
func UpdateNetMessage(net Net) (err error) {
	ret := dao.AssetDB.Model(&Net{}).Where("sn", net.Sn).Updates(net)
	err = ret.Error
	return
}
func GetGpuMessage(gpu Gpu) (gpuList []Gpu, err error) {
	ret := dao.AssetDB.Where(gpu).Find(&gpuList)
	err = ret.Error
	return
}
func CabinetsByLabId(labCode string) (roomCabinetRackList []RoomCabinetRack, err error) {
	err = dao.AssetDB.
		Select(`asset_rack.room_id,
		            asset_rack.room_name,
		            asset_rack.cabinet_id,
		            asset_rack.cabinet_name,
		            asset_rack.id,
		            asset_rack.rack_name 
					from asset_rack `).
		Joins(`left join asset_cabinet  on asset_cabinet.id = asset_rack.cabinet_id`).
		Joins(`left join asset_device_room  on asset_device_room.id = asset_rack.room_id`).
		Joins(`left join asset_lab  on asset_lab.id = asset_rack.lab_id`).
		Where("asset_lab.lab_code = ? and asset_rack.deleted = ?", labCode, dao.DELETED_N).
		Scan(&roomCabinetRackList).Error
	return
}

//根据labCode list 获取房间
func RoomsByLabCodes(labCodes []string) (rooms []RoomMysql, err error) {

	err = dao.AssetDB.Table("asset_device_room").Select("asset_device_room.id , room_name").
		Joins("left join asset_lab on asset_device_room.lab_id = asset_lab.id").
		Where("asset_lab.lab_code in ? and asset_lab.deleted = ?", labCodes, dao.DELETED_N).
		Find(&rooms).Error
	return
}

//根据roomids获取cabinets
func CabinetsByRoomIds(roomIds []int) (cabinets []CabinetMysql, err error) {
	err = dao.AssetDB.Table("asset_cabinet").
		Select(`
		asset_cabinet.id ,
		asset_cabinet.room_id ,
		asset_cabinet.cabinet_name  `).
		Where("asset_cabinet.room_id in (?) and asset_cabinet.deleted = ?", roomIds, dao.DELETED_N).
		Scan(&cabinets).Error
	return
}

//根据cabinetids获取未占用的U位 以及 物理资源自己所占的U位
func RacksByCabinetIds(cabinetIds []int, sn string) (cabinets []RackMysql, err error) {
	var where []string
	var values []interface{}
	whereQ := ""
	if len(cabinetIds) > 0 {
		where = append(where, " (asset_rack.cabinet_id in (?) and rack_status=0) ")
		values = append(values, cabinetIds)
	}
	if sn != "" {
		where = append(where, "asset_rack.rack_resource_sn = ?")
		values = append(values, sn)
	}
	if len(cabinetIds) > 0 && sn != "" {
		whereQ = strings.Join(where, " or ")
	} else {
		whereQ = strings.Join(where, " and ")
	}
	err = dao.AssetDB.Table("asset_rack").
		Select(`
		asset_rack.id ,
		asset_rack.cabinet_id ,
		asset_rack.rack_name  `).
		Where(" asset_rack.deleted = ?", dao.DELETED_N).
		Where(whereQ, values...).
		Scan(&cabinets).Error
	return
}

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/pkg/dao/basic/basicModel.go
```golang
package basic

type Region struct {
	Id                  int `gorm:"column:id" json:"id"`
	RegionCodeAggregate string `gorm:"column:region_code_aggregate" json:"regionCodeAggregate"`
	RegionCode          string `gorm:"column:region_code" json:"regionCode"`
	RegionName          string `gorm:"column:region_name" json:"regionName"`
}
type Az struct {
	Id              int `gorm:"column:id" json:"id"`
	AzCodeAggregate string `gorm:"column:az_code_aggregate" json:"azCodeAggregate"`
	AzCode          string `gorm:"column:az_code" json:"azCode"`
	AzName          string `gorm:"column:az_name" json:"azName"`
	RegionId        int `gorm:"column:region_id" json:"regionId"`
}
type Cpu struct {
	// CpuType string `json:"cpuType"`
	// CpuCore int32  `json:"cpuCore"`
	// CpuRate string `json:"cpuRate"`
	Sn   string `json:"sn"`
	Info string `json:"info"`
}

type Mem struct {
	// MemoryType    string `json:"memoryType"`
	// TotalCapacity int64  `json:"totalCapacity"`
	Sn   string `json:"sn"`
	Info string `json:"info"`
}

type Disk struct {
	// DiskType      string `json:"diskType"`
	// TotalCapacity int64  `json:"totalCapacity"`
	// Count         int32  `json:"count"`
	Sn   string `json:"sn"`
	Info string `json:"info"`
}

type Raid struct {
	// RaidType string `json:"raidType"`
	// Count    int32  `json:"count"`
	Sn   string `json:"sn"`
	Info string `json:"info"`
}

type Net struct {
	// NetworkCardType string `json:"networkCardType"`
	// Count           int32  `json:"count"`
	Sn   string `json:"sn"`
	Info string `json:"info"`
}

type Gpu struct {
	Sn   string `json:"sn"`
	Info string `json:"info"`
	// GpuType  string `json:"gpuType"`
	// Capacity int32  `json:"capacity"`
}

type RoomCabinetRack struct {
	RoomName    string `gorm:"column:room_name"`
	RoomUid     string `gorm:"column:room_id"`
	CabinetName string `gorm:"column:cabinet_name"`
	CabinetUid  string `gorm:"column:cabinet_id"`
	RackName    string `gorm:"column:rack_name"`
	RackUid     string `gorm:"column:id"`
}
type RoomMysql struct {
	RoomName string `gorm:"column:room_name"`
	Id       int    `gorm:"column:id"`
}
type RackMysql struct {
	Id        int
	CabinetId int
	RackName  string
}
type CabinetMysql struct {
	Id          int
	RoomId      int
	CabinetName string
}

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/pkg/dao/server/serverDao.go
```golang
package server

import (
	"database/sql"
	"errors"
	"fmt"
	"luban-cmdb-api/pkg/dao"
	"luban-cmdb-api/pkg/models/server"
	"strings"
	"time"

	"gorm.io/gorm"
	"k8s.io/klog/v2"
)

// 获取列表
func GetPhysicalHostList(physicalHostListQuery server.PhysicalHostListQuery) (rows *sql.Rows, count int, err error) { //(server.PhysicalHostDataResult, error) {
	var where []string
	var values []interface{}
	now := time.Now()
	where = append(where, "server.deleted=?")
	values = append(values, dao.DELETED_N)
	if len(physicalHostListQuery.Region) > 0 { //physicalHostListQuery.Region != "all" && physicalHostListQuery.Region != "" {
		where = append(where, "region.region_code in (?)")
		values = append(values, physicalHostListQuery.Region)
	}
	if len(physicalHostListQuery.Az) > 0 {
		where = append(where, "az.az_code in (?)")
		values = append(values, physicalHostListQuery.Az)
	}
	if len(physicalHostListQuery.Lab) > 0 {
		where = append(where, "lab.lab_code in (?)")
		values = append(values, physicalHostListQuery.Lab)
	}
	if len(physicalHostListQuery.Room) > 0 {
		where = append(where, "room.room_code in (?)")
		values = append(values, physicalHostListQuery.Room)
	}
	if len(physicalHostListQuery.CabinetId) > 0 {
		where = append(where, "cabinet.id in (?)")
		values = append(values, physicalHostListQuery.CabinetId)
	}
	if physicalHostListQuery.Name != "" {
		where = append(where, "server.name like ?")
		values = append(values, "%"+physicalHostListQuery.Name+"%")
	}
	if physicalHostListQuery.Id != "" {
		//where = append(where, "server.id  like ?")
		//idInt, _ := strconv.Atoi(physicalHostListQuery.Id)
		//values = append(values, idInt)
		where = append(where, "CAST(server.id  as CHAR) LIKE ?")
		//idInt, _ := strconv.Atoi(physicalHostListQuery.Id)
		values = append(values, "%"+physicalHostListQuery.Id+"%")
	}
	if physicalHostListQuery.Ip != "" {
		where = append(where, "server.ip like ?")
		values = append(values, "%"+physicalHostListQuery.Ip+"%")
	}
	if physicalHostListQuery.Sn != "" {
		where = append(where, "server.sn like ?")
		values = append(values, "%"+physicalHostListQuery.Sn+"%")
	}

	if len(physicalHostListQuery.Runstatus) > 0 {
		where = append(where, "server.run_status in (?)")
		values = append(values, physicalHostListQuery.Runstatus)
	}
	if len(physicalHostListQuery.AssignmentStatus) > 0 {
		where = append(where, "server.assignment_status in (?)")
		values = append(values, physicalHostListQuery.AssignmentStatus)
	}
	if len(physicalHostListQuery.InputMethod) > 0 {
		where = append(where, "server.input_method in (?)")
		values = append(values, physicalHostListQuery.InputMethod)
	}
	whereMaintStarus := ""
	if len(physicalHostListQuery.MaintenanceStatus) > 0 {
		//i64, err := strconv.ParseInt(hostData.MaintenanceDue, 10, 64)
		//cout := (i64 - time.Now().Unix()) / 86400
		whereMaintStarus = " and maintenance_status in (?)"
		//where = append(where, "server.maintenance_status in (?)")
		values = append(values, physicalHostListQuery.MaintenanceStatus)

	}

	if physicalHostListQuery.ResourcePool != "" {
		if physicalHostListQuery.MixDeploy {
			where = append(where, "server.resource_pool like ?")
			values = append(values, fmt.Sprintf("%s%s%s", "%", physicalHostListQuery.ResourcePool, "%"))
		} else {
			where = append(where, "server.resource_pool = ?")
			values = append(values, physicalHostListQuery.ResourcePool)
		}
	}

	if len(physicalHostListQuery.ResourcePoolType) > 0 {
		where = append(where, "server.resource_pool_type in (?)")
		values = append(values, physicalHostListQuery.ResourcePoolType)
	}

	if len(physicalHostListQuery.Node) > 0 {
		where = append(where, "server.node in (?)")
		values = append(values, physicalHostListQuery.Node)
	}

	if physicalHostListQuery.StorageType != "" {
		where = append(where, "server.resource_pool_type = ?")
		values = append(values, physicalHostListQuery.StorageType)
	}
	//where = append(where, "(server.kind is not null)")
	where = append(where, "server.is_vm = 0") //虚机
	// values = append(values, "KVM")
	sqlStr := "FROM asset_physical_server server " +
		" LEFT JOIN asset_az az ON server.az_id=az.id" +
		" LEFT JOIN asset_region region ON server.region_id=region.id " +
		" LEFT JOIN asset_lab lab ON server.lab_id=lab.id " +
		" LEFT JOIN asset_device_room room ON server.room_id=room.id " +
		" LEFT JOIN asset_cabinet cabinet ON server.cabinet_id=cabinet.id " +
		" LEFT JOIN asset_rack rack ON server.rack_id=rack.id " +
		" WHERE  " + strings.Join(where, " and ") + ") t1 WHERE 1=1 " + whereMaintStarus + " ORDER BY id DESC  "

	sqlStr = fmt.Sprintf(`(SELECT server.id,server.name,
    server.ip,
    server.run_status,
    server.assignment_status,
    server.service,
    region.region_code,
    region.region_name,
    az.az_code,
    az.az_name,
    lab.lab_code,
    lab.lab_name,
    room.room_code,
	room.id as room_id,
    room.room_name,
	cabinet.id as cabinet_id,
    cabinet.cabinet_name,
	server.rack_id,
    rack.rack_name,
    server.host_unit_number,
    server.sn,
    server.ip as management_ip,
    server.out_band_ip,
    server.out_band_user,
    server.power,
	server.label,
    server.uplink_switch,
    server.maintenance_due,
	case when server.maintenance_due BETWEEN 1 AND %d
        then 'insured'
		when server.maintenance_due  BETWEEN %d AND  %d
        then 'insured1m'
		when server.maintenance_due between %d and %d
        then 'insured3m'
        when server.maintenance_due > %d
        then 'uninsured'
        else 'N/A' end as maintenance_status,
    server.assets_number,
    server.input_method,
    server.description,
    server.create_time as create_time,
    server.cpu_allocation_ratio,
    server.ram_allocation_ratio,
    server.operate_system,
    server.cpu_total,
	server.resource_pool,
    server.resource_pool_type,
	server.node,
    server.node_type,
	server.kind,
    server.memory_total `, now.Unix(), now.Unix(), now.Unix()+86400*30, now.Unix()+86400*30, now.Unix()+86400*90, now.Unix()+86400*90) + sqlStr
	//count
	tx := dao.AssetDB.Raw("select count(1) from "+sqlStr, values...).Scan(&count)
	if tx.Error != nil {
		klog.Infoln(tx.Error)
	}
	if count <= 0 {
		return
	}
	if physicalHostListQuery.PageNo > 0 && physicalHostListQuery.PageSize > 0 {
		start := (physicalHostListQuery.PageNo - 1) * physicalHostListQuery.PageSize
		sqlStr += fmt.Sprintf(" LIMIT %d,%d", start, physicalHostListQuery.PageSize)
	}
	rows, err = dao.AssetDB.Raw("select * from "+sqlStr, values...).Rows()
	if err != nil {
		return
	}

	return

}

func GetPhysicalHostList2(physicalHostListQuery server.PhysicalHostListQuery) (rows *sql.Rows, count int, err error) { //(server.PhysicalHostDataResult, error) {
	var where []string
	var values []interface{}
	now := time.Now()
	where = append(where, "server.deleted=?")
	values = append(values, dao.DELETED_N)
	if len(physicalHostListQuery.Region) > 0 { //physicalHostListQuery.Region != "all" && physicalHostListQuery.Region != "" {
		where = append(where, "region.region_code in (?)")
		values = append(values, physicalHostListQuery.Region)
	}
	if len(physicalHostListQuery.Az) > 0 {
		where = append(where, "az.az_code in (?)")
		values = append(values, physicalHostListQuery.Az)
	}
	if len(physicalHostListQuery.Lab) > 0 {
		where = append(where, "lab.lab_code in (?)")
		values = append(values, physicalHostListQuery.Lab)
	}
	if len(physicalHostListQuery.Room) > 0 {
		where = append(where, "room.room_code in (?)")
		values = append(values, physicalHostListQuery.Room)
	}
	if len(physicalHostListQuery.CabinetId) > 0 {
		where = append(where, "cabinet.id in (?)")
		values = append(values, physicalHostListQuery.CabinetId)
	}
	if physicalHostListQuery.Name != "" {
		where = append(where, "server.name like ?")
		values = append(values, "%"+physicalHostListQuery.Name+"%")
	}
	if physicalHostListQuery.Id != "" {
		where = append(where, "CAST(server.id  as CHAR) LIKE ?")
		values = append(values, "%"+physicalHostListQuery.Id+"%")
	}
	if physicalHostListQuery.Ip != "" {
		where = append(where, "server.ip like ?")
		values = append(values, "%"+physicalHostListQuery.Ip+"%")
	}
	if physicalHostListQuery.Sn != "" {
		where = append(where, "server.sn like ?")
		values = append(values, "%"+physicalHostListQuery.Sn+"%")
	}

	if len(physicalHostListQuery.Runstatus) > 0 {
		where = append(where, "server.run_status in (?)")
		values = append(values, physicalHostListQuery.Runstatus)
	}
	if len(physicalHostListQuery.AssignmentStatus) > 0 {
		where = append(where, "server.assignment_status in (?)")
		values = append(values, physicalHostListQuery.AssignmentStatus)
	}
	if len(physicalHostListQuery.InputMethod) > 0 {
		where = append(where, "server.input_method in (?)")
		values = append(values, physicalHostListQuery.InputMethod)
	}
	whereMaintStarus := ""
	if len(physicalHostListQuery.MaintenanceStatus) > 0 {
		whereMaintStarus = " and maintenance_status in (?)"
		values = append(values, physicalHostListQuery.MaintenanceStatus)

	}

	if physicalHostListQuery.ResourcePool != "" {
		if physicalHostListQuery.MixDeploy {
			where = append(where, "server.resource_pool like ?")
			values = append(values, fmt.Sprintf("%s%s%s", "%", physicalHostListQuery.ResourcePool, "%"))
		} else {
			where = append(where, "server.resource_pool = ?")
			values = append(values, physicalHostListQuery.ResourcePool)
		}
	}

	if len(physicalHostListQuery.ResourcePoolType) > 0 {
		where = append(where, "server.resource_pool_type in (?)")
		values = append(values, physicalHostListQuery.ResourcePoolType)
	}

	if len(physicalHostListQuery.Node) > 0 {
		where = append(where, "server.node in (?)")
		values = append(values, physicalHostListQuery.Node)
	}

	if physicalHostListQuery.StorageType != "" {
		where = append(where, "server.resource_pool_type = ?")
		values = append(values, physicalHostListQuery.StorageType)
	}
	where = append(where, "(server.kind is not null)")
	sqlStr := "FROM asset_physical_server server " +
		" LEFT JOIN asset_az az ON server.az_id=az.id" +
		" LEFT JOIN asset_region region ON server.region_id=region.id " +
		" LEFT JOIN asset_lab lab ON server.lab_id=lab.id " +
		" LEFT JOIN asset_device_room room ON server.room_id=room.id " +
		" LEFT JOIN asset_cabinet cabinet ON server.cabinet_id=cabinet.id " +
		" LEFT JOIN asset_rack rack ON server.rack_id=rack.id " +
		" WHERE  " + strings.Join(where, " and ") + ") t1 WHERE 1=1 " + whereMaintStarus + " ORDER BY id DESC  "

	sqlStr = fmt.Sprintf(`(SELECT server.id,server.name,
    server.ip,
    server.run_status,
    server.assignment_status,
    server.service,
    region.region_code,
    region.region_name,
    az.az_code,
    az.az_name,
    lab.lab_code,
    lab.lab_name,
    room.room_code,
	room.id as room_id,
    room.room_name,
	cabinet.id as cabinet_id,
    cabinet.cabinet_name,
	server.rack_id,
    rack.rack_name,
    server.host_unit_number,
    server.sn,
    server.ip as management_ip,
    server.out_band_ip,
    server.out_band_user,
    server.power,
	server.label,
    server.uplink_switch,
    server.maintenance_due,
	case when server.maintenance_due BETWEEN 1 AND %d
        then 'insured'
		when server.maintenance_due  BETWEEN %d AND  %d
        then 'insured1m'
		when server.maintenance_due between %d and %d
        then 'insured3m'
        when server.maintenance_due > %d
        then 'uninsured'
        else 'N/A' end as maintenance_status,
    server.assets_number,
    server.input_method,
    server.description,
    server.create_time as create_time,
    server.cpu_allocation_ratio,
    server.ram_allocation_ratio,
    server.operate_system,
    server.cpu_total,
	server.resource_pool,
    server.resource_pool_type,
	server.node,
    server.node_type,
	server.kind,
    server.memory_total `, now.Unix(), now.Unix(), now.Unix()+86400*30, now.Unix()+86400*30, now.Unix()+86400*90, now.Unix()+86400*90) + sqlStr
	//count
	tx := dao.AssetDB.Raw("select count(1) from "+sqlStr, values...).Scan(&count)
	if tx.Error != nil {
		klog.Infoln(tx.Error)
	}
	if count <= 0 {
		return
	}
	if physicalHostListQuery.PageNo > 0 && physicalHostListQuery.PageSize > 0 {
		start := (physicalHostListQuery.PageNo - 1) * physicalHostListQuery.PageSize
		sqlStr += fmt.Sprintf(" LIMIT %d,%d", start, physicalHostListQuery.PageSize)
	}
	rows, err = dao.AssetDB.Raw("select * from "+sqlStr, values...).Rows()
	if err != nil {
		return
	}

	return

}

// 判断是否存在根据id
func CheckServerExist(uid int) (count int, err error) {
	err = dao.AssetDB.Raw("SELECT COUNT(1) from asset_physical_server where deleted=0").Where("id=?", uid).Scan(&count).Error
	return
}

func SelectServerByHostnameOrIp(name, ip string) (res server.PhysicalServer, err error) {
	err = dao.AssetDB.Where("name = ? or ip = ?", name, ip).Take(&res).Error
	return res, err
}

// 获取单条数据
func SelectServerInfo(name, sn string, id int) (server.PhysicalServer, error) {
	var where []string
	var values []interface{}
	now := time.Now()
	where = append(where, "server.deleted=?")
	values = append(values, dao.DELETED_N)
	if name != "" {
		where = append(where, "server.name = ?")
		values = append(values, name)
	}
	if sn != "" {
		where = append(where, "server.sn = ?")
		values = append(values, sn)
	}
	if id > 0 {
		where = append(where, "server.id = ?")
		values = append(values, id)
	}
	var hostEntity server.PhysicalServer
	sql := "FROM asset_physical_server server " +
		" LEFT JOIN asset_az az ON server.az_id=az.id" +
		" LEFT JOIN asset_region region ON server.region_id=region.id " +
		" LEFT JOIN asset_lab lab ON server.lab_id=lab.id " +
		" LEFT JOIN asset_device_room room ON server.room_id=room.id " +
		" LEFT JOIN asset_cabinet cabinet ON server.cabinet_id=cabinet.id " +
		" LEFT JOIN asset_rack rack ON server.rack_id=rack.id " +
		" WHERE " + strings.Join(where, " and ")
	sql = fmt.Sprintf(`SELECT server.id,server.name,
	
    server.ip,
    server.run_status,
    server.assignment_status,
    server.service,
	server.region_id,
	region.region_code,
    region.region_name,
    server.az_id,
	az.az_code,
	az.az_name,
    lab.lab_name,
    room.room_code,
    room.room_name,
    cabinet.cabinet_name,
	server.rack_id,
    rack.rack_name,
    server.host_unit_number,
    server.sn,
    server.server_type,
    server.ip as management_ip,
    server.out_band_ip,
    server.main_maintainer,
    server.power,
    server.uplink_switch,
	server.node,
    server.node_type,
    server.maintenance_due,
	case when server.maintenance_due BETWEEN 1 AND %d
        then 'insured'
		when server.maintenance_due  BETWEEN %d AND  %d
        then 'insured1m'
		when server.maintenance_due between %d and %d
        then 'insured3m'
        when server.maintenance_due > %d
        then 'uninsured'
        else 'N/A' end as maintenance_status,
    server.assets_number,
    server.input_method,
	server.input_time,
    server.system_sales,
    server.mac_address,
    server.description,
    server.label,
	server.cpu_allocation_ratio,
	server.ram_allocation_ratio,
	server.operate_system,
    server.create_time `, now.Unix(), now.Unix(), now.Unix()+86400*30, now.Unix()+86400*30, now.Unix()+86400*90, now.Unix()+86400*90) +
		sql
	ret := dao.AssetDB.Raw(sql, values...).First(&hostEntity)
	return hostEntity, ret.Error
}

type IpStruct struct {
	Id        int
	Ip        string
	OutBandIp string `json:"OutBandIP,omitempty" gorm:"column:out_band_ip"`
	Name      string
}

func QueryIpByIds(ids []int) (sis []IpStruct, err error) {
	ret := dao.AssetDB.Table("asset_physical_server").Where("id in ?", ids).Find(&sis)
	if ret.Error != gorm.ErrRecordNotFound {
		err = ret.Error
	}
	return
}

func QueryIpById(id int) (ip IpStruct, err error) {
	ret := dao.AssetDB.Table("asset_physical_server").Where("id = ?", id).Find(&ip)
	if ret.Error != gorm.ErrRecordNotFound {
		err = ret.Error
	}
	return
}

// 更新服务器用事务
func UpdateServerInfo(entityMap map[string]interface{}, tx *gorm.DB) error {
	if err := tx.Model(&server.PhysicalServer{}).Where("id", entityMap["id"]).Updates(entityMap).Error; err != nil {
		return err
	}
	return nil
}
func UpdateServer(entityMap map[string]interface{}) error {
	if err := dao.AssetDB.Model(&server.PhysicalServer{}).Where("id", entityMap["id"]).Updates(entityMap).Error; err != nil {
		return err
	}
	return nil
}

// 根据服务器所属存储资源池更新服务器的所属资源池以及资源池类型
func UpdateStorage(hosts server.PoolHostUpdate, sp map[string]interface{}) error {
	var where string
	var values []string

	if len(hosts.IpList) > 0 {
		where = "ip in (?)"
		values = hosts.IpList
	}
	if len(hosts.NameList) > 0 {
		where = "name in (?)"
		values = hosts.NameList
	}
	if where == "" || len(values) <= 0 {
		return errors.New("没有服务器列表")
	}
	err := dao.AssetDB.Model(&server.PhysicalServer{}).Where(where, values).Updates(sp).Error
	return err
}

// 插入单条数据
func InsertServerTransaction(entityMap map[string]interface{}, ip string) (id int64, err error) {
	// 根据ip获取数据
	physicalServer := server.PhysicalServer{}
	err = dao.AssetDB.Model(&server.PhysicalServer{}).
		Where("deleted = ? AND ip = ?", 0, ip).
		First(&physicalServer).Error

	if err == gorm.ErrRecordNotFound { // 新增
		return InsertServer(entityMap)
	}
	if physicalServer.Id > 0 { // 存在历史数据
		err = dao.AssetDB.Transaction(func(tx *gorm.DB) error {
			entityMap["out_band_ip"] = physicalServer.OutBandIP
			entityMap["out_band_user"] = physicalServer.OutBandUser
			entityMap["assets_number"] = physicalServer.Assetsnumber
			entityMap["description"] = physicalServer.Description
			entityMap["host_unit_number"] = physicalServer.HostUnitNumber
			entityMap["maintenance_due"] = physicalServer.MaintenanceDue
			entityMap["lab_id"] = physicalServer.LabId
			entityMap["room_id"] = physicalServer.RoomId
			entityMap["cabinet_id"] = physicalServer.CabinetId
			entityMap["rack_id"] = physicalServer.RackId
			entityMap["resource_pool_type"] = physicalServer.ResourcePoolType
			entityMap["resource_pool"] = physicalServer.ResourcePool
			entityMap["create_time"] = time.Now().Unix()
			result := tx.Model(&server.PhysicalServer{}).Create(entityMap)
			id = result.RowsAffected
			if result.Error != nil {
				return fmt.Errorf("新增服务器数据失败 %v", err)
			}
			if err = tx.Where("id = ?", physicalServer.Id).Delete(&server.PhysicalServer{}).Error; err != nil {
				return fmt.Errorf("删除服务器数据失败 %v", err)
			}
			return nil
		})
	}
	return id, err

}

// 插入单条数据
func InsertServer(entityMap map[string]interface{}) (int64, error) {
	entityMap["create_time"] = time.Now().Unix()
	klog.Infof("entityMap %#v", entityMap)
	result := dao.AssetDB.Model(&server.PhysicalServer{}).Create(entityMap)
	// .Select("Sn",
	// 	"Name",
	// 	"Ip",
	// 	"Label",
	// 	"RegionId",
	// 	"AzId",
	// 	"System",
	// 	"SystemSales",
	// 	"Runstatus",
	// 	"CpuTotal",
	// 	"MemoryTotal",
	// 	"InputTime",
	// 	"InputMethod",
	// 	"CpuAllocationRatio",
	// 	"RamAllocationRatio",
	// 	"MacAddress",
	// 	"AssignmentStatus",
	// 	"Service",
	// 	"ServerType")

	return result.RowsAffected, result.Error
}

// 根据Ips获取服务器列表
func GetPhysicalHostListByIps(ips []string, PageNo, PageSize int) (rows *sql.Rows, count int, err error) { //(server.PhysicalHostDataResult, error) {
	var where []string
	var values []interface{}
	where = append(where, "server.deleted=?")
	where = append(where, "server.is_vm = 0") //物理机
	values = append(values, dao.DELETED_N)

	if len(ips) > 0 {
		where = append(where, "server.ip in (?)")
		values = append(values, ips)
	}
	return GetServerListSql(where, values, PageNo, PageSize)

}

// 获取所有的hostList
func GetPhysicalHostListT(ips []string, PageNo, PageSize int) (rows *sql.Rows, count int, err error) { //(server.PhysicalHostDataResult, error) {
	var where []string
	var values []interface{}
	where = append(where, "server.deleted=?")
	values = append(values, dao.DELETED_N)

	if len(ips) > 0 {
		where = append(where, "server.ip in (?)")
		values = append(values, ips)
	}
	return GetServerListSql(where, values, PageNo, PageSize)

}
func GetServerListSql(where []string, values []interface{}, PageNo, PageSize int) (rows *sql.Rows, count int, err error) {
	now := time.Now()
	sql := "FROM asset_physical_server server " +
		" LEFT JOIN asset_az az ON server.az_id=az.id" +
		" LEFT JOIN asset_region region ON server.region_id=region.id " +
		" LEFT JOIN asset_lab lab ON server.lab_id=lab.id " +
		" LEFT JOIN asset_device_room room ON server.room_id=room.id " +
		" LEFT JOIN asset_cabinet cabinet ON server.cabinet_id=cabinet.id " +
		" LEFT JOIN asset_rack rack ON server.rack_id=rack.id " +
		" WHERE  " + strings.Join(where, " and ")

	//count
	dao.AssetDB.Debug().Raw("SELECT COUNT(1) "+sql, values...).Scan(&count)
	if count <= 0 {
		return
	}
	if PageNo > 0 {
		start := (PageNo - 1) * PageSize
		sql += fmt.Sprintf(" ORDER BY id DESC LIMIT %d,%d", start, PageSize)
	} else {
		sql += fmt.Sprintf(" ORDER BY id DESC ")
	}
	sql = fmt.Sprintf(`SELECT server.id,server.name,
    server.ip,
    server.run_status,
    server.assignment_status,
    server.service,
    region.region_code,
    region.region_name,
    az.az_code,
    az.az_name,
    lab.lab_code,
    lab.lab_name,
    room.room_code,
	room.id as room_id,
    room.room_name,
	cabinet.id as cabinet_id,
    cabinet.cabinet_name,
	server.rack_id,
    rack.rack_name,
    server.host_unit_number,
    server.sn,
    server.ip as management_ip,
    server.out_band_ip,
    server.power,
    server.uplink_switch,
    server.maintenance_due,
	case when server.maintenance_due BETWEEN 1 AND %d
        then 'insured'
		when server.maintenance_due  BETWEEN %d AND  %d
        then 'insured1m'
		when server.maintenance_due between %d and %d
        then 'insured3m'
		when server.maintenance_due > %d
        then 'uninsured'
        else 'N/A' end as maintenance_status,
    server.assets_number,
    server.input_method,
    server.description,
    server.create_time,
    server.cpu_allocation_ratio,
    server.ram_allocation_ratio,
    server.operate_system,
    server.cpu_total,
    server.memory_total `, now.Unix(), now.Unix(), now.Unix()+86400*30, now.Unix()+86400*30, now.Unix()+86400*90, now.Unix()+86400*90) +
		sql
	rows, err = dao.AssetDB.Debug().Raw(sql, values...).Rows()
	if err != nil {
		return
	}

	return
}
func GetAllHostList() (physicalServer []server.PhysicalHost, err error) {
	ret := dao.AssetDB.Table("asset_physical_server").Select("name,ip,'物理服务器' as server_type").Where("is_vm =?", 0).Scan(&physicalServer)
	if ret.Error != gorm.ErrRecordNotFound {
		err = ret.Error
	}
	return physicalServer, err
}

func AllServer() (physicalServer []server.PhysicalHost, err error) {
	err = dao.AssetDB.Table("asset_physical_server").Select("name,ip").
		Where("deleted=?", 0).
		Find(&physicalServer).Error
	return
}

func GetHostIdByHostName(hostname string) (int, error) {
	row := struct {
		Id int
	}{}
	err := dao.AssetDB.Table("asset_physical_server").
		Select("id").Where("name = ?", hostname).First(&row).Error
	if err == gorm.ErrRecordNotFound {
		return 0, nil
	}
	return row.Id, err
}

func GetServerNode(node []string) (nodeList []server.AssetPhysicalServerNode, err error) {
	err = dao.AssetDB.Table("asset_physical_server_node").
		Where("node IN (?)", node).
		Find(&nodeList).Error
	return
}

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/pkg/dao/server/serverModel.go
```golang
package server

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/pkg/dao/deviceroom/room.go
```golang
package deviceroom

import (
	"luban-cmdb-api/pkg/dao"
	deviceroommodel "luban-cmdb-api/pkg/models/deviceroom"
	"time"

	"gorm.io/gorm"
)

type DeviceRoom struct {
	Id         int
	RoomName   string `gorm:"column:room_name"`
	RoomCode   string
	RoomDesc   string
	AzId       int
	RegionId   int
	LabId      int
	Updater    string
	Creator    string
	CreateTime time.Time `gorm:"autoCreateTime"`
	UpdateTime time.Time `gorm:"autoUpdateTime"`
	Deleted    int16
}

func listQuery() (tx *gorm.DB) {
	return dao.AssetDB.Table("asset_device_room as dr").
		Joins("LEFT JOIN asset_az az ON dr.az_id=az.id").
		Joins("LEFT JOIN asset_region region ON dr.region_id=region.id").
		Joins("LEFT JOIN asset_lab lab ON dr.lab_id = lab.id").
		Select(drSelect)
}

//var listQuery = dao.AssetDB.Table("asset_device_room as dr").
//	Joins("LEFT JOIN asset_az az ON dr.az_id=az.id").
//	Joins("LEFT JOIN asset_region region ON dr.region_id=region.id").
//	Joins("LEFT JOIN asset_lab lab ON dr.lab_id = lab.id").
//	Select(drSelect)

var drSelect = "dr.id id,dr.room_name room_name, dr.room_code room_code, dr.lab_id lab_id," +
	"dr.create_time create_time,dr.update_time update_time, dr.creator creator," +
	"dr.room_desc room_desc, az.az_code az_code, az.az_name az_name, region.region_code region_code, " +
	"region.region_name region_name,lab.lab_code lab_code,lab.lab_name lab_name"

//根据azid/regionId等信息查询,分页
func PageQueryDeviceRoom(conditions map[string]interface{}, page int, pageSize int) (drs []deviceroommodel.RoomFullInfo2, count int, err error) {
	var mw = make(map[string]interface{})
	mw["dr.deleted"] = dao.DELETED_N
	likeSql := ""
	likeVal := ""
	for k, v := range conditions {
		field := "dr." + k
		//根据map key判断
		switch k {
		case "region_code":
			field = "region.region_code"
			mw[field] = v
		case "az_code":
			field = "az.az_code"
			mw[field] = v
		case "lab_code":
			field = "lab.lab_code"
			mw[field] = v
		case "lab_name":
			field = "lab.lab_name"
			mw[field] = v
		case "id":
			field = "dr.id"
			mw[field] = v

		//添加like
		case "room_name":
			likeSql = "dr.room_name like ?"
			likeVal = "%" + v.(string) + "%"
		case "room_code":
			likeSql = "dr.room_code like ?"
			likeVal = "%" + v.(string) + "%"
		}

	}
	query := listQuery().Session(&gorm.Session{}).Debug()

	if likeSql != "" && likeVal != "" {
		//count
		err = query.Where(mw).Where(likeSql, likeVal).Select("COUNT(1) as count").Scan(&count).Error
		if count <= 0 {
			return
		}
		start := (page - 1) * pageSize
		err = query.Select(drSelect).Where(mw).Where(likeSql, likeVal).
			Limit(pageSize).Offset(start).Order("dr.id DESC").Find(&drs).Error
		return
	} else {
		//count
		err = query.Where(mw).Select("COUNT(1) as count").Scan(&count).Error
		if count <= 0 {
			return
		}
		start := (page - 1) * pageSize
		err = query.Select(drSelect).Where(mw).
			Limit(pageSize).Offset(start).Order("dr.id DESC").Find(&drs).Error
		return
	}
}

//根据azid/regionId等信息查询
func QueryDeviceRoom(conditions map[string]interface{}) (drs []deviceroommodel.RoomFullInfo2, err error) {
	var mw = make(map[string]interface{})
	mw["dr.deleted"] = dao.DELETED_N
	for k, v := range conditions {
		field := "dr." + k
		//根据map key判断
		switch k {
		case "region_code":
			field = "region.region_code"
		case "az_code":
			field = "az.az_code"
		case "lab_code":
			field = "lab.lab_code"
		case "lab_name":
			field = "lab.lab_name"
		}
		mw[field] = v
	}
	err = listQuery().Session(&gorm.Session{}).Where(mw).Order("id DESC").Find(&drs).Error
	return
}

//查询一条
func GetDeviceRoom(id int) (deviceroommodel.RoomFullInfo2, error) {
	dr := deviceroommodel.RoomFullInfo2{}
	ret := dao.AssetDB.Model(DeviceRoom{}).Select("*").Where("id=? AND deleted = ?", id, dao.DELETED_N).First(&dr)
	if ret.Error != gorm.ErrRecordNotFound {
		return dr, ret.Error
	}
	return dr, nil
} //查询一条
func GetDeviceRoomByName(name string) (deviceroommodel.RoomFullInfo2, error) {
	dr := deviceroommodel.RoomFullInfo2{}
	ret := dao.AssetDB.Model(DeviceRoom{}).Select("*").Where("room_name=? AND deleted = ?", name, dao.DELETED_N).First(&dr)
	if ret.Error != gorm.ErrRecordNotFound {
		return dr, ret.Error
	}
	return dr, nil
}

func GetDeviceRoomByCode(code string) (DeviceRoom, error) {
	dr := DeviceRoom{}
	ret := dao.AssetDB.Where("room_code=? AND deleted = ?", code, dao.DELETED_N).First(&dr)
	if ret.Error != gorm.ErrRecordNotFound {
		return dr, ret.Error
	}
	return dr, nil
}

func GetByCodeOrName(code string, name string) (DeviceRoom, error) {
	dr := DeviceRoom{}
	ret := dao.AssetDB.Where("(room_code=? OR room_name=?) AND deleted = ?", code, name, dao.DELETED_N).First(&dr)
	if ret.Error != gorm.ErrRecordNotFound {
		return dr, ret.Error
	}
	return dr, nil
}

//根据ids查询房间
func GetDeviceRoomListByIds(ids []int) ([]DeviceRoom, error) {
	dr := []DeviceRoom{}
	ret := dao.AssetDB.Where("id in ? AND deleted=?", ids, dao.DELETED_N).Find(&dr)
	if ret.Error != gorm.ErrRecordNotFound {
		return dr, ret.Error
	}
	return dr, nil
}

//获取到某lab下的房间数量
func CountByLab(labIds []int) (map[int]int, error) {
	var m = make(map[int]int)
	var ls []struct {
		Count int `gorm:"column:count"`
		LabId int `gorm:"column:lab_id"`
	}
	err := dao.AssetDB.Model(DeviceRoom{}).Select("count(*) as count, lab_id").
		Where("lab_id in ? and deleted = ?", labIds, dao.DELETED_N).
		Group("lab_id").
		Find(&ls).Error
	for _, v := range ls {
		m[v.LabId] = v.Count
	}
	return m, err
}

func AddDeviceRoom(dr DeviceRoom) (int, error) {
	err := dao.AssetDB.Create(&dr).Error
	return dr.Id, err
}

func UpdateRoom(dr DeviceRoom) error {
	return dao.AssetDB.Model(&DeviceRoom{}).Where(DeviceRoom{Id: dr.Id}).Updates(dr).Error
}

//fake delete
func DelDeviceRoom(ids []int, updater string) error {
	dr := DeviceRoom{
		Updater: updater,
		Deleted: dao.DELETED_Y,
	}
	return dao.AssetDB.Where("id in ?", ids).Updates(dr).Error
}

//根据labCode list 获取房间
func GetRoomsByLabCodes(labCodes []string) (rooms []deviceroommodel.BasicRoom, err error) {

	err = dao.AssetDB.Model(DeviceRoom{}).Select("id as room_uid, room_name").
		Joins("left join asset_lab on asset_device_room.lab_id = asset_lab.id").
		Where("asset_lab.lab_code in ? and asset_lab.deleted = ?", labCodes, dao.DELETED_N).
		Find(&rooms).Error
	return
}

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/pkg/dao/businessManagement/noderef.go
```golang
package businessManagementDao

import (
	"fmt"
	"luban-cmdb-api/pkg/dao"
	"luban-cmdb-api/pkg/models/businessManagement"

	"gorm.io/gorm"
)

func queryNodeRefCountByRealNodeId(realNodeId int) (count int64) {
	dao.AssetDB.Model(&businessManagement.NodeRef{}).Where("real_node_id = ?", realNodeId).Count(&count)
	return count
}

// 根节点ROOT没有实际节点对应，他的parentId等于负的treeId
func makeRootNodeRef(treeId int, tx *gorm.DB) error {
	return tx.Create(&businessManagement.NodeRef{
		TreeId:   treeId,
		ParentId: -treeId,
	}).Error
}

// 挂载节点用
func CreateNodeRef(nodeRef businessManagement.NodeRef) error {
	nodeDetail, err := QueryNodeDetail(nodeRef.RealNodeId)
	if err != nil {
		return fmt.Errorf("create node ref err(Node Detail): err:%v", err)
	}
	treeDetail, err := QueryTreeDetail(nodeRef.TreeId)
	if err != nil {
		return fmt.Errorf("create node ref err(Tree Detail): err:%v", err)
	}
	if nodeDetail.RegionCode != treeDetail.RegionCode {
		return fmt.Errorf("挂载失败: 节点与业务树不在同一个区域")
	}
	if queryNodeRefIdCount(nodeRef.ParentId) <= 0 {
		return fmt.Errorf("create node ref err: fatherNodeRef not found")
	}
	return dao.AssetDB.Create(&nodeRef).Error
}

func queryNodeRefIdCount(refId int) (count int64) {
	dao.AssetDB.Model(&businessManagement.NodeRef{}).Where("ref_id = ?", refId).Count(&count)
	return count
}

func QueryNodeRefByTreeId(treeId int) (nodeRefs []businessManagement.NodeRef, err error) {
	err = dao.AssetDB.Where("tree_id = ?", treeId).Find(&nodeRefs).Error
	return nodeRefs, err
}

func QueryNodeRefByNodeId(realNodeId int) (nodeRefs []businessManagement.NodeRef, err error) {
	err = dao.AssetDB.Where("real_node_id = ?", realNodeId).Find(&nodeRefs).Error
	return nodeRefs, err
}

func DeleteNodeRef(refId int) error {
	return dao.AssetDB.Transaction(func(tx *gorm.DB) error {
		return deleteNodeRefStep(refId, tx)
	})
}

func queryChildNodeRefByRefId(refId int, tx *gorm.DB) (nodeRefs []businessManagement.NodeRef) {
	tx.Where("parent_id = ?", refId).Find(&nodeRefs)
	return nodeRefs
}

func deleteNodeRefStep(refId int, tx *gorm.DB) error {
	children := queryChildNodeRefByRefId(refId, tx)
	err := tx.Where("ref_id = ?", refId).Delete(&businessManagement.NodeRef{}).Error
	if err != nil {
		return err
	}
	for i := 0; i < len(children); i++ {
		ret := deleteNodeRefStep(children[i].RefId, tx)
		if ret != nil {
			return ret
		}
	}
	return err
}

func QueryRouteByRefId(refId int) (res string) {
	// 根据refId找到对应的nodref
	this := queryNodeRefByRefId(refId)
	if this.ParentId < 0 {
		return ""
	}
	// 根据this的realNodeId找到对应的node
	node, _ := QueryNodeDetail(this.RealNodeId)
	// 拼接 所有父节点的名称和子节点的名称使用"/"做拼接
	return QueryRouteByRefId(this.ParentId) + "/" + node.Name
}

func QueryRouteAndTreeIdByRefId(refId int) (res string, treeId int) {
	this := queryNodeRefByRefId(refId)
	if this.ParentId < 0 {
		return "", -this.ParentId
	}
	node, _ := QueryNodeDetail(this.RealNodeId)
	res, treeId = QueryRouteAndTreeIdByRefId(this.ParentId)
	return res + "/" + node.Name, treeId
}

func queryNodeRefByRefId(refId int) (nodeRef businessManagement.NodeRef) {
	dao.AssetDB.Where("ref_id = ?", refId).Find(&nodeRef)
	return nodeRef
}

func QueryNodeRefIdsByServiceIds(svcIds []int) (nodeRefIds []int, err error) {
	ret := dao.AssetDB.Raw("SELECT DISTINCT ref_id from asset_business_management_node_services LEFT JOIN asset_business_management_node_ref ON asset_business_management_node_services.node_id = asset_business_management_node_ref.real_node_id where service_id IN ?", svcIds).
		Scan(&nodeRefIds)
	return nodeRefIds, ret.Error
}

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/pkg/dao/businessManagement/service.go
```golang
package businessManagementDao

import (
	"fmt"
	"luban-cmdb-api/pkg/dao"
	"luban-cmdb-api/pkg/models/businessManagement"
)

func QueryServiceDetail(id int) (svc businessManagement.Service, err error) {
	res := dao.AssetDB.
		Where("id = ?", id).
		First(&svc)
	return svc, res.Error
}

func CreateService(svc *businessManagement.Service) error {
	// 首先校验同一个region下有没有相同的name
	count := queryServiceCountByRegionCodeAndName(svc.Name, svc.RegionCode)
	if count != 0 {
		return fmt.Errorf("创建服务失败: 同一区域下有相同服务名")
	}
	res := dao.AssetDB.Select("name", "region_code", "built_in", "creator", "updater").Create(&svc)
	return res.Error
}

func queryServiceCountByRegionCodeAndName(name string, regionCode string) (count int64) {
	dao.AssetDB.Model(&businessManagement.Service{}).
		Where("name = ? AND region_code = ?", name, regionCode).
		Count(&count)
	return
}

func QueryServiceList(regionCode, searchName string, builtIn int8, pageSize, pageNo int, sortField, sortType string) (services []businessManagement.Service, total int64, err error) {
	res := dao.AssetDB.
		Model(&businessManagement.Service{})
	if regionCode != "" {
		res.Where("region_code = ?", regionCode)
	}
	if searchName != "" {
		res.Where("name LIKE ?", fmt.Sprintf("%%%s%%", searchName))
	}
	if builtIn != -1 {
		res.Where("built_in = ?", builtIn)
	}
	res = res.Count(&total).
		Limit(pageSize).Offset((pageNo - 1) * pageSize)
	if sortField == "" {
		res = res.Order("built_in desc, create_time desc")
	} else {
		res = res.Order(fmt.Sprintf("built_in desc, %s %s", sortField, sortType))
	}
	res.Find(&services)
	return services, total, res.Error
}

func QueryServicesByIds(ids []int) (services []businessManagement.Service, err error) {
	ret := dao.AssetDB.Where("id IN ?", ids).Find(&services)
	return services, ret.Error
}

func UpdateService(svc businessManagement.Service) error {
	res := dao.AssetDB.
		Select("name", "updater").Updates(svc)
	return res.Error
}

func DeleteService(id int) error {
	svciCount := queryServiceInstanceCount(id)
	if svciCount != 0 {
		return fmt.Errorf("服务删除失败: 服务下存在服务实例，不允许删除")
	}
	nodeCount := queryNodeCountByServiceId(id)
	if nodeCount != 0 {
		return fmt.Errorf("服务删除失败: 服务已被节点绑定，不允许删除")
	}
	return dao.AssetDB.Delete(&businessManagement.Service{}, id).Error
}

func queryNodeCountByServiceId(serviceId int) int64 {
	count := int64(0)
	dao.AssetDB.Model(&businessManagement.NodeServices{}).Where("service_id", serviceId).Count(&count)
	return count
}

func QueryServiceByNameGroup(names []string) (svcs []businessManagement.Service, err error) {
	ret := dao.AssetDB.Where("name IN ?", names).Find(&svcs)
	return svcs, ret.Error
}

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/pkg/dao/businessManagement/tree.go
```golang
package businessManagementDao

import (
	"fmt"
	"luban-cmdb-api/pkg/dao"
	"luban-cmdb-api/pkg/models/businessManagement"

	"k8s.io/klog/v2"

	"gorm.io/gorm"
)

func CreateTree(tree businessManagement.Tree) error {
	// 同一region下相同名称不被允许
	count := queryTreeCountByName(tree.Name)
	if count > 0 {
		return fmt.Errorf("业务树创建失败：同一区域下有相同业务树名称")
	}
	return dao.AssetDB.Transaction(func(tx *gorm.DB) error {
		if err := tx.Select("name", "status", "region_code", "built_in", "creator", "updater").
			Create(&tree).Error; err != nil {
			klog.Error(err)
			return err
		}
		if err := makeRootNodeRef(tree.Id, tx); err != nil {
			klog.Error(err)
			return err
		}
		return nil
	})
}

func queryTreeCountByName(name string) (count int64) {
	dao.AssetDB.Model(&businessManagement.Tree{}).Where("name = ?", name).Count(&count)
	return count
}

func QueryTreeDetail(id int) (tree businessManagement.Tree, err error) {
	res := dao.AssetDB.Where("id = ?", id).
		First(&tree)
	return tree, res.Error
}

// 如果regionId = -1 相当于all status = -1 相当于all
func QueryTreeList(regionCode string, status []int, pageSize, pageNo int, sortField, sortType string) (trees []businessManagement.Tree, count int64, err error) {
	res := dao.AssetDB.Model(&businessManagement.Tree{})
	if regionCode != "" {
		res.Where("region_code = ?", regionCode)
	}
	if len(status) != 0 {
		res.Where("status IN ?", status)
	}
	res = res.Count(&count).
		Limit(pageSize).Offset((pageNo - 1) * pageSize)
	if sortField == "" {
		res = res.Order(fmt.Sprintf("built_in desc, create_time desc"))
	} else {
		res = res.Order(fmt.Sprintf("built_in desc, %s %s", sortField, sortType))
	}
	res.Find(&trees)
	return trees, count, res.Error
}

func UpdateTree(tree businessManagement.Tree) error {
	return dao.AssetDB.Select("name", "status", "updater").Updates(tree).Error
}

func DeleteTree(id int) error {
	detail, err := QueryTreeDetail(id)
	if err != nil {
		return fmt.Errorf("delete tree (got detail err) err: %v", err)
	}
	if detail.Status != businessManagement.TREE_STATUS_DONE {
		return fmt.Errorf("业务树删除失败：只有停运状态的树可以删除")
	}
	return dao.AssetDB.Transaction(func(tx *gorm.DB) error {
		if err := tx.Delete(&businessManagement.Tree{}, id).Error; err != nil {
			return fmt.Errorf("delete tree err: %v", err)
		}
		if err := tx.Where("tree_id = ?", id).Delete(&businessManagement.NodeRef{}).Error; err != nil {
			return fmt.Errorf("delete tree err: %v", err)
		}
		return nil
	})
}

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/pkg/dao/businessManagement/serviceinstance.go
```golang
package businessManagementDao

import (
	"fmt"
	"luban-cmdb-api/pkg/dao"
	"luban-cmdb-api/pkg/models/businessManagement"
	"luban-cmdb-api/pkg/utils/collection"

	"gorm.io/gorm"
)

func CreateServiceInstance(instance *businessManagement.ServiceInstance) error {
	serviceDetail, err := QueryServiceDetail(instance.ServiceId)
	if err != nil {
		return fmt.Errorf("serviceinstance create failed: service [id = %d] query got err: %v", instance.ServiceId, err)
	}
	if serviceDetail.RegionCode != instance.RegionCode {
		return fmt.Errorf("服务实例创建失败: 所选服务与该服务实例不在同一可用区")
	}
	return dao.AssetDB.Transaction(func(tx *gorm.DB) error {
		if err := tx.Select("name", "service_id",
			"region_code", "az_code", "host_id", "vm_id", "host_type", "creator", "updater").Create(instance).Error; err != nil {
			return err
		}
		// 创建进程列表
		if len(instance.ServiceProcess) == 0 {
			return nil
		}
		for i := 0; i < len(instance.ServiceProcess); i++ {
			instance.ServiceProcess[i].SvcInstanceId = instance.Id
		}
		if err = createServiceProcess(instance.ServiceProcess, tx); err != nil {
			return err
		}
		return nil
	})
}

func queryServiceInstanceCount(svcId int) (count int64) {
	dao.AssetDB.Model(&businessManagement.ServiceInstance{}).Where("service_id", svcId).Count(&count)
	return count
}

func QueryServiceInstancesByHostId(hostId int) (svci []businessManagement.ServiceInstance, err error) {
	ret := dao.AssetDB.Where("host_id = ?", hostId).Find(&svci)
	for i := 0; i < len(svci); i++ {
		svci[i].ServiceProcess = queryServiceProcess(svci[i].Id)
	}
	return svci, ret.Error
}

func QueryServiceInstances(regionCode string, azCodes []string, searchName string, searchSvcIds []int, pageSize, pageNo int, sortField, sortType string, hostId int) (svci []businessManagement.ServiceInstance, total int64, err error) {
	res := dao.AssetDB.
		Model(&businessManagement.ServiceInstance{})
	if regionCode != "" {
		res.Where("region_code = ?", regionCode)
	}
	if len(azCodes) != 0 {
		res.Where("az_code IN ?", azCodes)
	}
	if searchName != "" {
		res.Where("name LIKE ?", fmt.Sprintf("%%%s%%", searchName))
	}
	if len(searchSvcIds) != 0 {
		res.Where("service_id IN ?", searchSvcIds)
	}
	if hostId != 0 {
		res.Where("host_id = ?", hostId)
	}
	res = res.Count(&total) //.

	//pageSize=-1支持全量查询
	if pageSize != -1 {
		res.Limit(pageSize).Offset((pageNo - 1) * pageSize)

	}

	if sortField == "" {
		res = res.Order("built_in desc ,create_time desc")
	} else {
		res = res.Order(fmt.Sprintf("%s %s", sortField, sortType))
	}
	res.Find(&svci)

	// 塞入进程信息
	svcIdsSet := collection.NewSet()
	for i := 0; i < len(svci); i++ {
		//内置服务为POD,无进程信息
		if svci[i].BuiltIn == businessManagement.BUILT_IN_YES {
			continue
		}
		svcIdsSet.Add(svci[i].Id)
		//svci[i].ServiceProcess = queryServiceProcess(svci[i].Id)
	}

	spList := queryServiceProcessInIds(svcIdsSet.KeysInt())
	for i := 0; i < len(svci); i++ {
		for j := 0; j < len(spList); j++ {
			if svci[i].Id == spList[j].SvcInstanceId {
				svci[i].ServiceProcess = append(svci[i].ServiceProcess, spList[j])
			}
		}
	}

	return svci, total, res.Error
}

func QueryServiceInstanceDetail(id int) (svci businessManagement.ServiceInstance, err error) {
	res := dao.AssetDB.Where("id = ?", id).
		First(&svci)
	svci.ServiceProcess = queryServiceProcess(svci.Id)
	return svci, res.Error
}

func DeleteServiceInstances(ids []int) error {
	return dao.AssetDB.Transaction(func(tx *gorm.DB) error {
		err := tx.Where("id in ?", ids).Delete(&businessManagement.ServiceInstance{}).Error
		if err != nil {
			return err
		}
		err = deleteServiceProcessByServiceInstanceIds(ids, tx)
		if err != nil {
			return err
		}
		return nil
	})
}

func UpdateServiceInstance(scvi businessManagement.ServiceInstance) error {
	serviceDetail, err := QueryServiceDetail(scvi.ServiceId)
	if err != nil {
		return fmt.Errorf("serviceinstance update failed: service [id = %d] query got err: %v", scvi.ServiceId, err)
	}
	if serviceDetail.RegionCode != scvi.RegionCode {
		return fmt.Errorf("服务实例更新失败: 所选服务与服务实例不在同一区域")
	}
	return dao.AssetDB.Transaction(func(tx *gorm.DB) error {
		if err := tx.Select("name", "service_id", "host_id", "region_code", "az_code", "host_type", "vm_id", "updater").Updates(scvi).Error; err != nil {
			return err
		}
		var createProcess, updateProcess, deleteProcess []businessManagement.ServiceProcess
		dataBaseProcesses := queryServiceProcess(scvi.Id)
		deleteCounter := make(map[int]*businessManagement.ServiceProcess)
		for i := 0; i < len(dataBaseProcesses); i++ {
			deleteCounter[dataBaseProcesses[i].Id] = &dataBaseProcesses[i]
		}
		for i := 0; i < len(scvi.ServiceProcess); i++ {
			if scvi.ServiceProcess[i].Id == 0 {
				createProcess = append(createProcess, scvi.ServiceProcess[i])
			} else {
				v, ok := deleteCounter[scvi.ServiceProcess[i].Id]
				if ok {
					delete(deleteCounter, scvi.ServiceProcess[i].Id)
					if !v.Equals(&scvi.ServiceProcess[i]) {
						updateProcess = append(updateProcess, scvi.ServiceProcess[i])
					}
				}
			}
		}

		for _, v := range deleteCounter {
			deleteProcess = append(deleteProcess, *v)
		}

		if len(deleteProcess) != 0 {
			if err := deleteServiceProcess(deleteProcess, tx); err != nil {
				return err
			}
		}

		if len(updateProcess) != 0 {
			if err := updateServiceProcess(updateProcess, tx); err != nil {
				return err
			}
		}

		if len(createProcess) != 0 {
			for i := 0; i < len(createProcess); i++ {
				createProcess[i].SvcInstanceId = scvi.Id
			}
			if err := createServiceProcess(createProcess, tx); err != nil {
				return err
			}
		}
		return nil
	})
}

func QueryServiceInstancesByIds(ids []int) (svcis []businessManagement.ServiceInstance, err error) {
	ret := dao.AssetDB.Where("id IN ?", ids).Find(&svcis)
	return svcis, ret.Error
}

func QueryServiceInstanceBySn(sn string) (svcis []businessManagement.ServiceInstance, err error) {
	ret := dao.AssetDB.Raw("SELECT i.id, i.service_id FROM asset_business_management_service_instance i LEFT JOIN asset_physical_server s ON i.host_id = s.id WHERE s.sn = ?", sn).Scan(&svcis)
	return svcis, ret.Error
}

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/pkg/dao/businessManagement/serviceprocess.go
```golang
package businessManagementDao

import (
	"luban-cmdb-api/pkg/dao"
	"luban-cmdb-api/pkg/models/businessManagement"
	"time"

	"gorm.io/gorm"
)

func queryServiceProcess(scviId int) (res []businessManagement.ServiceProcess) {
	dao.AssetDB.Where("svc_instance_id = ?", scviId).Find(&res)
	return res
}

func queryServiceProcessInIds(scviIds []int) (res []businessManagement.ServiceProcess) {
	dao.AssetDB.Where("svc_instance_id IN ?", scviIds).Find(&res)
	return res
}

func createServiceProcess(sp []businessManagement.ServiceProcess, tx *gorm.DB) error {
	return tx.Select("name", "cmd", "port", "protocol", "svc_instance_id", "creator", "updater").Create(&sp).Error
}

func deleteServiceProcessByServiceInstanceIds(serviceInstanceIds []int, tx *gorm.DB) error {
	return tx.Where("svc_instance_id in ?", serviceInstanceIds).Delete(&businessManagement.ServiceProcess{}).Error
}

func deleteServiceProcess(sp []businessManagement.ServiceProcess, tx *gorm.DB) error {
	return tx.Delete(&sp).Error
}

func updateServiceProcess(sp []businessManagement.ServiceProcess, tx *gorm.DB) error {
	for i := 0; i < len(sp); i++ {
		err := tx.Select("name", "cmd", "port", "protocol", "updater").Updates(&sp[i]).Error
		if err != nil {
			return err
		}
	}
	return nil
}

func QueryRemoteProcessByTime(t time.Time) (sps []businessManagement.ServiceProcess, err error) {
	where := "(create_time >= ? OR update_time >= ?) AND port != ''"
	err = dao.AssetDB.Model(&businessManagement.ServiceProcess{}).Where(where, t, t).
		Find(&sps).Error
	return
}

// 所有远端进程
func RemoteProcessList() (sps []businessManagement.ServiceProcess, err error) {
	where := "port != ''"
	err = dao.AssetDB.Model(&businessManagement.ServiceProcess{}).Where(where).
		Find(&sps).Error
	return
}

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/pkg/dao/businessManagement/node.go
```golang
package businessManagementDao

import (
	"fmt"
	"gorm.io/gorm"
	"luban-cmdb-api/pkg/dao"
	"luban-cmdb-api/pkg/models/businessManagement"
)

func CreateNode(node businessManagement.Node) error {
	count := queryNodeCountByRegionAndName(node.RegionCode, node.Name)
	if count > 0 {
		return fmt.Errorf("节点创建失败：同一区域下有相同节点名")
	}
	return dao.AssetDB.Transaction(func(tx *gorm.DB) error {
		if err := tx.Select("name", "region_code", "built_in", "creator", "updater").Create(&node).Error; err != nil {
			return fmt.Errorf("create node failed; err: %v", err)
		}
		// 检查service的存在并建立中间关系 注意这里的查询要走同一个事务
		for i := 0; i < len(node.Services); i++ {
			if err := tx.Where("id = ?", node.Services[i].Id).First(&node.Services[i]).Error; err != nil {
				if err == gorm.ErrRecordNotFound {
					return fmt.Errorf("节点创建失败; 服务 id = [%d] 不存在", node.Services[i].Id)
				}
				return fmt.Errorf("create node failed; err: %v", err)
			}
			if node.Services[i].RegionCode != node.RegionCode {
				return fmt.Errorf("节点创建失败：节点与服务不在同一区域")
			}
			if err := tx.Create(&businessManagement.NodeServices{
				NodeId:    node.Id,
				ServiceId: node.Services[i].Id,
			}).Error; err != nil {
				return fmt.Errorf("create node failed; node_services failed err: %v", err)
			}
		}
		return nil
	})
}

func queryNodeCountByRegionAndName(regionCode, name string) (count int64) {
	dao.AssetDB.Model(&businessManagement.Node{}).
		Where("name = ? AND region_code = ?", name, regionCode).Count(&count)
	return count
}

func QueryNodeDetail(id int) (node businessManagement.Node, err error) {
	res := dao.AssetDB.
		Where("id = ?", id).
		First(&node)
	if res.Error != nil {
		return node, res.Error
	}
	svcs, err := queryServiceListByNodeId(id)
	if err != nil {
		return node, err
	}
	node.Services = svcs
	node.ServiceCount = len(svcs)
	return node, res.Error
}

func queryServiceListByNodeId(nodeId int) (svcs []businessManagement.Service, err error) {
	err = dao.AssetDB.Model(&businessManagement.Service{}).
		Joins("right join asset_business_management_node_services on asset_business_management_node_services.service_id = asset_business_management_service.id").
		Where("asset_business_management_node_services.node_id = ?", nodeId).Find(&svcs).Error
	return svcs, err
}

func QueryNodeList(regionCode string, pageSize, pageNo int, sortField, sortType string) (nodes []businessManagement.Node, count int64, err error) {
	res := dao.AssetDB.Model(&businessManagement.Node{})
	if regionCode != "" {
		res.Where("region_code = ?", regionCode)
	}
	res = res.Count(&count).
		Limit(pageSize).Offset((pageNo - 1) * pageSize)

	if sortField == "" {
		res = res.Order("built_in desc, create_time desc")
	} else {
		res = res.Order(fmt.Sprintf("built_in desc, %s %s", sortField, sortType))
	}
	res.Find(&nodes)
	for i := 0; i < len(nodes); i++ {
		svcs, err := queryServiceListByNodeId(nodes[i].Id)
		if err != nil {
			return nodes, count, err
		}
		nodes[i].Services = svcs
		nodes[i].ServiceCount = len(svcs)
	}
	return nodes, count, res.Error
}

func DeleteNode(id int) error {
	count := queryNodeRefCountByRealNodeId(id)
	if count != 0 {
		return fmt.Errorf("节点删除失败: 现有业务树挂载了该节点")
	}
	return dao.AssetDB.Transaction(func(tx *gorm.DB) error {
		if err := tx.Delete(&businessManagement.Node{}, id).Error; err != nil {
			return fmt.Errorf("node delete failed, err:%v", err)
		}
		if err := tx.Where("node_id = ?", id).Delete(&businessManagement.NodeServices{}).Error; err != nil {
			return fmt.Errorf("node delete failed, err:%v", err)
		}
		return nil
	})
}

func UpdateNode(node businessManagement.Node) (err error) {
	if err := dao.AssetDB.Select("region_code").Where("id = ?", node.Id).First(&node).Error; err != nil {
		return fmt.Errorf("节点更新失败：节点不存在")
	}
	return dao.AssetDB.Transaction(func(tx *gorm.DB) error {
		if err := tx.Select("name", "updater").Updates(&node).Error; err != nil {
			return fmt.Errorf("update node failed; err: %v", err)
		}
		// 先查询现在节点下所有的服务
		svcs, err := queryServiceListByNodeId(node.Id)
		if err != nil {
			return fmt.Errorf("update node failed; err: %v", err)
		}

		// 新增关联
		addCounter := make(map[int]int)
		for i := 0; i < len(node.Services); i++ {
			addCounter[node.Services[i].Id] = node.Services[i].Id
		}
		for i := 0; i < len(svcs); i++ {
			delete(addCounter, svcs[i].Id)
		}
		for k, _ := range addCounter {
			service := businessManagement.Service{}
			if err := tx.Where("id = ?", k).First(&service).Error; err != nil {
				if err == gorm.ErrRecordNotFound {
					return fmt.Errorf("节点更新失败; 服务 id = [%d] 不存在", k)
				}
				return fmt.Errorf("update node failed; err: %v", err)
			}
			fmt.Println(service.RegionCode, node.RegionCode)
			if service.RegionCode != node.RegionCode {
				return fmt.Errorf("节点更新失败; 节点与服务不在同一个区域")
			}
			if err := tx.Create(&businessManagement.NodeServices{
				NodeId:    node.Id,
				ServiceId: k,
			}).Error; err != nil {
				return fmt.Errorf("update; add node_services failed err: %v", err)
			}
		}
		// 删除关联
		deleteCounter := make(map[int]int)
		for i := 0; i < len(svcs); i++ {
			deleteCounter[svcs[i].Id] = svcs[i].Id
		}
		for i := 0; i < len(node.Services); i++ {
			delete(deleteCounter, node.Services[i].Id)
		}
		for k, _ := range deleteCounter {
			if err := tx.Where("node_id = ? AND service_id = ?", node.Id, k).Delete(&businessManagement.NodeServices{}).Error; err != nil {
				return fmt.Errorf("update node failed; delete node_services failed err: %v", err)
			}
		}
		return nil
	})
}

func queryNodeByNodeRefId(refId int) (node businessManagement.Node) {
	dao.AssetDB.Table("asset_business_management_node_ref").
		Joins("left join asset_business_management_node on asset_business_management_node_ref.real_node_id = asset_business_management_node.id").
		Where("asset_business_management_node_ref.ref_id = ?", refId).Scan(&node)
	return node
}

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/pkg/runtime/runtime.go
```golang
package runtime

import "github.com/emicklei/go-restful"

const APIRoot = "/cmdb/v1/instance"

func NewWebService(apiGroup string) *restful.WebService {
	ws := &restful.WebService{}
	ws.Path(APIRoot + "/" + apiGroup).
		Consumes(restful.MIME_JSON).
		Produces(restful.MIME_JSON)
	return ws
}

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/pkg/sqlloader/env.go
```golang
package sqlloader

import (
	"gorm.io/gorm"
	"io"
)

type loaderEnv struct {
	dbClient *gorm.DB    // DB
	r        []io.Reader // 执行语句，支持多行
}

func NewLoaderEnv(db *gorm.DB, r ...io.Reader) *loaderEnv {
	return &loaderEnv{
		dbClient: db,
		r:        r,
	}
}

type ExecSqlLog struct {
	Id         int    `json:"id" gorm:"primaryKey"`
	MD5        string `json:"md5" gorm:"column:md5"`
	Sql        string `json:"sql"`
	ActionTime int64  `json:"action_time" gorm:"autoCreateTime"`
}

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/pkg/sqlloader/action.go
```golang
package sqlloader

import (
	"crypto/md5"
	"encoding/hex"
	"errors"
	"fmt"
	"log"
)

func (e *loaderEnv) Do() error {
	if len(e.r) == 0 {
		return errors.New("sql io.reader nil")
	}
	if e.dbClient == nil {
		return errors.New("gorm client nil")
	}
	if err := e.init(); err != nil {
		return fmt.Errorf("table ExecSqlLog create err: %v", err)
	}
	var sqls []string
	for i := 0; i < len(e.r); i++ {
		s, err := lineSqls(e.r[i])
		if err != nil {
			return fmt.Errorf("sql read err: %v", err)
		}
		sqls = append(sqls, s...)
	}
	logs := make([]ExecSqlLog, 0, len(sqls))
	md5s := make([]string, 0, len(sqls))
	for _, sql := range sqls {
		md5 := MD5(sql)
		logs = append(logs, ExecSqlLog{
			Sql: sql,
			MD5: md5,
		})
		md5s = append(md5s, md5)
	}
	databaseLogs := make([]ExecSqlLog, 0)
	if err := e.dbClient.Where("md5 IN ?", md5s).Find(&databaseLogs).Error; err != nil {
		return fmt.Errorf("database ExecSqlLog query err: %v", err)
	}
	exist := make(map[string]bool)
	for i := 0; i < len(databaseLogs); i++ {
		exist[databaseLogs[i].MD5] = true
	}
	tx := e.dbClient.Begin()
	log.Printf("got %d sql", len(sqls))
	sum := 0
	for i := 0; i < len(logs); i++ {
		if _, ok := exist[logs[i].MD5]; !ok {
			// 不存在就是没执行过的语句
			if err := tx.Exec(logs[i].Sql).Error; err != nil {
				//tx.Rollback()
				//// 一条语句执行出错，全部归滚，交给使用者处理出错sql
				//return fmt.Errorf("sql exec err: %v, sql: %s, md5: %s", err, logs[i].Sql, logs[i].MD5)
				fmt.Printf("sql exec err: %v, sql: %s, md5: %s", err, logs[i].Sql, logs[i].MD5)
				continue
			}
			tx.Create(&logs[i])
			sum++
		}
	}
	tx.Commit()
	log.Printf("exec %d sql", sum)
	return nil
}

func (e *loaderEnv) init() error {
	return e.dbClient.AutoMigrate(&ExecSqlLog{})
}

func MD5(src string) string {
	m := md5.New()
	m.Write([]byte(src))
	res := hex.EncodeToString(m.Sum(nil))
	return res
}

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/pkg/sqlloader/parse.go
```golang
package sqlloader

import (
	"bufio"
	"io"
	"strings"
)

var spiltPrefix = map[string]bool{
	"SELECT ": true,
	"INSERT ": true,
	"DELETE ": true,
	"UPDATE ": true,
	"CREATE ": true,
	"DROP ":   true,
	"ALTER ":  true,
	"select ": true,
	"insert ": true,
	"delete ": true,
	"update ": true,
	"create ": true,
	"drop ":   true,
	"alert ":  true,
}

func lineSqls(r io.Reader) ([]string, error) {
	var (
		err           error
		sqlLine, line string
		res           []string
	)

	reader := bufio.NewReader(r)
	//insertLine := make(map[string][]string)
	for err == nil {
		// 读取一行进行处理
		line, err = reader.ReadString('\n')
		// 末尾退出
		//if err == io.EOF {
		//	break
		//}
		// 前后空格去掉
		line = strings.TrimSpace(line)
		if len(line) == 0 {
			continue
		}
		// 对比sql语句头
		title := line[:strings.Index(line, " ")+1]
		if _, ok := spiltPrefix[title]; ok {
			if sqlLine != "" {
				res = append(res, sqlLine)
			}
			sqlLine = line
		} else {
			sqlLine += line
		}
	}
	if err != io.EOF {
		return nil, err
	}
	// 读取完所有行后将最后的结果拼接上
	if sqlLine != "" {
		res = append(res, sqlLine)
	}
	return res, nil
}

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/pkg/utils/jsonx.go
```golang
package utils

import (
	"encoding/json"
	"fmt"
	"strings"

	"github.com/zeromicro/go-zero/core/logx"
)

func StructToJsonString(obj interface{}) string {
	b, err := json.Marshal(obj)
	if err != nil {
		logx.Errorf("Error: %s", err)
		return ""
	}
	return string(b)
}

//  unmarshals v from str.
func UnmarshalFromString(str string, v any) error {
	decoder := json.NewDecoder(strings.NewReader(str))
	if err := unmarshalUseNumber(decoder, v); err != nil {
		return formatError(str, err)
	}
	return nil
}

func unmarshalUseNumber(decoder *json.Decoder, v any) error {
	decoder.UseNumber()
	return decoder.Decode(v)
}

func formatError(v string, err error) error {
	return fmt.Errorf("string: `%s`, error: `%w`", v, err)
}

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/pkg/utils/commonutil.go
```golang
package utils

import (
	"reflect"
	"strings"
)

func If(condition bool, trueVal, falseVal interface{}) interface{} {
	if condition {
		return trueVal
	} else {
		return falseVal
	}
}

//求交集
func IntSliceIntersect(slice1, slice2 []int) []int { // 取两个切片的交集
	m := make(map[int]int)
	n := make([]int, 0)
	for _, v := range slice1 {
		m[v]++
	}
	for _, v := range slice2 {
		times, _ := m[v]
		if times == 1 {
			n = append(n, v)
		}
	}
	return n
}

//求差集
func IntSliceDifference(slice1, slice2 []int) []int { //取要校验的和已经校验过的差集，找出需要校验的切片IP（找出slice1中  slice2中没有的）
	m := make(map[int]int)
	n := make([]int, 0)
	inter := IntSliceIntersect(slice1, slice2)
	for _, v := range inter {
		m[v]++
	}
	for _, value := range slice1 {
		if m[value] == 0 {
			n = append(n, value)
		}
	}

	for _, v := range slice2 {
		if m[v] == 0 {
			n = append(n, v)
		}
	}
	return n
}

// XxYy to xx_yy , XxYY to xx_y_y
func SnakeString(s string) string {
	data := make([]byte, 0, len(s)*2)
	j := false
	num := len(s)
	for i := 0; i < num; i++ {
		d := s[i]
		// or通过ASCII码进行大小写的转化
		// 65-90（A-Z），97-122（a-z）
		//判断如果字母为大写的A-Z就在前面拼接一个_
		if i > 0 && d >= 'A' && d <= 'Z' && j {
			data = append(data, '_')
		}
		if d != '_' {
			j = true
		}
		data = append(data, d)
	}
	//ToLower把大写字母统一转小写
	return strings.ToLower(string(data[:]))
}

// xx_yy to XxYx  xx_y_y to XxYY
func CamelString(s string) string {
	data := make([]byte, 0, len(s))
	j := false
	k := false
	num := len(s) - 1
	for i := 0; i <= num; i++ {
		d := s[i]
		if k == false && d >= 'A' && d <= 'Z' {
			k = true
		}
		if d >= 'a' && d <= 'z' && (j || k == false) {
			d = d - 32
			j = false
			k = true
		}
		if k && d == '_' && num > i && s[i+1] >= 'a' && s[i+1] <= 'z' {
			j = true
			continue
		}
		data = append(data, d)
	}
	return string(data[:])
}

func In(haystack interface{}, needle interface{}) (isIn bool) {
	sVal := reflect.ValueOf(haystack)
	kind := sVal.Kind()
	if kind == reflect.Slice || kind == reflect.Array {
		//m := make(map[interface{}]struct{})
		//for i := 0; i < sVal.Len(); i++ {
		//	m[sVal.Index(i).Interface()] = struct{}{}
		//}
		//_, isIn = m[needle]
		for i := 0; i < sVal.Len(); i++ {
			isIn = sVal.Index(i).Interface() == needle
			if isIn {
				return
			}
		}
	}
	return
}

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/pkg/utils/randomString.go
```golang
package utils

import (
	"math/rand"
	"time"
)

func RandomString(n int) string {
	chars := []rune{'1', '2', '3', '4', '5', '6', '7', '8', '9', '0',
		'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'g', 'k', 'l', 'm',
		'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z',
		'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'G', 'K', 'L', 'M',
		'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z',
	}
	len := len(chars)
	runes := make([]rune, n)
	rand.Seed(time.Now().UnixNano())
	for i := 0; i < n; i++ {
		runes[i] = chars[rand.Intn(len)]
	}
	return string(runes)
}

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/pkg/utils/runtime.go
```golang
package utils

import "os"

func InK8s() bool {
	return len(os.Getenv("KUBERNETES_SERVICE_HOST")) > 0
}

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/pkg/utils/excelutil.go
```golang
package utils

import (
	"errors"
	"github.com/xuri/excelize/v2"
	"io"
	"strings"
)

func ReadExcel(r io.Reader) (*excelize.File, error) {
	return excelize.OpenReader(r)
}

func Rows2Map(rows *excelize.Rows, heads ...string) (result []map[string]string, err error) {
	rows.Next() //excelize包，默认首行为空
	if len(heads) == 0 {
		heads, err = rows.Columns()
		if err != nil {
			return
		}
	}
	heads, err = checkHeads(heads)
	if err != nil {
		return
	}
	for rows.Next() {
		row, err := rows.Columns()
		if err != nil {
			return nil, err
		}
		resMap := make(map[string]string)
		for i, head := range heads {
			//if head == "SN号" && len(row[i]) > 20 {
			//	err = errors.New("sn is too long. must be less than or equal to 20")
			//	return nil, err
			//}
			head = headMapping[head]
			if i < len(row) {
				resMap[head] = row[i]
			} else {
				resMap[head] = ""
			}
		}
		result = append(result, resMap)
		//again = rows.Next()
	}
	return
}

var headMapping = map[string]string{
	"名称":     "name",
	"SN号":    "sn",
	"所属区域":   "regionName",
	"所属可用区":  "azName",
	"所属机房":   "labName",
	"所属房间":   "roomName",
	"所属机柜":   "cabinName",
	"所属机架位":  "rackName",
	"所占U位":   "switchUnitNumber",
	"管理IP":   "managementIp",
	"带外IP":   "outBandIp",
	"团体字":    "community",
	"厂家":     "systemSales",
	"型号":     "switchType",
	"角色":     "switchRole",
	"CPU型号":  "cpuModel",
	"内存型号":   "memModel",
	"维保到期时间": "maintenanceDue",
	"责任人":    "mainMaintainer",
	"资产编号":   "assetsNumber",
	"描述":     "description",
}

func checkHeads(heads []string) ([]string, error) {
	err := errors.New("文件内容与模板不匹配")
	if len(heads) != len(headMapping) {
		return nil, err
	}
	names := make([]string, 0, len(heads))
	for _, head := range heads {
		head = strings.Trim(strings.Trim(head, "（*必填）"), " ")
		_, ok := headMapping[head]
		if !ok {
			return nil, err
		}
		names = append(names, head)
	}
	return names, nil
}

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/pkg/utils/jsonx_test.go
```golang
package utils

import "testing"

type TestStruct struct {
	Name string `json:"name"`
	Age  int    `json:"age"`
}

func TestStructToJsonString(t *testing.T) {

	type args struct {
		obj interface{}
	}
	tests := []struct {
		name string
		args args
		want string
	}{
		{"testMap", args{obj: map[string]string{"name": "niutao"}}, `{"name":"niutao"}`},
		{"testStruct", args{obj: TestStruct{"test", 99}}, `{"name":"test","age":99}`},
		{"testNil", args{obj: nil}, `null`},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if got := StructToJsonString(tt.args.obj); got != tt.want {
				t.Errorf("StructToJsonString() = %v, want %v", got, tt.want)
			}
		})
	}
}

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/pkg/utils/gosafe.go
```golang
package utils

import (
	"bytes"
	"fmt"
	"k8s.io/klog/v2"
	"runtime"
	"runtime/debug"
	"strconv"
)

// GoSafe runs the given fn using another goroutine, recovers if fn panics.
func GoSafe(fn func()) {
	go RunSafe(fn)
}

// RoutineId is only for debug, never use it in production.
func RoutineId() uint64 {
	b := make([]byte, 64)
	b = b[:runtime.Stack(b, false)]
	b = bytes.TrimPrefix(b, []byte("goroutine "))
	b = b[:bytes.IndexByte(b, ' ')]
	// if error, just return 0
	n, _ := strconv.ParseUint(string(b), 10, 64)

	return n
}

// RunSafe runs the given fn, recovers if fn panics.
func RunSafe(fn func()) {
	defer Recover()

	fn()
}

// Recover is used with defer to do cleanup on panics.
// Use it like:
//  defer Recover(func() {})
func Recover(cleanups ...func()) {
	for _, cleanup := range cleanups {
		cleanup()
	}

	if p := recover(); p != nil {
		klog.Error(fmt.Sprintf("%s\n%s", p, string(debug.Stack())))
	}
}

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/pkg/utils/pingUtil.go
```golang
package utils

import (
	"github.com/go-ping/ping"
	"time"
)

func PingHost(host string,pCount int,interval,timeout time.Duration) (running bool) {
	var (
		pinger *ping.Pinger
		size = 24
		ttl = 64
		err error
	)
	if pinger, err = ping.NewPinger(host);err != nil { return }
	pinger.Count = pCount
	pinger.Size = size
	pinger.Interval = interval
	pinger.Timeout = timeout
	pinger.TTL = ttl
	pinger.SetPrivileged(false)
	pinger.OnFinish = func(statistics *ping.Statistics) {
		if statistics.PacketLoss < 100 { running = true}
	}
	_ = pinger.Run()
	return
}
```

File path: /Users/mac/Desktop/woker_code/cmdb-api/pkg/utils/datetime.go
```golang
package utils

import (
	"time"
)

var Flag_time = time.Date(2999, 1, 1, 0, 0, 0, 0, time.Local)
var zeroTime time.Time

//type Datetime struct {
//	this time.Time
//}
type Datetime time.Time

func NewDateTime(t time.Time) Datetime {
	//return Datetime{
	//	this: t,
	//}
	return Datetime(t)
}

func (t Datetime) GetGolangTime() time.Time {
	//return t.this
	return time.Time(t)
}

// json转结构体
func (t Datetime) UnmarshalJSON(data []byte) error {
	//return (&t.this).UnmarshalJSON(data)
	tt := t.GetGolangTime()
	return tt.UnmarshalJSON(data)
}

// 结构体转json
func (t Datetime) MarshalJSON() ([]byte, error) {
	tt := t.GetGolangTime()
	if tt.Equal(zeroTime) {
		tt = Flag_time
	} else if tt.Equal(Flag_time) {
		return []byte{'"', '"'}, nil
	}
	return tt.MarshalJSON()
}

func (t Datetime) ToString() string {
	loc, _ := time.LoadLocation("Asia/Shanghai")
	return t.GetGolangTime().In(loc).Format("2006-01-02 15:04:05")
}

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/pkg/utils/gormconn.go
```golang
package utils

import (
	logging "log"
	"time"

	"gorm.io/driver/mysql"
	"gorm.io/gorm"
	"gorm.io/gorm/logger"
	"gorm.io/gorm/schema"
	"k8s.io/klog/v2"
)

func ConnectOrmDB(dsn, tablePrefix string) (db *gorm.DB, err error) {
	db, err = gorm.Open(mysql.Open(dsn), &gorm.Config{
		NamingStrategy: schema.NamingStrategy{
			TablePrefix:   tablePrefix, // 表名前缀: 资产表前缀 asset_
			SingularTable: true,        // 使用单数表名
		},
	})
	if err != nil {
		klog.Infoln("logger.Error:", logger.Error)
		return db, err
	}
	// db.Logger = db.Logger.LogMode(logger.Error)
	newLogger := logger.New(
		//&logging.Logger{}, //此行代码有问题，会导致db在debug模式下回调输出sql语句时出现空指针！！！
		logging.Default(),
		logger.Config{
			SlowThreshold:             time.Second,
			LogLevel:                  logger.Silent,
			IgnoreRecordNotFoundError: true,
			Colorful:                  false,
		},
	)
	db.Logger = newLogger
	return db, err
}

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/pkg/utils/collection/set.go
```golang
package collection

import (
	"k8s.io/klog/v2"
)

const (
	unmanaged = iota
	untyped
	intType
	int64Type
	uintType
	uint64Type
	stringType
)

// PlaceholderType represents a placeholder type.
type PlaceholderType = struct{}

// Set is not thread-safe, for concurrent use, make sure to use it with synchronization.
type Set struct {
	data map[interface{}]PlaceholderType
	tp   int
}

// NewSet returns a managed Set, can only put the values with the same type.
func NewSet() *Set {
	return &Set{
		data: make(map[interface{}]PlaceholderType),
		tp:   untyped,
	}
}

// NewUnmanagedSet returns a unmanaged Set, which can put values with different types.
func NewUnmanagedSet() *Set {
	return &Set{
		data: make(map[interface{}]PlaceholderType),
		tp:   unmanaged,
	}
}

// Add adds i into s.
func (s *Set) Add(i ...interface{}) {
	for _, each := range i {
		s.add(each)
	}
}

// AddInt adds int values ii into s.
func (s *Set) AddInt(ii ...int) {
	for _, each := range ii {
		s.add(each)
	}
}

// AddInt64 adds int64 values ii into s.
func (s *Set) AddInt64(ii ...int64) {
	for _, each := range ii {
		s.add(each)
	}
}

// AddUint adds uint values ii into s.
func (s *Set) AddUint(ii ...uint) {
	for _, each := range ii {
		s.add(each)
	}
}

// AddUint64 adds uint64 values ii into s.
func (s *Set) AddUint64(ii ...uint64) {
	for _, each := range ii {
		s.add(each)
	}
}

// AddStr adds string values ss into s.
func (s *Set) AddStr(ss ...string) {
	for _, each := range ss {
		s.add(each)
	}
}

// Contains checks if i is in s.
func (s *Set) Contains(i interface{}) bool {
	if len(s.data) == 0 {
		return false
	}

	s.validate(i)
	_, ok := s.data[i]
	return ok
}

// Keys returns the keys in s.
func (s *Set) Keys() []interface{} {
	var keys []interface{}

	for key := range s.data {
		keys = append(keys, key)
	}

	return keys
}

// KeysInt returns the int keys in s.
func (s *Set) KeysInt() []int {
	var keys []int

	for key := range s.data {
		if intKey, ok := key.(int); ok {
			keys = append(keys, intKey)
		}
	}

	return keys
}

// KeysInt64 returns int64 keys in s.
func (s *Set) KeysInt64() []int64 {
	var keys []int64

	for key := range s.data {
		if intKey, ok := key.(int64); ok {
			keys = append(keys, intKey)
		}
	}

	return keys
}

// KeysUint returns uint keys in s.
func (s *Set) KeysUint() []uint {
	var keys []uint

	for key := range s.data {
		if intKey, ok := key.(uint); ok {
			keys = append(keys, intKey)
		}
	}

	return keys
}

// KeysUint64 returns uint64 keys in s.
func (s *Set) KeysUint64() []uint64 {
	var keys []uint64

	for key := range s.data {
		if intKey, ok := key.(uint64); ok {
			keys = append(keys, intKey)
		}
	}

	return keys
}

// KeysStr returns string keys in s.
func (s *Set) KeysStr() []string {
	var keys []string

	for key := range s.data {
		if strKey, ok := key.(string); ok {
			keys = append(keys, strKey)
		}
	}

	return keys
}

// Remove removes i from s.
func (s *Set) Remove(i interface{}) {
	s.validate(i)
	delete(s.data, i)
}

// Count returns the number of items in s.
func (s *Set) Count() int {
	return len(s.data)
}

func (s *Set) add(i interface{}) {
	switch s.tp {
	case unmanaged:
		// do nothing
	case untyped:
		s.setType(i)
	default:
		s.validate(i)
	}
	s.data[i] = PlaceholderType{}
}

func (s *Set) setType(i interface{}) {
	// s.tp can only be untyped here
	switch i.(type) {
	case int:
		s.tp = intType
	case int64:
		s.tp = int64Type
	case uint:
		s.tp = uintType
	case uint64:
		s.tp = uint64Type
	case string:
		s.tp = stringType
	}
}

func (s *Set) validate(i interface{}) {
	if s.tp == unmanaged {
		return
	}

	switch i.(type) {
	case int:
		if s.tp != intType {
			klog.Errorf("Error: element is int, but set contains elements with type %d", s.tp)
		}
	case int64:
		if s.tp != int64Type {
			klog.Errorf("Error: element is int64, but set contains elements with type %d", s.tp)
		}
	case uint:
		if s.tp != uintType {
			klog.Errorf("Error: element is uint, but set contains elements with type %d", s.tp)
		}
	case uint64:
		if s.tp != uint64Type {
			klog.Errorf("Error: element is uint64, but set contains elements with type %d", s.tp)
		}
	case string:
		if s.tp != stringType {
			klog.Errorf("Error: element is string, but set contains elements with type %d", s.tp)
		}
	}
}

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/pkg/utils/unixtime/unixtime.go
```golang
package unixtime

import (
	"database/sql/driver"
	"errors"
	"fmt"
	"regexp"
	"strconv"
	"strings"
	"time"
)

const (
	timeT       = "^[0-9]{4}-[0-9]{2}-[0-9]{2}T[0-9]{2}:[0-9]{2}:[0-9]{2}"
	timeN       = "^[0-9]{4}-[0-9]{2}-[0-9]{2} [0-9]{2}:[0-9]{2}:[0-9]{2}"
	timeFormart = "2006-01-02 15:04:05"
	zone        = "Asia/Shanghai"
)

type UnixTime time.Time

// MarshalJSON implements json.Marshaler.
func (t UnixTime) MarshalJSON() ([]byte, error) {
	ts := time.Time(t).UnixNano() / int64(time.Millisecond)
	if ts < 0 {
		ts = 0
	}
	stamp := fmt.Sprintf("%d", ts)
	return []byte(stamp), nil
}

// UnmarshalJSON implements json unmarshal interface.
func (t *UnixTime) UnmarshalJSON(data []byte) (err error) {
	var (
		dataStr = strings.Trim(string(data), `"`)
		ts      int
		now     time.Time
	)
	if ts, err = strconv.Atoi(dataStr); err == nil {
		if len(dataStr) <= 10 {
			*t = UnixTime(time.Unix(int64(ts), 0))
			return
		}
		if len(dataStr) <= 13 {
			//*t = UnixTime(time.UnixMilli(int64(ts)))
			*t = UnixTime(time.Unix(int64(ts)/1e3, (int64(ts)%1e3)*1e6)) //Unix(msec/1e3, (msec%1e3)*1e6)
			return
		}
		err = errors.New("时间戳格式不合规")
		return
	}
	err = nil
	loc, _ := time.LoadLocation(zone)
	if loc == nil {
		loc = time.Local
	}
	if b, _ := regexp.MatchString(timeT, dataStr); b {
		//now, err = time.ParseInLocation(`"`+"2006-01-02T15:04:05"+`"`, dataStr, loc)
		now, err = time.ParseInLocation(`2006-01-02T15:04:05`, dataStr, loc)
	} else if b, _ = regexp.MatchString(timeN, dataStr); b {
		//now, err = time.ParseInLocation(`"`+timeFormart+`"`, dataStr, loc)
		now, err = time.ParseInLocation(timeFormart, dataStr, loc)
	}
	//if err != nil {
	//
	//}
	*t = UnixTime(now)
	return
}

func (t UnixTime) String() string {
	return time.Time(t).Format(timeFormart)
}

func (t UnixTime) local() time.Time {
	loc, _ := time.LoadLocation(zone)
	return time.Time(t).In(loc)
}

// Value ...
func (t UnixTime) Value() (driver.Value, error) {
	var zeroTime time.Time
	var ti = time.Time(t)
	if ti.UnixNano() == zeroTime.UnixNano() {
		return nil, nil
	}
	return ti, nil
}

// Scan valueof time.Time 注意是指针类型 method
func (t *UnixTime) Scan(v interface{}) error {
	value, ok := v.(time.Time)
	if ok {
		*t = UnixTime(value)
		return nil
	}
	return fmt.Errorf("can not convert %v to timestamp", v)
}

func (t UnixTime) IsZero() bool {
	return time.Time(t).IsZero()
}

func (t UnixTime) Year() int {
	return time.Time(t).Year()
}
func (t UnixTime) Month() time.Month {
	return time.Time(t).Month()
}
func (t UnixTime) Day() int {
	return time.Time(t).Day()
}
func (t UnixTime) Hour() int {
	return time.Time(t).Hour()
}
func (t UnixTime) Minute() int {
	return time.Time(t).Minute()
}
func (t UnixTime) Second() int {
	return time.Time(t).Second()
}
func (t UnixTime) Unix() int64 {
	return time.Time(t).Unix()
}

func (t UnixTime) Add(d time.Duration) UnixTime {
	//t = UnixTime(time.Time(t).Add(d))
	return UnixTime(time.Time(t).Add(d))
}
func (t UnixTime) AddDate(years int, months int, days int) UnixTime {
	//t = UnixTime(time.Time(t).Add(d))
	return UnixTime(time.Time(t).AddDate(years, months, days))
}

func (t UnixTime) After(u UnixTime) bool {
	return time.Time(t).After(time.Time(u))
}
func (t UnixTime) Before(u UnixTime) bool {
	return time.Time(t).Before(time.Time(u))
}
func (t UnixTime) Equal(u UnixTime) bool {
	return time.Time(t).Equal(time.Time(u))
}

func Now() UnixTime {
	return UnixTime(time.Now())
}

func (t UnixTime) Format(layout string) string {
	return time.Time(t).Format(layout)
}

func Parse(layout, value string) (UnixTime, error) {
	var ut UnixTime
	t, err := time.Parse(layout, value)
	if err != nil {
		return ut, err
	}
	return UnixTime(t), err
}

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/pkg/utils/keyStone/models.go
```golang
package keyStone

type (
	User struct {
		ID       string `json:"id"`
		Name     string `json:"name"`
		Username string `json:"username"`
		Enabled  bool   `json:"enabled"`
		Email    string `json:"email"`
		TenantID string `json:"tenant_id"`
	}
)

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/pkg/utils/keyStone/neutron.go
```golang
package keyStone

import (
	"context"
	"encoding/json"
	"fmt"
	"io"
	"k8s.io/klog/v2"
	"luban-cmdb-api/pkg/gredis"
	"net/http"
	"regexp"
	"strings"
	"time"
)

func AddHeaders(request *http.Request, headers map[string]string) *http.Request {
	var token string
	var ok bool
	if token, ok = headers["X-Auth-Token"]; !ok {
		token = GetAdminToken()
		if token == "" {
			token = "d92195c970e64359acd5b8bbd24fe67c:6262a999044a4e2fa0e97aef96a53b17"
		}
	}
	var heads = map[string]string{
		"X-Auth-Token":  token,
		"X-Auth-User":   "admin",
		"Conetent-Type": "application/json",
	}
	for k, v := range heads {
		request.Header.Add(k, v)
	}
	if headers == nil || len(headers) == 0 {
		return request
	}
	for k, v := range headers {
		if _, ok = heads[k]; ok {
			continue
		}
		request.Header.Add(k, v)
	}
	return request
}

//func GetUserIds() (uids []string) {
//	var (
//		result   = make(map[string]interface{})
//		request  *http.Request
//		resp     *http.Response
//		client   = &http.Client{}
//		bytes    []byte
//		err      error
//		uidMap   = make(map[string]struct{})
//		pageSize = 1000
//		pageNo   = 1
//		//total    = 0
//	)
//	for {
//		apiUrl := UserIdApiUrl + fmt.Sprintf("page=%d&per_page=%d", pageNo, pageSize)
//		request, err = http.NewRequest("GET", apiUrl, nil)
//		if err != nil {
//			return
//		}
//		request = AddHeaders(request, UserInfoHeader)
//		resp, err = client.Do(request)
//		if err != nil {
//			klog.Error("fetch userInfo from "+apiUrl+"failure: ", err.Error())
//			return
//		}
//		bytes, err = io.ReadAll(resp.Body)
//		resp.Body.Close()
//		if err != nil {
//			return
//		}
//		err = json.Unmarshal(bytes, &result)
//		if err != nil {
//			return
//		}
//		if _, ok := result["errno"]; ok {
//			break
//		}
//		if dataMap, ok := result["data"]; ok {
//			if data, ok := dataMap.(map[string]interface{}); ok {
//				if items, ok := data["items"]; ok {
//					if itemList, ok := items.([]interface{}); ok {
//						for _, item := range itemList {
//							if m, ok := item.(map[string]interface{}); ok {
//								if id, ok := m["user_id"]; ok {
//									if idif, ok := id.(float64); ok {
//										uid := strconv.Itoa(int(idif))
//										uidMap[uid] = struct{}{}
//									}
//								}
//							}
//						}
//					}
//				}
//			}
//		}
//		pageNo += 1
//	}
//	//180000000 该接口获取不到，此处手动补上
//	uidMap["180000000"] = struct{}{}
//	for uid := range uidMap {
//		uids = append(uids, uid)
//	}
//	return
//}

func GetUserIds() (uids []string) {
	var (
		result  = make(map[string][]User)
		request *http.Request
		resp    *http.Response
		client  = &http.Client{}
		bytes   []byte
		err     error
		//total    = 0
	)
	apiUrl := fmt.Sprintf("%s:%d/%s/users", KeystoneUrl, keystonePort, KeystoneVersion)
	request, err = http.NewRequest("GET", apiUrl, nil)
	if err != nil {
		return
	}
	request = AddHeaders(request, nil)
	resp, err = client.Do(request)
	if err != nil {
		klog.Error("fetch users from "+apiUrl+" failure: ", err.Error())
		return
	}
	bytes, err = io.ReadAll(resp.Body)
	resp.Body.Close()
	if err != nil {
		return
	}
	err = json.Unmarshal(bytes, &result)
	if err != nil {
		klog.Error("unmarshal users json form keystone failure: ", err.Error())
		return
	}
	if users, ok := result["users"]; ok {
		for _, user := range users {
			if user.Enabled {
				uids = append(uids, user.Name)
			}
		}
	}
	return
}

func GetUserList(uids []string) {
	var (
		result         = make(map[string]interface{})
		request        *http.Request
		resp           *http.Response
		client         = &http.Client{}
		bytes          []byte
		err            error
		step           = 25
		sindex, eindex = 0, step
	)
	userMap := make(map[string]interface{})
	if eindex > len(uids) {
		eindex = len(uids)
	}
	for sindex < len(uids) {
		ids := uids[sindex:eindex]
		apiUrl := UserInfoApiUrl + fmt.Sprintf("ids=%s", strings.Join(ids, ","))
		request, err = http.NewRequest("GET", apiUrl, nil)
		if err != nil {
			//return userMap
			return
		}
		request = AddHeaders(request, UserInfoHeader)
		resp, err = client.Do(request)
		if err != nil {
			klog.Error("fetch userInfo from "+apiUrl+"failure: ", err.Error())
			return
		}
		bytes, err = io.ReadAll(resp.Body)
		resp.Body.Close()
		if err != nil {
			//return userMap
			return
		}
		err = json.Unmarshal(bytes, &result)
		if err != nil {
			//return userMap
			return
		}
		//uMap := parseUserDetail(result, ids)
		//for s, user := range uMap {
		//	userMap[s] = user
		//}
		userMap = parseUserDetail(result, ids)
		if len(userMap) > 0 {
			ctx, celf := context.WithTimeout(context.Background(), 5*time.Second)
			_, err = gredis.HMSet(ctx, gredis.UserInfoKey, userMap)
			celf()
			if err != nil {
				klog.Error("userInfo data set into "+gredis.UserInfoKey+" failure: ", err.Error())
			}
		}
		sindex, eindex = sindex+step, eindex+step
		if eindex > len(uids) {
			eindex = len(uids)
		}
	}
	return
}

func parseUserDetail(result map[string]interface{}, ids []string) map[string]interface{} {
	var (
		userMap = make(map[string]interface{})
	)
	if dataMap, ok := result["data"]; ok {
		if data, ok := dataMap.(map[string]interface{}); ok {
			for _, id := range ids {
				if b, _ := regexp.MatchString("(\\w){9}", id); !b {
					continue
				}
				if item, ok := data[id]; ok {
					if im, ok := item.(map[string]interface{}); ok {
						if basic, ok := im["basic"]; ok {
							if bm, ok := basic.(map[string]interface{}); ok {
								var user = User{ID: id}
								if name, ok := bm["username"]; ok && name != "" {
									user.Name, _ = name.(string)
								} else {
									continue
								}
								if email, ok := bm["secure_email"]; ok {
									user.Email, _ = email.(string)
								}
								if person, ok := im["person"]; ok {
									if pm, ok := person.(map[string]interface{}); ok {
										if userName, ok := pm["name"]; ok {
											user.Username, _ = userName.(string)
										}
									}
								}
								if userByte, err := json.Marshal(user); err == nil {
									userMap[user.ID] = userByte
								}
							}
						}
					}
				}
			}
		}
	}
	return userMap
}

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/pkg/utils/keyStone/variable.go
```golang
package keyStone

import (
	"fmt"
	"os"
)

var (
	NeutronFirstApiUrl = "http://neutron.galaxy.cloud:9696/" + KeystoneVersion + "/vpc/regions"
	//用户信息url
	subDomain      string
	UserApiUrl     string //sdns.cqpcloud.cn
	UserInfoApiUrl string
	UserIdApiUrl   string
	//虚拟实例url
	vmApiUrl string
)

var (
	UserInfoHeader = map[string]string{
		"Authorization": "Basic a2VjOjUxNTViZDczZTJiZDI1ZGViNzRmMjk4MDk4ODRiNGM4",
	}
)

func init() {
	if subDomain = os.Getenv("GALAXY_SUB_DOMAIN"); subDomain == "" {
		subDomain = "sdns.cqpcloud.cn"
	}
	UserApiUrl = fmt.Sprintf("http://profile.inner.%s/admin/users?type=1", subDomain)
	UserInfoApiUrl = fmt.Sprintf("http://profile.inner.%s/basic_info/users?", subDomain)
	UserIdApiUrl = fmt.Sprintf("http://profile.inner.%s/admin/brief/users?", subDomain)
	vmApiUrl = fmt.Sprintf("http://ecs.inner.%s/", subDomain)
}

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/pkg/utils/keyStone/nova.go
```golang
package keyStone

import (
	"encoding/json"
	"fmt"
	"io"
	"k8s.io/klog/v2"
	"net/http"
	"os"
	"strings"
)

var (
	keystonePort = 8357
)

func init() {
	if len(os.Getenv("KUBERNETES_SERVICE_HOST")) > 0 {
		keystonePort = 35357
	}
}

func GetAdminToken() (token string) {
	var (
		url     string
		result  = make(map[string]interface{})
		request *http.Request
		resp    *http.Response
		client  = &http.Client{}
		bytes   []byte
		err     error
		data    string
		text    interface{}
		ok      bool
	)
	url = fmt.Sprintf("%s:%d/%s/tokens", KeystoneUrl, keystonePort, KeystoneVersion)
	data = fmt.Sprintf(`{"auth": {"tenantName": "admin", "passwordCredentials": {"username": "admin", "password": "ksc"}}}`)
	request, err = http.NewRequest("POST", url, strings.NewReader(data))
	if err != nil {
		return
	}
	request.Header.Add("Content-Type", "application/json")
	resp, err = client.Do(request)
	if err != nil {
		klog.Error("fetch nova token from "+url+"failure: ", err.Error())
		return
	}
	bytes, err = io.ReadAll(resp.Body)
	resp.Body.Close()
	if err != nil {
		klog.Error("read nova response body failure: ", err.Error())
		return
	}
	err = json.Unmarshal(bytes, &result)
	if err != nil {
		klog.Error("Unmarshal nova response body failure: ", err.Error())
		return
	}
	if text, ok = result["access"]; ok {
		if result, ok = text.(map[string]interface{}); ok {
			if text, ok = result["token"]; ok {
				if result, ok = text.(map[string]interface{}); ok {
					if text, ok = result["id"]; ok {
						token, ok = text.(string)
					}
				}
			}
		}
	}
	return
}

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/pkg/utils/keyStone/epccenter.go
```golang
package keyStone

import (
	"os"
)

var (
	EpcCenterUrl string
)

func init() {
	//http://epc-center.inner.sdns.yunyan.com
	//http://epc-center.inner.sdns.nhdc.cn
	if EpcCenterUrl = os.Getenv("EPC_CENTER_URL"); EpcCenterUrl == "" {
		EpcCenterUrl = "http://epc-center.inner.sdns.nhdc.cn"
	}
}

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/pkg/utils/keyStone/constant.go
```golang
package keyStone

const (
	KeystoneUrl     = "http://keystone.galaxy.cloud"
	KeystoneVersion = "v2.0"
)

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/pkg/utils/ebs/models.go
```golang
package ebs

type (
	VolumeEntityAPIResponse struct {
		RequestId string   `json:"RequestId"`
		Volumes   []Volume `json:"Volumes"`
	}
	Volume struct {
		VolumeId         string       `json:"VolumeId"`
		VolumeName       string       `json:"VolumeName"`
		VolumeDesc       string       `json:"VolumeDesc"`
		Size             int          `json:"Size"`
		VolumeStatus     string       `json:"VolumeStatus"`
		VolumeType       string       `json:"VolumeType"`
		VolumeCategory   string       `json:"VolumeCategory"`
		InstanceId       string       `json:"InstanceId"`
		Region           string       `json:"-"`
		UserId           string       `json:"-"`
		AvailabilityZone string       `json:"AvailabilityZone"`
		CreateTime       string       `json:"CreateTime"`
		Attachments      []Attachment `json:"Attachment"`
		//ProjectId        string       `json:"ProjectId"`
		ProjectId int `json:"ProjectId"`
	}
	Attachment struct {
		InstanceId string `json:"InstanceId"`
		MountPoint string `json:"MountPoint"`
		//DeleteWithInstance string `json:"DeleteWithInstance"`
		DeleteWithInstance bool `json:"DeleteWithInstance"`
	}
)

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/pkg/utils/ebs/volumes.go
```golang
package ebs

import (
	"encoding/json"
	"fmt"
	"github.com/google/uuid"
	"io/ioutil"
	"k8s.io/klog/v2"
	"net/http"
)

func GetCloudDiskDetailFromApi(uid, region, url string) (volumeDt VolumeEntityAPIResponse) {
	if region == "" || uid == "" {
		return
	}
	if url != "" {
		EbsApiUrl = url + "/?"
	}
	volumeApi := fmt.Sprintf("%sAction=DescribeVolumes&Version=2016-03-04", EbsApiUrl)
	request, err := http.NewRequest("GET", volumeApi, nil)
	request.Header.Add("X-KSC-ACCOUNT-ID", uid)
	request.Header.Add("X-KSC-REGION", region)
	request.Header.Add("Accept", "application/json")
	request.Header.Add("X-KSC-REQUEST-ID", uuid.New().String())
	request.Header.Add("X-KSC-SOURCE", "user")
	if err != nil {
		return
	}
	//处理返回结果
	var (
		response *http.Response
		bt       []byte
	)

	client := &http.Client{}
	response, err = client.Do(request)
	if err != nil {
		klog.Error(err)
		return
	}
	bt, err = ioutil.ReadAll(response.Body)
	if err != nil {
		klog.Error(err)
		return
	}
	err = json.Unmarshal(bt, &volumeDt)
	if err != nil {
		klog.Error(err)
		return
	}
	response.Body.Close()
	for i := 0; i < len(volumeDt.Volumes); i++ {
		volumeDt.Volumes[i].Region = region
		volumeDt.Volumes[i].UserId = uid
	}
	return
}

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/pkg/utils/ebs/variable.go
```golang
package ebs

import (
	"fmt"
	"os"
)

var (
	EbsApiUrl string
	subDomain string
)

func init() {
	if subDomain = os.Getenv("GALAXY_SUB_DOMAIN"); subDomain == "" {
		subDomain = "sdns.cqpcloud.cn"
	}
	EbsApiUrl = fmt.Sprintf("http://ebs.inner.%s/?", subDomain)
}

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/pkg/utils/pageUtil/Pagination.go
```golang
package pageUtil

import (
	"errors"
	"reflect"
)

type Pagination struct {
	PageNo      int         `json:"pageNo"`      // 当前页
	PageSize    int         `json:"pageSize"`    // 页大小
	TotalCount  int         `json:"totalCount"`  // 总数
	HasPrev     bool        `json:"hasPrev"`     // 是否有前一页
	HasNext     bool        `json:"hasNext"`     // 是否有后一页
	IsFirstPage bool        `json:"isFirstPage"` // 是否为第一页
	IsLastPage  bool        `json:"isLastPage"`  // 是否为最后一页
	Prev        int         `json:"prev"`        // 前一页
	Next        int         `json:"next"`        // 后一页
	Pages       int         `json:"pages"`       // 总页码数
	DataList    interface{} `json:"dataList"`    // 数据载体
}

func Build(pageNo, pageSize, totalCount int, dataList interface{}) (page *Pagination, err error) {
	if pageSize <= 0 {
		return nil, PageSizeDefErr
	}
	if totalCount < 0 {
		return nil, TotalCountLessThanZeroErr
	}
	page = &Pagination{
		PageNo:     pageNo,
		PageSize:   pageSize,
		DataList:   dataList,
		TotalCount: totalCount,
	}
	page.Pages = totalCount / pageSize
	if totalCount%pageSize != 0 {
		page.Pages = totalCount/pageSize + 1
	}
	if pageNo <= 0 {
		return nil, PageNoLessThanZero
	}
	if pageNo > page.Pages {
		return nil, PageNoMoreThanPages
	}
	if pageNo > 1 {
		page.HasPrev = true
		page.Prev = pageNo - 1
	} else {
		page.IsFirstPage = true
		page.Prev = 1
	}
	if pageNo < page.Pages {
		page.HasNext = true
		page.Next = pageNo + 1
	} else {
		page.IsLastPage = true
		page.Next = page.Pages
	}
	return
}

// BuildAuto 根据传入的dataList、PageNo、PageSize生成Page对象
// 带有数据校验 传入全量数据、会将slice[i, j]返回
func BuildAuto(pageNo, pageSize int, dataList interface{}) (page *Pagination, err error) {
	if pageSize <= 0 {
		return nil, PageSizeDefErr
	}
	page = &Pagination{
		PageNo:   pageNo,
		PageSize: pageSize,
		DataList: dataList,
	}
	totalCount, err := dataListTotalCount(dataList)
	if err != nil {
		return nil, err
	}
	page.TotalCount = totalCount
	page.Pages = totalCount / pageSize
	if totalCount%pageSize != 0 {
		page.Pages = totalCount/pageSize + 1
	}
	if pageNo <= 0 {
		return nil, PageNoLessThanZero
	}
	if pageNo > page.Pages {
		return nil, PageNoMoreThanPages
	}
	if pageNo > 1 {
		page.HasPrev = true
		page.Prev = pageNo - 1
	} else {
		page.IsFirstPage = true
		page.Prev = 1
	}
	if pageNo < page.Pages {
		page.HasNext = true
		page.Next = pageNo + 1
	} else {
		page.IsLastPage = true
		page.Next = page.Pages
	}
	page.buildSubSlice()
	return
}

func dataListTotalCount(dataList interface{}) (totalCount int, err error) {
	if reflect.TypeOf(dataList).Kind() != reflect.Slice {
		return 0, DataListTypeErr
	}
	val := reflect.ValueOf(dataList)
	return val.Len(), nil
}

func (p *Pagination) buildSubSlice() {
	left, right := 0, 0
	left = (p.PageNo - 1) * p.PageSize
	if left+p.PageSize > p.TotalCount {
		right = p.TotalCount
	} else {
		right = left + p.PageSize
	}
	val := reflect.ValueOf(p.DataList)
	p.DataList = val.Slice(left, right).Interface()
}

var DataListTypeErr = errors.New("dataList type != slice")
var PageSizeDefErr = errors.New("pageSize <= 0")
var PageNoLessThanZero = errors.New("pageNo <= 0")
var PageNoMoreThanPages = errors.New("pageNo >= pages")
var TotalCountLessThanZeroErr = errors.New("totalCount < 0")

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/pkg/utils/galaxy-inner-api/kec/types.go
```golang
package kec

import (
	"luban-cmdb-api/pkg/utils/unixtime"
)

type (
	VmResult struct {
		Marker        int          `json:"Marker"`
		InstanceCount int          `json:"InstanceCount"`
		RequestId     string       `json:"RequestId"`
		InstancesSet  []VmInstance `json:"InstancesSet"`
	}

	VmInstance struct {
		InstanceId          string      `json:"InstanceId"`
		ProjectId           int         `json:"ProjectId"`
		InstanceName        string      `json:"InstanceName"`
		InstanceType        string      `json:"InstanceType"`
		InstanceConfigure   VmConfigure `json:"InstanceConfigure"`
		ImageId             string      `json:"ImageId"`
		SubnetId            string      `json:"SubnetId"`
		PrivateIpAddress    string      `json:"PrivateIpAddress"`
		InstanceState       VmState     `json:"InstanceState"`
		NetworkInterfaceSet []struct {
			NetworkInterfaceId   string `json:"NetworkInterfaceId"`
			NetworkInterfaceType string `json:"NetworkInterfaceType"`
			VpcId                string `json:"VpcId"`
			SubnetId             string `json:"SubnetId"`
			MacAddress           string `json:"MacAddress"`
			PrivateIpAddress     string `json:"PrivateIpAddress"`
			GroupSet             []struct {
				GroupId string `json:"GroupId"`
			} `json:"GroupSet"`
			SecurityGroupSet []struct {
				SecurityGroupId string `json:"SecurityGroupId"`
			} `json:"SecurityGroupSet"`
		} `json:"NetworkInterfaceSet"`
		SriovNetSupport       string            `json:"SriovNetSupport"`
		IsShowSriovNetSupport bool              `json:"IsShowSriovNetSupport"`
		CreationDate          unixtime.UnixTime `json:"CreationDate"`
		AvailabilityZone      string            `json:"AvailabilityZone"`
		AvailabilityZoneName  string            `json:"AvailabilityZoneName"`
		ProductType           int               `json:"ProductType"`
		ProductWhat           int               `json:"ProductWhat"`
		LiveUpgradeSupport    bool              `json:"LiveUpgradeSupport"`
		ServiceEndTime        string            `json:"ServiceEndTime"`
		ChargeType            string            `json:"ChargeType"`
		SystemDisk            SystemDisk        `json:"SystemDisk"`
		HostName              string            `json:"HostName"`
		Migration             int               `json:"Migration"`
	}
	VmConfigure struct {
		VCPU         int    `json:"VCPU"`
		GPU          int    `json:"GPU"`
		MemoryGb     int    `json:"MemoryGb"`
		DataDiskGb   int    `json:"DataDiskGb"`
		RootDiskGb   int    `json:"RootDiskGb"`
		DataDiskType string `json:"DataDiskType"`
		VGPU         string `json:"VGPU"`
	}
	VmState struct {
		Name      string `json:"Name"`
		CostTime  string `json:"CostTime"`
		TimeStamp string `json:"TimeStamp"`
	}
	SystemDisk struct {
		DiskType string `json:"DiskType"`
		DiskSize int    `json:"DiskSize"`
	}
)

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/pkg/utils/galaxy-inner-api/kec/aggregates.go
```golang
package kec

import (
	"encoding/json"
	"fmt"
	"io"
	"k8s.io/klog/v2"
	"luban-cmdb-api/pkg/dao/basic"
	"luban-cmdb-api/pkg/utils/keyStone"
	"net/http"
	"os"
	"time"
)

// GetAggregatesVmListByInnerApi 通过开放api获取数据，用于过滤
func GetAggregatesVmListByInnerApi() (result map[string]struct{}) {
	result = make(map[string]struct{})
	uids := keyStone.GetUserIds()
	if len(uids) == 0 {
		return
	}
	list, err := basic.GetRegionList(basic.Region{})
	if err != nil {
		return
	}
	var regions []string
	for _, region := range list {
		regions = append(regions, region.RegionCode)
	}
	for _, uid := range uids {
		subResult := getAggregatesVmListByUid(uid, regions)
		for _, vmId := range subResult {
			result[vmId] = struct{}{}
		}
	}
	return
}

func getAggregatesVmListByUid(uid string, regions []string) (result []string) {
	var (
		request   *http.Request
		resp      *http.Response
		client    = &http.Client{}
		bytes     []byte
		err       error
		subDomain string
	)
	if subDomain = os.Getenv("GALAXY_SUB_DOMAIN"); subDomain == "" {
		subDomain = "sdns.yunyan.com"
	}
	urlFormat := "http://kecapi.inner.%s/?Action=DescribeInstances&Version=2016-03-04&MaxResults=%d&Marker=%d"
	for _, region := range regions {
		maxResults := 100
		marker := 0
		for {
			apiUrl := fmt.Sprintf(urlFormat, subDomain, maxResults, marker)
			request, err = http.NewRequest("GET", apiUrl, nil)
			if err != nil {
				return
			}
			headers := map[string]string{
				"X-KSC-REQUEST-ID": fmt.Sprintf("%d", time.Now().Unix()),
				"X-KSC-ACCOUNT-ID": uid,
				"X-KSC-REGION":     region,
				"Accept":           "application/json",
			}
			request = keyStone.AddHeaders(request, headers)
			resp, err = client.Do(request)
			if err != nil {
				klog.Error("fetch data from "+apiUrl+" failure: ", err.Error())
				return
			}
			bytes, err = io.ReadAll(resp.Body)
			resp.Body.Close()
			if err != nil {
				return
			}
			vms := &VmResult{}
			err = json.Unmarshal(bytes, vms)
			if err != nil {
				klog.Error("unmarshal data failure: ", err.Error())
				return
			}
			for _, instance := range vms.InstancesSet {
				result = append(result, instance.InstanceId)
			}
			if vms.Marker == 0 {
				break
			}
			marker = vms.Marker
		}
	}
	return
}

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/pkg/utils/galaxy-inner-api/kec/api_test.go
```golang
package kec

import "testing"

func Test_1(t *testing.T) {
	result := GetAggregatesVmListByInnerApi()
	t.Logf("%+v", result)

}

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/pkg/models/common.go
```golang
package models

import "encoding/json"

type CommonListReq struct {
	PageNo   int `json:"pageNo"`
	PageSize int `json:"pageSize"`

	SearchType  string `json:"searchType"`  // 搜索类型
	SearchValue string `json:"searchValue"` // 搜索值

	OrderCode string `json:"orderCode"`
	OrderType string `json:"orderType"`
}

type CommonResult struct {
	Code    int         `json:"code"`
	Message string      `json:"message"`
	Data    interface{} `json:"data"`
}

func (c *CommonResult) MarshalJSON() ([]byte, error) {
	type Alias CommonResult
	if c.Code == 0 {
		c.Code = 200
	}
	if c.Message == "" {
		c.Message = "success"
	}
	return json.Marshal(&struct {
		*Alias
	}{
		Alias: (*Alias)(c),
	})
}

type CommonListPagination struct {
	PageNo     int `json:"pageNo"`
	PageSize   int `json:"pageSize"`
	TotalCount int `json:"totalCount"`
}

type DgraphTypeModel struct {
	DgraphType string `json:"dgraph.type,omitempty"`
}

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/pkg/models/sl/sl.go
```golang
package sl

type SlInfo struct {
	ID             string `json:"id"`
	Name           string `json:"name"`
	Status         string `json:"status"`
	Type           string `json:"type"`
	AccessPoint    string `json:"accessPoint"`
	ExpirationTime int64  `json:"expirationTime"`
	CreateTime     int64  `json:"createTime"` //创建时间  秒级时间戳
	IsVlan         int64  `json:"isVlan"`     // 1 支持  0 不支持

	Region      string `json:"region"`
	Az          string `json:"az"`
	TenantId    string `json:"tenantId"`    //租户ID
	TenantName  string `json:"tenantName"`  //租户名称
	ProjectId   string `json:"projectId"`   //所属项目id
	ProjectName string `json:"projectName"` //所属项目名称 默认项目

	ResourcePoolName string `json:"resourcePoolName"`
}

type (
	SlPartListReq struct {
		InstanceId string `json:"instanceId"`
		PageNo     int    `json:"pageNo"`
		PageSize   int    `json:"pageSize"`
	}

	SlPartListRsp struct {
		TotalCount int         `json:"totalCount"`
		PageNo     int         `json:"pageNo"`
		PageSize   int         `json:"pageSize"`
		DataList   interface{} `json:"dataList"`
	}

	SlOverviewReq struct {
		Region string `json:"region"` //可用区
		Az     string `json:"az"`
	}

	SlOverviewRsp struct {
		InstanceOverview    []OverView     `json:"instanceOverview"`
		TypeOverview        []OverviewSlot `json:"typeOverview"`
		DistributedOverview []OverviewSlot `json:"distributedOverview"`
	}

	DistributedOverView struct {
		Name        string     `json:"name"`
		Region      string     `json:"region"`
		Az          string     `json:"az"`
		Distributed []OverView `json:"distributed"`
	}

	TypeOverviewData struct {
		Title string     `json:"title"`
		Totle int        `json:"totle"`
		Unit  string     `json:"unit"`
		Data  []OverView `json:"data"`
	}

	OverView struct {
		Name   string      `json:"name"`
		Code   string      `json:"code"`
		Status string      `json:"status"`
		Value  interface{} `json:"value"`
	}

	OverviewSlot struct {
		Info   SlotInfo    `json:"info"`
		Values []SlotValue `json:"values"`
	}
	SlotInfo struct {
		Name     string `json:"name"`
		Value    int    `json:"value"`
		UnitType string `json:"unitType"`
		Unit     string `json:"unit"`
	}
	SlotValue struct {
		Code     string `json:"code"`
		Name     string `json:"name"`
		Value    int    `json:"value"`
		Unit     string `json:"unit"`
		UnitType string `json:"unitType"` // storage【存储】、percent【百分比】、number【数值】
		Kind     string `json:"kind"`
	}

	GetSlResourceListReq struct {
		PageNo   int `json:"pageNo"`
		PageSize int `json:"pageSize"`

		Region           string `json:"region"` //可用区
		Az               string `json:"az"`
		ResourcePoolName string `json:"resourcePoolName"` //资源池名称

		TenantId    []string `json:"tenantId"`
		TenantName  []string `json:"tenantName"`
		ProjectName []string `json:"projectName"`

		SearchType  string `json:"searchType"`  // 搜索类型 (名称)
		SearchValue string `json:"searchValue"` // 搜索值 (注意要支持模糊搜索)

		OrderCode string `json:"orderCode"`
		OrderType string `json:"orderType"`
	}

	GetSlResourceListRsp struct {
		TotalCount int      `json:"totalCount"`
		PageNo     int      `json:"pageNo"`
		PageSize   int      `json:"pageSize"`
		DataList   []SlInfo `json:"dataList"`
	}
)

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/pkg/models/dgraph/dgraph.go
```golang
package dgraph

import "luban-cmdb-api/pkg/models/server"

type DgraphRegionData struct {
	Region []RegionData `json:"region"`
}
type RegionData struct {
	Uid                 string `json:"uid"`
	RegionCode          string `json:"regionCode"`
	RegionName          string `json:"regionName"`
	RegionCodeAggregate string `json:"regionCodeAggregate"`
}
type DgraphAZData struct {
	AZ []AZData `json:"az"`
}
type AZData struct {
	Uid             string `json:"uid"`
	AZCode          string `json:"azCode"`
	AZName          string `json:"azName"`
	AZCodeAggregate string `json:"azCodeAggregate"`
}

type DgraphHostData struct {
	Host []server.PhysicalHostData `json:"host"`
}
type HostData struct {
	Ip                string `json:"ip"`
	HostName          string `json:"hostName"`
	Uid               string `json:"uid"`
	Runstatus         string `json:"runstatus"`
	AssignmentStatus  string `json:"assignmentStatus"`
	ResourcePoolType  string `json:"resourcePoolType"`
	ResourcePool      string `json:"resourcePool"`
	Service           string `json:"service"`
	Region            string `json:"region"`
	Az                string `json:"az"`
	Lab               string `json:"lab"`
	Room              string `json:"room"`
	Cabinet           string `json:"cabinet"`
	Rack              string `json:"rack"`
	Unit              string `json:"unit"`
	ServerType        string `json:"serverType"`
	Sn                string `json:"sn"`
	ManagementIP      string `json:"managementIP"`
	OutbandIP         string `json:"outbandIP"`
	MainMaintainer    string `json:"mainMaintainer"`
	Power             string `json:"power"`
	UplinkSwitch      string `json:"uplinkSwitch"`
	MaintenanceDue    string `json:"maintenanceDue"`
	MaintenanceStatus string `json:"maintenanceStatus"`
	Assetsnumber      string `json:"assetsnumber"`
	InputTime         string `json:"inputTime"`
	InputMethod       string `json:"inputMethod"`
	MacAddress        string `json:"macAddress"`
	System            string `json:"system"`
	SystemSales       string `json:"systemSales"`
	Description       string `json:"description"`
	CreateTime        string `json:"createTime"`
}

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/pkg/models/storagePool/storagePoolSlice.go
```golang
package storagePool

import "time"

type StoragePoolSlice struct {
	Id         int       `gorm:"column:id" json:"id"`
	PoolId     int       `gorm:"column:pool_id" json:"poolId"`       // 存储资源池主键Id
	TabletName   int    `gorm:"column:tablet_name" json:"tabletName"`   // 分片名称
	Replicas   string    `gorm:"column:replicas" json:"replicas"`    //所在服务器/副本状态
	CopyNum    int       `gorm:"column:copy_num" json:"copyNum"`     // 副本个数
	TableName  string    `gorm:"column:table_name" json:"tableName"` //分片关联的云硬盘名称
	TableId    int       `gorm:"column:table_id" json:"tableId"`     // 分片关联的云硬盘id
	Creator    string    `gorm:"column:creator" json:"creator"`
	CreateTime  time.Time `gorm:"column:create_time" json:"createTime"`
	Updater    string    `gorm:"column:updater" json:"updater"`
	UpdateTime time.Time  `gorm:"column:update_time" json:"updateTime"` //
}

type EBSPollSlice struct {
	TableName string `json:"table_name"` //分片关联的云硬盘 //u89a081b7e03c4755ac2a16a17276fc08:volume-2889814c-467e-4e1b-8e9c-07fc35e8fcae
	TableId int `json:"table_id"` //分片关联的云硬盘id  520
	TabletName int `json:"tablet_name"`// 分片名称 104
	Replicas string `json:"replicas"` //所在服务器/副本状态  10.178.225.216:9002(kFollower)
}

type Pagination struct {
	Id       int
	PageNo   int
	PageSize int
}

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/pkg/models/storagePool/storagePool.go
```golang
package storagePool

import "time"

type StoragePool struct {
	Id           int       `gorm:"column:id" json:"id"`
	Name         string    `gorm:"column:name" json:"name"`
	StorageType  string    `gorm:"column:storage_type" json:"storageType"`
	RegionId     int       `gorm:"column:region_id" json:"regionId"`
	AzId         int       `gorm:"column:az_id" json:"azId"`
	ClusterUrl   string    `gorm:"column:cluster_url" json:"clusterUrl"`
	MetricUrl    string    `gorm:"column:metric_url" json:"metricUrl"`
	SliceUrl     string    `gorm:"column:slice_url" json:"sliceUrl"`
	StockUrl     string    `gorm:"column:stock_url" json:"stockUrl"`
	SubNameSpace string    `gorm:"column:sub_name_space" json:"subNameSpace"`
	CreateTime   time.Time `gorm:"column:create_time" json:"createTime"`
	ResourcePool string    `gorm:"column:resource_pool" json:"resourcePool"`
	Addresss     string    `gorm:"column:addresss" json:"addresss"`
	UpdateTime   time.Time `gorm:"column:update_time" json:"update_time"`
}

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/pkg/models/hardware/hardware.go
```golang
package hardware

import (
	"database/sql/driver"
	"encoding/json"
	"gorm.io/gorm"
)

type Hardware struct {
	Id            int                `json:"id" gorm:"column:id"`
	Sn            string             `json:"sn"`
	HostName      string             `json:"hostName"`
	SysInfo       SysInfoSlice       `json:"sysInfos" gorm:"type:json"`
	WorkInfo      WorkInfoSlice      `json:"workInfos" gorm:"type:json"`
	BaseboardInfo BaseboardInfoSlice `json:"baseboardInfos" gorm:"type:json"`
	CpuInfo       CpuInfoSlice       `json:"cpuInfos" gorm:"type:json"`
	DiskInfo      DiskInfoSlice      `json:"diskInfos" gorm:"type:json"`
	GpuInfo       GpuInfoSlice       `json:"gpuInfos" gorm:"type:json"`
	MemoryInfo    MemoryInfoSlice    `json:"memoryInfos" gorm:"type:json"`
	NicInfo       NicInfoSlice       `json:"nicInfos" gorm:"type:json"`
	RaidInfo      RaidInfoSlice      `json:"raidInfos" gorm:"type:json"`
}

func (hw *Hardware) Create(db *gorm.DB) (err error) {
	return db.Table("asset_hardware").Create(&hw).Error
}

func (hw *Hardware) FindBySn(db *gorm.DB) {
	db.Where("sn = ?", hw.Sn).First(hw)
}

func (hw *Hardware) FindById(db *gorm.DB) {
	db.First(hw)
}

func (hw *Hardware) UpdateBySn(db *gorm.DB) (err error) {
	return db.Model(hw).Where("sn = ?", hw.Sn).Select("host_name", "sys_info", "work_info", "baseboard_info", "cpu_info", "disk_info", "gpu_info", "memory_info", "nic_info", "raid_info").Updates(hw).Error
}

func (hw *Hardware) CheckExistBySn(db *gorm.DB) bool {
	var count int64
	db.Model(hw).Where("sn = ?", hw.Sn).First(&Hardware{}).Count(&count)
	return count > 0
}

type (
	SysInfo struct {
		Manufacturer      string `json:"manufacturer"`
		ProductName       string `json:"productName"`
		Version           string `json:"version"`
		SerialNumber      string `json:"serialNumber"`
		UUID              string `json:"uuid"`
		SystemProductName string `json:"systemProductName"`
	}
	WorkInfo struct {
		Name         string `json:"name"`
		HealthStatus string `json:"healthStatus"` // 健康状态
		Product      string `json:"product"`      // 厂商
		Vendor       string `json:"vendor"`       // 型号
		Speed        string `json:"speed"`        // 速率
		Units        string `json:"units"`
		Size         int    `json:"size"`
		Mac          string `json:"mac"`
	}
	BaseboardInfo struct {
		Model        string `json:"model"`
		SerialNumber string `json:"serialNumber"`
		Manufacturer string `json:"manufacturer"`
	}
	CpuInfo struct {
		SocketDesignation string `json:"socketDesignation"`
		Model             string `json:"model"` // 型号名
		CoreCount         byte   `json:"coreCount"`
		ThreadCount       byte   `json:"threadCount"`
		CurrentSpeed      string `json:"currentSpeed"` // MHZ
		MaxSpeed          string `json:"maxSpeed"`     // MHZ
		L1dCache          string `json:"l1dCache"`
		L1iCache          string `json:"l1iCache"`
		L2Cache           string `json:"l2Cache"`
		L3Cache           string `json:"l3Cache"`
	}
	DiskInfo struct {
		flag         string
		Model        string `json:"model"`
		SerialNumber string `json:"serialNumber"`
		Size         string `json:"size"`
		DiskName     string `json:"diskName"` //硬盘名称
		Vendor       string `json:"vendor"`   // 厂商
		DiskType     string `json:"diskType"` // 硬盘类型
		DiskRate     string `json:"diskRate"` // 使用率
	}

	GpuInfo struct {
		id    string
		Model string `json:"model"`
		Size  string `json:"size"`
	}
	MemoryDeviceInfo struct {
		PartNumber        string `json:"partNumber"`
		Size              uint16 `json:"size"`
		TotalWidth        uint16 `json:"totalWidth"`
		DataWidth         uint16 `json:"dataWidth"`
		FormFactor        string `json:"formFactor"`
		DeviceSet         byte   `json:"deviceSet"`
		DeviceLocator     string `json:"deviceLocator"`
		BankLocator       string `json:"bankLocator"`
		MemoryType        string `json:"memoryType"`
		TypeDetail        string `json:"typeDetail"`
		Speed             uint16 `json:"speed"`
		Manufacturer      string `json:"manufacturer"`
		SerialNumber      string `json:"serialNumber"`
		AssetTag          string `json:"assetTag"`
		Attributes        byte   `json:"attributes"`
		ConfiguredVoltage uint16 `json:"configuredVoltage"`
	}
	NicInfo struct {
		Model string `json:"model"`
		Count int    `json:"count"`
	}
	RaidInfo struct {
		Model string `json:"model"`
		Count int    `json:"count"`
	}
)

type (
	SysInfoSlice       []SysInfo
	WorkInfoSlice      []WorkInfo
	BaseboardInfoSlice []BaseboardInfo
	CpuInfoSlice       []CpuInfo
	DiskInfoSlice      []DiskInfo
	GpuInfoSlice       []GpuInfo
	MemoryInfoSlice    []MemoryDeviceInfo
	NicInfoSlice       []NicInfo
	RaidInfoSlice      []RaidInfo
)

func (c SysInfoSlice) Value() (driver.Value, error) {
	b, err := json.Marshal(c)
	return string(b), err
}

func (c *SysInfoSlice) Scan(input interface{}) error {
	return json.Unmarshal(input.([]byte), c)
}

func (c BaseboardInfoSlice) Value() (driver.Value, error) {
	b, err := json.Marshal(c)
	return string(b), err
}

func (c *BaseboardInfoSlice) Scan(input interface{}) error {
	return json.Unmarshal(input.([]byte), c)
}

func (c CpuInfoSlice) Value() (driver.Value, error) {
	b, err := json.Marshal(c)
	return string(b), err
}

func (c *CpuInfoSlice) Scan(input interface{}) error {
	return json.Unmarshal(input.([]byte), c)
}

func (c DiskInfoSlice) Value() (driver.Value, error) {
	b, err := json.Marshal(c)
	return string(b), err
}

func (c *DiskInfoSlice) Scan(input interface{}) error {
	return json.Unmarshal(input.([]byte), c)
}

func (c WorkInfoSlice) Value() (driver.Value, error) {
	b, err := json.Marshal(c)
	return string(b), err
}

func (c *WorkInfoSlice) Scan(input interface{}) error {
	return json.Unmarshal(input.([]byte), c)
}

func (c GpuInfoSlice) Value() (driver.Value, error) {
	b, err := json.Marshal(c)
	return string(b), err
}

func (c *GpuInfoSlice) Scan(input interface{}) error {
	return json.Unmarshal(input.([]byte), c)
}

func (c MemoryInfoSlice) Value() (driver.Value, error) {
	b, err := json.Marshal(c)
	return string(b), err
}

func (c *MemoryInfoSlice) Scan(input interface{}) error {
	return json.Unmarshal(input.([]byte), c)
}

func (c NicInfoSlice) Value() (driver.Value, error) {
	b, err := json.Marshal(c)
	return string(b), err
}

func (c *NicInfoSlice) Scan(input interface{}) error {
	return json.Unmarshal(input.([]byte), c)
}

func (c RaidInfoSlice) Value() (driver.Value, error) {
	b, err := json.Marshal(c)
	return string(b), err
}

func (c *RaidInfoSlice) Scan(input interface{}) error {
	return json.Unmarshal(input.([]byte), c)
}

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/pkg/models/netPoolModel/network.go
```golang
package netPoolModel

import (
	"database/sql/driver"
	"errors"
	"fmt"
	"luban-cmdb-api/pkg/models/server"
	"luban-cmdb-api/pkg/utils/unixtime"
	"strings"
)

type (
	NetWorkResourceQuery struct {
		PageNo       int      `json:"pageNo"`
		PageSize     int      `json:"pageSize"`
		PoolName     string   `json:"poolName"`
		RegionCode   string   `json:"regionCode"`
		PoolTypes    []string `json:"poolType"`
		OrderCode    string   `json:"orderCode"`
		OrderType    string   `json:"orderType"`
		ResourceType string   `json:"type"`
	}

	NetWorkResource struct {
		Hosts        StrSlice          `gorm:"column:hosts" json:"hosts"`
		PoolName     string            `gorm:"column:pool_name" json:"poolName"`
		PoolType     string            `gorm:"column:pool_type" json:"poolType"`
		RegionCode   string            `gorm:"column:region_code" json:"regionCode"`
		RegionName   string            `gorm:"column:region_name" json:"regionName"`
		ClusterCount int               `json:"clusterCount"`
		ServerCount  int               `gorm:"column:server_count" json:"serverCount"`
		NatCount     int               `gorm:"column:nat_count" json:"natCount"`
		LBCount      int               `gorm:"column:lb_count" json:"lbCount"`
		EipCount     int               `gorm:"column:eip_count" json:"eipCount"`
		BMCount      int               `json:"bmCount"`
		SLCount      int               `json:"slCount"`
		P2PCount     int               `json:"p2pCount"`
		VPNCount     int               `json:"vpnCount"`
		CreatedAt    unixtime.UnixTime `gorm:"column:created_at" json:"createdAt"`
	}

	NetWorkInventoryQuery struct {
		PageNo     int    `json:"pageNo"`
		PageSize   int    `json:"pageSize"`
		RegionCode string `json:"regionCode"`
	}
	NetWorkInventory struct {
		RegionCode       string  `gorm:"column:region_code" json:"regionCode"`
		RegionName       string  `gorm:"column:region_name" json:"regionName"`
		PoolType         string  `gorm:"column:pool_type" json:"poolType"`
		WayType          string  `gorm:"column:way_type" json:"wayType"`
		Cidr             string  `gorm:"column:cidr" json:"cidr"`
		IpCount          int     `gorm:"column:ip_sum" json:"ipCount"`
		IpUsedCount      int     `gorm:"column:ip_used" json:"ipUsedCount"`
		IpValidCount     int     `gorm:"column:ip_available" json:"ipValidCount"`
		IpRemindCount    int     `gorm:"column:reserved_sum" json:"ipRemindCount"`
		IpUsedRatio      float64 `gorm:"column:ip_used_ratio" json:"ipUsedRatio"`
		IpAvailableRatio float64 `gorm:"column:ip_available_ratio" json:"ipAvailableRatio"`
		CpuTotal         int     `gorm:"column:-" json:"cpuTotal"`
		CpuUsedRatio     float64 `gorm:"column:-" json:"cpuUsedRatio"`
		MemTotal         int     `gorm:"column:-" json:"memTotal"`
		MemUsedRatio     float64 `gorm:"column:-" json:"memUsedRatio"`
	}

	Cluster struct {
		ID             string `json:"id"`
		Name           string `json:"name"`
		VIP            string `json:"vip"`
		Description    string `json:"description"`
		AZName         string `json:"az_name"`
		Type           string `json:"type"`
		Configurations string `json:"configurations"`
		Status         string `json:"status"`
	}

	NetworkPoolOverview struct {
		PoolOverview []OverviewSlot `json:"poolOverview"`
	}

	OverviewSlot struct {
		Info   OverviewSlotInfo    `json:"info,omitempty"`
		Values []OverviewSlotValue `json:"values,omitempty"`
	}
	OverviewSlotInfo struct {
		Name        string `json:"name,omitempty"`
		Value       int    `json:"value"`
		UnitType    string `json:"unitType,omitempty"`
		Unit        string `json:"unit,omitempty"`
		PoolType    string `json:"poolType,omitempty"` // XGW、Tengine、KGW、SGW、NAT、PGW、TGW。。。
		Description string `json:"description,omitempty"`
	}
	OverviewSlotValue struct {
		Name     string `json:"name,omitempty"`
		Value    int    `json:"value"`
		Unit     string `json:"unit,omitempty"`
		UnitType string `json:"unitType,omitempty"` // storage【存储】、percent【百分比】、number【数值】
		Kind     string `json:"kind,omitempty"`
		Type     string `json:"type,omitempty"` // LB：负载均衡，EIP：弹性IP，NAT：NAT，BM：裸金属，SL：专线
	}

	PhsicalServerQuery struct {
		PageNo     int    `json:"pageNo"`
		PageSize   int    `json:"pageSize"`
		RegionCode string `json:"regionCode"`
		PoolName   string `json:"poolName"`
	}
	PhsicalServer struct {
		server.PhysicalHostData
		RackIp    string `json:"rackIp"`
		RackIloip string `json:"rackIloip"`
	}
	IpListRequestSuccess struct {
		Code    int            `json:"code"`
		Message string         `json:"message"`
		Data    IpListResponse `json:"data"`
	}
	IpListResponse struct {
		Result []server.PhysicalHostData `json:"result"`
		Total  int                       `json:"total"`
	}
	PhyIpListQuery struct {
		PoolNameSlice []string `json:"poolNameSlice"`
	}
	IpListSuccess struct {
		Code    int      `json:"code"`
		Message string   `json:"message"`
		Data    []string `json:"data"`
	}
)

type NetWorkList []NetWorkResource

func (s NetWorkList) Len() int {
	return len(s)
}
func (s NetWorkList) Less(i, j int) bool {
	return s[i].CreatedAt.Before(s[j].CreatedAt)
}
func (s NetWorkList) Swap(i, j int) {
	s[i], s[j] = s[j], s[i]
}

type StrSlice []string

func (s StrSlice) Value() (driver.Value, error) {
	return []uint8("[" + strings.Join(s, ",") + "]"), nil
}
func (s *StrSlice) Scan(v interface{}) error {
	switch str := v.(type) {
	case string:
		*s = strings.Split(strings.Trim(strings.Trim(str, "["), "]"), ",")
	case []uint8:
		ss := string(str)
		*s = strings.Split(strings.Trim(strings.Trim(ss, "["), "]"), ",")
	default:
		return errors.New(fmt.Sprintf("%+v not string.", v))
	}
	return nil
}

type PhsicalServerList []PhsicalServer

func (s PhsicalServerList) Len() int {
	return len(s)
}
func (s PhsicalServerList) Less(i, j int) bool {
	return s[i].Name < s[j].Name
}
func (s PhsicalServerList) Swap(i, j int) {
	s[i], s[j] = s[j], s[i]
}

type InventoryList []NetWorkInventory

func (s InventoryList) Len() int {
	return len(s)
}
func (s InventoryList) Less(i, j int) bool {
	return s[i].RegionCode < s[j].RegionCode && s[i].Cidr < s[j].Cidr
}
func (s InventoryList) Swap(i, j int) {
	s[i], s[j] = s[j], s[i]
}

var (
	NetWorkResourceQueryDoc = `
		pageNo： 页数 eg: 1
		pageSize： 页码 eg: 10
		poolName: 按资源池名称模糊搜索
		regionCode: 按区域搜索 全部请传空
		poolType: [] 按资源池类型搜索，支持多个
		orderCode: 'createAt',与接口返回的“创建时间”字段保持一致
		orderType: 'ascending',descending
		type: 默认为LB(负载均衡)；LB：负载均衡，EIP：弹性IP，NAT：NAT，BM：裸金属，SL：专线
`
	NetWorkInventoryQueryDoc = `
		pageNo： 页数 eg: 1
		pageSize： 页码 eg: 10
		regionCode: 按区域搜索 全部请传空
`
	PhsicalServerQueryQueryDoc = `
		pageNo： 页数 eg: 1
		pageSize： 页码 eg: 10
		regionCode: 按区域搜索 全部请传空
		poolName: 资源池名称 必传
`
	PhysicalIpListQueryDoc = `
     poolNameSlice: 资源池名称切片 必传
`
)

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/pkg/models/bm/bm.go
```golang
package bm

type (
	OverviewRsp struct {
		InstanceOverview []OverView   `json:"instanceOverview"`
		CPUOverview      OverviewSlot `json:"cpuOverview"`
		GPUOverview      OverviewSlot `json:"gpuOverview"`
		Distribution     OverviewSlot `json:"distribution"`
	}

	OverviewSlot struct {
		Info   OverviewSlotInfo    `json:"info,omitempty"`
		Values []OverviewSlotValue `json:"values,omitempty"`
	}

	OverviewSlotInfo struct {
		Name     string `json:"name"`
		Unit     string `json:"unit"`
		UnitType string `json:"unitType"`
		Value    int    `json:"value"`
	}

	OverviewSlotValue struct {
		Code     string      `json:"code"`
		Name     string      `json:"name"`
		Unit     string      `json:"unit"`
		UnitType string      `json:"unitType"`
		Value    interface{} `json:"value"`
	}

	OverView struct {
		Name   string      `json:"name"`
		Code   string      `json:"code"`
		Status interface{} `json:"status"`
		Value  interface{} `json:"value"`
	}

	ListReq struct {
		PageNo      int    `json:"pageNo"`
		PageSize    int    `json:"pageSize"`
		SearchType  string `json:"searchType"`  // 搜索类型 (实例名称 name/实例ID id)
		SearchValue string `json:"searchValue"` // 搜索值 (注意要支持模糊搜索)
		OrderCode   string `json:"orderCode"`
		OrderType   string `json:"orderType"`

		Region           string   `json:"region"`           //可用区
		Id               []string `json:"id"`               //实例ID
		InstanceStates   []string `json:"instanceStates"`   //实例状态
		InstanceType     []string `json:"instanceType"`     //实例类型
		Az               []string `json:"az"`               //可用区
		TenantId         []string `json:"tenantId"`         //租户id
		TenantName       []string `json:"tenantName"`       //租户名
		ProjectName      []string `json:"projectName"`      //项目名
		ResourcePoolName string   `json:"resourcePoolName"` //资源池名称

	}
	ListRsp struct {
		TotalCount int        `json:"totalCount"`
		PageNo     int        `json:"pageNo"`
		PageSize   int        `json:"pageSize"`
		DataList   []ListInfo `json:"dataList"`
	}

	ListInfo struct {
		BmConf
		Id               string `json:"id"`
		Name             string `json:"name"`
		InstanceStates   string `json:"instanceStates"` //实例状态 0:运行中 3:已关闭 12:创建失败 14:重装失败  https://wiki.op.ksyun.com/pages/viewpage.action?pageId=180181587
		InstanceType     string `json:"instanceType"`   //实例类型
		SN               string `json:"sn"`
		Region           string `json:"region"`
		RegionName       string `json:"regionName"`
		Az               string `json:"az"`
		AzName           string `json:"azName"`
		TenantId         string `json:"tenantId"`    //租户id
		TenantName       string `json:"tenantName"`  //租户名
		ProjectName      string `json:"projectName"` //项目名
		VpcName          string `json:"vpcName"`
		IntranetIP       string `json:"intranetIP"` //内网ip
		NetworkIP        string `json:"networkIP"`  //外网ip
		Bound            int8   `json:"bound"`      //是否绑定了资源  0:否 1:是
		LineType         string `json:"lineType"`   //线路类型 BGP
		AlarmNum         int    `json:"alarmNum"`   //告警数量
		CreateTime       string `json:"createTime"`
		ResourcePoolName string `json:"resourcePoolName"` //资源池名称
	}

	BmConf struct {
		Cpu     string `json:"cpu"`
		Memory  string `json:"memory"`
		Storage string `json:"storage"`
	}

	DetailReq struct {
		Id string `json:"id"`
	}
	DetailRsp struct {
		//basic
		Id             string `json:"id"`
		Name           string `json:"name"`
		InstanceStates string `json:"instanceStates"` //实例状态
		InstanceType   string `json:"instanceType"`   //实例类型
		Region         string `json:"region"`
		RegionName     string `json:"regionName"`
		Az             string `json:"az"`
		AzName         string `json:"azName"`
		TenantId       string `json:"tenantId"`    //租户id
		TenantName     string `json:"tenantName"`  //租户名
		ProjectName    string `json:"projectName"` //项目名
		CreateTime     string `json:"createTime"`
		//conf
		BmConf
		//network
		Eip           string `json:"eip"`          //弹性ip
		EipBandwidth  string `json:"eipBandwidth"` //Eip带宽
		IntranetIP    string `json:"intranetIP"`   //内网ip
		NetworkIP     string `json:"networkIP"`    //外网ip
		Bound         int    `json:"bound"`        //是否绑定了资源
		LineType      string `json:"lineType"`
		SN            string `json:"sn"`
		HostName      string `json:"hostName"`
		VpcName       string `json:"vpcName"`
		SubNet        string `json:"subNet"`        //子网
		Attribute     string `json:"attribute"`     //属性
		SecurityGroup string `json:"securityGroup"` //安全组
		//other
		Mac      string `json:"mac"`
		RaidType string `json:"raidType"`
		Cabinet  string `json:"cabinet"` //机柜
		Rack     string `json:"rack"`    //机架
		ImageId  string `json:"imageId"` //镜像id
		OsName   string `json:"osName"`  //操作系统名称
	}
)

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/pkg/models/aggregate/aggregate.go
```golang
package aggregate

import (
	"luban-cmdb-api/pkg/models"
	"luban-cmdb-api/pkg/models/storage"

	"github.com/gophercloud/gophercloud/openstack/compute/v2/servers"
)

type PageStruct struct {
	TotalCount int `json:"totalCount"`
	PageNo     int `json:"pageNo"`
	PageSize   int `json:"pageSize"`
}

var AggregatesListQueryDoc string = `
pageNo： 页数，必传eg: 1
pageSize： 页码，必传eg: 10
region:区域;默认值：all
az:可用区;默认值：[]
name:资源池名字;默认值：""
`

type AggregatesListQuery struct {
	models.CommonListReq
	//Count    bool   `json:"count"`
	Region string   `json:"region"`
	Az     []string `json:"az"`
	Name   string   `json:"name"`
}

var AggregateHostListQueryDoc string = `
pageNo： 页数，必传eg: 1
pageSize： 页码，必传eg: 10
status:运行状态;默认值：[]
assignmentStatus:分配状态;默认值：[]
`

type AggregateHostListQuery struct {
	PageNo           int      `json:"pageNo"`
	PageSize         int      `json:"pageSize"`
	Id               string   `json:"id"`
	Status           []string `json:"status"`
	AssignmentStatus []string `json:"assignmentStatus"`
}

var AggregatesUsageQueryDoc string = `
        id:aggregate 必填，eg:[1]
		region:区域;默认值：all
		az:可用区;默认值：[]
		pageNo:eg:1,页码，默认值1
		pageSize:eg:10, 页大小，默认值10
		orderCode:The orderCode of order.eg:cpuUsage;memoryRate
		orderType:The orderType of order.eg:升：asc;降：desc
`

type AggregatesUsageQuery struct {
	PageNo    int      `json:"pageNo"`
	PageSize  int      `json:"pageSize"`
	Id        []string `json:"id"`
	Region    string   `json:"region"`
	Az        []string `json:"az"`
	OrderCode string   `json:"orderCode"`
	OrderType string   `json:"orderType"`
}

var AggregatesVmsQueryDoc string = `
pageNo： 页数，必传eg: 1
pageSize： 页码，必传eg: 10
status:运行状态;默认值：[]
`

type AggregatesVmsQuery struct {
	PageNo   int      `json:"pageNo"`
	PageSize int      `json:"pageSize"`
	Id       string   `json:"id"`
	Status   []string `json:"status"`
}

type PhysicalHostResourceQuery struct {
	PageNo   int `json:"pageNo"`
	PageSize int `json:"pageSize"`
	//Count    bool   `json:"count"`
	ServerName   string `json:"serverName"`
	Az           string `json:"az"`
	ResourcePool string `json:"resourcePool"`
}

type VMQuery struct {
	Id        string `json:"id"`
	Az        string `json:"az"`
	Aggregate string `json:"aggregate"`
}

var HostVMListQueryDoc string = `
pageNo： 页数，必传eg: 1
pageSize： 页码，必传eg: 10
status:运行状态;默认值：[]
`

type HostVMListQuery struct {
	PageNo     int      `json:"pageNo"`
	PageSize   int      `json:"pageSize"`
	ServerName string   `json:"serverName"`
	Status     []string `json:"status"`
}

var VMListQueryDoc string = `
pageNo： 页数，必传eg: 1
pageSize： 页码，必传eg: 10
region:必传eg: all
az:默认值: []
name:默认值 ""
id:默认值 ""
tenantId:默认值 ""
status:运行状态;默认值：[]
aggregate:所属资源池
hypervisor:所属服务器
innerIp:内网IP
publicIp:外网IP
`

type VMListQuery struct {
	PageNo      int      `json:"pageNo"`
	PageSize    int      `json:"pageSize"`
	Region      string   `json:"region"`
	Az          []string `json:"az"`
	Name        string   `json:"name"`
	Id          string   `json:"id"`
	TenantId    string   `json:"tenantId"`
	Status      []string `json:"status"`
	Flavor      string   `json:"flavor"`
	Aggregate   *string  `json:"aggregate"`
	Aggregates  []string `json:"aggregates"`
	AggregateId int      `json:"aggregateId"`
	Hypervisor  string   `json:"hypervisor"`
	InnerIP     string   `json:"innerIp"`
	PublicIP    string   `json:"publicIp"`

	SearchType  string `json:"searchType"`  // 搜索类型 (实例名称 name/实例ID id/租户ID tenantId)
	SearchValue string `json:"searchValue"` // 搜索值 (注意要支持模糊搜索)
}

type AggregatesResult struct {
	PageStruct
	DataList []Aggregates `json:"dataList" description:"paging data"`
	//TotalCount int          `json:"total_count" description:"total count"`
}

type AggregatesUsageResult struct {
	PageStruct
	DataList []AggregatesUsage `json:"dataList"`
}

type Aggregates struct {
	Name       string            `json:"name"`
	Id         int               `json:"id"`
	Service    string            `json:"service"`
	Region     string            `json:"region"`
	Az         string            `json:"az"`
	RegionCode string            `json:"regionCode"`
	AzCode     string            `json:"azCode"`
	HostCount  int               `json:"hostCount"`
	Hosts      []string          `json:"hosts"`
	VMCount    int               `json:"vmCount"`
	VMs        []servers.Server  `json:"vms"`
	Metadata   map[string]string `json:"metadata"`
	CreateTime int64             `json:"createTime"`
}

type AggregatesVms struct {
	PageStruct
	DataList              []AggregatesVm           `json:"dataList" description:"paging data"`
	ListOptionalCondition map[string][]interface{} `json:"listOptionalCondition"`
}

type AggregatesVm struct {
	ID   string `json:"id"`
	Name string `json:"name"`
	//Flavor     interface{} `json:"flavor"`
	Flavor      string `json:"flavor"`
	Status      string `json:"status"`
	Aggregate   string `json:"aggregate"`
	AggregateId int    `json:"aggregateId"`
	Region      string `json:"region"`
	RegionCode  string `json:"regionCode"`
	Az          string `json:"az"`
	AzCode      string `json:"azCode"`
	TenantId    string `json:"tenantId"`
	TenantName  string `json:"tenantName"`
	Hypervisor  string `json:"hypervisor"`
	InnerIP     string `json:"innerIp"`
	PublicIP    string `json:"publicIp"`
	//CreateTime time.Time `json:"createTime"`
	CreateTime int64  `json:"createTime"`
	Tags       string `json:"tags"`
	ImageId    string `json:"imageId"`
	AdminPass  string `json:"adminPass"`
}

type AggregatesHosts struct {
	DataList   []AggregatesHost `json:"dataList" description:"paging data"`
	PageStruct                  //int              `json:"totalCount" description:"total count"`
}

type AggregatesHost struct {
	Id               string `json:"id"`
	Name             string `json:"name"`
	Status           string `json:"status"`
	AssignmentStatus string `json:"assignmentStatus"`
	ResourcePoolType string `json:"resourcePoolType"`
	ResourcePool     string `json:"resourcePool"`
	Service          string `json:"service"`
	Region           string `json:"region"`
	Az               string `json:"az"`
	Room             string `json:"room"`
	Rack             string `json:"rack"`
	RackPosition     int    `json:"rackPosition"`
	SN               string `json:"sn"`
	Ip               string `json:"ip"`
}

type AggregatesUsage struct {
	Id           int     `json:"id"`
	Name         string  `json:"name"`
	Region       string  `json:"region"`
	RegionCode   string  `json:"regionCode"`
	Az           string  `json:"az"`
	AzCode       string  `json:"azCode"`
	UsableCount  int     `json:"usableCount"`
	VCPUTotal    int     `json:"cpuTotal"`
	VCPUUsage    int     `json:"cpuUsage"`
	VCPURemain   int     `json:"cpuRemain"`
	VCPURate     float64 `json:"cpuRate"`
	MemoryTotal  float64 `json:"memoryTotal"`
	MemoryUsage  float64 `json:"memoryUsage"`
	MemoryRemain float64 `json:"memoryRemain"`
	MemoryRate   float64 `json:"memoryRate"`
	InstanceType string  `json:"instanceType"`
	PType        string  `json:"pType" description:"机型"`
	CreateTime   int64   `json:"createTime"`
}

type VmDetail struct {
	Id                     string                 `json:"id"`
	TenantId               string                 `json:"tenantId"`
	TenantName             string                 `json:"tenantName"`
	Status                 string                 `json:"status"`
	Name                   string                 `json:"name"`
	Aggregate              string                 `json:"aggregate"`
	AggregateId            int                    `json:"aggregateId"`
	Region                 string                 `json:"region"`
	RegionCode             string                 `json:"regionCode"`
	Az                     string                 `json:"az"`
	AzCode                 string                 `json:"azCode"`
	Host                   string                 `json:"host"`
	VmName                 string                 `json:"vmName"`
	Business               string                 `json:"business"`
	OpsLabel               string                 `json:"opsLabel"`
	Label                  string                 `json:"label"`
	ImageId                string                 `json:"imageId"`
	DataGuardSet           string                 `json:"dataGuardSet"`
	AdminPass              string                 `json:"adminPass"`
	CreateTime             int64                  `json:"create_time"`
	EndTime                int64                  `json:"endTime"`
	DeleteTime             int64                  `json:"deleteTime"`
	InstanceType           string                 `json:"instanceType"`
	Size                   string                 `json:"size"`
	Os                     string                 `json:"os"`
	SysDisk                string                 `json:"sys_disk"`
	DataDisk               string                 `json:"data_disk"`
	INCId                  string                 `json:"incId"`
	EIp                    string                 `json:"eIp"`
	DNS1                   string                 `json:"dns1"`
	DNS2                   string                 `json:"dns2"`
	InternetIpV4           string                 `json:"internetIpv4"`
	SecurityGroup          string                 `json:"securityGroup"`
	VPC                    string                 `json:"vpc"`
	SubNetwork             string                 `json:"subNetwork"`
	InnerIp                string                 `json:"innerIp"`
	NetworkList            []NetworkData          `json:"networkData"`
	KeySet                 []string               `json:"keySet"`
	KeyList                []KeyData              `json:"keyList"`
	DataGuardList          []DataGuardSetData     `json:"dataGuardsSet"`
	SecurityList           []SecurityGroupSetData `json:"securityList"`
	LocalVolumeSetDataList []LocalVolumeSetData   `json:"localVolumeSetDataList"`
	VmVolumeSetDataList    []storage.DiskDetail   `json:"vmVolumeSetDataList"`
	EBSVolumes             []EBSVolume            `json:"ebsVolumes"`
	HostName               string                 `json:"hostname"`
	MetricDir              []string               `json:"metricDir"`
}

type EBSVolume struct {
	DirectorName     string `json:"director_name"`
	Region           string `json:"region"`
	PersonName       string `json:"person_name"`
	DeleteTime       string `json:"delete_time"`
	Status           int    `json:"status"`
	VmId             string `json:"vm_id"`
	VolumeType       string `json:"volume_type"`
	VolumeState      string `json:"volume_state"` // 硬盘状态: https://wiki.op.ksyun.com/pages/viewpage.action?pageId=50201463
	VolumeSize       int    `json:"volume_size"`
	BillType         int    `json:"bill_type"`
	VolumeId         string `json:"volume_id"`
	CompanyName      string `json:"company_name"`
	ServiceBeginTime string `json:"service_begin_time"`
	ServiceEndTime   string `json:"service_end_time"`
	VolumeName       string `json:"volume_name"`
	CreateTime       string `json:"create_time"`
	UserId           int    `json:"user_id"`
	Zone             string `json:"zone"`
	VolumeCategory   string `json:"volume_category"`
	OrderType        int    `json:"order_type"`
}

type NetworkData struct {
	NetworkInterfaceId   string `json:"networkInterfaceId"`
	NetworkInterfaceType string `json:"networkInterfaceType"`
	VpcName              string `json:"vpcName"`
	SubnetName           string `json:"subnetName"`
	PrivateIpAddress     string `json:"privateIpAddress"`
	Az                   string `json:"az"`
	//SecurityGroupSet     []SecurityGroupSetData `json:"SecurityGroupSet"`
}

type VmFromNova struct {
	Server      []servers.Server `json:"server"`
	Aggregate   string           `json:"aggregate"`
	AggregateId int              `json:"aggregateId"`
	Az          string           `json:"az"`
	BelongHost  string           `json:"belongHost"`
}

//云主机概览页面struct
type OverviewQuery struct {
	Region string `json:"region"`
	Az     string `json:"az"`
	//Id     string `json:"id"`
}
type DistributedOverviewSlice []DistributedOverView
type AggregateOverview struct {
	ReasourcePoolOverview ReasourcePoolOverviewData `json:"reasourcePoolOverview"`
	DistributedOverview   DistributedOverviewSlice  `json:"distributedOverview"`
	InstanceOverview      []OverView                `json:"instanceOverview"`
}

//CMDB 计算资源池概览页struct
type CMDBOverViewQuery struct {
	Region   string `json:"region"`
	Az       string `json:"az"`
	DiskType string `json:"diskType"`
}
type CMDBAggregateOverview struct {
	CpuRate          []DistributedOverView1 `json:"cpuRate"`
	MemaryRate       []DistributedOverView1 `json:"MemaryRate"`
	DiskRate         []DistributedOverView1 `json:"DiskRate"`
	InstanceOverview []OverView1            `json:"instanceOverview"`
}

type OverView1 struct {
	Name     string      `json:"name"`
	Code     string      `json:"code"`
	UnitType string      `json:"unitType"`
	Value    interface{} `json:"value"`
	Unit     interface{} `json:"unit"`
}

type DistributedOverView1 struct {
	Name        string      `json:"name"`
	Id          int         `json:"Id"`
	Distributed []OverView1 `json:"distributed"`
	//Distributed2 OverView `json:"distributed2"`
}

func (s DistributedOverviewSlice) Len() int {
	return len(s)
}

func (s DistributedOverviewSlice) Less(i, j int) bool {
	return s[i].Region < s[j].Region || s[i].Az < s[j].Az
}

func (s DistributedOverviewSlice) Swap(i, j int) {
	s[i], s[j] = s[j], s[i]
}

type ReasourcePoolOverviewData struct {
	Title string     `json:"title"`
	Totle int        `json:"totle"`
	Unit  string     `json:"unit"`
	Data  []OverView `json:"data"`
}

type OverView struct {
	Name   string      `json:"name"`
	Code   string      `json:"code"`
	Status string      `json:"status"`
	Value  interface{} `json:"value"`
}
type DistributedOverView struct {
	Name        string     `json:"name"`
	Region      string     `json:"region"`
	Az          string     `json:"az"`
	Distributed []OverView `json:"distributed"`
	//Distributed2 OverView `json:"distributed2"`
}

//获取云主机详情query
type VmDetailQuery struct {
	Action     string            `json:"action"`     //公共参数，本接口取值：DescribeInstances
	Version    string            `json:"version"`    //公共参数，本接口取值：2016-03-04
	MaxResults string            `json:"maxResults"` //单次调用所返回的最大实例数目,默认值是10
	Marker     string            `json:"marker"`     //分页标识,默认值是0
	InstanceId []string          `json:"instanceId"` //待返回描述信息的实例ID列表
	Filter     map[string]string `json:"filter"`     //一个或者多个过滤器
	Sort       string            `json:"sort"`       //筛选器
	Search     string            `json:"search"`     //搜索条件
	ProjectId  []string          `json:"projectId"`  //项目制id列表

	Region   string `json:"region"`
	UserName string `json:"UserName"` //例如：180000000
}

//获取云主机详情detail
type VmDetailFromNova struct {
	Marker        int                `json:"marker"`
	InstanceCount int                `json:"InstanceCount"`
	RequestId     string             `json:"RequestId"`
	InstancesSet  []InstancesSetData `json:"InstancesSet"`
}
type InstancesSetData struct {
	InstanceId        string                `json:"InstanceId"`
	ProjectId         int                   `json:"ProjectId"`
	InstanceName      string                `json:"InstanceName"`
	InstanceType      string                `json:"instanceType"`
	InstanceConfigure InstanceConfigureData `json:"InstanceConfigure"`
	ImageId           string                `json:"ImageId"`
	SubnetId          string                `json:"SubnetId"`
	PrivateIpAddress  string                `json:"PrivateIpAddress"`
	InstanceState     InstanceStateData     `json:"InstanceState"`
	//Monitoring            string                    `json:"Monitoring"`
	Monitoring          interface{}               `json:"Monitoring"`
	NetworkInterfaceSet []NetworkInterfaceSetData `json:"NetworkInterfaceSet"`
	SriovNetSupport     string                    `json:"SriovNetSupport"`
	//IsShowSriovNetSupport string                    `json:"IsShowSriovNetSupport"`
	IsShowSriovNetSupport interface{}    `json:"IsShowSriovNetSupport"`
	CreationDate          string         `json:"CreationDate"`
	AvailabilityZone      string         `json:"AvailabilityZone"`
	AvailabilityZoneName  string         `json:"AvailabilityZoneName"`
	SystemDisk            SystemDiskData `json:"SystemDisk"`
	HostName              string         `json:"HostName"`
	//Migration             string             `json:"Migration"`
	Migration      interface{}        `json:"Migration"`
	DataDisks      []DataDiskData     `json:"DataDisks"`
	AutoDeleteTime string             `json:"AutoDeleteTime"`
	DataGuardSet   []DataGuardSetData `json:"DataGuardSet"`
	KeySet         []string           `json:"KeySet"`
}
type InstanceConfigureData struct {
	VCPU     int `json:"VCPU"`
	GPU      int `json:"GPU"`
	MemoryGb int `json:"MemoryGb"`
	//DataDiskGb   string `json:"DataDiskGb"`
	DataDiskGb interface{} `json:"DataDiskGb"`
	//RootDiskGb   string      `json:"RootDiskGb"`
	RootDiskGb   interface{} `json:"RootDiskGb"`
	DataDiskType string      `json:"DataDiskType"`
	VGPU         string      `json:"VGPU"`
}
type InstanceStateData struct {
	Name string `json:"Name"`
}
type MonitoringData struct {
	State string `json:"State"`
}
type NetworkInterfaceSetData struct {
	NetworkInterfaceId   string                 `json:"NetworkInterfaceId"`
	NetworkInterfaceType string                 `json:"NetworkInterfaceType"`
	VpcId                string                 `json:"VpcId"`
	VpcName              string                 `json:"VpcName"`
	DNS1                 string                 `json:"DNS1"`
	DNS2                 string                 `json:"DNS2"`
	SubnetId             string                 `json:"SubnetId"`
	SubnetName           string                 `json:"SubnetName"`
	SecurityGroupId      string                 `json:"SecurityGroupId"`
	SecurityGroupName    string                 `json:"SecurityGroupName"`
	MacAddress           string                 `json:"MacAddress"`
	PrivateIpAddress     string                 `json:"PrivateIpAddress"`
	GroupSet             []GroupSetData         `json:"GroupSet"`
	SecurityGroupSet     []SecurityGroupSetData `json:"SecurityGroupSet"`
}
type GroupSetData struct {
	GroupId string `json:"GroupId"`
}
type SecurityGroupSetData struct {
	SecurityGroupId       string               `json:"SecurityGroupId"`
	SecurityGroupName     string               `json:"SecurityGroupName"`
	SecurityGroupType     string               `json:"SecurityGroupType"`
	VpcId                 string               `json:"VpcId"`
	VpcName               string               `json:"VpcName"`
	CreateTime            string               `json:"CreateTime"`
	SecurityGroupEntrySet []SecurityGroupEntry `json:"SecurityGroupEntrySet"`
	InCount               int                  `json:"inCount"`
	OutCount              int                  `json:"outCount"`
}

type SystemDiskData struct {
	DiskType string `json:"DiskType"`
	DiskSize int    `json:"DiskSize"`
}
type DataGuardSetData struct {
	DataGuardId       string `json:"DataGuardId"`
	DataGuardName     string `json:"DataGuardName"`
	DataGuardLevel    string `json:"DataGuardLevel"`
	DataGuardCapacity string `json:"DataGuardCapacity"`
	DataGuardUsedSize string `json:"DataGuardUsedSize"`
}

//网络信息struct列表
type NetworkInterfaceData struct {
	RequestId           string                    `json:"RequestId"`
	NetworkInterfaceSet []NetworkInterfaceSetData `json:"NetworkInterfaceSet"`
}

//密钥对列表
type KeyResult struct {
	KeySet     []KeyData `json:"KeySet"`
	RequestId  string    `json:"RequestId"`
	TotalCount int       `json:"TotalCount"`
	NextToken  string    `json:"NextToken"`
}
type KeyData struct {
	KeyId      string `json:"KeyId"`
	PublicKey  string `json:"PublicKey"`
	CreateTime string `json:"CreateTime"`
	KeyName    string `json:"KeyName"`
}

//容灾组列表
type DataGuardResult struct {
	RequestId     string             `json:"RequestId"`
	DataGuardList []DataGuardSetData `json:"DataGuardsSet"`
}

//安全组列表
type SecurityGroupResult struct {
	RequestId        string                 `json:"RequestId"`
	SecurityGroupSet []SecurityGroupSetData `json:"SecurityGroupSet"`
}
type SecurityGroupEntry struct {
	SecurityGroupEntryId string `json:"SecurityGroupEntryId"`
	CidrBlock            string `json:"CidrBlock"`
	Direction            string `json:"Direction"`
	Protocol             string `json:"Protocol"`
}

//本地盘列表
type LocalVolumeResult struct {
	RequestId        string               `json:"RequestId"`
	Marker           int                  `json:"Marker"`
	LocalVolumeCount int                  `json:"LocalVolumeCount"`
	LocalVolumeSet   []LocalVolumeSetData `json:"LocalVolumeSet"`
}
type LocalVolumeSetData struct {
	LocalVolumeId       string `json:"LocalVolumeId"`
	LocalVolumeName     string `json:"LocalVolumeName"`
	LocalVolumeState    string `json:"LocalVolumeState"`
	InstanceId          string `json:"InstanceId"`
	InstanceName        string `json:"InstanceName"`
	InstanceState       string `json:"InstanceState"`
	LocalVolumeType     string `json:"LocalVolumeType"`
	LocalVolumeCategory string `json:"LocalVolumeCategory"`
	LocalVolumeSize     int    `json:"LocalVolumeSize"`
	CreationDate        string `json:"CreationDate"`
}

//数据盘
type DataDiskData struct {
	DiskId   string `json:"DiskId"`
	DiskType string `json:"DiskType"`
	DiskSize int    `json:"DiskSize"`
}

//EIP
type EipResult struct {
	RequestId    string    `json:"RequestId"`
	AddressesSet []EipData `json:"AddressesSet"`
}
type EipData struct {
	PublicIp     string `json:"PublicIp"`
	AllocationId string `json:"AllocationId"`
	State        string `json:"State"`
	LineId       string `json:"LineId"`
	BandWidth    int    `json:"BandWidth"`
	InstanceType string `json:"InstanceType"`
	InstanceId   string `json:"InstanceId"`
	ChargeType   string `json:"ChargeType"`
	IpVersion    string `json:"IpVersion"`
	ProjectId    string `json:"ProjectId"`
	CreateTime   string `json:"CreateTime"`
	PassThrough  string `json:"PassThrough"`
}

//镜像 系统
type ImageResult struct {
	RequestId string      `json:"RequestId"`
	ImagesSet []ImageData `json:"ImagesSet"`
}
type ImageData struct {
	ImageId          string `json:"ImageId"`
	Name             string `json:"Name"`
	ImageState       string `json:"ImageState"`
	CreationDate     string `json:"CreationDate"`
	Platform         string `json:"Platform"`
	IsPublic         bool   `json:"IsPublic"`
	InstanceId       string `json:"InstanceId"`
	IsNpe            bool   `json:"IsNpe"`
	UserCategory     string `json:"UserCategory"`
	SysDisk          int    `json:"SysDisk"`
	Progress         string `json:"Progress"`
	ImageSource      string `json:"ImageSource"`
	CloudInitSupport string `json:"CloudInitSupport"`
	Ipv6Support      bool   `json:"Ipv6Support"`
	IpVersion        bool   `json:"IpVersion"`
	IsModifyType     bool   `json:"IsModifyType"`
	IsCloudMarket    bool   `json:"IsCloudMarket"`
}

type AggregateHost struct {
	Id           int    `json:"id"`
	HostName     string `json:"name"`
	RegionName   string `json:"regionName"`
	RegionCode   string `json:"regionCode"`
	AzName       string `json:"azName"`
	AzCode       string `json:"azCode"`
	StorageType  string `json:"storageType"`
	ResourcePool string `json:"resourcePool"`
	Ip           string `json:"ip"`
}

type PTypeConfig struct {
	PType           int             `json:"p_type"`
	PName           string          `json:"p_name"`
	SystemDisk      string          `json:"systemDisk"`
	InstructionSet  int             `json:"instruction_set"`
	ImageModel      string          `json:"image_model"`
	PGroup          int             `json:"p_group"`
	FlavorAggregate FlavorAggregate `json:"flavor_aggregate"`
}

type FlavorAggregate struct {
	Cluster     string `json:"cluster"`
	VmAttr      string `json:"vm_attr"`
	StorageType string `json:"storage_type"`
}

type ListMetricsResponse struct {
	ListMetricsResult `json:"listMetricsResult"`
	ResponseMetadata  interface{} `json:"responseMetadata"`
}
type ListMetricsResult struct {
	Metrics `json:"metrics"`
}
type Metrics struct {
	Members []Member `json:"member"`
}

type Member struct {
	InstanceId string `json:"instanceId"`
	MetricName string `json:"metricName"`
	Namespace  string `json:"namespace"`
	Interval   string `json:"interval"`
	Type       string `json:"type"`
	Unit       string `json:"unit"`
}

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/pkg/models/aggregate/storage.go
```golang
package aggregate

import (
	"context"
	"encoding/json"
	"luban-cmdb-api/pkg/gredis"
	"strings"
	"time"

	"k8s.io/klog/v2"
)

var AggregatesVmMap []AggregatesVm

//从缓存中取出云主机
func GetAggregatesVmMap() (vmDL []VmDetail) {
	ctx, cefl := context.WithTimeout(context.Background(), 5*time.Second)
	defer cefl()
	//rs, err := gredis.SMembers(ctx, gredis.AggregatesVmMapKey)
	rs, err := gredis.HGetAll(ctx, gredis.AggregatesVmMapKey)
	if err != nil {
		klog.Error("AggregatesVmMap read from redis failure:", err.Error())
		return vmDL
	}
	var resultList []string
	for _, vmStr := range rs {
		resultList = append(resultList, vmStr)
	}
	rsStr := "[" + strings.Join(resultList, ",") + "]"
	err = json.Unmarshal([]byte(rsStr), &vmDL)
	if err != nil {
		klog.Error("AggregatesVmMap Unmarshal failure:", err.Error())
		return vmDL
	}
	return vmDL
}

//从缓存中取出云主机单条
func GetAggregateVm(key string) (vmDL VmDetail, err error) {
	ctx, cefl := context.WithTimeout(context.Background(), 5*time.Second)
	defer cefl()
	//rs, err := gredis.SMembers(ctx, gredis.AggregatesVmMapKey)
	rs, err := gredis.HGet(ctx, gredis.AggregatesVmMapKey, key)
	if err != nil {
		//klog.Error("AggregatesVmMap read from redis failure:", err.Error())
		return vmDL, err
	}
	err = json.Unmarshal([]byte(rs), &vmDL)
	if err != nil {
		klog.Error("AggregatesVmMap Unmarshal failure:", err.Error())
		return vmDL, err
	}
	return vmDL, err
}

//从缓存中取出资源池
func GetAggregateMap() (aggregates []Aggregates) {
	ctx, cefl := context.WithTimeout(context.Background(), 5*time.Second)
	defer cefl()
	//rs, err := gredis.SMembers(ctx, gredis.AggregatesVmMapKey)
	rs, err := gredis.HGetAll(ctx, gredis.AggregatesMapKey)
	if err != nil {
		klog.Error("AggregatesVmMap read from redis failure:", err.Error())
		return
	}
	var resultList []string
	for _, str := range rs {
		resultList = append(resultList, str)
	}
	rsStr := "[" + strings.Join(resultList, ",") + "]"
	err = json.Unmarshal([]byte(rsStr), &aggregates)
	if err != nil {
		klog.Error("AggregatesVmMap Unmarshal failure:", err.Error())
		return
	}
	return
}

//从缓存中取出资源池库存
func GetAggregateUsageMap() (aggregatesUsage []AggregatesUsage) {
	ctx, cefl := context.WithTimeout(context.Background(), 5*time.Second)
	defer cefl()
	//rs, err := gredis.SMembers(ctx, gredis.AggregatesVmMapKey)
	rs, err := gredis.HGetAll(ctx, gredis.AggregatesUsageMapKey)
	if err != nil {
		klog.Error("AggregatesUsageVmMap read from redis failure:", err.Error())
		return
	}
	var resultList []string
	for _, str := range rs {
		resultList = append(resultList, str)
	}
	rsStr := "[" + strings.Join(resultList, ",") + "]"
	err = json.Unmarshal([]byte(rsStr), &aggregatesUsage)
	if err != nil {
		klog.Error("AggregatesUsageVmMap Unmarshal failure:", err.Error())
		return
	}
	return
}

//从缓存中取出资源池
func GetAggregateVmCount() (result map[string]int) {
	vms := GetAggregatesVmMap()
	result = make(map[string]int)
	for _, vm := range vms {
		var name = vm.Aggregate
		if name == "" {
			name = "--"
		}
		result[name]++
	}
	return
}

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/pkg/models/nat/nat.go
```golang
package nat

type (
	NatPartListReq struct {
		InstanceId string `json:"instanceId"`
		PageNo     int    `json:"pageNo"`
		PageSize   int    `json:"pageSize"`
		EgressType *int   `json:"egressType"` // 1 已限速，0 未限速
	}

	NatPartListRsp struct {
		TotalCount int         `json:"totalCount"`
		PageNo     int         `json:"pageNo"`
		PageSize   int         `json:"pageSize"`
		DataList   interface{} `json:"dataList"`
	}

	NatOverviewReq struct {
		Region string `json:"region"` //可用区
	}

	NatOverviewRsp struct {
		//TypeOverview        TypeOverviewData      `json:"typeOverview"`
		DistributedOverview []DistributedOverView `json:"distributedOverview"`
		InstanceOverview    []OverView            `json:"instanceOverview"`
	}

	DistributedOverView struct {
		Name        string     `json:"name"`
		Region      string     `json:"region"`
		Az          string     `json:"az"`
		Distributed []OverView `json:"distributed"`
	}

	TypeOverviewData struct {
		Title string     `json:"title"`
		Totle int        `json:"totle"`
		Unit  string     `json:"unit"`
		Data  []OverView `json:"data"`
	}

	OverView struct {
		Name   string      `json:"name"`
		Code   string      `json:"code"`
		Status string      `json:"status"`
		Value  interface{} `json:"value"`
	}

	GetNatResourceListReq struct {
		PageNo   int `json:"pageNo"`
		PageSize int `json:"pageSize"`

		Region           string `json:"region"`           //可用区
		ResourcePoolName string `json:"resourcePoolName"` //资源池名称

		//单选
		Scope   []string `json:"scope"`   //作用范围  [classic,custom] 所属的vpc,绑定的子网
		NatType []string `json:"natType"` //类型 ['public', 'private']

		//多选
		VpcName     []string `json:"vpcName"`     //所属VPC
		TenantId    []string `json:"tenantId"`    //租户ID
		TenantName  []string `json:"tenantName"`  //租户名称
		ProjectName []string `json:"projectName"` //所属项目名称 默认项目

		SearchType  string `json:"searchType"`  // 搜索类型 (实例名称)
		SearchValue string `json:"searchValue"` // 搜索值 (注意要支持模糊搜索)

		OrderCode string `json:"orderCode"`
		OrderType string `json:"orderType"`
	}

	GetNatResourceListRsp struct {
		TotalCount int       `json:"totalCount"`
		PageNo     int       `json:"pageNo"`
		PageSize   int       `json:"pageSize"`
		DataList   []NatInfo `json:"dataList"`
	}

	NatInfo struct {
		PoolId           int    `json:"poolId"`
		ResourcePoolName string `json:"resourcePoolName"` //资源池名称
		InstanceName     string `json:"instanceName"`     //实例名称
		InstanceId       string `json:"instanceId"`       //实例ID
		VpcName          string `json:"vpcName"`          //所属VPC
		Scope            string `json:"scope"`            //作用范围    [classic,custom] 所属的vpc,绑定的子网
		NatType          string `json:"natType"`          //类型       ['public', 'private'] 公网 内网
		Region           string `json:"region"`           //区域
		RegionName       string `json:"regionName"`       //区域名称
		TenantId         string `json:"tenantId"`         //租户ID
		TenantName       string `json:"tenantName"`       //租户名称
		ProjectName      string `json:"projectName"`      //所属项目名称 默认项目
		Bandwidth        int    `json:"bandwidth"`        //带宽
		BoundSubNetNum   int    `json:"boundSubNetNum"`   //绑定子网数量
		CreateTime       int    `json:"createTime"`       //创建时间  秒级时间戳

		Natipallocations []Natipallocation `json:"natipallocations"`
		Snats            []Snat            `json:"snats"`
		Dnatrules        []Dnatrule        `json:"dnatrules"`
		ServerLimits     []ServerLimit     `json:"serverLimits"`
	}

	Natipallocation struct {
		IPAddress string `json:"ipAddress"`
		ID        string `json:"id"`
	}

	Dnatrule struct {
		ID           string `json:"id"`
		Name         string `json:"name"`         //规则名称
		Natip        string `json:"natip"`        //NAT IP
		Protocol     string `json:"protocol"`     //协议类型   ['TCP', 'UDP', 'ANY']
		NatipPort    int    `json:"natipPort"`    //公网端口
		InternalIP   string `json:"internalIp"`   //私网IP
		InternalPort int    `json:"internalPort"` //私网端口
		Description  string `json:"description"`  //备注
		CreatedAt    string `json:"createdAt"`    //创建时间
	}

	Snat struct {
		ServerName string `json:"serverName"` // 主机名称
		ServerIp   string `json:"serverIp"`   // 云服务器IP
		VifId      string `json:"vifId"`      // 网卡ID
		VifType    string `json:"vifType"`    // 网卡属性     主网卡,副网卡,弹性网卡 ['primary', 'extension', 'eni']
	}

	ServerLimit struct {
		ServerIp   string `json:"serverIp"`   //IP地址
		ServerType string `json:"serverType"` //资源类型       host_type  虚拟机，物理机，容器   ['vm', 'physical', 'docker','smartnic']
		ServerName string `json:"serverName"` //资源名称
		VifId      string `json:"vifId"`      //网卡ID
		EgressType int    `json:"egressType"` // 1 已限速，0 未限速
		Egress     int    `json:"egress"`     //出向带宽上限
	}
)

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/pkg/models/lb/lb.go
```golang
package lb

type (
	LbPartListReq struct {
		InstanceId string `json:"instanceId"`
		PageNo     int    `json:"pageNo"`
		PageSize   int    `json:"pageSize"`
	}

	LbPartListRsp struct {
		TotalCount int         `json:"totalCount"`
		PageNo     int         `json:"pageNo"`
		PageSize   int         `json:"pageSize"`
		DataList   interface{} `json:"dataList"`
	}

	LbOverviewReq struct {
		Region string `json:"region"` //可用区
	}

	LbOverviewRsp struct {
		InstanceOverview    []OverView     `json:"instanceOverview"`
		TypeOverview        []OverviewSlot `json:"typeOverview"`
		DistributedOverview []OverviewSlot `json:"distributedOverview"`
	}

	DistributedOverView struct {
		Name        string     `json:"name"`
		Region      string     `json:"region"`
		Az          string     `json:"az"`
		Distributed []OverView `json:"distributed"`
	}

	TypeOverviewData struct {
		Title string     `json:"title"`
		Totle int        `json:"totle"`
		Unit  string     `json:"unit"`
		Data  []OverView `json:"data"`
	}

	OverView struct {
		Name   string      `json:"name"`
		Code   string      `json:"code"`
		Status string      `json:"status"`
		Value  interface{} `json:"value"`
	}

	OverviewSlot struct {
		Info   SlotInfo    `json:"info"`
		Values []SlotValue `json:"values"`
	}
	SlotInfo struct {
		Name     string `json:"name"`
		Value    int    `json:"value"`
		UnitType string `json:"unitType"`
		Unit     string `json:"unit"`
	}
	SlotValue struct {
		Code     string `json:"code"`
		Name     string `json:"name"`
		Value    int    `json:"value"`
		Unit     string `json:"unit"`
		UnitType string `json:"unitType"` // storage【存储】、percent【百分比】、number【数值】
		Kind     string `json:"kind"`
	}

	GetLbResourceListReq struct {
		PageNo   int `json:"pageNo"`
		PageSize int `json:"pageSize"`

		Region           string `json:"region"`           //可用区
		ResourcePoolName string `json:"resourcePoolName"` //资源池名称

		State        []string `json:"state"`        //状态 开启 已停止 [active,stop]
		InstanceType []string `json:"instanceType"` //实例类型 ['default', 'application']  经典型， 应用型
		NetType      []string `json:"netType"`      //网络类型  公网 私网 [public,private]
		TenantId     []string `json:"tenantId"`
		TenantName   []string `json:"tenantName"`
		ProjectName  []string `json:"projectName"`
		LineType     []string `json:"lineType"` //线路类型 [bgp,private]

		SearchType  string `json:"searchType"`  // 搜索类型 (实例名称/后端服务ID/后端服务内网IP)
		SearchValue string `json:"searchValue"` // 搜索值 (注意要支持模糊搜索)

		OrderCode string `json:"orderCode"`
		OrderType string `json:"orderType"`
	}

	GetLbResourceListRsp struct {
		TotalCount int      `json:"totalCount"`
		PageNo     int      `json:"pageNo"`
		PageSize   int      `json:"pageSize"`
		DataList   []LbInfo `json:"dataList"`
	}

	LbInfo struct {
		ResourcePoolType string `json:"resourcePoolType"` //资源池类型
		ResourcePoolName string `json:"resourcePoolName"` //资源池名称
		Region           string `json:"region"`           //区域

		InstanceName    string `json:"instanceName"`    //实例名称
		InstanceId      string `json:"instanceId"`      //实例id
		State           string `json:"state"`           //状态 开启 已停止 [active,stop]
		InstanceType    string `json:"instanceType"`    //实例类型 经典型 应用型 ['default', 'application']
		IpVersion       string `json:"ipVersion"`       //IP版本 4 6
		NetType         string `json:"netType"`         //网络类型  公网 私网 [public,private]
		TenantId        string `json:"tenantId"`        //租户ID
		TenantName      string `json:"tenantName"`      //租户名称
		ProjectId       string `json:"projectId"`       //所属项目id
		ProjectName     string `json:"projectName"`     //所属项目名称 默认项目
		VPCInstanceName string `json:"vpcInstanceName"` //VPC实例名称
		Eip             string `json:"eip"`             //弹性IP
		LineType        string `json:"lineType"`        //线路类型 [bgp,private]
		ListenerNum     int    `json:"listenerNum"`     //监听器数量
		CreateTime      int    `json:"createTime"`      //创建时间  秒级时间戳

		Listeners []Listener `json:"listeners"`
	}

	Listener struct {
		Name            string `json:"name"`            //名称
		ID              string `json:"id"`              //id
		State           bool   `json:"state"`           //状态  开启
		NetworkProtocol string `json:"networkProtocol"` //协议  HTTP  HTTPS
		Port            int    `json:"port"`            //监听端口
		ForwardType     string `json:"forwardType"`     //转发方式 轮询
		KeepAlive       bool   `json:"keepAlive"`       //会话保持 开启
		HealthCheck     bool   `json:"healthCheck"`     //健康检查 开启
		ACL             string `json:"acl"`             //ACL
		BackgroundNum   int    `json:"backgroundNum"`   //后端服务数
	}
)

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/pkg/models/cabinet/cabinet.go
```golang
package cabinet

import (
	"luban-cmdb-api/pkg/utils"
	"time"
)

type (

	//CabinetListResponse cabinet列表
	CabinetListResponse struct {
		TotalCount int64           `json:"totalCount"`
		PageNo     int           `json:"pageNo"`
		PageSize   int           `json:"pageSize"`
		DataList   []CabinetInfo `json:"dataList"`
	}

	QueryCabinetParam struct {
		PageNo          int      `json:"pageNo" `
		PageSize        int      `json:"pageSize" validate:"gte=1" `
		ID              interface{}   `json:"id"`
		CabinetName     string   `json:"cabinetName"`
		CabinetRoom     string   `json:"cabinetRoom"`
		CabinetRoomCode string   `json:"cabinetRoomCode"`
		CabinetRoomUid int   `json:"roomUid"`
		Region          string   `json:"region"`
		Azs             []string `json:"azs"`
		CabinetLabNames []string `json:"cabinetLabNames"`
		CabinetRooms    []string `json:"cabinetRooms"`
	}

	//CreateCabinetParam struct {
	//	CabinetName        string  `json:"cabinetName" validate:"required"`           //机柜名称
	//	CabinetDesc        string  `json:"cabinetDesc" `                              //描述
	//	CabinetRoomCode    string  `json:"cabinetRoomCode"`                           //所属房间代号
	//	CabinetCapacity    int     `json:"cabinetCapacity" validate:"required,gte=0"` //机柜容量
	//	CabinetBrand       string  `json:"cabinetBrand" `                             //机柜品牌
	//	CabinetType        string  `json:"cabinetType" `                              //机柜型号
	//	CabinetElectricity float64 `json:"cabinetElectricity" `                       // 机柜电流
	//	CabinetPower       float64 `json:"cabinetPower" `                             //机柜功率
	//	PDUJackNum         int     `json:"PDUJackNum" `                               //PDU插孔数量
	//	PDUJackType        string  `json:"PDUJackType" `                              // PDU插孔类型
	//}

	DeleteCabinetParam struct {
		CabinetIds []int `json:"cabinetIds" validate:"required"`
	}

	CabinetParam struct {
		CabinetElectricity float64 `json:"cabinetElectricity"`  // 机柜电流
		CabinetPower       float64 `json:"cabinetPower"`  //机柜功率
		CabinetName        string `json:"cabinetName"` //机柜名称
		CabinetBrand       string `json:"cabinetBrand"`  //机柜品牌
		CabinetType        string `json:"cabinetType"`  //机柜型号
		CabinetUpdater     string `json:"cabinetUpdater"`
		CabinetCreater     string `json:"cabinetCreater"`
		CabinetDesc        string  `json:"cabinetDesc"`  //描述
		Uid                int `json:"id"`
		AzId               int `json:"azId"`  //可用区id
		RegionId           int `json:"regionId"`  //所属区域id
		LabId              int `json:"labId"`  //所属jifangid
		RoomId             int `json:"roomId"`  //所属房间id
		CabinetRoomCode             string `json:"cabinetRoomCode"`  //所属房间id
		CabinetCapacity    int `json:"cabinetCapacity"`  //机柜容量
		PDUJackNum         int `json:"PDUJackNum"`  //PDU插孔数量
		PDUJackType         string `json:"PDUJackType"`  // PDU插孔类型
	}

	CabinetDetail struct {
		QueryCabinet []CabinetInfo `json:"queryCabinet"`
	}
	// CabinetInfo 机柜查询bean
	CabinetInfo struct {
		Uid                int     `json:"id,omitempty" gorm:"column:id"`                // ID
		CabinetName        string  `json:"cabinetName,omitempty" gorm:"column:cabinet_name"`        // 机柜名称
		CabinetRoom        string  `json:"cabinetRoom,omitempty" gorm:"column:cabinet_room"`        // 所属房间
		CabinetRegionCode  string  `json:"cabinetRegionCode,omitempty" gorm:"column:cabinet_region_code"`  // 区域code
		CabinetAzCode      string  `json:"cabinetAzCode,omitempty" gorm:"column:cabinet_az_code"`      // 可用区code
		CabinetRegionName  string  `json:"cabinetRegionName,omitempty" gorm:"column:cabinet_region_name"`  // 区域名称
		CabinetAzName      string  `json:"cabinetAzName,omitempty" gorm:"column:cabinet_az_name"`      // 可用区名称
		CabinetRoomCode    string  `json:"cabinetRoomCode,omitempty" gorm:"column:cabinet_room_code"`    // 所属房间代号
		CabinetDesc        string  `json:"cabinetDesc,omitempty" gorm:"column:cabinet_desc"`        //描述
		CabinetLabName     string  `json:"cabinetLabName,omitempty" gorm:"column:cabinet_lab_name"`     // 机房中文
		CabinetCapacity    int     `json:"cabinetCapacity,omitempty" gorm:"column:cabinet_capacity"`    // 机柜容量
		CabinetElectricity float64 `json:"cabinetElectricity,omitempty" gorm:"column:cabinet_electricity"` // 机柜电流
		CabinetPower       float64 `json:"cabinetPower,omitempty" gorm:"column:cabinet_power"`       // 机柜功率
		PDUJackNum         int     `json:"PDUJackNum,omitempty" gorm:"column:pdu_jack_num"`         // PDU插孔数量
		PDUJackType         string     `json:"PDUJackType,omitempty" gorm:"column:pdu_jack_type"`         // PDU插孔数量
		UsedUnitCount      int     `json:"usedUnitCount" gorm:"column:used_unit_count"`                // 已使用U位
		UnusedUnitCount    int     `json:"unusedUnitCount" gorm:"column:unused_unit_count"`              // 未使用U位
		CabinetBrand       string  `json:"cabinetBrand,omitempty" gorm:"column:cabinet_brand"`       // 机柜品牌
		CabinetType        string  `json:"cabinetType,omitempty" gorm:"column:cabinet_type"`        // 机柜型号
		CabinetCreateTime time.Time `json:"cabinetCreateTime,omitempty" gorm:"column:cabinet_create_time"` // 创建时间
		CabinetUpdateTime time.Time `json:"cabinetUpdateTime,omitempty" gorm:"column:cabinet_update_time"` // 更新时间
		CabinetCreator    string    `json:"cabinetCreator,omitempty" gorm:"column:cabinet_creator"`    // 创建人
		CabinetCount int64 `json:"-" gorm:"-"` //机柜总量
	}
)

var GetCabinetListDoc = `
pageSize：分页展示条数
pageNo：页数
region: 区域
azs: 可用区列表
id: 搜索的ID值（只支持精确搜索）
cabinetName: 机柜名称
cabinetRoom: 所属房间
cabinetRoomCode: 所属房间代号
cabinetLabNames: 机房列表
cabinetRooms: 所属房间列表
`

//var CreateCabinetDoc = `
//注意这个接口需要Auth的Header
//cabinetName：机柜名称
//cabinetDesc：描述
//roomId: 所属房间代号
//cabinetCapacity: 机柜容量
//cabinetBrand: 机柜品牌
//cabinetType: 机柜型号
//cabinetElectricity: 机柜电流
//cabinetPower: 机柜功率
//PDUJackNum: PDU插孔数量
//PDUJackType: PDU插孔类型
//`

var DeleteCabinetDoc = `
cabinetIds: 需要删除的机柜id. 例如:["1", "2"]
`

var OpCabinetDoc = `
注意这个接口需要Auth的Header
id : 机柜ID
cabinetName : 机柜名称
azId : 可用区ID
regionId : 区域ID
labId : 机房id
roomId : 房间id
cabinetRoomCode : 房间code
cabinetPower : 机柜功率
cabinetElectricity : 机柜电流
cabinetCapacity : 机柜容量
pduJackNum : PDU数量
pduJackType : PDU类型
cabinetBrand : 机柜品牌
cabinetType : 机柜型号
cabinetDesc : 机柜描述
`

/**
dgraph结构
*/

type (
	GetCabinetList struct {
		CabinetInfoCount []struct {
			CabinetTotal int `json:"cabinetTotal"`
		} `json:"cabinetInfoCount"`
		CabinetInfoList []CabinetInfo `json:"cabinetInfoList"`
	}
	RoomInfo struct {
		QueryRoomByCode []RoomByCodeMap `json:"queryRoomByCode"`
	}

	RoomByCodeMap struct {
		Uid            string        `json:"uid,omitempty"`
		DeviceRoomCode string        `json:"deviceRoomCode,omitempty"`
		DeviceRoomName string        `json:"deviceRoomName,omitempty"`
		RegionCode     string        `json:"regionCode,omitempty"`
		AzCode         string        `json:"azCode,omitempty"`
		LabRooms       []LabRoomsMap `json:"~lab_rooms,omitempty"`
	}

	LabRoomsMap struct {
		Uid     string `json:"uid,omitempty"`
		LabCode string `json:"labCode"`
		LabName string `json:"labName"`
	}

	RoomToCabinetMap struct {
		//Uid            string       `json:"uid,omitempty"`
		Uid            int64        `json:"uid,omitempty"`
		DeviceRoomCode string       `json:"deviceRoomCode,omitempty"`
		DeviceRoomName string       `json:"deviceRoomName,omitempty"`
		Cabinets       []CabinetMap `json:"deviceRoom_cabinets,omitempty"`
	}

	CabinetMap struct {
		Uid                int            `json:"uid,omitempty"`                // ID
		CabinetName        string         `json:"cabinetName,omitempty"`        // 机柜名称
		CabinetRoom        string         `json:"cabinetRoom,omitempty"`        // 所属房间
		CabinetRoomCode    string         `json:"cabinetRoomCode,omitempty"`    // 所属房间代号
		CabinetRegionCode  string         `json:"cabinetRegionCode,omitempty"`  // 区域
		CabinetAzCode      string         `json:"cabinetAzCode,omitempty"`      // 可用区
		CabinetDesc        string         `json:"cabinetDesc,omitempty"`        //描述
		CabinetLabName     string         `json:"cabinetLabName,omitempty"`     // 机房中文
		CabinetLabCode     string         `json:"cabinetLabCode,omitempty"`     // 机房code
		CabinetCapacity    int            `json:"cabinetCapacity,omitempty"`    // 机柜容量
		CabinetElectricity float32        `json:"cabinetElectricity,omitempty"` // 机柜电流
		CabinetPower       float32        `json:"cabinetPower,omitempty"`       // 机柜功率
		PDUJackNum         int            `json:"PDUJackNum,omitempty"`         // PDU插孔数量
		PDUJackType        string         `json:"PDUJackType,omitempty"`        // PDU插孔类型
		CabinetBrand       string         `json:"cabinetBrand,omitempty"`       // 机柜品牌
		CabinetType        string         `json:"cabinetType,omitempty"`        // 机柜型号
		CabinetCreateTime  utils.Datetime `json:"cabinetCreateTime,omitempty"`  // 创建时间
		CabinetUpdateTime  utils.Datetime `json:"cabinetUpdateTime,omitempty"`  // 更新时间
		CabinetCreator     string         `json:"cabinetCreator,omitempty"`     // 创建人
		DgraphType         string         `json:"dgraph.type,omitempty"`        // dgraph_type
		Racks              []RackMap      `json:"cabinet_racks,omitempty"`
	}

	RackMap struct {
		Uid              string         `json:"id,omitempty"`               // 机架位ID
		RackRegionCode   string         `json:"rackRegionCode,omitempty"`   // 区域
		RackAzCode       string         `json:"rackAzCode,omitempty"`       // 可用区
		RackName         string         `json:"rackName,omitempty"`         // 机架位名称
		RackLab          string         `json:"rackLab,omitempty"`          // 所属机房
		RackLabCode      string         `json:"rackLabCode,omitempty"`      // 所属机房代号
		RackRoomCode     string         `json:"rackRoomCode,omitempty"`     //所属房间code
		RackCabinetCode  string         `json:"rackCabinetCode,omitempty"`  // 所属机柜
		RackStatus       int            `json:"rackStatus"`                 // 机架位状态 0：未占用 1：占用
		RackResourceType string         `json:"rackResourceType,omitempty"` // 占用资源类型
		RackResourceName string         `json:"rackResourceName,omitempty"` // 资源名称
		RackCreateTime   utils.Datetime `json:"rackCreateTime,omitempty"`   // 创建时间
		RackUpdateTime   utils.Datetime `json:"rackUpdateTime,omitempty"`   // 更新时间
		RackCreator      string         `json:"rackCreator,omitempty"`      // 创建人
		DgraphType       string         `json:"dgraph.type,omitempty"`      // dgraph_type
	}

	IdStruct struct {
		Uid string `json:"uid"`
	}

	DeleteDeviceRoomCabinetsEdge struct {
		Uid     string   `json:"uid"`
		Cabinet IdStruct `json:"deviceRoom_cabinets"`
	}

	DeleteCabinetRacksEdge struct {
		Uid   string     `json:"uid"`
		Racks []IdStruct `json:"cabinet_racks"`
	}
)

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/pkg/models/lab/lab.go
```golang
package lab

import (
	"luban-cmdb-api/pkg/utils"
)

type (
	// LabListResponse lab列表返回结果
	LabListResponse struct {
		TotalCount int       `json:"totalCount"`
		PageNo     int       `json:"pageNo"`
		PageSize   int       `json:"pageSize"`
		DataList   []LabInfo `json:"dataList"`
	}
	// LabQueryParams lab列表查询接口参数
	LabQueryParams struct {
		PageNo      int         `json:"pageNo"`
		PageSize    int         `json:"pageSize"`
		RegionCode  string      `json:"regionCode"`
		AzCode      []string    `json:"azCode"`
		SearchType  string      `json:"searchType"`
		SearchValue interface{} `json:"searchValue"`
	}
	// CreateLabQuery 创建Lab接口i参数
	CreateLabQuery struct {
		LabName         string            `json:"labName"`
		LabCode         string            `json:"labCode"`
		Description     string            `json:"description"`
		AzCode          string            `json:"azCode"`
		LabAddress      string            `json:"labAddress"`
		ServiceProvider string            `json:"serviceProvider"`
		Power           string            `json:"power"`
		SparePower      string            `json:"sparePower"`
		MainContact     ContactsMapping   `json:"mainContact"`
		OtherContacts   []ContactsMapping `json:"otherContacts"`
	}

	// LabInfo Lab查询结果 仅List查询使用
	LabInfo struct {
		Uid             int               `json:"id,omitempty" gorm:"column:id"`              // ID
		LabName         string            `json:"labName,omitempty"`                          // 中文名称
		LabCode         string            `json:"labCode,omitempty"`                          // 名称代号
		RegionName      string            `json:"regionName,omitempty"`                       // 所属区域
		RegionCode      string            `json:"regionCode,omitempty"`                       //所属区域code
		AzName          string            `json:"azName,omitempty"`                           // 所属可用区
		AzUid           string            `json:"azId,omitempty"`                             // 可用区Id
		AzCode          string            `json:"azCode,omitempty"`                           //可用区code
		LabAddress      string            `json:"labAddress,omitempty" gorm:"column:address"` // 地址
		ServiceProvider string            `json:"serviceProvider,omitempty"`                  // 运营商
		RoomCount       int               `json:"roomCount,omitempty"`                        // 房间数
		CabinetCount    int               `json:"cabinetCount,omitempty"`                     // 机柜数
		RackCount       int               `json:"rackCount,omitempty"`                        // 机架位数量
		UsedUnitCount   int               `json:"usedUnitCount,omitempty"`                    // 已使用U位
		UnusedUnitCount int               `json:"unusedUnitCount,omitempty"`                  // 未使用U位
		Description     string            `json:"description,omitempty"`                      // 描述
		CreateTime      utils.Datetime    `json:"createTime,omitempty"`                       // 创建时间
		Creator         string            `json:"creator,omitempty"`                          // 创建人
		Power           string            `json:"power,omitempty"`
		SparePower      string            `json:"sparePower,omitempty"`
		MainContact     ContactsMapping   `json:"mainContact,omitempty" gorm:"-"`
		OtherContacts   []ContactsMapping `json:"otherContacts,omitempty" gorm:"-"`
	}
	// DeleteParams 删除接口传入参数
	DeleteParams struct {
		LabIds []int `json:"labIds"`
	}
	// UpdateParams
	UpdateParams struct {
		Id                int               `json:"id"`
		Description       string            `json:"description,omitempty"`
		LabAddress        string            `json:"labAddress,omitempty"`
		ServiceProvider   string            `json:"serviceProvider,omitempty"`
		Power             string            `json:"power,omitempty"`
		SparePower        string            `json:"sparePower,omitempty"`
		MainContact       ContactsMapping   `json:"mainContact,omitempty"`
		OtherContacts     []ContactsMapping `json:"otherContacts,omitempty"`
		DeleteContactUids []int             `json:"deleteContactUids"`
	}
)

// DGraph映射
type (
	// LabListDGraphMapping 查询Lab列表时的DGraph查询结构
	LabListDGraphMapping struct {
		UidList []struct {
			ContainAzs []struct {
				ContainLabs []struct {
					Uid string `json:"uid"`
				} `json:"az_labs,omitempty"`
			} `json:"region_azs,omitempty"`
		} `json:"uidList,omitempty"`
		DataList []struct {
			Uid             string         `json:"uid,omitempty"`
			LabName         string         `json:"labName,omitempty"`
			LabCode         string         `json:"labCode,omitempty"`
			ServiceProvider string         `json:"serviceProvider,omitempty"`
			LabAddress      string         `json:"labAddress,omitempty"`
			Description     string         `json:"description,omitempty"`
			CreateTime      utils.Datetime `json:"createTime,omitempty"`
			Creator         string         `json:"creator,omitempty"`
			Power           string         `json:"power,omitempty"`
			SparePower      string         `json:"sparePower,omitempty"`
			RoomCount       int            `json:"roomCount,omitempty"`
			Az              []struct {
				AzName string `json:"azName"`
				AzId   string `json:"azId"`
				Region []struct {
					RegionName string `json:"regionName"`
				} `json:"~region_azs,omitempty"`
			} `json:"~az_labs,omitempty"`
			Rooms []struct {
				RoomUid  string `json:"roomUid"`
				Cabinets []struct {
					CabinetUid string `json:"cabinetUid"`
					UnusedUNum int    `json:"unusedUNum"`
					UsedUNum   int    `json:"usedUNum"`
					Racks      []struct {
						RackUid string `json:"rackUid"`
					} `json:"cabinet_racks"`
					Units []struct {
						UnitUid string `json:"unitUid"`
					} `json:"cabinet_units"`
				} `json:"deviceRoom_cabinets"`
			} `json:"lab_rooms"`
			MainContact []ContactsMapping `json:"lab_mainContact"`
		}
	}

	AZMapping struct {
		Uid    string       `json:"uid,omitempty"`
		AzName string       `json:"azName,omitempty"`
		AzCode string       `json:"azCode,omitempty"`
		Labs   []LabMapping `json:"az_labs,omitempty"`
	}

	LabMapping struct {
		Uid             string            `json:"uid,omitempty"`
		LabName         string            `json:"labName,omitempty"`
		LabCode         string            `json:"labCode,omitempty"`
		ServiceProvider string            `json:"serviceProvider,omitempty"`
		LabAddress      string            `json:"labAddress,omitempty"`
		Description     string            `json:"description,omitempty"`
		CreateTime      utils.Datetime    `json:"createTime,omitempty"`
		Creator         string            `json:"creator,omitempty"`
		Power           string            `json:"power,omitempty"`
		SparePower      string            `json:"sparePower,omitempty"`
		Rooms           []RoomMapping     `json:"lab_rooms,omitempty"`
		MainContact     []ContactsMapping `json:"lab_mainContact"`
		OtherContacts   []ContactsMapping `json:"lab_otherContacts"`
		DGraphType      string            `json:"dgraph.type"`
	}
	DeleteLabMapping struct {
		Uid  string           `json:"uid"`
		Labs []DeleteLabModel `json:"az_labs"`
	}
	DeleteLabModel struct {
		Uid             string            `json:"uid"`
		LabName         string            `json:"labName"`
		LabCode         string            `json:"labCode"`
		ServiceProvider string            `json:"serviceProvider"`
		LabAddress      string            `json:"labAddress"`
		Description     string            `json:"description"`
		Creator         string            `json:"creator"`
		Power           string            `json:"power"`
		SparePower      string            `json:"sparePower"`
		MainContact     []ContactsMapping `json:"lab_mainContact"`
		OtherContacts   []ContactsMapping `json:"lab_otherContacts"`
	}
	UpdateLabMapping struct {
		Uid             string            `json:"uid,omitempty"`
		ServiceProvider string            `json:"serviceProvider,omitempty"`
		LabAddress      string            `json:"labAddress,omitempty"`
		Description     string            `json:"description,omitempty"`
		Power           string            `json:"power,omitempty"`
		SparePower      string            `json:"sparePower,omitempty"`
		MainContact     ContactsMapping   `json:"mainContact,omitempty"`
		OtherContacts   []ContactsMapping `json:"lab_otherContacts"`
	}

	ContactsMapping struct {
		Uid             int    `json:"uid"`
		LinkName        string `json:"linkName"`
		LinkPhoneNumber string `json:"linkPhoneNumber"`
	}

	RoomMapping struct {
		RoomUid  string           `json:"roomUid"`
		RoomName string           `json:"roomName"`
		Cabinets []CabinetMapping `json:"deviceRoom_cabinets"`
	}
	CabinetMapping struct {
		CabinetUid  string        `json:"cabinetUid"`
		CabinetName string        `json:"cabinetName"`
		Units       []UnitMapping `json:"cabinet_units"`
		Racks       []RackMapping `json:"cabinet_racks"`
	}

	UnitMapping struct {
		UnitUid    string `json:"unitUid"`
		UnitNumber string `json:"unitNumber"`
	}

	RackMapping struct {
		RackUid  string `json:"rackUid"`
		RackName string `json:"rackName"`
	}

	DetailModel struct {
		QueryLab []ReverseLabMapping `json:"queryLab"`
	}

	ReverseLabMapping struct {
		Uid             string             `json:"uid,omitempty"`
		LabName         string             `json:"labName,omitempty"`
		LabCode         string             `json:"labCode,omitempty"`
		ServiceProvider string             `json:"serviceProvider,omitempty"`
		LabAddress      string             `json:"labAddress,omitempty"`
		Description     string             `json:"description,omitempty"`
		Power           string             `json:"power,omitempty"`
		SparePower      string             `json:"sparePower,omitempty"`
		CreateTime      utils.Datetime     `json:"createTime"`
		Az              []ReverseAzMapping `json:"~az_labs,omitempty"`
		MainContact     []ContactsMapping  `json:"lab_mainContact,omitempty"`
		OtherContacts   []ContactsMapping  `json:"lab_otherContacts,omitempty"`
	}
	ReverseAzMapping struct {
		Uid    string                 `json:"uid,omitempty"`
		AzName string                 `json:"azName,omitempty"`
		AzCode string                 `json:"azCode,omitempty"`
		Region []ReverseRegionMapping `json:"~region_azs,omitempty"`
	}
	ReverseRegionMapping struct {
		RegionName string `json:"regionName"`
		RegionCode string `json:"regionCode"`
	}

	PreDeleteMapping struct {
		PreDelete []struct {
			Uid         string `json:"uid"`
			LabName     string `json:"labName"`
			RoomCount   int    `json:"roomCount"`
			MainContact []struct {
				Uid string `json:"uid"`
			} `json:"lab_mainContact"`
			OtherContacts []struct {
				Uid string `json:"uid"`
			} `json:"lab_otherContacts"`
			Az []struct {
				Uid string `json:"uid"`
			} `json:"~az_labs"`
		} `json:"PreDelete"`
	}
	BasicLab struct {
		LabCode string `json:"labCode"`
		LabName string `json:"labName"`
		Id      int    `json:"id"`
	}
)

var CreateLabQueryDoc = `
注意这个接口需要Auth的Header
labName：机房名称
labCode：机房代号
description: 描述
azCode: 可用区id
labAddress: 地址
power: 供电
sparePower: 备电
lab_mainContact: 主要联系人、联系电话组. 例如: {"linkName" : "张三", "linkPhoneNumber" : "5351234"}
lab_otherContact: 其他联系人、联系电话组，例如：[{"linkName" : "张三", "linkPhoneNumber" : "5351234"}, {"linkName" : "李四", "linkPhoneNumber" : "5361234"}]
`

var DeleteLabDoc = `
labIds: 需要删除的机房id. 例如:["1", "2"]
`

var UpdateLabDoc = `
id: 当前Lab id
description： 描述
labAddress： 地址
serviceProvider： 服务提供商
power： 供电
sparePower：备电
contacts：联系人、联系电话、uid组（注意已存在的联系人必须附带uid，新增的联系人没有uid）. 例如: lab_otherContact: 其他联系人、联系电话组，例如：[{"linkName" : "张三", "linkPhoneNumber" : "5351234"， "uid": "0xdn23"}, {"linkName" : "李四", "linkPhoneNumber" : "5361234"}]
DeleteContactUids:需要删除的其他联系人uid数组，例如: ["0x123", "0x456"]
`
var LabQueryParamsDoc = `
pageNo： 页数，必传eg: 1
pageSize： 页码，必传eg: 10
region:必传eg: all
az:默认值: []
searchType:默认值 "" ,搜索的类型（ID、labName、labCode、serviceProvider）
searchValue:默认值 "",搜索值
`

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/pkg/models/basic/basic.go
```golang
package basic

type Unit struct {
	UnitUid    string `json:"unitUid"`
	UnitNumber string `json:"unitNumber"`
}

type Rack struct {
	RackUid int `json:"rackUid"`
	//RackCode string `json:"rackCode"`
	RackName string `json:"rackName"`
}

type Cabinet struct {
	CabinetUid int `json:"cabinetUid"`
	//CabinetCode  string `json:"cabinetCode"`
	CabinetName  string `json:"cabinetName"`
	ContainRacks []Rack `json:"containRacks"`
	//ContainUnits []Unit `json:"containUnits"`
}

type Room struct {
	RoomUid int `json:"roomUid"`
	//RoomCode        string    `json:"roomCode"`
	RoomName        string    `json:"roomName"`
	ContainCabinets []Cabinet `json:"containCabinets"`
}
type LabQuery struct {
	Region string   `json:"region"`
	Az     []string `json:"az"`
}

var LabQueryDoc = `
region: 区域
az: 可用区[]
`

type Lab struct {
	Uid     int    `json:"uid"`
	LabCode string `json:"labCode"`
	LabName string `json:"labName"`
}

type CabinetInfo struct {
	Uid         int    `json:"uid" gorm:"column:id"`
	CabinetName string `json:"cabinetName" gorm:"column:cabinet_name"`
}

type CabinetQueryParam struct {
	Region   string   `json:"region"`
	Azs      []string `json:"azs"`
	LabCode  []string `json:"labCode"`
	RoomCode []string `json:"roomCode"`
	RoomUid  int      `json:"roomUid"`
}

type GetCabinetInfos struct {
	GetBasicCabinetList []CabinetInfo `json:"getBasicCabinetList"`
}

type GetLabs struct {
	QueryLabList []Lab `json:"queryLabList"`
}
type Az struct {
	AzId            int    `json:"azId"`
	AzCode          string `json:"azCode"`
	AzName          string `json:"azName"`
	AzCodeAggregate string `json:"azCodeAggregate"`
	ContainLabs     []Lab  `json:"containLabs"`
	//ContainResourcePools []ResourcePool `json:"containResourcePools"`
}

type Region struct {
	RegionCode          string `json:"regionCode"`
	RegionName          string `json:"regionName"`
	RegionCodeAggregate string `json:"regionCodeAggregate"`
	ContainAzs          []Az   `json:"containAzs"`
}

type RegionData struct {
	DataList []Region `json:"dataList"`
}

type RoomData struct {
	DataList []ContainRoom `json:"dataList"`
}

type ContainRoom struct {
	ContainRooms []Room `json:"containRooms"`
}

type ResourceTypeData struct {
	DataList []ResourceType `json:"dataList"`
}

type ResourceType struct {
	Id                      int               `json:"-"`
	ResourceTypeCode        string            `json:"resourceTypeCode"`
	ResourceTypeName        string            `json:"resourceTypeName"`
	ContainResourceSubTypes []ResourceSubType `json:"containResourceSubTypes"`
}
type ResourceSubType struct {
	Id                  int    `json:"-"`
	ResourceSubTypeCode string `json:"resourceSubTypeCode"`
	ResourceSubTypeName string `json:"resourceSubTypeName"`
}
type PhysicalHostList struct {
	DataList []PhysicalHostData `json:"dataList"`
}
type PhysicalHostData struct {
	HostName string `json:"hostName"`
	Uid      string `json:"uid"`
}

type Resource struct {
	ResourceKey   string `json:"resourceKey"`
	ResourceValue string `json:"resourceValue"`
}
type ResourceList struct {
	ResourceType    []Resource `json:"resourceType"`
	ResourceSubType []Resource `json:"resourceSubType"`
}

var ResourcePoolQueryDoc = `
RegionCode region code ，可选;默认值:"all"
AzCode Az Code，可选;默认值:"all"
StorageTypeCode:存储类型;默认值：[]
ResourceTypeCode:资源池类型;必选：eg:计算资源池:aggregate; 块存储资源池:blockStoragePool
`

var GetCabinetListDoc = `
region: 区域
az: 可用区
labCode: 机房code列表
roomCode: 所属房间code列表
`

// var GetAzRegionInfoDoc = `
// regionCodes: 区列列表
// `

func ReturnReads(strct interface{}) {

}

//ResourcePoolList for overview Query
type ResourcePoolQuery struct {
	RegionCode       string   `json:"regionCode"` //cn-shanghai-2
	AzCode           []string `json:"azCode"`     //cn-shanghai-2a
	StorageTypeCode  []string `json:"storageTypeCode"`
	ResourceTypeCode string   `json:"resourceTypeCode"` //aggregate;physicalHost;blockStorage;objectStorage
	//ResourcePoolCode string `json:"resourcePoolCode"` //ks3;ebs3.0;ehdd;aggregate1,2,3
}
type ResourcePool struct {
	ResourcePoolCode string `json:"resourcePoolCode"`
	ResourcePoolName string `json:"resourcePoolName"`
}

type DynamicColumnList struct {
	ColumnData string `json:"column_data"`
	Uid        int    `json:"uid"`
}

type ResourcePoolStorageType struct {
	StorageTypeCode      string         `json:"storageTypeCode"`
	StorageTypeName      string         `json:"storageTypeName"`
	ContainResourcePools []ResourcePool `json:"containResourcePools,omitempty"`
}
type ResourcePoolAz struct {
	AzCode               string                    `json:"azCode"`
	AzName               string                    `json:"azName"`
	AzCodeAggregate      string                    `json:"azCodeAggregate"`
	ContainResourcePools []ResourcePool            `json:"containResourcePools,omitempty"`
	ContainStorageTypes  []ResourcePoolStorageType `json:"containStorageTypes,omitempty"`
}

type ResourcePoolRegion struct {
	RegionCode          string                    `json:"regionCode"`
	RegionName          string                    `json:"regionName"`
	RegionCodeAggregate string                    `json:"regionCodeAggregate"`
	ContainAzs          []ResourcePoolAz          `json:"containAzs,omitempty"`
	ContainStorageTypes []ResourcePoolStorageType `json:"containStorageTypes,omitempty"`
}

type ResourcePoolRegionData struct {
	DataList []ResourcePoolRegion `json:"dataList"`
}

type RoomCodesParams struct {
	AzCode     string   `json:"az"`
	RegionCode string   `json:"region"`
	RoomCodes  []string `json:"roomCodes"`
}

type AzCodesParams struct {
	RegionCodes []string `json:"regionCodes"`
}

type AzRegionInfo struct {
	AzRegion []struct {
		RegionName string `json:"regionName"`
		RegionCode string `json:"regionCode"`
		ContainAzs []struct {
			AzName string `json:"azName"`
			AzCode string `json:"azCode"`
		} `json:"containAzs"`
	} `json:"azRegionInfo"`
}

//获取资源类型、资源子类型下的对象包含（资源池，物理机。。。）
type ResourceObject struct {
	Key                 string `json:"key"`
	Value               string `json:"value"`
	Name                string `json:"name"`
	Region              string `json:"region"`     //cn-shanghai-2
	RegionName          string `json:"regionName"` //cn-shanghai-2
	Az                  string `json:"az"`         //cn-shanghai-2a
	AzName              string `json:"azName"`     //cn-shanghai-2a
	Lab                 string `json:"lab"`
	LabName             string `json:"labName"`
	ResourceTypeName    string `json:"resourceTypeName"`    //resourcePool，resourcPhysical
	ResourceSubTypeName string `json:"resourceSubTypeName"` //ks3;ebs3.0;ehdd;aggregate1,2,3
}

var ResourceObjectQueryDoc = `
RegionCode region code ，可选;默认值:"all"
AzCode Az Code，可选;默认值:"all"
labCode: 机房code
ResourceTypeCode:资源类型;默认值：resourcePool，resourcPhysical
ResourceSubTypeCode:资源子类型：eg:ks3;ebs;kec
resourceObjects:资源列表
`

type ResourceObjectQuery struct {
	Region              []string `json:"region"` //cn-shanghai-2
	Az                  []string `json:"az"`     //cn-shanghai-2a
	Lab                 []string `json:"lab"`
	ResourceTypeCode    string   `json:"resourceTypeCode"`    //resourcePool，resourcPhysical
	ResourceSubTypeCode string   `json:"resourceSubTypeCode"` //ks3;ebs3.0;ehdd;aggregate1,2,3
	ResourceObjects     []string `json:"resourceObjects"`
	//ResourcePoolCode string `json:"resourcePoolCode"`
}
type (
	RegionList struct {
		DataList []RegionDt `json:"dataList"`
	}
	RegionDt struct {
		RegionCode          string `json:"regionCode"`
		RegionCodeAggregate string `json:"regionCodeAggregate"`
		RegionName          string `json:"regionName"`
	}
	AzList struct {
		DataList []RegionAzs `json:"dataList"`
	}
	RegionAzs struct {
		ContainAzs []AzDt `json:"containAzs"`
	}
	AzDt struct {
		AzCode string `json:"azCode"`
		AzName string `json:"azName"`
		AzId   int    `json:"azId"`
	}
)
type HardwareMess struct {
	Sn       string `json:"sn" description:"交换机获取物理服务器的sn"`
	CpuInfo  string `json:"cpuInfo" description:"CPU信息"`
	DiskInfo string `json:"diskInfo" description:"Disk信息"`
	MemInfo  string `json:"memInfo" description:"Memory信息"`
	NetInfo  string `json:"netInfo" description:"Net信息"`
	RaidInfo string `json:"raidInfo" description:"Raid信息"`
}

type Tenant struct {
	Id   string `json:"id"`
	Name string `json:"name"`
}

type ResourcePoolStorageQuery struct {
	RegionCode      []string `json:"regionCode"` //cn-shanghai-2
	AzCode          []string `json:"azCode"`     //cn-shanghai-2a
	StorageTypeCode string   `json:"storageTypeCode"`
	ResourcePool    []string `json:"resourcePool"`
}

var ResourcePoolStorageQueryDoc = `
RegionCode region code ，可选;默认值:[]
AzCode Az Code，可选;默认值:[]
StorageTypeCode:存储类型;默认值：""
resourcePool:资源池类型;ssd3.0  ehdd ks3
`

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/pkg/models/server/server.go
```golang
package server

import "time"

type PhysicalHostData struct {
	Name             string `json:"name"`
	Uid              int    `json:"uid" gorm:"column:id"`
	Ip               string `json:"ip"`
	Runstatus        string `json:"runstatus" gorm:"column:run_status"`
	AssignmentStatus string `json:"assignmentStatus"`
	ResourcePoolType string `json:"resourcePoolType" gorm:"colume:resource_pool_type"`
	ResourcePool     string `json:"resourcePool" gorm:"colume:resource_pool"`
	NodeType         string `json:"nodeType" gorm:"colume:node_type"`
	Node             string `json:"node" gorm:"colume:node"`
	Service          string `json:"service"`
	ServerType       string `json:"serverType"`
	HostRegionCode   string `json:"hostRegionCode" gorm:"column:region_code"`
	HostRegionName   string `json:"hostRegionName" gorm:"column:region_name"`
	HostAzCode       string `json:"hostAzCode" gorm:"column:az_code"`
	HostAzName       string `json:"hostAzName" gorm:"column:az_name"`
	HostLabCode      string `json:"hostLabCode" gorm:"column:lab_code"`
	HostLabName      string `json:"hostLabName" gorm:"column:lab_name"`
	HostRoomUid      int    `json:"hostRoomUid,omitempty" gorm:"column:room_id"`
	HostRoomCode     string `json:"hostRoomCode" gorm:"column:room_code"`
	HostRoomName     string `json:"hostRoomName" gorm:"column:room_name"`
	HostCabinetUid   int    `json:"hostCabinetUid,omitempty" gorm:"column:cabinet_id"`
	HostCabinetName  string `json:"hostCabinetName" gorm:"column:cabinet_name"`
	HostRackUid      int    `json:"hostRackUid,omitempty" gorm:"column:rack_id"`
	HostRackName     string `json:"hostRackName" gorm:"column:rack_name"`
	//HostUnitUid        string  `json:"hostUnitUid" gorm:"column:out_band_ip"`
	HostUnitNumber     int       `json:"hostUnitNumber" gorm:"column:host_unit_number"`
	Sn                 string    `json:"sn"`
	MacAddress         string    `json:"macAddress"`
	ManagementIP       string    `json:"managementIP" gorm:"column:management_ip"`
	OutbandIP          string    `json:"outbandIP" gorm:"column:out_band_ip"`
	OutbandUser        string    `json:"outbandUser" gorm:"column:out_band_user"`
	Power              string    `json:"power"`
	UplinkSwitch       string    `json:"uplinkSwitch"`
	MaintenanceDue     time.Time `json:"maintenanceDue"`
	MaintenanceStatus  string    `json:"maintenanceStatus"`
	Assetsnumber       string    `json:"assetsnumber" gorm:"column:assets_number"`
	InputMethod        string    `json:"inputMethod"`
	InputTime          int64     `json:"inputTime"`
	Description        string    `json:"description"`
	CreateTime         int64     `json:"createTime"`
	CpuAllocationRatio int       `json:"cpuAllocationRatio"` //cpu超配额
	RamAllocationRatio float64   `json:"ramAllocationRatio"` //内存超配额
	System             string    `json:"system" gorm:"column:operate_system"`
	SystemSales        string    `json:"systemSales"`
	CpuTotal           int       `json:"cpuTotal"`
	MemoryTotal        int       `json:"memoryTotal"`
	Label              string    `json:"label" gorm:"column:label"`
}

type PhysicalHostDataNew struct {
	Name             string `json:"name"`
	Uid              int    `json:"uid" gorm:"column:id"`
	Ip               string `json:"ip"`
	Runstatus        string `json:"runstatus" gorm:"column:run_status"`
	AssignmentStatus string `json:"assignmentStatus"`
	ResourcePoolType string `json:"resourcePoolType" gorm:"colume:resource_pool_type"`
	ResourcePool     string `json:"resourcePool" gorm:"colume:resource_pool"`
	NodeType         string `json:"nodeType" gorm:"colume:node_type"`
	Node             string `json:"node" gorm:"colume:node"`
	Service          string `json:"service"`
	ServerType       string `json:"serverType"`
	HostRegionCode   string `json:"hostRegionCode" gorm:"column:region_code"`
	HostRegionName   string `json:"hostRegionName" gorm:"column:region_name"`
	HostAzCode       string `json:"hostAzCode" gorm:"column:az_code"`
	HostAzName       string `json:"hostAzName" gorm:"column:az_name"`
	HostLabCode      string `json:"hostLabCode" gorm:"column:lab_code"`
	HostLabName      string `json:"hostLabName" gorm:"column:lab_name"`
	HostRoomUid      int    `json:"hostRoomUid,omitempty" gorm:"column:room_id"`
	HostRoomCode     string `json:"hostRoomCode" gorm:"column:room_code"`
	HostRoomName     string `json:"hostRoomName" gorm:"column:room_name"`
	HostCabinetUid   int    `json:"hostCabinetUid,omitempty" gorm:"column:cabinet_id"`
	HostCabinetName  string `json:"hostCabinetName" gorm:"column:cabinet_name"`
	HostRackUid      int    `json:"hostRackUid,omitempty" gorm:"column:rack_id"`
	HostRackName     string `json:"hostRackName" gorm:"column:rack_name"`
	//HostUnitUid        string  `json:"hostUnitUid" gorm:"column:out_band_ip"`
	HostUnitNumber     int       `json:"hostUnitNumber" gorm:"column:host_unit_number"`
	Sn                 string    `json:"sn"`
	MacAddress         string    `json:"macAddress"`
	ManagementIP       string    `json:"managementIP" gorm:"column:management_ip"`
	OutbandIP          string    `json:"outbandIP" gorm:"column:out_band_ip"`
	OutbandUser        string    `json:"outbandUser" gorm:"column:out_band_user"`
	Power              string    `json:"power"`
	UplinkSwitch       string    `json:"uplinkSwitch"`
	MaintenanceDue     time.Time `json:"maintenanceDue"`
	MaintenanceStatus  string    `json:"maintenanceStatus"`
	Assetsnumber       string    `json:"assetsnumber" gorm:"column:assets_number"`
	InputMethod        string    `json:"inputMethod"`
	InputTime          int64     `json:"inputTime"`
	Description        string    `json:"description"`
	CreateTime         int64     `json:"createTime"`
	CpuAllocationRatio int       `json:"cpuAllocationRatio"` //cpu超配额
	RamAllocationRatio float64   `json:"ramAllocationRatio"` //内存超配额
	System             string    `json:"system" gorm:"column:operate_system"`
	SystemSales        string    `json:"systemSales"`
	CpuTotal           int       `json:"cpuTotal"`
	MemoryTotal        int       `json:"memoryTotal"`
	Label              string    `json:"label" gorm:"column:label"`
}

type HostOverview struct {
	HostStateOverview       []OverView            `json:"hostStateOverview"`
	HostMaintenanceOverview []OverView            `json:"hostMaintenanceOverview"`
	DistributedOverview     []DistributedOverView `json:"distributedOverview"`
}
type OverView struct {
	Name  string `json:"name"`
	Code  string `json:"code"`
	Value int    `json:"value"`
}
type DistributedOverView struct {
	Name   string `json:"name"`
	Region string `json:"region"`
	Az     string `json:"az"`
	//Lab         string     `json:"lab"`
	Distributed []OverView `json:"distributed"`
	//Distributed2 OverView `json:"distributed2"`
}

var PhysicalHostListQueryDoc string = `
pageNo： 页数，必传eg: 1
pageSize： 页码，必传eg: 10
region： 区域;必传eg:all
az： 可用区;必传eg:all
lab： 机房;必传eg:all
room: 房间;
cabinetUid: 机柜ids;
name： 服务器名称;默认值：""
id:服务器ID;默认值：""
ip:服务器IP;默认值：""
sn:服务器SN号;默认值：""
runstatus:运行状态;默认值：[]
assignmentStatus:分配状态;默认值：[]
maintenanceStatus:维保状态;默认值：[]
inputMethod:录入方式;默认值：[]
`

type PhysicalHostListQuery struct {
	PageNo            int      `json:"pageNo"`
	PageSize          int      `json:"pageSize"`
	Region            []string `json:"region"`
	Az                []string `json:"az"`
	Lab               []string `json:"lab"`
	Room              []string `json:"room"`
	CabinetId         []int    `json:"cabinetId"`
	Name              string   `json:"name"`
	Id                string   `json:"id"`
	Ip                string   `json:"ip"`
	Sn                string   `json:"sn"`
	Runstatus         []string `json:"runstatus"`
	AssignmentStatus  []string `json:"assignmentStatus"`
	MaintenanceStatus []string `json:"maintenanceStatus"`
	InputMethod       []string `json:"inputMethod"`
	StorageType       string   `json:"storageType"`
	ResourcePool      string   `json:"resourcePool"`
	MixDeploy         bool     //是否是混合部署
	ResourcePoolType  []string `json:"resourcePoolType"`
	Node              []string `json:"node"`
}

type PhysicalHostDataResult struct {
	//nihao
	RequestId string `json:"requestId" description:"identifier of the user"`
	PageStruct
	DataList []PhysicalHostData `json:"dataList"`
}

type PageStruct struct {
	TotalCount int `json:"totalCount"`
	PageNo     int `json:"pageNo"`
	PageSize   int `json:"pageSize"`
}
type PhysicalHostList struct {
	Host []PhysicalHostData `json:"host"`
}
type Data struct {
	Host []Host `json:"host"`
}

type Host struct {
	Count int `json:"count"`
}

// 如果没有设置omitempty，那么将为没有明确指定的值创建具有
// 空值的边（对于int/float为0、对于string为""、对于bool为false）
type PhysicalHostUpdateEntity struct {
	Uid             int    `json:"uid,omitempty"`
	HostLabCode     string `json:"hostLabCode,omitempty"`
	HostLabName     string `json:"hostLabName,omitempty"`
	HostRoomUid     int    `json:"hostRoomUid,omitempty"`
	HostRoomName    string `json:"hostRoomName,omitempty"`
	HostCabinetUid  int    `json:"hostCabinetUid,omitempty"`
	HostCabinetName string `json:"hostCabinetName,omitempty"`
	HostRackUid     int    `json:"hostRackUid,omitempty"`
	HostRackName    string `json:"hostRackName,omitempty"`
	HostUnitUid     int    `json:"hostUnitUid,omitempty"`
	HostUnitNumber  int    `json:"hostUnitNumber"`
	//ManagementIP    string `json:"managementIP,omitempty"`
	OutbandIP      string `json:"outbandIP"`
	Assetsnumber   string `json:"assetsnumber"`
	MaintenanceDue int64  `json:"maintenanceDue"`
	Label          string `json:"label"`
	Description    string `json:"description" description:"描述"`
}

type ReportPhysicalHostEntity struct {
	Sn                 string   `json:"sn,omitempty" description:"sn号"`
	Name               string   `json:"hostname,omitempty" description:"服务器hostname"`
	Ip                 string   `json:"ip,omitempty" description:"服务器ip"`
	Label              string   `json:"label,omitempty" description:"标签"`
	Region             string   `json:"hostRegionCode,omitempty" description:"region code"`
	Az                 string   `json:"hostAzCode,omitempty" description:"az code"`
	System             string   `json:"system,omitempty" gorm:"column:operate_system" description:"系统"`
	SystemSales        string   `json:"systemSales,omitempty" description:"系统厂商"`
	Runstatus          string   `json:"runstatus,omitempty" description:"运行状态"`
	CpuTotal           int      `json:"cpuTotal,omitempty" description:"cpu总核"`
	MemoryTotal        int      `json:"memoryTotal,omitempty" description:"内存总和"`
	InputTime          int64    `json:"inputTime,omitempty" description:"导入时间"`
	InputMethod        string   `json:"inputMethod,omitempty" description:"导入方式"`
	CreateDate         int64    `json:"createDate,omitempty" description:"创建时间"`
	CpuAllocationRatio int      `json:"cpuAllocationRatio,omitempty" description:"cpu超配额"` //cpu超配额
	RamAllocationRatio float64  `json:"ramAllocationRatio,omitempty" description:"内存超配额"`  //内存超配额
	MacAddress         string   `json:"macAddress,omitempty" description:"mac地址"`
	AssignmentStatus   string   `json:"assignmentStatus,omitempty" description:"分配状态"`
	Service            string   `json:"service,omitempty" description:"业务"`
	ServerType         string   `json:"serverType,omitempty" description:"服务器型号"`
	Description        string   `json:"description,omitempty" description:"描述"`
	Kind               string   `json:"kind,omitempty"` // dmidecode -s system-product-name 这个字段可以区分出是不是虚拟机
	Node               []string `json:"node,omitempty" description:"服务器节点类型"`
}

//
//type ReportPhysicalHostEntity struct {
//	Sn                 string   `json:"sn,omitempty" description:"sn号"`
//	Name               string   `json:"name,omitempty" description:"服务器name"`
//	Ip                 string   `json:"ip,omitempty" description:"服务器ip"`
//	OutBandIp          string   `json:"outBandIp,omitempty" description:"带外ip"`
//	Label              string   `json:"label,omitempty" description:"标签"`
//	RegionCode         string   `json:"regionCode,omitempty" description:"regionCode"`
//	AzCode             string   `json:"azCode,omitempty" description:"azCode"`
//	Node               []string `json:"node,omitempty" description:"服务器节点类型"`
//	System             string   `json:"system,omitempty" gorm:"column:operate_system" description:"系统"`
//	SystemSales        string   `json:"systemSales,omitempty" description:"系统厂商"`
//	Runstatus          string   `json:"runstatus,omitempty" description:"运行状态"`
//	CpuTotal           int      `json:"cpuTotal,omitempty" description:"cpu总核"`
//	MemoryTotal        int      `json:"memoryTotal,omitempty" description:"内存总和"`
//	InputTime          int64    `json:"inputTime,omitempty" description:"导入时间"`
//	InputMethod        string   `json:"inputMethod,omitempty" description:"导入方式"`
//	CreateDate         int64    `json:"createDate,omitempty" description:"创建时间"`
//	CpuAllocationRatio int      `json:"cpuAllocationRatio,omitempty" description:"cpu超配额"` //cpu超配额
//	RamAllocationRatio float64  `json:"ramAllocationRatio,omitempty" description:"内存超配额"`  //内存超配额
//	MacAddress         string   `json:"macAddress,omitempty" description:"mac地址"`
//	AssignmentStatus   string   `json:"assignmentStatus,omitempty" description:"分配状态"`
//	Service            string   `json:"service,omitempty" description:"业务"`
//	ServerType         string   `json:"serverType,omitempty" description:"服务器型号"`
//	Description        string   `json:"description,omitempty" description:"描述"`
//	Kind               string   `json:"kind,omitempty"` // dmidecode -s system-product-name 这个字段可以区分出是不是虚拟机
//}

type ResourcePoolHost struct {
	StorageType      string `json:"storageType"`
	ResourcePool     string `json:"resourcePool"`
	ResourcePoolName string `json:"resourcePoolName"`
	Ip               string `json:"ip"`
	HostName         string `json:"hostName"`
}
type PhysicalHostDetail struct {
	// BasicMessage       PhysicalServer
	PhysicalServer
	CpuMessage         []Cpu    `json:"cpuMessage"`
	MemoryMessage      []Memory `json:"memoryMessage"`
	DiskMessage        []Disk   `json:"diskMessage"`
	RAIDMessage        []Raid   `json:"raidMessage"`
	NetworkCardMessage []Net    `json:"networkCardMessage"`
	GPUMessage         []Gpu    `json:"gpuMessage"`
}
type PhysicalServer struct {
	Name               string    `json:"name,omitempty"`
	Id                 int       `json:"uid,omitempty"`
	Ip                 string    `json:"ip,omitempty"`
	Runstatus          string    `json:"runstatus,omitempty" gorm:"column:run_status"`
	AssignmentStatus   string    `json:"assignmentStatus,omitempty"`
	ResourcePoolType   string    `json:"resourcePoolType,omitempty"`
	ResourcePool       string    `json:"resourcePool,omitempty"`
	NodeType           string    `json:"nodeType" gorm:"colume:node_type"`
	Node               string    `json:"node" gorm:"colume:node"`
	Service            string    `json:"service,omitempty"`
	RegionId           int       `json:"regionId,omitempty"`
	RegionName         string    `json:"region,omitempty"`
	RegionCode         string    `json:"regionCode" gorm:"column:region_code"`
	AzId               int       `json:"azId,omitempty"`
	AzCode             string    `json:"azCode" gorm:"column:az_code"`
	AzName             string    `json:"az,omitempty"`
	RoomId             int       `json:"roomId,omitempty" gorm:"column:room_id"`
	RoomName           string    `json:"roomName,omitempty" gorm:"column:room_name"`
	LabId              int       `json:"labId,omitempty"`
	LabName            string    `json:"lab,omitempty"`
	CabinetId          int       `json:"cabinetId,omitempty"`
	CabinetName        string    `json:"cabinet,omitempty"`
	RackId             int       `json:"RackId,omitempty"`
	RackName           string    `json:"hostRackName,omitempty"`
	HostUnitNumber     int       `json:"hostUnitNumber,omitempty" gorm:"column:host_unit_number"`
	ServerType         string    `json:"serverType,omitempty"`
	Sn                 string    `json:"sn,omitempty"`
	ManagementIP       string    `json:"managementIP,omitempty"`
	OutBandIP          string    `json:"outBandIp,omitempty" gorm:"column:out_band_ip"`
	OutBandUser        string    `json:"outBandUser,omitempty" gorm:"column:out_band_user"`
	MainMaintainer     string    `json:"mainMaintainer,omitempty"`
	Power              string    `json:"power,omitempty"`
	UplinkSwitch       string    `json:"uplinkSwitch,omitempty"`
	MaintenanceDue     time.Time `json:"maintenanceDue,omitempty"`
	MaintenanceStatus  string    `json:"maintenanceStatus,omitempty"`
	Assetsnumber       string    `json:"assetsnumber,omitempty" gorm:"column:assets_number"`
	InputTime          int64     `json:"inputTime,omitempty"`
	InputMethod        string    `json:"inputMethod,omitempty"`
	MacAddress         string    `json:"macAddress,omitempty"`
	System             string    `json:"system,omitempty" gorm:"column:operate_system"`
	SystemSales        string    `json:"systemSales,omitempty"`
	Description        string    `json:"description,omitempty"`
	CreateTime         int64     `json:"createTime,omitempty"`
	Label              string    `json:"label,omitempty"`
	CpuAllocationRatio int       `json:"cpuAllocationRatio,omitempty"` //cpu超配额
	RamAllocationRatio float64   `json:"ramAllocationRatio,omitempty"` //内存超配额
	CpuTotal           int       `json:"cpuTotal,omitempty" description:"cpu总核"`
	MemoryTotal        int       `json:"memoryTotal,omitempty" description:"内存总和"`
	Kind               string    `json:"kind,omitempty"` // dmidecode -s system-product-name 这个字段可以区分出是不是虚拟机
}
type Cpu struct {
	CpuType string `json:"cpuType"`
	CpuCore int32  `json:"cpuCore"`
	CpuRate string `json:"cpuRate"`
	CpuInfo string `json:"cpuInfo"`
}

type Memory struct {
	MemoryType    string `json:"memoryType"`
	TotalCapacity int64  `json:"totalCapacity"`
	Count         int32  `json:"count"`
}

type Disk struct {
	DiskType          string  `json:"diskType"`
	TotalCapacity     float64 `json:"totalCapacity"` // 单位TB 可能为小数
	TotalCapacityByte int64   `json:"-"`             // 单位byte
	Count             int32   `json:"count"`
	Device            string  `json:"device"`
}

type Raid struct {
	RaidType string `json:"raidType"`
	Count    int32  `json:"count"`
	RaidInfo string `json:"raidInfo"`
}

type Net struct {
	NetworkCardType string `json:"networkCardType"`
	Count           int32  `json:"count"`
	NetInfo         string `json:"netInfo"`
}

type Gpu struct {
	GpuType  string `json:"gpuType"`
	Capacity string `json:"capacity"`
}
type HostListQuery struct {
	IpArray []string `json:"ipArray"`
}

type PhysicalHost struct {
	Name       string `json:"name"`
	Ip         string `json:"ip"`
	ServerType string `json:"serverType"`
}
type PoolHostUpdate struct {
	NameList []string `json:"nameList"`
	IpList   []string `json:"ipList"`
}

type AssetPhysicalServerNetwork struct {
	Id           int       `gorm:"column:id;type:int(11);primary_key;AUTO_INCREMENT" json:"id"`
	Sn           string    `gorm:"column:sn;type:varchar(100)" json:"sn"`
	HostName     string    `gorm:"column:host_name;type:varchar(100);comment:服务器名称;NOT NULL" json:"host_name"`
	NetWork      string    `gorm:"column:net_work;type:varchar(50);comment:服务器网卡名称;NOT NULL" json:"net_work"`
	Mac          string    `gorm:"column:mac;type:varchar(50);comment:服务器网卡mac;NOT NULL" json:"mac"`
	Speed        int       `gorm:"column:speed;type:int(11);comment:网卡速率  Mb/s" json:"speed"`
	LastUpdateAt time.Time `gorm:"column:last_update_at;type:timestamp;default:CURRENT_TIMESTAMP;NOT NULL" json:"last_update_at"`
}

type AssetPhysicalServerNode struct {
	Id          uint   `gorm:"column:id;type:int(11) unsigned;primary_key;AUTO_INCREMENT" json:"id"`
	Node        string `gorm:"column:node;type:varchar(30);comment:节点;NOT NULL" json:"node"`
	NodeType    string `gorm:"column:node_type;type:varchar(30);comment:节点所属类型;NOT NULL" json:"node_type"`
	NodeGroup   string `gorm:"column:node_group;type:varchar(30);comment:节点所属类型;NOT NULL" json:"node_group"`
	Order       int    `gorm:"column:order;type:int(11);comment:排序;NOT NULL" json:"order"`
	Description string `gorm:"column:description;type:varchar(30);comment:描述;NOT NULL" json:"description"`
}

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/pkg/models/storage/storage.go
```golang
package storage

import (
	"context"
	"encoding/json"
	"luban-cmdb-api/pkg/gredis"
	"strings"
	"time"

	"k8s.io/klog/v2"
)

var ClouddiskMap []CloudDiskData

func GetClouddiskMap() []CloudDiskData {
	ctx, cefl := context.WithTimeout(context.Background(), 5*time.Second)
	defer cefl()
	//rs, err := gredis.SMembers(ctx, gredis.ClouddiskMapKey)
	rs, err := gredis.HGetAll(ctx, gredis.ClouddiskMapKey)
	if err != nil {
		klog.Error("ClouddiskMap read from redis failure:", err.Error())
		return ClouddiskMap
	}
	var resultList []string
	for _, vmStr := range rs {
		resultList = append(resultList, vmStr)
	}
	var ClouddiskMapTemp []CloudDiskData
	rsStr := "[" + strings.Join(resultList, ",") + "]"
	err = json.Unmarshal([]byte(rsStr), &ClouddiskMapTemp)
	if err != nil {
		klog.Error("ClouddiskMap Unmarshal failure:", err.Error())
		return ClouddiskMap
	}
	ClouddiskMap = ClouddiskMapTemp
	return ClouddiskMap
}
func GetBucketMap() (bucketList []BucketDetail) {
	ctx, cefl := context.WithTimeout(context.Background(), 5*time.Second)
	defer cefl()
	//rs, err := gredis.SMembers(ctx, gredis.ClouddiskMapKey)
	rs, err := gredis.HGetAll(ctx, gredis.BucketMapKey)
	if err != nil {
		klog.Error("BucketDetail read from redis failure:", err.Error())
		return
	}
	var resultList []string
	for _, vmStr := range rs {
		resultList = append(resultList, vmStr)
	}
	var BucketDetailTemp []BucketDetail
	rsStr := "[" + strings.Join(resultList, ",") + "]"
	err = json.Unmarshal([]byte(rsStr), &BucketDetailTemp)
	if err != nil {
		klog.Error("BucketDetail Unmarshal failure:", err.Error())
		return
	}
	return BucketDetailTemp
}

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/pkg/models/storage/block.go
```golang
package storage

import (
	"encoding/json"
	"luban-cmdb-api/pkg/models"
)

type BlockRe struct {
	Name       string `json:"name"`
	Id         int    `json:"id"`
	RegionName string `json:"regionName"`
	RegionCode string `json:"regionCode"`
	AzId       int    `json:"azId"`
	AzName     string `json:"azName"`
	AzCode     string `json:"azCode"`
	//ResourcePoolType string `json:"resourcePoolType"` //资源池类型(块存储)
	ResourcePool       string   `json:"resourcePool"` //资源池（高效云盘，云硬盘3.0）
	ClusterUrl         string   `json:"clusterUrl"`
	MetricUrl          string   `json:"metricUrl"`
	SliceUrl           string   `json:"sliceUrl"`
	StockUrl           string   `json:"stockUrl"`
	Addresss           []string `json:"addresss"`
	Attribute          string   `json:"attribute"`
	HostNumber         int      `json:"hostNumber"`
	CloudDiskNumber    int      `json:"cloudDiskNumber"`
	CloudDiskErrNumber int      `json:"cloudDiskErrNumber"`
	CreateTime         int64    `json:"createTime"`
}

type BlockStoragePoolQuery struct {
	models.CommonListReq
	RegionCode   string   `json:"regionCode"`
	AzCode       []string `json:"azCode"`
	Name         string   `json:"name"`
	ResourcePool []string `json:"resourcePool"`
	//Id           string   `json:"id"`
}

var BlockStoragePoolQueryDoc string = `
pageNo： 页数，必传eg: 1
pageSize： 页码，必传eg: 10
	RegionCode   区域，默认值 ""
	AzCode       可用区，默认值 ""
	Name         实例名称，默认值 ""
	ResourcePool 存储类型，[]string 默认值 []
`

type EbsHost struct {
	Id      string `json:"id"`
	Address string `json:"address"`
	Status  string `json:"status"`
	Zone    string `json:"zone"`
}
type Ks3Host struct {
	Ip        string `json:"ip"`
	Port      int    `json:"port"`
	Status    int    `json:"status"`
	StatusMsg string `json:"status_msg"`
	Role      string `json:"role"`
}

func (h Ks3Host) MarshalBinary() ([]byte, error) {
	return json.Marshal(h)
}

type Addresss struct {
	Address []string `json:"address"`
}
type PageStruct struct {
	TotalCount int `json:"totalCount"`
	PageNo     int `json:"pageNo"`
	PageSize   int `json:"pageSize"`
}

type BlockStoragePoolListDataResult struct {
	PageStruct
	DataList []BlockRe `json:"dataList"`
}

type ObjectRe struct {
	Name         string    `json:"name"`
	Id           int       `json:"id"`
	RegionName   string    `json:"regionName"`
	RegionCode   string    `json:"regionCode"`
	AzCode       string    `json:"azCode"`
	ResourcePool string    `json:"resourcePool"`
	BucketNumber int       `json:"bucketNumber"`
	HostNumber   int       `json:"hostNumber"`
	ObjectNumber string    `json:"objectNumber"`
	CreateTime   int64     `json:"createTime"`
	Servers      []Ks3Host `json:"servers"`
	Status       string    `json:"status"`
	MetricUrl    string    `json:"metricUrl"`
}
type ObjectStoragePoolListDataResult struct {
	PageStruct
	DataList []ObjectRe `json:"dataList"`
}
type BlockStoragePoolDisk struct {
	models.CommonListPagination
	DataList []DiskDetail `json:"dataList"`
}

type DiskDetail struct {
	Name       string `json:"name"`
	Id         string `json:"id"`
	UseStatus  string `json:"state"`
	Size       int    `json:"size"`
	Type       string `json:"type"`
	Region     string `json:"region"`
	Zone       string `json:"zone"`
	TenantId   string `json:"tenantId"`
	TenantName string `json:"tenantName"`
	HostName   string `json:"hostname"`
	HostId     string `json:"hostId"`
	CreateTime int64  `json:"createTime"`
}

type BlockStoragePoolStock struct {
	models.CommonListPagination
	DataList []BlockStockDetail `json:"dataList"`
}

var BlockStoragePoolDiskQueryDoc string = `
pageNo： 页数，必传eg: 1
pageSize： 页码，必传eg: 10
cloudDiskType:  []string默认值 []
state:运行状态;[]string默认值 []
`

type BlockStoragePoolDiskQuery struct {
	Pagination
	State []string `json:"state"`
	Type  []string `json:"type"`
}

type BlockStockDetail struct {
	Region           string `json:"region"`
	StorageType      string `json:"storageType"`
	ResourcePoolName string `json:"resourcePoolName"`
	Total            int    `json:"total"`
	Free             int    `json:"free"`
	UsedPercent      int    `json:"usedPercent"`
}

type ObjectStoragePoolBucket struct {
	models.CommonListPagination
	DataList []BucketDetail `json:"dataList"`
}

type BucketDetail struct {
	Id              string `json:"id"`
	Name            string `json:"name"`
	Size            int    `json:"size"`
	StorageType     string `json:"storageType"`
	Region          string `json:"region"`
	RegionCode      string `json:"regionCode"`
	AzName          string `json:"azName"`
	AzCode          string `json:"azCode"`
	TenantId        string `json:"tenantId"`
	TenantName      string `json:"tenantName"`
	InnerDomainName string `json:"innerDomainName"`
	OuterDomainName string `json:"outerDomainName"`
	CreateTime      int64  `json:"createTime"`
	Policy          string `json:"policy"`
	// 前端非要封装在详情页封装这么个结构体,其实就是InnerDomainName, outerDomainName
	Domains          []BucketDomain `json:"bucketDomains"`
	ResourcePoolId   int            `json:"resourcePoolId,omitempty"`
	ResourcePoolName string         `json:"resourcePoolName"`
	ObjectCount      int64          `json:"objectCount"`
	BucketUsage
}

type BucketUsage struct {
	CurrentSize           int `json:"currentSize"`
	Last30DayDownload     int `json:"last30DayDownload"`
	Last30DayAPICallTimes int `json:"last30DayAPICallTimes"`
}

type BucketDomain struct {
	AccessType string `json:"accessType"`
	Endpoint   string `json:"endpoint"` // domain去掉bucketName的
	Domain     string `json:"domain"`
}

type ObjectStoragePoolStock struct {
	models.CommonListPagination
	DataList []ObjectStockDetail `json:"dataList"`
}

type ObjectStockDetail struct {
	Region           string `json:"region"`
	StorageType      string `json:"storageType"`
	ResourcePoolName string `json:"resourcePoolName"`
	Total            int    `json:"total"`
	Free             int    `json:"free"`
	UsedPercent      int    `json:"usedPercent"`
	IncreaseByDay    int    `json:"increaseByDay"`
	IncreaseByWeek   int    `json:"increaseByWeek"`
	IncreaseByMonth  int    `json:"increaseByMonth"`
	TimeLeftByDay    int64  `json:"timeLeftByDay"`
}

type Pagination struct {
	PageNo   int
	PageSize int
}

func (p Pagination) Limit() int {
	return p.PageSize
}

func (p Pagination) Offset() int {
	return (p.PageNo - 1) * p.PageSize
}

var CloudDiskRequestDoc string = `
pageNo： 页数，必传eg: 1
pageSize： 页码，必传eg: 10
region:必传eg: all
az:必传eg: all
name:默认值 ""
instanceId:默认值 ""
tenantId:默认值 ""
useStatus:运行状态;默认值：[]
resourcePoolType:云硬盘状态;默认值：[]
`

type CloudDiskRequest struct {
	Pagination
	Region           string   `json:"region"`
	Az               []string `json:"az"`
	Name             string   `json:"name"`
	ResourcePool     string   `json:"resourcePool"`
	InstanceId       string   `json:"instanceId"`
	TenantId         string   `json:"tenantId"`
	UseStatus        []string `json:"useStatus"`
	ResourcePoolType []string `json:"resourcePoolType"`

	SearchType  string `json:"searchType"`  // 搜索类型 (实例名称 name/实例ID instanceId/租户ID tenantId)
	SearchValue string `json:"searchValue"` // 搜索值 (注意要支持模糊搜索)
}

type CloudDiskData struct {
	Name             string `json:"name"`
	InstanceId       string `json:"instanceId"`
	Region           string `json:"region"`
	RegionCode       string `json:"regionCode"`
	Az               string `json:"az"`
	AzCode           string `json:"azCode"`
	ResourcePool     string `json:"resourcePool"`
	ResourcePoolType string `json:"resourcePoolType"`
	//Specs      string `json:"specs"`
	UseStatus  string `json:"useStatus"`
	TenantId   string `json:"tenantId"`
	TenantName string `json:"tenantName"`
	Vm         string `json:"vm"`
	VmId       string `json:"vmId"`
	CreateTime int64  `json:"createTime"` // timestamp
	Size       int    `json:"size"`
	MountPoint string `json:"mountPoint"`
}

type CloudDiskDataDetail struct {
	CloudDiskData
	ExpireTime int64 `json:"expireTime"`
}

type CloudDiskResult struct {
	models.CommonListPagination
	DataList  []CloudDiskData `json:"dataList"`
	DataTotal int
}

var BucketRequestDoc string = `
pageNo： 页数，必传eg: 1
pageSize： 页码，必传eg: 10
region:必传eg: all
az:必传eg: all
name:默认值 ""
id:默认值 ""
tenantId:默认值 ""
storageType:运行状态;默认值：[]
`

type BucketRequest struct {
	Pagination
	//ContentSelector string `json:"contentSelector"`
	//Count bool `json:"count"`
	Region      string   `json:"region"`
	Az          string   `json:"az"`
	Name        string   `json:"name"`
	Id          string   `json:"id"`
	TenantId    string   `json:"tenantId"`
	StorageType []string `json:"storageType"`

	SearchType  string `json:"searchType"`  // 搜索类型 name/id/tenantId
	SearchValue string `json:"searchValue"` // 搜索值 (注意要支持模糊搜索)
}

//type DomainName struct {
//    DomainType       string `json:"domainType"`
//    Endpoint         string `json:"endpoint"`
//    BucketDomainName string `json:"bucketDomainName"`
//}

//type BucketDataDetail struct {
//    Name                  string `json:"name"`
//    Id                    string `json:"Id"`
//    Region                string `json:"region"`
//    Type                  string `json:"type"`
//    Role                  string `json:"role"`
//    CurrentStorageTotal   string `json:"currentStorageTotal"`
//    DownLoadTotal30Days   string `json:"downLoadTotal30Days"`
//    RequestAPITotal30Days string `json:"requestAPITotal30Days"`
//    DomainName
//    CreateTime time.Time `json:"createTime"`
//}
//云硬盘概览页面struct//块存储资源池以及
type CloudDiskOverview struct {
	CloudDiskOverview   []OverView                     `json:"cloudDiskOverview"`
	StorageTypeOverview []OverView                     `json:"storageTypeOverview"`
	DistributedOverview []DistributedHistogramOverView `json:"distributedOverview"`
}

//对象存储概览页面struct//对象存储资源池以及
type ObjectStorageOverview struct {
	StorageCountOverview []OverView                     `json:"storageCountOverview"`
	StorageTypeOverview  []OverView                     `json:"storageTypeOverview"`
	DistributedOverview  []DistributedHistogramOverView `json:"distributedOverview"`
	// FileStorageOverview     map[string]int `json:"fileStorageOverview"`
	// StandardStorageOverview map[string]int `json:"standardStorageOverview"`
}
type OverView struct {
	Name  string `json:"name"`
	Code  string `json:"code"`
	Value int    `json:"value"`
}

// type DistributedOverView struct {
// 	Name        string     `json:"name"`
// 	Region      string     `json:"region"`
// 	Distributed []OverView `json:"distributed"`
// }
type HistogramOverView struct {
	Name   string `json:"name"`
	Region string `json:"region"`
	Az     string `json:"az"`
	Value  int    `json:"value"`
}
type DistributedHistogramOverView struct {
	Name        string              `json:"name"`
	Code        string              `json:"code"`
	Distributed []HistogramOverView `json:"distributed"`
}

type BucketStore struct {
	BucketCreatedTime      string `json:"bucketCreatedTime"`
	BucketDeletedFlag      bool   `json:"bucketDeletedFlag"`
	BucketLastModifiedTime string `json:"bucketLastModifiedTime"`
	Date                   string `json:"date"`
	DeleteSize             int64  `json:"deleteSize"`
	Id                     int64  `json:"id"`
	Name                   string `json:"name"`
	PutSize                int    `json:"putSize"`
	Region                 string `json:"region"`
	StorageClass           string `json:"storageClass"`
	Total                  int    `json:"total"`
	UserId                 string `json:"userId"`
}

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/pkg/models/bmpool/bmpool.go
```golang
package bmpool

import (
	"time"
)

type (
	OverviewRsp struct {
		BMInstanceOverview  OverviewSlot `json:"bmInstanceOverview"`
		BMInventoryOverview OverviewSlot `json:"bmInventoryOverview"`
	}

	OverviewSlot struct {
		Info    OverviewSlotInfo    `json:"info,omitempty"`
		Servers []OverviewSlotValue `json:"values,omitempty"`
	}

	OverviewSlotInfo struct {
		Name     string `json:"name"`
		Unit     string `json:"unit"`
		UnitType string `json:"unitType"`
		Value    int    `json:"value"`
	}

	OverviewSlotValue struct {
		Code     string `json:"code"`
		Name     string `json:"name"`
		Unit     string `json:"unit"`
		UnitType string `json:"unitType"`
		Value    int    `json:"value"`
	}

	ListReq struct {
		PageNo   int `json:"pageNo"`
		PageSize int `json:"pageSize"`
		// 模糊搜索
		SearchType  string `json:"searchType"`
		SearchValue string `json:"searchValue"`
		// SN 号
		SN string `json:"SN"`
		// 所属区域
		Region string `json:"region"`
		// 多选
		// 所属可用区
		AZ []string `json:"az"`
		// 库存状态
		InventoryStatus []string `json:"inventory_status"`
		// 实例类型
		InstanceType []string `json:"instance_type"`
		// 售卖租户ID
		UserID []int64 `json:"user_id"`
		// 售卖租户
		UserName []string `json:"user_name"`
		// 预留租户ID
		ReservedUserID []int `json:"reserved_user_id"`
		// 预留租户名称
		ReservedUserName []string `json:"reserved_user_name"`
		// 预留状态
		ReservationStatus string `json:"reservation_status"`
		// 排序
		OrderType string `json:"orderType"`
		OrderCode string `json:"orderCode"`
	}
	ListInfo struct {
		// SN号
		SN string `json:"SN"`
		// 所属区域
		Region string `json:"region"`
		// 所属可用区
		AZ string `json:"az"`
		// 库存状态
		InventoryStatus string `json:"inventory_status"`
		// 售卖租户ID
		UserID int64 `json:"user_id,omitempty"`
		// 售卖租户
		UserName string `json:"user_name"`
		// 机器套餐
		MachinePackage string `json:"machine_package"`
		// 实例类型
		InstanceType string `json:"instance_type"`
		// 实例配置
		InstanceConf string `json:"instance_conf"`
		CPU          string `json:"cpu"`
		Memory       string `json:"memory"`
		Storage      string `json:"storage"`
		// 预留状态
		ReservationStatus string `json:"reservation_status"`
		// 预留租户ID
		ReservedUserID int `json:"reserved_user_id,omitempty"`
		// 预留租户名称
		ReservedUserName string `json:"reserved_user_name"`
		// 预留天数
		ReservedTime int `json:"reserved_time,omitempty"`

		// 带外IP
		OutIP string `json:"out_ip"`
		// 机房名称
		Room string `json:"room"`
		// 机架位名称
		Rack string `json:"rack"`
		// 交换机管理IP
		IP string `json:"ip"`
		// 交换机端口
		Port int `json:"port"`
		// MAC
		Mac string `json:"mac"`
		// 入库时间
		InboundTime time.Time `json:"inbound_time"`
	}

	ListRsp struct {
		TotalCount int        `json:"totalCount"`
		PageNo     int        `json:"pageNo"`
		PageSize   int        `json:"pageSize"`
		DataList   []ListInfo `json:"dataList"`
	}

	ListOpInfo struct {
		// 所属可用区
		AZ []string `json:"az"`
		// 库存状态
		InventoryStatus []string `json:"inventory_status"`
		// 售卖租户ID
		UserID []int64 `json:"user_id"`
		// 售卖租户
		UserName []string `json:"user_name"`
		// 预留状态
		ReservationStatus []string `json:"reservation_status"`
		// 预留租户ID
		ReservedUserID []int `json:"reserved_user_id"`
		// 预留租户名称
		ReservedUserName []string `json:"reserved_user_name"`
		// 实例类型
		InstanceType []string `json:"instance_type"`
	}

	InventoryReq struct {
		PageNo   int `json:"pageNo"`
		PageSize int `json:"pageSize"`
		//单选
		Region string `json:"region"`
		//多选
		Az           []string `json:"az"`
		InstanceType []string `json:"instanceType"`
		//排序
		OrderCode string `json:"orderCode"` //inventoryTotal(库存总量),soldNum(已卖),reservedNum(已预留),forSaleNum(可卖量)
		OrderType string `json:"orderType"` //ascending, descending

	}
	InventoryRsp struct {
		TotalCount int             `json:"totalCount"`
		PageNo     int             `json:"pageNo"`
		PageSize   int             `json:"pageSize"`
		DataList   []InventoryInfo `json:"dataList"`
	}
	InventoryInfo struct {
		BmConf
		InstanceType   string `json:"instanceType"`
		Region         string `json:"region"`
		RegionName     string `json:"regionName"`
		Az             string `json:"az"`
		AzName         string `json:"azName"`
		InventoryTotal int64  `json:"inventoryTotal"` //库存总量
		SoldNum        int64  `json:"soldNum"`        //已卖
		ReservedNum    int64  `json:"reservedNum"`    //已预留
		ForSaleNum     int64  `json:"forSaleNum"`     //可卖量
	}

	BmConf struct {
		Cpu     string `json:"cpu"`
		Memory  string `json:"memory"`
		Storage string `json:"storage"`
	}
)

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/pkg/models/switch/switchParts.go
```golang
package switchMachine

type HealthChecker interface {
	GetHealth() int
}
type (
	SwitchFan struct {
		Name       string  `json:"name"`
		Health     int     `json:"health"` //1:健康；2：告警；3：故障；0：未知
		Exist      bool    `json:"exist"`  //false:不在位；true：在位
		Speed      int     `json:"speed"`  //rpm
		SpeedRatio float64 `json:"speedRatio"`
		Redundant  bool    `json:"redundant"` //false:不冗余；true：冗余
	}

	SwitchPower struct {
		Name            string `json:"name"`
		Health          int    `json:"health"` //1:健康；2：告警；3：故障；0：未知
		Exist           bool   `json:"exist"`  //false:不在位；true：在位
		Temperature     int    `json:"temperature"`
		RatedPower      int    `json:"ratedPower"`
		InPower         int    `json:"inPower"`
		InModel         string `json:"inModel"`
		PowerType       string `json:"powerType"`
		FirmwareVersion string `json:"firmwareVersion"`
		MfgName         string `json:"mfgName"`
		SerialNum       string `json:"serialNum"`
		PartNum         string `json:"partNum"`
	}

	SwitchCpu struct {
		Name        string  `json:"name"`
		Health      int     `json:"health"` //1:健康；2：告警；3：故障；0：未知
		Utilization float64 `json:"utilization"`
		Temperature int     `json:"temperature"`
		CpuType     string  `json:"cpuType"`
		MainHertz   float64 `json:"mainHertz"`
		MaxHertz    float64 `json:"maxHertz"`
		CacheLv     int     `json:"cacheLv"` //1：1级；2：2级；3：3级
	}

	SwitchMemory struct {
		Name        string  `json:"name"`
		Health      int     `json:"health"` //1:健康；2：告警；3：故障；0：未知
		Utilization float64 `json:"utilization"`
		Exist       bool    `json:"exist"` //false:不在位；true：在位
		Location    string  `json:"location"`
		Tunnel      string  `json:"tunnel"`
		SlotNum     string  `json:"slotNum"`
		MemType     string  `json:"memType"`
		Ranks       string  `json:"ranks"`
		BitWide     int     `json:"bitWide"`
		MaxHertz    float64 `json:"maxHertz"`
		Capacity    int     `json:"capacity"`
		Technology  string  `json:"technology"`
		MfgName     string  `json:"mfgName"`
		SerialNum   string  `json:"serialNum"`
		PartNum     string  `json:"partNum"`
	}

	SwitchBoard struct {
		Name             string `json:"name"`
		Health           int    `json:"health"` //1:健康；2：告警；3：故障；0：未知
		ManufacturedDate string `json:"manufacturedDate"`
		MfgName          string `json:"mfgName"`
		SerialNum        string `json:"serialNum"`
		PartNum          string `json:"partNum"`
	}

	SwitchView struct {
		AirInLet    int          `json:"airInLet"`
		AirOutLet   int          `json:"airOutLet"`
		IfHealth    SwitchHealth `json:"ifHealth"`
		CpuHealth   SwitchHealth `json:"cpuHealth"`
		MemHealth   SwitchHealth `json:"memHealth"`
		PowerHealth SwitchHealth `json:"powerHealth"`
		FanHealth   SwitchHealth `json:"fanHealth"`
	}

	SwitchHealth struct {
		Normal   int `json:"normal" gorm:"column:normal"`
		AbNormal int `json:"abNormal" gorm:"column:ab_normal"`
		Alarm    int `json:"alarm" gorm:"column:alarm"`
		UnKnown  int `json:"unKnown" gorm:"column:unKnown"`
		Total    int `json:"total" gorm:"column:total"`
	}
)

func (s SwitchFan) GetHealth() int {
	//TODO implement me
	return s.Health
}

func (s SwitchPower) GetHealth() int {
	//TODO implement me
	return s.Health
}

func (s SwitchCpu) GetHealth() int {
	//TODO implement me
	return s.Health
}

func (s SwitchMemory) GetHealth() int {
	//TODO implement me
	return s.Health
}

func (s SwitchBoard) GetHealth() int {
	//TODO implement me
	return s.Health
}
func (s SwitchView) GetHealth() int {
	//TODO implement me
	return 1
}

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/pkg/models/switch/switch.go
```golang
package switchMachine

import (
	"luban-cmdb-api/pkg/utils"
	"time"
)

type SwitchDetailDGraphMapping struct {
	QuerySwitchInfo []SwitchMapping `json:"querySwitchInfo"`
}
type SwitchListDGraphMapping struct {
	QueryUids []struct {
		Uid string `json:"uid"`
	} `json:"queryUids"`
	QuerySwitchInfo []SwitchMapping `json:"querySwitchInfo"`
}

type QueryUidBySwitchNameMapping struct {
	QueryUidBySwitchName []struct {
		Uid string `json:"uid"`
	} `json:"queryUidBySwitchName"`
}

type QueryOverviewMapping struct {
	SwitchStateOverview []struct {
		GroupBy []struct {
			RunStatus string `json:"runStatus"`
			Count     int    `json:"count"`
		} `json:"@groupby"`
	} `json:"switchStateOverview"`
	MaintenanceDue []struct {
		Count int `json:"count"`
	} `json:"maintenanceDue"`
	MaintenanceDue1m []struct {
		Count int `json:"count"`
	} `json:"maintenanceDue1m"`
	MaintenanceDue3m []struct {
		Count int `json:"count"`
	} `json:"maintenanceDue3m"`
	SwitchList []struct {
		Uid              string `json:"uid"`
		SwitchName       string `json:"switchName"`
		SwitchRegionName string `json:"switchRegionName"`
		SwitchAzName     string `json:"switchAzName"`
		SwitchLabName    string `json:"switchLabName"`
	} `json:"switchList"`
}

type SwitchListParams struct {
	PageSize          int      `json:"pageSize"`          //`json:"pageSize"`
	PageNo            int      `json:"pageNo"`            //`json:"pageNo"`
	RegionCode        string   `json:"region"`            //`json:"regionCode"`
	AzCode            []string `json:"az"`                //`json:"azCode"`
	LabCode           []string `json:"lab"`               //`json:"labCode"`
	Name              string   `json:"name"`              //`json:"name"`
	ManagementIp      string   `json:"managementIp"`      // 管理IP
	Sn                string   `json:"sn"`                // sn
	Manufacturer      []string `json:"manufacturer"`      //厂商列表
	Vendor            string   `json:"vendor"`            //厂商
	Role              []string `json:"switchRole"`        //角色
	SwitchType        string   `json:"switchType"`        //型号
	RunStatus         []string `json:"runStatus"`         //`json:"runStatus"`
	MaintenanceStatus []string `json:"maintenanceStatus"` //`json:"runStatus"`
}

type SwitchDeleteParams struct {
	Ids []int `json:"ids"`
}

type SwitchAddParams struct {
	//Switchs []SwitchNew `json:"switchs"`
	Switchs []MysqlSwitch `json:"switchs"`
}

type SwitchOverview struct {
	SwitchStateOverview       []OverviewSlot     `json:"switchStateOverview"`
	SwitchMaintenanceOverview []OverviewSlot     `json:"switchMaintenanceOverview"`
	SwitchLocationOverview    []LocationOverView `json:"switchLocationOverview"`
}

type OverviewSlot struct {
	Code   string `json:"code"`
	Name   string `json:"name"  gorm:"column:name"`
	Count  int64  `json:"value" gorm:"column:total"`
	Region string `json:"-" gorm:"column:region_code"`
	Az     string `json:"-" gorm:"column:az_code"`
	Unit   string `json:"unit"  gorm:"column:unit"`
}

type LocationOverView struct {
	Name   string `json:"name"`
	Region string `json:"region"`
	Az     string `json:"az"`
	//Lab         string     `json:"lab"`
	Distributed []OverviewSlot `json:"distributed"`
	//Distributed2 OverView `json:"distributed2"`
}

type SwitchUpdateParams struct {
	//Id             int            `json:"id"`
	//Name           string         `json:"name,omitempty"`
	LabCode string `json:"labCode"`
	//RackId         string         `json:"rackuID,omitempty"`
	//UnitNumber     string         `json:"unitNumber,omitempty"`
	//SwitchRole     string         `json:"switchRole"` // 角色
	//Sn             string         `json:"sn"`         // SN号
	//AssetNumber    string         `json:"assetNumber,omitempty"`
	//MaintenanceDue time.Time `json:"maintenanceDue,omitempty"`
	//MainMaintainer string         `json:"mainMaintainer"` // 维护人
	//Description    string         `json:"description"`    // 描述
	Uid       int    `json:"id"`
	Name      string `json:"name"`
	Ip        string `json:"ip"`
	RunStatus string `json:"runStatus"`
	//AzId              int    `json:"azId"` // TODO: 这里后续也需要修改回来
	AzCode            string `json:"azCode"`
	RegionId          int    `json:"regionId"`
	LabId             int    `json:"labId"`
	RoomId            int    `json:"roomId"`
	CabinetId         int    `json:"cabinetUid"`
	RackId            int    `json:"rackUid"`
	SwitchUnitNumber  int    `json:"switchUnitNumber"`
	Sn                string `json:"sn"`
	SwitchType        string `json:"switchType"`
	SwitchRole        string `json:"switchRole"`
	OutBandIp         string `json:"outBandIp"`
	MainMaintainer    string `json:"mainMaintainer"`
	MaintenanceDue    int64  `json:"maintenanceDue"`
	MaintenanceStatus string `json:"maintenanceStatus"`
	AssetsNumber      string `json:"assetsNumber"`
	InputTime         int64  `json:"inputTime"`
	SystemSales       string `json:"systemSales"`
	HardwareVersion   string `json:"hardwareVersion"`
	OsVersion         string `json:"osVersion"`
	Description       string `json:"description"`
	Creator           string `json:"creator"`
	Updater           string `json:"updater"`
	OperateSystem     string `json:"operateSystem"`
}

type SwitchListResult struct {
	TotalCount int64       `json:"totalCount"`
	PageNo     int         `json:"pageNo"`
	PageSize   int         `json:"pageSize"`
	DataList   []SwitchNew `json:"dataList"`
}

type Switch struct {
	Uid                string `json:"uid,omitempty" gorm:"column:id"`                                 // Uid
	SwitchName         string `json:"switchName,omitempty" gorm:"column:switch_name"`                 // 名称
	RunStatus          string `json:"runStatus,omitempty" gorm:"column:run_status"`                   // 运行状态
	Sn                 string `json:"sn,omitempty" gorm:"column:sn"`                                  // SN号
	Role               string `json:"role,omitempty" gorm:"column:role"`                              // 角色
	UnitNumber         string `json:"unitNumber,omitempty" gorm:"column:unit_number"`                 // 所占U位
	SwitchType         string `json:"switchType,omitempty" gorm:"column:switch_type"`                 // 交换机型号
	ManagementIP       string `json:"managementIP,omitempty" gorm:"column:management_ip"`             // 管理IP
	OutBandIP          string `json:"outbandIP,omitempty" gorm:"column:out_band_ip"`                  // 外带IP
	SwitchManufacturer string `json:"switchManufacturer,omitempty" gorm:"column:switch_manufacturer"` // 交换机厂商
	//MaintenanceDue     utils.Datetime `json:"maintenanceDue,omitempty" gorm:"column:maintenance_due"`     // 维保到期时间
	MaintenanceDue time.Time `json:"maintenanceDue,omitempty" gorm:"column:maintenance_due"` // 维保到期时间
	Maintainer     string    `json:"maintainer,omitempty" gorm:"column:maintainer"`          // 维护人
	//CreateTime         utils.Datetime `json:"createTime,omitempty" gorm:"column:create_time"`         // 创建时间
	CreateTime         time.Time `json:"createTime,omitempty" gorm:"column:create_time"`                  // 创建时间
	PackForwardingRate string    `json:"packForwardingRate,omitempty" gorm:"column:pack_forwarding_rate"` // 包转发率
	SwapMem            string    `json:"swapMem,omitempty" gorm:"column:swap_mem"`                        // 交换容量
	SlotCount          int       `json:"slotCount,omitempty" gorm:"column:slot_count"`                    // 业务槽位
	SwapSlotCount      int       `json:"swapSlotCount,omitempty" gorm:"column:swap_slot_count"`           // 交换槽位
	SwitchNo           string    `json:"switchNo,omitempty" gorm:"column:switch_no"`                      // 资产编号
	Power              string    `json:"power,omitempty" gorm:"column:power"`                             // 电源
	WorkRate           string    `json:"workRate,omitempty" gorm:"column:work_rate"`                      // 功率
	Label              string    `json:"label,omitempty" gorm:"column:label"`                             // 标签
	Description        string    `json:"description,omitempty" gorm:"column:description"`                 // 描述
	SwitchRegionName   string    `json:"switchRegionName,omitempty" gorm:"column:switch_region_name"`
	SwitchRegionCode   string    `json:"switchRegionCode,omitempty" gorm:"column:switch_region_code"`
	SwitchAzName       string    `json:"switchAzName,omitempty" gorm:"column:switch_az_name"`
	SwitchAzCode       string    `json:"switchAzCode,omitempty" gorm:"column:switch_az_code"`
	SwitchLabName      string    `json:"switchLabName,omitempty" gorm:"column:switch_lab_name"`
	SwitchLabCode      string    `json:"switchLabCode,omitempty" gorm:"column:switch_lab_code"`
	SwitchRackName     string    `json:"switchRackName,omitempty" gorm:"column:switch_rack_name"`
	SwitchRackCode     string    `json:"switchRackCode,omitempty" gorm:"column:switch_rack_code"`
	AssetNumber        string    `json:"assetNumber,omitempty" gorm:"column:asset_number"`
	SwitchRoomCode     string    `json:"switchRoomCode,omitempty" gorm:"column:switch_room_code"`
	SwitchRoomName     string    `json:"switchRoomName,omitempty" gorm:"column:switch_room_name"`
	SwitchCabintCode   string    `json:"switchCabintCode,omitempty" gorm:"column:switch_cabint_code"`
	SwitchCabintName   string    `json:"switchCabintName,omitempty" gorm:"column:switch_cabint_name"`
	//Cpu                []CPU      `json:"cpu"`
	//Memory             []Memory   `json:"memory"`
	//PortInfos          []PortInfo `json:"switch_port"`
	UplinkSwitch   []Switch `json:"uplinkSwitch,omitempty"`   // 上联交换机
	DownLinkSwitch []Switch `json:"downLinkSwitch,omitempty"` // 下联交换机
}

type SwitchNew struct {
	Id                 int    `json:"id" gorm:"column:id;"`                                 // Uid
	Name               string `json:"name" gorm:"column:name;unique"`                       // 名称
	RunStatus          string `json:"runStatus" gorm:"column:run_status"`                   // 运行状态
	SnmpStatus         int    `json:"snmpStatus" gorm:"column:snmp_status"`                 // snmp状态
	Sn                 string `json:"sn" gorm:"column:sn;unique"`                           // SN号
	SwitchRole         string `json:"switchRole" gorm:"column:switch_role"`                 // 角色
	SwitchRoleZh       string `json:"switchRoleZh" gorm:"column:switch_role_zh"`            // 角色中文
	SwitchRackName     string `json:"rackName" gorm:"column:Switch_rack_name"`              // 机架位名称
	SwitchUnitNumber   int    `json:"switchUnitNumber" gorm:"column:switch_unit_number"`    // 所占U位
	SwitchType         string `json:"switchType" gorm:"column:switch_type"`                 // 交换机型号
	ManagementIP       string `json:"managementIp" gorm:"column:management_ip"`             // 管理IP
	OutBandIP          string `json:"outbandIP" gorm:"column:out_band_ip"`                  // 外带IP
	SwitchManufacturer string `json:"switchManufacturer" gorm:"column:switch_manufacturer"` // 交换机厂商
	//MaintenanceDue     utils.Datetime `json:"maintenanceDue" gorm:"column:maintenance_due"`         // 维保到期时间
	MaintenanceDue    int    `json:"maintenanceDue" gorm:"column:maintenance_due"`       // 维保到期时间
	MainMaintainer    string `json:"mainMaintainer" gorm:"column:main_maintainer"`       // 维护人
	MaintenanceStatus string `json:"maintenanceStatus" gorm:"column:maintenance_status"` // 维保状态
	InterfaceCount    int    `json:"interfaceCount" gorm:"column:interface_count"`       //接口数量
	OsVersion         string `json:"osVersion" gorm:"column:os_version"`                 // OS版本
	HardwareVersion   string `json:"hardwareVersion" gorm:"column:hardware_version"`     // 硬件版本
	AssetsNumber      string `json:"assetsNumber" gorm:"column:assets_number"`           // 资产编号
	Label             string `json:"label" gorm:"column:label"`                          // 标签
	Description       string `json:"description" gorm:"column:description"`              // 描述
	RegionName        string `json:"regionName" gorm:"column:region_name"`
	RegionCode        string `json:"regionCode" gorm:"column:region_code"`
	AzName            string `json:"azName" gorm:"column:az_name"`
	AzCode            string `json:"azCode" gorm:"column:az_code"`
	AzId              int    `json:"azId" gorm:"column:az_id"`
	LabName           string `json:"labName" gorm:"column:lab_name"`
	LabCode           string `json:"labCode" gorm:"column:lab_code"`
	RoomUid           int    `json:"roomUid,omitempty" gorm:"column:room_id"`
	RoomCode          string `json:"roomCode,omitempty" gorm:"column:room_code"`
	RoomName          string `json:"roomName,omitempty" gorm:"column:room_name"`
	CabinetId         int    `json:"cabinetUid" gorm:"column:cabinet_id"`
	CabinetCode       string `json:"cabinetCode" gorm:"column:cabinet_code"`
	CabinetName       string `json:"cabinetName" gorm:"column:cabinet_name"`
	RackId            int    `json:"rackUid" gorm:"column:rack_id"`
	InputTime         int    `json:"inputTime" gorm:"column:input_time"`
	CreateTime        int    `json:"createTime" gorm:"column:create_time"` // 创建时间
	Creator           string `json:"creator" gorm:"column:creator"`        // 创建人
	Updater           string `json:"updater" gorm:"column:updater"`        // 更新者
	UpdateTime        int    `json:"updateTime" gorm:"column:update_time"` // 更新时间
	CpuModel          string `json:"cpuModel" gorm:"column:cpu_model"`
	MemModel          string `json:"memModel" gorm:"column:mem_model"`
	//TotalCount         int            `json:"-" gorm:"column:total_count"`
	//PowerWorkRate      string         `json:"powerWorkRate"`      //  电源功率
	Cpu       []CPU         `json:"cpu" gorm:"-"`
	Memory    []Memory      `json:"memory" gorm:"-"`
	Power     []PowerSupply `json:"power" gorm:"-"`
	PortInfos []PortInfo    `json:"switch_port" gorm:"-"`
}

type SwitchMapping struct {
	Uid                string         `json:"uid,omitempty"`            // Uid
	SwitchName         string         `json:"switchName"`               // 名称
	RunStatus          string         `json:"runStatus"`                // 运行状态
	Sn                 string         `json:"sn"`                       // SN号
	Role               string         `json:"role"`                     // 角色
	UnitNumber         string         `json:"unitNumber"`               // 所占U位
	SwitchType         string         `json:"switchType"`               // 交换机型号
	ManagementIP       string         `json:"managementIP"`             // 管理IP
	OutBandIP          string         `json:"outbandIP"`                // 外带IP
	SwitchManufacturer string         `json:"switchManufacturer"`       // 交换机厂商
	MaintenanceDue     utils.Datetime `json:"maintenanceDue,omitempty"` // 维保到期时间
	Maintainer         string         `json:"maintainer"`               // 维护人
	CreateTime         utils.Datetime `json:"createTime"`               // 创建时间
	PackForwardingRate string         `json:"packForwardingRate"`       // 包转发率
	SwapMem            string         `json:"swapMem"`                  // 交换容量
	SlotCount          int            `json:"slotCount"`                // 业务槽位
	SwapSlotCount      int            `json:"swapSlotCount"`            // 交换槽位
	SwitchNo           string         `json:"switchNo"`                 // 资产编号
	Power              string         `json:"power"`                    // 电源
	WorkRate           string         `json:"workRate"`                 // 功率
	Label              string         `json:"label"`                    // 标签
	Description        string         `json:"description"`              // 描述
	SwitchRegionName   string         `json:"switchRegionName"`
	SwitchRegionCode   string         `json:"switchRegionCode"`
	SwitchAzName       string         `json:"switchAzName"`
	SwitchAzCode       string         `json:"switchAzCode"`
	SwitchLabName      string         `json:"switchLabName"`
	SwitchLabCode      string         `json:"switchLabCode"`
	SwitchRackName     string         `json:"switchRackName"`
	SwitchRackCode     string         `json:"switchRackCode"`
	AssetNumber        string         `json:"assetNumber"`
	SwitchRoomCode     string         `json:"switchRoomCode"`
	SwitchRoomName     string         `json:"switchRoomName"`
	SwitchCabintCode   string         `json:"switchCabintCode"`
	SwitchCabintName   string         `json:"switchCabintName"`
	//Cpu                []CPU      `json:"cpu"`
	//Memory             []Memory   `json:"memory"`
	//PortInfos          []PortInfo `json:"switch_port"`
	UplinkSwitch   []Switch `json:"up_edge"`  // 上联交换机
	DownLinkSwitch []Switch `json:"~up_edge"` // 下联交换机
}

type CPU struct {
	CPUType   string `json:"cpuType,omitempty"`   // 型号
	CoreCount int    `json:"coreCount,omitempty"` // 总核心数
	//Frequency string `json:"frequency,omitempty"` // 频率
}

type Memory struct {
	//MemoryType string `json:"memoryType,omitempty"` // 型号
	MemoryCap string `json:"memoryCapTotal,omitempty" gorm:"column:memory_cap_total"` // 总容量
	Count     int    `json:"count,omitempty" gorm:"column:slot"`                      // 数量
}

type PowerSupply struct {
	//MemoryType string `json:"memoryType,omitempty"` // 型号
	Voltage string `json:"voltage,omitempty" gorm:"column:voltage"` // 额定电压
	Power   string `json:"power,omitempty" gorm:"column:power"`     // 额定功率
}

type PortInfo struct {
	PortType    string `json:"portType,omitempty"`    // 类型
	PortMarking string `json:"portMarking,omitempty"` // 型号
	PortSpecs   string `json:"portSpecs,omitempty"`   // 规格
	Count       int    `json:"count,omitempty"`       // 数量
}
type SwitchInterfaceLayout struct {
	SwitchClass   int    `json:"switchClass" gorm:"column:switch_class"`     //  not null comment '交换机分类',
	SwitchType    string `json:"switchType" gorm:"column:switch_type"`       //not null comment '交换机类型',
	InterfaceType string `json:"interfaceType" gorm:"column:interface_type"` // not null comment '接口类型',
	Address       string `json:"address" gorm:"column:address"`              //not null comment '位置信息，',
	StartIndex    int    `json:"startIndex" gorm:"column:start_index"`       //not null comment '接口起始index',
	X             int    `json:"X" gorm:"column:x"`                          // not null comment '行',
	Y             int    `json:"y" gorm:"column:y"`                          // not null comment '列',
}

type SwitchInterfaceLayoutListParams struct {
	PageSize int    `json:"pageSize"` //`json:"pageSize"`
	PageNo   int    `json:"pageNo"`   //`json:"pageNo"`
	Sn       string `json:"sn"`
	Index    string `json:"index"`
}
type SwitchInterfaceLayoutListResult struct {
	TotalCount int64 `json:"totalCount"`
	//PageNo     int                     `json:"pageNo"`
	//PageSize   int                     `json:"pageSize"`
	DataList []SwitchInterfaceLayout `json:"dataList"`
}

type SwitchInterfaceInfo struct {
	ManagementIp  string `json:"managementIp" gorm:"column:management_ip"`
	OutBandIp     string `json:"outBandIp" gorm:"column:out_band_ip"`
	SwitchType    string `json:"switchType" gorm:"column:switch_type"`
	InterfaceType string `json:"interfaceType" gorm:"column:interface_type"`
	Index         int    `json:"index" gorm:"column:xc"`
}

type SwitchInterfaceInfoResult struct {
	TotalCount int64                 `json:"totalCount"`
	PageNo     int                   `json:"pageNo"`
	PageSize   int                   `json:"pageSize"`
	DataList   []SwitchInterfaceInfo `json:"dataList"`
}

type SwitchInterfaceDetail struct {
	Id                int       `json:"-" gorm:"column:id"`
	Sn                string    `gorm:"column:sn" json:"sn"`
	IfName            string    `gorm:"column:if_name" json:"ifName"`
	IfIndex           int       `gorm:"column:if_index" json:"ifIndex"`
	IfStatus          int       `gorm:"column:if_status" json:"ifStatus"`
	IfIp              string    `gorm:"column:if_ip" json:"ifIp"`
	IfMac             string    `gorm:"column:if_mac" json:"ifMac"`
	IfType            string    `gorm:"column:if_type;<-:false" json:"ifType"`
	IfSpeed           int       `gorm:"column:if_speed" json:"ifSpeed"`
	OrtherEndDevice   string    `gorm:"column:orther_end_device" json:"ortherEndDevice"`
	OrtherEndDeviceId int       `json:"ortherEndDeviceId" gorm:"column:orther_end_id;<-:false"`
	OrtherEndIf       string    `gorm:"column:orther_end_if" json:"ortherEndIf"`
	OrtherEndDescr    string    `gorm:"column:orther_end_descr" json:"ortherEndDescr"`
	OrtherEndType     string    `json:"ortherEndType" gorm:"column:orther_end_type"`
	AdminState        int       `json:"adminState" gorm:"column:admin_state"`
	OperState         int       `json:"operState" gorm:"column:oper_state"`
	PortState         int       `json:"portState" gorm:"column:port_state"`
	LastUpdateAt      time.Time `json:"last_update_at" gorm:"column:last_update_at"`
}

type SwitchInterfaceDetailResult struct {
	DataList []SwitchInterfaceDetail `json:"dataList"`
}

type MysqlSwitch struct {
	Uid              int    `json:"id" gorm:"primaryKey;column:id"`
	Name             string `json:"name" gorm:"column:name"`
	Ip               string `json:"ip" gorm:"column:ip"`
	RunStatus        string `json:"runStatus" gorm:"column:run_status"`
	AzId             int    `json:"azId" gorm:"column:az_id"`
	RegionId         int    `json:"regionId" gorm:"column:region_id"`
	LabId            int    `json:"labId" gorm:"column:lab_id"`
	RoomId           int    `json:"roomId" gorm:"column:room_id"`
	CabinetId        int    `json:"cabinetId" gorm:"column:cabinet_id"`
	RackId           int    `json:"rackId" gorm:"column:rack_id"`
	SwitchUnitNumber int    `json:"switchUnitNumber" gorm:"column:switch_unit_number"`
	Sn               string `json:"sn" gorm:"column:sn"`
	SwitchType       string `json:"switchType" gorm:"column:switch_type"`
	SwitchRole       string `json:"switchRole" gorm:"column:switch_role"`
	OutBandIp        string `json:"outBandIp" gorm:"column:out_band_ip"`
	//Community         string    `json:"community" gorm:"column:community"`
	MainMaintainer    string    `json:"mainMaintainer" gorm:"column:main_maintainer"`
	MaintenanceDue    time.Time `json:"maintenanceDue" gorm:"column:maintenance_due"`
	MaintenanceStatus string    `json:"maintenanceStatus" gorm:"column:maintenance_status"`
	AssetsNumber      string    `json:"assetsNumber" gorm:"column:assets_number"`
	InputTime         time.Time `json:"inputTime" gorm:"column:input_time"`
	SystemSales       string    `json:"systemSales" gorm:"column:system_sales"`
	HardwareVersion   string    `json:"hardwareVersion" gorm:"column:hardware_version"`
	OsVersion         string    `json:"osVersion" gorm:"column:os_version"`
	Description       string    `json:"description" gorm:"column:description"`
	CpuModel          string    `json:"cpuModel" gorm:"column:cpu_model"`
	MemModel          string    `json:"memModel" gorm:"column:mem_model"`
	Creator           string    `json:"creator" gorm:"column:creator"`
	CreateTime        time.Time `json:"createTime" gorm:"column:create_time;autoCreateTime"`
	Updater           string    `json:"updater" gorm:"column:updater"`
	UpdateTime        time.Time `json:"updateTime" gorm:"column:update_time;autoUpdateTime"`
	OperateSystem     string    `json:"operateSystem" gorm:"column:operate_system"`
}
type PhysicalSwitch struct {
	Name          string `json:"name" gorm:"column:name"`
	Ip            string `json:"ip" gorm:"column:ip"`
	PhysicalType  string `json:"physicalType" gorm:"column:physical_type"`
	Id            int    `json:"-" gorm:"column:id"`
	RegionId      int    `json:"-" gorm:"region_id"`
	AzId          int    `json:"-" gorm:"az_id"`
	Mib           string `json:"mib" gorm:"column:mib"`
	IntervalTime  string `json:"interval_time" gorm:"column:interval_time"`
	ScrapeTimeout string `json:"scrape_timeout" gorm:"column:scrape_timeout"`
}

type PhysicalSwitchMib struct {
	Id            int       `json:"id" gorm:"column:id;"`
	MibType       string    `json:"mib_type" gorm:"column:mib_type"`
	Name          string    `json:"name" gorm:"column:name"`
	Oid           string    `json:"oid" gorm:"column:oid"`
	Type          string    `json:"type" gorm:"column:type"`
	Help          string    `json:"help" gorm:"column:help"`
	Indexes       string    `json:"indexes" gorm:"column:indexes"`
	Lookups       string    `json:"lookups" gorm:"column:lookups"`
	ScrapeTimeout string    `json:"scrape_timeout" gorm:"column:scrape_timeout"`
	CreateTime    time.Time `json:"createTime" gorm:"column:create_time;create_time"`
}

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/pkg/models/rack/rack.go
```golang
package rack

import (
	"time"
)

type (
	RackListResponse struct {
		TotalCount int64      `json:"totalCount"`
		PageNo     int        `json:"pageNo"`
		PageSize   int        `json:"pageSize"`
		DataList   []RackInfo `json:"dataList"`
	}

	SimpleSliceResponse struct {
		RackSlice []Rack `json:"rackSlice"`
	}

	QueryRackParam struct {
		//PageNo           int      `json:"pageNo"  validate:"gte=1"`
		//PageSize         int      `json:"pageSize" validate:"gte=1" `
		PageNo           int      `json:"pageNo"`
		PageSize         int      `json:"pageSize"`
		Region           string   `json:"region"`
		Azs              []string `json:"azs"`
		RackName         string   `json:"rackName"`
		RackLabs         []string `json:"rackLabs"`
		RackLabCodes     []string `json:"rackLabCodes"`
		RackRoomCodes    []string `json:"rackRoomCodes"`
		RackCabinetCodes []string `json:"rackCabinetCodes"`
		RackStatus       []string `json:"rackStatus"`
	}

	QueryRackByCabinetParam struct {
		CabinetId []int `json:"cabinetId"`
	}

	GetRackList struct {
		RackInfoCount []struct {
			RackTotal int `json:"rackTotal"`
		} `json:"rackInfoCount"`
		RackInfoList []RackInfo `json:"rackInfoList"`
	}

	// RackInfo 机架位查询bean
	Rack struct {
		Id       int    `json:"id" gorm:"column:id"`
		RackName string `json:"rackName" gorm:"column:rack_name"`
	}
	RackInfo struct {
		Uid              int    `json:"uid" gorm:"column:id"`                                    // ID
		RackRegionCode   string `json:"rackRegionCode,omitempty" gorm:"column:rack_region_code"` // 区域code
		RackAzCode       string `json:"rackAzCode,omitempty" gorm:"column:rack_az_code"`         // 可用区code
		RackRegionName   string `json:"rackRegionName,omitempty" gorm:"column:rack_region_name"` // 区域名称
		RackAzName       string `json:"rackAzName,omitempty" gorm:"column:rack_az_name"`         // 可用区名称
		RackName         string `json:"rackName" gorm:"column:rack_name"`                        // 机架位名称
		RackLab          string `json:"rackLab" gorm:"column:rack_lab"`                          // 所属机房
		RackLabCode      string `json:"rackLabCode" gorm:"column:rack_lab_code"`                 // 所属机房代号
		RackRoomCode     string `json:"rackRoomCode" gorm:"column:rack_room_code"`               // 所属房间code
		RackRoomName     string `json:"rackRoomName" gorm:"column:rack_room_name"`               // 所属房间code
		RackCabinetCode  string `json:"rackCabinetCode" gorm:"column:rack_cabinet_name"`         // 所属机柜
		RackStatus       int    `json:"rackStatus" gorm:"column:rack_status"`                    // 机架位状态 0：未占用 1：占用
		RackResourceType string `json:"rackResourceType" gorm:"column:rack_resource_type"`       // 占用资源类型
		RackResourceName string `json:"rackResourceName" gorm:"column:rack_resource_name"`       // 资源名称
		RackCreateTime   string `json:"rackCreateTime" gorm:"column:rack_create_time"`           // 创建时间
		RackUpdateTime   string `json:"rackUpdateTime" gorm:"column:rack_update_time"`           // 更新时间
		RackCreator      string `json:"rackCreator" gorm:"column:rack_creator"`                  // 创建人
		RackCount        int64  `json:"-" gorm:"-"`
	}

	RackList struct {
		RackInfoList []RackEntity `json:"rackInfoList"`
	}

	RackEntity struct {
		Uid              int    `json:"uid,omitempty" gorm:"column:id"`                              // UID   用于修改。。。
		RackName         string `json:"rackName,omitempty" gorm:"column:rack_name"`                  // 机架位名称
		RackLab          string `json:"rackLab,omitempty" gorm:"column:rack_lab"`                    // 所属机房
		RackLabCode      string `json:"rackLabCode,omitempty" gorm:"column:rack_lab_code"`           // 所属机房代号
		RackRoomCode     string `json:"rackRoomCode,omitempty" gorm:"column:rack_room_code"`         // 所属房间code
		RackCabinetCode  string `json:"rackCabinetCode,omitempty" gorm:"column:rack_cabinet_code"`   // 所属机柜
		RackStatus       int    `json:"rackStatus" gorm:"column:rack_status"`                        // 机架位状态 0：未占用 1：占用
		RackResourceType string `json:"rackResourceType,omitempty" gorm:"column:rack_resource_type"` // 占用资源类型
		RackResourceName string `json:"rackResourceName,omitempty" gorm:"column:rack_resource_name"` // 资源名称
		RackResourceSn   string `json:"rackResourceSn,omitempty" gorm:"column:rack_resource_sn"`     // 资源SN
		//RackCreateTime   time.Time      `json:"rackCreateTime,omitempty"`   // 创建时间
		RackUpdateTime time.Time `json:"rackUpdateTime,omitempty" gorm:"column:rack_update_time"` // 更新时间
		RackCreator    string    `json:"rackCreator,omitempty" gorm:"column:rack_creator"`        // 创建人
	}
)

var GetRackListDoc = `
pageSize：分页展示条数
pageNo：页数
region: 区域
azs: 可用区列表
rackName:机架位名称
rackLabs: 所属机房列表
rackLabCodes: 所属机房代号列表
rackRoomCodes: 所属房间列表
rackCabinetCodes: 所属机柜列表
rackStatus: 机架位状态列表 0：未占用 1：占用
`

var RackInfoDoc = `
 返回机架位信息注释
      "uid": ID
      "rackName": 机架位名称,
      "rackLab": 所属机房,
      "rackLabelCode": 所属机房代号,
      "rackRoomCode": 所属房间code,
      "rackCabinetCode": 所属机柜,
      "rackResourceType": 占用资源类型,
      "RackResourceName": 资源名称,
      "rackStatus": 机架位状态 0：未占用 1：占用
`

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/pkg/models/yaml/yaml.go
```golang
package yaml

type ServiceData struct {
	ProcessNames []Service `yaml:"process_names"`
}
type Service struct {
	Name        string   `yaml:"name"`
	CmdLine     []string `yaml:"cmdline"`
	ServiceName string   `yaml:"service_name"`
	Hosts       []string `yaml:"hosts"`
}

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/pkg/models/deviceroom/deviceroom.go
```golang
package deviceroom

import (
	"time"
)

type Contact struct {
	Uid                          int    `json:"uid" gorm:"column:id"`
	DeviceRoomContactName        string `json:"linkName" gorm:"column:name"`
	DeviceRoomContactPhoneNumber string `json:"linkPhoneNumber" gorm:"column:phone"`
}

type DeviceRoom struct {
	Uid                      int       `json:"uid" gorm:"column:id"`
	DeviceRoomCode           string    `json:"deviceRoomCode,omitempty" gorm:"column:room_code"`
	DeviceRoomName           string    `json:"deviceRoomName,omitempty" gorm:"column:room_name"`
	DeviceRoomDesc           string    `json:"deviceRoomDesc,omitempty" gorm:"column:room_desc"`
	DeviceRoomComputerRoomId int       `json:"-"`
	DeviceRoomMainContact    Contact   `json:"deviceRoom_mainContact,omitempty" gorm:"-"`
	DeviceRoomOtherContacts  []Contact `json:"deviceRoom_otherContacts,omitempty" gorm:"-"`
	DeviceRoomCreateTime     time.Time `json:"deviceRoomCreateTime,omitempty" gorm:"column:create_time"`
	DeviceRoomUpdateTime     time.Time `json:"deviceRoomUpdateTime,omitempty" gorm:"column:update_time"`
	DeviceRoomCreator        string    `json:"deviceRoomCreator,omitempty" gorm:"column:creator"`
	AzCode                   string    `json:"azCode,omitempty" gorm:"column:az_code"`
	AzName                   string    `json:"azName,omitempty" gorm:"column:az_name"`
	RegionCode               string    `json:"regionCode,omitempty" gorm:"column:region_code"`
}

type ComputerRoomInfo struct {
	Uid              int    `json:"uid,omitempty"  gorm:"column:lab_id"`
	ComputerRoomCode string `json:"computerRoomCode,omitempty" gorm:"column:lab_name" argType:"body" argDoc:"机房的code"`
	ComputerRoomName string `json:"computerRoomName,omitempty"  gorm:"column:lab_name" argType:"body" argDoc:"机房的名称"`
}
type LabInfo struct {
	LabId   int    `json:"lab_id,omitempty"  gorm:"column:lab_id"`
	LabCode string `json:"computerRoomCode,omitempty" gorm:"column:lab_code" argType:"body" argDoc:"机房的code"`
	LabName string `json:"computerRoomName,omitempty"  gorm:"column:lab_name" argType:"body" argDoc:"机房的名称"`
}

type CabinetCountInfo struct {
	RackNum    int `json:"rackNum,omitempty" argType:"body" argDoc:"机架数量"`
	UsedUNum   int `json:"usedUNum,omitempty" argType:"body" argDoc:"已使用的U位数量"`
	UnusedUNum int `json:"unusedUNum,omitempty" argType:"body" argDoc:"未使用的U位数量"`
}

type RoomFullInfo2 struct {
	DeviceRoom
	LabInfo
	CabinetNum int `json:"cabinetNum,omitempty" argType:"body" argDoc:"机柜数量"`
	CabinetCountInfo
}

type PageDeviceRoomFullInfo2 struct {
	Page  int             `json:"page,omitempty"`
	Size  int             `json:"size,omitempty"`
	Total int             `json:"total,omitempty"`
	Rooms []RoomFullInfo2 `json:"rooms,omitempty"`
}
type BasicRoom struct {
	RoomUid  int    `json:"roomUid"`
	RoomName string `json:"roomName,omitempty"`
}

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/pkg/models/businessManagement/noderef.go
```golang
package businessManagement

// 这个文件只有业务拓扑页面的挂载节点和卸载节点
// 这里的结构适用于构建树结构(挂载)，因为节点这个概念压根就没有层级关系故引入该结构
// 根节点ROOT没有实际节点对应，他的parentId等于负的treeId
type NodeRef struct {
	RefId      int        `gorm:"column:ref_id;primary_key" json:"refId"`
	RealNodeId int        `gorm:"real_node_id" json:"realNodeId"`
	ParentId   int        `gorm:"parent_id" json:"parentId"`
	TreeId     int        `gorm:"tree_id" json:"treeId"`
	Data       Node       `gorm:"-" json:"data"`
	Children   []*NodeRef `gorm:"-" json:"children,omitempty"`
}

func (m *NodeRef) TableName() string {
	return "asset_business_management_node_ref"
}

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/pkg/models/businessManagement/service.go
```golang
package businessManagement

import "time"

type Service struct {
	Id         int       `gorm:"column:id" json:"id"`            // ID
	Name       string    `gorm:"column:name" json:"name"`        // 服务名称
	BuiltIn    int8      `gorm:"column:built_in" json:"builtIn"` // 是否是内置(1:内置;2:自定义)
	RegionCode string    `gorm:"region_code" json:"regionCode"`  // 所在的区域
	RegionName string    `gorm:"-" json:"regionName"`            // 所在的区域
	Creator    string    `gorm:"column:creator" json:"creator"`  // 创建人
	CreateTime time.Time `gorm:"column:create_time" json:"createTime"`
	Updater    string    `gorm:"column:updater" json:"updater"` // 修改人
	UpdateTime time.Time `gorm:"column:update_time" json:"updateTime"`
}

func (m *Service) TableName() string {
	return "asset_business_management_service"
}

type BusinessServiceGroup struct {
	ServiceGroupId   int    `json:"serviceGroupId"`
	ServiceGroupName string `json:"serviceGroupName"`
	RegionCode       string `json:"regionCode"`
	RegionName       string `json:"regionName"`
	//Az               string `json:"az"`
}

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/pkg/models/businessManagement/tree.go
```golang
package businessManagement

import "time"

type Tree struct {
	Id         int       `gorm:"column:id" json:"id"`         // ID
	Name       string    `gorm:"column:name" json:"name"`     // 业务树名称
	Status     int16     `gorm:"column:status" json:"status"` // 生命周期(1:已上线；2测试中;3停运)
	RegionName string    `gorm:"-" json:"regionName"`
	RegionCode string    `gorm:"column:region_code" json:"regionCode"` // region code
	BuiltIn    int8      `gorm:"column:built_in" json:"builtIn"`       // 是否是内置
	Creator    string    `gorm:"column:creator" json:"creator"`        // 创建人
	CreateTime time.Time `gorm:"column:create_time" json:"createTime"`
	Updater    string    `gorm:"column:updater" json:"updater"` // 修改人
	UpdateTime time.Time `gorm:"column:update_time" json:"updateTime"`
}

func (m *Tree) TableName() string {
	return "asset_business_management_tree"
}

type Topology struct {
	Key        string      `json:"key"`
	Name       string      `json:"name"`
	RefId      int         `json:"refId"`
	RealNodeId int         `json:"realNodeId"`
	ServiceId  int         `json:"serviceId"`
	ParentId   int         `json:"-"`
	IsLeaf     bool        `json:"isLeaf"` // 前端使用，这里可以理解为是不是服务。
	Children   []*Topology `json:"children"`
}

type QueryTreeListParams struct {
	RegionCode string `json:"regionCode"`
	Status     []int  `json:"status"`
	PageSize   int    `json:"pageSize"`
	PageNo     int    `json:"pageNo"`
	SortField  string `json:"sortField"`
	SortType   string `json:"sortType"`
}

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/pkg/models/businessManagement/defineValue.go
```golang
package businessManagement

const (
	HOST_TYPE_PHYSICAL int = 0 //物理机
	HOST_TYPE_VIRTUAL  int = 1 //虚拟机
)

const (
	BUILT_IN_NO  int8 = 0 // 自定义
	BUILT_IN_YES int8 = 1 // 内置
)

const (
	PROTOCOL_TCP   int16 = 1
	PROTOCOL_UDP   int16 = 2
	PROTOCOL_HTTP  int16 = 3
	PROTOCOL_HTTPS int16 = 4
	PROTOCOL_ICMP  int16 = 5
	PROTOCOL_DNS   int16 = 6
	PROTOCOL_SSH   int16 = 7
)

const (
	TREE_STATUS_ONLINE  int16 = 1 //已上线
	TREE_STATUS_TESTING int16 = 2 //测试中
	TREE_STATUS_DONE    int16 = 3 //停运
)

const (
	ROOT_NODEREF_NAME = "ROOT"
)

const (
	DELETED_YES int8 = 1
	DELETED_NO  int8 = 0
)

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/pkg/models/businessManagement/serviceinstance.go
```golang
package businessManagement

import "time"

type ServiceInstance struct {
	Id             int              `gorm:"column:id;primaryKey" json:"id"` // ID
	Name           string           `gorm:"column:name" json:"name"`        // 服务实例名称
	ServiceId      int              `gorm:"column:service_id" json:"svcId"`
	ServiceName    string           `gorm:"-" json:"serviceName"`
	RegionCode     string           `gorm:"column:region_code" json:"regionCode"` // region id
	RegionName     string           `gorm:"-" json:"regionName"`
	AzCode         string           `gorm:"column:az_code" json:"azCode"` // az id
	AzName         string           `gorm:"-" json:"azName"`              // az id
	HostId         int              `gorm:"column:host_id" json:"hostId"` // 所属主机id
	HostName       string           `gorm:"-" json:"hostName"`
	VmId           string           `gorm:"column:vm_id" json:"vmId"`
	HostType       int              `gorm:"column:host_type" json:"hostType"`
	HostIp         string           `gorm:"-" json:"hostIp"`               // 服务器：管理IP 云主机：内网IP
	OutIp          string           `gorm:"-" json:"outIp"`                // 服务器：带外IP 云主机：外网IP
	Creator        string           `gorm:"column:creator" json:"creator"` // 创建人
	CreateTime     time.Time        `gorm:"column:create_time;autoCreateTime" json:"createTime"`
	Updater        string           `gorm:"column:updater" json:"updater"` // 修改人
	UpdateTime     time.Time        `gorm:"column:update_time;autoCreateTime" json:"updateTime"`
	ServiceProcess []ServiceProcess `gorm:"-" json:"processList"`
	State          int8             `gorm:"-" json:"state" description:"[1 正常] [-1 异常]"`       //服务实例状态
	BuiltIn        int8             `gorm:"column:built_in" json:"builtIn" description:"是否内置"` // 是否为内置服务实例
	Deleted        int8             `gorm:"column:deleted" json:"deleted"`                     //是否删除 1：删除，0：未删除
}

type ServiceInstanceUpdateReq struct {
	ServiceInstance ServiceInstance  `json:"serviceInstance"`
	CreateProcess   []ServiceProcess `json:"createProcess"`
	UpdateProcess   []ServiceProcess `json:"updateProcess"`
	DeleteProcess   []ServiceProcess `json:"deleteProcess"`
}

type DeleteServiceInstanceParams struct {
	Ids []int `json:"ids"`
}

type QueryServiceInstanceListParams struct {
	//regionCode, azCode, searchName string, searchSvcIds []int, pageSize, pageNo int
	Region       string   `json:"region"`
	Az           []string `json:"az"`
	SearchName   string   `json:"searchName"`
	SearchSvcIds []int    `json:"searchSvcIds"`
	PageSize     int      `json:"pageSize"`
	PageNo       int      `json:"pageNo"`
	SortField    string   `json:"sortField"`
	SortType     string   `json:"sortType"`
	
	HostName string `json:"HostName"`
}

func (m *ServiceInstance) TableName() string {
	return "asset_business_management_service_instance"
}

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/pkg/models/businessManagement/container.go
```golang
package businessManagement

import "time"

type Container struct {
	Name        string `json:"name"` // 容器名称
	CpuUsage    string `json:"cpuUsage"`
	MemoryUsage string `json:"memoryUsage"`
	Status      string `json:"status"`
}

type PodMetrics struct {
	Kind       string `json:"kind"`
	APIVersion string `json:"apiVersion"`
	Metadata   struct {
		SelfLink string `json:"selfLink"`
	} `json:"Metadata"`
	Timestamp  time.Time `json:"timestamp"`
	Window     string    `json:"window"`
	Containers []struct {
		Name  string `json:"name"`
		Usage struct {
			Cpu    string `json:"cpu"`
			Memory string `json:"memory"`
		} `json:"usage"`
	} `json:"containers"`
}

type PodMetricsList struct {
	Kind       string `json:"kind"`
	APIVersion string `json:"apiVersion"`
	Metadata   struct {
		SelfLink string `json:"selfLink"`
	} `json:"Metadata"`
	Items []struct {
		Metadata struct {
			Name              string    `json:"name"`
			Namespace         string    `json:"namespace"`
			SelfLink          string    `json:"selfLink"`
			CreationTimestamp time.Time `json:"creationTimestamp"`
		} `json:"Metadata"`
		Timestamp  time.Time `json:"timestamp"`
		Window     string    `json:"window"`
		Containers []struct {
			Name  string `json:"name"`
			Usage struct {
				Cpu    string `json:"cpu"`
				Memory string `json:"memory"`
			} `json:"usage"`
		} `json:"containers"`
	} `json:"items"`
}

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/pkg/models/businessManagement/serviceprocess.go
```golang
package businessManagement

import "time"

type ServiceProcess struct {
	Id            int       `gorm:"column:id" json:"id"`     // ID
	Name          string    `gorm:"column:name" json:"name"` // process名称
	Cmd           string    `gorm:"column:cmd" json:"cmd"`
	Port          string    `gorm:"column:port" json:"port"`                     // process端口
	Protocol      int16     `gorm:"column:protocol" json:"protocol"`             // process协议
	SvcInstanceId int       `gorm:"column:svc_instance_id" json:"svcInstanceId"` // 所属服务实例id
	Creator       string    `gorm:"column:creator" json:"creator"`               // 创建人
	CreateTime    time.Time `gorm:"column:create_time;autoCreateTime" json:"createTime"`
	Updater       string    `gorm:"column:updater" json:"updater"` // 修改人
	UpdateTime    time.Time `gorm:"column:update_time;autoUpdateTime" json:"updateTime"`
}

func (s *ServiceProcess) Equals(sp *ServiceProcess) bool {
	if s.Id == sp.Id && s.Name == sp.Name && s.Cmd == sp.Cmd &&
		s.Port == sp.Port && s.Protocol == sp.Protocol && s.SvcInstanceId == sp.SvcInstanceId {
		return true
	}
	return false
}

func (m *ServiceProcess) TableName() string {
	return "asset_business_management_service_process"
}

type ProcessLatest struct {
	Id            int    `json:"id"`            // ID
	Name          string `json:"name"`          // process名称
	Port          string `json:"port"`          // process端口
	Protocol      int16  `json:"protocol"`      // process协议
	SvcInstanceId int    `json:"svcInstanceId"` // 所属服务实例id
	Ip            string `json:"ip"`            //所属服务实例ip
	SvcId         int    `json:"svcId"`         //所属服务id
	AzCode        string `json:"az"`            //所属az
	RegionCode    string `json:"region"`        //所属region
	HostName      string `json:"hostName"`      //所属主机名
}

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/pkg/models/businessManagement/node.go
```golang
package businessManagement

import "time"

type Node struct {
	Id           int       `gorm:"column:id" json:"id"`                  // ID
	Name         string    `gorm:"column:name" json:"name"`              // 业务树节点名称
	RegionCode   string    `gorm:"column:region_code" json:"regionCode"` // region id
	RegionName   string    `gorm:"-" json:"regionName"`                  // region id
	BuiltIn      int8      `gorm:"column:built_in" json:"builtIn"`       // 是否是内置(1:内置;0:自定义)
	Services     []Service `gorm:"-" json:"services"`
	ServiceCount int       `gorm:"-" json:"serviceCount"`
	Routes       []R       `gorm:"-" json:"routes"`
	Creator      string    `gorm:"column:creator" json:"creator"` // 创建人
	CreateTime   time.Time `gorm:"column:create_time" json:"createTime"`
	Updater      string    `gorm:"column:updater" json:"updater"` // 修改人
	UpdateTime   time.Time `gorm:"column:update_time" json:"updateTime"`
}

type R struct {
	TreeName string `json:"treeName"`
	Route    string `json:"route"`
}

func (m *Node) TableName() string {
	return "asset_business_management_node"
}

type NodeServices struct {
	NodeId    int `gorm:"column:node_id"`
	ServiceId int `gorm:"column:service_id"`
}

func (m *NodeServices) TableName() string {
	return "asset_business_management_node_services"
}

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/pkg/models/eip/eip.go
```golang
package eip

import "luban-cmdb-api/pkg/utils/unixtime"

type (
	//该结构体于pkg/dao/basic/basicModel文件中已定义，可以复用
	//Region struct {
	//	Id         int    `json:"id"`
	//	RegionCode string `json:"regionCode"`
	//	RegionName string `json:"regionName"`
	//}

	EipResponse struct {
		TotalCount            int                      `json:"totalCount"`
		PageNo                int                      `json:"pageNo"`
		PageSize              int                      `json:"pageSize"`
		DataList              interface{}              `json:"dataList"` //此处请赋值一个切片
		ListOptionalCondition map[string][]interface{} `json:"listOptionalCondition"`
	}

	Utilization struct {
		Id         string  `json:"id"`
		RegionCode string  `json:"regionCode"`
		RegionName string  `json:"regionName"`
		Date       int     `json:"date"`
		Cidr       string  `json:"cidr"`
		UsedRatio  float64 `json:"usedRatio"`
		//...
	}
	UtilizationTrend struct {
		Id                 string `json:"id"`
		RegionCode         string `json:"regionCode"`
		RegionName         string `json:"regionName"`
		IpSegment          string `json:"ipSegment"`
		AllocStateWithDate []struct {
			Date      int     `json:"date"`
			UsedRatio float64 `json:"usedRatio"`
		} `json:"allocStateWithDate"`
	}

	SegParams struct {
		Cidr      string   `json:"cidr"` //基于网段模糊匹配
		PageNo    int      `json:"pageNo"`
		PageSize  int      `json:"pageSize"`
		Region    string   `json:"region"`    // region 如果查询所有传入all
		IpVersion []string `json:"ipVersion"` //基于ip版本匹配
	}

	SegByListParams struct {
		CidrList   []string `json:"cidrs"`
		RegionList []string `json:"regions"`
	}

	GetEipListParams struct {
		Segment    string   `json:"segment"`    // 网段 必须
		BoundState []int    `json:"boundState"` // 状态
		WayType    []string `json:"wayType"`    // 线路类型
		IpVersion  []string `json:"ipVersion"`  // ip版本
		BoundType  []string `json:"boundType"`  // 绑定实例类型
		PoolName   string   `json:"poolName"`   // 绑定实例类型
		PageSize   int      `json:"pageSize"`
		PageNo     int      `json:"pageNo"`

		SearchType  string `json:"searchType"`  // 搜索类型 (ipAddr/tenantId/boundName)
		SearchValue string `json:"searchValue"` // 搜索值 (注意要支持模糊搜索)
	}

	Segment struct {
		Id                  string  `json:"id"`
		Cidr                string  `json:"cidr"`
		NetSegName          string  `json:"netSegName"`
		RegionCode          string  `json:"regionCode"`
		RegionName          string  `json:"regionName"`
		RegionAggregateCode string  `json:"regionAggregateCode"`
		IpVersion           string  `json:"ipVersion"`
		IpCount             int     `json:"ipCount"`
		UsedIpCount         int     `json:"usedIpCount"`
		RemainingIpCount    int     `json:"remainingIpCount"`
		RetainedIpCount     int     `json:"retainedIpCount"`
		AvailableRatio      float64 `json:"availableRatio"`
		UsedRatio           float64 `json:"usedRatio"`
		CreateTime          int     `json:"createTime"` //秒级时间戳
	}

	SegmentSlice []Segment

	Eip struct {
		Id                  string            `json:"id"`
		XgwCluster          string            `json:"xgwCluster"` // eip 所属资源池
		IpAddr              string            `json:"ipAddr"`
		BoundState          int               `json:"boundState"` //0:保留；1:未分配；2：已分配未绑定；3已绑定
		NetSegName          string            `json:"netSegName"`
		Cidr                string            `json:"cidr"`
		RegionCode          string            `json:"regionCode"`
		RegionAggregateCode string            `json:"regionAggregateCode"`
		RegionName          string            `json:"regionName"`
		IpVersion           string            `json:"ipVersion"`
		WayType             string            `json:"wayType"`
		TenantId            string            `json:"tenantId"`
		TenantName          string            `json:"tenantName"`
		BoundType           string            `json:"boundType"`
		BoundName           string            `json:"boundName"`
		BoundId             string            `json:"boundId"` // 绑定实例Id
		NetCard             string            `json:"netCard"`
		CardType            string            `json:"cardType"`
		Bandwidth           string            `json:"bandWidth"`
		RowNum              int               `json:"rowNum"`
		CreateTime          unixtime.UnixTime `json:"createTime"` //秒级时间戳
		PoolNames           []string          `json:"poolNames"`
	}

	EipSlice []Eip

	EipOverview struct {
		StateOverview        []EipOverviewSlot `json:"stateOverview"`
		BoundTypeOverview    []EipOverviewSlot `json:"boundTypeOverview"`
		DistributionOverview []EipOverviewSlot `json:"distributionOverview"`
	}

	EipOverviewSlot struct {
		Info   EipOverviewSlotInfo    `json:"info"`
		Values []EipOverviewSlotValue `json:"values"`
	}
	EipOverviewSlotInfo struct {
		Name     string `json:"name"`
		Value    int    `json:"value"`
		UnitType string `json:"unitType"`
		Unit     string `json:"unit"`
	}
	EipOverviewSlotValue struct {
		Code     string `json:"code"`
		Name     string `json:"name"`
		Value    int    `json:"value"`
		Unit     string `json:"unit"`
		UnitType string `json:"unitType"` // storage【存储】、percent【百分比】、number【数值】
		Kind     string `json:"kind"`
	}
	BoundInstanceResponse struct {
		// 基本信息（弹性IP自身信息）
		BoundId     string `json:"boundId"` // 实例ID
		IpAddr      string `json:"ipAddr"`  // IP地址
		Cidr        string `json:"cidr"`    // 所属网段
		RegionCode  string `json:"regionCode"`
		RegionName  string `json:"regionName"`
		WayType     string `json:"wayType"`   // 线路类型
		BandWidth   string `json:"bandWidth"` // 带宽
		IpVersion   string `json:"ipVersion"` // IP版本
		TenantId    string `json:"tenantId"`
		CreateDate  int    `json:"createTime"` //秒级时间戳
		Label       string // 标签
		Description string `json:"description"` // 描述
		// 绑定实例信息
		Id         string `json:"id"`
		BoundType  string `json:"boundType"`
		Name       string `json:"name"`       // 实例名称
		Flavor     string `json:"flavor"`     // 规格
		Status     string `json:"status"`     // 运行状态
		Aggregate  string `json:"aggregate"`  // 所属资源池
		Hypervisor string `json:"hypervisor"` // 所属服务器
	}
	BoundInstance struct {
		Id          string `json:"id"`
		BoundType   string `json:"boundType"`
		Name        string `json:"vmName"`    // 实例名称
		Flavor      string `json:"size"`      // 规格
		Status      string `json:"status"`    // 运行状态
		Aggregate   string `json:"aggregate"` // 所属资源池
		Hypervisor  string `json:"host"`      // 所属服务器
		AggregateId int    `json:"aggregateId"`
		Region      string `json:"region"`
		RegionCode  string `json:"regionCode"`
		Az          string `json:"az"`
		AzCode      string `json:"azCode"`
		TenantId    string `json:"tenantId"`
		InnerIp     string `json:"innerIp"`
		PublicIp    string `json:"publicIp"`
		CreateTime  int    `json:"createTime"`
	}
	GetEipResourceListParams struct {
		SearchType  string   `json:"searchType"`  // 搜索类型 (IP地址/租户ID/绑定实例名称)
		SearchValue string   `json:"searchValue"` // 搜索值 (注意要支持模糊搜索)
		PageNo      int      `json:"pageNo"`
		PageSize    int      `json:"pageSize"`
		Region      string   `json:"region"`
		Regions     []string `json:"-"`
		Cidr        []string `json:"cidr"`       // segment cidr
		IpVersion   []string `json:"ipVersion"`  // IP版本
		WayType     []string `json:"wayType"`    // 线路类型
		BoundType   []string `json:"boundType"`  // 绑定实例类型
		BoundState  []int    `json:"boundState"` //0:保留；1:未分配；2：已分配未绑定；3已绑定
		PoolName    string   `json:"poolName"`
	}
	IpVersionMapping struct {
		IpVersion     string `json:"ipVersion"`
		IpVersionName string `json:"ipVersionName"`
	}
	BoundStateMapping struct { //0:保留；1:未分配；2：已分配未绑定；3已绑定
		BoundState     int    `json:"boundState"`
		BoundStateName string `json:"boundStateName"`
	}
)

func (s SegmentSlice) Len() int {
	return len(s)
}

func (s SegmentSlice) Less(i, j int) bool {
	return s[i].CreateTime > s[j].CreateTime
}

func (s SegmentSlice) Swap(i, j int) {
	s[i], s[j] = s[j], s[i]
}

func (e EipSlice) Len() int {
	return len(e)
}

func (e EipSlice) Less(i, j int) bool {
	return e[i].CreateTime.After(e[j].CreateTime)
}

func (e EipSlice) Swap(i, j int) {
	e[i], e[j] = e[j], e[i]
}

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/pkg/gredis/redisclusterConn.go
```golang
package gredis

import (
	"context"
	"os"

	"github.com/go-redis/redis/v8"
)

var (
	rClient *redis.Client
)

func InitRedis(client *redis.Client) {
	rClient = client
}

//func init() {
//	var rHost = "127.0.0.1:32753"
//	if inK8s() {
//		rHost = "redis-master.luban:6379"
//		klog.Info("eip gredis in kubernetes")
//	}
//	rClient = redis.NewClient(&redis.Options{
//		Addr:     rHost,
//		Password: "123456",
//		DB:       0, // use default DB
//	})
//}

func Connect(host, password string, db int) (*redis.Client, error) {
	client := redis.NewClient(&redis.Options{
		Addr:     host,
		Password: password,
		DB:       db,
	})

	_, err := client.Ping(context.Background()).Result()
	if err != nil {
		return nil, err
	}
	return client, nil
}

//判断是否在k8s内
func inK8s() bool {
	return len(os.Getenv("KUBERNETES_SERVICE_HOST")) > 0
}

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/pkg/gredis/redisConstantParameters.go
```golang
package gredis

import "strings"

const (
	//资源池、云产品 弹性IP相关redis缓存keys
	RegSegMappingKeyPrefix = "cmdb_eip_region_segment_mapping_"
	SegsRegKeyPrefix       = "cmdb_eip_region_"
	SegEipKeyPrefix        = "cmdb_eip_subnet_"
	AllIpEntityKey         = "cmdb_eip_all_mapping"
	WayTypeSetKey          = "cmdb_eip_all_wayType"
	CMDBEipTaskLock        = "cmdb_eip_data_fetch_lock"

	//计算资源池云主机相关redis缓存keys
	AggregatesVmMapKey = "cmdb_aggregates_vm_list"
	ClouddiskMapKey    = "cmdb_cloud_disk_list"
	BucketMapKey       = "cmdb_bucket_list"

	//用户信息缓存key
	UserInfoKey = "cmdb_user_info_mapping"

	//tenantId-userId mapping key
	TidUidMappingKey     = "cmdb_tid_uid_mapping"
	TenantUserMappingKey = "cmdb_tenant_user_mapping"
	//存储资源池缓存key
	StoragePoolMapKey = "cmdb_storage_pool_list"
	//计算资源池缓存key
	AggregatesMapKey = "cmdb_aggregates_list"
	//计算资源池库存缓存key
	AggregatesUsageMapKey = "cmdb_aggregates_usage_list"

	//网络资源池缓存key
	NetWorkPoolKey         = "cmdb_network_pool_hash"
	NetWorkTypeMapKey      = "cmdb_network_type_mapping"
	NetWorkInventoryMapKey = "cmdb_network_inventory_hash"

	// 资源池
	StoragePool = "storage_pool"

	//交换机硬件监控数据存储
	SnmpSwitchFansKey   = "snmp_switch_fans"
	SnmpSwitchPowersKey = "snmp_switch_powers"
	SnmpSwitchCpusKey   = "snmp_switch_cpus"
	SnmpSwitchMemsKey   = "snmp_switch_memories"
	SnmpSwitchBoardsKey = "snmp_switch_boards"
	SnmpSwitchViewsKey  = "snmp_switch_views"

	//负载均衡LB
	LBSetKey  = "cmdb_lb_set"
	LBHashKey = "cmdb_lb_hash"
	//NAT
	NATSetKey  = "cmdb_nat_set"
	NATHashKey = "cmdb_nat_hash"

	//数据库资源池缓存的key
	DbMapKey = "dbms_aggregates_hash"

	//裸金属资源池缓存key
	BMInventoryKey = "bm_inventory_hash"
	BMInstanceKey  = "bm_instance_hash"
	BMTypeKey      = "bm_type_hash"
	BMtypeKey      = "bm_Type_hash"
	BMListKey      = "bm_list_set"

	//裸金属-云产品
	BMCloudHashKey = "bm_cloud_hash"

	//专线-云产品
	SLCloudHashKey = "sl_cloud_hash"

	//nova相关原始数据
	NovaCloudServerHashKey                    = "nova_cloud_servers_hash"
	NovaPhysicalServiceHashKey                = "nova_physical_services_hash"
	NovaAggregateHashKey                      = "nova_aggregates_hash"
	NovaAggregateAndPhysicalServiceMappingKey = "nova_aggregates_services_mapping"
)

var (
	// KS3 资源池
	KS3StoragePool        = strings.Join([]string{StoragePool, "ks3"}, ":")
	KS3StoragePoolServers = strings.Join([]string{KS3StoragePool, "servers"}, ":")

	// 存储资源池
	EBS30StoragePool        = strings.Join([]string{StoragePool, "ebs3.0"}, ":")
	EBS30StoragePoolServers = strings.Join([]string{KS3StoragePool, "servers"}, ":")

	EHDDStoragePool        = strings.Join([]string{StoragePool, "ehdd"}, ":")
	EHDDStoragePoolServers = strings.Join([]string{KS3StoragePool, "servers"}, ":")
)

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/pkg/gredis/opredis.go
```golang
package gredis

import (
	"context"
	"errors"
	"fmt"
	"github.com/go-redis/redis/v8"
	"time"
)

/**
*	设置字符串值
*	@param: redisInstance redis集群实例
*	@param: key 键
*	@param: data 值
*	@param: expiration 过期时间 单位秒
 */
func Set(ctx context.Context, k string, v interface{}, expiration int64) (rs string, err error) {
	return rClient.Set(ctx, k, v, time.Duration(expiration)*time.Second).Result()
}

func SetNX(ctx context.Context, k string, v interface{}, expiration int64) (bool, error) {
	return rClient.SetNX(ctx, k, v, time.Duration(expiration)*time.Second).Result()
}

func Keys(ctx context.Context, pattern string) ([]string, error) {
	return rClient.Keys(ctx, pattern).Result()
}

/**
*	获取字符串值
*	@param: context 实例
*	@param: key 键
 */
func Get(ctx context.Context, k string) (rs string, err error) {
	return rClient.Get(ctx, k).Result()
}

/**
*	重命名指定键
*	@param: context 实例
*	@param: key 键
*	@return :v 1 成功 0 没有该键
 */
func Rename(ctx context.Context, oldKey, newKey string) (rs string, err error) {
	return rClient.Rename(ctx, oldKey, newKey).Result()
}

/**
*	删除指定键的值
*	@param: context 实例
*	@param: key 键
*	@return :v 1 成功 0 没有该键
 */
func Del(ctx context.Context, k string) (rs int64, err error) {
	return rClient.Del(ctx, k).Result()
}

/**
*	hash设置 键值
*	@param: k key
*	@param: field字段
*	@param: v 值
 */
func HSet(ctx context.Context, k, field string, v interface{}) (rs int64, err error) {
	return rClient.HSet(ctx, k, field, v).Result()
}

/**
*	hash获取值
*	@param:
*	@param:k key
 */
func HGet(ctx context.Context, k, field string) (rs string, err error) {
	return rClient.HGet(ctx, k, field).Result()
}

/**
*	hash 设置多个值
*	@param:context 实例
*	@param: k 键
*	@param: v hash键值对
 */
func HMSet(ctx context.Context, k string, v map[string]interface{}) (rs bool, err error) {
	return rClient.HMSet(ctx, k, v).Result()
}

/**
*	获取hash多个值
*	@param: context 实例
*	@param: k 键
*	@param: field 要获取的字段
 */
func HMGet(ctx context.Context, k string, fields []string) (rs []interface{}, err error) {
	return rClient.HMGet(ctx, k, fields...).Result()
}

/**
*	获取hash所有fields
*	@param: context 实例
*	@param: k 键
 */
func HKeys(ctx context.Context, k string) (rs []string, err error) {
	return rClient.HKeys(ctx, k).Result()
}

/**
*	获取hash所有值
*	@param: context 实例
*	@param: k 键
 */
func HGetAll(ctx context.Context, k string) (rs map[string]string, err error) {
	return rClient.HGetAll(ctx, k).Result()
}

/**
*	删除hash指定field,支持删除多个field
*	@param: context 实例
*	@param: k 键
 */
func HDel(ctx context.Context, k string, fields []string) (rs int64, err error) {
	return rClient.HDel(ctx, k, fields...).Result()
}

/**
*	有序集合中添加元素
*	@param: context 实例
*	@param: k 键
*	@param: scores[]float64 分数
*	@param: members[]interface 元素
 */
func ZAdd(ctx context.Context, k string, scores []float64, members []interface{}) (rs int64, err error) {
	if len(scores) != len(members) {
		return 0, errors.New("zadd scores != members")
	}
	zs := make([]*redis.Z, 0)
	for i, v := range scores {
		zs = append(zs, &redis.Z{
			Score:  v,
			Member: members[i],
		})
	}
	return rClient.ZAdd(ctx, k, zs...).Result()
}

/**
*	删除有序集合中的元素
*	@param: context 实例
*	@param: k 键
*	@param: members 要删除的元素
 */
func ZRem(ctx context.Context, k string, members []interface{}) (rs int64, err error) {
	return rClient.ZRem(ctx, k, members...).Result()
}

/**
*	计算有序集合中元素个数
*	@param: context 实例
*	@param: k 键
 */
func ZCard(ctx context.Context, k string) (rs int64, err error) {
	return rClient.ZCard(ctx, k).Result()
}

/**
*	遍历有序集合
*	@param: context 实例
*	@param: k 键
*	@param: s 开始位置
*	@param: s 结束位置
 */
func ZRange(ctx context.Context, k string, s, e int64) (rs []string, err error) {
	return rClient.ZRange(ctx, k, s, e).Result()
}

/**
*	按照分数遍历有序集合
*	@param: redisInstance
*	@param: k 键
*	@param: s开始位置
*	@param: e结束位置
*	@return [值 分数 值 分数....]
 */
func ZRangeWithScores(ctx context.Context, k string, s, e int64) (rs []interface{}, err error) {
	z, err := rClient.ZRangeWithScores(ctx, k, s, e).Result()
	if err != nil {
		return rs, err
	}
	for _, v := range z {
		rs = append(rs, v.Member, v.Score)
	}
	return rs, nil
}

/**
*	添加无序集合
*	@param: context 实例
*	@param: k 键
*	@param: members 添加的元素
*	@return: rs 添加成功的元素个数 err 错误信息
 */
func SAdd(ctx context.Context, k string, members []interface{}) (rs int64, err error) {
	return rClient.SAdd(ctx, k, members...).Result()
}

/**
*	删除无序集合元素
*	@param: context 实例
*	@param: k 键
*	@param: members 删除的元素
*	@return: rs 删除成功的元素个数 err 错误信息
 */
func SRem(ctx context.Context, k string, members []interface{}) (rs int64, err error) {
	return rClient.SRem(ctx, k, members...).Result()
}

// SMembers
/**
*	获取无序集合中的元素
*	@param: context 实例
*	@param: k 键
*	@return: rs 返回的字符串slice,err 错误信息
 */
func SMembers(ctx context.Context, k string) (rs []string, err error) {
	return rClient.SMembers(ctx, k).Result()
}

// Expire
/**
*	设置过期时间
*	@param: context 实例
*	@param: k 键
*	@param: expiration 过期时间 单位秒
*	@return: rs bool 设置成功失败 err 错误信息
 */
func Expire(ctx context.Context, k string, expiration int) (rs bool, err error) {
	return rClient.Expire(ctx, k, time.Duration(expiration)*time.Second).Result()
}

/**
*	查看过期时间
*	@param: context 实例
*	@param: k 键
*	@return: rs 过期时间 err 错误信息
 */
func TTL(ctx context.Context, k string) (time.Duration, error) {
	return rClient.TTL(ctx, k).Result()
}

/**
*	将 key 所储存的值加上给定的增量值
*	@param: context 实例
*	@param: k 键
*	@return: rs 返回相加后的值 err 错误信息
 */
func Incrby(ctx context.Context, k string, value int64) (int64, error) {
	return rClient.IncrBy(ctx, k, value).Result()
}

/**
*	将 Redis Hincrby 命令用于为哈希表中的字段值加上指定增量值。
*	@param: context 实例
*	@param: k 键
*	@return: rs 返回相加后的值 err 错误信息
 */
func Hincrby(ctx context.Context, k, filed string, value int64) (int64, error) {
	return rClient.HIncrBy(ctx, k, filed, value).Result()
}

func SIsMember(ctx context.Context, k string, value interface{}) (bool, error) {
	return rClient.SIsMember(ctx, k, value).Result()
}

func Pipelined(ctx context.Context, f func(pipe redis.Pipeliner) error) (cmdEr []redis.Cmder, err error) {
	return rClient.Pipelined(ctx, f)
}

func Exists(ctx context.Context, k string) bool {
	sign, _ := rClient.Exists(ctx, k).Result()
	if sign <= 0 {
		return false
	}
	return true
}

//限流功能
func RateLimit(ctx context.Context, k string, stepLen, threshold, expire int) (sign int, err error) {
	script := createScript(threshold, expire)
	cmd := rClient.Eval(ctx, script, []string{k}, stepLen)
	sign, err = cmd.Int()
	if err != nil {
		sign = -1
	}
	return
}

func createScript(threshold, expire int) string {
	script := fmt.Sprintf(`
		if gredis.call('EXISTS',KEYS[1]) == 0 then
			gredis.call('SET',KEYS[1],ARGV[1],'NX','EX',%d)
			return tonumber(gredis.call('GET',KEYS[1]))
		else
			if tonumber(gredis.call('GET',KEYS[1])) + ARGV[1] <= %d then
				return gredis.call('incrby',KEYS[1],ARGV[1])
			else
				return -1
			end
		end
	`, expire, threshold)
	return script
}

/**
*	限量设置
*	@param: key1 hset KEY_NAME   format:{mark}_xxx  mark为hashTag，可以是任意值，redis集群会根据该值将key分配到相同的slot内。注：{mark} 大括号必须带
*	@param: key2 hset FIELD_NAME   format:{mark}_xxx  mark同上
*	@param: arg1 hset INCR_BY_NUMBER
*	@param: arg2 hset EXPIREAT TIME_IN_UNIX_TIMESTAMP  代表过期时间的时间戳
*	@return: cumul 返回累加的值 err 错误信息
 */
func OperationLimit(ctx context.Context, key1, key2 string, arg1, arg2 int64) (cumul int, err error) {
	script := fmt.Sprintf(`
		if gredis.call('EXISTS',KEYS[1]) == 0 then
			gredis.call('HINCRBY',KEYS[1],KEYS[2],ARGV[1])
			gredis.call('EXPIREAT',KEYS[1],ARGV[2])
			return tonumber(gredis.call('HGET',KEYS[1],KEYS[2]))
		else
			return tonumber(gredis.call('HINCRBY',KEYS[1],KEYS[2],ARGV[1]))
		end
	`)
	cmd := rClient.Eval(ctx, script, []string{key1, key2}, arg1, arg2)
	cumul, err = cmd.Int()
	return
}

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/pkg/version/version.go
```golang
package version

import (
	"fmt"
)

var (
	Version   = "v0.1"
	GitHash   = "unknown"
	BuildTime = "unknown"
	GoVersion = "unknown"
)

func Info() string {
	return fmt.Sprintf("Version: %s\nGitHash: %s\nBuildTime: %s\nGoVersion: %s\n", Version, GitHash, BuildTime, GoVersion)
}

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/pkg/version/version-handler.go
```golang
package version

import "github.com/emicklei/go-restful/v3"

func NewVersionService() *restful.WebService {
	ws := new(restful.WebService)
	ws.
		Path("/version").
		Consumes(restful.MIME_XML, restful.MIME_JSON).
		Produces(restful.MIME_JSON, restful.MIME_XML)

	ws.Route(ws.GET("/").To(getVersion).Doc("Version"))
	return ws
}

func getVersion(request *restful.Request, response *restful.Response) {
	s := Info()
	response.Write([]byte(s))
}

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/pkg/api/types.go
```golang
package api

type ListResult struct {
	Items      []interface{} `json:"items" description:"paging data"`
	TotalCount int           `json:"total_count" description:"total count"`
}

const (
	Aggregate = "Aggregate"
)

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/pkg/api/utils.go
```golang
package api

import (
	"net"
	"net/http"
	"runtime"
	"strings"

	"github.com/emicklei/go-restful"
	"k8s.io/klog/v2"
)

// Avoid emitting errors that look like valid HTML. Quotes are okay.
var sanitizer = strings.NewReplacer(`&`, "&amp;", `<`, "&lt;", `>`, "&gt;")

func HandleInternalError(response *restful.Response, err error) {
	handle(http.StatusInternalServerError, response, err)
}

func HandleBadRequest(response *restful.Response, err error) {
	handle(http.StatusBadRequest, response, err)
}

func HandleConflict(response *restful.Response, err error) {
	handle(http.StatusConflict, response, err)
}

func handle(code int, response *restful.Response, err error) {
	_, fn, line, _ := runtime.Caller(2)
	klog.Errorf("%s:%d %v", fn, line, err)
	http.Error(response, sanitizer.Replace(err.Error()), code)
}

func ValidatedIP(inputIP string) bool {
	return net.ParseIP(inputIP) != nil
}

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/pkg/api/sl/register.go
```golang
package sl

import (
	"luban-cmdb-api/pkg/models/sl"
	"luban-cmdb-api/pkg/runtime"
	slservice "luban-cmdb-api/pkg/service/sl"

	"github.com/emicklei/go-restful"
	restfulspec "github.com/emicklei/go-restful-openapi"
)

const APIGroup = "sl"

func AddToContainer(c *restful.Container) error {
	slTag := []string{"sl"}
	ws := runtime.NewWebService(APIGroup)
	slService := slservice.NewService()
	handler := NewHandler(slService)

	ws.Route(ws.GET("cloudProduct/slOverview").To(handler.getSlOverviewHandler).
		Doc("获取专线概览").
		Metadata(restfulspec.KeyOpenAPITags, slTag).
		Param(ws.QueryParameter("region", "region")).
		Returns(200, "OK", sl.SlOverviewRsp{}))
	ws.Route(ws.POST("cloudProduct/slList").To(handler.getSlResourceListHandler).
		Doc("专线资源列表").
		Metadata(restfulspec.KeyOpenAPITags, slTag).
		Reads(sl.GetSlResourceListReq{}, "region:区域\nsearchType:搜索类型 (名称 name)\nsearchValue：搜索值\nresourcePoolName:资源池名称").
		Returns(200, "OK", sl.GetSlResourceListRsp{}))
	ws.Route(ws.GET("cloudProduct/slList/optionalCondition").To(handler.getListOptionalCondition).
		Doc("专线列表可选条件").
		Metadata(restfulspec.KeyOpenAPITags, slTag).
		Reads("", "").
		Returns(200, "OK", nil))
	ws.Route(ws.GET("cloudProduct/detail/{instanceId}").To(handler.getSlInfo).
		Doc("获取专线详情").
		Metadata(restfulspec.KeyOpenAPITags, slTag).
		Param(ws.PathParameter("instanceId", "专线实例id")).
		Returns(200, "OK", sl.SlInfo{}))
	c.Add(ws)
	return nil
}

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/pkg/api/sl/handler.go
```golang
package sl

import (
	"github.com/emicklei/go-restful"
	"luban-cmdb-api/pkg/models"
	"luban-cmdb-api/pkg/models/sl"
)

type SlService interface {
	GetSlOverview(req sl.SlOverviewReq) (sl.SlOverviewRsp, error)
	GetSlResourceList(params sl.GetSlResourceListReq) (sl.GetSlResourceListRsp, error)
	GetListOptionalCondition() (map[string][]interface{}, error)
	SlDetail(instanceId string) (sl.SlInfo, error)
}

type Handler struct {
	svc SlService
}

func NewHandler(slService SlService) *Handler {
	return &Handler{
		svc: slService,
	}
}

func (h *Handler) getSlOverviewHandler(req *restful.Request, resp *restful.Response) {
	resp.AddHeader(restful.HEADER_AccessControlAllowOrigin, "*")
	res := &models.CommonResult{
		Code:    200,
		Message: "success",
		Data:    nil,
	}
	region := req.QueryParameter("region")
	params := sl.SlOverviewReq{
		Region: region,
	}
	overview, err := h.svc.GetSlOverview(params)
	if err != nil {
		res.Code = 500
		res.Message = err.Error()
		resp.WriteAsJson(res)
		return
	}
	res.Data = overview
	resp.WriteAsJson(res)
}

func (h *Handler) getSlResourceListHandler(req *restful.Request, resp *restful.Response) {
	resp.AddHeader(restful.HEADER_AccessControlAllowOrigin, "*")
	res := &models.CommonResult{
		Code:    200,
		Message: "success",
		Data:    nil,
	}
	params := sl.GetSlResourceListReq{}
	err := req.ReadEntity(&params)
	if err != nil {
		res.Code = 500
		res.Message = "参数解析错误"
		resp.WriteAsJson(res)
		return
	}
	if params.PageSize <= 0 {
		params.PageSize = 10
	}
	if params.PageNo < 1 {
		params.PageNo = 1
	}
	data, err := h.svc.GetSlResourceList(params)
	if err != nil {
		res.Code = 500
		res.Message = err.Error()
		resp.WriteAsJson(res)
		return
	}
	res.Data = data
	resp.WriteAsJson(res)
}

func (h *Handler) getListOptionalCondition(req *restful.Request, resp *restful.Response) {
	resp.AddHeader(restful.HEADER_AccessControlAllowOrigin, "*")
	res := &models.CommonResult{
		Code:    200,
		Message: "success",
		Data:    nil,
	}
	data, err := h.svc.GetListOptionalCondition()
	if err != nil {
		res.Code = 500
		res.Message = err.Error()
		resp.WriteAsJson(res)
		return
	}
	res.Data = data
	resp.WriteAsJson(res)
}

func (h *Handler) getSlInfo(request *restful.Request, response *restful.Response) {
	response.AddHeader(restful.HEADER_AccessControlAllowOrigin, "*")
	res := &models.CommonResult{
		Code:    200,
		Message: "success",
		Data:    nil,
	}
	instanceId := request.PathParameter("instanceId")
	detail, err := h.svc.SlDetail(instanceId)
	if err != nil {
		res.Code = 500
		res.Message = err.Error()
		response.WriteAsJson(res)
		return
	}
	res.Code = 200
	res.Message = "success"
	res.Data = detail
	response.WriteAsJson(res)
}

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/pkg/api/basicmanager/register.go
```golang
package basicmanager

import (
	"luban-cmdb-api/pkg/apiserver/config"
	"luban-cmdb-api/pkg/models/basic"
	"luban-cmdb-api/pkg/runtime"
	"luban-cmdb-api/pkg/service"

	"github.com/dgraph-io/dgo/v200"
	"github.com/emicklei/go-restful"
	restfulspec "github.com/emicklei/go-restful-openapi"
	"github.com/gophercloud/gophercloud"
)

const APIGroup = "basic"

func AddToContainer(c *restful.Container, dgraphclient *dgo.Dgraph, novaclient *gophercloud.ServiceClient, identityClient *gophercloud.ServiceClient, config *config.Config) error {
	ws := runtime.NewWebService(APIGroup)
	aggregateService := service.NewAggregateService(novaclient, identityClient, *config)
	basicService := service.NewBasicService(dgraphclient, aggregateService)
	handler := NewHandler(basicService)
	//服务器
	tag1 := []string{"basic"}
	ws.Route(ws.GET("/getRegions").To(handler.getRegionsHandler).
		Doc("获取所有区域和对应的可用区以及机房。").
		Metadata(restfulspec.KeyOpenAPITags, tag1).
		Returns(200, "ok", []basic.Region{}))
	ws.Route(ws.GET("/getRooms/{lab}").To(handler.getRoomsHandler).
		Doc("获取所有房间。。。").
		Metadata(restfulspec.KeyOpenAPITags, tag1).
		Param(ws.PathParameter("lab", "lab code")).
		Param(ws.QueryParameter("sn", "物理资产的sn")).
		Returns(200, "ok", []basic.Room{}))
	ws.Route(ws.POST("/getLabs").To(handler.getLabsHandler).
		Doc("获取机房列表").
		Metadata(restfulspec.KeyOpenAPITags, tag1).
		Reads(basic.LabQuery{}, basic.LabQueryDoc).
		// Param(ws.QueryParameter("az", "az code")).
		// Param(ws.QueryParameter("region", "region code")).
		Returns(200, "ok", []basic.Lab{}))
	ws.Route(ws.POST("/getLabsByRooms").To(handler.getLabsByRoomsHandler).
		Doc("根据房间获取其所在的机房,如果机房列表没有则通过region、az查询机房").
		Metadata(restfulspec.KeyOpenAPITags, tag1).
		Param(ws.BodyParameter("roomCodes", "房间Code列表")).
		Param(ws.BodyParameter("region", "房间Code列表")).
		Param(ws.BodyParameter("az", "房间Code列表")).
		Returns(200, "ok", []basic.Lab{}))
	ws.Route(ws.GET("/getResourceTree").To(handler.getResourceTreeHandler).
		Doc("获取资源类型tree。").
		Metadata(restfulspec.KeyOpenAPITags, tag1).
		Returns(200, "ok", []basic.ResourceType{}))
	ws.Route(ws.GET("/getResourceList").To(handler.getResourceListHandler).
		Doc("获取资源类型list。").
		Metadata(restfulspec.KeyOpenAPITags, tag1).
		Returns(200, "ok", []basic.Resource{}))
	// ws.Route(ws.GET("/getHostTree").To(handler.getHostTreeHandler).
	// 	Doc("获取服务器列表。").
	// 	Metadata(restfulspec.KeyOpenAPITags, tag1).
	// 	Returns(200, "ok", []basic.PhysicalHostData{}))
	ws.Route(ws.POST("/getResourcePoolList").To(handler.getResourcePoolList).
		Doc("获取resourcePool列表。").
		Metadata(restfulspec.KeyOpenAPITags, tag1).
		Reads(basic.ResourcePoolQuery{}, basic.ResourcePoolQueryDoc).
		// Param(ws.BodyParameter("regionCode", "regionCode code")).
		// Param(ws.BodyParameter("azCode", "azCode code")).
		// Param(ws.BodyParameter("storageTypeCode", "storageTypeCode 存储类型")).
		// Param(ws.BodyParameter("resourceTypeCode", "resourceTypeCode;eg:计算资源池:aggregate; 块存储资源池:blockStoragePool").Required(false)).
		Returns(200, "ok", []basic.ResourcePool{}))
	ws.Route(ws.POST("/getResourcePoolStorageList").To(handler.getResourcePoolStorageList).
		Doc("获取resourcePoolStorage列表。用于cluster_exporter").
		Metadata(restfulspec.KeyOpenAPITags, tag1).
		Reads(basic.ResourcePoolStorageQuery{}, basic.ResourcePoolStorageQueryDoc).
		Returns(200, "ok", []service.StoragePool{}))
	ws.Route(ws.POST("/getCabinets").To(handler.getBasicCabinetList).
		Doc("获取机柜列表").
		Metadata(restfulspec.KeyOpenAPITags, tag1).
		Reads(basic.CabinetQueryParam{}, basic.GetCabinetListDoc).
		Returns(200, "ok", []basic.CabinetInfo{}))

	ws.Route(ws.GET("/dynamicColumnList/{url}").To(handler.getDynamicColumnList).
		Doc("获取动态列").
		Metadata(restfulspec.KeyOpenAPITags, tag1).
		Param(ws.PathParameter("url", "页标识")).
		Returns(200, "ok", basic.DynamicColumnList{}))

	ws.Route(ws.POST("/dynamicColumnList/{url}").To(handler.updateDynamicColumnList).
		Doc("更新动态列").
		Metadata(restfulspec.KeyOpenAPITags, tag1).
		Param(ws.PathParameter("url", "页标识")).
		Param(ws.BodyParameter("columnData", "动态列数据")).
		Param(ws.BodyParameter("uid", "动态列uid")).
		Returns(200, "ok", nil))
	ws.Route(ws.POST("/getResourceObjectList").To(handler.getObjectOfResourceTypeHandler).
		Doc("获取resourceObject列表。").
		Metadata(restfulspec.KeyOpenAPITags, tag1).
		Reads(basic.ResourceObjectQuery{}, basic.ResourceObjectQueryDoc).
		// Param(ws.BodyParameter("regionCode", "regionCode code")).
		// Param(ws.BodyParameter("azCode", "azCode code")).getObjectOfResourceTypeHandler
		// Param(ws.BodyParameter("storageTypeCode", "storageTypeCode 存储类型")).
		// Param(ws.BodyParameter("resourceTypeCode", "resourceTypeCode;eg:计算资源池:aggregate; 块存储资源池:blockStoragePool").Required(false)).
		Returns(200, "ok", []basic.ResourceObject{}))
	ws.Route(ws.GET("/getRegionList").To(handler.getRegionListHandler).
		Doc("获取所有区域").
		Metadata(restfulspec.KeyOpenAPITags, tag1).
		Returns(200, "ok", []basic.RegionDt{}))
	ws.Route(ws.GET("/getAzList").To(handler.getAzListHandler).
		Doc("获取区域对应的可用区").
		Metadata(restfulspec.KeyOpenAPITags, tag1).
		Param(ws.QueryParameter("region", "region code")).
		Returns(200, "ok", []basic.AzDt{}))
	ws.Route(ws.POST("/reportHardwareMess").To(handler.reportHardwareMessHandler).
		Doc("上报硬件信息").
		Metadata(restfulspec.KeyOpenAPITags, tag1).
		Reads(basic.HardwareMess{}).
		Returns(200, "ok", nil))
	ws.Route(ws.POST("/reportHardware").To(handler.reportHardwareHandler).
		Doc("上报硬件信息").
		Metadata(restfulspec.KeyOpenAPITags, tag1).
		Reads(basic.HardwareMess{}).
		Returns(200, "ok", nil))
	// ws.Route(ws.POST("/getAzRegionInfo").To(handler.getAzRegionInfoHandler).
	// 	Doc("根据azCode列表查询区域、可用区信息").
	// 	Metadata(restfulspec.KeyOpenAPITags, tag1).
	// 	Reads(basic.AzCodesParams{}, basic.GetAzRegionInfoDoc).reportHardwareMessHandler
	// 	Returns(200, "ok", basic.AzRegionInfo{}))
	ws.Route(ws.GET("/racksByCabinetId/{cabinetId}").To(handler.getRacksByCabinetIdsHandler).
		Doc("根据cabinetids获取未占用的U位 以及 物理资源自己所占的U位").
		Metadata(restfulspec.KeyOpenAPITags, tag1).
		Param(ws.PathParameter("cabinetId", "cabinet Id")).
		Param(ws.QueryParameter("sn", "物理资产的sn")).
		Returns(200, "ok", []basic.Rack{}))
	c.Add(ws)
	return nil
}

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/pkg/api/basicmanager/handler.go
```golang
package basicmanager

import (
	"encoding/json"
	"fmt"
	"luban-cmdb-api/pkg/client/idp"
	"luban-cmdb-api/pkg/models/basic"
	"luban-cmdb-api/pkg/models/hardware"
	labmodel "luban-cmdb-api/pkg/models/lab"
	"luban-cmdb-api/pkg/service"
	"net/http"
	"strconv"
	"strings"

	"github.com/zeromicro/go-zero/core/logx"

	"github.com/pkg/errors"

	"github.com/dgrijalva/jwt-go"
	"github.com/emicklei/go-restful"
)

type Service interface {
	GetRegions(regionMap, azMap, labMap map[string]interface{}) ([]basic.Region, error)
	GetRooms(labCode, sn string) ([]basic.Room, error)
	GetResourceTree() ([]basic.ResourceType, error)
	GetResourceList() (basic.ResourceList, error)
	//GetHostTree() ([]basic.PhysicalHostData, error)
	GetResourcePoolList(resourcePoolQuery basic.ResourcePoolQuery) ([]basic.ResourcePool, error)
	GetResourcePoolStorageList(storageType string, regionCode, azArr, resourcePoolArr []string) ([]service.StoragePool, error)
	GetDynamicColumnList(url, userName string) (basic.DynamicColumnList, error)
	UpdateDynamicColumnList(url, userName, columnData string, uid int) error
	GetLabs(region string, az []string) ([]labmodel.BasicLab, error)
	GetLabsByRoomCodes(codes []string) ([]labmodel.BasicLab, error)
	GetBasicCabinetList(params basic.CabinetQueryParam) ([]basic.CabinetInfo, error)
	GetObjectOfResourceType(resourceObjectQuery basic.ResourceObjectQuery) ([]basic.ResourceObject, error)
	GetRegionList() ([]basic.RegionDt, error)
	GetAzList(region string) ([]basic.AzDt, error)
	//GetAzRegionInfo(regionCodes []string) (basic.AzRegionInfo, error)
	ReportHardwareMess(hardwareMess basic.HardwareMess) error
	ReportHardware(hardware hardware.Hardware) error
	GetRacksByCabinetId(sn string, cabinetsId int) (rackList []basic.Rack, err error)
}

type Handler struct {
	svc Service
	//dgraphClient *dgo.Dgraph
}

func NewHandler(svc Service) *Handler {
	return &Handler{
		svc: svc,
	}
}

func (h *Handler) getRegionsHandler(request *restful.Request, response *restful.Response) {
	logx.Debugf("IN getRegionsHandler ....")
	defer logx.Debugf("OUT getRegionsHandler ....")
	response.AddHeader("Access-Control-Allow-Origin", "*")
	rst := new(Result)
	regionResult, err := h.svc.GetRegions(make(map[string]interface{}), make(map[string]interface{}), make(map[string]interface{}))
	if err != nil {
		rst.Code = 500
		rst.Message = err.Error()
		response.WriteAsJson(rst)
		return
	} else {
		rst.Code = 200
		rst.Message = "success"
		rst.Data = regionResult
		response.WriteAsJson(rst)
		return
	}

}
func (h *Handler) getRoomsHandler(request *restful.Request, response *restful.Response) {
	response.AddHeader("Access-Control-Allow-Origin", "*")
	lab := request.PathParameter("lab")
	sn := request.QueryParameter("sn")
	rst := new(Result)
	regionResult, err := h.svc.GetRooms(lab, sn)
	if err != nil {
		rst.Code = 500
		rst.Message = err.Error()
		response.WriteAsJson(rst)
		return
	} else {
		rst.Code = 200
		rst.Message = "success"
		rst.Data = regionResult
		response.WriteAsJson(rst)
		return
	}

}
func (h *Handler) getResourceTreeHandler(request *restful.Request, response *restful.Response) {
	response.AddHeader("Access-Control-Allow-Origin", "*")
	//lab := request.PathParameter("lab")
	rst := new(Result)
	resourceResult, err := h.svc.GetResourceTree()
	if err != nil {
		rst.Code = 500
		rst.Message = err.Error()
		response.WriteAsJson(rst)
		return
	} else {
		rst.Code = 200
		rst.Message = "success"
		rst.Data = resourceResult
		response.WriteAsJson(rst)
		return
	}

}

// func (h *Handler) getHostTreeHandler(request *restful.Request, response *restful.Response) {
// 	response.AddHeader("Access-Control-Allow-Origin", "*")
// 	//lab := request.PathParameter("lab")
// 	rst := new(Result)
// 	hostResult, err := h.svc.GetHostTree()
// 	if err != nil {
// 		rst.Code = 500
// 		rst.Message = err.Error()
// 		response.WriteAsJson(rst)
// 		return
// 	} else {
// 		rst.Code = 200
// 		rst.Message = "success"
// 		rst.Data = hostResult
// 		response.WriteAsJson(rst)
// 		return
// 	}

// }

// func (h *Handler) getLabsHandler(request *restfulapi.Request, response *restfulapi.Response) {
// 	response.AddHeader("Access-Control-Allow-Origin", "*")
// 	rst := new(Result)
// 	labResult, err := h.getLabs()
// 	if err != nil {
// 		rst.Code = 500
// 		rst.Message = err.Error()
// 		response.WriteAsJson(rst)
// 		return
// 	} else {
// 		rst.Code = 200
// 		rst.Message = "success"
// 		rst.Data = labResult
// 		response.WriteAsJson(rst)
// 		return
// 	}

// }

func (h *Handler) getResourceListHandler(request *restful.Request, response *restful.Response) {
	response.AddHeader("Access-Control-Allow-Origin", "*")
	//lab := request.PathParameter("lab")
	rst := new(Result)
	resourceResult, err := h.svc.GetResourceList()
	if err != nil {
		rst.Code = 500
		rst.Message = err.Error()
		response.WriteAsJson(rst)
		return
	} else {
		rst.Code = 200
		rst.Message = "success"
		rst.Data = resourceResult
		response.WriteAsJson(rst)
		return
	}

}
func (h *Handler) getResourcePoolList(request *restful.Request, response *restful.Response) {
	response.AddHeader("Access-Control-Allow-Origin", "*")
	//lab := request.PathParameter("lab")
	rst := new(Result)
	resourcePoolQuery := new(basic.ResourcePoolQuery)
	err := request.ReadEntity(&resourcePoolQuery)
	if err != nil {
		rst.Code = 500
		rst.Message = err.Error()
		response.WriteAsJson(rst)
		return
	}
	if resourcePoolQuery.ResourceTypeCode == "" {
		rst.Code = 500
		rst.Message = "请输入resourceTypeCode"
		response.WriteAsJson(rst)
		return
	}
	if resourcePoolQuery.RegionCode == "" {
		resourcePoolQuery.RegionCode = "all"
	}
	// if resourcePoolQuery.AzCode == "" {
	// 	resourcePoolQuery.AzCode = "all"
	// }
	//if len(resourcePoolQuery.AzCode)
	for i := range resourcePoolQuery.StorageTypeCode {
		resourcePoolQuery.StorageTypeCode[i] = strings.ToLower(resourcePoolQuery.StorageTypeCode[i])
	}
	resourceResult, err := h.svc.GetResourcePoolList(*resourcePoolQuery)
	if err != nil {
		rst.Code = 500
		rst.Message = err.Error()
		response.WriteAsJson(rst)
		return
	} else {
		rst.Code = 200
		rst.Message = "success"
		rst.Data = resourceResult
		response.WriteAsJson(rst)
		return
	}
}
func (h *Handler) getResourcePoolStorageList(request *restful.Request, response *restful.Response) {
	response.AddHeader("Access-Control-Allow-Origin", "*")
	//lab := request.PathParameter("lab")
	rst := new(Result)
	resourcePoolQuery := new(basic.ResourcePoolStorageQuery)
	err := request.ReadEntity(&resourcePoolQuery)
	if err != nil {
		rst.Code = 500
		rst.Message = err.Error()
		response.WriteAsJson(rst)
		return
	}
	resourceResult, err := h.svc.GetResourcePoolStorageList(resourcePoolQuery.StorageTypeCode, resourcePoolQuery.RegionCode, resourcePoolQuery.AzCode, resourcePoolQuery.ResourcePool)
	if err != nil {
		rst.Code = 500
		rst.Message = err.Error()
		response.WriteAsJson(rst)
		return
	} else {
		rst.Code = 200
		rst.Message = "success"
		rst.Data = resourceResult
		response.WriteAsJson(rst)
		return
	}
}

// 获取动态列表
func (h *Handler) getDynamicColumnList(request *restful.Request, response *restful.Response) {
	response.AddHeader("Access-Control-Allow-Origin", "*")
	res := new(Result)
	url := request.PathParameter("url")
	id, err := getUserID(request)
	if err != nil {
		res.Code = 500
		res.Message = err.Error()
		response.WriteAsJson(res)
		return
	}
	columnList, err := h.svc.GetDynamicColumnList(url, id)
	if err != nil {
		res.Code = 500
		res.Message = err.Error()
		response.WriteAsJson(res)
		return
	}
	res.Code = 200
	res.Message = "success"
	res.Data = columnList
	response.WriteAsJson(res)
	return
}

func (h *Handler) updateDynamicColumnList(request *restful.Request, response *restful.Response) {
	response.AddHeader("Access-Control-Allow-Origin", "*")
	url := request.PathParameter("url")
	res := new(Result)
	JsonParams := &struct {
		ColumnData string
		Uid        int
	}{}
	err := request.ReadEntity(JsonParams)
	if err != nil {
		res.Code = 500
		res.Message = err.Error()
		response.WriteAsJson(res)
		return
	}
	id, err := getUserID(request)
	if err != nil {
		res.Code = 500
		res.Message = err.Error()
		response.WriteAsJson(res)
		return
	}
	err = h.svc.UpdateDynamicColumnList(url, id, JsonParams.ColumnData, JsonParams.Uid)
	if err != nil {
		res.Code = 500
		res.Message = err.Error()
		response.WriteAsJson(res)
		return
	}
	res.Code = 200
	res.Message = "success"
	response.WriteAsJson(res)
}

func (h *Handler) getLabsHandler(request *restful.Request, response *restful.Response) {
	response.AddHeader(restful.HEADER_AccessControlAllowOrigin, "*")
	res := new(Result)
	// region := request.QueryParameter("region")
	// az := request.QueryParameter("az")
	req := basic.LabQuery{}
	err := request.ReadEntity(&req)
	labs, err := h.svc.GetLabs(req.Region, req.Az)
	if err != nil {
		res.Code = 200
		res.Message = err.Error()
		response.WriteAsJson(res)
		return
	}
	res.Code = 200
	res.Message = "success"
	res.Data = labs
	response.WriteAsJson(res)
	return
}

// 根据房间的Code获取机房
func (h *Handler) getLabsByRoomsHandler(request *restful.Request, response *restful.Response) {
	response.AddHeader(restful.HEADER_AccessControlAllowOrigin, "*")
	res := new(Result)
	params := basic.RoomCodesParams{}
	err := request.ReadEntity(&params)
	if err != nil {
		res.Code = 500
		res.Message = err.Error()
		response.WriteAsJson(res)
		return
	}
	var labs []labmodel.BasicLab
	if params.RoomCodes == nil || len(params.RoomCodes) == 0 {
		azString := []string{}
		if params.AzCode != "" && params.AzCode != "all" {
			azString = append(azString, params.AzCode)
		}
		labs, err = h.svc.GetLabs(params.RegionCode, azString)
	} else {
		labs, err = h.svc.GetLabsByRoomCodes(params.RoomCodes)
	}
	if err != nil {
		res.Code = 200
		res.Message = err.Error()
		response.WriteAsJson(res)
		return
	}
	res.Code = 200
	res.Message = "success"
	res.Data = labs
	response.WriteAsJson(res)
	return
}

func (h *Handler) getBasicCabinetList(request *restful.Request, response *restful.Response) {
	response.AddHeader(restful.HEADER_AccessControlAllowOrigin, "*")
	res := new(Result)
	params := basic.CabinetQueryParam{}
	error := request.ReadEntity(&params)
	if error != nil {
		res.Code = 500
		res.Message = error.Error()
		response.WriteAsJson(res)
		return
	}
	cabinets, err := h.svc.GetBasicCabinetList(params)
	if err != nil {
		res.Code = 200
		res.Message = err.Error()
		response.WriteAsJson(res)
		return
	}
	res.Code = 200
	res.Message = "success"
	res.Data = cabinets
	response.WriteAsJson(res)
	return
}

// 获取userID 之前是以UserName作为用户表示，token payload内容修改后现改为Id，避免再由id查询userName的二次查询
func getUserID(request *restful.Request) (string, error) {
	//Authorization := request.HeaderParameter("Authorization")
	//if Authorization == "" {
	//	return "", errors.New("header Authorization not found")
	//}
	//// 'Authorization: Bearer $BEARER_TOKEN'
	//idx := strings.Index(Authorization, "Bearer")
	//if idx == -1 || (idx+7) >= len(Authorization) {
	//	return "", errors.New("header Authorization parse failed")
	//}
	//userToken := Authorization[idx+7:]
	//username, err := validateTokenGetUserID(userToken)
	//if err != nil {
	//	return "", err
	//}

	//用户服务取消 Authorization Bearer jwt token
	var userName string
	userName, err := getUserNameFromIdp(request.Request)
	if err != nil || userName == "" {
		userName = "ksyun_admin"
	}
	return userName, nil
}

func getUserNameFromIdp(r *http.Request) (string, error) {
	fmt.Printf("getUserNameFromIdp start:%+v", r.Cookies())
	tag := "x-auth-session"
	authSession, err := r.Cookie(tag)
	if err != nil {
		fmt.Printf("getUserNameFromIdp end:%s", err)
		return "", errors.Wrap(err, "getUserNameFromIdp - get cookie key: x-auth-session fail")
	}
	authSessionStr := authSession.Value
	idpClient := idp.NewClient(idp.Config{})
	userInfo, err := idpClient.GetUserInfo(authSessionStr)
	if err != nil {
		fmt.Printf("getUserNameFromIdp end:%s", err)
		return "", errors.Wrap(err, "getUserNameFromIdp -GetUserInfo fail")
	}
	fmt.Printf("getUserNameFromIdp end:%+v", userInfo)
	return userInfo.Username, nil
}

func getUserNameFromCookie(req *http.Request) (string, error) {
	cookies := req.Cookies()
	fmt.Printf("cookies:%+v", cookies)
	cookieAll, err := req.Cookie("all")
	if err != nil {
		return "", errors.Wrap(err, "get cookie key: all fail")
	}
	// json string to map
	m := map[string]string{}
	err = json.Unmarshal([]byte(cookieAll.Value), &m)
	if err != nil {
		return "", errors.Wrap(err, "cookie key: all unmarshal fail")
	}
	userName, ok := m["LoginName"]
	if !ok {
		return "", errors.New("parse LoginName fail from cookie")
	}
	return userName, nil
}

func validateTokenGetUserID(tokenStr string) (string, error) {
	token, _, err := new(jwt.Parser).ParseUnverified(tokenStr, jwt.MapClaims{})
	if err != nil {
		return "", errors.Wrap(err, "token parse failed")
	}

	claims, ok := token.Claims.(jwt.MapClaims)
	if !ok {
		return "", errors.New("Invalide token")
	}
	err = claims.Valid()
	if err != nil {
		return "", err
	}
	if id, ok := claims["name"]; !ok {
		return "", errors.New("username not found")
	} else {
		return id.(string), nil
	}
}
func (h *Handler) getObjectOfResourceTypeHandler(request *restful.Request, response *restful.Response) {
	response.AddHeader("Access-Control-Allow-Origin", "*")
	//lab := request.PathParameter("lab")
	resourcePoolQuery := new(basic.ResourceObjectQuery)
	err := request.ReadEntity(&resourcePoolQuery)
	rst := new(Result)
	hostResult, err := h.svc.GetObjectOfResourceType(*resourcePoolQuery)
	if err != nil {
		rst.Code = 500
		rst.Message = err.Error()
		response.WriteAsJson(rst)
		return
	} else {
		rst.Code = 200
		rst.Message = "success"
		rst.Data = hostResult
		response.WriteAsJson(rst)
		return
	}

}
func (h *Handler) getRegionListHandler(request *restful.Request, response *restful.Response) {
	response.AddHeader("Access-Control-Allow-Origin", "*")
	rst := new(Result)
	regionResult, err := h.svc.GetRegionList()
	if err != nil {
		rst.Code = 500
		rst.Message = err.Error()
		response.WriteAsJson(rst)
		return
	} else {
		rst.Code = 200
		rst.Message = "success"
		rst.Data = regionResult
		response.WriteAsJson(rst)
		return
	}

}
func (h *Handler) getAzListHandler(request *restful.Request, response *restful.Response) {
	response.AddHeader("Access-Control-Allow-Origin", "*")
	rst := new(Result)
	region := request.QueryParameter("region")
	if region == "" || region == "all" {
		rst.Code = 200
		rst.Message = ""
		rst.Data = []basic.AzDt{}
		response.WriteAsJson(rst)
		return
	}

	azResult, err := h.svc.GetAzList(region)
	if err != nil {
		rst.Code = 500
		rst.Message = err.Error()
		response.WriteAsJson(rst)
		return
	} else {
		rst.Code = 200
		rst.Message = "success"
		rst.Data = azResult
		response.WriteAsJson(rst)
		return
	}

}
func (h *Handler) getRacksByCabinetIdsHandler(request *restful.Request, response *restful.Response) {
	response.AddHeader("Access-Control-Allow-Origin", "*")
	rst := new(Result)
	cabinetId := request.PathParameter("cabinetId")
	cabinetIdInt, err := strconv.Atoi(cabinetId)
	if err != nil {
		rst.Code = 500
		rst.Message = err.Error()
		response.WriteAsJson(rst)
		return
	}
	sn := request.QueryParameter("sn")
	regionResult, err := h.svc.GetRacksByCabinetId(sn, cabinetIdInt)
	if err != nil {
		rst.Code = 500
		rst.Message = err.Error()
		response.WriteAsJson(rst)
		return
	} else {
		rst.Code = 200
		rst.Message = "success"
		rst.Data = regionResult
		response.WriteAsJson(rst)
		return
	}

}

// 根据azCodes或者区域、可用区信息
// func (h *Handler) getAzRegionInfoHandler(request *restful.Request, response *restful.Response) {
// 	response.AddHeader(restful.HEADER_AccessControlAllowOrigin, "*")
// 	res := new(Result)
// 	params := basic.AzCodesParams{}
// 	err := request.ReadEntity(&params)
// 	if err != nil {
// 		res.Code = 500
// 		res.Message = err.Error()
// 		response.WriteAsJson(res)
// 		return
// 	}
// 	azRegionInfo, err := h.svc.GetAzRegionInfo(params.RegionCodes)
// 	if err != nil {
// 		res.Code = 200
// 		res.Message = err.Error()
// 		response.WriteAsJson(res)
// 		return
// 	}
// 	res.Code = 200
// 	res.Message = "success"
// 	res.Data = azRegionInfo
// 	response.WriteAsJson(res)
// 	return
// }
func (h *Handler) reportHardwareMessHandler(request *restful.Request, response *restful.Response) {
	response.AddHeader(restful.HEADER_AccessControlAllowOrigin, "*")
	res := new(Result) //hardwareMess basic.HardwareMess
	params := basic.HardwareMess{}
	err := request.ReadEntity(&params)
	if err != nil {
		res.Code = 500
		res.Message = err.Error()
		response.WriteAsJson(res)
		return
	}
	err = h.svc.ReportHardwareMess(params)
	if err != nil {
		res.Code = 200
		res.Message = err.Error()
		response.WriteAsJson(res)
		return
	}
	res.Code = 200
	res.Message = "success"
	response.WriteAsJson(res)
	return
}

func (h *Handler) reportHardwareHandler(request *restful.Request, response *restful.Response) {
	response.AddHeader(restful.HEADER_AccessControlAllowOrigin, "*")
	res := new(Result) //hardwareMess basic.HardwareMess
	params := hardware.Hardware{}
	err := request.ReadEntity(&params)
	if err != nil {
		res.Code = 500
		res.Message = err.Error()
		response.WriteAsJson(res)
		return
	}
	err = h.svc.ReportHardware(params)
	if err != nil {
		res.Code = 200
		res.Message = err.Error()
		response.WriteAsJson(res)
		return
	}
	res.Code = 200
	res.Message = "success"
	response.WriteAsJson(res)
	return
}

// func (h *Handler) getRegions() ([]Region, error) {
// 	q := `{
// 		dataList(func:has(containAzs))
// 		   {
// 			regionName
// 			regionCode
// 			regionCodeAggregate
// 			containAzs{
// 			  azName
// 			  azCode
// 			  azCodeAggregate
// 			  containLabs{
// 				labName
// 				labCode
// 			  }
// 			}
// 		  }
//         }`
// 	fmt.Println(q)
// 	var regionDataResult RegionData
// 	resp, err := h.dgraphClient.NewTxn().Query(context.Background(), q)
// 	err = json.Unmarshal(resp.Json, &regionDataResult)
// 	return regionDataResult.DataList, err
// }

// func (h *Handler) getRooms(labCode string) ([]Room, error) {
// 	q := `{
// 		dataList(func:eq(labCode,"` + labCode + `") )
// 		{
// 			containRooms{
// 				roomUid:uid
// 			  roomName
// 				containCabinets{
// 					cabinetUid:uid
// 				  cabinetName
// 				  containRacks{
// 				    rackUid:uid
// 					rackName:rackCode
// 				  }
// 				  containUnits{
// 					unitUid:uid
// 					unitNumber:unitCode
// 				  }
// 				}
// 			}
// 		}
//     }`
// 	fmt.Println(q)
// 	var roomDataResult RoomData
// 	resp, err := h.dgraphClient.NewTxn().Query(context.Background(), q)
// 	err = json.Unmarshal(resp.Json, &roomDataResult)
// 	if len(roomDataResult.DataList) > 0 {
// 		return roomDataResult.DataList[0].ContainRooms, err
// 	}
// 	var rom []Room
// 	return rom, err
// }

// func (h *Handler) getResourceTree() ([]ResourceType, error) {
// 	q := `{
// 		dataList(func:has(containResourceSubTypes), orderasc:resourceTypeIndex)
// 		   {
// 			resourceTypeCode
// 			resourceTypeName
// 			containResourceSubTypes(orderasc:resourceSubTypeIndex){
// 				resourceSubTypeCode
// 				resourceSubTypeName
// 			}
// 		  }
//         }`
// 	fmt.Println(q)
// 	var resourceTypeDataResult ResourceTypeData
// 	resp, err := h.dgraphClient.NewTxn().Query(context.Background(), q)
// 	err = json.Unmarshal(resp.Json, &resourceTypeDataResult)
// 	return resourceTypeDataResult.DataList, err
// }

// func (h *Handler) getResourceList() (ResourceList, error) {
// 	resourceList := ResourceList{}
// 	resourceType := []Resource{}
// 	resourceSubType := []Resource{}
// 	resourceResult, err := h.getResourceTree()
// 	if err != nil {
// 		return resourceList, err
// 	}
// 	for _, resourceT := range resourceResult {
// 		resourceType = append(resourceType, Resource{
// 			ResourceKey:   resourceT.ResourceTypeCode,
// 			ResourceValue: resourceT.ResourceTypeName,
// 		})
// 		for _, resourceSType := range resourceT.ContainResourceSubTypes {
// 			resourceSubType = append(resourceSubType, Resource{
// 				ResourceKey:   resourceSType.ResourceSubTypeCode,
// 				ResourceValue: resourceSType.ResourceSubTypeName,
// 			})
// 		}
// 	}
// 	resourceList.ResourceType = resourceType
// 	resourceList.ResourceSubType = resourceSubType
// 	return resourceList, err
// }

// //获取主机列表
// func (h *Handler) getHostTree() ([]PhysicalHostData, error) {

// 	q := `{
// 		dataList(func:has(sn))  {
// 		uid
// 		hostname
// 	  }
// 	}`
// 	fmt.Println(q)
// 	var physicalHostResult PhysicalHostList
// 	resp, err := h.dgraphClient.NewTxn().Query(context.Background(), q)
// 	err = json.Unmarshal(resp.Json, &physicalHostResult)
// 	return physicalHostResult.DataList, err
// }

// // func (h *Handler) getLabs() ([]Lab, error) {
// // 	q := `{
// // 		labList(func:has(labCode)){
// // 			labCode
// // 			labName
// // 		 }
// // 	   }`
// // 	fmt.Println(q)
// // 	var labDataResult LabData
// // 	resp, err := h.dgraphClient.NewTxn().Query(context.Background(), q)
// // 	err = json.Unmarshal(resp.Json, &labDataResult)
// // 	return labDataResult.LabList, err
// // }

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/pkg/api/basicmanager/result.go
```golang
package basicmanager

type Result struct {
	Code    int         `json:"code"`
	Message string      `json:"message"`
	Data    interface{} `json:"data"`
}

// type Unit struct {
// 	UnitUid    string `json:"unitUid"`
// 	UnitNumber string `json:"unitNumber"`
// }

// type Rack struct {
// 	RackUid string `json:"rackUid"`
// 	//RackCode string `json:"rackCode"`
// 	RackName string `json:"rackName"`
// }

// type Cabinet struct {
// 	CabinetUid string `json:"cabinetUid"`
// 	//CabinetCode  string `json:"cabinetCode"`
// 	CabinetName  string `json:"cabinetName"`
// 	ContainRacks []Rack `json:"containRacks"`
// 	ContainUnits []Unit `json:"containUnits"`
// }

// type Room struct {
// 	RoomUid string `json:"roomUid"`
// 	//RoomCode        string    `json:"roomCode"`
// 	RoomName        string    `json:"roomName"`
// 	ContainCabinets []Cabinet `json:"containCabinets"`
// }

// type Lab struct {
// 	LabCode string `json:"labCode"`
// 	LabName string `json:"labName"`
// }

// type Az struct {
// 	AzCode          string `json:"azCode"`
// 	AzName          string `json:"azName"`
// 	AzCodeAggregate string `json:"azCodeAggregate"`
// 	ContainLabs     []Lab  `json:"containLabs"`
// }

// type Region struct {
// 	RegionCode          string `json:"regionCode"`
// 	RegionName          string `json:"regionName"`
// 	RegionCodeAggregate string `json:"regionCodeAggregate"`
// 	ContainAzs          []Az   `json:"containAzs"`
// }

// type RegionData struct {
// 	DataList []Region `json:"dataList"`
// }

// type RoomData struct {
// 	DataList []ContainRoom `json:"dataList"`
// }

// type ContainRoom struct {
// 	ContainRooms []Room `json:"containRooms"`
// }

// type ResourceTypeData struct {
// 	DataList []ResourceType `json:"dataList"`
// }

// type ResourceType struct {
// 	ResourceTypeCode        string            `json:"resourceTypeCode"`
// 	ResourceTypeName        string            `json:"resourceTypeName"`
// 	ContainResourceSubTypes []ResourceSubType `json:"containResourceSubTypes"`
// }
// type ResourceSubType struct {
// 	ResourceSubTypeCode string `json:"resourceSubTypeCode"`
// 	ResourceSubTypeName string `json:"resourceSubTypeName"`
// }
// type PhysicalHostList struct {
// 	DataList []PhysicalHostData `json:"dataList"`
// }
// type PhysicalHostData struct {
// 	HostName string `json:"hostName"`
// 	Uid      string `json:"uid"`
// }

// type Resource struct {
// 	ResourceKey   string `json:"resourceKey"`
// 	ResourceValue string `json:"resourceValue"`
// }
// type ResourceList struct {
// 	ResourceType    []Resource `json:"resourceType"`
// 	ResourceSubType []Resource `json:"resourceSubType"`
// }

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/pkg/api/objectStorage/register.go
```golang
package objectStorage

import (
	"luban-cmdb-api/pkg/apiserver/config"
	"luban-cmdb-api/pkg/models/storage"
	"luban-cmdb-api/pkg/runtime"
	"luban-cmdb-api/pkg/service"

	"github.com/dgraph-io/dgo/v200"
	"github.com/emicklei/go-restful"
	restfulspec "github.com/emicklei/go-restful-openapi"
)

const APIGroup = "bucket"

func AddToContainer(c *restful.Container, config *config.Config, dgraphclient *dgo.Dgraph) error {
	ws := runtime.NewWebService(APIGroup)
	objectStoragePoolService := service.NewObjectStoragePoolService(config.StorageStateAddr, config.PrometheusAddr, config.CustomerDomain, dgraphclient)
	handler := NewHandler(objectStoragePoolService)

	//对象存储
	tag3 := []string{"bucket"}
	ws.Route(ws.POST("/").To(handler.getBucketDataList).
		Doc("获取bucket列表。").
		Metadata(restfulspec.KeyOpenAPITags, tag3).
		Reads(storage.BucketRequest{}, storage.BucketRequestDoc).
		// Param(ws.QueryParameter("pageNo", "eg:1,页码，默认值1。").DataType("int32").Required(false).DefaultValue("1")).
		// Param(ws.QueryParameter("pageSize", "eg:10, 页大小，默认值10。").DataType("int32").Required(false).DefaultValue("10")).
		// //Param(ws.QueryParameter("contentSelector", "要返回的字段，默认返回所有字段，格式：[`attr1`,`attr2`]。").DataType("[]string").Required(false)).
		// //Param(ws.QueryParameter("count", "eg:true, 是否统计实例数量，默认值true。值域：true,false").DataType("bool").Required(true).DefaultValue("true")).
		// Param(ws.QueryParameter("region", "区域;默认值：全部").DataType("string").Required(true).DefaultValue("全部")).
		// Param(ws.QueryParameter("az", "可用区;默认值：全部").DataType("string").Required(true).DefaultValue("全部")).
		// Param(ws.QueryParameter("name", "实例名称").DataType("string").Required(false)).
		// Param(ws.QueryParameter("id", "实例ID").DataType("string").Required(false)).
		// Param(ws.QueryParameter("tenantId", "租户ID").DataType("string").Required(false)).
		// Param(ws.QueryParameter("type", "bucket类型").DataType("string").Required(false)).
		Returns(200, "ok", storage.ObjectStoragePoolBucket{}))
	tagOverview := []string{"Overview"}
	ws.Route(ws.GET("/objectStoragePoolOverView").To(handler.getBucketOverView).
		Doc("Get overview data./获取云产品对象存储概览数据").
		Metadata(restfulspec.KeyOpenAPITags, tagOverview).
		Param(ws.QueryParameter("region", "区域;默认值：all").DataType("string").Required(true).DefaultValue("all")).
		Returns(200, "ok", storage.ObjectStorageOverview{}))
	ws.Route(ws.GET("/{instanceId}").To(handler.getBucketDataDetail).
		Doc("查询单个bucket的详情").
		Metadata(restfulspec.KeyOpenAPITags, tag3).
		Param(ws.PathParameter("instanceId", "bucket的唯一ID。").DataType("string").Required(true)).
		Returns(200, "ok", storage.BucketDetail{}))

	c.Add(ws)
	return nil
}

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/pkg/api/objectStorage/handler.go
```golang
package objectStorage

import (
	"github.com/emicklei/go-restful"

	"luban-cmdb-api/pkg/api"
	"luban-cmdb-api/pkg/models"
	"luban-cmdb-api/pkg/models/storage"
)

type Service interface {
	GetBucketList(r storage.BucketRequest) (*storage.ObjectStoragePoolBucket, error)
	GetBucketDetail(insId string) (storage.BucketDetail, error)
	GetBucketOverView(bucketRequest storage.BucketRequest) (storage.ObjectStorageOverview, error)
}

type Handler struct {
	svc Service
}

func NewHandler(svc Service) *Handler {
	return &Handler{
		svc: svc,
	}
}

func (h *Handler) getBucketDataList(req *restful.Request, resp *restful.Response) {
	t := new(storage.BucketRequest)
	err := req.ReadEntity(&t)
	// bucketRequest := storage.BucketRequest{
	// 	Pagination:  handler.CommonPagination(req),
	// 	Region:      req.QueryParameter("region"),
	// 	Az:          req.QueryParameter("az"),
	// 	Name:        req.QueryParameter("name"),
	// 	Id:          req.QueryParameter("id"),
	// 	TenantId:    req.QueryParameter("tenantId"),
	// 	StorageType: req.QueryParameter("storageType"),
	// }
	data, err := h.svc.GetBucketList(*t)
	if err != nil {
		api.HandleInternalError(resp, err)
		return
	}
	var res models.CommonResult
	res.Data = data
	resp.WriteAsJson(&res)
}

func (h *Handler) getBucketDataDetail(req *restful.Request, resp *restful.Response) {
	insId := req.PathParameter("instanceId")
	data, err := h.svc.GetBucketDetail(insId)
	if err != nil {
		api.HandleInternalError(resp, err)
		return
	}
	var res models.CommonResult
	res.Data = data
	resp.WriteAsJson(&res)
}
func (h *Handler) getBucketOverView(req *restful.Request, resp *restful.Response) {

	bucketRequest := storage.BucketRequest{

		Region: req.QueryParameter("region"),
	}
	data, err := h.svc.GetBucketOverView(bucketRequest)
	if err != nil {
		api.HandleInternalError(resp, err)
		return
	}
	var res models.CommonResult
	res.Data = data
	resp.WriteAsJson(&res)
}

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/pkg/api/objectStorage/result.go
```golang
package objectStorage

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/pkg/api/jsonconv/jsonconv.go
```golang
package jsonconv

import (
	"bytes"
	"encoding/json"
	"log"
	"regexp"
	"strconv"
	"strings"
	"unicode"
)

/*************************************** 下划线json ***************************************/
type JsonSnakeCase struct {
	Value interface{}
}

func (c JsonSnakeCase) MarshalJSON() ([]byte, error) {
	// Regexp definitions
	var keyMatchRegex = regexp.MustCompile(`\"(\w+)\":`)
	var wordBarrierRegex = regexp.MustCompile(`(\w)([A-Z])`)
	marshalled, err := json.Marshal(c.Value)
	converted := keyMatchRegex.ReplaceAllFunc(
		marshalled,
		func(match []byte) []byte {
			return bytes.ToLower(wordBarrierRegex.ReplaceAll(
				match,
				[]byte(`${1}_${2}`),
			))
		},
	)
	return converted, err
}

/*************************************** 驼峰json ***************************************/
type JsonCamelCase struct {
	Value interface{}
}

func (c JsonCamelCase) MarshalJSON() ([]byte, error) {
	var keyMatchRegex = regexp.MustCompile(`\"(\w+)\":`)
	marshalled, err := json.Marshal(c.Value)
	converted := keyMatchRegex.ReplaceAllFunc(
		marshalled,
		func(match []byte) []byte {
			matchStr := string(match)
			key := matchStr[1 : len(matchStr)-2]
			resKey := Lcfirst(Case2Camel(key))
			return []byte(`"` + resKey + `":`)
		},
	)
	return converted, err
}

/*************************************** 其他方法 ***************************************/
// 驼峰式写法转为下划线写法
func Camel2Case(name string) string {
	buffer := NewBuffer()
	for i, r := range name {
		if unicode.IsUpper(r) {
			if i != 0 {
				buffer.Append('_')
			}
			buffer.Append(unicode.ToLower(r))
		} else {
			buffer.Append(r)
		}
	}
	return buffer.String()
}

// 下划线写法转为驼峰写法
func Case2Camel(name string) string {
	name = strings.Replace(name, "_", " ", -1)
	name = strings.Title(name)
	return strings.Replace(name, " ", "", -1)
}

// 首字母大写
func Ucfirst(str string) string {
	for i, v := range str {
		return string(unicode.ToUpper(v)) + str[i+1:]
	}
	return ""
}

// 首字母小写
func Lcfirst(str string) string {
	for i, v := range str {
		return string(unicode.ToLower(v)) + str[i+1:]
	}
	return ""
}

// 内嵌bytes.Buffer，支持连写
type Buffer struct {
	*bytes.Buffer
}

func NewBuffer() *Buffer {
	return &Buffer{Buffer: new(bytes.Buffer)}
}

func (b *Buffer) Append(i interface{}) *Buffer {
	switch val := i.(type) {
	case int:
		b.append(strconv.Itoa(val))
	case int64:
		b.append(strconv.FormatInt(val, 10))
	case uint:
		b.append(strconv.FormatUint(uint64(val), 10))
	case uint64:
		b.append(strconv.FormatUint(val, 10))
	case string:
		b.append(val)
	case []byte:
		b.Write(val)
	case rune:
		b.WriteRune(val)
	}
	return b
}

func (b *Buffer) append(s string) *Buffer {
	defer func() {
		if err := recover(); err != nil {
			log.Println("*****内存不够了！******")
		}
	}()
	b.WriteString(s)
	return b
}

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/pkg/api/swagger/register.go
```golang
package swagger

import (
	"github.com/emicklei/go-restful"
	restfulspec "github.com/emicklei/go-restful-openapi"
	"github.com/go-openapi/spec"
)

func AddToContainer(c *restful.Container) error {
	config := restfulspec.Config{
		WebServices:                   c.RegisteredWebServices(),
		WebServicesURL:                "http://luban.cmdb.galaxy.cloud",
		APIPath:                       "/apidocs.json",
		DisableCORS:                   false,
		PostBuildSwaggerObjectHandler: enrichSwaggerObject}
	c.Add(restfulspec.NewOpenAPIService(config))
	return nil
}

func enrichSwaggerObject(swo *spec.Swagger) {
	swo.Info = &spec.Info{
		InfoProps: spec.InfoProps{
			Title:       "Luban Service",
			Description: "Resource for managing resources of Luban",
			Contact: &spec.ContactInfo{
				Name:  "wangfengteng",
				Email: "wangfengteng@kingsoft.com",
				URL:   "",
			},
			License: &spec.License{
				Name: "MIT",
				URL:  "http://mit.org",
			},
			Version: "1.0.0",
		},
	}
	swo.Tags = []spec.Tag{
		{TagProps: spec.TagProps{
			Name:        "physicalHost",
			Description: "服务器"}},
		{TagProps: spec.TagProps{
			Name:        "computePool",
			Description: "计算资源池"}},
		{TagProps: spec.TagProps{
			Name:        "bucket",
			Description: "对象存储"}},
		{TagProps: spec.TagProps{
			Name:        "clouddisk",
			Description: "块存储"}},
	}
}

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/pkg/api/bm/register.go
```golang
package bm

import (
	"luban-cmdb-api/pkg/models/bm"
	"luban-cmdb-api/pkg/runtime"
	bmservice "luban-cmdb-api/pkg/service/bm"

	"github.com/emicklei/go-restful"
	restfulspec "github.com/emicklei/go-restful-openapi"
)

const APIGroup = "bm"

func AddToContainer(c *restful.Container) error {
	bmTag := []string{"bm"}
	ws := runtime.NewWebService(APIGroup)
	//ToDo: create service
	bmService := bmservice.NewService()
	handler := NewHandler(bmService)

	ws.Route(ws.GET("cloudProduct/overview").To(handler.getBmOverviewHandler).
		Doc("获取裸金属概览").
		Metadata(restfulspec.KeyOpenAPITags, bmTag).
		Param(ws.QueryParameter("region", "region")).
		Param(ws.QueryParameter("az", "available zone")).
		Returns(200, "OK", bm.OverviewRsp{}))
	ws.Route(ws.POST("cloudProduct/list").To(handler.getBmResourceListHandler).
		Doc("裸金属资源列表").
		Metadata(restfulspec.KeyOpenAPITags, bmTag).
		Reads(bm.ListReq{}, "region:region\nsearchType:搜索类型 (实例名称 name/实例ID id)\nsearchValue：搜索值").
		Returns(200, "OK", bm.ListRsp{}))
	ws.Route(ws.GET("cloudProduct/bmList/optionalCondition").To(handler.getListOptionalCondition).
		Doc("裸金属资源列表可选条件").
		Metadata(restfulspec.KeyOpenAPITags, bmTag).
		Reads("", "").
		Returns(200, "OK", nil))
	ws.Route(ws.GET("cloudProduct/detail/{id}").To(handler.getDetailHandler).
		Doc("裸金属实例详情").
		Metadata(restfulspec.KeyOpenAPITags, bmTag).
		Reads(bm.DetailReq{}, "id:实例id").
		Returns(200, "OK", bm.DetailRsp{}))
	c.Add(ws)
	return nil
}

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/pkg/api/bm/handler.go
```golang
package bm

import (
	"luban-cmdb-api/pkg/models"
	"luban-cmdb-api/pkg/models/bm"

	"github.com/emicklei/go-restful"
)

type BmService interface {
	GetBmOverview(region, az string) (bm.OverviewRsp, error)
	GetBmResourceList(params bm.ListReq) (bm.ListRsp, error)
	GetListOptionalCondition() (map[string][]interface{}, error)
	GetBmDetail(params bm.DetailReq) (bm.DetailRsp, error)
}

type Handler struct {
	svc BmService
}

func NewHandler(bmService BmService) *Handler {
	return &Handler{
		svc: bmService,
	}
}

func (h *Handler) getBmOverviewHandler(req *restful.Request, resp *restful.Response) {
	resp.AddHeader(restful.HEADER_AccessControlAllowOrigin, "*")
	res := &models.CommonResult{
		Code:    200,
		Message: "success",
		Data:    nil,
	}
	region := req.QueryParameter("regionCode")
	az := req.QueryParameter("azCode")
	overview, err := h.svc.GetBmOverview(region, az)
	if err != nil {
		res.Code = 500
		res.Message = err.Error()
		resp.WriteAsJson(res)
		return
	}
	res.Data = overview
	resp.WriteAsJson(res)
}

func (h *Handler) getBmResourceListHandler(req *restful.Request, resp *restful.Response) {
	resp.AddHeader(restful.HEADER_AccessControlAllowOrigin, "*")
	res := &models.CommonResult{
		Code:    200,
		Message: "success",
		Data:    nil,
	}
	params := bm.ListReq{}
	err := req.ReadEntity(&params)
	if err != nil {
		res.Code = 500
		res.Message = "参数解析错误"
		resp.WriteAsJson(res)
		return
	}
	if params.PageSize <= 0 {
		params.PageSize = 10
	}
	if params.PageNo < 1 {
		params.PageNo = 1
	}
	data, err := h.svc.GetBmResourceList(params)
	if err != nil {
		res.Code = 500
		res.Message = err.Error()
		resp.WriteAsJson(res)
		return
	}
	res.Data = data
	resp.WriteAsJson(res)
}

func (h *Handler) getListOptionalCondition(req *restful.Request, resp *restful.Response) {
	resp.AddHeader(restful.HEADER_AccessControlAllowOrigin, "*")
	res := &models.CommonResult{
		Code:    200,
		Message: "success",
		Data:    nil,
	}
	data, err := h.svc.GetListOptionalCondition()
	if err != nil {
		res.Code = 500
		res.Message = err.Error()
		resp.WriteAsJson(res)
		return
	}
	res.Data = data
	resp.WriteAsJson(res)
}

func (h *Handler) getDetailHandler(req *restful.Request, resp *restful.Response) {
	resp.AddHeader(restful.HEADER_AccessControlAllowOrigin, "*")
	res := &models.CommonResult{
		Code:    200,
		Message: "success",
		Data:    nil,
	}
	id := req.PathParameter("id")
	if id == "" {
		res.Code = 500
		res.Message = "参数解析错误"
		resp.WriteAsJson(res)
		return
	}
	params := bm.DetailReq{
		Id: id,
	}
	data, err := h.svc.GetBmDetail(params)
	if err != nil {
		res.Code = 500
		res.Message = err.Error()
		resp.WriteAsJson(res)
		return
	}
	res.Data = data
	resp.WriteAsJson(res)
}

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/pkg/api/blockStorage/register.go
```golang
package blockStorage

import (
	"github.com/dgraph-io/dgo/v200"
	"github.com/emicklei/go-restful"
	restfulspec "github.com/emicklei/go-restful-openapi"

	"luban-cmdb-api/pkg/apiserver/config"
	"luban-cmdb-api/pkg/models/aggregate"
	"luban-cmdb-api/pkg/models/storage"
	"luban-cmdb-api/pkg/runtime"
	"luban-cmdb-api/pkg/service"
)

const APIGroup = "clouddisk"

func AddToContainer(c *restful.Container, dgraphclient *dgo.Dgraph, config *config.Config) error {
	ws := runtime.NewWebService(APIGroup)
	blockStoragePoolService := service.NewBlockStoragePoolService(config.EBSAddr, config.StorageStateAddr, dgraphclient)
	handler := NewHandler(blockStoragePoolService)
	//块存储
	tag4 := []string{"clouddisk"}
	ws.Route(ws.POST("/").To(handler.getCloudDiskList).
		Doc("获取云硬盘列表。").
		Metadata(restfulspec.KeyOpenAPITags, tag4).
		Reads(storage.CloudDiskRequest{}, storage.CloudDiskRequestDoc).
		Returns(200, "ok", storage.CloudDiskResult{}))
	ws.Route(ws.POST("/getCloudDiskTest").To(handler.getCloudDiskListTT).
		Doc("获取云硬盘列表测试。").
		Metadata(restfulspec.KeyOpenAPITags, tag4).
		Reads(storage.CloudDiskRequest{}, storage.CloudDiskRequestDoc).
		Returns(200, "ok", storage.CloudDiskResult{}))
	ws.Route(ws.GET("/{instanceId}").To(handler.getCloudDiskDetail).
		Doc("查询单个云硬盘的详情").
		Metadata(restfulspec.KeyOpenAPITags, tag4).
		Param(ws.PathParameter("instanceId", "云硬盘的唯一ID。").DataType("string").Required(true)).
		Returns(200, "ok", storage.CloudDiskDataDetail{}))
	tagOverview := []string{"Overview"}
	ws.Route(ws.GET("/blockStoragePoolOverView").To(handler.getBlockStoragePoolOverViewHandler).
		Doc("Get overview data./获取云产品块存储概览数据"). //获取云产品块存储概览数据
		Metadata(restfulspec.KeyOpenAPITags, tagOverview).
		Param(ws.QueryParameter("regionCode", "regionCode").DataType("string")).
		Param(ws.QueryParameter("azCode", " azCode").DataType("string")).
		//Param(ws.QueryParameter("resourcePoolCode", "ResourcePoolCode").DataType("string")).
		Returns(200, "OK", aggregate.AggregateOverview{}))
	c.Add(ws)
	return nil
}

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/pkg/api/blockStorage/handler.go
```golang
package blockStorage

import (
	"github.com/emicklei/go-restful"

	"luban-cmdb-api/pkg/api"
	"luban-cmdb-api/pkg/models"
	"luban-cmdb-api/pkg/models/storage"
)

type Service interface {
	GetCloudDiskList(req storage.CloudDiskRequest) (*storage.CloudDiskResult, error)
	GetCloudDiskDetail(insId string) (*storage.CloudDiskDataDetail, error)
	GetCloudDiskOverviewData(cloudDiskReq storage.CloudDiskRequest) (storage.CloudDiskOverview, error)
}

type Handler struct {
	svc Service
}

func NewHandler(svc Service) *Handler {
	return &Handler{svc: svc}
}

func (h *Handler) getCloudDiskList(req *restful.Request, resp *restful.Response) {
	t := new(storage.CloudDiskRequest)
	err := req.ReadEntity(&t)
	data, err := h.svc.GetCloudDiskList(*t)
	if err != nil {
		api.HandleInternalError(resp, err)
		return
	}
	res := models.CommonResult{Data: data}
	resp.WriteAsJson(&res)
}
func (h *Handler) getCloudDiskListTT(req *restful.Request, resp *restful.Response) {
	t := new(storage.CloudDiskRequest)
	err := req.ReadEntity(&t)
	data, err := h.svc.GetCloudDiskList(*t)
	if err != nil {
		api.HandleInternalError(resp, err)
		return
	}
	res := models.CommonResult{Data: data}
	resp.WriteAsJson(&res)
}

func (h *Handler) getCloudDiskDetail(req *restful.Request, resp *restful.Response) {
	instanceId := req.PathParameter("instanceId")
	data, err := h.svc.GetCloudDiskDetail(instanceId)
	if err != nil {
		api.HandleInternalError(resp, err)
		return
	}
	res := models.CommonResult{Code: 200, Data: data}
	resp.WriteAsJson(res)
}

//查询云产品块存储概览数据
func (h *Handler) getBlockStoragePoolOverViewHandler(request *restful.Request, response *restful.Response) {
	//instanceId := request.PathParameter("instanceId")
	//response.AddHeader("Access-Control-Allow-Origin", "*")
	rst := new(Result)
	t := new(storage.CloudDiskRequest)
	t.Region = request.QueryParameter("regionCode")
	az := request.QueryParameter("azCode")
	azQ := []string{}
	if az != "" && az != "all" {
		azQ = append(azQ, az)
	}
	t.Az = azQ //request.QueryParameter("azCode")
	objectRe, err := h.svc.GetCloudDiskOverviewData(*t)
	if err != nil {
		rst.Code = 500
		rst.Message = err.Error()
		response.WriteAsJson(rst)
		return
	} else {
		rst.Code = 200
		rst.Message = "success"
		rst.Data = objectRe
		response.WriteAsJson(rst)
		return
	}
}

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/pkg/api/blockStorage/result.go
```golang
package blockStorage

type Result struct {
	Code    int         `json:"code"`
	Message string      `json:"message"`
	Data    interface{} `json:"data"`
}

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/pkg/api/aggregate/register.go
```golang
package aggregate

import (
	"luban-cmdb-api/pkg/api"
	"luban-cmdb-api/pkg/apiserver/config"
	"luban-cmdb-api/pkg/models/aggregate"
	"luban-cmdb-api/pkg/runtime"
	"luban-cmdb-api/pkg/service"
	"net/http"

	"github.com/emicklei/go-restful"
	restfulspec "github.com/emicklei/go-restful-openapi"
	"github.com/gophercloud/gophercloud"
)

const APIGroup = "computePool"

func AddToContainer(c *restful.Container, novaclient *gophercloud.ServiceClient, identityClient *gophercloud.ServiceClient, config config.Config) error {
	ws := runtime.NewWebService(APIGroup)
	aggregateService := service.NewAggregateService(novaclient, identityClient, config)
	//handler := NewHandler(novaclient, config)
	handler := NewHandler(aggregateService)
	ws.Route(ws.POST("/").To(handler.listAggregates).
		Metadata(restfulspec.KeyOpenAPITags, []string{api.Aggregate}).
		Doc("list all aggregates/获取计算资源池列表。").
		Reads(aggregate.AggregatesListQuery{}, aggregate.AggregatesListQueryDoc).
		// Param(ws.QueryParameter("pageNo", "eg:1,页码，默认值1。").DataType("int32").Required(false).DefaultValue("1")).
		// Param(ws.QueryParameter("pageSize", "eg:10, 页大小，默认值10。").DataType("int32").Required(false).DefaultValue("10")).
		// Param(ws.QueryParameter("region", "区域;默认值：全部").DataType("string").Required(false).DefaultValue("全部")).
		// Param(ws.QueryParameter("az", "可用区;默认值：全部").DataType("string").Required(false).DefaultValue("全部")).
		// Param(ws.QueryParameter("name", "实例名称").DataType("string").Required(false)).
		Returns(http.StatusOK, "ok", aggregate.AggregatesResult{}))

	ws.Route(ws.GET("/{id}").To(handler.getAggregate).
		Metadata(restfulspec.KeyOpenAPITags, []string{api.Aggregate}).
		Doc("show a aggregate detail/查询单个计算资源池的资源详情").
		Param(ws.PathParameter("id", "aggregate id/计算资源池的唯一ID。")).
		Returns(http.StatusOK, "ok", aggregate.Aggregates{}))

	ws.Route(ws.POST("/{id}/hosts").To(handler.getAggregateHosts).
		Metadata(restfulspec.KeyOpenAPITags, []string{api.Aggregate}).
		Doc("list a aggregate all hosts/查询单个计算资源池的服务器列表").
		Param(ws.PathParameter("id", "aggregate id").Required(true)).
		Reads(aggregate.AggregateHostListQuery{}, aggregate.AggregateHostListQueryDoc).
		Returns(http.StatusOK, "ok", aggregate.AggregatesHosts{}))

	ws.Route(ws.POST("/{id}/vms").To(handler.getAggregateVMs).
		Metadata(restfulspec.KeyOpenAPITags, []string{api.Aggregate}).
		Doc("list a aggregate all vms/查询单个计算资源池的云主机列表").
		Param(ws.PathParameter("id", "aggregate id")).
		Reads(aggregate.AggregatesVmsQuery{}, aggregate.AggregatesVmsQueryDoc).
		Returns(http.StatusOK, "ok", aggregate.AggregatesVms{}))

	ws.Route(ws.POST("/usage").To(handler.getAggregateUsage).
		Metadata(restfulspec.KeyOpenAPITags, []string{api.Aggregate}).
		Doc("get a aggregate resource usage/查询单个计算资源池的库存列表").
		Reads(aggregate.AggregatesUsageQuery{}, aggregate.AggregatesUsageQueryDoc).
		Returns(http.StatusOK, "ok", aggregate.AggregatesUsage{}))

	tag1 := []string{"physicalHost"}
	ws.Route(ws.POST("/physicalHostResourceList/{serverName}").To(handler.getPhysicalHostResourceList).
		Doc("查询单个服务器的云资源列表").
		Metadata(restfulspec.KeyOpenAPITags, tag1).
		Param(ws.PathParameter("serverName", "服务器的名称。").DataType("string").Required(true)).
		Reads(aggregate.HostVMListQuery{}, aggregate.HostVMListQueryDoc).
		Returns(200, "ok", aggregate.AggregatesVms{}))
	//云主机
	tag2 := []string{"vm"}
	ws.Route(ws.POST("/vm").To(handler.getPhysicalVMsList).
		Doc("Get block storage resource pool list./获取云产品云主机列表").
		Metadata(restfulspec.KeyOpenAPITags, tag2).
		Reads(aggregate.VMListQuery{}, aggregate.VMListQueryDoc).
		Returns(200, "OK", aggregate.AggregatesVms{}))
	ws.Route(ws.GET("/vm/{instanceId}").To(handler.getVmDetailsHandler).
		Doc("Get vm detail.").
		Metadata(restfulspec.KeyOpenAPITags, tag2).
		Param(ws.PathParameter("instanceId", "The id of cloud host.").DataType("string").Required(true)).
		Returns(200, "ok", aggregate.VmDetail{}))
	tagOverview := []string{"Overview"}
	ws.Route(ws.GET("/aggregateOverview").To(handler.getOverview).
		Doc("Get overview data./获取云产品云主机概览数据").
		Metadata(restfulspec.KeyOpenAPITags, tagOverview).
		Param(ws.QueryParameter("regionCode", "regionCode").DataType("string")).
		Param(ws.QueryParameter("azCode", " azCode").DataType("string")).
		Returns(200, "OK", aggregate.AggregateOverview{}))
	ws.Route(ws.GET("/overview").To(handler.getPoolOverview).
		Metadata(restfulspec.KeyOpenAPITags, tagOverview).
		Doc("计算资源池概览数据").
		Param(ws.QueryParameter("region", "区域;all").DataType("string").Required(false).DefaultValue("all")).
		Param(ws.QueryParameter("az", "可用区;默认值：all").DataType("string").Required(false).DefaultValue("all")).
		Returns(http.StatusOK, "ok", aggregate.CMDBAggregateOverview{}))
	c.Add(ws)
	return nil
}

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/pkg/api/aggregate/handler.go
```golang
package aggregate

import (
	"encoding/json"
	"fmt"
	"luban-cmdb-api/pkg/api/jsonconv"
	"luban-cmdb-api/pkg/models/aggregate"
	"strconv"

	"github.com/emicklei/go-restful"
)

type Service interface {
	GetAggregateHostsList(aggregatesHostsQuery aggregate.AggregateHostListQuery) (aggregate.AggregatesHosts, error)     //
	GetAggregateAllList(aggregatesListQuery aggregate.AggregatesListQuery) (aggregate.AggregatesResult, error)          //
	GetAggregateDetail(id int) (aggregate.Aggregates, error)                                                            //
	GetAggregateUsageList(aggregatesUsageQuery aggregate.AggregatesUsageQuery) (aggregate.AggregatesUsageResult, error) //
	GetAggregateVMsList(aggregatesVMQuery aggregate.VMListQuery) (aggregate.AggregatesVms, error)                       //
	GetPhysicalHostResoursList(aggregatesVMQuery aggregate.HostVMListQuery) (aggregate.AggregatesVms, error)            //
	//GetVMsList(vmListQuery aggregate.VMListQuery) (aggregate.AggregatesVms, error)                                      //
	GetVmDetails(vmQuery aggregate.VMQuery) (aggregate.VmDetail, error)                         //
	GetOverviewData(overviewQuery aggregate.OverviewQuery) (aggregate.AggregateOverview, error) //
	GetCMDBOverView(aggragateListQuery aggregate.CMDBOverViewQuery) (aggregate.CMDBAggregateOverview, error)
}

type Handler struct {
	svc Service
}

func NewHandler(svc Service) *Handler {
	fmt.Println("获取nava客户端")
	return &Handler{
		svc: svc,
	}
}

func (h *Handler) listAggregates(request *restful.Request, response *restful.Response) {

	response.AddHeader("Access-Control-Allow-Origin", "*")
	rst := new(Result)
	t := new(aggregate.AggregatesListQuery)
	err := request.ReadEntity(&t)
	//pageNo, err := strconv.Atoi(request.QueryParameter("pageNo"))
	if err != nil {
		rst.Code = 500
		rst.Message = err.Error()
		response.WriteAsJson(rst)
		return
	}
	//pageSize, err := strconv.Atoi(request.QueryParameter("pageSize"))
	// if err != nil {
	// 	rst.Code = 500
	// 	rst.Message = "pageSize false"
	// 	response.WriteAsJson(rst)
	// 	return
	// }
	// count, err := strconv.ParseBool(request.QueryParameter("count"))
	// if err != nil {
	// 	rst.Code = 500
	// 	rst.Message = "count false"
	// 	response.WriteAsJson(rst)
	// 	return
	// }
	// t.PageNo = pageNo
	// t.PageSize = pageSize
	// //t.Count = count
	// t.Region = request.QueryParameter("region")
	// t.Az = request.QueryParameter("az")
	// t.Name = request.QueryParameter("name")
	fmt.Println(&t)
	//request.ReadEntity(t)
	AggregateDataResult, err := h.svc.GetAggregateAllList(*t)
	if err != nil {
		rst.Code = 500
		rst.Message = err.Error()
		response.WriteAsJson(rst)
		return
	} else {
		rst.Code = 200
		rst.Message = "success"
		rst.Data = AggregateDataResult
		response.WriteAsJson(rst)
		return
	}

}

func (h *Handler) getAggregate(request *restful.Request, response *restful.Response) {
	aggregateID := request.PathParameter("id")
	rst := new(Result)
	id, err := strconv.Atoi(aggregateID)
	if err != nil {
		rst.Code = 500
		rst.Message = err.Error()
		response.WriteAsJson(rst)
		return
	}
	res, err := h.svc.GetAggregateDetail(id)
	if err != nil {
		rst.Code = 500
		rst.Message = err.Error()
		response.WriteAsJson(rst)
		return
	} else {
		rst.Code = 200
		rst.Message = "success"
		rst.Data = res
		response.WriteAsJson(rst)
		return
	}
}

//获取计算资源池云主机列表api
func (h *Handler) getAggregateVMs(request *restful.Request, response *restful.Response) {

	rst := new(Result)
	t := new(aggregate.VMListQuery)
	err := request.ReadEntity(&t)
	if err != nil {
		rst.Code = 500
		rst.Message = err.Error()
		response.WriteAsJson(rst)
		return
	}
	id := request.PathParameter("id")
	if id == "" {
		rst.Code = 500
		rst.Message = "id false"
		response.WriteAsJson(rst)
		return
	}
	idInt, err := strconv.Atoi(id)
	if err != nil {
		rst.Code = 500
		rst.Message = "id false"
		response.WriteAsJson(rst)
		return
	}
	t.AggregateId = idInt
	t.Region = "all"
	//t.Az = "all"
	aggregatesVMsList, err := h.svc.GetAggregateVMsList(*t)
	if err != nil {
		rst.Code = 500
		rst.Message = err.Error()
		response.WriteAsJson(rst)
		return
	} else {
		rst.Code = 200
		rst.Message = "success"
		rst.Data = aggregatesVMsList
		response.WriteAsJson(rst)
		return
	}
}

//获取云资源列表api适用物力资源管理资源列表页面的云资源列表
func (h *Handler) getPhysicalHostResourceList(request *restful.Request, response *restful.Response) {

	rst := new(Result)
	t := new(aggregate.HostVMListQuery)

	err := request.ReadEntity(&t)
	if err != nil {
		rst.Code = 500
		rst.Message = err.Error()
		response.WriteAsJson(rst)
		return
	}
	serverName := request.PathParameter("serverName")
	if serverName == "" {
		rst.Code = 500
		rst.Message = "serverName false"
		response.WriteAsJson(rst)
		return
	}
	t.ServerName = serverName

	aggregatesVMsList, err := h.svc.GetPhysicalHostResoursList(*t)
	if err != nil {
		rst.Code = 500
		rst.Message = err.Error()
		response.WriteAsJson(rst)
		return
	} else {
		rst.Code = 200
		rst.Message = "success"
		rst.Data = aggregatesVMsList
		response.WriteAsJson(rst)
		return
	}
}

//获取云产品云主机列表也适用物力资源管理资源列表页面的云资源列表
func (h *Handler) getPhysicalVMsList(request *restful.Request, response *restful.Response) {

	rst := new(Result)
	t := new(aggregate.VMListQuery)
	err := request.ReadEntity(&t)
	if err != nil {
		rst.Code = 500
		rst.Message = err.Error()
		response.WriteAsJson(rst)
		return
	}
	// pageNo, err := strconv.Atoi(request.QueryParameter("pageNo"))
	// if err != nil {
	// 	rst.Code = 500
	// 	rst.Message = "pageNo false"
	// 	response.WriteAsJson(rst)
	// 	return
	// }
	// pageSize, err := strconv.Atoi(request.QueryParameter("pageSize"))
	// if err != nil {
	// 	rst.Code = 500
	// 	rst.Message = "pageSize false"
	// 	response.WriteAsJson(rst)
	// 	return
	// }
	// //t.ServerName = serverName
	// t.PageNo = pageNo
	// t.PageSize = pageSize
	// t.Region = request.QueryParameter("region")
	// t.Az = request.QueryParameter("az")
	// t.Name = request.QueryParameter("name")
	// t.Id = request.QueryParameter("id")
	// t.TenantId = request.QueryParameter("tenantId")
	// t.Status = request.QueryParameter("status")
	aggregatesVMsList, err := h.svc.GetAggregateVMsList(*t)
	if err != nil {
		rst.Code = 500
		rst.Message = err.Error()
		response.WriteAsJson(rst)
		return
	} else {
		rst.Code = 200
		rst.Message = "success"
		rst.Data = aggregatesVMsList
		response.WriteAsJson(rst)
		return
	}
}

//查询单个计算资源池的服务器列表
func (h *Handler) getAggregateHosts(request *restful.Request, response *restful.Response) {
	rst := new(Result)
	t := new(aggregate.AggregateHostListQuery)
	err := request.ReadEntity(&t)
	id := request.PathParameter("id")
	if id == "" {
		rst.Code = 500
		rst.Message = "id false"
		response.WriteAsJson(rst)
		return
	}
	// pageNo, err := strconv.Atoi(request.QueryParameter("pageNo"))
	// if err != nil {
	// 	rst.Code = 500
	// 	rst.Message = "pageNo false"
	// 	response.WriteAsJson(rst)
	// 	return
	// }
	// pageSize, err := strconv.Atoi(request.QueryParameter("pageSize"))
	// if err != nil {
	// 	rst.Code = 500
	// 	rst.Message = "pageSize false"
	// 	response.WriteAsJson(rst)
	// 	return
	// }
	t.Id = id
	// t.PageNo = pageNo
	// t.PageSize = pageSize
	// t.Status = request.QueryParameter("status")
	// t.AssignmentStatus = request.QueryParameter("assignmentStatus")
	aggregatesUsageList, err := h.svc.GetAggregateHostsList(*t)
	if err != nil {
		rst.Code = 500
		rst.Message = err.Error()
		response.WriteAsJson(rst)
		return
	} else {
		rst.Code = 200
		rst.Message = "success"
		rst.Data = aggregatesUsageList
		response.WriteAsJson(rst)
		return
	}
}

//获取库存api
func (h *Handler) getAggregateUsage(request *restful.Request, response *restful.Response) {
	rst := new(Result)
	t := new(aggregate.AggregatesUsageQuery)
	err := request.ReadEntity(&t)
	if err != nil {
		rst.Code = 500
		rst.Message = err.Error()
		response.WriteAsJson(rst)
		return
	}
	if t.Region == "" {
		t.Region = "all"
	}
	// if t.Az == "" {
	// 	t.Az = "all"
	// }
	aggregatesUsageList, err := h.svc.GetAggregateUsageList(*t)
	if err != nil {
		rst.Code = 500
		rst.Message = err.Error()
		response.WriteAsJson(rst)
		return
	} else {
		rst.Code = 200
		rst.Message = "success"
		rst.Data = aggregatesUsageList
		response.WriteAsJson(rst)
		return
	}

}

//获取云主机详情
func (h *Handler) getVmDetailsHandler(request *restful.Request, response *restful.Response) {
	//rst := new(Result)
	var rst Result
	t := new(aggregate.VMQuery)
	id := request.PathParameter("instanceId")
	if id == "" {
		rst.Code = 500
		rst.Message = "instanceId false"
		response.WriteAsJson(rst)
		return
	}

	t.Id = id
	// t.Az = request.QueryParameter("az")
	// t.Aggregate = request.QueryParameter("aggregate")
	vmDetail, err := h.svc.GetVmDetails(*t)
	if err != nil {
		rst.Code = 500
		rst.Message = err.Error()

		response.WriteAsJson(rst)
		return
	} else {
		rst.Code = 200
		rst.Message = "success"
		rst.Data = vmDetail
		res, _ := json.Marshal(jsonconv.JsonCamelCase{Value: rst})
		response.Write(res)
		return
	}

}

//获取计算资源池以及云主机概览页数据
func (h *Handler) getOverview(request *restful.Request, response *restful.Response) {

	rst := new(Result)
	t := new(aggregate.OverviewQuery)
	t.Region = request.QueryParameter("regionCode")
	t.Az = request.QueryParameter("azCode")
	aggregatesVMsList, err := h.svc.GetOverviewData(*t)
	if err != nil {
		rst.Code = 500
		rst.Message = err.Error()
		response.WriteAsJson(rst)
		return
	} else {
		rst.Code = 200
		rst.Message = "success"
		rst.Data = aggregatesVMsList
		response.WriteAsJson(rst)
		return
	}
}

//获取计算资源池概览页数据
func (h *Handler) getPoolOverview(request *restful.Request, response *restful.Response) {
	response.AddHeader("Access-Control-Allow-Origin", "*")
	rst := new(Result)
	t := new(aggregate.CMDBOverViewQuery)

	region := request.QueryParameter("region")
	if region == "" || region == "all" {
		region = "all"
	}
	az := request.QueryParameter("az")
	if az == "" || az == "all" {
		az = "all"
	}

	//t.Count = count
	t.Region = region
	t.Az = az
	//request.ReadEntity(t)

	responseMetric, err := h.svc.GetCMDBOverView(*t)
	if err != nil {
		rst.Code = 500
		rst.Message = err.Error()
		response.WriteAsJson(rst)
		return
	} else {
		rst.Code = 200
		rst.Message = "success"
		rst.Data = responseMetric
		response.WriteAsJson(rst)
		return
	}
}

// func (h *Handler) getHostInstance(host string) ([]servers.Server, error) {
// 	page, err := servers.List(h.novaclient, servers.ListOpts{Host: host, AllTenants: true}).AllPages()
// 	if err != nil {
// 		return nil, err
// 	}
// 	instances, err := servers.ExtractServers(page)
// 	if err != nil {
// 		return nil, err
// 	}
// 	return instances, nil
// }

// func (h *Handler) getAggregateHostsAll(aggregateID string) ([]AggregatesHost, error) {
// 	//aggregateID := request.PathParameter("id")
// 	id, err := strconv.Atoi(aggregateID)
// 	res := []AggregatesHost{}
// 	if err != nil {
// 		//api.HandleInternalError(response, err)
// 		return res, err
// 	}
// 	agg, err := aggregates.Get(h.novaclient, id).Extract()
// 	if err != nil {
// 		//api.HandleInternalError(response, err)
// 		return res, err
// 	}

// 	hostData := service.DgraphService{
// 		Code:  "hostname",
// 		Value: "",
// 	}
// 	for _, host := range agg.Hosts {
// 		hostData.Value = host
// 		//[]model.HostData
// 		hostList, err := hostData.HostQuery()
// 		if err != nil || len(hostList) < 1 {
// 			continue
// 		}
// 		aggHost := AggregatesHost{
// 			Id:               hostList[0].Uid, //agg.ID
// 			Name:             host,
// 			Status:           hostList[0].Runstatus,        //"unknown",
// 			ResourcePoolType: hostList[0].ResourcePoolType, //"kec", //"compute",
// 			ResourcePool:     hostList[0].ResourcePool,     //agg.Name,
// 			Service:          hostList[0].Service,          //"unknown",
// 			Region:           hostList[0].Region,           //h.apiServerConfig.RegionName,
// 			Az:               hostList[0].Az,               //.GetAZByOurWay(), //agg.AvailabilityZone,
// 			Room:             hostList[0].Room,             //"unknown",
// 			Rack:             hostList[0].Rack,             //"unknown",
// 			RackPosition:     hostList[0].Unit,             //"unknown",
// 			SN:               hostList[0].Sn,               //"unknown",
// 		}
// 		res = append(res, aggHost)
// 	}
// 	return res, err
// }

// //从总的服务器列表中进行分页获取数据
// func (h *Handler) getAggregateHostsList(aggregatesHostsQuery AggregatesUsageQuery) (AggregatesHosts, error) {
// 	aggregatesDataList, err := h.getAggregateHostsAll(aggregatesHostsQuery.Id)
// 	//listAll := AggregatesData
// 	//对查询结果进行分页
// 	listPageResult := AggregatesHosts{}

// 	low := (aggregatesHostsQuery.PageNo - 1) * aggregatesHostsQuery.PageSize
// 	high := (aggregatesHostsQuery.PageNo) * aggregatesHostsQuery.PageSize
// 	if high > len(aggregatesDataList) {
// 		high = len(aggregatesDataList)
// 	}

// 	listPageResult.DataList = aggregatesDataList[low:high]
// 	listPageResult.TotalCount = len(aggregatesDataList)
// 	listPageResult.PageNo = aggregatesHostsQuery.PageNo
// 	listPageResult.PageSize = aggregatesHostsQuery.PageSize
// 	return listPageResult, err

// }

// //从总的Aggregate中进行分页获取数据
// func (h *Handler) getAggregateAllList(aggregatesListQuery AggregatesListQuery) (AggregatesResult, error) {
// 	fmt.Println("222222222222")
// 	AggregatesData, err := h.getAggregateAll()
// 	listAll := AggregatesData.DataList
// 	//获取查询结果  ---可以进行查询结果的时候就按照分页来获取数据
// 	listQueryResult := []Aggregates{}
// 	//对查询结果进行分页
// 	listPageResult := AggregatesResult{}
// 	for _, aggregate := range listAll {

// 		if (aggregatesListQuery.Region == "all" || aggregatesListQuery.Region == aggregate.RegionCode) &&
// 			(aggregatesListQuery.Az == "all" || aggregatesListQuery.Az == aggregate.AzCode) &&
// 			(aggregatesListQuery.Name == "" || aggregatesListQuery.Name == aggregate.Name) {
// 			listQueryResult = append(listQueryResult, aggregate)
// 		}
// 	}
// 	//if aggregatesListQuery.Region

// 	low := (aggregatesListQuery.PageNo - 1) * aggregatesListQuery.PageSize
// 	high := (aggregatesListQuery.PageNo) * aggregatesListQuery.PageSize
// 	if high > len(listQueryResult) {
// 		high = len(listQueryResult)
// 	}

// 	listPageResult.DataList = listQueryResult[low:high]
// 	listPageResult.TotalCount = len(listQueryResult)
// 	listPageResult.PageNo = aggregatesListQuery.PageNo
// 	listPageResult.PageSize = aggregatesListQuery.PageSize
// 	return listPageResult, err

// }

// //获取所有的Aggregate
// func (h *Handler) getAggregateAll() (AggregatesResult, error) {
// 	res := AggregatesResult{}
// 	fmt.Println("true")
// 	page, err := aggregates.List(h.novaclient).AllPages()
// 	if err != nil {
// 		//api.HandleInternalError(response, err)
// 		return res, err
// 	}
// 	aggs, err := aggregates.ExtractAggregates(page)
// 	if err != nil {
// 		//api.HandleInternalError(response, err)
// 		return res, err
// 	}
// 	region := service.DgraphService{
// 		Code:  "regionCodeAggregate",
// 		Value: h.apiServerConfig.RegionName,
// 	}
// 	az := service.DgraphService{
// 		Code:  "azCodeAggregate",
// 		Value: "",
// 	}
// 	regionData := region.GetRegionByOurWay()
// 	azData := az.GetAZByOurWay()
// 	for _, agg := range aggs {
// 		allInstannces := []servers.Server{}
// 		for i := range agg.Hosts {
// 			//通过服务器获取虚机
// 			instances, err := h.getHostInstance(agg.Hosts[i])
// 			if err != nil {
// 				//api.HandleInternalError(response, err)
// 				return res, err
// 			}
// 			allInstannces = append(allInstannces, instances...)
// 		}
// 		az.Value = agg.AvailabilityZone

// 		res.DataList = append(res.DataList, Aggregates{
// 			Name:       agg.Name,
// 			Id:         agg.ID,
// 			Region:     regionData.RegionName, //h.apiServerConfig.RegionName,
// 			RegionCode: regionData.RegionCode, //h.apiServerConfig.RegionName,
// 			Service:    "unknown",
// 			Az:         azData.AZName, //agg.AvailabilityZone,
// 			AzCode:     azData.AZCode, //agg.AvailabilityZone,
// 			HostCount:  len(agg.Hosts),
// 			VMCount:    len(allInstannces),
// 		})
// 	}
// 	res.TotalCount = len(res.DataList)
// 	return res, err
// 	//response.WriteEntity(res)
// }

// //从总的库存中进行分页获取数据
// func (h *Handler) getAggregateUsageList(aggregatesUsageQuery AggregatesUsageQuery) (AggregatesUsageResult, error) {
// 	aggregatesDataList, err := h.getAggregateUsageAll(aggregatesUsageQuery.Id)
// 	//listAll := AggregatesData
// 	//对查询结果进行分页
// 	listPageResult := AggregatesUsageResult{}

// 	low := (aggregatesUsageQuery.PageNo - 1) * aggregatesUsageQuery.PageSize
// 	high := (aggregatesUsageQuery.PageNo) * aggregatesUsageQuery.PageSize
// 	if high > len(aggregatesDataList) {
// 		high = len(aggregatesDataList)
// 	}

// 	listPageResult.DataList = aggregatesDataList[low:high]
// 	listPageResult.TotalCount = len(aggregatesDataList)
// 	listPageResult.PageNo = aggregatesUsageQuery.PageNo
// 	listPageResult.PageSize = aggregatesUsageQuery.PageSize
// 	return listPageResult, err

// }

// //获取总库存根据资源池id
// func (h *Handler) getAggregateUsageAll(aggregateID string) ([]AggregatesUsage, error) {
// 	var resAll []AggregatesUsage
// 	id, err := strconv.Atoi(aggregateID)
// 	if err != nil {
// 		return resAll, err
// 	}
// 	agg, err := aggregates.Get(h.novaclient, id).Extract()
// 	if err != nil {
// 		return resAll, err
// 	}
// 	page, err := hypervisors.List(h.novaclient).AllPages()
// 	if err != nil {
// 		return resAll, err
// 	}
// 	hs, err := hypervisors.ExtractHypervisors(page)
// 	if err != nil {
// 		return resAll, err
// 	}

// 	for _, hypervisor := range hs {
// 		freeRam := 0
// 		usedRam := 0
// 		totalRam := 0
// 		usedvCPU := 0
// 		totalvCPU := 0
// 		freeRam += hypervisor.FreeRamMB
// 		usedRam += hypervisor.MemoryMBUsed
// 		totalRam += hypervisor.MemoryMB
// 		usedvCPU += hypervisor.VCPUsUsed
// 		totalvCPU += hypervisor.VCPUs
// 		freevCPU := 0
// 		if free := totalvCPU - usedvCPU; free > 0 {
// 			freevCPU = free
// 		}
// 		region := service.DgraphService{
// 			Code:  "regionCodeAggregate",
// 			Value: h.apiServerConfig.RegionName,
// 		}
// 		regionData := region.GetRegionByOurWay()
// 		az := service.DgraphService{
// 			Code:  "azCodeAggregate",
// 			Value: agg.AvailabilityZone,
// 		}
// 		azData := az.GetAZByOurWay()
// 		res := AggregatesUsage{
// 			VCPUTotal:    totalvCPU,
// 			VCPUUsage:    usedvCPU,
// 			VCPURemain:   freevCPU,
// 			VCPURate:     float64(freevCPU) / float64(totalvCPU),
// 			MemoryTotal:  totalRam,
// 			MemoryUsage:  usedRam,
// 			MemoryRemain: freeRam,
// 			MemoryRate:   float64(freeRam) / float64(totalRam),
// 			Name:         agg.Name,
// 			Region:       regionData.RegionName, //h.apiServerConfig.RegionName,
// 			RegionCode:   regionData.RegionCode, //h.apiServerConfig.RegionName,
// 			Az:           azData.AZName,         //agg.AvailabilityZone,
// 			AzCode:       azData.AZCode,         //agg.AvailabilityZone,
// 		}
// 		resAll = append(resAll, res)
// 	}
// 	return resAll, err
// }

// func (h *Handler) getAggregateVMsAll(aggregateID string) ([]AggregatesVm, error) {
// 	//aggregateID := request.PathParameter("id")
// 	res := []AggregatesVm{}
// 	id, err := strconv.Atoi(aggregateID)
// 	if err != nil {
// 		//api.HandleInternalError(response, err)
// 		return res, err
// 	}
// 	agg, err := aggregates.Get(h.novaclient, id).Extract()
// 	if err != nil {
// 		//api.HandleInternalError(response, err)
// 		return res, err
// 	}
// 	allInstannces := []servers.Server{}
// 	for i := range agg.Hosts {
// 		fmt.Println(agg.Hosts[i])
// 		instances, err := h.getHostInstance(agg.Hosts[i])
// 		if err != nil {
// 			//api.HandleInternalError(response, err)
// 			return res, err
// 		}
// 		allInstannces = append(allInstannces, instances...)
// 	}
// 	region := service.DgraphService{
// 		Code:  "regionCodeAggregate",
// 		Value: h.apiServerConfig.RegionName,
// 	}
// 	regionData := region.GetRegionByOurWay()
// 	az := service.DgraphService{
// 		Code:  "azCodeAggregate",
// 		Value: agg.AvailabilityZone,
// 	}
// 	azData := az.GetAZByOurWay()
// 	for _, vm := range allInstannces {
// 		fmt.Println("vcpus")
// 		fmt.Println(reflect.TypeOf(vm.Flavor["vcpus"]))
// 		fmt.Println(interfaceToValue(vm.Flavor["vcpus"]))
// 		fmt.Println(reflect.TypeOf(vm.Flavor["ram"]))
// 		fmt.Println(reflect.TypeOf(vm.Flavor["disk"]))
// 		//fmt.Printf("%v-%s-%v-%v-%v-/n", vm.Flavor["cluster"], interfaceToValue(vm.Flavor["vcpus"]), interfaceToValue(vm.Flavor["ram"]), interfaceToValue(vm.Flavor["storage_type"]), interfaceToValue(vm.Flavor["disk"]))
// 		vm := AggregatesVm{
// 			ID:   vm.ID,
// 			Name: vm.Name,
// 			//Flavor:     vm.Flavor,
// 			Flavor:     interfaceToValue(vm.Flavor["cluster"]) + "-" + interfaceToValue(vm.Flavor["vcpus"]) + "-" + interfaceToValue(vm.Flavor["ram"]) + "-" + interfaceToValue(vm.Flavor["storage_type"]) + "-" + interfaceToValue(vm.Flavor["disk"]),
// 			Status:     vm.Status,
// 			Aggregate:  agg.Name,
// 			Region:     regionData.RegionName, //h.apiServerConfig.RegionName,
// 			RegionCode: regionData.RegionCode, //h.apiServerConfig.RegionName,
// 			Az:         azData.AZName,         //agg.AvailabilityZone,
// 			AzCode:     azData.AZCode,         //agg.AvailabilityZone,
// 			TenantId:   vm.TenantID,
// 			Hypervisor: vm.HostID,
// 			CreateTime: fmt.Sprintf("%d", vm.Created.Unix()),
// 			InnerIP:    "unknown",
// 			PublicIP:   "unknown",
// 		}
// 		res = append(res, vm)
// 	}
// 	return res, err
// }

// //从总的服务器列表中进行分页获取数据
// func (h *Handler) getAggregateVMsList(aggregatesVMQuery AggregatesUsageQuery) (AggregatesVms, error) {
// 	aggregatesVmDataList, err := h.getAggregateVMsAll(aggregatesVMQuery.Id)
// 	//listAll := AggregatesData
// 	//对查询结果进行分页
// 	listPageResult := AggregatesVms{}

// 	low := (aggregatesVMQuery.PageNo - 1) * aggregatesVMQuery.PageSize
// 	high := (aggregatesVMQuery.PageNo) * aggregatesVMQuery.PageSize
// 	if high > len(aggregatesVmDataList) {
// 		high = len(aggregatesVmDataList)
// 	}

// 	listPageResult.DataList = aggregatesVmDataList[low:high]
// 	listPageResult.TotalCount = len(aggregatesVmDataList)
// 	listPageResult.PageNo = aggregatesVMQuery.PageNo
// 	listPageResult.PageSize = aggregatesVMQuery.PageSize
// 	return listPageResult, err

// }

// //从总的云资源列表中进行分页获取数据
// func (h *Handler) getPhysicalHostResoursList(aggregatesVMQuery PhysicalHostResourceQuery) (AggregatesVms, error) {
// 	res := []AggregatesVm{}
// 	//对查询结果进行分页
// 	listPageResult := AggregatesVms{}
// 	page, err := aggregates.List(h.novaclient).AllPages()
// 	if err != nil {
// 		//api.HandleInternalError(response, err)
// 		return listPageResult, err
// 	}
// 	aggs, err := aggregates.ExtractAggregates(page)
// 	if err != nil {
// 		//api.HandleInternalError(response, err)
// 		return listPageResult, err
// 	}
// 	aggregate := ""
// 	az := ""
// 	for _, agg := range aggs {

// 		for i := range agg.Hosts {
// 			//通过服务器获取虚机
// 			fmt.Println(agg.Hosts[i])
// 			if agg.Hosts[i] == aggregatesVMQuery.ServerName {
// 				aggregate = agg.Name
// 				az = agg.AvailabilityZone
// 				break
// 			}
// 		}
// 	}
// 	region := service.DgraphService{
// 		Code:  "regionCodeAggregate",
// 		Value: h.apiServerConfig.RegionName,
// 	}
// 	//regionName := region.GetRegionByOurWay()
// 	azD := service.DgraphService{
// 		Code:  "azCodeAggregate",
// 		Value: az,
// 	}
// 	regionData := region.GetRegionByOurWay()

// 	azData := azD.GetAZByOurWay()
// 	///qd01-cp-compute177009026.qd01.ksyun.com
// 	aggregatesVmDataList, err := h.getHostInstance(aggregatesVMQuery.ServerName)
// 	for _, vm := range aggregatesVmDataList {
// 		fmt.Println(vm.Flavor["cluster"])
// 		vm := AggregatesVm{
// 			ID:         vm.ID,
// 			Name:       vm.Name,
// 			Flavor:     interfaceToValue(vm.Flavor["cluster"]) + "-" + interfaceToValue(vm.Flavor["vcpus"]) + "-" + interfaceToValue(vm.Flavor["ram"]) + "-" + interfaceToValue(vm.Flavor["storage_type"]) + "-" + interfaceToValue(vm.Flavor["disk"]),
// 			Status:     vm.Status,
// 			Aggregate:  aggregate,
// 			Region:     regionData.RegionName, //h.apiServerConfig.RegionName,
// 			RegionCode: regionData.RegionCode, //h.apiServerConfig.RegionName,
// 			Az:         azData.AZName,         //az,
// 			AzCode:     azData.AZCode,         //az,
// 			TenantId:   vm.TenantID,
// 			Hypervisor: vm.HostID,
// 			CreateTime: fmt.Sprintf("%d", vm.Created.Unix()),
// 			InnerIP:    "unknown",
// 			PublicIP:   "unknown",
// 		}
// 		res = append(res, vm)
// 	}

// 	low := (aggregatesVMQuery.PageNo - 1) * aggregatesVMQuery.PageSize
// 	high := (aggregatesVMQuery.PageNo) * aggregatesVMQuery.PageSize
// 	if high > len(res) {
// 		high = len(res)
// 	}

// 	listPageResult.DataList = res[low:high]
// 	listPageResult.TotalCount = len(res)
// 	listPageResult.PageNo = aggregatesVMQuery.PageNo
// 	listPageResult.PageSize = aggregatesVMQuery.PageSize
// 	return listPageResult, err

// }

// // //根据服务器name获取
// // func (h *Handler) getPhysicalAll(serverName string) ([]AggregatesVm, error) {
// // 	AggregatesData, err := h.getAggregateAll()
// // 	var aggregatesVmDataList []AggregatesVm
// // 	if AggregatesData.TotalCount > 0 {
// // 		for _, aggregate := range AggregatesData.DataList {
// // 			VmDataList, err := h.getAggregateVMsAll(strconv.Itoa(aggregate.Id))
// // 			if err != nil {
// // 				return aggregatesVmDataList, err
// // 			}
// // 			for _, data := range VmDataList {
// // 				//查询等于服务器name的云主机列表
// // 				if data.Name == serverName {
// // 					aggregatesVmDataList = append(aggregatesVmDataList, data)
// // 				}

// // 			}
// // 		}
// // 	}
// // 	return aggregatesVmDataList, err
// // }

// //根据区域，可用区，名称，id，所属租户id获取并分页
// func (h *Handler) getVMsList(vmListQuery VMListQuery) (AggregatesVms, error) {

// 	aggregatesVmDataList, err := h.getVMAll(vmListQuery)
// 	//对查询结果进行分页
// 	listPageResult := AggregatesVms{}

// 	low := (vmListQuery.PageNo - 1) * vmListQuery.PageSize
// 	high := (vmListQuery.PageNo) * vmListQuery.PageSize
// 	if high > len(aggregatesVmDataList) {
// 		high = len(aggregatesVmDataList)
// 	}

// 	listPageResult.DataList = aggregatesVmDataList[low:high]
// 	listPageResult.TotalCount = len(aggregatesVmDataList)
// 	listPageResult.PageNo = vmListQuery.PageNo
// 	listPageResult.PageSize = vmListQuery.PageSize
// 	return listPageResult, err

// }

// //根据区域，可用区，名称，id，所属租户id获取
// func (h *Handler) getVMAll(vmListQuery VMListQuery) ([]AggregatesVm, error) {
// 	AggregatesData, err := h.getAggregateAll()
// 	var aggregatesVmDataList []AggregatesVm
// 	if AggregatesData.TotalCount > 0 {
// 		for _, aggregate := range AggregatesData.DataList {
// 			VmDataList, err := h.getAggregateVMsAll(strconv.Itoa(aggregate.Id))
// 			if err != nil {
// 				return aggregatesVmDataList, err
// 			}
// 			for _, data := range VmDataList {
// 				//查询等于服务器name的云主机列表
// 				if (vmListQuery.Region == "all" || data.RegionCode == vmListQuery.Region) &&
// 					(vmListQuery.Az == "all" || data.AzCode == vmListQuery.Az) &&
// 					(vmListQuery.Name == "" || data.Name == vmListQuery.Name) &&
// 					(vmListQuery.Id == "" || data.ID == vmListQuery.Id) &&
// 					(vmListQuery.TenantId == "" || data.TenantId == vmListQuery.TenantId) {
// 					aggregatesVmDataList = append(aggregatesVmDataList, data)
// 				}

// 			}
// 		}
// 	}
// 	return aggregatesVmDataList, err
// }

// //获取云主机详情
// func (h *Handler) getVmDetails(vmQuery VMQuery) (VmDetail, error) {
// 	res := VmDetail{}
// 	InstancesData, err := h.getInstancesAll()
// 	if len(InstancesData) > 0 {
// 		region := service.DgraphService{
// 			Code:  "regionCodeAggregate",
// 			Value: h.apiServerConfig.RegionName,
// 		}
// 		//regionName := region.GetRegionByOurWay()
// 		az := service.DgraphService{
// 			Code:  "azCodeAggregate",
// 			Value: "",
// 		}
// 		regionData := region.GetRegionByOurWay()

// 		azData := az.GetAZByOurWay()
// 		for _, instances := range InstancesData {
// 			if len(instances.Server) > 0 {
// 				for _, instance := range instances.Server {
// 					if vmQuery.Id == "" || instance.ID == vmQuery.Id {
// 						az.Value = instances.Az
// 						res.Id = instance.ID
// 						res.TenantId = instance.TenantID
// 						res.Aggregate = instances.Aggregate
// 						res.Region = regionData.RegionName     //h.apiServerConfig.RegionName
// 						res.RegionCode = regionData.RegionCode //h.apiServerConfig.RegionName
// 						res.Az = azData.AZName
// 						res.AzCode = azData.AZCode
// 						res.Host = instance.HostID
// 						res.Business = "unknown"
// 						res.OpsLabel = "unknown"
// 						res.Label = instance.Tags
// 						res.ImageId = interfaceToValue(instance.Image["id"])
// 						res.DisasterTolerantGroup = instance.Fault.Details
// 						res.AdminPass = instance.AdminPass
// 						res.CreateTime = fmt.Sprintf("%d", instance.Created.Unix())
// 						res.EndTime = "unknown"
// 						res.DeleteTime = "unknown"
// 						res.Type = "unknown"
// 						res.Size = "unknown"
// 						res.Os = "unknown"
// 						res.SysDisk = "unknown"
// 						res.DataDisk = "unknown"
// 						res.INCId = "unknown"
// 						res.EIp = "unknown"
// 						res.DNS1 = "unknown"
// 						res.DNS2 = "unknown"
// 						res.InternetIpV4 = instance.AccessIPv4
// 						res.SecurityGroup = instance.SecurityGroups
// 						res.VPC = "unknown"
// 						res.SubNetwork = "unknown"
// 						res.InnerIp = "unknown"
// 						return res, err
// 					}
// 				}

// 			}

// 		}
// 	}
// 	return res, err

// }

// //获取所有的instance
// func (h *Handler) getInstancesAll() ([]VmFromNova, error) {
// 	allInstannces := []VmFromNova{}
// 	fmt.Println("true")
// 	page, err := aggregates.List(h.novaclient).AllPages()
// 	if err != nil {
// 		//api.HandleInternalError(response, err)
// 		return allInstannces, err
// 	}
// 	aggs, err := aggregates.ExtractAggregates(page)
// 	if err != nil {
// 		//api.HandleInternalError(response, err)
// 		return allInstannces, err
// 	}

// 	for _, agg := range aggs {

// 		for i := range agg.Hosts {
// 			//通过服务器获取虚机
// 			instances, err := h.getHostInstance(agg.Hosts[i])
// 			if err != nil {
// 				//api.HandleInternalError(response, err)
// 				return allInstannces, err
// 			}
// 			Vm := VmFromNova{
// 				Server:    instances,
// 				Az:        agg.AvailabilityZone,
// 				Aggregate: agg.Name,
// 			}
// 			allInstannces = append(allInstannces, Vm)
// 		}
// 	}
// 	return allInstannces, err
// 	//response.WriteEntity(res)
// }

// //根据区域，可用区，资源池 获取计算资源池或者云主机概览页面数据
// func (h *Handler) getOverviewData(overviewQuery OverviewQuery) (AggregateOverview, error) {
// 	AggregatesData, err := h.getAggregateAll()
// 	//var aggregatesVmDataList []AggregatesVm
// 	var aggregateOverview AggregateOverview
// 	aggregateOverview.InstanceOverview = make(map[string]int)
// 	aggregateOverview.ReasourcePoolOverview = make(map[string]int)
// 	aggregateOverview.VmOverview = make(map[string]int)
// 	instanceTotalCount := 0
// 	instanceRunningCount := 0
// 	instanceErrorCount := 0
// 	if AggregatesData.TotalCount > 0 {
// 		for _, aggregate := range AggregatesData.DataList {
// 			if overviewQuery.Id == "all" || strconv.Itoa(aggregate.Id) == overviewQuery.Id {
// 				VmDataList, err := h.getAggregateVMsAll(strconv.Itoa(aggregate.Id))
// 				if err != nil {
// 					return aggregateOverview, err
// 				}
// 				reasourcePoolVMCount := 0

// 				for _, data := range VmDataList {
// 					//查询等于服务器name的云主机列表
// 					if (overviewQuery.Region == "all" || data.RegionCode == overviewQuery.Region) &&
// 						(overviewQuery.Az == "all" || data.AzCode == overviewQuery.Az) {
// 						if vmCount, ok := aggregateOverview.VmOverview[data.Region+data.Az]; ok {
// 							aggregateOverview.VmOverview[data.Region+data.Az] = vmCount + 1
// 						} else {
// 							aggregateOverview.VmOverview[data.Region+data.Az] = 1
// 						}
// 						instanceTotalCount++
// 						if data.Status == "ACTIVE" {
// 							instanceRunningCount++
// 						} else {
// 							instanceErrorCount++
// 						}
// 						reasourcePoolVMCount++
// 						//aggregatesVmDataList = append(aggregatesVmDataList, data)
// 					}

// 				}
// 				aggregateOverview.ReasourcePoolOverview[aggregate.Name] = reasourcePoolVMCount
// 				aggregateOverview.InstanceOverview["总数量"] = instanceTotalCount
// 				aggregateOverview.InstanceOverview["运行中"] = instanceRunningCount
// 				aggregateOverview.InstanceOverview["故障"] = instanceErrorCount
// 			}
// 		}

// 	}
// 	return aggregateOverview, err
// }

// func interfaceToValue(value interface{}) string {
// 	res := ""
// 	switch value.(type) {
// 	case string:
// 		// 将interface转为string字符串类型
// 		op, ok := value.(string)
// 		if ok {
// 			res = op
// 		}
// 	case int32:
// 		// 将interface转为int32类型
// 		op, ok := value.(int32)
// 		if ok {
// 			res = string(op)
// 		}
// 	case int:
// 		// 将interface转为int32类型
// 		op, ok := value.(int)
// 		if ok {
// 			res = strconv.Itoa(op)
// 		}
// 	case int64:
// 		// 将interface转为int64类型
// 		op, ok := value.(int64)
// 		if ok {
// 			res = string(rune(op))
// 		}
// 	case float64:
// 		// 将interface转为int64类型
// 		op, ok := value.(float64)
// 		if ok {
// 			res = strconv.FormatFloat(op, 'f', 0, 64)
// 		}
// 	default:
// 		fmt.Println("unknown")
// 	}
// 	return res
// }

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/pkg/api/aggregate/result.go
```golang
package aggregate

type Result struct {
	Code    int         `json:"code"`
	Message string      `json:"message"`
	Data    interface{} `json:"data"`
}

// type PageStruct struct {
// 	TotalCount int `json:"totalCount"`
// 	PageNo     int `json:"pageNo"`
// 	PageSize   int `json:"pageSize"`
// }

// type AggregatesListQuery struct {
// 	PageNo   int `json:"pageNo"`
// 	PageSize int `json:"pageSize"`
// 	//Count    bool   `json:"count"`
// 	Region string `json:"region"`
// 	Az     string `json:"az"`
// 	Name   string `json:"name"`
// }

// type AggregatesUsageQuery struct {
// 	PageNo   int `json:"pageNo"`
// 	PageSize int `json:"pageSize"`
// 	//Count    bool   `json:"count"`
// 	Id string `json:"id"`
// }

// type PhysicalHostResourceQuery struct {
// 	PageNo   int `json:"pageNo"`
// 	PageSize int `json:"pageSize"`
// 	//Count    bool   `json:"count"`
// 	ServerName   string `json:"serverName"`
// 	Az           string `json:"az"`
// 	ResourcePool string `json:"resourcePool"`
// }

// type VMQuery struct {
// 	Id        string `json:"id"`
// 	Az        string `json:"az"`
// 	Aggregate string `json:"aggregate"`
// }

// type VMListQuery struct {
// 	PageNo   int `json:"pageNo"`
// 	PageSize int `json:"pageSize"`
// 	//Count    bool   `json:"count"`
// 	Region   string `json:"region"`
// 	Az       string `json:"az"`
// 	Name     string `json:"name"`
// 	Id       string `json:"id"`
// 	TenantId string `json:"tenantId"`
// }

// type AggregatesResult struct {
// 	PageStruct
// 	DataList []Aggregates `json:"dataList" description:"paging data"`
// 	//TotalCount int          `json:"total_count" description:"total count"`
// }

// type AggregatesUsageResult struct {
// 	PageStruct
// 	DataList []AggregatesUsage `json:"dataList"`
// }

// type Aggregates struct {
// 	Name       string `json:"name"`
// 	Id         int    `json:"id"`
// 	Service    string `json:"service"`
// 	Region     string `json:"region"`
// 	Az         string `json:"az"`
// 	RegionCode string `json:"regionCode"`
// 	AzCode     string `json:"azCode"`
// 	HostCount  int    `json:"hostCount"`
// 	VMCount    int    `json:"vmCount"`
// }

// type AggregatesVms struct {
// 	PageStruct
// 	DataList []AggregatesVm `json:"dataList" description:"paging data"`
// 	//TotalCount int            `json:"totalCount" description:"total count"`
// }

// type AggregatesVm struct {
// 	ID   string `json:"id"`
// 	Name string `json:"name"`
// 	//Flavor     interface{} `json:"flavor"`
// 	Flavor     string `json:"flavor"`
// 	Status     string `json:"status"`
// 	Aggregate  string `json:"aggregate"`
// 	Region     string `json:"region"`
// 	RegionCode string `json:"regionCode"`
// 	Az         string `json:"az"`
// 	AzCode     string `json:"azCode"`
// 	TenantId   string `json:"tenantId"`
// 	Hypervisor string `json:"hypervisor"`
// 	InnerIP    string `json:"innerIp"`
// 	PublicIP   string `json:"publicIp"`
// 	//CreateTime time.Time `json:"createTime"`
// 	CreateTime string `json:"createTime"`
// }

// type AggregatesHosts struct {
// 	DataList   []AggregatesHost `json:"dataList" description:"paging data"`
// 	PageStruct                  //int              `json:"totalCount" description:"total count"`
// }

// type AggregatesHost struct {
// 	Id               string `json:"id"`
// 	Name             string `json:"name"`
// 	Status           string `json:"status"`
// 	ResourcePoolType string `json:"resourcePoolType"`
// 	ResourcePool     string `json:"resourcePool"`
// 	Service          string `json:"service"`
// 	Region           string `json:"region"`
// 	Az               string `json:"az"`
// 	Room             string `json:"room"`
// 	Rack             string `json:"rack"`
// 	RackPosition     string `json:"rackPosition"`
// 	SN               string `json:"sn"`
// 	Ip               string `json:"ip"`
// }

// type AggregatesUsage struct {
// 	Name         string  `json:"name"`
// 	Region       string  `json:"region"`
// 	RegionCode   string  `json:"regionCode"`
// 	Az           string  `json:"az"`
// 	AzCode       string  `json:"azCode"`
// 	UsableCount  int     `json:"usableCount"`
// 	VCPUTotal    int     `json:"cpuTotal"`
// 	VCPUUsage    int     `json:"cpuUsage"`
// 	VCPURemain   int     `json:"cpuRemain"`
// 	VCPURate     float64 `json:"cpuRate"`
// 	MemoryTotal  int     `json:"memoryTotal"`
// 	MemoryUsage  int     `json:"memoryUsage"`
// 	MemoryRemain int     `json:"memoryRemain"`
// 	MemoryRate   float64 `json:"memoryRate"`
// }

// type VmDetail struct {
// 	Id                    string                   `json:"id"`
// 	TenantId              string                   `json:"tenantId"`
// 	Aggregate             string                   `json:"aggregate"`
// 	Region                string                   `json:"region"`
// 	RegionCode            string                   `json:"regionCode"`
// 	Az                    string                   `json:"az"`
// 	AzCode                string                   `json:"azCode"`
// 	Host                  string                   `json:"host"`
// 	Business              string                   `json:"business"`
// 	OpsLabel              string                   `json:"opsLabel"`
// 	Label                 *[]string                `json:"label"`
// 	ImageId               string                   `json:"imageId"`
// 	DisasterTolerantGroup string                   `json:"disasterTolerantGroup"`
// 	AdminPass             string                   `json:"adminPass"`
// 	CreateTime            string                   `json:"create_time"`
// 	EndTime               string                   `json:"endTime"`
// 	DeleteTime            string                   `json:"deleteTime"`
// 	Type                  string                   `json:"type"`
// 	Size                  string                   `json:"size"`
// 	Os                    string                   `json:"os"`
// 	SysDisk               string                   `json:"sys_disk"`
// 	DataDisk              string                   `json:"data_disk"`
// 	INCId                 string                   `json:"incId"`
// 	EIp                   string                   `json:"eIp"`
// 	DNS1                  string                   `json:"dns1"`
// 	DNS2                  string                   `json:"dns2"`
// 	InternetIpV4          string                   `json:"internetIpv4"`
// 	SecurityGroup         []map[string]interface{} `json:"securityGroup"`
// 	VPC                   string                   `json:"vpc"`
// 	SubNetwork            string                   `json:"subNetwork"`
// 	InnerIp               string                   `json:"innerIp"`
// }

// type VmFromNova struct {
// 	Server    []servers.Server `json:"server"`
// 	Aggregate string           `json:"aggregate"`
// 	Az        string           `json:"az"`
// }

// //计算资源池以及云主机概览页面struct
// type OverviewQuery struct {
// 	Region string `json:"region"`
// 	Az     string `json:"az"`
// 	Id     string `json:"id"`
// }
// type AggregateOverview struct {
// 	ReasourcePoolOverview map[string]int `json:"reasourcePoolOverview"`
// 	VmOverview            map[string]int `json:"vmOverview"`
// 	InstanceOverview      map[string]int `json:"instanceOverview"`
// }

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/pkg/api/nat/register.go
```golang
package nat

import (
	"luban-cmdb-api/pkg/models/nat"
	"luban-cmdb-api/pkg/runtime"
	natservice "luban-cmdb-api/pkg/service/nat"

	"github.com/emicklei/go-restful"
	restfulspec "github.com/emicklei/go-restful-openapi"
)

const APIGroup = "nat"

func AddToContainer(c *restful.Container) error {
	natTag := []string{"nat"}
	ws := runtime.NewWebService(APIGroup)
	natService := natservice.NewService()
	handler := NewHandler(natService)

	ws.Route(ws.GET("cloudProduct/natOverview").To(handler.getNatOverviewHandler).
		Doc("获取NAT概览").
		Metadata(restfulspec.KeyOpenAPITags, natTag).
		Param(ws.QueryParameter("region", "region")).
		Returns(200, "OK", nat.NatOverviewRsp{}))
	ws.Route(ws.GET("cloudProduct/natList/optionalCondition").To(handler.getListOptionalCondition).
		Doc("NAT资源列表可选条件").
		Metadata(restfulspec.KeyOpenAPITags, natTag).
		Reads("", "").
		Returns(200, "OK", nil))
	ws.Route(ws.POST("cloudProduct/natList").To(handler.getNatResourceListHandler).
		Doc("NAT资源列表").
		Metadata(restfulspec.KeyOpenAPITags, natTag).
		Reads(nat.GetNatResourceListReq{}, "region:region\n resourcePoolName:资源池名称\n natType:类型['public', 'private']\n scope:作用范围\n  searchType:搜索类型 (实例名称 instanceName)\nsearchValue：搜索值\nvpcNames: 所属VPC\n tenantIds:所属租户ID\n tenantNames:所属租户名称\n projectNames:所属项目\n OrderCode:排序字段 [createTime,bandwidth] \n OrderType:顺序[ascending,descending]").
		Returns(200, "OK", nat.GetNatResourceListRsp{}))
	ws.Route(ws.GET("cloudProduct/detail/{instanceId}").To(handler.getNatInfo).
		Doc("获取NAT详情").
		Metadata(restfulspec.KeyOpenAPITags, natTag).
		Param(ws.PathParameter("instanceId", "NAT实例id")).
		Returns(200, "OK", nat.NatInfo{}))
	ws.Route(ws.GET("cloudProduct/natipList/{instanceId}").To(handler.getNatipList).
		Doc("获取NAT IP列表").
		Metadata(restfulspec.KeyOpenAPITags, natTag).
		Param(ws.PathParameter("instanceId", "NAT实例id")).
		Param(ws.QueryParameter("pageNo", "")).
		Param(ws.QueryParameter("pageSize", "")).
		Returns(200, "OK", nat.NatPartListRsp{}))
	ws.Route(ws.GET("cloudProduct/snatList/{instanceId}").To(handler.getSnatipList).
		Doc("获取SNAT列表").
		Metadata(restfulspec.KeyOpenAPITags, natTag).
		Param(ws.PathParameter("instanceId", "NAT实例id")).
		Param(ws.QueryParameter("pageNo", "")).
		Param(ws.QueryParameter("pageSize", "")).
		Returns(200, "OK", nat.NatPartListRsp{}))
	ws.Route(ws.GET("cloudProduct/dnatList/{instanceId}").To(handler.getDnatipList).
		Doc("获取DNAT列表").
		Metadata(restfulspec.KeyOpenAPITags, natTag).
		Param(ws.PathParameter("instanceId", "NAT实例id")).
		Param(ws.QueryParameter("pageNo", "")).
		Param(ws.QueryParameter("pageSize", "")).
		Returns(200, "OK", nat.NatPartListRsp{}))
	ws.Route(ws.GET("cloudProduct/serveLimitList/{instanceId}").To(handler.getServeLimitList).
		Doc("获取服务器限速列表").
		Metadata(restfulspec.KeyOpenAPITags, natTag).
		Param(ws.PathParameter("instanceId", "NAT实例id")).
		Param(ws.QueryParameter("pageNo", "")).
		Param(ws.QueryParameter("pageSize", "")).
		Returns(200, "OK", nat.NatPartListRsp{}))

	c.Add(ws)
	return nil
}

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/pkg/api/nat/handler.go
```golang
package nat

import (
	"luban-cmdb-api/pkg/models"
	"luban-cmdb-api/pkg/models/nat"
	"strconv"

	"k8s.io/klog/v2"

	"github.com/emicklei/go-restful"
)

type NatService interface {
	GetNatOverview(region string) (nat.NatOverviewRsp, error)
	GetListOptionalCondition() (map[string][]interface{}, error)
	GetNatResourceList(params nat.GetNatResourceListReq) (nat.GetNatResourceListRsp, error)
	NatDetail(instanceId string) (nat.NatInfo, error)
	NatipList(instanceId string, req nat.NatPartListReq) (*nat.NatPartListRsp, error)
	SnatipList(instanceId string, req nat.NatPartListReq) (*nat.NatPartListRsp, error)
	DnatipList(instanceId string, req nat.NatPartListReq) (*nat.NatPartListRsp, error)
	ServeLimitList(instanceId string, req nat.NatPartListReq) (*nat.NatPartListRsp, error)
}

type Handler struct {
	svc NatService
}

func NewHandler(NatService NatService) *Handler {
	return &Handler{
		svc: NatService,
	}
}

func (h *Handler) getNatipList(request *restful.Request, response *restful.Response) {
	response.AddHeader(restful.HEADER_AccessControlAllowOrigin, "*")
	res := &models.CommonResult{
		Code:    200,
		Message: "success",
		Data:    nil,
	}
	instanceId := request.PathParameter("instanceId")
	pageNo, err := strconv.Atoi(request.QueryParameter("pageNo"))
	pageSize, err := strconv.Atoi(request.QueryParameter("pageSize"))

	if err != nil {
		res.Code = 500
		res.Message = "参数解析错误"
		response.WriteAsJson(res)
		return
	}

	params := nat.NatPartListReq{
		InstanceId: request.PathParameter("instanceId"),
		PageNo:     pageNo,
		PageSize:   pageSize,
	}

	detail, err := h.svc.NatipList(instanceId, params)
	if err != nil {
		res.Code = 500
		res.Message = err.Error()
		response.WriteAsJson(res)
		return
	}
	res.Code = 200
	res.Message = "success"
	res.Data = detail
	response.WriteAsJson(res)
}
func (h *Handler) getSnatipList(request *restful.Request, response *restful.Response) {
	response.AddHeader(restful.HEADER_AccessControlAllowOrigin, "*")
	res := &models.CommonResult{
		Code:    200,
		Message: "success",
		Data:    nil,
	}
	instanceId := request.PathParameter("instanceId")
	pageNo, err := strconv.Atoi(request.QueryParameter("pageNo"))
	pageSize, err := strconv.Atoi(request.QueryParameter("pageSize"))

	if err != nil {
		res.Code = 500
		res.Message = "参数解析错误"
		response.WriteAsJson(res)
		return
	}

	params := nat.NatPartListReq{
		InstanceId: request.PathParameter("instanceId"),
		PageNo:     pageNo,
		PageSize:   pageSize,
	}

	detail, err := h.svc.SnatipList(instanceId, params)
	if err != nil {
		res.Code = 500
		res.Message = err.Error()
		response.WriteAsJson(res)
		return
	}
	res.Code = 200
	res.Message = "success"
	res.Data = detail
	response.WriteAsJson(res)
}
func (h *Handler) getDnatipList(request *restful.Request, response *restful.Response) {
	response.AddHeader(restful.HEADER_AccessControlAllowOrigin, "*")
	res := &models.CommonResult{
		Code:    200,
		Message: "success",
		Data:    nil,
	}
	instanceId := request.PathParameter("instanceId")
	pageNo, err := strconv.Atoi(request.QueryParameter("pageNo"))
	pageSize, err := strconv.Atoi(request.QueryParameter("pageSize"))

	if err != nil {
		res.Code = 500
		res.Message = "参数解析错误"
		response.WriteAsJson(res)
		return
	}

	params := nat.NatPartListReq{
		InstanceId: request.PathParameter("instanceId"),
		PageNo:     pageNo,
		PageSize:   pageSize,
	}

	detail, err := h.svc.DnatipList(instanceId, params)
	if err != nil {
		res.Code = 500
		res.Message = err.Error()
		response.WriteAsJson(res)
		return
	}
	res.Code = 200
	res.Message = "success"
	res.Data = detail
	response.WriteAsJson(res)
}
func (h *Handler) getServeLimitList(request *restful.Request, response *restful.Response) {
	response.AddHeader(restful.HEADER_AccessControlAllowOrigin, "*")
	res := &models.CommonResult{
		Code:    200,
		Message: "success",
		Data:    nil,
	}
	var err error
	instanceId := request.PathParameter("instanceId")
	pageNo, err := strconv.Atoi(request.QueryParameter("pageNo"))
	pageSize, err := strconv.Atoi(request.QueryParameter("pageSize"))

	var egressType int
	paramEgressType := request.QueryParameter("egressType")
	if paramEgressType != "" {
		egressType, err = strconv.Atoi(paramEgressType)
	}

	if err != nil {
		klog.Error(err)
		res.Code = 500
		res.Message = "参数解析错误"
		response.WriteAsJson(res)
		return
	}

	params := nat.NatPartListReq{
		InstanceId: request.PathParameter("instanceId"),
		PageNo:     pageNo,
		PageSize:   pageSize,
		EgressType: &egressType,
	}

	detail, err := h.svc.ServeLimitList(instanceId, params)
	if err != nil {
		res.Code = 500
		res.Message = err.Error()
		response.WriteAsJson(res)
		return
	}
	res.Code = 200
	res.Message = "success"
	res.Data = detail
	response.WriteAsJson(res)
}

func (h *Handler) getNatInfo(request *restful.Request, response *restful.Response) {
	response.AddHeader(restful.HEADER_AccessControlAllowOrigin, "*")
	res := &models.CommonResult{
		Code:    200,
		Message: "success",
		Data:    nil,
	}
	instanceId := request.PathParameter("instanceId")

	detail, err := h.svc.NatDetail(instanceId)
	if err != nil {
		res.Code = 500
		res.Message = err.Error()
		response.WriteAsJson(res)
		return
	}
	res.Code = 200
	res.Message = "success"
	res.Data = detail
	response.WriteAsJson(res)
}

func (h *Handler) getNatOverviewHandler(req *restful.Request, resp *restful.Response) {
	resp.AddHeader(restful.HEADER_AccessControlAllowOrigin, "*")
	res := &models.CommonResult{
		Code:    200,
		Message: "success",
		Data:    nil,
	}
	region := req.QueryParameter("region")
	overview, err := h.svc.GetNatOverview(region)
	if err != nil {
		res.Code = 500
		res.Message = err.Error()
		resp.WriteAsJson(res)
		return
	}
	res.Data = overview
	resp.WriteAsJson(res)
}

func (h *Handler) getListOptionalCondition(req *restful.Request, resp *restful.Response) {
	resp.AddHeader(restful.HEADER_AccessControlAllowOrigin, "*")
	res := &models.CommonResult{
		Code:    200,
		Message: "success",
		Data:    nil,
	}
	data, err := h.svc.GetListOptionalCondition()
	if err != nil {
		res.Code = 500
		res.Message = err.Error()
		resp.WriteAsJson(res)
		return
	}
	res.Data = data
	resp.WriteAsJson(res)
}

func (h *Handler) getNatResourceListHandler(req *restful.Request, resp *restful.Response) {
	resp.AddHeader(restful.HEADER_AccessControlAllowOrigin, "*")
	res := &models.CommonResult{
		Code:    200,
		Message: "success",
		Data:    nil,
	}
	params := nat.GetNatResourceListReq{}
	err := req.ReadEntity(&params)
	if err != nil {
		res.Code = 500
		res.Message = "参数解析错误"
		resp.WriteAsJson(res)
		return
	}

	if params.OrderCode == "" {
		params.OrderCode = "createTime"
	}
	//if params.OrderCode != "createTime" && params.OrderCode != "bandwidth" {
	//	res.Code = 500
	//	res.Message = `暂时不支持以非 "createTime, bandwidth" 字段排序`
	//	resp.WriteAsJson(res)
	//	return
	//}
	if params.OrderType == "" || (params.OrderType != "ascending" && params.OrderType != "descending") {
		params.OrderCode = "descending"
	}

	if params.PageSize <= 0 {
		params.PageSize = 10
	}
	if params.PageNo < 1 {
		params.PageNo = 1
	}
	data, err := h.svc.GetNatResourceList(params)
	if err != nil {
		res.Code = 500
		res.Message = err.Error()
		resp.WriteAsJson(res)
		return
	}
	res.Data = data
	resp.WriteAsJson(res)
}

//print hello

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/pkg/api/lb/register.go
```golang
package lb

import (
	"luban-cmdb-api/pkg/models/lb"
	"luban-cmdb-api/pkg/runtime"
	lbservice "luban-cmdb-api/pkg/service/lb"

	"github.com/emicklei/go-restful"
	restfulspec "github.com/emicklei/go-restful-openapi"
)

const APIGroup = "lb"

func AddToContainer(c *restful.Container) error {
	lbTag := []string{"lb"}
	ws := runtime.NewWebService(APIGroup)
	lbService := lbservice.NewService()
	handler := NewHandler(lbService)

	ws.Route(ws.GET("cloudProduct/lbOverview").To(handler.getLbOverviewHandler).
		Doc("获取负载均衡概览").
		Metadata(restfulspec.KeyOpenAPITags, lbTag).
		Param(ws.QueryParameter("region", "region")).
		Returns(200, "OK", lb.LbOverviewRsp{}))
	ws.Route(ws.POST("cloudProduct/lbList").To(handler.getLbResourceListHandler).
		Doc("负载均衡LB资源列表").
		Metadata(restfulspec.KeyOpenAPITags, lbTag).
		Reads(lb.GetLbResourceListReq{}, "region:区域\nsearchType:搜索类型 (实例名称 instanceName/后端服务ID serverId/后端服务内网IP serverIp)\nsearchValue：搜索值\nresourcePoolName:资源池名称\nInstanceType:实例类型 ['default', 'application']  经典型， 应用型").
		Returns(200, "OK", lb.GetLbResourceListRsp{}))
	ws.Route(ws.GET("cloudProduct/lbList/optionalCondition").To(handler.getListOptionalCondition).
		Doc("负载均衡列表可选条件").
		Metadata(restfulspec.KeyOpenAPITags, lbTag).
		Reads("", "").
		Returns(200, "OK", nil))
	ws.Route(ws.GET("cloudProduct/detail/{instanceId}").To(handler.getLbInfo).
		Doc("获取LB详情").
		Metadata(restfulspec.KeyOpenAPITags, lbTag).
		Param(ws.PathParameter("instanceId", "LB实例id")).
		Returns(200, "OK", lb.LbInfo{}))
	ws.Route(ws.GET("cloudProduct/lbListenerList/{instanceId}").To(handler.getLbListenerList).
		Doc("获取LB 监听器列表").
		Metadata(restfulspec.KeyOpenAPITags, lbTag).
		Param(ws.PathParameter("instanceId", "LB实例id")).
		Param(ws.QueryParameter("pageNo", "")).
		Param(ws.QueryParameter("pageSize", "")).
		Returns(200, "OK", lb.LbPartListRsp{}))

	c.Add(ws)
	return nil
}

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/pkg/api/lb/handler.go
```golang
package lb

import (
	"luban-cmdb-api/pkg/models"
	"luban-cmdb-api/pkg/models/lb"
	"strconv"

	"github.com/emicklei/go-restful"
)

type LbService interface {
	GetLbOverview(req lb.LbOverviewReq) (lb.LbOverviewRsp, error)
	GetLbResourceList(params lb.GetLbResourceListReq) (lb.GetLbResourceListRsp, error)
	GetListOptionalCondition() (map[string][]interface{}, error)
	LbDetail(instanceId string) (lb.LbInfo, error)
	LbListenerList(instanceId string, req lb.LbPartListReq) (*lb.LbPartListRsp, error)
}

type Handler struct {
	svc LbService
}

func NewHandler(lbService LbService) *Handler {
	return &Handler{
		svc: lbService,
	}
}

func (h *Handler) getLbListenerList(request *restful.Request, response *restful.Response) {
	response.AddHeader(restful.HEADER_AccessControlAllowOrigin, "*")
	res := &models.CommonResult{
		Code:    200,
		Message: "success",
		Data:    nil,
	}
	instanceId := request.PathParameter("instanceId")
	pageNo, err := strconv.Atoi(request.QueryParameter("pageNo"))
	pageSize, err := strconv.Atoi(request.QueryParameter("pageSize"))

	if err != nil {
		res.Code = 500
		res.Message = "参数解析错误"
		response.WriteAsJson(res)
		return
	}

	params := lb.LbPartListReq{
		InstanceId: request.PathParameter("instanceId"),
		PageNo:     pageNo,
		PageSize:   pageSize,
	}

	detail, err := h.svc.LbListenerList(instanceId, params)
	if err != nil {
		res.Code = 500
		res.Message = err.Error()
		response.WriteAsJson(res)
		return
	}
	res.Code = 200
	res.Message = "success"
	res.Data = detail
	response.WriteAsJson(res)
}

func (h *Handler) getLbOverviewHandler(req *restful.Request, resp *restful.Response) {
	resp.AddHeader(restful.HEADER_AccessControlAllowOrigin, "*")
	res := &models.CommonResult{
		Code:    200,
		Message: "success",
		Data:    nil,
	}
	region := req.QueryParameter("region")
	params := lb.LbOverviewReq{
		Region: region,
	}
	overview, err := h.svc.GetLbOverview(params)
	if err != nil {
		res.Code = 500
		res.Message = err.Error()
		resp.WriteAsJson(res)
		return
	}
	res.Data = overview
	resp.WriteAsJson(res)
}

func (h *Handler) getLbResourceListHandler(req *restful.Request, resp *restful.Response) {
	resp.AddHeader(restful.HEADER_AccessControlAllowOrigin, "*")
	res := &models.CommonResult{
		Code:    200,
		Message: "success",
		Data:    nil,
	}
	params := lb.GetLbResourceListReq{}
	err := req.ReadEntity(&params)
	if err != nil {
		res.Code = 500
		res.Message = "参数解析错误"
		resp.WriteAsJson(res)
		return
	}
	if params.PageSize <= 0 {
		params.PageSize = 10
	}
	if params.PageNo < 1 {
		params.PageNo = 1
	}
	data, err := h.svc.GetLbResourceList(params)
	if err != nil {
		res.Code = 500
		res.Message = err.Error()
		resp.WriteAsJson(res)
		return
	}
	res.Data = data
	resp.WriteAsJson(res)
}

func (h *Handler) getListOptionalCondition(req *restful.Request, resp *restful.Response) {
	resp.AddHeader(restful.HEADER_AccessControlAllowOrigin, "*")
	res := &models.CommonResult{
		Code:    200,
		Message: "success",
		Data:    nil,
	}
	data, err := h.svc.GetListOptionalCondition()
	if err != nil {
		res.Code = 500
		res.Message = err.Error()
		resp.WriteAsJson(res)
		return
	}
	res.Data = data
	resp.WriteAsJson(res)
}

func (h *Handler) getLbInfo(request *restful.Request, response *restful.Response) {
	response.AddHeader(restful.HEADER_AccessControlAllowOrigin, "*")
	res := &models.CommonResult{
		Code:    200,
		Message: "success",
		Data:    nil,
	}
	instanceId := request.PathParameter("instanceId")
	detail, err := h.svc.LbDetail(instanceId)
	if err != nil {
		res.Code = 500
		res.Message = err.Error()
		response.WriteAsJson(res)
		return
	}
	res.Code = 200
	res.Message = "success"
	res.Data = detail
	response.WriteAsJson(res)
}

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/pkg/api/cabinet/register.go
```golang
package cabinet

import (
	"github.com/dgraph-io/dgo/v200"
	"github.com/emicklei/go-restful"
	restfulspec "github.com/emicklei/go-restful-openapi"
	"luban-cmdb-api/pkg/models/cabinet"
	"luban-cmdb-api/pkg/runtime"
	"luban-cmdb-api/pkg/service"
)

const APIGroup = "cabinet"

func AddToContainer(c *restful.Container, dgraphclient *dgo.Dgraph) error {
	ws := runtime.NewWebService(APIGroup)
	cabinetTag := []string{"cabinet"}
	labService := service.NewLabService(dgraphclient)
	basicService := service.NewBasicService(dgraphclient, nil)
	//cabinetService := service.NewCabinetService(dgraphclient, labService, basicService)
	cabinetService := service.NewCabinetService( labService, basicService)
	handler := NewHandler(cabinetService)
	ws.Route(ws.POST("/list").To(handler.getCabinetList).
		Doc("获取机柜列表").
		Metadata(restfulspec.KeyOpenAPITags, cabinetTag).
		Reads(cabinet.QueryCabinetParam{}, cabinet.GetCabinetListDoc).
		Returns(200, "OK", cabinet.CabinetListResponse{}))
	ws.Route(ws.GET("detail/{id}").To(handler.getCabinetInfo).
		Doc("获取机柜信息").
		Metadata(restfulspec.KeyOpenAPITags, cabinetTag).
		Param(ws.PathParameter("id", "显示机柜详情")).
		Returns(200, "OK", cabinet.CabinetInfo{}))
	ws.Route(ws.POST("cabinetInfo").To(handler.createCabinetInfo).
		Doc("新增机柜").
		Metadata(restfulspec.KeyOpenAPITags, cabinetTag).
		Reads(cabinet.CabinetParam{}, cabinet.OpCabinetDoc).
		Returns(200, "ok", nil))
	ws.Route(ws.DELETE("cabinetInfo").To(handler.deleteCabinetInfo).
		Doc("删除机柜").
		Metadata(restfulspec.KeyOpenAPITags, cabinetTag).
		Reads(cabinet.DeleteCabinetParam{}, cabinet.DeleteCabinetDoc).
		Returns(200, "OK", nil))
	ws.Route(ws.PATCH("cabinetInfo").To(handler.UpdateCabinetInfo).
		Doc("修改机柜信息").
		Metadata(restfulspec.KeyOpenAPITags, cabinetTag).
		Reads(cabinet.CabinetParam{}, cabinet.OpCabinetDoc).
		Returns(200, "OK", nil))
	c.Add(ws)

	return nil
}

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/pkg/api/cabinet/handler.go
```golang
package cabinet

import (
	"luban-cmdb-api/pkg/models/cabinet"
	"strconv"

	"github.com/emicklei/go-restful"
)

type CabinetService interface {
	GetCabinetList(params cabinet.QueryCabinetParam) (cabinet.CabinetListResponse, error)
	CreateCabinet(params cabinet.CabinetParam, userName string) error
	DeleteCabinets(params cabinet.DeleteCabinetParam) error
	//CabinetDetail(id string) (cabinet.CabinetInfo, error)
	CabinetDetail(id int) (cabinet.CabinetInfo, error)
	UpdateCabinet(params cabinet.CabinetParam) error
}

type Handler struct {
	svc CabinetService
}

func NewHandler(service CabinetService) *Handler {
	return &Handler{
		svc: service,
	}
}

func (h *Handler) getCabinetList(request *restful.Request, response *restful.Response) {
	response.AddHeader(restful.HEADER_AccessControlAllowOrigin, "*")
	res := new(Result)
	params := cabinet.QueryCabinetParam{}
	error := request.ReadEntity(&params)
	if error != nil {
		res.Code = 500
		res.Message = error.Error()
		response.WriteAsJson(res)
		return
	}
	cabinetEmpy := cabinet.CabinetListResponse{
		TotalCount: 0,
		PageNo:     1,
		PageSize:   params.PageSize,
		DataList:   []cabinet.CabinetInfo{},
	}

	cabinetList, err := h.svc.GetCabinetList(params)
	if err == nil {
		cabinetEmpy = cabinetList
		// res.Code = 500
		// res.Message = err.Error()
		// response.WriteAsJson(res)
		// return
	}
	res.Code = 200
	res.Message = "success"
	res.Data = cabinetEmpy
	response.WriteAsJson(res)

}

func (h *Handler) createCabinetInfo(request *restful.Request, response *restful.Response) {
	response.AddHeader(restful.HEADER_AccessControlAllowOrigin, "*")
	res := new(Result)
	params := cabinet.CabinetParam{}
	err := request.ReadEntity(&params)
	if err != nil {
		res.Code = 500
		res.Message = err.Error()
		response.WriteAsJson(res)
		return
	}
	//Authorization := request.HeaderParameter("Authorization")
	userName := request.HeaderParameter("x-auth-username")
	err = h.svc.CreateCabinet(params, userName)
	if err != nil {
		res.Code = 500
		res.Message = err.Error()
		response.WriteAsJson(res)
		return
	}
	res.Code = 200
	res.Message = "success"
	response.WriteAsJson(res)
	return

}

func (h *Handler) deleteCabinetInfo(request *restful.Request, response *restful.Response) {
	response.AddHeader(restful.HEADER_AccessControlAllowOrigin, "*")
	res := new(Result)
	params := cabinet.DeleteCabinetParam{}
	err := request.ReadEntity(&params)
	if err != nil {
		res.Code = 500
		res.Message = err.Error()
		response.WriteAsJson(res)
		return
	}
	err = h.svc.DeleteCabinets(params)
	if err != nil {
		res.Code = 500
		res.Message = err.Error()
		response.WriteAsJson(res)
		return
	}
	res.Code = 200
	res.Message = "success"
	response.WriteAsJson(res)
	return
}

func (h *Handler) getCabinetInfo(request *restful.Request, response *restful.Response) {
	response.AddHeader(restful.HEADER_AccessControlAllowOrigin, "*")
	res := new(Result)
	idStr := request.PathParameter("id")
	id, err := strconv.Atoi(idStr)
	if err != nil {
		res.Code = 500
		res.Message = err.Error()
		response.WriteAsJson(res)
		return
	}
	detail, err := h.svc.CabinetDetail(id)
	if err != nil {
		res.Code = 500
		res.Message = err.Error()
		response.WriteAsJson(res)
		return
	}
	res.Code = 200
	res.Message = "success"
	res.Data = detail
	response.WriteAsJson(res)
	return
}

func (h *Handler) UpdateCabinetInfo(request *restful.Request, response *restful.Response) {
	response.AddHeader(restful.HEADER_AccessControlAllowOrigin, "*")
	res := new(Result)
	params := cabinet.CabinetParam{}
	err := request.ReadEntity(&params)
	if err != nil {
		res.Code = 500
		res.Message = err.Error()
		response.WriteAsJson(res)
		return
	}
	// Authorization := request.HeaderParameter("Authorization")
	// if Authorization == "" {
	// 	res.Code = 500
	// 	res.Message = "Authorization does not exist"
	// 	response.WriteAsJson(res)
	// 	return
	// }
	// userName, err := service.GetUserName(Authorization)
	// if err != nil {
	// 	res.Code = 500
	// 	res.Message = "invalid Authorization. err: " + err.Error()
	// 	response.WriteAsJson(res)
	// 	return
	// }
	userName := request.HeaderParameter("x-auth-username")
	params.CabinetUpdater = userName
	err = h.svc.UpdateCabinet(params)
	if err != nil {
		res.Code = 500
		res.Message = err.Error()
		response.WriteAsJson(res)
		return
	}
	res.Code = 200
	res.Message = "success"
	response.WriteAsJson(res)
}

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/pkg/api/cabinet/result.go
```golang
package cabinet

type Result struct {
	Code    int         `json:"code"`
	Message string      `json:"message"`
	Data    interface{} `json:"data"`
}

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/pkg/api/lab/register.go
```golang
package lab

import (
	"github.com/dgraph-io/dgo/v200"
	"github.com/emicklei/go-restful"
	restfulspec "github.com/emicklei/go-restful-openapi"
	"luban-cmdb-api/pkg/models/lab"
	"luban-cmdb-api/pkg/runtime"
	"luban-cmdb-api/pkg/service"
)

const APIGroup = "lab"

func AddToContainer(c *restful.Container, dgraphclient *dgo.Dgraph) error {
	labTag := []string{"lab"}
	ws := runtime.NewWebService(APIGroup)
	labService := service.NewLabService(dgraphclient)
	handler := NewHandler(labService)
	ws.Route(ws.POST("/list").To(handler.getLabList).
		Doc("获取机房列表").
		Metadata(restfulspec.KeyOpenAPITags, labTag).
		Reads(lab.LabQueryParams{}, lab.LabQueryParamsDoc).
		// Param(ws.QueryParameter("pageSize", "pageSize").DataType("string").Required(true)).
		// Param(ws.QueryParameter("pageNo", "pageNo").DataType("string").Required(true)).
		// Param(ws.QueryParameter("regionCode", "regionCode").DataType("string").Required(true).Description("若全选请返回all")).
		// Param(ws.QueryParameter("azCode", "azCode").DataType("string").Required(true).Description("若全选请返回all")).
		// Param(ws.QueryParameter("searchType", "搜索的类型（ID、labName、labCode、serviceProvider）").DataType("string").Required(true)).
		// Param(ws.QueryParameter("searchValue", "搜索值").DataType("string").Required(true)).
		Returns(200, "OK", lab.LabListResponse{}))
	ws.Route(ws.GET("detail/{id}").To(handler.getLabInfo).
		Doc("获取机房信息").
		Metadata(restfulspec.KeyOpenAPITags, labTag).
		Param(ws.PathParameter("id", "显示机房详情")).
		Returns(200, "OK", lab.LabInfo{}))
	ws.Route(ws.POST("labInfo").To(handler.createLabInfo).
		Doc("新增机房").
		Metadata(restfulspec.KeyOpenAPITags, labTag).
		Reads(lab.CreateLabQuery{}, lab.CreateLabQueryDoc).
		Returns(200, "ok", nil))
	ws.Route(ws.DELETE("labInfo").To(handler.deleteLabInfo).
		Doc("删除机房").
		Metadata(restfulspec.KeyOpenAPITags, labTag).
		Reads(lab.DeleteParams{}, lab.DeleteLabDoc).
		Returns(200, "OK", nil))
	ws.Route(ws.PATCH("labInfo").To(handler.UpdateLabInfo).
		Doc("修改机房信息").
		Metadata(restfulspec.KeyOpenAPITags, labTag).
		Reads(lab.UpdateParams{}, lab.UpdateLabDoc).
		Returns(200, "OK", nil))
	c.Add(ws)
	return nil
}

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/pkg/api/lab/handler.go
```golang
package lab

import (
	"luban-cmdb-api/pkg/models/lab"
	"strconv"

	"github.com/emicklei/go-restful"
	"k8s.io/klog/v2"
)

type LabService interface {
	GetLabList(params lab.LabQueryParams) (lab.LabListResponse, error)
	CreateLab(params lab.CreateLabQuery, userName string) error
	DeleteLabs(params lab.DeleteParams, userName string) (msg string, err error)
	LabDetail(id int) (lab.LabInfo, error)
	UpdateLab(params lab.UpdateParams, userName string) error
}

type Handler struct {
	svc LabService
}

func NewHandler(service LabService) *Handler {
	return &Handler{
		svc: service,
	}
}

func (h *Handler) getLabList(request *restful.Request, response *restful.Response) {
	response.AddHeader(restful.HEADER_AccessControlAllowOrigin, "*")
	res := new(Result)
	responseData := lab.LabListResponse{
		TotalCount: 0,
		DataList:   []lab.LabInfo{},
	}
	t := new(lab.LabQueryParams)
	err := request.ReadEntity(&t)
	if err != nil {
		res.Code = 500
		res.Message = err.Error()
		response.WriteAsJson(res)
		return
	}
	// pageSizeStr := request.QueryParameter("pageSize")
	// pageSize, err := strconv.Atoi(pageSizeStr)
	if t.PageSize <= 0 {
		res.Code = 500
		if err != nil {
			res.Message = err.Error()
		} else {
			res.Message = "pageSize less than 0"
		}
		response.WriteAsJson(res)
		return
	}

	// pageNoStr := request.QueryParameter("pageNo")
	// pageNo, err := strconv.Atoi(pageNoStr)
	if t.PageNo <= 0 {
		res.Code = 200
		res.Message = "success"
		res.Data = responseData
		response.WriteAsJson(res)
		return
	}

	labList, err := h.svc.GetLabList(*t)
	if err != nil {
		res.Code = 200
		res.Message = "success"
		res.Data = responseData
		response.WriteAsJson(res)
		return
	}
	res.Code = 200
	res.Message = "success"
	res.Data = labList
	response.WriteAsJson(res)
}

func (h *Handler) createLabInfo(request *restful.Request, response *restful.Response) {
	response.AddHeader(restful.HEADER_AccessControlAllowOrigin, "*")
	res := new(Result)
	params := lab.CreateLabQuery{}
	request.ReadEntity(&params)
	//Authorization := request.HeaderParameter("Authorization")
	userName := request.HeaderParameter("x-auth-username")
	klog.Infof("%#v", request.Request.Header)
	err := h.svc.CreateLab(params, userName)
	if err != nil {
		res.Code = 500
		res.Message = err.Error()
		response.WriteAsJson(res)
		return
	}
	res.Code = 200
	res.Message = "success"
	response.WriteAsJson(res)

}

func (h *Handler) deleteLabInfo(request *restful.Request, response *restful.Response) {
	response.AddHeader(restful.HEADER_AccessControlAllowOrigin, "*")
	res := new(Result)
	params := lab.DeleteParams{}
	err := request.ReadEntity(&params)
	if err != nil {
		res.Code = 500
		res.Message = err.Error()
		response.WriteAsJson(res)
		return
	}
	//Authorization := request.HeaderParameter("Authorization")
	userName := request.HeaderParameter("x-auth-username")
	msg, err := h.svc.DeleteLabs(params, userName)
	if err != nil {
		res.Code = 500
		res.Message = err.Error()
		response.WriteAsJson(res)
		return
	}
	res.Code = 200
	if msg == "" {
		res.Message = "删除成功"
	} else {
		res.Code = 500
		res.Message = msg
	}
	response.WriteAsJson(res)
}

func (h *Handler) getLabInfo(request *restful.Request, response *restful.Response) {
	response.AddHeader(restful.HEADER_AccessControlAllowOrigin, "*")
	res := new(Result)
	id := request.PathParameter("id")
	idInt, err := strconv.Atoi(id)
	if err != nil {
		res.Code = 500
		res.Message = err.Error()
		response.WriteAsJson(res)
		return
	}
	detail, err := h.svc.LabDetail(idInt)
	if err != nil {
		res.Code = 500
		res.Message = err.Error()
		response.WriteAsJson(res)
		return
	}
	res.Code = 200
	res.Message = "success"
	res.Data = detail
	response.WriteAsJson(res)
}

func (h *Handler) UpdateLabInfo(request *restful.Request, response *restful.Response) {
	response.AddHeader(restful.HEADER_AccessControlAllowOrigin, "*")
	res := new(Result)
	params := lab.UpdateParams{}
	err := request.ReadEntity(&params)
	if err != nil {
		res.Code = 500
		res.Message = err.Error()
		response.WriteAsJson(res)
		return
	}
	//Authorization := request.HeaderParameter("Authorization")
	userName := request.HeaderParameter("x-auth-username")
	err = h.svc.UpdateLab(params, userName)
	if err != nil {
		res.Code = 500
		res.Message = err.Error()
		response.WriteAsJson(res)
		return
	}
	res.Code = 200
	res.Message = "success"
	response.WriteAsJson(res)
}

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/pkg/api/lab/result.go
```golang
package lab

type Result struct {
	Code    int         `json:"code"`
	Message string      `json:"message"`
	Data    interface{} `json:"data"`
}


```

File path: /Users/mac/Desktop/woker_code/cmdb-api/pkg/api/networkPool/register.go
```golang
package networkPool

import (
	"github.com/emicklei/go-restful"
	restfulspec "github.com/emicklei/go-restful-openapi"
	"luban-cmdb-api/pkg/models/netPoolModel"
	"luban-cmdb-api/pkg/service/networkPool"

	"luban-cmdb-api/pkg/runtime"
)

const APIGroup = "networkPool"

func AddToContainer(c *restful.Container) error {

	tag1 := []string{"networkPool"}
	ws := runtime.NewWebService(APIGroup)
	svc := networkPool.NewService()
	handler := NewHandler(svc)
	//资源库存
	ws.Route(ws.POST("resourcePool/inventory").To(handler.getNetWorkPoolInventory).
		Doc("网络资源库存").
		Reads(netPoolModel.NetWorkInventoryQuery{}, netPoolModel.NetWorkInventoryQueryDoc).
		Metadata(restfulspec.KeyOpenAPITags, tag1).
		Returns(200, "ok", []netPoolModel.NetWorkInventory{}))

	//资源列表
	ws.Route(ws.POST("resourcePool/resourceList").To(handler.getNetWorkPoolResourceList).
		Doc("网络资源列表").
		Reads(netPoolModel.NetWorkResourceQuery{}, netPoolModel.NetWorkResourceQueryDoc).
		Metadata(restfulspec.KeyOpenAPITags, tag1).
		Returns(200, "ok", []netPoolModel.NetWorkResource{}))

	ws.Route(ws.GET("resourcePool/overview").To(handler.getNetWorkPoolOverview).
		Doc("网络资源池概览").
		Param(ws.QueryParameter("region", "region, 全部请传入空")).
		Metadata(restfulspec.KeyOpenAPITags, tag1).
		Returns(200, "ok", netPoolModel.NetworkPoolOverview{}))

	//资源详情
	ws.Route(ws.GET("resourcePool/resourceInfo").To(handler.getNetWorkPoolResourceInfo).
		Doc("网络资源详情").
		Param(ws.QueryParameter("regionCode", "region code, 详情页必传")).
		Param(ws.QueryParameter("poolName", "poolName, 网络资源池名称")).
		Metadata(restfulspec.KeyOpenAPITags, tag1).
		Returns(200, "ok", &netPoolModel.NetWorkResource{}))

	//资源类型
	ws.Route(ws.GET("resourcePool/poolType").To(handler.getNetWorkPoolType).
		Doc("网络资源池类型").
		Metadata(restfulspec.KeyOpenAPITags, tag1).
		Returns(200, "ok", []string{}))

	//资源服务器列表
	ws.Route(ws.POST("resourcePool/phsicalServers").To(handler.getNetWorkPoolPhsicalServers).
		Doc("网络资源服务器列表").
		Reads(netPoolModel.PhsicalServerQuery{}, netPoolModel.PhsicalServerQueryQueryDoc).
		Metadata(restfulspec.KeyOpenAPITags, tag1).
		Returns(200, "ok", netPoolModel.PhsicalServerList{}))

	// 根据资源池类型取服务器IP managementIP，这里调用的是 resourcePool/physicalServers,根据这个接口的要求，所以必传的一个参数是poolName
	ws.Route(ws.POST("resourcePool/getManagementIps").To(handler.getManagementIps).
		Doc("根据资源池类型获取服务器IP").
		Reads(netPoolModel.PhyIpListQuery{}, netPoolModel.PhysicalIpListQueryDoc).
		Metadata(restfulspec.KeyOpenAPITags, tag1).
		Returns(200, "ok", []string{}))

	c.Add(ws)
	return nil
}

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/pkg/api/networkPool/handler.go
```golang
package networkPool

import (
	"luban-cmdb-api/pkg/models"
	"luban-cmdb-api/pkg/models/netPoolModel"

	"github.com/emicklei/go-restful"
)

type NetworkPoolService interface {
	GetNetworkPoolResourceList(params netPoolModel.NetWorkResourceQuery) (netPoolModel.NetWorkList, error)
	GetNetworkPoolOverview(region string) (netPoolModel.NetworkPoolOverview, error)
	GetNetworkPoolResourceInfo(region, poolName string) (netPoolModel.NetWorkResource, error)
	GetNetWorkPoolType() []string
	GetNetWorkPoolInventory(netPoolModel.NetWorkInventoryQuery) (netPoolModel.InventoryList, int, error)
	GetNetWorkPoolPhsicalServers(query netPoolModel.PhsicalServerQuery) (result netPoolModel.PhsicalServerList, total int, err error)
	GetPoolManagementIps(param netPoolModel.PhyIpListQuery) ([]string, error)
}

type Handler struct {
	svc NetworkPoolService
}

func NewHandler(svc NetworkPoolService) *Handler {
	return &Handler{
		svc: svc,
	}
}

func (h *Handler) getNetWorkPoolResourceList(req *restful.Request, resp *restful.Response) {
	resp.AddHeader(restful.HEADER_AccessControlAllowOrigin, "*")
	result := &models.CommonResult{
		Code:    200,
		Message: "success",
		Data:    nil,
	}
	param := netPoolModel.NetWorkResourceQuery{}
	err := req.ReadEntity(&param)
	if err != nil {
		result.Code = 500
		result.Message = err.Error()
		resp.WriteAsJson(result)
		return
	}
	if param.PageNo == 0 {
		param.PageNo = 1
	}
	if param.PageSize == 0 {
		param.PageSize = 10
	}
	//PageSize == -1，返回全量
	if param.PageSize == -1 {
		param.PageNo = 0
		param.PageSize = 0
	}
	if param.OrderCode == "" {
		param.OrderCode = "createdAt"
	}
	if param.OrderCode != "createdAt" {
		result.Code = 500
		result.Message = `暂时不支持以非 "createdAt" 字段排序`
		resp.WriteAsJson(result)
		return
	}
	if param.OrderType == "" || (param.OrderType != "ascending" && param.OrderType != "descending") {
		param.OrderCode = "descending" //默认倒序
	}
	if param.ResourceType == "" {
		param.ResourceType = "LB"
	}
	data, err := h.svc.GetNetworkPoolResourceList(param)
	if err != nil {
		result.Code = 500
		result.Message = err.Error()
		resp.WriteAsJson(result)
		return
	}
	result.Data = data
	resp.WriteAsJson(result)
}

func (h *Handler) getNetWorkPoolResourceInfo(req *restful.Request, resp *restful.Response) {
	resp.AddHeader(restful.HEADER_AccessControlAllowOrigin, "*")
	res := &models.CommonResult{
		Code:    200,
		Message: "success",
		Data:    nil,
	}
	region := req.QueryParameter("regionCode")
	poolName := req.QueryParameter("poolName")
	if region == "" || poolName == "" {
		res.Code = 500
		res.Message = "regionCode 或 poolName 不可为空"
		resp.WriteAsJson(res)
		return
	}
	data, err := h.svc.GetNetworkPoolResourceInfo(region, poolName)
	if err != nil {
		res.Code = 500
		res.Message = err.Error()
		resp.WriteAsJson(res)
		return
	}
	res.Data = data
	resp.WriteAsJson(res)
}

func (h *Handler) getNetWorkPoolOverview(req *restful.Request, resp *restful.Response) {
	resp.AddHeader(restful.HEADER_AccessControlAllowOrigin, "*")
	region := req.QueryParameter("region")
	res := &models.CommonResult{
		Code:    200,
		Message: "success",
		Data:    nil,
	}
	data, err := h.svc.GetNetworkPoolOverview(region)
	if err != nil {
		res.Code = 500
		res.Message = err.Error()
		resp.WriteAsJson(res)
		return
	}
	res.Data = data
	resp.WriteAsJson(res)
}

func (h *Handler) getNetWorkPoolType(req *restful.Request, resp *restful.Response) {
	resp.AddHeader(restful.HEADER_AccessControlAllowOrigin, "*")
	res := &models.CommonResult{
		Code:    200,
		Message: "success",
		Data:    nil,
	}
	data := h.svc.GetNetWorkPoolType()
	res.Data = data
	_ = resp.WriteAsJson(res)
}

func (h *Handler) getNetWorkPoolInventory(req *restful.Request, resp *restful.Response) {
	resp.AddHeader(restful.HEADER_AccessControlAllowOrigin, "*")
	res := &models.CommonResult{
		Code:    200,
		Message: "success",
		Data:    nil,
	}
	param := netPoolModel.NetWorkInventoryQuery{}
	err := req.ReadEntity(&param)
	if err != nil {
		res.Code = 500
		res.Message = err.Error()
		resp.WriteAsJson(res)
		return
	}
	if param.PageNo == 0 {
		param.PageNo = 1
	}
	if param.PageSize == 0 {
		param.PageSize = 10
	}
	//PageSize == -1，返回全量
	if param.PageSize == -1 {
		param.PageNo = 0
		param.PageSize = 0
	}
	data, total, err := h.svc.GetNetWorkPoolInventory(param)
	if err != nil {
		res.Code = 500
		res.Message = err.Error()
		resp.WriteAsJson(res)
		return
	}
	result := DataResult{
		Result: data,
		Total:  total,
	}
	res.Data = result
	resp.WriteAsJson(res)
}

func (h *Handler) getNetWorkPoolPhsicalServers(req *restful.Request, resp *restful.Response) {
	resp.AddHeader(restful.HEADER_AccessControlAllowOrigin, "*")
	res := &models.CommonResult{
		Code:    200,
		Message: "success",
		Data:    nil,
	}
	param := netPoolModel.PhsicalServerQuery{}
	err := req.ReadEntity(&param)
	if err != nil {
		res.Code = 500
		res.Message = err.Error()
		resp.WriteAsJson(res)
		return
	}
	if param.PoolName == "" {
		res.Code = 500
		res.Message = "poolName 不可为空"
		resp.WriteAsJson(res)
		return
	}
	if param.PageNo == 0 {
		param.PageNo = 1
	}
	if param.PageSize == 0 {
		param.PageSize = 10
	}
	//PageSize == -1，返回全量
	if param.PageSize == -1 {
		param.PageNo = 0
		param.PageSize = 0
	}
	data, total, err := h.svc.GetNetWorkPoolPhsicalServers(param)
	if err != nil {
		res.Code = 500
		res.Message = err.Error()
		resp.WriteAsJson(res)
		return
	}
	result := DataResult{
		Result: data,
		Total:  total,
	}
	res.Data = result
	resp.WriteAsJson(res)
}

func (h *Handler) getManagementIps(req *restful.Request, resp *restful.Response) {
	resp.AddHeader(restful.HEADER_AccessControlAllowOrigin, "*")
	res := &models.CommonResult{
		Code:    200,
		Message: "success",
		Data:    nil,
	}
	param := netPoolModel.PhyIpListQuery{}
	err := req.ReadEntity(&param)

	data, err := h.svc.GetPoolManagementIps(param)
	if err != nil {
		res.Code = 500
		res.Message = err.Error()
		resp.WriteAsJson(res)
		return
	}
	res.Data = data
	_ = resp.WriteAsJson(res)

}

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/pkg/api/networkPool/result.go
```golang
package networkPool

type Statistics struct {
	Name    string      `json:"name"`
	Type    string      `json:"type"`
	Supply  string      `json:"supply"`
	Cnt     int         `json:"cnt"`
	Product interface{} `json:"product"`
}

type DataResult struct {
	Result interface{} `json:"result"`
	Total  int         `json:"total"`
}

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/pkg/api/server/register.go
```golang
package server

import (
	"luban-cmdb-api/pkg/models/hardware"
	"luban-cmdb-api/pkg/models/server"
	"luban-cmdb-api/pkg/runtime"
	"luban-cmdb-api/pkg/service"

	"github.com/dgraph-io/dgo/v200"
	"github.com/emicklei/go-restful"
	restfulspec "github.com/emicklei/go-restful-openapi"
)

const APIGroup = ""

func AddToContainer(c *restful.Container, dgraphclient *dgo.Dgraph) error {
	ws := runtime.NewWebService(APIGroup)
	//aggregateService := service.NewAggregateService(novaclient, identityClient, *config)
	serverService := service.NewServerService(dgraphclient)
	basicService := service.NewBasicService(dgraphclient, nil)
	rackService := service.NewRackService(dgraphclient, basicService)
	handler := NewHandler(dgraphclient, serverService, rackService)
	//服务器
	tag1 := []string{"physicalHost"}
	ws.Route(ws.POST("/physicalHost").To(handler.getPhysicalHost).
		Doc("获取所有服务器的实例。").
		Metadata(restfulspec.KeyOpenAPITags, tag1).
		Reads(server.PhysicalHostListQuery{}, server.PhysicalHostListQueryDoc).
		Returns(200, "ok", PhysicalHostDataResult{}))
	ws.Route(ws.POST("/getHostsByIpArray").To(handler.getHostsByIpArray).
		Doc("根据ips获取服务器的列表。").
		Metadata(restfulspec.KeyOpenAPITags, tag1).
		Param(ws.BodyParameter("ipArray", "服务器IP数组").DataType("[]array").Required(false)).
		Returns(200, "ok", PhysicalHostDataResult{}))
	ws.Route(ws.GET("/physicalHostDetail/{name}").To(handler.getPhysicalHostDetail).
		Doc("查询单个服务器的详情").
		Metadata(restfulspec.KeyOpenAPITags, tag1).
		Param(ws.PathParameter("name", "服务器的唯一name。").DataType("string").Required(true)).
		Returns(200, "ok", server.PhysicalHostDetail{}))
	ws.Route(ws.GET("/PhysicalHostDetailById/{id}").To(handler.getPhysicalHostDetailById).
		Doc("查询单个服务器的详情").
		Metadata(restfulspec.KeyOpenAPITags, tag1).
		Param(ws.PathParameter("id", "服务器的id").Required(true)).
		Returns(200, "ok", server.PhysicalHostDetail{}))
	ws.Route(ws.POST("/physicalHost/report").To(handler.reportPhysicalHost).
		Doc("上报服务器信息").
		Metadata(restfulspec.KeyOpenAPITags, tag1).
		Reads(server.ReportPhysicalHostEntity{}).
		Returns(200, "ok", PhysicalHostUpdate{}))
	ws.Route(ws.POST("/physicalHost/{instanceId}").To(handler.updatePhysicalHost).
		Doc("修改服务器的详情").
		Metadata(restfulspec.KeyOpenAPITags, tag1).
		Param(ws.PathParameter("instanceId", "服务器的唯一ID。").DataType("string").Required(true)).
		Param(ws.FormParameter("hostLabCode", "服务器所属机房Code").DataType("string")).
		Param(ws.FormParameter("hostRoomUid", "服务器所属房间uid").DataType("string")).
		Param(ws.FormParameter("hostCabinetUid", "服务器所属机柜uid").DataType("string")).
		Param(ws.FormParameter("hostRackUid", "服务器所属机架uid").DataType("string")).
		Param(ws.FormParameter("hostUnitNumber", "服务器所占U位数").DataType("string")).
		Param(ws.FormParameter("managementIP", "服务器管理IP").DataType("string")).
		Param(ws.FormParameter("outbandIP", "服务器带外IP").DataType("string")).
		Param(ws.FormParameter("assetsnumber", "服务器的固定资产编号").DataType("string")).
		Param(ws.FormParameter("maintenanceDue", "服务器的维保到期时间").DataType("string")).
		Param(ws.FormParameter("label", "服务器运维标签").DataType("string")).
		Param(ws.FormParameter("description", "服务器描述").DataType("string")).
		Returns(200, "ok", PhysicalHostUpdate{}))
	ws.Route(ws.GET("/getAllPhysicalHost").To(handler.getAllPhysicalHostListHandler).
		Doc("Get all data./获取所有物理资源管理服务器").
		Metadata(restfulspec.KeyOpenAPITags, tag1).
		Returns(200, "OK", []server.PhysicalHost{}))
	tagOverview := []string{"Overview"}
	ws.Route(ws.GET("/physicalHosOverview").To(handler.getPhysicalHostOverView).
		Doc("Get overview data./获取物理资源管理服务器概览").
		Metadata(restfulspec.KeyOpenAPITags, tagOverview).
		Param(ws.QueryParameter("regionCode", "regionCode").DataType("string")).
		Param(ws.QueryParameter("azCode", " azCode").DataType("string")).
		Param(ws.QueryParameter("lab", "机房;默认值：全部").DataType("string").Required(false).DefaultValue("全部")).
		Returns(200, "OK", server.HostOverview{}))
	ws.Route(ws.GET("/physicalHostHardware").To(handler.getPhysicalHostHardware).
		Doc("获取cmdb中存储的服务器硬件信息").
		Metadata(restfulspec.KeyOpenAPITags, tag1).
		Param(ws.QueryParameter("sn", "sn")).
		Returns(200, "OK", hardware.Hardware{}))
	c.Add(ws)

	return nil
}

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/pkg/api/server/handler.go
```golang
package server

import (
	"luban-cmdb-api/pkg/models/hardware"
	"net"
	"regexp"
	"strconv"
	"strings"

	"k8s.io/klog/v2"

	"luban-cmdb-api/pkg/models/rack"
	"luban-cmdb-api/pkg/models/server"
	"luban-cmdb-api/pkg/service"

	"github.com/dgraph-io/dgo/v200"
	"github.com/emicklei/go-restful"

	"luban-cmdb-api/pkg/dao/cabidao"
)

type ServerInterface interface {
	CheckHostExist(uid int) (int, error)
	//GetResourcePoolByHost(hostName, ip string) (storageType, resourcePool string)
	GetPhysicalHostList(physicalHostListQuery server.PhysicalHostListQuery) (server.PhysicalHostDataResult, error)
	GetPhysicalHostEntity(name string, id int) (detail server.PhysicalHostDetail, err error)
	UpdatePhysicalHost(serverEntityNew server.PhysicalHostUpdateEntity) (err error)
	GetPhysicalHostEntityBySn(sn string) (detail server.PhysicalServer, err error)
	ReportPhysicalHost(serverEntityNew server.ReportPhysicalHostEntity) (err error)
	GetHostListByips(hostListQuery server.HostListQuery) (server.PhysicalHostDataResult, error)
	GetPhysicalHostOverView(physicalHostListQuery server.PhysicalHostListQuery) (hostOverview server.HostOverview, err error)
	GetAllPhysicalHostList() (physicalServer []server.PhysicalHost, err error)
	GetPhysicalHostHardware(sn string) hardware.Hardware
}
type RackService interface {
	GetRackListByRackId(rackIdStart, hostUnitNumber int, rackStatus int) (rack.RackList, error)
	UpdateRack(rackInfoList []rack.RackEntity) (string, error)
}
type Handler struct {
	dgraphClient *dgo.Dgraph
	//AggregateInterface AggregateInterface
	ServerInterface ServerInterface
	RackService     RackService
}

func NewHandler(dgraphClient *dgo.Dgraph, service *service.ServerService, rackService RackService) *Handler {
	return &Handler{
		dgraphClient: dgraphClient,
		//AggregateInterface: aggregateService,
		ServerInterface: service,
		RackService:     rackService,
	}
}

func (h *Handler) getPhysicalHost(request *restful.Request, response *restful.Response) {
	response.AddHeader("Access-Control-Allow-Origin", "*")
	//request.Request.Header.Add("Content-Type", "application/json")
	rst := new(Result)
	t := new(server.PhysicalHostListQuery)
	request.ReadEntity(&t)
	physicalHostData := PhysicalHostDataResult{
		PageStruct: PageStruct{TotalCount: 0},
		DataList:   []server.PhysicalHostData{},
	}
	var IsLetter = regexp.MustCompile(`^[0-9A-Za-z]+$`).MatchString
	if t.Id != "" && !IsLetter(t.Id) {
		rst.Code = 200
		rst.Message = "success"
		rst.Data = physicalHostData
		response.WriteAsJson(rst)
		return
	}
	physicalHostDataResult, err := h.ServerInterface.GetPhysicalHostList(*t)
	if err != nil {
		rst.Code = 200
		rst.Message = "success"
		rst.Data = physicalHostData
		response.WriteAsJson(rst)
		return
	} else {
		rst.Code = 200
		rst.Message = "success"
		rst.Data = physicalHostDataResult
		response.WriteAsJson(rst)
		return
	}

}
func (h *Handler) getHostsByIpArray(request *restful.Request, response *restful.Response) {
	response.AddHeader("Access-Control-Allow-Origin", "*")
	rst := new(Result)
	t := new(server.HostListQuery)
	request.ReadEntity(t) //request.BodyParameter("ips")
	if len(t.IpArray) < 1 {
		rst.Code = 500
		rst.Message = `Please insert ipArray eg:{"ipArray":["2222","111"]}`
		response.WriteAsJson(rst)
		return
	}
	//fmt.Println("-----------------------", t)
	physicalHostDataResult, err := h.ServerInterface.GetHostListByips(*t)
	if err != nil {
		rst.Code = 500
		rst.Message = err.Error()
		response.WriteAsJson(rst)
		return
	} else {
		rst.Code = 200
		rst.Message = "success"
		rst.Data = physicalHostDataResult
		response.WriteAsJson(rst)
		return
	}

}
func (h *Handler) updatePhysicalHost(request *restful.Request, response *restful.Response) {
	response.AddHeader("Access-Control-Allow-Origin", "*")

	rst := new(Result)
	//fmt.Println("this is true method!!!")
	n := request.PathParameter("instanceId")
	if n == "" {
		rst.Code = 500
		rst.Message = "instanceId is nil, Invalid value!!!"
		response.WriteAsJson(rst)
		return
	}
	idInt, err := strconv.Atoi(n)
	if err != nil {
		rst.Code = 500
		rst.Message = "instanceId is err, Invalid value!!!"
		response.WriteAsJson(rst)
		return
	}
	count, err := h.ServerInterface.CheckHostExist(idInt)
	if err != nil {
		rst.Code = 500
		rst.Message = "instanceId is nil, Invalid value!!!"
		response.WriteAsJson(rst)
		return
	} else if count < 1 {
		rst.Code = 500
		rst.Message = "InstanceId is not exist,please provide a true instanceId!!!"
		response.WriteAsJson(rst)
		return
	}
	//checkHost := physicalHostDataResult.DataList[0]
	//var physicalHostUpdateResult PhysicalHostUpdate
	// ctx := context.Background()
	// txn := h.dgraphClient.NewTxn()
	//defer txn.Discard(ctx)
	t := new(server.PhysicalHostUpdateEntity)
	request.ReadEntity(t)
	t.Uid = idInt
	// if strings.Trim(t.ManagementIP, " ") == "" {
	// 	rst.Code = 500
	// 	rst.Message = "ManagementIP is blank,please write a true IP!!!"
	// 	response.WriteAsJson(rst)
	// 	return
	// }
	if strings.Trim(t.OutbandIP, " ") != "" {
		address := net.ParseIP(t.OutbandIP)
		if address == nil {
			rst.Code = 500
			rst.Message = "带外IP地址格式不正确"
			response.WriteAsJson(rst)
			return
		}
	}
	if t.Assetsnumber != "" {
		match, _ := regexp.MatchString(`^[0-9A-Za-z]+$`, t.Assetsnumber)
		if !match {
			rst.Code = 500
			rst.Message = "Assetsnumber is error,please write a true Assetsnumber!!!"
			response.WriteAsJson(rst)
			return
		} else if len([]rune(t.Assetsnumber)) > 8 {
			rst.Code = 500
			rst.Message = " The total length of Assetsnumber must be less than 8,please write a true Assetsnumber!!!"
			response.WriteAsJson(rst)
			return
		}
	}

	//校验u位是否满足机柜容量限制
	cabinet, err := cabidao.SelectCabinetById(t.HostCabinetUid)
	if err != nil {
		klog.Errorf("SelectCabinetById err %v", err)
	}
	cabinetCapacity := 0
	if cabinet != nil {
		cabinetCapacity = cabinet.CabinetCapacity
	}
	if t.HostUnitNumber <= 0 || t.HostUnitNumber > cabinetCapacity {
		rst.Code = 500
		rst.Message = " 所占机架位数必须大于等于0!!! 且满足机柜容量限制"
		response.WriteAsJson(rst)
		return
	}

	err = h.ServerInterface.UpdatePhysicalHost(*t)
	if err != nil {
		rst.Code = 500
		rst.Message = err.Error()
		response.WriteAsJson(rst)
		return
	}
	rst.Code = 200
	response.WriteAsJson(rst)

}

//上报服务器信息ReportPhysicalHost(serverEntityNew server.ReportPhysicalHostEntity)
func (h *Handler) reportPhysicalHost(request *restful.Request, response *restful.Response) {
	klog.Info("ReportPhysicalHost in handler")
	response.AddHeader("Access-Control-Allow-Origin", "*")
	rst := new(Result)
	var physicalHostUpdateResult PhysicalHostUpdate
	param := &server.ReportPhysicalHostEntity{}
	err := request.ReadEntity(param)
	if err != nil {
		klog.Errorf("json Unmarshal error : %s", err.Error())
		rst.Code = 500
		rst.Message = err.Error()
		response.WriteEntity(rst)
		return
	}
	err = h.ServerInterface.ReportPhysicalHost(*param)
	if err != nil {
		rst.Code = 500
		rst.Message = err.Error()
		response.WriteAsJson(rst)
		return
	} else {
		rst.Code = 200
		rst.Message = "success"
		physicalHostUpdateResult.ReturnIf = true
		rst.Data = physicalHostUpdateResult
		response.WriteAsJson(rst)
		return
	}
}

func (h *Handler) getPhysicalHostDetail(request *restful.Request, response *restful.Response) {

	response.AddHeader("Access-Control-Allow-Origin", "*")
	rst := new(Result)
	name := request.PathParameter("name")
	physicalHostDetailResult, err := h.ServerInterface.GetPhysicalHostEntity(name, 0)
	if err != nil {
		rst.Code = 500
		rst.Message = err.Error()
		response.WriteAsJson(rst)
		return
	} else {

		// if physicalHostDetailResult.DeviceRoomService != "" {
		// 	physicalHostDetailResult.AssignmentStatus = "assigned" //"已分配"
		// } else {
		// 	physicalHostDetailResult.AssignmentStatus = "unassigned" //"未分配"
		// }

		// if physicalHostDetailResult.InputMethod == "auto" {
		// 	physicalHostDetailResult.InputMethod = "自动"
		// } else {
		// 	physicalHostDetailResult.InputMethod = "手动"
		// }
		// storageType, resourcePool := h.ServerInterface.GetResourcePoolByHost(physicalHostDetailResult.Name, physicalHostDetailResult.ManagementIP)
		// physicalHostDetailResult.ResourcePoolType = storageType
		// physicalHostDetailResult.ResourcePool = resourcePool
		// ips := []string{physicalHostDetailResult.ManagementIP}
		// ser := service.GetServiceByIps(ips)
		// physicalHostDetailResult.Service = ser
		rst.Code = 200
		rst.Message = "success"
		rst.Data = physicalHostDetailResult
		response.WriteAsJson(rst)
		return
	}

}

func (h *Handler) getPhysicalHostDetailById(request *restful.Request, response *restful.Response) {

	response.AddHeader("Access-Control-Allow-Origin", "*")
	rst := new(Result)
	idStr := request.PathParameter("id")
	id, err := strconv.Atoi(idStr)
	if err != nil {
		rst.Code = 500
		rst.Message = err.Error()
		response.WriteAsJson(rst)
		return
	}
	physicalHostDetailResult, err := h.ServerInterface.GetPhysicalHostEntity("", id)
	if err != nil {
		rst.Code = 500
		rst.Message = err.Error()
		response.WriteAsJson(rst)
		return
	} else {
		rst.Code = 200
		rst.Message = "success"
		rst.Data = physicalHostDetailResult
		response.WriteAsJson(rst)
		return
	}

}

func (h *Handler) getPhysicalHostOverView(request *restful.Request, response *restful.Response) {
	response.AddHeader("Access-Control-Allow-Origin", "*")
	rst := new(Result)
	region := request.QueryParameter("regionCode")
	az := request.QueryParameter("azCode")
	lab := request.QueryParameter("lab")
	var physicalHostListQuery server.PhysicalHostListQuery
	physicalHostListQuery.PageNo = 0

	regionQ := []string{}
	if region != "" && region != "all" {
		regionQ = append(regionQ, region)
	}
	azQ := []string{}
	if az != "" && az != "all" {
		azQ = append(azQ, az)
	}
	labQ := []string{}
	if lab != "" && lab != "all" {
		labQ = append(labQ, lab)
	}
	physicalHostListQuery.Region = regionQ
	physicalHostListQuery.Az = azQ   //[]string{az}
	physicalHostListQuery.Lab = labQ //[]string{lab}

	physicalHostAll, err := h.ServerInterface.GetPhysicalHostOverView(physicalHostListQuery)
	if err != nil {
		rst.Code = 500
		rst.Message = err.Error()
		response.WriteAsJson(rst)
		return
	}

	rst.Code = 200
	rst.Message = "success"
	rst.Data = physicalHostAll
	response.WriteAsJson(rst)
	//return

}
func (h *Handler) getAllPhysicalHostListHandler(request *restful.Request, response *restful.Response) {
	response.AddHeader("Access-Control-Allow-Origin", "*")
	rst := new(Result)

	physicalHostAll, err := h.ServerInterface.GetAllPhysicalHostList()
	if err != nil {
		rst.Code = 500
		rst.Message = err.Error()
		response.WriteAsJson(rst)
		return
	}

	rst.Code = 200
	rst.Message = "success"
	rst.Data = physicalHostAll
	response.WriteAsJson(rst)
	//return

}

func (h *Handler) getPhysicalHostHardware(request *restful.Request, response *restful.Response) {
	response.AddHeader("Access-Control-Allow-Origin", "*")
	rst := new(Result)
	sn := request.QueryParameter("sn")
	if sn == "" {
		rst.Code = 500
		rst.Message = "sn nil"
		response.WriteAsJson(rst)
		return
	}
	hostHardware := h.ServerInterface.GetPhysicalHostHardware(sn)
	rst.Code = 200
	rst.Message = "success"
	rst.Data = hostHardware
	response.WriteAsJson(rst)
}

/*
"data":[
	{
		"regionName":"beijing"
		"az": [
			{
				"azName":"beijing-1"
			}
		]
	}
]

[
  {
	"regionCode": "cn-beijing-6",
    "regionName": "北京",
    "containAzs": [
      {
        "azCode": "cn-beijing-6a",
		"azName": "北京6a",
		"containLabs":[
			{
			"labCode": "lab-1",
		    "labName": "机房一"
			}
		]
      }
    ]
  }
]


{
  set{


            <0xafca5> <region> "北京一区" .
                <0xafca5> <runstatus> "运行中" .
                <0xafca5> <assignmentStatus> "未分配" .
                <0xafca5> <resourcePoolType> "计算资源池" .
                <0xafca5> <resourcePool> "资源池2" .
                <0xafca5> <service> "云主机" .
                <0xafca5> <az> "可用区B" .
                <0xafca5> <lab> "机房2" .
                <0xafca5> <cabinet> "YZ022FE-E02-07-8" .
                <0xafca5> <unit> "3" .
               <0xafca5> <managementIP> "10.1.1.1" .
                <0xafca5> <outbandIP> "10.1.1.1" .
                <0xafca5> <power> "16A/XXX" .
                <0xafca5> <uplinkSwitch> "交换机2" .
                <0xafca5> <maintenanceDue> "2021-03-03" .
                <0xafca5> <maintenanceStatus> "未过保" .
                <0xafca5> <assetsnumber> "010101002" .
                <0xafca5> <inputMethod> "手动" .
                <0xafca5> <description> "这是一个北京一区已经分配了资源池的服务器" .
                <0xafca5> <createTime> "2021-05-29T11:38:30.894Z" .

  }
}




{
  set{

    _:lab1 <labCode> "cn-beijing-lab1" .
    _:lab1 <labName> "机房1" .

    _:lab2 <labCode> "cn-beijing-lab2" .
    _:lab2 <labName> "机房2" .


    _:lab3 <labCode> "cn-beijing-lab3" .
    _:lab3 <labName> "机房3" .

    _:lab4 <labCode> "cn-shanghai-lab4" .
    _:lab4 <labName> "机房4" .

    _:lab5 <labCode> "cn-shanghai-lab1" .
    _:lab5 <labName> "机房1" .

    _:lab6 <labCode> "cn-shanghai-lab2" .
    _:lab6 <labName> "机房2" .
    _:lab7 <labCode> "cn-shanghai-lab3" .
	_:lab7 <labName> "机房3" .
	 _:lab8 <labCode> "cn-shanghai-lab4" .
    _:lab8 <labName> "机房4" .


     _:az1 <azCode> "cn-beijing-azA" .
	_:az1 <azName> "可用区A" .
	_:az1 <containLabs> _:lab1 .
	_:az1 <containLabs> _:lab2 .

    _:az2 <azCode> "cn-beijing-azB" .
	_:az2 <azName> "可用区B" .
	_:az2 <containLabs> _:lab3 .
	_:az2 <containLabs> _:lab4 .


    _:az3 <azCode> "cn-beijing-azA" .
	_:az3 <azName> "可用区A" .
	_:az3 <containLabs> _:lab5 .
	_:az3 <containLabs> _:lab6 .

    _:az4 <azCode> "cn-shanghai-azB" .
	_:az4 <azName> "可用区B" .
	_:az4 <containLabs> _:lab7 .
	_:az4 <containLabs> _:lab8 .


    _:region1 <regionCode> "cn-beijing-6" .
    _:region1 <regionName> "北京一区" .
    _:region1 <containAzs> _:az1 .
    _:region1 <containAzs> _:az2 .

    _:region2 <regionCode> "cn-beijing-6" .
    _:region2 <regionName> "上海一区" .
    _:region2 <containAzs> _:az3 .
    _:region2 <containAzs> _:az4 .

  }
}



{
        "region": "cn-beijing-6",
        "uid": "0xb69d8",
        "containAzs": [
          {
            "az": "cn-beijing-6b",
            "uid": "0xb69de",
            "containLabs": [
              {
                "uid": "0xb69da",
                "lab": "cn-beijing-lab3"
              },
              {
                "uid": "0xb69df",
                "lab": "cn-shanghai-lab4"
              }
            ]
          },
          {
            "az": "cn-beijing-6a",
            "uid": "0xb69e0",
            "containLabs": [
              {
                "uid": "0xb69d6",
                "lab": "cn-beijing-lab1"
              },
              {
                "uid": "0xb69d9",
                "lab": "cn-beijing-lab2"
              }
            ]
          }
        ]
      },
      {
        "region": "cn-shanghai-6",
        "uid": "0xb69e2",
        "containAzs": [
          {
            "az": "cn-shanghai-3b",
            "uid": "0xb69d5",
            "containLabs": [
              {
                "uid": "0xb69d7",
                "lab": "cn-shanghai-lab3"
              },
              {
                "uid": "0xb69dd",
                "lab": "cn-shanghai-lab4"
              }
            ]
          },
          {
            "az": "cn-shanghai-3a",
            "uid": "0xb69e1",
            "containLabs": [
              {
                "uid": "0xb69db",
                "lab": "cn-shanghai-lab1"
              },
              {
                "uid": "0xb69dc",
                "lab": "cn-shanghai-lab2"
              }
            ]
          }
		]




{
  set{

    _:rack1 <rackCode> "HZ01-01-CABINT01-01" .

    _:rack2 <rackCode> "HZ01-01-CABINT01-02" .


    _:rack3 <rackCode> "HZ01-01-CABINT02-01" .

    _:rack4 <rackCode> "HZ01-01-CABINT02-02" .

    _:rack5 <rackCode> "HZ01-01-CABINT01-01" .

    _:rack6 <rackCode> "HZ01-01-CABINT01-02" .
    _:rack7 <rackCode> "HZ01-01-CABINT02-01" .
	 _:rack8 <rackCode> "HZ01-01-CABINT02-02" .

	_:unit1 <unitCode> "1" .

    _:unit2 <unitCode> "2" .


    _:unit3 <unitCode> "1" .

    _:unit4 <unitCode> "2" .

    _:unit5 <unitCode> "1" .

    _:unit6 <unitCode> "2" .
    _:unit7 <unitCode> "1" .
	_:unit8 <unitCode> "2" .


     _:cabinet1 <cabinetCode> "cn-beijing-cabint01" .
	_:cabinet1 <cabinetName> "机柜1" .
	_:cabinet1 <containRacks> _:rack1 .
	_:cabinet1 <containRacks> _:rack2 .
	_:cabinet1 <containUnits> _:unit1 .
	_:cabinet1 <containUnits> _:unit2 .

    _:cabinet2 <cabinetCode> "cn-beijing-cabint02" .
	_:cabinet2 <cabinetName> "机柜2" .
	_:cabinet2 <containRacks> _:rack3 .
	_:cabinet2 <containRacks> _:rack4 .
	_:cabinet2 <containUnits> _:unit3 .
	_:cabinet2 <containUnits> _:unit4 .


    _:cabinet3 <cabinetCode> "cn-beijing-cabint01" .
	_:cabinet3 <cabinetName> "机柜1" .
	_:cabinet3 <containRacks> _:rack5 .
	_:cabinet3 <containRacks> _:rack6 .
	_:cabinet3 <containUnits> _:unit5 .
	_:cabinet3 <containUnits> _:unit6 .


    _:cabinet4 <cabinetCode> "cn-beijing-cabint02" .
	_:cabinet4 <cabinetName> "机柜2" .
	_:cabinet4 <containRacks> _:rack7 .
	_:cabinet4 <containRacks> _:rack8 .
	_:cabinet4 <containUnits> _:unit7 .
	_:cabinet4 <containUnits> _:unit8 .


    _:room1 <roomCode> "cn-beijing-room1" .
    _:room1 <roomName> "北京房间1" .
    _:room1 <containCabinets> _:cabinet1 .
    _:room1 <containCabinets> _:cabinet2 .

    _:room2 <roomCode> "cn-beijing-room1" .
    _:room2 <roomName> "上海房间1" .
    _:room2 <containCabinets> _:cabinet3 .
    _:room2 <containCabinets> _:cabinet4 .

  }
}
"dataList": [
      {
        "uid": "0xb69e5",
        "cabinetCode": "cn-beijing-cabint01"
      },
      {
        "uid": "0xb69e7",
        "cabinetCode": "cn-beijing-cabint01"
      },
      {
        "uid": "0xb69fc",
        "cabinetCode": "cn-beijing-cabint02"
      },
      {
        "uid": "0xb69fe",
        "cabinetCode": "cn-beijing-cabint02"
      }
    ]
"dataList": [
      {
        "uid": "0xb69e8",
        "rackCode": "HZ01-01-CABINT01-01"
      },
      {
        "uid": "0xb69f0",
        "rackCode": "HZ01-01-CABINT02-01"
      },
      {
        "uid": "0xb69f7",
        "rackCode": "HZ01-01-CABINT02-02"
      },
      {
        "uid": "0xb69f8",
        "rackCode": "HZ01-01-CABINT01-01"
      },
      {
        "uid": "0xb69ff",
        "rackCode": "HZ01-01-CABINT02-01"
      },
      {
        "uid": "0xb6a00",
        "rackCode": "HZ01-01-CABINT02-02"
      },
      {
        "uid": "0xb6a06",
        "rackCode": "HZ01-01-CABINT01-02"
      },
      {
        "uid": "0xb6a0a",
        "rackCode": "HZ01-01-CABINT01-02"
      }
    ]
"dataList": [
      {
        "uid": "0xb69e9",
        "unitCode": "1"
      },
      {
        "uid": "0xb69ea",
        "unitCode": "2"
      },
      {
        "uid": "0xb69eb",
        "unitCode": "1"
      },
      {
        "uid": "0xb69ec",
        "unitCode": "2"
      },
      {
        "uid": "0xb69f1",
        "unitCode": "2"
      },
      {
        "uid": "0xb69f9",
        "unitCode": "2"
      },
      {
        "uid": "0xb6a01",
        "unitCode": "1"
      },
      {
        "uid": "0xb6a02",
        "unitCode": "1"
      }
	]

	 "dataList": [
      {
        "uid": "0xb69ef",
        "roomName": "上海房间1"
      },
      {
        "uid": "0xb6a09",
        "roomName": "北京房间1"
      }
	]

{
set {
	<0xb69e5> <containRacks> <0xb69e8> .
	<0xb69e5> <containRacks> <0xb69f0> .
	<0xb69e5> <containUnits> <0xb69e9> .
	<0xb69e5> <containUnits> <0xb69ea> .

	<0xb69e7> <containRacks> <0xb69f7> .
	<0xb69e7> <containRacks> <0xb69f8> .
	<0xb69e7> <containUnits> <0xb69eb> .
	<0xb69e7> <containUnits> <0xb69ec> .

  <0xb69fc> <containRacks> <0xb69ff> .
	<0xb69fc> <containRacks> <0xb6a00> .
	<0xb69fc> <containUnits> <0xb69f1> .
	<0xb69fc> <containUnits> <0xb69f9> .

	<0xb69fe> <containRacks> <0xb6a06> .
	<0xb69fe> <containRacks> <0xb6a0a> .
	<0xb69fe> <containUnits> <0xb6a01> .
	<0xb69fe> <containUnits> <0xb6a02> .

	<0xb69ef> <containCabinets> <0xb69e5> .
	<0xb6a09> <containCabinets> <0xb69e7> .
  <0xb69ef> <containCabinets> <0xb69e7> .
	<0xb6a09> <containCabinets> <0xb69fe> .


}
}
{
                dataList(func:has(containCabinets))

                   {
                    uid
                    roomCode
                    roomName

                    containCabinets{
                      uid
											cabinetCode
                      cabinetName
                      containRacks{
                        uid
                        rackCode
                        roomName
                      }
                      containUnits{
                        uid
                        unitCode

                      }
                    }
                  }
        }

删除不掉
{
delete {
	<0xb69da> * * .
}
}





{
  "data": {
    "dataList": [
      {
        "uid": "0xb69ef",
        "roomCode": "cn-beijing-room1",
        "roomName": "上海房间1",
        "containCabinets": [
          {
            "uid": "0xb69e5",
            "cabinetCode": "cn-beijing-cabint01",
            "cabinetName": "机柜1",
            "containRacks": [
              {
                "uid": "0xb69e6"
              },
              {
                "uid": "0xb69e8",
                "rackCode": "HZ01-01-CABINT01-01"
              },
              {
                "uid": "0xb69f0",
                "rackCode": "HZ01-01-CABINT02-01"
              },
              {
                "uid": "0xb69f2"
              }
            ],
            "containUnits": [
              {
                "uid": "0xb69e9",
                "unitCode": "1"
              },
              {
                "uid": "0xb69ea",
                "unitCode": "2"
              },
              {
                "uid": "0xb6a03"
              },
              {
                "uid": "0xb6a0b"
              }
            ]
          },
          {
            "uid": "0xb69ed"
          },
          {
            "uid": "0xb69f6"
          },
          {
            "uid": "0xb69fc",
            "cabinetCode": "cn-beijing-cabint02",
            "cabinetName": "机柜2",
            "containRacks": [
              {
                "uid": "0xb69fa"
              },
              {
                "uid": "0xb69ff",
                "rackCode": "HZ01-01-CABINT02-01"
              },
              {
                "uid": "0xb6a00",
                "rackCode": "HZ01-01-CABINT02-02"
              },
              {
                "uid": "0xb6a0c"
              }
            ],
            "containUnits": [
              {
                "uid": "0xb69f1",
                "unitCode": "2"
              },
              {
                "uid": "0xb69f9",
                "unitCode": "2"
              },
              {
                "uid": "0xb69fb"
              },
              {
                "uid": "0xb6a07"
              }
            ]
          }
        ]
      },
      {
        "uid": "0xb6a09",
        "roomCode": "cn-beijing-room1",
        "roomName": "北京房间1",
        "containCabinets": [
          {
            "uid": "0xb69e7",
            "cabinetCode": "cn-beijing-cabint01",
            "cabinetName": "机柜1",
            "containRacks": [
              {
                "uid": "0xb69f4"
              },
              {
                "uid": "0xb69f7",
                "rackCode": "HZ01-01-CABINT02-02"
              },
              {
                "uid": "0xb69f8",
                "rackCode": "HZ01-01-CABINT01-01"
              },
              {
                "uid": "0xb6a08"
              }
            ],
            "containUnits": [
              {
                "uid": "0xb69eb",
                "unitCode": "1"
              },
              {
                "uid": "0xb69ec",
                "unitCode": "2"
              },
              {
                "uid": "0xb69f5"
              },
              {
                "uid": "0xb69fd"
              }
            ]
          },
          {
            "uid": "0xb69fe",
            "cabinetCode": "cn-beijing-cabint02",
            "cabinetName": "机柜2",
            "containRacks": [
              {
                "uid": "0xb69ee"
              },
              {
                "uid": "0xb69f3"
              },
              {
                "uid": "0xb6a06",
                "rackCode": "HZ01-01-CABINT01-02"
              },
              {
                "uid": "0xb6a0a",
                "rackCode": "HZ01-01-CABINT01-02"
              }
            ],
            "containUnits": [
              {
                "uid": "0xb69e4"
              },
              {
                "uid": "0xb6a01",
                "unitCode": "1"
              },
              {
                "uid": "0xb6a02",
                "unitCode": "1"
              },
              {
                "uid": "0xb6a04"
              }
            ]
          },
          {
            "uid": "0xb6a05"
          },
          {
            "uid": "0xb6a0d"
          }
        ]
      }
    ]
  },
  "extensions": {
    "server_latency": {
      "parsing_ns": 198008,
      "processing_ns": 2093704,
      "encoding_ns": 246334,
      "assign_timestamp_ns": 907803,
      "total_ns": 3595756
    },
    "txn": {
      "start_ts": 1803012
    },
    "metrics": {
      "num_uids": {
        "_total": 128,
        "cabinetCode": 8,
        "cabinetName": 8,
        "containCabinets": 2,
        "containRacks": 8,
        "containUnits": 8,
        "rackCode": 16,
        "roomCode": 2,
        "roomName": 18,
        "uid": 42,
        "unitCode": 16
      }
    }
  }
}


{
                dataList(func:has(containCabinets))

                   {
                    uid
                    roomCode
                    roomName

                    containCabinets{
                      uid
											cabinetCode
                      cabinetName
                      containRacks{
                        uid
                        rackCode
                        roomName
                      }
                      containUnits{
                        uid
                        unitCode

                      }
                    }
                  }
		}



		{
  "data": {
    "dataList": [
      {
        "regionName": "上海一区",
        "regionCode": "cn-beijing-6",
        "containAzs": [
          {
            "azName": "可用区A",
            "azCode": "cn-beijing-azA",
            "containLabs": [
              {
                "labName": "机房1",
                "labCode": "cn-shanghai-lab1"
              },
              {
                "labName": "机房2",
                "labCode": "cn-shanghai-lab2"
              }
            ]
          },
          {
            "azName": "可用区B",
            "azCode": "cn-shanghai-azB",
            "containLabs": [
              {
                "labName": "机房3",
                "labCode": "cn-shanghai-lab3"
              },
              {
                "labName": "机房4",
                "labCode": "cn-shanghai-lab4"
              }
            ]
          }
        ]
      },
      {
        "regionName": "北京一区",
        "regionCode": "cn-beijing-6",
        "containAzs": [
          {
            "azName": "可用区B",
            "azCode": "cn-beijing-azB",
            "containLabs": [
              {
                "labName": "机房3",
                "labCode": "cn-beijing-lab3"
              },
              {
                "labName": "机房4",
                "labCode": "cn-shanghai-lab4"
              }
            ]
          },
          {
            "azName": "可用区A",
            "azCode": "cn-beijing-azA",
            "containLabs": [
              {
                "labName": "机房1",
                "labCode": "cn-beijing-lab1"
              },
              {
                "labName": "机房2",
                "labCode": "cn-beijing-lab2"
              }
            ]
          }
        ]
      }
    ]
  },
  "extensions": {
    "server_latency": {
      "parsing_ns": 163396,
      "processing_ns": 2555205,
      "encoding_ns": 103895,
      "assign_timestamp_ns": 964815,
      "total_ns": 3914520
    },
    "txn": {
      "start_ts": 1803187
    },
    "metrics": {
      "num_uids": {
        "_total": 66,
        "azCode": 8,
        "azName": 8,
        "containAzs": 4,
        "containLabs": 8,
        "labCode": 15,
        "labName": 15,
        "regionCode": 4,
        "regionName": 4
      }
    }
  }
}


0xb69cd

0xb69c8



"data": {
    "dataList": [
      {
        "regionName": "上海一区",
        "regionCode": "cn-shanghai-5",
        "containAzs": [
          {
            "azName": "可用区A",
            "azCode": "cn-shanghai-azA",
            "containLabs": [
              {
                "labName": "机房1",
                "labCode": "cn-shanghai-lab1",
                "uid": "0xb69cd",
                "containRooms": [
                  {
                    "uid": "0xb69ef",
                    "roomCode": "cn-beijing-room1"
                  }
                ]
              },
              {
                "labName": "机房2",
                "labCode": "cn-shanghai-lab2",
                "uid": "0xb69cf"
              }
            ]
          },
          {
            "azName": "可用区B",
            "azCode": "cn-shanghai-azB",
            "containLabs": [
              {
                "labName": "机房3",
                "labCode": "cn-shanghai-lab3",
                "uid": "0xb69c6"
              },
              {
                "labName": "机房4",
                "labCode": "cn-shanghai-lab4",
                "uid": "0xb69c7"
              }
            ]
          }
        ]
      },
      {
        "regionName": "北京一区",
        "regionCode": "cn-beijing-6",
        "containAzs": [
          {
            "azName": "可用区B",
            "azCode": "cn-beijing-azB",
            "containLabs": [
              {
                "labName": "机房3",
                "labCode": "cn-beijing-lab3",
                "uid": "0xb69c5"
              },
              {
                "labName": "机房4",
                "labCode": "cn-beijing-lab4",
                "uid": "0xb69cc"
              }
            ]
          },
          {
            "azName": "可用区A",
            "azCode": "cn-beijing-azA",
            "containLabs": [
              {
                "labName": "机房1",
                "labCode": "cn-beijing-lab1",
                "uid": "0xb69c8",
                "containRooms": [
                  {
                    "uid": "0xb6a09",
                    "roomCode": "cn-beijing-room1"
                  }
                ]
              },
              {
                "labName": "机房2",
                "labCode": "cn-beijing-lab2",
                "uid": "0xb69c9"
              }
            ]
          }
        ]
      },
      {
        "containAzs": [
          {
            "az": "cn-beijing-6b",
            "containLabs": [
              {
                "uid": "0xb69df"
              }
            ]
          },
          {
            "az": "cn-beijing-6a",
            "containLabs": [
              {
                "uid": "0xb69d6"
              },
              {
                "uid": "0xb69d9"
              }
            ]
          }
        ]
      },
      {
        "containAzs": [
          {
            "az": "cn-shanghai-3b",
            "containLabs": [
              {
                "uid": "0xb69d7"
              },
              {
                "uid": "0xb69dd"
              }
            ]
          },
          {
            "az": "cn-shanghai-3a",
            "containLabs": [
              {
                "uid": "0xb69db"
              },
              {
                "uid": "0xb69dc"
              }
            ]
          }
        ]
      }
    ]
  },




*/

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/pkg/api/server/result.go
```golang
package server

import (
	"luban-cmdb-api/pkg/models/basic"
	"luban-cmdb-api/pkg/models/server"
)

type PhysicalHostDataResult struct {
	//nihao
	RequestId string `json:"requestId" description:"identifier of the user"`
	PageStruct
	DataList []server.PhysicalHostData `json:"dataList"`
}

type CpuMessage struct {
	// CpuType string `json:"cpuType"`
	// CpuCore int32  `json:"cpuCore"`
	// CpuRate string `json:"cpuRate"`
	CpuInfo string `json:"cpuInfo"`
}

type MemoryMessage struct {
	// MemoryType    string `json:"memoryType"`
	// TotalCapacity int64  `json:"totalCapacity"`
	Device string `json:"device"`
}

type DiskMessage struct {
	// DiskType      string `json:"diskType"`
	// TotalCapacity int64  `json:"totalCapacity"`
	// Count         int32  `json:"count"`
	Device string `json:"device"`
}

type RAIDMessage struct {
	// RaidType string `json:"raidType"`
	// Count    int32  `json:"count"`
	RaidInfo string `json:"raidInfo"`
}

type NetworkCardMessage struct {
	// NetworkCardType string `json:"networkCardType"`
	// Count           int32  `json:"count"`
	NetInfo string `json:"netInfo"`
}

type GPUMessage struct {
	GpuType  string `json:"gpuType"`
	Capacity int32  `json:"capacity"`
}

type BasicMessage struct {
	Name              string `json:"name"`
	Id                string `json:"uid"`
	Runstatus         string `json:"runstatus"`
	AssignmentStatus  string `json:"assignmentStatus"`
	ResourcePoolType  string `json:"resourcePoolType"`
	ResourcePool      string `json:"resourcePool"`
	Service           string `json:"service"`
	Region            string `json:"region"`
	Az                string `json:"az"`
	Lab               string `json:"lab"`
	Cabinet           string `json:"cabinet"`
	Room              string `json:"Room" `
	HostRackUid       string `json:"hostRackUid"`
	HostRackName      string `json:"hostRackName"`
	ServerType        string `json:"serverType"`
	Sn                string `json:"sn"`
	ManagementIP      string `json:"managementIP"`
	OutbandIP         string `json:"outbandIP"`
	MainMaintainer    string `json:"mainMaintainer"`
	Power             string `json:"power"`
	UplinkSwitch      string `json:"uplinkSwitch"`
	MaintenanceDue    string `json:"maintenanceDue"`
	MaintenanceStatus string `json:"maintenanceStatus"`
	Assetsnumber      string `json:"assetsnumber"`
	InputTime         string `json:"inputTime"`
	InputMethod       string `json:"inputMethod"`
	MacAddress        string `json:"macAddress"`
	System            string `json:"system"`
	SystemSales       string `json:"systemSales"`
	Description       string `json:"description"`
	CreateTime        string `json:"createTime"`
}

type physicalHostDetail struct {
	BasicMessage
	CpuMessage         []CpuMessage         `json:"cpuMessage"`
	MemoryMessage      []MemoryMessage      `json:"memoryMessage"`
	DiskMessage        []DiskMessage        `json:"diskMessage"`
	RAIDMessage        []RAIDMessage        `json:"raidMessage"`
	NetworkCardMessage []NetworkCardMessage `json:"networkCardMessage"`
	GPUMessage         []GPUMessage         `json:"gpuMessage"`
}

// type physicalHostDetailFromDgraph struct {
// 	Data physicalHostDetailFromDgraphHost `json:"data"`
// }

type physicalHostDetailFromDgraphHost struct {
	Host []physicalHostDetail `json:"host"`
}

type PhysicalHostResourceData struct {
	Name             string `json:"name"`
	Uid              string `json:"uid"`
	Standards        string `json:"standards"`
	AssignmentStatus string `json:"assignmentStatus"`
	ResourcePool     string `json:"resourcePool"`
	Region           string `json:"region"`
	Az               string `json:"az"`
	System           string `json:"system"`
	TenantId         string `json:"tenantId"`
	IP               string `json:"ip"`
	CreateTime       string `json:"createTime"`
}

type PageStruct struct {
	TotalCount int `json:"totalCount"`
	PageNo     int `json:"pageNo"`
	PageSize   int `json:"pageSize"`
}

type PhysicalHostResourceResult struct {
	PageStruct
	DataList []PhysicalHostResourceData `json:"dataList"`
}

type PhysicalHostUpdate struct {
	RequestId string `json:"requestId"`
	ReturnIf  bool   `json:"returnIf"`
}

var PhysicalHostListQueryDoc1 string = `
pageNo： 页数，必传eg: 1
pageSize： 页码，必传eg: 10
region： 区域;必传eg:all
az： 可用区;必传eg:all
lab： 机房;必传eg:all
name： 服务器名称;默认值：""
id:服务器ID;默认值：""
ip:服务器IP;默认值：""
sn:服务器SN号;默认值：""
runstatus:运行状态;默认值：[]
assignmentStatus:分配状态;默认值：[]
maintenanceStatus:维保状态;默认值：[]
inputMethod:录入方式;默认值：[]
`

type PhysicalHostListQuery1 struct {
	PageNo            int      `json:"pageNo"`
	PageSize          int      `json:"pageSize"`
	Region            string   `json:"region"`
	Az                []string `json:"az"`
	Lab               []string `json:"lab"`
	Name              string   `json:"name"`
	Id                string   `json:"id"`
	Ip                string   `json:"ip"`
	Sn                string   `json:"sn"`
	Runstatus         []string `json:"runstatus"`
	AssignmentStatus  []string `json:"assignmentStatus"`
	MaintenanceStatus []string `json:"maintenanceStatus"`
	InputMethod       []string `json:"inputMethod"`
}

type HostListQuery struct {
	IpArray []string `json:"ipArray"`
}

// 如果没有设置omitempty，那么将为没有明确指定的值创建具有
// 空值的边（对于int/float为0、对于string为""、对于bool为false）
type PhysicalHostUpdateEntity struct {
	Uid             string `json:"uid,omitempty"`
	HostLabCode     string `json:"hostLabCode,omitempty"`
	HostLabName     string `json:"hostLabName,omitempty"`
	HostRoomUid     string `json:"hostRoomUid,omitempty"`
	HostRoomName    string `json:"hostRoomName,omitempty"`
	HostCabinetUid  string `json:"hostCabinetUid,omitempty"`
	HostCabinetName string `json:"hostCabinetName,omitempty"`
	HostRackUid     int    `json:"hostRackUid,omitempty"`
	HostRackName    string `json:"hostRackName,omitempty"`
	HostUnitNumber  int    `json:"hostUnitNumber,omitempty"`
	Assetsnumber    string `json:"assetsnumber,omitempty"`
	MaintenanceDue  string `json:"maintenanceDue,omitempty"`
}

type Result struct {
	Code    int         `json:"code"`
	Message string      `json:"message"`
	Data    interface{} `json:"data"`
}
type Data struct {
	Host []Host `json:"host"`
}
type Host struct {
	Count int `json:"count"`
}
type PhysicalHostList struct {
	Host []server.PhysicalHostData `json:"host"`
}

type PhysicalHostResourceList struct {
	Host []PhysicalHostResourceData `json:"host"`
}

type PhysicalHostStateQuery struct {
}

type PhysicalHostRunningState struct {
	HostNums []HostNumPerRunningState `json:"hostNums"`
}

type physicalHostRunningStateInternal struct {
	HostNums []runningStateGroupBy `json:"hostNums"`
}

type runningStateGroupBy struct {
	GroupBy []HostNumPerRunningState `json:"@groupby"`
}

type HostNumPerRunningState struct {
	Runstatus string `json:"runstatus"`
	Count     int    `json:"count"`
}

type PhysicalHostMaintainState struct {
	HostNums []HostNumPerMaintainState `json:"hostNums"`
}

type HostNumPerMaintainState struct {
	HostMaintainState string `json:"hostMaintainState"`
	HostNum           int    `json:"hostNum"`
}

type physicalHostLocationStateInternal struct {
	HostNums []locationStateGroupBy `json:"hostNums"`
	Regions  []basic.Region         `json:"dataList"`
}

type locationStateGroupBy struct {
	GroupBy []HostNumPerLab `json:"@groupby"`
}

type PhysicalHostLocationState struct {
	HostNums []HostNumPerLab `json:"hostNums"`
}

type HostNumPerLab struct {
	HostLabCode    string `json:"hostLabCode"`
	Count          int    `json:"count"`
	HostLabName    string `json:"hostLabName"`
	HostRegionCode string `json:"hostRegionCode"`
	HostRegionName string `json:"hostRegionName"`
	HostAzCode     string `json:"hostAzCode"`
	HostAzName     string `json:"hostAzName"`
}

type LabInfo struct {
	HostLabName    string
	HostLabCode    string
	HostAzName     string
	HostAzCode     string
	HostRegionName string
	HostRegionCode string
}
type LabInfoData struct {
	LabInfo []Lab `json:"labInfo"`
}
type Lab struct {
	Uid     string `json:"uid"`
	LabCode string `json:"labCode"`
	LabName string `json:"labName"`
}

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/pkg/api/bmpool/register.go
```golang
package bmpool

import (
	"luban-cmdb-api/pkg/models/bmpool"
	"luban-cmdb-api/pkg/runtime"
	bmpoolservice "luban-cmdb-api/pkg/service/bmpool"

	"github.com/emicklei/go-restful"
	restfulspec "github.com/emicklei/go-restful-openapi"
)

const APIGroup = "bmPool"

func AddToContainer(c *restful.Container) error {
	bmTag := []string{"bmPool"}
	ws := runtime.NewWebService(APIGroup)
	//ToDo: create service
	bmPoolService := bmpoolservice.NewService()
	handler := NewHandler(bmPoolService)

	ws.Route(ws.GET("resourcePool/overview").To(handler.getBmOverviewHandler).
		Doc("获取裸金属概览").
		Metadata(restfulspec.KeyOpenAPITags, bmTag).
		Param(ws.QueryParameter("region", "region")).
		Param(ws.QueryParameter("az", "available zone")).
		Returns(200, "OK", bmpool.OverviewRsp{}))
	ws.Route(ws.POST("resourcePool/list").To(handler.getBmResourceListHandler).
		Doc("裸金属资源列表").
		Metadata(restfulspec.KeyOpenAPITags, bmTag).
		Reads(bmpool.ListReq{}, "必传参数:\npageNo:页数, int eg:1\n:pageSize:每页实例个数, int eg:10\n"+
			"orderType:排序方式string (ascending, descending)\norderCode:排序字段目前默认入库时间eg:inbound_time, string\n"+
			"可选参数:\nsearchType:搜索类型 string(''/'SN'支持SN模糊查询) 默认为空\nsearchValue：SN模糊查询搜索值 string\nSN:SN号 string\nregion:所属区域 string\n"+
			"多选+可选参数:\naz:所属可用区[]string\ninventory_status:库存状态[]string"+
			"\ninstance_type:实例类型[]string\nuser_id:售卖租户ID[]int64\nuser_name:售卖租户名字[]string\n"+
			"reserved_user_id:预留租户ID[]string\nreserved_user_name:预留租户名字[]string\n"+
			"单选+可选参数:\nreservation_status:预留状态 string").
		Returns(200, "OK", bmpool.ListRsp{}))
	ws.Route(ws.POST("resourcePool/inventory").To(handler.getInventoryHandler).
		Doc("裸金属库存列表").
		Metadata(restfulspec.KeyOpenAPITags, bmTag).
		Reads(bmpool.InventoryReq{}, "region:区域\naz:可用区\ninstanceType:实例类型\norderCode:inventoryTotal(库存总量),soldNum(已卖),reservedNum(已预留),forSaleNum(可卖量)\norderType:ascending, descending").
		Returns(200, "OK", bmpool.InventoryRsp{}))
	ws.Route(ws.GET("resourcePool/inventory/optionalCondition").To(handler.getOptionalCondition).
		Doc("裸金属库存列表可选参数").
		Metadata(restfulspec.KeyOpenAPITags, bmTag).
		Reads("", "").
		Returns(200, "OK", nil))
	ws.Route(ws.GET("resourcePool/list/optionalCondition").To(handler.getlistOptionalCondition).
		Doc("裸金属资源列表可选参数").
		Metadata(restfulspec.KeyOpenAPITags, bmTag).
		Reads("", "get请求获取下划列表可选参数信息").
		Returns(200, "OK", bmpool.ListOpInfo{}))
	c.Add(ws)
	return nil
}

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/pkg/api/bmpool/handler.go
```golang
package bmpool

import (
	"github.com/emicklei/go-restful"
	"luban-cmdb-api/pkg/models"
	"luban-cmdb-api/pkg/models/bmpool"
)

type BmService interface {
	GetBmPoolOverview(region, az string) (bmpool.OverviewRsp, error)
	GetBmResourceList(params bmpool.ListReq) (bmpool.ListRsp, error)
	GetInventory(params bmpool.InventoryReq) (bmpool.InventoryRsp, error)
	GetInventoryOptionalCondition() (map[string][]interface{}, error)
	GetbmListOptionalCondition() (rsp bmpool.ListOpInfo, err error)
}

type Handler struct {
	svc BmService
}

func NewHandler(bmService BmService) *Handler {
	return &Handler{
		svc: bmService,
	}
}

func (h *Handler) getBmOverviewHandler(req *restful.Request, resp *restful.Response) {
	resp.AddHeader(restful.HEADER_AccessControlAllowOrigin, "*")
	res := &models.CommonResult{
		Code:    200,
		Message: "success",
		Data:    nil,
	}
	region := req.QueryParameter("region")
	az := req.QueryParameter("az")
	overview, err := h.svc.GetBmPoolOverview(region, az)
	if err != nil {
		res.Code = 500
		res.Message = err.Error()
		resp.WriteAsJson(res)
		return
	}
	res.Data = overview
	resp.WriteAsJson(res)
}

func (h *Handler) getBmResourceListHandler(req *restful.Request, resp *restful.Response) {
	resp.AddHeader(restful.HEADER_AccessControlAllowOrigin, "*")
	res := &models.CommonResult{
		Code:    200,
		Message: "success",
		Data:    nil,
	}
	params := bmpool.ListReq{}
	err := req.ReadEntity(&params)
	if err != nil {
		res.Code = 500
		res.Message = "参数解析错误"
		resp.WriteAsJson(res)
		return
	}
	if params.PageSize <= 0 {
		params.PageSize = 10
	}
	if params.PageNo < 1 {
		params.PageNo = 1
	}
	data, err := h.svc.GetBmResourceList(params)
	if err != nil {
		res.Code = 500
		res.Message = err.Error()
		resp.WriteAsJson(res)
		return
	}
	res.Data = data
	resp.WriteAsJson(res)
}

func (h *Handler) getInventoryHandler(req *restful.Request, resp *restful.Response) {
	resp.AddHeader(restful.HEADER_AccessControlAllowOrigin, "*")
	res := &models.CommonResult{
		Code:    200,
		Message: "success",
		Data:    nil,
	}
	params := bmpool.InventoryReq{}
	err := req.ReadEntity(&params)
	if err != nil {
		res.Code = 500
		res.Message = "参数解析错误"
		resp.WriteAsJson(res)
		return
	}
	if params.PageSize <= 0 {
		params.PageSize = 10
	}
	if params.PageNo < 1 {
		params.PageNo = 1
	}
	data, err := h.svc.GetInventory(params)
	if err != nil {
		res.Code = 500
		res.Message = err.Error()
		resp.WriteAsJson(res)
		return
	}
	res.Data = data
	resp.WriteAsJson(res)
}

func (h *Handler) getOptionalCondition(req *restful.Request, resp *restful.Response) {
	resp.AddHeader(restful.HEADER_AccessControlAllowOrigin, "*")
	res := &models.CommonResult{
		Code:    200,
		Message: "success",
		Data:    nil,
	}
	data, err := h.svc.GetInventoryOptionalCondition()
	if err != nil {
		res.Code = 500
		res.Message = err.Error()
		resp.WriteAsJson(res)
		return
	}
	res.Data = data
	resp.WriteAsJson(res)
}

func (h *Handler) getlistOptionalCondition(req *restful.Request, resp *restful.Response) {
	resp.AddHeader(restful.HEADER_AccessControlAllowOrigin, "*")
	res := &models.CommonResult{
		Code:    200,
		Message: "success",
		Data:    nil,
	}
	//params := bmpool.ListReq{}
	//err := req.ReadEntity(&params)
	//if err != nil {
	//	res.Code = 500
	//	res.Message = "参数解析错误"
	//	resp.WriteAsJson(res)
	//	return
	//}
	//if params.PageSize <= 0 {
	//	params.PageSize = 10
	//}
	//if params.PageNo < 1 {
	//	params.PageNo = 1
	//}
	data, err := h.svc.GetbmListOptionalCondition()
	if err != nil {
		res.Code = 500
		res.Message = err.Error()
		resp.WriteAsJson(res)
		return
	}
	res.Data = data
	resp.WriteAsJson(res)
}

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/pkg/api/bmpool/result.go
```golang
package bmpool

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/pkg/api/objectStoragePool/register.go
```golang
package objectStoragePool

import (
	"luban-cmdb-api/pkg/apiserver/config"
	"luban-cmdb-api/pkg/models/storage"
	"luban-cmdb-api/pkg/runtime"
	"luban-cmdb-api/pkg/service"

	"github.com/dgraph-io/dgo/v200"
	"github.com/emicklei/go-restful"
	restfulspec "github.com/emicklei/go-restful-openapi"
)

const APIGroup = "objectStoragePool"

func AddToContainer(c *restful.Container, dgraphclient *dgo.Dgraph, config *config.Config) error {
	ws := runtime.NewWebService(APIGroup)
	objectStoragePoolService := service.NewObjectStoragePoolService(config.StorageStateAddr, config.PrometheusAddr, config.CustomerDomain, dgraphclient)
	handler := NewHandler(dgraphclient, objectStoragePoolService)
	//对象存储资源池
	tag1 := []string{"objectStoragePool"}
	//对象存储资源池
	ws.Route(ws.GET("/").To(handler.getobjectStoragePoolHandler).
		Doc("Get block storage resource pool list./获取对象存储资源池列表。").
		Metadata(restfulspec.KeyOpenAPITags, tag1).
		Param(ws.QueryParameter("pageNo", "Page number. eg:`1`, default value: `1`, mix value: `1`").DataType("int32").Required(false)).
		Param(ws.QueryParameter("pageSize", "Page size. eg:`10`, default value: `10`,").DataType("int32").Required(false)).
		Param(ws.QueryParameter("region", "region").DataType("string").Required(true)).
		Param(ws.QueryParameter("name", "Resource pool name").DataType("string")).
		Returns(200, "OK", objectStoragePoolListDataResult{}))
	ws.Route(ws.GET("/detail/{name}").To(handler.getObjectStoragePoolDetailHandler).
		Doc("Get one pool detail./查询单个对象存储资源池的详情").
		Metadata(restfulspec.KeyOpenAPITags, tag1).
		Param(ws.PathParameter("name", "The name of object storage pool").DataType("string").Required(true)).
		Returns(200, "OK", ObjectRe{}))
	ws.Route(ws.POST("/{name}").To(handler.getPhysicalHostByResourcePoolUidHandler).
		Doc("查询单个存储（对象/块）资源池的服务器列表。").
		Metadata(restfulspec.KeyOpenAPITags, tag1).
		Param(ws.PathParameter("name", "资源池名字").DataType("string").Required(true)).
		Reads(PhysicalHostQuery{}, PhysicalHostQueryDoc).
		Returns(200, "ok", PhysicalHostResourceResult{}))
	// ws.Route(ws.GET("/stock/{name}").To(handler.getStock). //在server中查看
	// 	Doc("Get stock./查询单个对象存储资源池的库存").
	// 	Metadata(restfulspec.KeyOpenAPITags, tag1).
	// 	Param(ws.PathParameter("name", "The name of block storage pool").DataType("string").Required(true)).
	// 	Param(ws.QueryParameter("pageNo", "Page number. e.g. `1`, default `1`").DataType("int")).
	// 	Param(ws.QueryParameter("pageSize", "Page size. e.e.g `10` default `10`").DataType("int")).
	// 	Param(ws.QueryParameter("orderCode", "The orderCode of order.eg:cpuUsage;memoryRate")).
	// 	Param(ws.QueryParameter("orderType", "The orderType of order.eg:升：asc;降：desc")).
	// 	Returns(200, "OK", storage.ObjectStoragePoolStock{}))
	ws.Route(ws.POST("/bucket/{name}").To(handler.getBucketList).
		Doc("Get one pool bucket list/查询单个对象存储资源池的bucket列表").
		Metadata(restfulspec.KeyOpenAPITags, tag1).
		Param(ws.PathParameter("name", "The name of block storage pool").DataType("string").Required(true)).
		Reads(ObjectStorageBucketQuery{}, ObjectStorageBucketQueryDoc).
		// Param(ws.QueryParameter("pageNo", "Page number. e.g. `1`, default `1`").DataType("int")).
		// Param(ws.QueryParameter("pageSize", "Page size. e.e.g `10` default `10`").DataType("int")).
		// Param(ws.QueryParameter("storageType", "存储类型状态").DataType("string")).
		Returns(200, "OK", storage.ObjectStoragePoolBucket{}))
	c.Add(ws)
	return nil
}

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/pkg/api/objectStoragePool/handler.go
```golang
package objectStoragePool

import (
	"context"
	"encoding/json"
	"fmt"
	"luban-cmdb-api/pkg/service"
	"sort"
	"strconv"

	"github.com/dgraph-io/dgo/v200"
	"github.com/emicklei/go-restful"

	"luban-cmdb-api/pkg/api"
	"luban-cmdb-api/pkg/handler"
	"luban-cmdb-api/pkg/models"
	"luban-cmdb-api/pkg/models/server"
	"luban-cmdb-api/pkg/models/storage"
)

type ObjectStoragePoolSvc interface {
	//ListBuckets(poolName string, pageNo int, pageSize int, storageType []string) (*storage.ObjectStoragePoolBucket, error)
	GetBucketList(r storage.BucketRequest) (*storage.ObjectStoragePoolBucket, error)
	GetPoolStock(poolName string, pageNo, pageSize int) (*storage.ObjectStoragePoolStock, error)
	GetobjectStoragePoolList(objectStoragePoolQuery storage.BlockStoragePoolQuery) ([]storage.ObjectRe, error)
}

type Handler struct {
	dgraphClient *dgo.Dgraph
	svc          ObjectStoragePoolSvc
}

func NewHandler(dgraphClient *dgo.Dgraph, svc ObjectStoragePoolSvc) *Handler {
	return &Handler{
		dgraphClient: dgraphClient,
		svc:          svc,
	}
}

func (h *Handler) getobjectStoragePoolHandler(request *restful.Request, response *restful.Response) {
	response.AddHeader("Access-Control-Allow-Origin", "*")
	rst := new(Result)
	t := new(storage.BlockStoragePoolQuery)
	pageNo, err := strconv.Atoi(request.QueryParameter("pageNo"))
	if err != nil {
		rst.Code = 500
		rst.Message = "pageNo false"
		response.WriteAsJson(rst)
		return
	}
	pageSize, err := strconv.Atoi(request.QueryParameter("pageSize"))
	if err != nil {
		rst.Code = 500
		rst.Message = "pageSize false"
		response.WriteAsJson(rst)
		return
	}
	t.PageNo = pageNo
	t.PageSize = pageSize
	t.RegionCode = request.QueryParameter("region")
	t.Name = request.QueryParameter("name")
	//t.ResourcePool = request.QueryParameter("resourcePool")
	t.SearchType = request.QueryParameter("searchType")
	t.SearchValue = request.QueryParameter("searchValue")

	regionResult, err := h.GetobjectStoragePoolList(*t)
	if err != nil {
		rst.Code = 500
		rst.Message = err.Error()
		response.WriteAsJson(rst)
		return
	} else {
		rst.Code = 200
		rst.Message = "success"
		rst.Data = regionResult
		response.WriteAsJson(rst)
		return
	}

}

//查询对象资源池资源详情api
func (h *Handler) getObjectStoragePoolDetailHandler(request *restful.Request, response *restful.Response) {
	//instanceId := request.PathParameter("instanceId")
	response.AddHeader("Access-Control-Allow-Origin", "*")
	rst := new(Result)
	t := new(storage.BlockStoragePoolQuery)
	name := request.PathParameter("name")
	//resourcePool := []string{name}
	t.RegionCode = "all"
	//t.AzCode = "all"
	t.Name = name
	//fmt.Println(*t)
	objectReList, err := h.svc.GetobjectStoragePoolList(*t)
	if err != nil {
		rst.Code = 500
		rst.Message = err.Error()
		response.WriteAsJson(rst)
		return
	} else {
		objectRe := storage.ObjectRe{}
		if len(objectReList) > 0 {
			objectRe = objectReList[0]
		}
		rst.Code = 200
		rst.Message = "success"
		rst.Data = objectRe
		response.WriteAsJson(rst)
		return
	}
}

//根据资源池名字来查询此资源池下的服务器列表
func (h *Handler) getPhysicalHostByResourcePoolUidHandler(request *restful.Request, response *restful.Response) {
	response.AddHeader("Access-Control-Allow-Origin", "*")
	rst := new(Result)
	t := new(PhysicalHostQuery)
	err := request.ReadEntity(&t)
	if err != nil {
		rst.Code = 500
		rst.Message = err.Error()
		response.WriteAsJson(rst)
		return
	}
	t.Name = request.PathParameter("name")

	physicalHostDataResult, err := h.GetPhysicalHostList(*t)
	if err != nil {
		rst.Code = 500
		rst.Message = err.Error()
		response.WriteAsJson(rst)
		return
	} else {
		// for index, hostData := range physicalHostDataResult.DataList {

		// 	// if hostData.Service != "" {
		// 	// 	physicalHostDataResult.DataList[index].AssignmentStatus = "assigned"
		// 	// } else {
		// 	// 	physicalHostDataResult.DataList[index].AssignmentStatus = "unassigned"
		// 	// }
		// 	// switch strings.ToLower(hostData.RunStatus) {
		// 	// case "up":
		// 	// 	physicalHostDataResult.DataList[index].RunStatus = "运行中"
		// 	// case "down":
		// 	// 	physicalHostDataResult.DataList[index].RunStatus = "故障"
		// 	// default:
		// 	// 	physicalHostDataResult.DataList[index].RunStatus = "故障"
		// 	// }

		// }
		rst.Code = 200
		rst.Message = "success"
		rst.Data = physicalHostDataResult
		response.WriteAsJson(rst)
		return
	}

}

//获取单个服务器详情
func (h *Handler) GetObjectStoragePoolEntity(instanceId string) (ObjectRe, error) {

	q := `{
		objectStoragePool(func:uid(` + instanceId + `))  {
			id:uid
			name
			regionName:hostRegionName
			resourcePool:serviceType
			bucketNumber
			hostNumber
			objectNumber
		} 
	}`
	//fmt.Println(q)

	var objectStoragePool ObjectStoragePool
	resp, err := h.dgraphClient.NewTxn().Query(context.Background(), q)
	err = json.Unmarshal(resp.Json, &objectStoragePool)
	//fmt.Println(*resp)
	var objectStoragePoolResult ObjectRe
	if err != nil {
		return objectStoragePoolResult, err
	} else {
		objectStoragePoolResult = objectStoragePool.ObjectStoragePool[0]
	}
	return objectStoragePoolResult, err
}

//获取对象资源池资源列表
func (h *Handler) GetobjectStoragePoolList(objectStoragePoolQuery storage.BlockStoragePoolQuery) (storage.ObjectStoragePoolListDataResult, error) {
	var blockReList []storage.ObjectRe
	var ObjectStoragePoolListDataResult storage.ObjectStoragePoolListDataResult
	var err error

	blockReList, err = h.svc.GetobjectStoragePoolList(objectStoragePoolQuery)
	if err != nil {
		return ObjectStoragePoolListDataResult, err
	}
	returnList, err := h.SortobjectStoragePoolList(objectStoragePoolQuery, blockReList)
	low := (objectStoragePoolQuery.PageNo - 1) * objectStoragePoolQuery.PageSize
	high := (objectStoragePoolQuery.PageNo) * objectStoragePoolQuery.PageSize
	if high > len(returnList) {
		high = len(returnList)
	}
	ObjectStoragePoolListDataResult.TotalCount = len(returnList)
	returnList = returnList[low:high]
	for i := range returnList {
		blockReList = append(blockReList, returnList[i].(storage.ObjectRe))
	}
	ObjectStoragePoolListDataResult.DataList = blockReList[low:high]

	return ObjectStoragePoolListDataResult, nil
}
func (h *Handler) SortobjectStoragePoolList(objectStoragePoolQuery storage.BlockStoragePoolQuery, list []storage.ObjectRe) ([]interface{}, error) {
	results := service.Bucket{}
	sortList := make([]interface{}, len(list))
	for i := range list {
		sortList[i] = list[i]
	}
	results.Slice = sortList
	time_by := func(a, b interface{}) bool {
		return a.(storage.ObjectRe).CreateTime > b.(storage.ObjectRe).CreateTime
	}
	results.By = time_by
	sort.Sort(results)
	return results.Slice, nil
}

/* //获取块存储资源列表
func (h *Handler) GetobjectStoragePool(objectStoragePoolQuery objectStoragePoolQuery) (ObjectRe, error) {
	var qList []string
	qString := ""
	if objectStoragePoolQuery.RegionCode != "all" && objectStoragePoolQuery.RegionCode != "" {
		qList = append(qList, `eq(hostRegionCode, "`+objectStoragePoolQuery.RegionCode+`")`)
	}
	if objectStoragePoolQuery.Name != "" {
		qList = append(qList, `eq(serviceType, "`+objectStoragePoolQuery.Name+`")`)
	}
	q := `{
		hostCount(func:anyofterms(serviceType,ks3))`
	if len(qList) > 0 {
		qString = "@filter(" + strings.Join(qList, "and ") + ")"
		q = q + qString
	}
	q = q + `   {
	count(uid)
	  }
	   host(func:eq(serviceType,ks3),offset:0,first:1)

		 `
	if len(qList) > 0 {
		qString = "@filter(" + strings.Join(qList, "and ") + ")"
		q = q + qString
	}
	fmt.Println(qString)
	q += `  {
		id:uid
		name:serviceType
		regionName:hostRegionName
		regionCode:hostRegionCode
		resourcePool:serviceType
		bucketNumber
		hostNumber
	  }
	}`
	fmt.Println(q)
	var objectStoragePoolResult objectStoragePoolList
	var ObjectReData ObjectRe
	//var objectStoragePoolDataResult objectStoragePoolListDataResult
	resp, err := h.dgraphClient.NewTxn().Query(context.Background(), q)
	err = json.Unmarshal(resp.Json, &objectStoragePoolResult)
	if err != nil {
		fmt.Println(err)
		return ObjectReData, err
	}
	if len(objectStoragePoolResult.Host) > 0 {
		ObjectReData = objectStoragePoolResult.Host[0]
		ObjectReData.HostNumber = objectStoragePoolResult.HostCount[0].Count
		data, err := h.svc.GetBucketList(objectStoragePoolQuery.Name, 0, 10, []string{})
		if err != nil {
			return ObjectReData, err
		}
		ObjectReData.BucketNumber = data.TotalCount
	}
	// objectStoragePoolDataResult.DataList = objectStoragePoolResult.Host
	// objectStoragePoolDataResult.PageNo = objectStoragePoolQuery.PageNo
	// objectStoragePoolDataResult.PageSize = objectStoragePoolQuery.PageSize
	// objectStoragePoolDataResult.TotalCount, _ = h.GetCountByQ(`eq(resourcePoolType,"ks3")`, qString)

	return ObjectReData, err
} */
func (h *Handler) GetCountByQ(funcFirst string, qString string) (int, error) {
	// 为创建的节点分配的uid将在resp.AssignedUids map中返回。
	//variables := map[string]string{"$id": assigned.Uids["blank-0"]}
	q := `{
		host(func:` + funcFirst + `)`
	if qString == "" {
		q = q + qString
	}
	q += `{
	     count(uid)
	    }
      }
	`
	//fmt.Println(q)
	resp, err := h.dgraphClient.NewTxn().Query(context.Background(), q)
	if err != nil {
		fmt.Println(err)
		return 0, err
	} else {
		var r Data
		err = json.Unmarshal(resp.Json, &r)
		if err != nil {
			return 0, err
		} else {
			return r.Host[0].Count, nil
		}
	}
}

//获取服务器列表
func (h *Handler) GetPhysicalHostList(physicalHostQuery PhysicalHostQuery) (physicalHostDataResult server.PhysicalHostDataResult, err error) {
	//var addrs []string
	// storageType := ""
	// reasourcePool := ""
	// spList := service.GetPoolList()
	// for i := 0; i < len(spList); i++ {
	// 	if spList[i].Name == physicalHostQuery.Name {
	// 		// address, err := service.StoragePoolList[i].GetStoragePoolIps()
	// 		// if err != nil {
	// 		// 	return physicalHostDataResult, err
	// 		// }
	// 		//addrs = address.Address
	// 		addrs = spList[i].Addresss
	// 		reasourcePool = spList[i].ResourcePool
	// 		storageType = spList[i].StorageType
	// 		break
	// 	}
	// }
	// if len(addrs) <= 0 {
	// 	return physicalHostDataResult, nil
	// }
	serverservice := service.NewServerService(nil)
	var physicalHostListQuery server.PhysicalHostListQuery
	physicalHostListQuery.PageNo = physicalHostQuery.PageNo
	physicalHostListQuery.PageSize = physicalHostQuery.PageSize
	physicalHostListQuery.Runstatus = physicalHostQuery.RunStatus
	physicalHostListQuery.AssignmentStatus = physicalHostQuery.AssignmentStatus
	physicalHostListQuery.ResourcePool = physicalHostQuery.Name
	physicalHostAll, err := serverservice.GetPhysicalHostList(physicalHostListQuery)
	return physicalHostAll, err
}

func (h *Handler) getBucketList(req *restful.Request, resp *restful.Response) {
	// poolName := req.PathParameter("name")
	// pagination := handler.CommonPagination(req)
	// storageType := req.PathParameter("storageType")
	t := new(storage.BucketRequest)
	err := req.ReadEntity(&t)
	if err != nil {
		api.HandleInternalError(resp, err)
		return
	}
	//data, err := h.svc.ListBuckets(t.Name, t.PageNo, t.PageSize, t.StorageType)
	data, err := h.svc.GetBucketList(*t)
	if err != nil {
		api.HandleInternalError(resp, err)
		return
	}
	var res models.CommonResult
	res.Data = data
	resp.WriteAsJson(&res)
}

func (h *Handler) getStock(req *restful.Request, resp *restful.Response) {
	poolName := req.PathParameter("name")
	pagination := handler.CommonPagination(req)
	data, err := h.svc.GetPoolStock(poolName, pagination.PageNo, pagination.PageSize)
	if err != nil {
		api.HandleInternalError(resp, err)
		return
	}
	var res models.CommonResult
	res.Data = data
	resp.WriteAsJson(&res)
}

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/pkg/api/objectStoragePool/result.go
```golang
package objectStoragePool

type Result struct {
	Code    int         `json:"code"`
	Message string      `json:"message"`
	Data    interface{} `json:"data"`
}

type PageStruct struct {
	TotalCount int `json:"totalCount"`
	PageNo     int `json:"pageNo"`
	PageSize   int `json:"pageSize"`
}

type objectStoragePoolListDataResult struct {
	PageStruct
	DataList []ObjectRe `json:"dataList"`
}

// type objectStoragePoolList struct {
// 	RequestId string    `json:"requestId"`
// 	Returns   []BlockRe `json:"returns"`
// }

type ObjectRe struct {
	Name         string `json:"name"`
	Id           string `json:"id"`
	RegionName   string `json:"regionName"`
	RegionCode   string `json:"regionCode"`
	ResourcePool string `json:"resourcePool"`
	BucketNumber int    `json:"bucketNumber"`
	HostNumber   int    `json:"hostNumber"`
	ObjectNumber string `json:"objectNumber"`
}

type objectStoragePoolQuery struct {
	PageNo     int    `json:"pageNo"`
	PageSize   int    `json:"pageSize"`
	RegionCode string `json:"regionCode"`
	Name       string `json:"name"`
	//ResourcePoolType string `json:"resourcePoolType"` //资源池类型(对象存储,块存储)
	ResourcePool string `json:"resourcePool"` //资源池（标准存储，归档存储，ehdd,ebs）
}

var PhysicalHostQueryDoc string = `
pageNo： 页数，必传eg: 1
pageSize： 页码，必传eg: 10
runStatus:默认值 ""
assignmentStatus:运行状态;默认值：[]
`

type PhysicalHostQuery struct {
	PageNo           int      `json:"pageNo"`
	PageSize         int      `json:"pageSize"`
	Name             string   `json:"name"` //资源池Uid
	RunStatus        []string `json:"runstatus"`
	AssignmentStatus []string `json:"assignmentStatus"`
	//ResourcePoolType string `json:"resourcePoolType"` //资源池类型(对象存储，块存储)
}

var ObjectStorageBucketQueryDoc string = `
pageNo： 页数，必传eg: 1
pageSize： 页码，必传eg: 10
storageType:运行状态;默认值：[]
`

type ObjectStorageBucketQuery struct {
	PageNo      int      `json:"pageNo"`
	PageSize    int      `json:"pageSize"`
	Name        string   `json:"name"` //资源池Uid
	StorageType []string `json:"storageType"`
}

type objectStoragePoolList struct {
	Host      []ObjectRe  `json:"host"`
	HostCount []HostCount `json:"hostCount"`
}
type HostCount struct {
	Count int `json:"count"`
}
type Data struct {
	Host []Host `json:"host"`
}
type Host struct {
	Count int `json:"count"`
}

type ObjectStoragePool struct {
	ObjectStoragePool []ObjectRe `json:"objectStoragePool"`
}

type PhysicalHostData struct {
	Name             string `json:"name"`
	Uid              string `json:"uid"`
	RunStatus        string `json:"runStatus"`
	AssignmentStatus string `json:"assignmentStatus"`
	ResourcePoolType string `json:"resourcePoolType"`
	ResourcePool     string `json:"resourcePool"`
	ResourcePoolUid  string `json:"resourcePoolUid"`
	Service          string `json:"service"`
	HostRegionCode   string `json:"hostRegionCode"`
	HostRegionName   string `json:"hostRegionName"`
	HostAzCode       string `json:"hostAzCode"`
	HostAzName       string `json:"hostAzName"`
	HostLabCode      string `json:"hostLabCode"`
	HostLabName      string `json:"hostLabName"`
	HostRackUid      string `json:"hostRackUid"`
	HostRackName     string `json:"hostRackName"`
	HostUnitUid      string `json:"hostUnitUid"`
	HostUnitNumber   string `json:"hostUnitNumber"`
	Sn               string `json:"sn"`
	Ip               string `json:"ip"`
}

type PhysicalHostResourceList struct {
	Host []PhysicalHostData `json:"host"`
}
type PhysicalHostResourceResult struct {
	PageStruct
	DataList []PhysicalHostData `json:"dataList"`
}

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/pkg/api/objectStoragePool/handler_test.go
```golang
package objectStoragePool

import (
	"encoding/json"
	"errors"
	"io/ioutil"
	"net/http/httptest"
	"testing"

	"github.com/emicklei/go-restful"
	"k8s.io/klog/v2"

	"luban-cmdb-api/pkg/models"
	"luban-cmdb-api/pkg/models/storage"
)

type mockObjectStorageService struct {
	Buckets      *storage.ObjectStoragePoolBucket
	Stock        *storage.ObjectStoragePoolStock
	ObjectReList []storage.ObjectRe
	Error        error
}

func (m *mockObjectStorageService) GetBucketList(r storage.BucketRequest) (*storage.ObjectStoragePoolBucket, error) {
	return m.Buckets, m.Error
}

func (m *mockObjectStorageService) GetPoolStock(insId string, pageNo, pageSize int) (*storage.ObjectStoragePoolStock, error) {
	return m.Stock, m.Error
}
func (m *mockObjectStorageService) GetobjectStoragePoolList(objectStoragePoolQuery storage.BlockStoragePoolQuery) ([]storage.ObjectRe, error) {
	return m.ObjectReList, m.Error
}

func TestObjectStoragePoolHandler_getStock(t *testing.T) {
	testCases := []struct {
		Name                     string
		StatusCode               int
		Error                    error
		MockObjectStorageService *mockObjectStorageService
	}{
		{
			Name:       "regular-test-flow",
			Error:      nil,
			StatusCode: 200,
			MockObjectStorageService: &mockObjectStorageService{
				Stock: &storage.ObjectStoragePoolStock{
					DataList: []storage.ObjectStockDetail{
						{
							Region: "test-region",
						},
					},
				},
			},
		}, {
			Name:       "500-server-error",
			Error:      errors.New("500 server error test"),
			StatusCode: 500,
			MockObjectStorageService: &mockObjectStorageService{
				Error: errors.New("500 server error test"),
			},
		},
	}
	for _, testCase := range testCases {
		t.Run(testCase.Name, func(t *testing.T) {
			server := mockObjectStorageHandler(testCase.MockObjectStorageService)
			req := httptest.NewRequest("GET", "/objectStoragePoolStock/test-id", nil)
			record := httptest.NewRecorder()
			server.ServeHTTP(record, req)
			resp := record.Result()
			if resp.StatusCode != testCase.StatusCode {
				t.Fatalf("statusCode not match: %d, %d", resp.StatusCode, testCase.StatusCode)
			}
			if testCase.StatusCode == 200 {
				b, err := ioutil.ReadAll(resp.Body)
				if err != nil {
					t.Fatalf("read response error: %s", err)
				}
				var res models.CommonResult
				err = json.Unmarshal(b, &res)
				if err != nil {
					t.Fatalf("json unmarshal res error: %s", err)
				}
				var stock storage.BlockStoragePoolStock
				data, err := json.Marshal(res.Data)
				if err != nil {
					t.Fatalf("json marshal error: %s", err)
				}
				err = json.Unmarshal(data, &stock)
				if err != nil {
					t.Fatalf("json unmarshal error: %s", err)
				}
				t.Logf("stock test %+v", stock)
				if stock.DataList[0].Region != testCase.MockObjectStorageService.Stock.DataList[0].Region {
					t.Fatalf("stock data not match")
				}
			}
		})
	}
}

func TestObjectStoragePoolHandler_getBucketList(t *testing.T) {
	testCases := []struct {
		Name                     string
		StatusCode               int
		Error                    error
		MockObjectStorageService *mockObjectStorageService
	}{
		{
			Name:       "regular-test-flow",
			Error:      nil,
			StatusCode: 200,
			MockObjectStorageService: &mockObjectStorageService{
				Buckets: &storage.ObjectStoragePoolBucket{
					DataList: []storage.BucketDetail{
						{
							Name: "test-name",
						},
					},
				},
			},
		}, {
			Name:       "500-server-error",
			Error:      errors.New("500 server internal error"),
			StatusCode: 500,
			MockObjectStorageService: &mockObjectStorageService{
				Error: errors.New("500 server internal error"),
			},
		},
	}
	for _, testCase := range testCases {
		t.Run(testCase.Name, func(t *testing.T) {
			server := mockObjectStorageHandler(testCase.MockObjectStorageService)
			req := httptest.NewRequest("GET", "/objectStoragePoolBuckets/test-insId", nil)
			record := httptest.NewRecorder()
			server.ServeHTTP(record, req)
			resp := record.Result()
			t.Logf("resp: %+v", resp)
			if resp.StatusCode != testCase.StatusCode {
				t.Fatalf("statusCode not match: %d, %d", resp.StatusCode, testCase.StatusCode)
			}
			if testCase.StatusCode == 200 {
				b, err := ioutil.ReadAll(resp.Body)
				if err != nil {
					t.Fatalf("read response body error: %s", err)
				}
				var commonRes models.CommonResult
				err = json.Unmarshal(b, &commonRes)
				if err != nil {
					t.Fatalf("unmarshal common result error: %s", err)
				}
				// test common code message
				if commonRes.Code != 200 {
					t.Fatalf("common result code default should be 200, got: %d", commonRes.Code)
				}
				data, err := json.Marshal(commonRes.Data)
				if err != nil {
					t.Fatalf("marshal common result data error: %s", err)
				}
				var buckets storage.ObjectStoragePoolBucket
				err = json.Unmarshal(data, &buckets)
				if err != nil {
					t.Fatalf("buckets body error: %s", err)
				}
				if buckets.DataList[0].Name != testCase.MockObjectStorageService.Buckets.DataList[0].Name {
					t.Fatalf("response data not match")
				}
			}
		})
	}
}

func mockObjectStorageHandler(svc *mockObjectStorageService) *restful.Container {
	h := NewHandler(nil, svc)
	ws := new(restful.WebService)
	ws.Consumes(restful.MIME_JSON)
	ws.Route(ws.GET("/objectStoragePoolStock/{instanceId}").To(h.getStock))
	ws.Route(ws.GET("/objectStoragePoolBuckets/{instanceId}").To(h.getBucketList))
	server := restful.NewContainer()
	server.Add(ws)
	klog.Infof("routes for test: %s", ws.Routes())
	return server
}

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/pkg/api/switch/register.go
```golang
package switchMachine

import (
	"luban-cmdb-api/pkg/dao/switchdao"
	switchMachine "luban-cmdb-api/pkg/models/switch"
	"luban-cmdb-api/pkg/runtime"
	"luban-cmdb-api/pkg/service"

	"github.com/dgraph-io/dgo/v200"
	"github.com/emicklei/go-restful"
	restfulspec "github.com/emicklei/go-restful-openapi"
)

const APIGroup = "switch"

func AddToContainer(c *restful.Container, dgraphclient *dgo.Dgraph) error {
	switchTag := []string{"switch"}
	ws := runtime.NewWebService(APIGroup)
	switchService := service.NewSwitchService(dgraphclient)
	handler := NewHandler(switchService)
	ws.Route(ws.GET("detail/{id}").To(handler.getSwitchInfo).
		Doc("获取交换机基础信息").
		Metadata(restfulspec.KeyOpenAPITags, switchTag).
		Param(ws.PathParameter("id", "查询的交换机id").DataType("string").Required(true)).
		Returns(200, "success", switchMachine.SwitchNew{}))
	ws.Route(ws.GET("detailByName/{name}").To(handler.getSwitchInfoByName).
		Doc("获取交换机基础信息").
		Metadata(restfulspec.KeyOpenAPITags, switchTag).
		Param(ws.PathParameter("name", "查询的交换机名称").DataType("string").Required(true)).
		Returns(200, "success", switchMachine.SwitchNew{}))
	ws.Route(ws.POST("list").To(handler.getSwitchList).
		Doc("获取交换机列表").
		Metadata(restfulspec.KeyOpenAPITags, switchTag).
		Reads(switchMachine.SwitchListParams{}).
		Returns(200, "success", switchMachine.SwitchListResult{}))
	ws.Route(ws.GET("role").To(handler.getSwitchRole).
		Doc("获取交换机角色").
		Metadata(restfulspec.KeyOpenAPITags, switchTag).
		Returns(200, "success", []switchdao.SwitchRole{}))
	ws.Route(ws.DELETE("switchInfo").To(handler.deleteSwitch).
		Doc("删除交换机").
		Metadata(restfulspec.KeyOpenAPITags, switchTag).
		Reads(switchMachine.SwitchDeleteParams{}).
		Returns(200, "success", nil))
	ws.Route(ws.POST("switchInfo").To(handler.addSwitch).Consumes("multipart/form-data").
		Doc("新增交换机").
		Metadata(restfulspec.KeyOpenAPITags, switchTag).
		Reads(switchMachine.SwitchAddParams{}).
		Returns(200, "success", nil))
	ws.Route(ws.PATCH("switchInfo").To(handler.updateSwitch).
		Doc("更新交换机信息").
		Metadata(restfulspec.KeyOpenAPITags, switchTag).
		Reads(switchMachine.SwitchUpdateParams{}).
		//Reads(switchMachine.MysqlSwitch{}).
		Returns(200, "success", nil))
	ws.Route(ws.GET("overview").To(handler.overview).
		Doc("获取交换机概览数据").
		Metadata(restfulspec.KeyOpenAPITags, switchTag).
		Param(ws.QueryParameter("regionCode", "所在区域").DataType("string").Required(true)).
		Param(ws.QueryParameter("azCode", "所在可用区").DataType("string").Required(true)).
		Returns(200, "success", switchMachine.SwitchOverview{}))
	ws.Route(ws.GET("sales").To(handler.getSwitchSales).
		Doc("获取交换机厂商数据").
		Metadata(restfulspec.KeyOpenAPITags, switchTag).
		Returns(200, "success", []string{}))
	ws.Route(ws.GET("getInterfaceLayoutList").To(handler.getInterfaceLayoutHandler).
		Doc("获取交换机接口布局表").
		Metadata(restfulspec.KeyOpenAPITags, switchTag).
		Param(ws.QueryParameter("sn", "交换机sn").DataType("string").Required(true)).
		Returns(200, "success", switchMachine.SwitchInterfaceLayoutListResult{}))
	ws.Route(ws.POST("postSwitchInterfaceInfoList").To(handler.postSwitchInterfaceInfoList).
		Doc("获取交换机接口细节序列").
		Metadata(restfulspec.KeyOpenAPITags, switchTag).
		Reads(switchMachine.SwitchInterfaceLayoutListParams{}).
		Returns(200, "success", switchMachine.SwitchInterfaceInfoResult{}))
	ws.Route(ws.POST("postSwitchInterfaceDetails").To(handler.postSwitchInterfaceDetails).
		Doc("获取交换机接口细节参数").
		Metadata(restfulspec.KeyOpenAPITags, switchTag).
		Reads(switchMachine.SwitchInterfaceLayoutListParams{}).
		Returns(200, "success", switchMachine.SwitchInterfaceDetailResult{}))
	ws.Route(ws.GET("getSwitchPartsAndView").To(handler.getSwitchPartsAndView).
		Doc("获取交换机硬件监控数据").
		Metadata(restfulspec.KeyOpenAPITags, switchTag).
		Param(ws.QueryParameter("sn", "交换机sn").DataType("string").Required(true)).
		Returns(200, "success", map[string]interface{}{}))
	c.Add(ws)
	return nil
}

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/pkg/api/switch/handler.go
```golang
package switchMachine

import (
	"luban-cmdb-api/pkg/dao/basic"
	labdao "luban-cmdb-api/pkg/dao/lab"
	"luban-cmdb-api/pkg/dao/switchdao"
	switchMachine "luban-cmdb-api/pkg/models/switch"
	"luban-cmdb-api/pkg/service"
	"luban-cmdb-api/pkg/utils"
	"strconv"
	"time"

	"github.com/emicklei/go-restful"
)

type SwitchService interface {
	GetSwitchInfo(id int) (switchMachine.SwitchNew, error)
	GetSwitchInfoByName(name string) (switchMachine.SwitchNew, error)
	GetSwitchList(params switchMachine.SwitchListParams) (result switchMachine.SwitchListResult, err error)
	DeleteSwitchInfo(params switchMachine.SwitchDeleteParams) error
	AddSwitchInfo(params switchMachine.SwitchAddParams) error
	UpdateSwitchInfo(params switchMachine.MysqlSwitch) error
	SwitchOverview(regionCode, azCode string) (switchMachine.SwitchOverview, error)
	GetSwitchLayout(sn string) (switchMachine.SwitchInterfaceLayoutListResult, error)
	GetSwitchInterfaceInfoList(param switchMachine.SwitchInterfaceLayoutListParams) (int64, []switchMachine.SwitchInterfaceInfo, error)
	GetSwitchInterfaceDetails(sn, index string) ([]switchMachine.SwitchInterfaceDetail, error)
	GetSwitchSales() []string
	GetSwitchPartsAndView(sn string) (map[string]interface{}, error)
}

type Handler struct {
	svc SwitchService
}

func NewHandler(service SwitchService) *Handler {
	return &Handler{
		svc: service,
	}
}

func (h *Handler) getSwitchSales(request *restful.Request, response *restful.Response) {
	response.AddHeader(restful.HEADER_AccessControlAllowOrigin, "*")
	res := new(Result)
	res.Data = h.svc.GetSwitchSales()
	res.Code = 200
	res.Message = "success"
	response.WriteAsJson(res)
	return
}

func (h *Handler) getSwitchInfo(request *restful.Request, response *restful.Response) {
	response.AddHeader(restful.HEADER_AccessControlAllowOrigin, "*")
	res := new(Result)
	idStr := request.PathParameter("id")
	id, err := strconv.Atoi(idStr)
	if err != nil {
		res.Code = 500
		res.Message = err.Error()
		response.WriteAsJson(res)
		return
	}
	info, err := h.svc.GetSwitchInfo(id)
	if err != nil {
		res.Code = 500
		res.Message = err.Error()
		response.WriteAsJson(res)
		return
	}
	res.Code = 200
	res.Message = "success"
	res.Data = info
	response.WriteAsJson(res)
	return
}
func (h *Handler) getSwitchInfoByName(request *restful.Request, response *restful.Response) {
	response.AddHeader(restful.HEADER_AccessControlAllowOrigin, "*")
	res := new(Result)
	name := request.PathParameter("name")
	if name == "" {
		res.Code = 500
		res.Message = "switch name is invalid"
		_ = response.WriteAsJson(res)
		return
	}
	info, err := h.svc.GetSwitchInfoByName(name)
	if err != nil {
		res.Code = 500
		res.Message = err.Error()
		response.WriteAsJson(res)
		return
	}
	res.Code = 200
	res.Message = "success"
	res.Data = info
	response.WriteAsJson(res)
	return
}

func (h *Handler) getSwitchList(request *restful.Request, response *restful.Response) {
	response.AddHeader(restful.HEADER_AccessControlAllowOrigin, "*")
	res := new(Result)
	params := switchMachine.SwitchListParams{}
	err := request.ReadEntity(&params)
	if err != nil {
		res.Code = 500
		res.Message = err.Error()
		return
	}
	result, err := h.svc.GetSwitchList(params)
	if err != nil {
		res.Code = 500
		res.Message = err.Error()
		response.WriteAsJson(res)
		return
	}
	res.Code = 200
	res.Message = "success"
	res.Data = result
	response.WriteAsJson(res)
	return
}

func (h *Handler) getSwitchRole(request *restful.Request, response *restful.Response) {
	response.AddHeader(restful.HEADER_AccessControlAllowOrigin, "*")
	res := new(Result)
	res.Code = 200
	res.Message = "success"
	res.Data = switchdao.SwitchRoles
	response.WriteAsJson(res)
}

func (h *Handler) deleteSwitch(request *restful.Request, response *restful.Response) {
	response.AddHeader(restful.HEADER_AccessControlAllowOrigin, "*")
	res := new(Result)
	params := switchMachine.SwitchDeleteParams{}
	err := request.ReadEntity(&params)
	if err != nil {
		res.Code = 500
		res.Message = err.Error()
		return
	}
	err = h.svc.DeleteSwitchInfo(params)
	if err != nil {
		res.Code = 500
		res.Message = err.Error()
		response.WriteAsJson(res)
		return
	}
	res.Code = 200
	res.Message = "success"
	response.WriteAsJson(res)
}

//待讨论确定
func (h *Handler) addSwitch(request *restful.Request, response *restful.Response) {
	response.AddHeader(restful.HEADER_AccessControlAllowOrigin, "*")
	res := new(Result)
	// Authorization := request.HeaderParameter("Authorization")
	// if Authorization == "" {
	// 	res.Code = 500
	// 	res.Message = "Authorization does not exist"
	// 	response.WriteAsJson(res)
	// 	return
	// }
	// userName, err := service.GetUserName(Authorization)
	// if err != nil {
	// 	res.Code = 500
	// 	res.Message = "invalid Authorization. err: " + err.Error()
	// 	response.WriteAsJson(res)
	// 	return
	// }
	userName := request.HeaderParameter("x-auth-username")
	file, _, err := request.Request.FormFile("file")
	f, err := utils.ReadExcel(file)
	if err != nil {
		res.Code = 500
		res.Message = err.Error()
		res.Data = map[string]interface{}{
			"code": 5001,
		}
		response.WriteAsJson(res)
		return
	}
	rows, err := f.Rows(f.GetSheetMap()[1])
	if err != nil {
		res.Code = 500
		res.Message = err.Error()
		res.Data = map[string]interface{}{
			"code": 5001,
		}
		response.WriteAsJson(res)
		return
	}
	xlsMap, err := utils.Rows2Map(rows)
	if err != nil {
		res.Code = 500
		res.Message = err.Error()
		res.Data = map[string]interface{}{
			"code": 5001,
		}
		response.WriteAsJson(res)
		return
	}
	switchList, err := service.XlsToSwitch(xlsMap, userName)
	if err != nil {
		res.Code = 500
		res.Message = err.Error()
		response.WriteAsJson(res)
		return
	}
	params := switchMachine.SwitchAddParams{Switchs: switchList}
	err = h.svc.AddSwitchInfo(params)
	if err != nil {
		res.Code = 500
		res.Message = err.Error()
		response.WriteAsJson(res)
		return
	}
	res.Code = 200
	res.Message = "success"
	response.WriteAsJson(res)
}

func (h *Handler) updateSwitch(request *restful.Request, response *restful.Response) {
	response.AddHeader(restful.HEADER_AccessControlAllowOrigin, "*")
	res := new(Result)
	params := switchMachine.SwitchUpdateParams{}
	//params := switchMachine.MysqlSwitch{}
	err := request.ReadEntity(&params)
	if err != nil {
		res.Code = 500
		res.Message = err.Error()
		response.WriteAsJson(res)
		return
	}
	if params.RackId > 0 && params.SwitchUnitNumber <= 0 {
		res.Code = 500
		res.Message = "switchUnitNumber cannot be zero"
		response.WriteAsJson(res)
		return
	}

	if params.SwitchRole == "" {
		res.Code = 500
		res.Message = "SwitchRole cannot be zero"
		response.WriteAsJson(res)
		return
	}

	// TODO：注意！！！！ 这里将为适配前端做了下转化
	az, err := basic.QueryAzByAzCode(params.AzCode)
	if err != nil {
		res.Code = 500
		res.Message = err.Error()
		response.WriteAsJson(res)
		return
	}

	var (
		maintenanceDue time.Time
		inputTime      time.Time
	)

	if params.MaintenanceDue > 0 {
		maintenanceDue = time.Unix(params.MaintenanceDue, 0)
	}
	if params.InputTime > 0 {
		inputTime = time.Unix(params.InputTime, 0)
	}

	//接口传labCode，转为labId后写入数据库
	var labId int
	if params.LabCode != "" {
		lb, err := labdao.GetLabByCode(params.LabCode)
		if err != nil {
			res.Code = 500
			res.Message = "labCode 查询错误"
			response.WriteAsJson(res)
			return
		}
		labId = lb.Id
	} else {
		labId = -1
	}

	//处理前端传空，想置零，但是orm无法更新零值的问题
	roomId := -1
	cabinetId := -1
	rackId := -1
	if params.RoomId != 0 {
		roomId = params.RoomId
	}
	if params.CabinetId != 0 {
		cabinetId = params.CabinetId
	}
	if params.RackId != 0 {
		rackId = params.RackId
	}

	mySwitch := switchMachine.MysqlSwitch{
		Uid:       params.Uid,
		Name:      params.Name,
		Ip:        params.Ip,
		RunStatus: params.RunStatus,
		//AzId : params.AzId,
		AzId:              az.Id, // TODO: 这里后续也需要修改回来
		RegionId:          params.RegionId,
		LabId:             labId,
		RoomId:            roomId,
		CabinetId:         cabinetId,
		RackId:            rackId,
		SwitchUnitNumber:  params.SwitchUnitNumber,
		Sn:                params.Sn,
		SwitchType:        params.SwitchType,
		SwitchRole:        params.SwitchRole,
		OutBandIp:         params.OutBandIp,
		MainMaintainer:    params.MainMaintainer,
		MaintenanceDue:    maintenanceDue,
		MaintenanceStatus: params.MaintenanceStatus,
		AssetsNumber:      params.AssetsNumber,
		//InputTime:         time.Unix(params.InputTime, 0),
		InputTime:       inputTime,
		SystemSales:     params.SystemSales,
		HardwareVersion: params.HardwareVersion,
		OsVersion:       params.OsVersion,
		Description:     params.Description,
		Creator:         params.Creator,
		Updater:         params.Updater,
		OperateSystem:   params.OperateSystem,
	}
	err = h.svc.UpdateSwitchInfo(mySwitch)
	if err != nil {
		res.Code = 500
		res.Message = err.Error()
		response.WriteAsJson(res)
		return
	}

	res.Code = 200
	res.Message = "success"
	response.WriteAsJson(res)
}

func (h *Handler) overview(request *restful.Request, response *restful.Response) {
	response.AddHeader(restful.HEADER_AccessControlAllowOrigin, "*")
	res := new(Result)
	regionCode := request.QueryParameter("region")
	azCode := request.QueryParameter("az")
	overview, err := h.svc.SwitchOverview(regionCode, azCode)
	if err != nil {
		res.Code = 500
		res.Message = err.Error()
		response.WriteAsJson(res)
		return
	}
	res.Code = 200
	res.Message = "success"
	res.Data = overview
	response.WriteAsJson(res)
}

func (h *Handler) getInterfaceLayoutHandler(request *restful.Request, response *restful.Response) {
	//response.AddHeader(restful.HEADER_AccessControlAllowOrigin, "*")
	//res := new(Result)
	//response.WriteAsJson(res)
	response.AddHeader(restful.HEADER_AccessControlAllowOrigin, "*")
	res := new(Result)
	//params := switchMachine.SwitchInterfaceLayoutListParams{}
	sn := request.QueryParameter("sn")
	if sn == "" {
		res.Code = 500
		res.Message = "invalid Sn"
		response.WriteAsJson(res)
		return
	}
	var err error
	res.Data, err = h.svc.GetSwitchLayout(sn)
	if err != nil {
		res.Code = 500
		res.Message = err.Error()
		response.WriteAsJson(res)
		return
	}
	res.Code = 200
	res.Message = "success"
	response.WriteAsJson(res)
}

func (h *Handler) postSwitchInterfaceInfoList(request *restful.Request, response *restful.Response) {
	response.AddHeader(restful.HEADER_AccessControlAllowOrigin, "*")
	res := new(Result)
	params := switchMachine.SwitchInterfaceLayoutListParams{}
	err := request.ReadEntity(&params)
	if err != nil {
		res.Code = 500
		res.Message = err.Error()
		response.WriteAsJson(res)
		return
	}
	total, details, err := h.svc.GetSwitchInterfaceInfoList(params)
	if err != nil {
		res.Code = 500
		res.Message = err.Error()
		response.WriteAsJson(res)
		return
	}
	res.Data = switchMachine.SwitchInterfaceInfoResult{
		PageSize:   params.PageSize,
		PageNo:     params.PageNo,
		TotalCount: total,
		DataList:   details,
	}
	res.Code = 200
	res.Message = "success"
	response.WriteAsJson(res)
}

func (h *Handler) postSwitchInterfaceDetails(request *restful.Request, response *restful.Response) {
	response.AddHeader(restful.HEADER_AccessControlAllowOrigin, "*")
	res := new(Result)
	params := switchMachine.SwitchInterfaceLayoutListParams{}
	err := request.ReadEntity(&params)
	if err != nil {
		res.Code = 500
		res.Message = err.Error()
		response.WriteAsJson(res)
		return
	}

	details, err := h.svc.GetSwitchInterfaceDetails(params.Sn, params.Index)
	if err != nil {
		res.Code = 500
		res.Message = err.Error()
		response.WriteAsJson(res)
		return
	}
	res.Data = switchMachine.SwitchInterfaceDetailResult{
		DataList: details,
	}
	res.Code = 200
	res.Message = "success"
	response.WriteAsJson(res)
}

func (h *Handler) getSwitchPartsAndView(request *restful.Request, response *restful.Response) {
	//response.AddHeader(restful.HEADER_AccessControlAllowOrigin, "*")
	//res := new(Result)
	//response.WriteAsJson(res)
	response.AddHeader(restful.HEADER_AccessControlAllowOrigin, "*")
	res := new(Result)
	//params := switchMachine.SwitchInterfaceLayoutListParams{}
	sn := request.QueryParameter("sn")
	if sn == "" {
		res.Code = 500
		res.Message = "invalid Sn"
		response.WriteAsJson(res)
		return
	}
	var err error
	res.Data, err = h.svc.GetSwitchPartsAndView(sn)
	if err != nil {
		res.Code = 500
		res.Message = err.Error()
		response.WriteAsJson(res)
		return
	}
	res.Code = 200
	res.Message = "success"
	response.WriteAsJson(res)
}

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/pkg/api/switch/result.go
```golang
package switchMachine

type Result struct {
	Code    int         `json:"code"`
	Message string      `json:"message"`
	Data    interface{} `json:"data"`
}
```

File path: /Users/mac/Desktop/woker_code/cmdb-api/pkg/api/rack/register.go
```golang
package rack

import (
	"github.com/dgraph-io/dgo/v200"
	"github.com/emicklei/go-restful"
	restfulspec "github.com/emicklei/go-restful-openapi"
	"luban-cmdb-api/pkg/models/rack"
	"luban-cmdb-api/pkg/runtime"
	"luban-cmdb-api/pkg/service"
)

const APIGroup = "rack"

func AddToContainer(c *restful.Container, dgraphclient *dgo.Dgraph) error {
	ws := runtime.NewWebService(APIGroup)
	rackTag := []string{"rack"}
	basicService := service.NewBasicService(dgraphclient, nil)
	rackService := service.NewRackService(dgraphclient, basicService)
	handler := NewHandler(rackService)
	ws.Route(ws.POST("/list").To(handler.getRackList).
		Doc("获取机架位列表").
		Reads(rack.QueryRackParam{}, rack.GetRackListDoc).
		Metadata(restfulspec.KeyOpenAPITags, rackTag).
		Returns(200, "OK", rack.RackListResponse{}))
	ws.Route(ws.POST("/listByCabinetId").To(handler.getRackListByCabinetId).
		Doc("根据机柜获取机架位列表").
		Reads(rack.QueryRackByCabinetParam{}, "cabinetId:机柜ID列表").
		Metadata(restfulspec.KeyOpenAPITags, rackTag).
		Returns(200, "OK", rack.SimpleSliceResponse{}))
	c.Add(ws)

	return nil
}

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/pkg/api/rack/handler.go
```golang
package rack

import (
	"github.com/emicklei/go-restful"
	"luban-cmdb-api/pkg/models/rack"
)

type RackService interface {
	GetRackList(params rack.QueryRackParam) (rack.RackListResponse, error)
	GetRackListByCabinetId(params rack.QueryRackByCabinetParam) (rack.SimpleSliceResponse, error)
}

type Handler struct {
	svc RackService
}

func NewHandler(service RackService) *Handler {
	return &Handler{
		svc: service,
	}
}

func (h *Handler) getRackList(request *restful.Request, response *restful.Response) {
	response.AddHeader(restful.HEADER_AccessControlAllowOrigin, "*")
	res := new(Result)
	params := rack.QueryRackParam{}
	error := request.ReadEntity(&params)
	if error != nil {
		res.Code = 500
		res.Message = error.Error()
		response.WriteAsJson(res)
		return
	}
	rackList, err := h.svc.GetRackList(params)
	if err != nil {
		res.Code = 500
		res.Message = err.Error()
		response.WriteAsJson(res)
		return
	}
	res.Code = 200
	res.Message = "success"
	res.Data = rackList
	response.WriteAsJson(res)
}

func (h *Handler) getRackListByCabinetId(request *restful.Request, response *restful.Response) {
	response.AddHeader(restful.HEADER_AccessControlAllowOrigin, "*")
	res := new(Result)
	params := rack.QueryRackByCabinetParam{}
	error := request.ReadEntity(&params)
	if error != nil {
		res.Code = 500
		res.Message = error.Error()
		response.WriteAsJson(res)
		return
	}
	rackList, err := h.svc.GetRackListByCabinetId(params)
	if err != nil {
		res.Code = 500
		res.Message = err.Error()
		response.WriteAsJson(res)
		return
	}
	res.Code = 200
	res.Message = "success"
	res.Data = rackList
	response.WriteAsJson(res)
}

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/pkg/api/rack/result.go
```golang
package rack

type Result struct {
	Code    int         `json:"code"`
	Message string      `json:"message"`
	Data    interface{} `json:"data"`
}

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/pkg/api/deviceroom/register.go
```golang
package deviceroom

import (
	"fmt"
	"luban-cmdb-api/pkg/models"
	"luban-cmdb-api/pkg/models/deviceroom"
	"luban-cmdb-api/pkg/restfulapi"
	"luban-cmdb-api/pkg/service"
	"strconv"
	"strings"

	"github.com/emicklei/go-restful"
	"github.com/go-playground/validator/v10"
)

const (
	ApiGroupName = "deviceRoom"
)

type QueryParameter struct {
	restfulapi.PageQuery
	RoomId           int    `json:"deviceRoomId,omitempty" argType:"query" argDoc:"房间ID"`
	RoomName         string `json:"deviceRoomName,omitempty" argType:"query" argDoc:"房间名称"`
	RoomCode         string `json:"deviceRoomCode,omitempty" argType:"query" argDoc:"房间代码code"`
	ComputerRoomName string `json:"computerRoomName,omitempty" argType:"query" argDoc:"机房名称"`
	ComputerRoomCode string `json:"computerRoomCode,omitempty" argType:"query" argDoc:"机房code"`
	SearchType       string `json:"searchType,omitempty" argType:"query" argDoc:"模糊查询类型，deviceRoomName：房间名称，deviceRoomId：房间id，deviceRoomCode：房间code，computerRoomName：机房名称，computerRoomCode：机房code"`
	SearchValue      string `json:"searchValue,omitempty" argType:"query" argDoc:"模糊查询值"`
	RegionCode       string `json:"regionCode,omitempty" argType:"query" argDoc:"区域的code"`
	AzCode           string `json:"azCode,omitempty" argType:"query" argDoc:"可用区code"`
}

type PostPageQueryBody struct {
	QueryParameter
	ExactComputerRoomCode []string `json:"exactComputerRoomCode" argDoc:"机房的ID列表"`
	ExactAzCode           []string `json:"exactAzCode" argType:"query" argDoc:"可用区code列表"`
}

type PostPageQueryParameter struct {
	restfulapi.CommonParameter
	TargetParameter PostPageQueryBody `json:"body" argType:"body" argDoc:"分页查询参数"`
}

func (queryParam *QueryParameter) SetSearchCondition() error {
	if queryParam.SearchType != "" && queryParam.SearchValue != "" {
		switch queryParam.SearchType {
		case "deviceRoomName":
			if queryParam.RoomName == "" {
				queryParam.RoomName = queryParam.SearchValue
			} else {
				queryParam.RoomName = queryParam.RoomName + "," + queryParam.SearchValue
			}
		case "deviceRoomId":
			//queryParam.RoomId = queryParam.SearchValue
			r, _ := strconv.ParseInt(queryParam.SearchValue, 10, 64)
			queryParam.RoomId = int(r)
		case "deviceRoomCode":
			if queryParam.RoomCode == "" {
				queryParam.RoomCode = queryParam.SearchValue
			} else {
				queryParam.RoomCode = queryParam.RoomCode + "," + queryParam.SearchValue
			}
		case "computerRoomName":
			if queryParam.ComputerRoomCode == "" {
				queryParam.ComputerRoomName = queryParam.SearchValue
			} else {
				queryParam.ComputerRoomName = queryParam.ComputerRoomName + "," + queryParam.SearchValue
			}
		case "computerRoomCode":
			if queryParam.ComputerRoomCode == "" {
				queryParam.ComputerRoomCode = queryParam.SearchValue
			} else {
				queryParam.ComputerRoomCode = queryParam.ComputerRoomCode + "," + queryParam.SearchValue
			}
		default:
			return fmt.Errorf("unknown search type: %s", queryParam.SearchType)
		}
	}

	if strings.ToLower(queryParam.ComputerRoomCode) == "all" {
		queryParam.ComputerRoomCode = ""
	}
	// if strings.ToLower(queryParam.AzCode) == "all" {
	// 	queryParam.AzCode = ""
	// }
	if strings.ToLower(queryParam.RegionCode) == "all" {
		queryParam.RegionCode = ""
	}
	if strings.ToLower(queryParam.RoomCode) == "all" {
		queryParam.RoomCode = ""
	}
	return nil
}

func (queryParam *QueryParameter) pageQueryCondition() error {
	if queryParam.SearchType != "" && queryParam.SearchValue != "" {
		switch queryParam.SearchType {
		case "deviceRoomName":
			queryParam.RoomName = queryParam.SearchValue
		case "deviceRoomId":
			r, _ := strconv.ParseInt(queryParam.SearchValue, 10, 64)
			queryParam.RoomId = int(r)
		case "deviceRoomCode":
			queryParam.RoomCode = queryParam.SearchValue
		case "computerRoomName":
			queryParam.ComputerRoomName = queryParam.SearchValue
		default:
			//return fmt.Errorf("unknown search type: %s", queryParam.SearchType)
		}
	}

	if strings.ToLower(queryParam.ComputerRoomCode) == "all" {
		queryParam.ComputerRoomCode = ""
	}
	if strings.ToLower(queryParam.RegionCode) == "all" {
		queryParam.RegionCode = ""
	}
	if strings.ToLower(queryParam.AzCode) == "all" {
		queryParam.AzCode = ""
	}
	return nil
}

type RoomBodyParameter struct {
	restfulapi.CommonParameter
	TargetDeviceRoom CreateRoomBody `json:"targetDeviceRoom" argType:"body" argDoc:"房间信息"`
}

type QueryDeviceRoomParameter struct {
	Id int `json:"id" argType:"path" argDoc:"查询的房间的ID"`
}

type BatchQueryParameter struct {
	TargetQueryData BatchQueryBody `json:"targetQueryData" argType:"body" argDoc:"批量查询的参数"`
}

type BatchQueryBody struct {
	ExactComputerCode []string `json:"exactComputerCode" argDoc:"机房的Code列表"`
	ExactAzCode       []string `json:"exactAzCode,omitempty" argDoc:"准确的az code查询"`
	RegionCode        string   `json:"regionCode,omitempty" argDoc:"区域的code"`
	AzCode            string   `json:"azCode,omitempty" argDoc:"可用区code"`
}

type IdHolder struct {
	DeviceRoomIds []int `json:"deviceRoomId" argType:"body" argDoc:"要删除的房间ID列表"`
}

type DeleteDeviceRoomParameter struct {
	restfulapi.CommonParameter
	TargetIds IdHolder `json:"targetIds" argType:"body" argDoc:"删除房间的信息"`
}

type RoomPageResult struct {
	models.CommonListPagination
	Data []RoomInfo `json:"dataList" argDoc:"房间列表数据"`
}

type Contact struct {
	ContactId          int    `json:"deviceRoomContactId,omitempty" argType:"body" argDoc:"房间联系人id"`
	ContactName        string `json:"deviceRoomContactName,omitempty" argType:"body" argDoc:"房间联系人名称" validate:"required"`
	ContactPhoneNumber string `json:"deviceRoomContactPhoneNumber,omitempty" argType:"body" argDoc:"房间联系人手机号" validate:"required"`
}

type Room struct {
	RoomId            int       `json:"deviceRoomId,omitempty" argType:"body" argDoc:"房间ID，自动生成，创建不需要，更新必须传"`
	RoomName          string    `json:"deviceRoomName,omitempty" argType:"body" argDoc:"房间名称，必填，不能重复" validate:"required"`
	RoomCode          string    `json:"deviceRoomCode,omitempty" argType:"body" argDoc:"房间Code，必填，不能重复" validate:"required"`
	RoomDesc          string    `json:"deviceRoomDesc,omitempty" argType:"body" argDoc:"房间描述说明"`
	RoomMainContact   Contact   `json:"deviceRoomMainContact,omitempty" argType:"body" argDoc:"房间主要联系人" validate:"required"`
	RoomOtherContacts []Contact `json:"deviceRoomOtherContacts,omitempty" argType:"body" argDoc:"房间次要联系人"`
	RoomCreateTime    string    `json:"deviceRoomCreateTime" argType:"body" argDoc:"创建时间"`
	RoomUpdateTime    string    `json:"deviceRoomUpdateTime" argType:"body" argDoc:"更新时间"`
	RoomCreator       string    `json:"deviceRoomCreator,omitempty" argDoc:"创建人"`
	AzCode            string    `json:"azCode,omitempty" argDoc:"可用区code，创建可不传，不可更新"`
	AzName            string    `json:"azName,omitempty" argType:"body" argDoc:"可用区的名称"`
	RegionCode        string    `json:"regionCode,omitempty" argDoc:"区域code，创建可不传，不可更新"`
}

type CreateRoomBody struct {
	Room
	ComputerRoomId int `json:"computerRoomId,omitempty" argType:"body" argDoc:"机房id" validate:"required"`
}

type RoomInfo struct {
	Room
	AzName           string `json:"azName,omitempty" argType:"body" argDoc:"可用区的名称"`
	RegionName       string `json:"regionName,omitempty" argType:"body" argDoc:"区域的名称"`
	ComputerRoomId   int    `json:"computerRoomId" argType:"body" argDoc:"机房id" validate:"required"`
	ComputerRoomCode string `json:"computerRoomCode" argType:"body" argDoc:"机房的code"`
	ComputerRoomName string `json:"computerRoomName" argType:"body" argDoc:"机房的名称"`
	CabinetNum       int    `json:"cabinetNum" argType:"body" argDoc:"机柜数量"`
	RackNum          int    `json:"rackNum" argType:"body" argDoc:"机架数量"`
	UsedUNum         int    `json:"usedUNum" argType:"body" argDoc:"已使用的U位数量"`
	UnusedUNum       int    `json:"unusedUNum" argType:"body" argDoc:"未使用的U位数量"`
}

func (r *Room) ToDbRoom() *deviceroom.DeviceRoom {
	dbRoom := &deviceroom.DeviceRoom{
		Uid:               r.RoomId,
		DeviceRoomName:    r.RoomName,
		DeviceRoomCode:    r.RoomCode,
		DeviceRoomDesc:    r.RoomDesc,
		DeviceRoomCreator: r.RoomCreator,
		DeviceRoomMainContact: deviceroom.Contact{
			Uid:                          r.RoomMainContact.ContactId,
			DeviceRoomContactName:        r.RoomMainContact.ContactName,
			DeviceRoomContactPhoneNumber: r.RoomMainContact.ContactPhoneNumber,
		},
		DeviceRoomOtherContacts: []deviceroom.Contact{},
		AzCode:                  r.AzCode,
		RegionCode:              r.RegionCode,
	}
	for _, item := range r.RoomOtherContacts {
		dbRoom.DeviceRoomOtherContacts = append(dbRoom.DeviceRoomOtherContacts, deviceroom.Contact{
			Uid:                          item.ContactId,
			DeviceRoomContactName:        item.ContactName,
			DeviceRoomContactPhoneNumber: item.ContactPhoneNumber,
		})
	}
	return dbRoom
}

func (r *CreateRoomBody) ToDbRoomWithComputerRoomId() *deviceroom.DeviceRoom {
	dbRoom := &deviceroom.DeviceRoom{
		Uid:               r.RoomId,
		DeviceRoomName:    r.RoomName,
		DeviceRoomCode:    r.RoomCode,
		DeviceRoomDesc:    r.RoomDesc,
		DeviceRoomCreator: r.RoomCreator,
		DeviceRoomMainContact: deviceroom.Contact{
			Uid:                          r.RoomMainContact.ContactId,
			DeviceRoomContactName:        r.RoomMainContact.ContactName,
			DeviceRoomContactPhoneNumber: r.RoomMainContact.ContactPhoneNumber,
		},
		DeviceRoomOtherContacts: []deviceroom.Contact{},
		RegionCode:              r.RegionCode,
		AzCode:                  r.AzCode,
	}
	for _, item := range r.RoomOtherContacts {
		dbRoom.DeviceRoomOtherContacts = append(dbRoom.DeviceRoomOtherContacts, deviceroom.Contact{
			DeviceRoomContactName:        item.ContactName,
			DeviceRoomContactPhoneNumber: item.ContactPhoneNumber,
		})
	}
	dbRoom.DeviceRoomComputerRoomId = r.ComputerRoomId
	return dbRoom
}

func (rInfo *RoomInfo) LoadFullFromDbRoomInfo2(dbRoom *deviceroom.RoomFullInfo2) *RoomInfo {
	rInfo.RoomId = dbRoom.Uid
	rInfo.RoomName = dbRoom.DeviceRoomName
	rInfo.RoomCode = dbRoom.DeviceRoomCode
	rInfo.RoomDesc = dbRoom.DeviceRoomDesc
	rInfo.RoomCreateTime = dbRoom.DeviceRoomCreateTime.Format("2006-01-02 15:04:05")
	rInfo.RoomUpdateTime = dbRoom.DeviceRoomUpdateTime.Format("2006-01-02 15:04:05")
	rInfo.RoomCreator = dbRoom.DeviceRoomCreator
	rInfo.AzCode = dbRoom.AzCode
	rInfo.AzName = dbRoom.AzName
	rInfo.RegionCode = dbRoom.RegionCode
	rInfo.RoomMainContact = Contact{
		ContactId:          dbRoom.DeviceRoomMainContact.Uid,
		ContactName:        dbRoom.DeviceRoomMainContact.DeviceRoomContactName,
		ContactPhoneNumber: dbRoom.DeviceRoomMainContact.DeviceRoomContactPhoneNumber,
	}
	for _, item := range dbRoom.DeviceRoomOtherContacts {
		rInfo.RoomOtherContacts = append(rInfo.RoomOtherContacts, Contact{
			ContactId:          item.Uid,
			ContactName:        item.DeviceRoomContactName,
			ContactPhoneNumber: item.DeviceRoomContactPhoneNumber,
		})
	}
	rInfo.ComputerRoomId = dbRoom.LabId
	rInfo.ComputerRoomName = dbRoom.LabName
	rInfo.ComputerRoomCode = dbRoom.LabCode
	rInfo.CabinetNum = dbRoom.CabinetNum
	return rInfo
}

type Controller struct {
	service    *service.DeviceRoomService
	labService *service.LabService
}

func (drs *Controller) Init(server *restfulapi.ServerContext) error {
	drs.service = service.NewDeviceRoomService()
	drs.labService = service.NewLabService(server.DgraphClient)
	return nil
}

func (drs *Controller) GroupName() string {
	return ApiGroupName
}

func (drs *Controller) Register() []*restfulapi.ApiDefinition {
	return []*restfulapi.ApiDefinition{
		{
			Path:       "/",
			Method:     restfulapi.ApiMethodGet,
			Doc:        "分页查询房间信息，废弃",
			Parameter:  QueryParameter{},
			ReturnData: RoomPageResult{},
			Tags:       []string{"deviceRoom"},
			Handler:    drs.pageQueryHandler,
		}, {
			Path:       "/postPageQuery",
			Method:     restfulapi.ApiMethodPost,
			Doc:        "以post请求的方式分页查询房间信息",
			Parameter:  PostPageQueryParameter{},
			ReturnData: RoomPageResult{},
			Tags:       []string{"deviceRoom"},
			Handler:    drs.postPageQueryHandler,
		}, {
			Path:      "/",
			Method:    restfulapi.ApiMethodPatch,
			Doc:       "修改房间",
			Parameter: RoomBodyParameter{},
			Tags:      []string{"deviceRoom"},
			Handler:   drs.modifyRoomHandler,
		}, {
			Path:      "/",
			Method:    restfulapi.ApiMethodPost,
			Doc:       "创建房间",
			Parameter: RoomBodyParameter{},
			Tags:      []string{"deviceRoom"},
			Handler:   drs.createRoomHandler,
		}, {
			Path:      "/",
			Method:    restfulapi.ApiMethodDelete,
			Doc:       "批量删除房间",
			Parameter: DeleteDeviceRoomParameter{},
			Tags:      []string{"deviceRoom"},
			Handler:   drs.deleteRoomHandler,
		}, {
			Path:       "/{id}",
			Method:     restfulapi.ApiMethodGet,
			Doc:        "查询指定房间基本信息",
			Parameter:  QueryDeviceRoomParameter{},
			ReturnData: RoomInfo{},
			Tags:       []string{"deviceRoom"},
			Handler:    drs.queryRoomHandler,
		}, {
			Path:       "/batchQuery",
			Method:     restfulapi.ApiMethodPost,
			Doc:        "用于大量参数的批量查询",
			Parameter:  BatchQueryParameter{},
			ReturnData: []RoomInfo{},
			Tags:       []string{"deviceRoom"},
			Handler:    drs.batchQueryHandler,
		},
	}
}

func (drs *Controller) batchQueryHandler(input interface{}, request *restful.Request, response *restful.Response) (interface{}, error) {
	queryParam := input.(BatchQueryParameter)
	queryData := queryParam.TargetQueryData
	param := service.ExactQueryParameter{
		ComputerRoomCode: queryData.ExactComputerCode,
		AzCode:           queryData.ExactAzCode,
	}
	if queryData.AzCode != "" && queryData.AzCode != "all" {
		param.AzCode = []string{
			queryData.AzCode,
		}
	}
	if queryData.RegionCode != "" && queryData.RegionCode != "all" {
		param.RegionCode = []string{
			queryData.RegionCode,
		}
	}
	data, err := drs.service.QueryWithExactCondition(param)
	if err != nil {
		return nil, err
	}
	var rs = make([]RoomInfo, 0)
	//labMap := make(map[string]lab.LabInfo)
	for _, item := range data {
		rm := RoomInfo{}
		rm.LoadFullFromDbRoomInfo2(&item)
		rs = append(rs, rm)
	}
	return rs, nil
}

func (drs *Controller) postPageQueryHandler(input interface{}, request *restful.Request, response *restful.Response) (interface{}, error) {
	parameter := input.(PostPageQueryParameter)
	targetParameter := parameter.TargetParameter

	err := targetParameter.pageQueryCondition()
	if err != nil {
		return nil, err
	}
	//组合az code和region code
	if targetParameter.ComputerRoomCode != "" {
		targetParameter.ExactComputerRoomCode = append(targetParameter.ExactComputerRoomCode, targetParameter.ComputerRoomCode)
	}
	if targetParameter.AzCode != "" {
		targetParameter.ExactAzCode = append(targetParameter.ExactAzCode, targetParameter.AzCode)
	}
	matchQueryParam := service.MatchQueryParameter{
		DeviceRoomCode:        targetParameter.RoomCode,
		DeviceRoomName:        targetParameter.RoomName,
		DeviceRoomId:          targetParameter.RoomId,
		ComputerRoomName:      targetParameter.ComputerRoomName,
		ExactAzCode:           targetParameter.ExactAzCode,
		ExactComputerRoomCode: targetParameter.ExactComputerRoomCode,
		RegionCode:            targetParameter.RegionCode,
	}
	pageData, err := drs.service.QueryFullInfoByPage(targetParameter.Page, targetParameter.Size, matchQueryParam)
	if err != nil {
		return nil, err
	}
	pageResult := RoomPageResult{
		Data: []RoomInfo{},
	}
	pageResult.PageNo = targetParameter.Page
	pageResult.PageSize = targetParameter.Size
	pageResult.TotalCount = pageData.Total
	//labMap := make(map[string]lab.LabInfo)
	for _, item := range pageData.Rooms {
		room := RoomInfo{}
		room.LoadFullFromDbRoomInfo2(&item)
		pageResult.Data = append(pageResult.Data, room)
	}
	return pageResult, nil
}

func (drs *Controller) pageQueryHandler(input interface{}, request *restful.Request, response *restful.Response) (interface{}, error) {
	query := input.(QueryParameter)
	err := query.SetSearchCondition()
	if err != nil {
		return nil, err
	}

	matchQueryParam := service.MatchQueryParameter{
		DeviceRoomCode:   query.RoomCode,
		DeviceRoomName:   query.RoomName,
		DeviceRoomId:     query.RoomId,
		ComputerRoomCode: query.ComputerRoomCode,
		ComputerRoomName: query.ComputerRoomName,
		AzCode:           query.AzCode,
		RegionCode:       query.RegionCode,
	}
	pageData, err := drs.service.QueryFullInfoByPage(query.Page, query.Size, matchQueryParam)
	if err != nil {
		return nil, err
	}
	pageResult := RoomPageResult{
		Data: []RoomInfo{},
	}
	pageResult.PageNo = query.Page
	pageResult.PageSize = query.Size
	pageResult.TotalCount = pageData.Total
	for _, item := range pageData.Rooms {
		room := RoomInfo{}
		room.LoadFullFromDbRoomInfo2(&item)
		pageResult.Data = append(pageResult.Data, room)
	}
	return pageResult, nil
}

func (drs *Controller) createRoomHandler(input interface{}, request *restful.Request, response *restful.Response) (interface{}, error) {
	parameter := input.(RoomBodyParameter)
	// authToken := parameter.Authorization
	// userName, err := service.GetUserName(authToken)
	// if err != nil {
	// 	return nil, err
	// }
	username := request.HeaderParameter("x-auth-username")
	room := parameter.TargetDeviceRoom
	room.RoomCreator = username //"userName"
	err := validator.New().Struct(parameter.TargetDeviceRoom)
	if err != nil {
		return nil, err
	}
	err = drs.service.Create(room.ToDbRoomWithComputerRoomId())
	if err != nil {
		return nil, err
	}
	return nil, nil
}

func (drs *Controller) modifyRoomHandler(input interface{}, request *restful.Request, response *restful.Response) (interface{}, error) {
	parameter := input.(RoomBodyParameter)
	// authToken := parameter.Authorization
	// user, err := service.GetUserName(authToken)
	// if err != nil {
	// 	return nil, err
	// }
	userName := request.HeaderParameter("x-auth-username")
	room := parameter.TargetDeviceRoom
	err := drs.service.Update(room.ToDbRoomWithComputerRoomId(), userName)
	if err != nil {
		return nil, err
	}
	return nil, nil
}

func (drs *Controller) deleteRoomHandler(input interface{}, request *restful.Request, response *restful.Response) (interface{}, error) {
	parameter := input.(DeleteDeviceRoomParameter)
	// username, err := service.GetUserName(parameter.Authorization)
	// if err != nil {
	// 	return nil, err
	// }
	userName := request.HeaderParameter("x-auth-username")
	err := drs.service.DeleteByIds(parameter.TargetIds.DeviceRoomIds, userName)
	if err != nil {
		return nil, err
	}
	return nil, nil
}

func (drs *Controller) queryRoomHandler(input interface{}, request *restful.Request, response *restful.Response) (interface{}, error) {
	parameter := input.(QueryDeviceRoomParameter)
	dbRoom := drs.service.QueryById(parameter.Id)
	room := RoomInfo{}
	room.LoadFullFromDbRoomInfo2(&dbRoom)
	labInfo, err := drs.labService.LabDetail(room.ComputerRoomId)
	if err != nil {
		return nil, fmt.Errorf("can't find computer room %d", room.ComputerRoomId)
	}
	room.AzName = labInfo.AzName
	room.RegionName = labInfo.RegionName
	room.ComputerRoomCode = labInfo.LabCode
	room.ComputerRoomName = labInfo.LabName
	return room, nil
}

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/pkg/api/blockStoragePool/register.go
```golang
package blockStoragePool

import (
	"luban-cmdb-api/pkg/apiserver/config"
	"luban-cmdb-api/pkg/models/storage"
	"luban-cmdb-api/pkg/models/storagePool"
	"luban-cmdb-api/pkg/runtime"
	"luban-cmdb-api/pkg/service"

	"github.com/dgraph-io/dgo/v200"
	"github.com/emicklei/go-restful"
	restfulspec "github.com/emicklei/go-restful-openapi"
)

const APIGroup = "blockStoragePool"

func AddToContainer(c *restful.Container, dgraphclient *dgo.Dgraph, config *config.Config) error {
	ws := runtime.NewWebService(APIGroup)
	blockStoragePoolService := service.NewBlockStoragePoolService(config.EBSAddr, config.StorageStateAddr, dgraphclient)
	handler := NewHandler(dgraphclient, blockStoragePoolService)
	//块存储资源池
	tag1 := []string{"blockStoragePool"}
	//块存储资源池
	ws.Route(ws.POST("/").To(handler.getBlockStoragePoolHandler).
		Doc("Get block storage resource pool list./获取块存储资源池列表。").
		Metadata(restfulspec.KeyOpenAPITags, tag1).
		Reads(storage.BlockStoragePoolQuery{}, storage.BlockStoragePoolQueryDoc).
		Returns(200, "OK", Result{200, "", BlockStoragePoolListDataResult{}}))
	ws.Route(ws.GET("/detail/{name}").To(handler.getBlockStoragePoolDetailHandler).
		Doc("Get one pool detail./查询单个块存储资源池的资源详情").
		Metadata(restfulspec.KeyOpenAPITags, tag1).
		Param(ws.PathParameter("name", "Resource pool type").DataType("string").Required(true)).
		Returns(200, "OK", BlockStoragePoolData{}))
	ws.Route(ws.POST("disk/{name}").To(handler.getPoolDiskList).
		Doc("Get one pool disk list/查询单个块存储资源池的云硬盘列表").
		Metadata(restfulspec.KeyOpenAPITags, tag1).
		Param(ws.PathParameter("name", "The name of block storage pool").DataType("string").Required(true)).
		Reads(storage.BlockStoragePoolDiskQuery{}, storage.BlockStoragePoolDiskQueryDoc).
		Returns(200, "OK", storage.BlockStoragePoolDisk{}))
	ws.Route(ws.GET("stock/{name}").To(handler.getStock).
		Doc("Get stock./查询单个块存储资源池的库存").
		Metadata(restfulspec.KeyOpenAPITags, tag1).
		Param(ws.PathParameter("name", "The name of block storage pool").DataType("string").Required(true)).
		Param(ws.QueryParameter("pageNo", "Page number. e.g. `1`, default `1`").DataType("int")).
		Param(ws.QueryParameter("pageSize", "Page size. e.e.g `10` default `10`").DataType("int")).
		Param(ws.QueryParameter("orderCode", "The orderCode of order.eg:cpuUsage;memoryRate")).
		Param(ws.QueryParameter("orderType", "The orderType of order.eg:升：asc;降：desc")).
		Returns(200, "OK", storage.BlockStoragePoolStock{}))
	ws.Route(ws.POST("sliceList").To(handler.getPoolSliceList).
		Doc("Get one pool slice list/查询存储资源池分片信息").
		Metadata(restfulspec.KeyOpenAPITags, tag1).
		Param(ws.PathParameter("id", "The id of block storage pool").DataType("int").Required(true)).
		Param(ws.QueryParameter("pageNo", "Page number. e.g. `1`, default `1`").DataType("int")).
		Param(ws.QueryParameter("pageSize", "Page size. e.e.g `10` default `10`").DataType("int")).
		Returns(200, "OK", storagePool.StoragePoolSlice{}))
	c.Add(ws)
	return nil
}

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/pkg/api/blockStoragePool/handler.go
```golang
package blockStoragePool

import (
	"context"
	"encoding/json"
	"fmt"
	"luban-cmdb-api/pkg/models/storagePool"
	"sort"

	"github.com/dgraph-io/dgo/v200"
	"github.com/emicklei/go-restful"

	"luban-cmdb-api/pkg/api"
	"luban-cmdb-api/pkg/handler"
	"luban-cmdb-api/pkg/models"
	"luban-cmdb-api/pkg/models/storage"
	"luban-cmdb-api/pkg/service"
)

type BlockStoragePoolService interface {
	GetPoolDiskList(regionCode, poolName string, pageNo, pageSize int, azCode, state, cloudType []string) (*storage.BlockStoragePoolDisk, error)
	GetPoolStock(poolName string, pageNo, pageSize int) (*storage.BlockStoragePoolStock, error)
	GetBlockStoragePoolList(blockStoragePoolQuery storage.BlockStoragePoolQuery) ([]storage.BlockRe, error)
	GetPoolSliceStock(id, PageNo, PageSize int) ([]storagePool.StoragePoolSlice, error)
}

type Handler struct {
	dgraphClient *dgo.Dgraph
	svc          BlockStoragePoolService
}

func NewHandler(dgraphClient *dgo.Dgraph, svc BlockStoragePoolService) *Handler {
	return &Handler{
		dgraphClient: dgraphClient,
		svc:          svc,
	}
}

func (h *Handler) getBlockStoragePoolHandler(request *restful.Request, response *restful.Response) {
	response.AddHeader("Access-Control-Allow-Origin", "*")
	rst := new(Result)
	t := new(storage.BlockStoragePoolQuery)
	err := request.ReadEntity(&t)

	regionResult, err := h.GetBlockStoragePoolList(*t)
	if err != nil {
		rst.Code = 500
		rst.Message = err.Error()
		response.WriteAsJson(rst)
		return
	} else {
		rst.Code = 200
		rst.Message = "success"
		rst.Data = regionResult
		response.WriteAsJson(rst)
		return
	}

}

//查询对象资源池资源详情api
func (h *Handler) getBlockStoragePoolDetailHandler(request *restful.Request, response *restful.Response) {
	//instanceId := request.PathParameter("instanceId")
	response.AddHeader("Access-Control-Allow-Origin", "*")
	rst := new(Result)
	t := new(storage.BlockStoragePoolQuery)
	name := request.PathParameter("name")
	resourcePool := []string{name}
	t.ResourcePool = resourcePool
	t.RegionCode = "all"
	//t.AzCode = "all"
	//fmt.Println(*t)
	blockReReList, err := h.svc.GetBlockStoragePoolList(*t)
	if err != nil {
		rst.Code = 500
		rst.Message = err.Error()
		response.WriteAsJson(rst)
		return
	} else {
		blockRe := storage.BlockRe{}
		if len(blockReReList) > 0 {
			blockRe = blockReReList[0]
		}
		rst.Code = 200
		rst.Message = "success"
		rst.Data = blockRe
		response.WriteAsJson(rst)
		return
	}
}

//获取块存储资源池列表
func (h *Handler) GetBlockStoragePoolList(blockStoragePoolQuery storage.BlockStoragePoolQuery) (storage.BlockStoragePoolListDataResult, error) {
	var blockReList []storage.BlockRe
	var BlockStoragePoolDataResult storage.BlockStoragePoolListDataResult
	var err error
	blockReList, err = h.svc.GetBlockStoragePoolList(blockStoragePoolQuery)
	if err != nil {
		return BlockStoragePoolDataResult, err
	}

	//returnList, err := h.SortBlockStoragePoolList(blockStoragePoolQuery, blockReList)
	//if err != nil {
	//	return BlockStoragePoolDataResult, err
	//}

	//sort
	sort.Slice(blockReList, func(i, j int) bool {
		return blockReList[i].CreateTime > blockReList[j].CreateTime
	})
	returnList := blockReList

	low := (blockStoragePoolQuery.PageNo - 1) * blockStoragePoolQuery.PageSize
	high := (blockStoragePoolQuery.PageNo) * blockStoragePoolQuery.PageSize
	if high > len(returnList) {
		high = len(returnList)
	}
	BlockStoragePoolDataResult.TotalCount = len(returnList)
	returnList = returnList[low:high]
	for i := range returnList {
		blockReList = append(blockReList, returnList[i])
	}
	BlockStoragePoolDataResult.DataList = blockReList[low:high]

	return BlockStoragePoolDataResult, nil
}
func (h *Handler) SortBlockStoragePoolList(blockStoragePoolQuery storage.BlockStoragePoolQuery, list []storage.BlockRe) ([]interface{}, error) {
	results := service.Bucket{}
	sortList := make([]interface{}, len(list))
	for i := range list {
		sortList[i] = list[i]
	}
	results.Slice = sortList
	time_by := func(a, b interface{}) bool {
		return a.(storage.BlockRe).CreateTime > b.(storage.BlockRe).CreateTime
	}
	results.By = time_by
	sort.Sort(results)
	return results.Slice, nil
}

// //获取块存储资源列表单条数据
// func (h *Handler) GetBlockStoragePool(blockStoragePoolQuery BlockStoragePoolQuery) (BlockRe, error) {
// 	var qList []string
// 	qString := ""
// 	if blockStoragePoolQuery.RegionCode != "all" && blockStoragePoolQuery.RegionCode != "" {
// 		qList = append(qList, `eq(hostRegionCode, "`+blockStoragePoolQuery.RegionCode+`")`)
// 	}
// 	if blockStoragePoolQuery.AzCode != "all" && blockStoragePoolQuery.AzCode != "" {
// 		qList = append(qList, `eq(hostAzCode, "`+blockStoragePoolQuery.AzCode+`")`)
// 	}
// 	if blockStoragePoolQuery.Name != "" {
// 		qList = append(qList, `eq(serviceType, "`+blockStoragePoolQuery.Name+`")`)
// 	}
// 	q := `{
// 		hostCount(func:anyofterms(serviceType,"` + blockStoragePoolQuery.ResourcePool + `"))`
// 	if len(qList) > 0 {
// 		qString = "@filter(" + strings.Join(qList, "and ") + ")"
// 		q = q + qString
// 	}
// 	q = q + `   {
// 	count(uid)
// 	  }
// 	   host(func:eq(serviceType,"` + blockStoragePoolQuery.ResourcePool + `"),offset:0,first:1)

// 		 `

// 	if len(qList) > 0 {
// 		qString = "@filter(" + strings.Join(qList, "and ") + ")"
// 		q = q + qString
// 	}
// 	fmt.Println(qString)
// 	q += `  {
// 		id:uid
// 		name:serviceType
// 		regionName:hostRegionName
// 		regionCode:hostRegionCode
// 		azName:hostAzName
// 		resourcePool:serviceType
// 		attribute
// 		hostNumber
// 		cloudDiskNumber
// 	  }
// 	}`
// 	fmt.Println(q)
// 	var BlockStoragePoolResult BlockStoragePoolList
// 	var BlockReData BlockRe
// 	//var BlockStoragePoolDataResult BlockStoragePoolListDataResult
// 	resp, err := h.dgraphClient.NewTxn().Query(context.Background(), q)
// 	err = json.Unmarshal(resp.Json, &BlockStoragePoolResult)
// 	if err != nil {
// 		fmt.Println(err)
// 		return BlockReData, err
// 	}
// 	if len(BlockStoragePoolResult.Host) > 0 {
// 		BlockReData = BlockStoragePoolResult.Host[0]
// 		BlockReData.HostNumber = BlockStoragePoolResult.HostCount[0].Count

// 		data, err := h.svc.GetPoolDiskList(BlockReData.RegionCode, BlockReData.AzName.ResourcePool, 0, 10, "", blockStoragePoolQuery.ResourcePool)
// 		if err != nil {
// 			return BlockReData, err
// 		}
// 		BlockReData.CloudDiskNumber = data.TotalCount
// 	}
// 	fmt.Println(BlockReData)
// 	return BlockReData, err
// }

// func (h *Handler) GetBlockStoragePoolList(blockStoragePoolQuery BlockStoragePoolQuery) (BlockStoragePoolListDataResult, error) {

// 	q := `{
// 		host(func:eq(resourcePoolType,"ebs"),orderasc:sn,offset:` + fmt.Sprintf("%v", (blockStoragePoolQuery.PageNo-1)*blockStoragePoolQuery.PageSize) + `,first:` + fmt.Sprintf("%v", blockStoragePoolQuery.PageSize) + `)

// 		 `
// 	var qList []string
// 	qString := ""
// 	if blockStoragePoolQuery.RegionCode != "all" && blockStoragePoolQuery.RegionCode != "" {
// 		//q += `and eq(region, "` + blockStoragePoolQuery.Region + `")`
// 		qList = append(qList, `eq(poolRegionCode, "`+blockStoragePoolQuery.RegionCode+`")`)
// 	}
// 	if blockStoragePoolQuery.AzCode != "all" && blockStoragePoolQuery.AzCode != "" {
// 		//q += `and eq(az, "` + blockStoragePoolQuery.Az + `")`
// 		qList = append(qList, `eq(poolAzCode, "`+blockStoragePoolQuery.AzCode+`")`)
// 	}
// 	if blockStoragePoolQuery.Name != "" {
// 		//q += `and eq(name, "` + blockStoragePoolQuery.Name + `")`
// 		qList = append(qList, `eq(name, "`+blockStoragePoolQuery.Name+`")`)
// 	}
// 	if blockStoragePoolQuery.ResourcePool != "all" {
// 		//q += `and uid("` + blockStoragePoolQuery.Id + `")`
// 		qList = append(qList, `eq(resourcePool, "`+blockStoragePoolQuery.ResourcePool+`")`)
// 	}
// 	if len(qList) > 0 {
// 		qString = "@filter(" + strings.Join(qList, "and ") + ")"
// 		q = q + qString
// 	}
// 	fmt.Println(qString)
// 	q += `  {
// 		id:uid
// 		name
// 		regionName:poolRegionName
// 		azName:poolAzName
// 		resourcePool
// 		attribute
// 		hostNumber
// 		cloudDiskNumber
// 	  }
// 	}`
// 	fmt.Println(q)
// 	var BlockStoragePoolResult BlockStoragePoolList
// 	var BlockStoragePoolDataResult BlockStoragePoolListDataResult
// 	resp, err := h.dgraphClient.NewTxn().Query(context.Background(), q)
// 	err = json.Unmarshal(resp.Json, &BlockStoragePoolResult)
// 	if err != nil {
// 		fmt.Println(err)
// 		return BlockStoragePoolDataResult, err
// 	} else {
// 		BlockStoragePoolDataResult.DataList = BlockStoragePoolResult.Host
// 		BlockStoragePoolDataResult.PageNo = blockStoragePoolQuery.PageNo
// 		BlockStoragePoolDataResult.PageSize = blockStoragePoolQuery.PageSize
// 		BlockStoragePoolDataResult.TotalCount, _ = h.GetCountByQ(qString)
// 	}
// 	return BlockStoragePoolDataResult, err
// }

func (h *Handler) GetCountByQ(qString string) (int, error) {
	// 为创建的节点分配的uid将在resp.AssignedUids map中返回。
	//variables := map[string]string{"$id": assigned.Uids["blank-0"]}
	q := `{
		host(func:eq(resourcePoolType,"ebs"))`
	if qString == "" {
		q = q + qString
	}
	q += `{
	     count(uid)
	    }
      }
	`
	resp, err := h.dgraphClient.NewTxn().Query(context.Background(), q)
	if err != nil {
		fmt.Println(err)
		return 0, err
	} else {
		var r Data
		err = json.Unmarshal(resp.Json, &r)
		if err != nil {
			return 0, err
		} else {
			return r.Host[0].Count, nil
		}
	}
}

//获取单个服务器详情
func (h *Handler) GetBlockStoragePoolEntity(instanceId string) (BlockRe, error) {

	q := `{
		blockStoragePool(func:uid(` + instanceId + `))  {
			id:uid
			name
			regionName:hostRegionName
			resourcePool:serviceType
			bucketNumber
			hostNumber
			cloudDiskNumber
		}
	}`
	//fmt.Println(q)

	var blockStoragePool BlockStoragePoolData
	resp, err := h.dgraphClient.NewTxn().Query(context.Background(), q)
	err = json.Unmarshal(resp.Json, &blockStoragePool)
	//fmt.Println(*resp)
	var blockStoragePoolResult BlockRe
	if err != nil {
		return blockStoragePoolResult, err
	} else {
		blockStoragePoolResult = blockStoragePool.BlockStoragePool[0]
	}
	return blockStoragePoolResult, err
}

func (h *Handler) getStock(req *restful.Request, resp *restful.Response) {
	poolName := req.PathParameter("name")
	pagination := handler.CommonPagination(req)
	data, err := h.svc.GetPoolStock(poolName, pagination.PageNo, pagination.PageSize)
	if err != nil {
		api.HandleInternalError(resp, err)
		return
	}
	var res models.CommonResult
	res.Data = data
	resp.WriteAsJson(&res)
}

func (h *Handler) getPoolDiskList(req *restful.Request, resp *restful.Response) {
	poolName := req.PathParameter("name")
	// state := req.QueryParameter("state")
	// cloudType := req.QueryParameter("type")
	//pagination := handler.CommonPagination(req)
	t := new(storage.BlockStoragePoolDiskQuery)
	err := req.ReadEntity(&t)
	// state := ""
	// storageType := ""
	// if len(t.State) > 0 {
	// 	state = t.State[0]
	// }
	// if len(t.Type) > 0 {
	// 	storageType = t.Type[0]
	// }
	//data, err := h.svc.GetPoolDiskList("all", "all", poolName, t.PageNo, t.PageSize, t.State, t.Type)
	data, err := h.svc.GetPoolDiskList("all", poolName, t.PageNo, t.PageSize, []string{}, t.State, t.Type)
	if err != nil {
		api.HandleInternalError(resp, err)
		return
	}
	var res models.CommonResult
	res.Data = data
	resp.WriteAsJson(&res)
}

// 获取资源池分片列表
func (h *Handler) getPoolSliceList(req *restful.Request, resp *restful.Response) {
	param := new(storagePool.Pagination)
	err := req.ReadEntity(&param)

	data, err := h.svc.GetPoolSliceStock(param.Id, param.PageNo, param.PageSize)
	if err != nil {
		api.HandleInternalError(resp, err)
		return
	}
	var res models.CommonResult
	res.Data = data
	resp.WriteAsJson(&res)
}

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/pkg/api/blockStoragePool/result.go
```golang
package blockStoragePool

type Result struct {
	Code    int         `json:"code"`
	Message string      `json:"message"`
	Data    interface{} `json:"data"`
}

type PageStruct struct {
	TotalCount int `json:"totalCount"`
	PageNo     int `json:"pageNo"`
	PageSize   int `json:"pageSize"`
}

type BlockStoragePoolListDataResult struct {
	PageStruct
	DataList []BlockRe `json:"dataList"`
}

// type BlockStoragePoolList struct {
// 	RequestId string    `json:"requestId"`
// 	Returns   []BlockRe `json:"returns"`
// }

type BlockRe struct {
	Name       string `json:"name"`
	Id         string `json:"id"`
	RegionName string `json:"regionName"`
	RegionCode string `json:"regionCode"`
	AzName     string `json:"azName"`
	//AzCode           string `json:"azCode"`
	//ResourcePoolType string `json:"resourcePoolType"` //资源池类型(块存储)
	ResourcePool    string `json:"resourcePool"` //资源池（高效云盘，云硬盘3.0）
	Attribute       string `json:"attribute"`
	HostNumber      int    `json:"hostNumber"`
	CloudDiskNumber int    `json:"cloudDiskNumber"`
}

type BlockStoragePoolQuery struct {
	PageNo       int    `json:"pageNo"`
	PageSize     int    `json:"pageSize"`
	RegionCode   string `json:"regionCode"`
	AzCode       string `json:"azCode"`
	Name         string `json:"name"`
	ResourcePool string `json:"resourcePool"`
	Id           string `json:"id"`
}
type BlockStoragePoolData struct {
	BlockStoragePool []BlockRe `json:"blockStoragePool"`
}
type BlockStoragePoolList struct {
	Host      []BlockRe   `json:"host"`
	HostCount []HostCount `json:"hostCount"`
}
type HostCount struct {
	Count int `json:"count"`
}
type Data struct {
	Host []Host `json:"host"`
}
type Host struct {
	Count int `json:"count"`
}

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/pkg/api/blockStoragePool/handler_test.go
```golang
package blockStoragePool

import (
	"encoding/json"
	"errors"
	"io/ioutil"
	"luban-cmdb-api/pkg/models/storagePool"
	"net/http/httptest"
	"testing"

	"github.com/emicklei/go-restful"

	"luban-cmdb-api/pkg/models"
	"luban-cmdb-api/pkg/models/storage"
)

type mockBlockStorageService struct {
	PoolDisk            *storage.BlockStoragePoolDisk
	PoolStock           *storage.BlockStoragePoolStock
	CloudDiskResult     *storage.CloudDiskResult
	CloudDiskDataDetail *storage.CloudDiskDataDetail
	StorageBlock        []storage.BlockRe
	StoragePoolSlic     []storagePool.StoragePoolSlice
	Error               error
}

func (m *mockBlockStorageService) GetPoolDiskList(regionCode, poolName string, pageNo, pageSize int, azCode, state, cloudType []string) (*storage.BlockStoragePoolDisk, error) {
	if m.Error != nil {
		return nil, m.Error
	}
	return m.PoolDisk, nil
}

func (m *mockBlockStorageService) GetPoolStock(insId string, pageNo, pageSize int) (*storage.BlockStoragePoolStock, error) {
	if m.Error != nil {
		return nil, m.Error
	}
	return m.PoolStock, nil
}
func (m *mockBlockStorageService) GetBlockStoragePoolList(blockStoragePoolQuery storage.BlockStoragePoolQuery) ([]storage.BlockRe, error) {
	if m.Error != nil {
		return nil, m.Error
	}
	return m.StorageBlock, nil
}
func (m *mockBlockStorageService) GetCloudDiskOverviewData(cloudDiskReq storage.CloudDiskRequest) (*storage.BlockStoragePoolStock, error) {
	if m.Error != nil {
		return nil, m.Error
	}
	return m.PoolStock, nil
}

func (m *mockBlockStorageService) GetPoolSliceStock(id, PageNo, PageSize int) ([]storagePool.StoragePoolSlice, error) {
	if m.Error != nil {
		return nil, m.Error
	}
	return m.StoragePoolSlic, nil
}

func TestNewBlockStoragePoolHandler(t *testing.T) {
	testCases := []struct {
		Name                    string
		StatusCode              int
		StockUrl                string
		DiskUrl                 string
		BlockStoragePoolService *mockBlockStorageService
	}{
		{
			Name:       "regular-test-flow",
			StatusCode: 200,
			DiskUrl:    "/disk/test-insId",
			StockUrl:   "/stock/test-insId",
			BlockStoragePoolService: &mockBlockStorageService{
				PoolStock: &storage.BlockStoragePoolStock{
					DataList: []storage.BlockStockDetail{
						{
							Region: "test-region",
						},
					},
				},
				PoolDisk: &storage.BlockStoragePoolDisk{
					CommonListPagination: models.CommonListPagination{
						TotalCount: 1,
					},
					DataList: []storage.DiskDetail{
						{
							Name: "test-pool-disk",
						},
					},
				},
			},
		}, {
			Name:       "test-server-500-error",
			StatusCode: 500,
			DiskUrl:    "/disk/test-insId",
			StockUrl:   "/stock/test-insId",
			BlockStoragePoolService: &mockBlockStorageService{
				Error: errors.New("test server internal error"),
			},
		},
	}
	for _, testCase := range testCases {
		t.Run(testCase.Name, func(t *testing.T) {
			h := NewHandler(nil, testCase.BlockStoragePoolService)
			ws := new(restful.WebService)
			ws.Consumes(restful.MIME_JSON)
			ws.Route(ws.GET("/stock/{instanceId}").To(h.getStock))
			ws.Route(ws.GET("/disk/{instanceId}").To(h.getPoolDiskList))
			server := restful.NewContainer()
			server.Add(ws)

			req := httptest.NewRequest("GET", testCase.StockUrl, nil)
			record := httptest.NewRecorder()
			server.ServeHTTP(record, req)
			resp := record.Result()
			if resp.StatusCode != testCase.StatusCode {
				t.Fatalf("status code not match, shuold be %d, got %d", testCase.StatusCode, resp.StatusCode)
			}
			if resp.StatusCode == 200 {
				b, err := ioutil.ReadAll(resp.Body)
				if err != nil {
					t.Fatalf("read response body error: %s", err)
				}
				var stock storage.BlockStoragePoolStock
				err = json.Unmarshal(b, &stock)
				if err != nil {
					t.Fatalf("json unmarshal body data error: %s", err)
				}
				if stock.DataList[0].Region != testCase.BlockStoragePoolService.PoolStock.DataList[0].Region {
					t.Fatalf("stock response data not match")
				}
				t.Logf("stock response data: %+v", stock)
			}

			diskReq := httptest.NewRequest("GET", testCase.DiskUrl, nil)
			diskRecord := httptest.NewRecorder()
			server.ServeHTTP(diskRecord, diskReq)
			diskResp := diskRecord.Result()
			if diskResp.StatusCode != testCase.StatusCode {
				t.Fatalf("status code not match, shuold be %d, got %d", testCase.StatusCode, diskResp.StatusCode)
			}
			if diskResp.StatusCode == 200 {
				b, err := ioutil.ReadAll(diskResp.Body)
				if err != nil {
					t.Fatalf("read disk response error: %s", err)
				}
				var disk storage.BlockStoragePoolDisk
				err = json.Unmarshal(b, &disk)
				if err != nil {
					t.Fatalf("json unmarshal disk body data error: %s", err)
				}
				if disk.DataList[0].Name != testCase.BlockStoragePoolService.PoolDisk.DataList[0].Name {
					t.Fatalf("disk response data not match")
				}
				t.Logf("disk response data: %+v", disk)
			}
		})
	}
}

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/pkg/api/overview/register.go
```golang
package overview

import (
	"luban-cmdb-api/pkg/apiserver/config"
	"luban-cmdb-api/pkg/runtime"
	"luban-cmdb-api/pkg/service"

	"github.com/dgraph-io/dgo/v200"
	"github.com/emicklei/go-restful"
	restfulspec "github.com/emicklei/go-restful-openapi"
	"github.com/gophercloud/gophercloud"
)

const APIGroup = "overview"

func AddToContainer(c *restful.Container, dgraphclient *dgo.Dgraph, novaclient *gophercloud.ServiceClient, identityClient *gophercloud.ServiceClient, config *config.Config) error {
	overViewTag := []string{"Overview"}
	ws := runtime.NewWebService(APIGroup)
	switchService := service.NewSwitchService(dgraphclient)
	OverviewService := service.NewOverviewService(dgraphclient, novaclient, identityClient, config)
	handler := NewHandler(OverviewService, switchService)
	ws.Route(ws.GET("/resourceOverview").To(handler.getResourceOverview).
		Doc("获取资源总览").
		Metadata(restfulspec.KeyOpenAPITags, overViewTag).
		Param(ws.QueryParameter("regionCode", "regionCode").DataType("string")).
		Param(ws.QueryParameter("azCode", "azCode").DataType("string")).
		Returns(200, "OK", ResourceOverview{}))
	c.Add(ws)
	return nil
}

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/pkg/api/overview/handler.go
```golang
package overview

import (
	"github.com/emicklei/go-restful"
)

type OverviewService interface {
	GetCloudDiskInfo(region, az string) (cloudDiskTotalCount, cloudDiskUsedCount, cloudDiskErrorCount, cloudDiskAvailableCount int, err error)
	GetInstanceInfo(region, az string) (instanceTotalCount, instanceRunningCount, instanceErrorCount int, err error)
	GetPhysicalHostInfo(region, az string) (totalCount, runningCount, errorCount, insuredCount, insured1mCount, insured3mCount int, err error)
	GetObjectStorageInfo(region string) (bucketCount int, err error)
	// business库
	GetObjectStorageCount(region string) (bucketCount int, err error)
	GetBlockStorageCount(region, az string) (cloudDiskTotalCount, cloudDiskUsedCount, cloudDiskErrorCount, cloudDiskAvailableCount int, err error)
}
type SwitchService interface {
	GetPhysicalSwitchInfo(region, az string) (totalCount, runningCount, errorCount, insuredCount, insured1mCount, insured3mCount int64, err error)
}
type Handler struct {
	overviewService OverviewService
	switchService   SwitchService
}

func NewHandler(service OverviewService, switchService SwitchService) *Handler {
	return &Handler{
		overviewService: service,
		switchService:   switchService,
	}
}

func (h *Handler) getResourceOverview(request *restful.Request, response *restful.Response) {
	response.AddHeader(restful.HEADER_AccessControlAllowOrigin, "*")
	res := new(Result)
	//region := request.QueryParameter("regionCode")
	//az := request.QueryParameter("azCode")
	region := request.QueryParameter("region")
	if region == "" {
		region = request.QueryParameter("regionCode")
	}
	az := request.QueryParameter("az")
	if az == "" {
		az = request.QueryParameter("azCode")
	}
	var resourceOverView ResourceOverview

	totalCount, runningCount, errorCount, insuredCount, insured1mCount, insured3mCount, err := h.overviewService.GetPhysicalHostInfo(region, az)
	if err != nil {
		res.Code = 500
		res.Message = err.Error()
		response.WriteAsJson(res)
		return
	}
	// 物理资源：服务器
	resourceOverView.PhysicalResourcesOverview = append(resourceOverView.PhysicalResourcesOverview, BaseResourcesOverview{
		Name:   "服务器",
		Code:   "physicalHost",
		Number: totalCount,
		Unit:   "个",
		List: []SubOverView{
			{Name: "监控中", Code: "runningCount", Number: runningCount, Unit: "个", Kind: "success", Status: "up"},
			{Name: "监控异常", Code: "errorCount", Number: errorCount, Unit: "个", Kind: "error", Status: "down"},
		},
	})
	// 资产维保统计：服务器
	resourceOverView.PhysicalMaintenanceOverview = append(resourceOverView.PhysicalMaintenanceOverview, ChartBaseResourcesOverview{
		Title: "服务器",
		Totle: totalCount,
		Unit:  "个",
		Data: []ChartSubData{
			{Name: "已过保", Value: insuredCount, Status: "insured"},
			{Name: "1个月内过保", Value: insured1mCount, Status: "insured1m"},
			{Name: "3个月内过保", Value: insured3mCount, Status: "insured3m"},
		},
	})
	//云资源：云主机
	instanceTotalCount, instanceRunningCount, instanceErrorCount, err := h.overviewService.GetInstanceInfo(region, az)
	if err != nil {
		res.Code = 500
		res.Message = err.Error()
		response.WriteAsJson(res)
		return
	}
	resourceOverView.CloudResourcesOverview = append(resourceOverView.CloudResourcesOverview, BaseResourcesOverview{
		Name:   "云主机",
		Code:   "vm",
		Number: instanceTotalCount,
		Unit:   "个",
		List: []SubOverView{
			{Name: "运行中", Code: "instanceRunningCount", Number: instanceRunningCount, Unit: "个", Kind: "success", Status: "active"},
			{Name: "故障", Code: "instanceErrorCount", Number: instanceErrorCount, Unit: "个", Kind: "error", Status: "error"},
		},
	})
	// 云资源：云硬盘
	cloudDiskTotalCount, cloudDiskUsedCount, cloudDiskErrorCount, _, err := h.overviewService.GetBlockStorageCount(region, az)
	if err != nil {
		res.Code = 500
		res.Message = err.Error()
		response.WriteAsJson(res)
		return
	}
	resourceOverView.CloudResourcesOverview = append(resourceOverView.CloudResourcesOverview, BaseResourcesOverview{
		Name:   "块存储",
		Code:   "clouddisk",
		Number: cloudDiskTotalCount,
		Unit:   "个",
		List: []SubOverView{
			{Name: "使用中", Code: "cloudDiskUsedCount", Number: cloudDiskUsedCount, Unit: "个", Kind: "success", Status: "in-use"},
			{Name: "故障", Code: "cloudDiskErrorCount", Number: cloudDiskErrorCount, Unit: "个", Kind: "error", Status: "error"},
		},
	})
	// 云资源：对象存储
	bucketCount, err := h.overviewService.GetObjectStorageCount(region)
	if err != nil {
		res.Code = 500
		res.Message = err.Error()
		response.WriteAsJson(res)
		return
	}
	resourceOverView.CloudResourcesOverview = append(resourceOverView.CloudResourcesOverview, BaseResourcesOverview{
		Name:   "对象存储",
		Code:   "bucket",
		Number: bucketCount,
		Unit:   "个",
	})

	totalCountSwitch, runningCountSwitch, errorCountSwitch, insuredCountSwitch, insured1mCountSwitch, insured3mCountSwitch, err := h.switchService.GetPhysicalSwitchInfo(region, az)
	if err != nil {
		res.Code = 500
		res.Message = err.Error()
		response.WriteAsJson(res)
		return
	}
	// 物理资源：交换机
	resourceOverView.PhysicalResourcesOverview = append(resourceOverView.PhysicalResourcesOverview, BaseResourcesOverview{
		Name:   "交换机",
		Code:   "physicalSwitch",
		Number: int(totalCountSwitch),
		Unit:   "个",
		List: []SubOverView{
			{Name: "监控中", Code: "up", Number: int(runningCountSwitch), Unit: "个", Kind: "success", Status: "up"},
			{Name: "监控异常", Code: "down", Number: int(errorCountSwitch), Unit: "个", Kind: "error", Status: "down"},
		},
	})
	// 资产维保统计：交换机
	resourceOverView.PhysicalMaintenanceOverview = append(resourceOverView.PhysicalMaintenanceOverview, ChartBaseResourcesOverview{
		Title: "交换机",
		Totle: int(totalCountSwitch),
		Unit:  "个",
		Data: []ChartSubData{
			{Name: "已过保", Value: int(insuredCountSwitch), Status: "insured"},
			{Name: "1个月内过保", Value: int(insured1mCountSwitch), Status: "insured1m"},
			{Name: "3个月内过保", Value: int(insured3mCountSwitch), Status: "insured3m"},
		},
	})
	res.Code = 200
	res.Message = "success"
	res.Data = resourceOverView
	response.WriteAsJson(res)
}

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/pkg/api/overview/result.go
```golang
package overview

type Result struct {
	Code    int         `json:"code"`
	Message string      `json:"message"`
	Data    interface{} `json:"data"`
}

// ResourceOverview 资源总览返回消息
type ResourceOverview struct {
	PhysicalResourcesOverview   []BaseResourcesOverview      `json:"physicalResourcesOverview"`
	CloudResourcesOverview      []BaseResourcesOverview      `json:"cloudResourcesOverview"`
	PhysicalMaintenanceOverview []ChartBaseResourcesOverview `json:"physicalMaintenanceOverview"`
}

type BaseResourcesOverview struct {
	Name   string        `json:"label"`
	Code   string        `json:"code"`
	Number int           `json:"number"`
	Unit   string        `json:"unit"`
	List   []SubOverView `json:"list"`
}

type SubOverView struct {
	Name   string `json:"label"`
	Code   string `json:"code"`
	Number int    `json:"number"`
	Unit   string `json:"unit"`
	Kind   string `json:"kind"`
	Status string `json:"status"`
}

type ChartBaseResourcesOverview struct {
	Title string         `json:"title"`
	Totle int            `json:"totle"`
	Unit  string         `json:"unit"`
	Data  []ChartSubData `json:"data"`
}

type ChartSubData struct {
	Name   string `json:"name"`
	Status string `json:"status"`
	Value  int    `json:"value"`
}

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/pkg/api/businessManagement/register.go
```golang
package businessManagement

import (
	"github.com/emicklei/go-restful"
	restfulspec "github.com/emicklei/go-restful-openapi"
	"github.com/gophercloud/gophercloud"
	"luban-cmdb-api/pkg/apiserver/config"
	"luban-cmdb-api/pkg/models/businessManagement"
	"luban-cmdb-api/pkg/runtime"
	"luban-cmdb-api/pkg/service"
)

const APIGroup = "businessManagement"

func AddToContainer(c *restful.Container, novaclient *gophercloud.ServiceClient, identityClient *gophercloud.ServiceClient, config config.Config) error {
	ws := runtime.NewWebService(APIGroup)
	svc := service.NewBusinessManagementService()
	aggregateService := service.NewAggregateService(novaclient, identityClient, config)
	handler := NewHandler(svc, aggregateService)

	//容器
	containerTag := []string{"businessManagement", "container"}
	ws.Route(ws.GET("/containerList/ns/{ns}/pod/{pod}").To(handler.GetContainerListHandler).
		Doc("查看一个Pod的容器列表").
		Metadata(restfulspec.KeyOpenAPITags, containerTag).
		Param(ws.PathParameter("ns", "namespace")).
		Param(ws.PathParameter("pod", "pod name")).
		Returns(200, "OK", []businessManagement.Container{}))

	// 服务实例
	instanceTag := []string{"businessManagement", "serviceInstance"}
	ws.Route(ws.GET("/serviceInstanceDetail/{id}").To(handler.GetServiceInstanceHandler).
		Doc("查看一个服务实例").
		Metadata(restfulspec.KeyOpenAPITags, instanceTag).
		Param(ws.PathParameter("id", "服务实例的id")).
		Returns(200, "OK", businessManagement.ServiceInstance{}))
	ws.Route(ws.POST("/serviceInstanceList").To(handler.GetServiceInstanceListHandler).
		Doc("查看服务实例列表").
		Metadata(restfulspec.KeyOpenAPITags, instanceTag).
		Reads(businessManagement.QueryServiceInstanceListParams{}, "").
		Returns(200, "OK", []businessManagement.ServiceInstance{}))
	ws.Route(ws.POST("/serviceInstance").To(handler.CreateServiceInstanceHandler).
		Doc("创建一个服务实例").
		Metadata(restfulspec.KeyOpenAPITags, instanceTag).
		Reads(businessManagement.ServiceInstance{}, "可传入字段：name serviceId regionCode azCode hostId serviceProcess").
		Returns(200, "OK", nil))
	ws.Route(ws.PUT("/serviceInstance").To(handler.UpdateServiceInstanceHandler).
		Doc("更新服务实例").
		Metadata(restfulspec.KeyOpenAPITags, instanceTag).
		Reads(businessManagement.ServiceInstance{}, "可修改字段：name serviceId hostId process,process直接将修改后的列表传回就好，增加的判别依据进程是否有ID,删除的判别依据传回的进程与查询的进程差集，修改的判别依据传回的进程与查询的进程并集后比对字段是否相等").
		Returns(200, "OK", nil))
	ws.Route(ws.POST("serviceInstance/delete").To(handler.DeleteServiceInstanceHandler).
		Doc("删除服务实例").
		Metadata(restfulspec.KeyOpenAPITags, instanceTag).
		Reads(businessManagement.DeleteServiceInstanceParams{}, "ids: 传入服务ID数组").
		Returns(200, "OK", nil))
	ws.Route(ws.GET("/serviceInstanceListByHostName").To(handler.GetServiceInstanceByHostNameHandler).
		Doc("根据主机名获取服务实例列表(当前仅支持服务器，不支持云主机)").
		Metadata(restfulspec.KeyOpenAPITags, instanceTag).
		Param(ws.QueryParameter("hostname", "主机名")).
		Returns(200, "OK", []businessManagement.ServiceInstance{}))

	// 服务
	serviceTag := []string{"businessManagement", "service"}
	ws.Route(ws.POST("/service").To(handler.CreateServiceHandler).
		Doc("创建一个服务").
		Metadata(restfulspec.KeyOpenAPITags, serviceTag).
		Reads(businessManagement.Service{}, "可传入字段：name regionCode").
		Returns(200, "OK", nil))
	ws.Route(ws.GET("/serviceDetail/{id}").To(handler.GetServiceHandler).
		Doc("查看一个服务").
		Metadata(restfulspec.KeyOpenAPITags, serviceTag).
		Param(ws.PathParameter("id", "服务的id")).
		Returns(200, "OK", businessManagement.Service{}))
	ws.Route(ws.GET("/serviceList").To(handler.GetServiceListHandler).
		Doc("查看服务列表").
		Metadata(restfulspec.KeyOpenAPITags, serviceTag).
		Param(ws.QueryParameter("regionCode", "regionCode")).
		Param(ws.QueryParameter("searchName", "searchName")).
		Param(ws.QueryParameter("builtIn", "builtIn")).
		Param(ws.QueryParameter("pageSize", "pageSize")).
		Param(ws.QueryParameter("pageNo", "pageNo")).
		Param(ws.QueryParameter("sortField", "sortField")).
		Param(ws.QueryParameter("sortType", "sortType")).
		Returns(200, "OK", []businessManagement.Service{}))
	ws.Route(ws.PUT("/service").To(handler.UpdateServiceHandler).
		Doc("更新服务").
		Metadata(restfulspec.KeyOpenAPITags, serviceTag).
		Reads(businessManagement.Service{}, "可修改字段：name").
		Returns(200, "OK", nil))
	ws.Route(ws.DELETE("service/{id}").To(handler.DeleteServiceHandler).
		Doc("删除服务").
		Metadata(restfulspec.KeyOpenAPITags, serviceTag).
		Param(ws.PathParameter("id", "id")).
		Returns(200, "OK", nil))
	ws.Route(ws.GET("/eaglesServiceGroup").To(handler.GetEaglesServiceGroupHandler).
		Doc("for eagles").
		Metadata(restfulspec.KeyOpenAPITags, serviceTag).
		Returns(200, "OK", []businessManagement.BusinessServiceGroup{}))

	// 树结构
	treeTag := []string{"businessManagement", "tree"}
	ws.Route(ws.POST("/tree").To(handler.CreateTreeHandler).
		Doc("创建一个树").
		Metadata(restfulspec.KeyOpenAPITags, treeTag).
		Reads(businessManagement.Tree{}, "可传入字段：name status regionCode").
		Returns(200, "OK", nil))
	ws.Route(ws.GET("/treeDetail/{id}").To(handler.GetTreeHandler).
		Doc("查看一个树").
		Metadata(restfulspec.KeyOpenAPITags, treeTag).
		Param(ws.PathParameter("id", "树的id")).
		Returns(200, "OK", businessManagement.Tree{}))
	ws.Route(ws.POST("/treeList").To(handler.GetTreeListHandler).
		Doc("查看树列表").
		Metadata(restfulspec.KeyOpenAPITags, treeTag).
		Reads(businessManagement.QueryTreeListParams{}, "").
		Returns(200, "OK", []businessManagement.Tree{}))
	ws.Route(ws.PUT("/tree").To(handler.UpdateTreeHandler).
		Doc("更新树").
		Metadata(restfulspec.KeyOpenAPITags, treeTag).
		Reads(businessManagement.Tree{}, "可修改字段：name status").
		Returns(200, "OK", nil))
	ws.Route(ws.DELETE("/tree/{id}").To(handler.DeleteTreeHandler).
		Doc("删除树").
		Metadata(restfulspec.KeyOpenAPITags, treeTag).
		Param(ws.PathParameter("id", "id")).
		Returns(200, "OK", nil))

	// 节点结构
	nodeTag := []string{"businessManagement", "node"}
	ws.Route(ws.POST("/node").To(handler.CreateNodeHandler).
		Doc("创建一个节点").
		Metadata(restfulspec.KeyOpenAPITags, nodeTag).
		Reads(businessManagement.Node{}, "可传入字段：name services regionCode").
		Returns(200, "OK", nil))
	ws.Route(ws.GET("/nodeDetail/{id}").To(handler.GetNodeHandler).
		Doc("查看一个节点").
		Metadata(restfulspec.KeyOpenAPITags, nodeTag).
		Param(ws.PathParameter("id", "节点的id")).
		Returns(200, "OK", businessManagement.Node{}))
	ws.Route(ws.GET("/nodeList").To(handler.GetNodeListHandler).
		Doc("查看节点列表").
		Metadata(restfulspec.KeyOpenAPITags, nodeTag).
		Param(ws.QueryParameter("regionCode", "regionCode")).
		Param(ws.QueryParameter("pageSize", "pageSize")).
		Param(ws.QueryParameter("pageNo", "pageNo")).
		Param(ws.QueryParameter("sortField", "sortField")).
		Param(ws.QueryParameter("sortType", "sortType")).
		Returns(200, "OK", []businessManagement.Node{}))
	ws.Route(ws.PUT("/node").To(handler.UpdateNodeHandler).
		Doc("更新节点").
		Metadata(restfulspec.KeyOpenAPITags, nodeTag).
		Reads(businessManagement.Node{}, "可修改字段：name services").
		Returns(200, "OK", nil))
	ws.Route(ws.DELETE("/node/{id}").To(handler.DeleteNodeHandler).
		Doc("删除节点").
		Metadata(restfulspec.KeyOpenAPITags, nodeTag).
		Param(ws.PathParameter("id", "id")).
		Returns(200, "OK", nil))

	// 业务拓扑
	topologyTag := []string{"businessManagement", "topology"}
	ws.Route(ws.GET("/topology/show").To(handler.TopologyHandler).
		Doc("显示业务拓扑").
		Metadata(restfulspec.KeyOpenAPITags, topologyTag).
		Param(ws.QueryParameter("treeId", "treeId")).
		Returns(200, "OK", businessManagement.NodeRef{}))
	ws.Route(ws.GET("/simplifyTopology/show").To(handler.SimplifyTopologyHandler).
		Doc("显示精简的业务拓扑").
		Metadata(restfulspec.KeyOpenAPITags, topologyTag).
		Param(ws.QueryParameter("treeId", "treeId")).
		Returns(200, "OK", businessManagement.Topology{}))
	ws.Route(ws.POST("topology/install").To(handler.installNode).
		Doc("挂载节点").
		Metadata(restfulspec.KeyOpenAPITags, topologyTag).
		Reads(businessManagement.NodeRef{}, "填入parentId realNodeId treeId").
		Returns(200, "OK", nil))
	ws.Route(ws.DELETE("topology/uninstall/{refId}").To(handler.uninstallNode).
		Doc("卸载节点").
		Metadata(restfulspec.KeyOpenAPITags, topologyTag).
		Param(ws.PathParameter("refId", "refId")).
		Returns(200, "OK", nil))

	ws.Route(ws.GET("/latestRemoteProcess").To(handler.latestProcessHandler).
		Doc("Get latest remote process List./获取到最近的远程进程列表").
		Metadata(restfulspec.KeyOpenAPITags, []string{"businessManagement"}).
		Returns(200, "ok", businessManagement.ProcessLatest{}))

	ws.Route(ws.GET("/test").To(handler.testHandler).
		Doc("测试接口").
		Metadata(restfulspec.KeyOpenAPITags, []string{"businessManagement"}).
		Returns(200, "ok", businessManagement.ProcessLatest{}))

	c.Add(ws)
	return nil
}

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/pkg/api/businessManagement/handler.go
```golang
package businessManagement

import (
	"encoding/json"
	"fmt"
	"luban-cmdb-api/pkg/models"
	"luban-cmdb-api/pkg/models/businessManagement"
	"luban-cmdb-api/pkg/service"
	"strconv"

	"github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/aggregates"
	"k8s.io/klog/v2"

	"github.com/emicklei/go-restful"
)

type Service interface {
	QueryContainerList(ns, pod string) (containers []businessManagement.Container, err error)

	CreateServiceInstance(svci businessManagement.ServiceInstance) error
	UpdateServiceInstance(svci businessManagement.ServiceInstance) error
	QueryServiceInstance(id int, aggregateService *service.AggregateService) (svci businessManagement.ServiceInstance, err error)
	QueryServiceInstanceList(params businessManagement.QueryServiceInstanceListParams, aggregateService *service.AggregateService) (svcis []businessManagement.ServiceInstance, total int, err error)
	DeleteServiceInstances(ids []int) error

	CreateService(svc businessManagement.Service) error
	QueryService(id int) (svc businessManagement.Service, err error)
	QueryServiceList(regionCode, SearchName string, builtIn, pageSize, pageNo int, sortField, sortType string) (services []businessManagement.Service, total int64, err error)
	UpdateService(svc businessManagement.Service) error
	DeleteService(id int) error

	CreateTree(tree businessManagement.Tree) error
	QueryTree(id int) (tree businessManagement.Tree, err error)
	QueryTreeList(regionCode string, status []int, pageSize, pageNo int, sortField, sortType string) (trees []businessManagement.Tree, count int64, err error)
	UpdateTree(tree businessManagement.Tree) error
	DeleteTree(id int) error

	CreateNode(node businessManagement.Node) error
	QueryNode(id int) (tree businessManagement.Node, err error)
	QueryNodeList(regionCode string, pageSize, pageNo int, sortField, sortType string) (nodes []businessManagement.Node, total int64, err error)
	UpdateNode(node businessManagement.Node) error
	DeleteNode(id int) error

	QueryTopology(treeId int) (nodeRef businessManagement.NodeRef, err error)
	QuerySimplifyTopology(treeId int) (topology businessManagement.Topology, err error)
	InstallNode(nodeRef businessManagement.NodeRef) error
	UninstallNode(refId int) error

	GetEaglesServiceGroup() (res []businessManagement.BusinessServiceGroup, err error)
	QueryServiceInstanceByHostNameList(hostname string) (svcis []businessManagement.ServiceInstance, err error)

	LatestProcessList(full int) (result []businessManagement.ProcessLatest, err error)
}

type Handler struct {
	svc              Service
	aggregateService *service.AggregateService
}

func NewHandler(svc Service, aggregateService *service.AggregateService) *Handler {
	return &Handler{
		svc:              svc,
		aggregateService: aggregateService,
	}
}

func (h *Handler) CreateServiceInstanceHandler(req *restful.Request, resp *restful.Response) {
	resp.AddHeader(restful.HEADER_AccessControlAllowOrigin, "*")
	res := &models.CommonResult{
		Code:    200,
		Message: "success",
		Data:    nil,
	}
	svci := businessManagement.ServiceInstance{}
	err := req.ReadEntity(&svci)
	if err != nil {
		res.Code = 500
		res.Message = fmt.Sprintf("参数解析失败 err:%v", err)
		resp.WriteAsJson(res)
		return
	}

	username := req.HeaderParameter("x-auth-username")
	svci.Creator = username
	svci.Updater = username
	err = h.svc.CreateServiceInstance(svci)
	if err != nil {
		res.Code = 500
		res.Message = err.Error()
		resp.WriteAsJson(res)
		return
	}
	resp.WriteAsJson(res)
	return
}

func (h *Handler) UpdateServiceInstanceHandler(req *restful.Request, resp *restful.Response) {
	resp.AddHeader(restful.HEADER_AccessControlAllowOrigin, "*")
	res := &models.CommonResult{
		Code:    200,
		Message: "success",
		Data:    nil,
	}
	svci := businessManagement.ServiceInstance{}
	err := req.ReadEntity(&svci)
	if err != nil {
		res.Code = 500
		res.Message = fmt.Sprintf("参数解析失败 err:%v", err)
		resp.WriteAsJson(res)
		return
	}

	username := req.HeaderParameter("x-auth-username")
	svci.Updater = username
	err = h.svc.UpdateServiceInstance(svci)
	if err != nil {
		res.Code = 500
		res.Message = err.Error()
		resp.WriteAsJson(res)
		return
	}
	resp.WriteAsJson(res)
	return
}

func (h *Handler) GetContainerListHandler(req *restful.Request, resp *restful.Response) {
	resp.AddHeader(restful.HEADER_AccessControlAllowOrigin, "*")
	res := &models.CommonResult{
		Code:    200,
		Message: "success",
		Data:    nil,
	}
	ns := req.PathParameter("ns")
	pod := req.PathParameter("pod")

	containers, err := h.svc.QueryContainerList(ns, pod)
	if err != nil {
		res.Code = 500
		res.Message = err.Error()
		resp.WriteAsJson(res)
		return
	}
	res.Data = containers
	resp.WriteAsJson(res)
	return
}

func (h *Handler) GetServiceInstanceHandler(req *restful.Request, resp *restful.Response) {
	resp.AddHeader(restful.HEADER_AccessControlAllowOrigin, "*")
	res := &models.CommonResult{
		Code:    200,
		Message: "success",
		Data:    nil,
	}
	idStr := req.PathParameter("id")
	id, err := strconv.Atoi(idStr)
	if err != nil {
		res.Code = 500
		res.Message = fmt.Sprintf("参数解析失败 err:%v", err)
		resp.WriteAsJson(res)
		return
	}

	svci, err := h.svc.QueryServiceInstance(id, h.aggregateService)
	if err != nil {
		res.Code = 500
		res.Message = err.Error()
		resp.WriteAsJson(res)
		return
	}
	res.Data = svci
	resp.WriteAsJson(res)
	return
}

func (h *Handler) GetServiceInstanceListHandler(req *restful.Request, resp *restful.Response) {
	resp.AddHeader(restful.HEADER_AccessControlAllowOrigin, "*")
	res := &models.CommonResult{
		Code:    200,
		Message: "success",
		Data:    nil,
	}
	params := businessManagement.QueryServiceInstanceListParams{}
	err := req.ReadEntity(&params)
	if err != nil {
		res.Code = 500
		res.Message = fmt.Sprintf("参数解析失败 err:%v", err)
		resp.WriteAsJson(res)
		return
	}
	if params.PageNo == 0 {
		params.PageNo = 1
	}
	if params.PageSize == 0 {
		params.PageSize = 10
	}
	svcis, total, err := h.svc.QueryServiceInstanceList(params, h.aggregateService)
	if err != nil {
		res.Code = 500
		res.Message = err.Error()
		resp.WriteAsJson(res)
		return
	}
	resMap := make(map[string]interface{})
	resMap["total"] = total
	resMap["dataList"] = svcis
	res.Data = resMap
	resp.WriteAsJson(res)
	return
}

func (h *Handler) DeleteServiceInstanceHandler(req *restful.Request, resp *restful.Response) {
	resp.AddHeader(restful.HEADER_AccessControlAllowOrigin, "*")
	res := &models.CommonResult{
		Code:    200,
		Message: "success",
		Data:    nil,
	}
	params := businessManagement.DeleteServiceInstanceParams{}
	err := req.ReadEntity(&params)
	if err != nil {
		res.Code = 500
		res.Message = fmt.Sprintf("参数解析失败 err:%v", err)
		resp.WriteAsJson(res)
		return
	}
	err = h.svc.DeleteServiceInstances(params.Ids)
	if err != nil {
		res.Code = 500
		res.Message = err.Error()
		resp.WriteAsJson(res)
		return
	}
	resp.WriteAsJson(res)
	return
}

func (h *Handler) CreateServiceHandler(req *restful.Request, resp *restful.Response) {
	resp.AddHeader(restful.HEADER_AccessControlAllowOrigin, "*")
	res := &models.CommonResult{
		Code:    200,
		Message: "success",
		Data:    nil,
	}
	svc := businessManagement.Service{}
	err := req.ReadEntity(&svc)
	if err != nil {
		res.Code = 500
		res.Message = fmt.Sprintf("参数解析失败 err:%v", err)
		resp.WriteAsJson(res)
		return
	}

	username := req.HeaderParameter("x-auth-username")
	svc.Creator = username
	svc.Updater = username

	err = h.svc.CreateService(svc)
	if err != nil {
		res.Code = 500
		res.Message = err.Error()
		resp.WriteAsJson(res)
		return
	}
	resp.WriteAsJson(res)
	return
}

func (h *Handler) GetServiceHandler(req *restful.Request, resp *restful.Response) {
	resp.AddHeader(restful.HEADER_AccessControlAllowOrigin, "*")
	res := &models.CommonResult{
		Code:    200,
		Message: "success",
		Data:    nil,
	}
	idStr := req.PathParameter("id")
	id, err := strconv.Atoi(idStr)
	if err != nil {
		res.Code = 500
		res.Message = fmt.Sprintf("参数解析失败 err:%v", err)
		resp.WriteAsJson(res)
		return
	}

	svc, err := h.svc.QueryService(id)
	if err != nil {
		res.Code = 500
		res.Message = err.Error()
		resp.WriteAsJson(res)
		return
	}
	res.Data = svc
	resp.WriteAsJson(res)
	return
}

func (h *Handler) GetServiceListHandler(req *restful.Request, resp *restful.Response) {
	resp.AddHeader(restful.HEADER_AccessControlAllowOrigin, "*")
	res := &models.CommonResult{
		Code:    200,
		Message: "success",
		Data:    nil,
	}
	regionCode := req.QueryParameter("regionCode")
	searchName := req.QueryParameter("searchName")
	pageSizeStr := req.QueryParameter("pageSize")
	var pageSize, pageNo int = 10, 1
	var err error
	if pageSizeStr != "" {
		pageSize, err = strconv.Atoi(pageSizeStr)
		if err != nil {
			res.Code = 500
			res.Message = fmt.Sprintf("参数解析失败 err:%v", err)
			resp.WriteAsJson(res)
			return
		}
	}
	pageNoStr := req.QueryParameter("pageNo")
	if pageNoStr != "" {
		pageNo, err = strconv.Atoi(pageNoStr)
		if err != nil {
			res.Code = 500
			res.Message = fmt.Sprintf("参数解析失败 err:%v", err)
			resp.WriteAsJson(res)
			return
		}
	}
	builtInStr := req.QueryParameter("builtIn")
	var builtIn = -1
	if builtInStr != "" {
		builtIn, err = strconv.Atoi(builtInStr)
		if err != nil {
			res.Code = 500
			res.Message = fmt.Sprintf("参数解析失败 err:%v", err)
			resp.WriteAsJson(res)
			return
		}
	}
	sortField := req.QueryParameter("sortField")
	sortType := req.QueryParameter("sortType")
	svcs, total, err := h.svc.QueryServiceList(regionCode, searchName, builtIn, pageSize, pageNo, sortField, sortType)
	if err != nil {
		res.Code = 500
		res.Message = err.Error()
		resp.WriteAsJson(res)
		return
	}
	resMap := make(map[string]interface{})
	resMap["total"] = total
	resMap["dataList"] = svcs
	res.Data = resMap
	resp.WriteAsJson(res)
	return
}

func (h *Handler) UpdateServiceHandler(req *restful.Request, resp *restful.Response) {
	resp.AddHeader(restful.HEADER_AccessControlAllowOrigin, "*")
	res := &models.CommonResult{
		Code:    200,
		Message: "success",
		Data:    nil,
	}
	svc := businessManagement.Service{}
	err := req.ReadEntity(&svc)
	if err != nil {
		res.Code = 500
		res.Message = fmt.Sprintf("参数解析失败 err:%v", err)
		resp.WriteAsJson(res)
		return
	}

	username := req.HeaderParameter("x-auth-username")
	svc.Updater = username

	err = h.svc.UpdateService(svc)
	if err != nil {
		res.Code = 500
		res.Message = err.Error()
		resp.WriteAsJson(res)
		return
	}
	resp.WriteAsJson(res)
	return
}

func (h *Handler) DeleteServiceHandler(req *restful.Request, resp *restful.Response) {
	resp.AddHeader(restful.HEADER_AccessControlAllowOrigin, "*")
	res := &models.CommonResult{
		Code:    200,
		Message: "success",
		Data:    nil,
	}
	idStr := req.PathParameter("id")
	id, err := strconv.Atoi(idStr)
	if err != nil {
		res.Code = 500
		res.Message = fmt.Sprintf("参数解析失败 err:%v", err)
		resp.WriteAsJson(res)
		return
	}
	err = h.svc.DeleteService(id)
	if err != nil {
		res.Code = 500
		res.Message = err.Error()
		resp.WriteAsJson(res)
		return
	}
	resp.WriteAsJson(res)
	return
}

func (h *Handler) CreateTreeHandler(req *restful.Request, resp *restful.Response) {
	resp.AddHeader(restful.HEADER_AccessControlAllowOrigin, "*")
	res := &models.CommonResult{
		Code:    200,
		Message: "success",
		Data:    nil,
	}
	tree := businessManagement.Tree{}
	err := req.ReadEntity(&tree)
	if err != nil {
		res.Code = 500
		res.Message = fmt.Sprintf("参数解析失败 err:%v", err)
		resp.WriteAsJson(res)
		return
	}

	username := req.HeaderParameter("x-auth-username")
	tree.Creator = username
	tree.Updater = username

	err = h.svc.CreateTree(tree)
	if err != nil {
		klog.Errorln(err)
		res.Code = 500
		res.Message = err.Error()
		resp.WriteAsJson(res)
		return
	}
	resp.WriteAsJson(res)
	return
}

func (h *Handler) GetTreeHandler(req *restful.Request, resp *restful.Response) {
	resp.AddHeader(restful.HEADER_AccessControlAllowOrigin, "*")
	res := &models.CommonResult{
		Code:    200,
		Message: "success",
		Data:    nil,
	}
	idStr := req.PathParameter("id")
	id, err := strconv.Atoi(idStr)
	if err != nil {
		res.Code = 500
		res.Message = fmt.Sprintf("参数解析失败 err:%v", err)
		resp.WriteAsJson(res)
		return
	}

	tree, err := h.svc.QueryTree(id)
	if err != nil {
		res.Code = 500
		res.Message = err.Error()
		resp.WriteAsJson(res)
		return
	}
	res.Data = tree
	resp.WriteAsJson(res)
	return
}

func (h *Handler) GetTreeListHandler(req *restful.Request, resp *restful.Response) {
	resp.AddHeader(restful.HEADER_AccessControlAllowOrigin, "*")
	res := &models.CommonResult{
		Code:    200,
		Message: "success",
		Data:    nil,
	}
	params := &businessManagement.QueryTreeListParams{}
	err := req.ReadEntity(&params)
	if err != nil {
		res.Code = 500
		res.Message = fmt.Sprintf("参数解析失败 err:%v", err)
		resp.WriteAsJson(res)
		return
	}
	if params.PageNo == 0 {
		params.PageNo = 1
	}
	if params.PageSize == 0 {
		params.PageSize = 10
	}
	trees, total, err := h.svc.QueryTreeList(params.RegionCode, params.Status, params.PageSize, params.PageNo, params.SortField, params.SortType)
	if err != nil {
		res.Code = 500
		res.Message = err.Error()
		resp.WriteAsJson(res)
		return
	}
	resMap := make(map[string]interface{})
	resMap["total"] = total
	resMap["dataList"] = trees
	res.Data = resMap
	resp.WriteAsJson(res)
	return
}

func (h *Handler) UpdateTreeHandler(req *restful.Request, resp *restful.Response) {
	resp.AddHeader(restful.HEADER_AccessControlAllowOrigin, "*")
	res := &models.CommonResult{
		Code:    200,
		Message: "success",
		Data:    nil,
	}
	tree := businessManagement.Tree{}
	err := req.ReadEntity(&tree)
	if err != nil {
		res.Code = 500
		res.Message = fmt.Sprintf("参数解析失败 err:%v", err)
		resp.WriteAsJson(res)
		return
	}

	username := req.HeaderParameter("x-auth-username")
	tree.Updater = username

	err = h.svc.UpdateTree(tree)
	if err != nil {
		res.Code = 500
		res.Message = err.Error()
		resp.WriteAsJson(res)
		return
	}
	resp.WriteAsJson(res)
	return
}

func (h *Handler) DeleteTreeHandler(req *restful.Request, resp *restful.Response) {
	resp.AddHeader(restful.HEADER_AccessControlAllowOrigin, "*")
	res := &models.CommonResult{
		Code:    200,
		Message: "success",
		Data:    nil,
	}
	idStr := req.PathParameter("id")
	id, err := strconv.Atoi(idStr)
	if err != nil {
		res.Code = 500
		res.Message = fmt.Sprintf("参数解析失败 err:%v", err)
		resp.WriteAsJson(res)
		return
	}

	err = h.svc.DeleteTree(id)
	if err != nil {
		res.Code = 500
		res.Message = err.Error()
		resp.WriteAsJson(res)
		return
	}
	resp.WriteAsJson(res)
	return
}

func (h *Handler) CreateNodeHandler(req *restful.Request, resp *restful.Response) {
	resp.AddHeader(restful.HEADER_AccessControlAllowOrigin, "*")
	res := &models.CommonResult{
		Code:    200,
		Message: "success",
		Data:    nil,
	}
	node := businessManagement.Node{}
	err := req.ReadEntity(&node)
	if err != nil {
		res.Code = 500
		res.Message = fmt.Sprintf("参数解析失败 err:%v", err)
		resp.WriteAsJson(res)
		return
	}

	username := req.HeaderParameter("x-auth-username")
	klog.Infof("DEBUG username %+v", username)
	node.Updater = username
	node.Creator = username

	err = h.svc.CreateNode(node)
	if err != nil {
		res.Code = 500
		res.Message = err.Error()
		resp.WriteAsJson(res)
		return
	}
	resp.WriteAsJson(res)
	return
}

func (h *Handler) GetNodeHandler(req *restful.Request, resp *restful.Response) {
	resp.AddHeader(restful.HEADER_AccessControlAllowOrigin, "*")
	res := &models.CommonResult{
		Code:    200,
		Message: "success",
		Data:    nil,
	}
	idStr := req.PathParameter("id")
	id, err := strconv.Atoi(idStr)
	if err != nil {
		res.Code = 500
		res.Message = fmt.Sprintf("参数解析失败 err:%v", err)
		resp.WriteAsJson(res)
		return
	}

	tree, err := h.svc.QueryNode(id)
	if err != nil {
		res.Code = 500
		res.Message = err.Error()
		resp.WriteAsJson(res)
		return
	}
	res.Data = tree
	resp.WriteAsJson(res)
	return
}

func (h *Handler) GetNodeListHandler(req *restful.Request, resp *restful.Response) {
	resp.AddHeader(restful.HEADER_AccessControlAllowOrigin, "*")
	res := &models.CommonResult{
		Code:    200,
		Message: "success",
		Data:    nil,
	}
	regionCode := req.QueryParameter("regionCode")
	pageSizeStr := req.QueryParameter("pageSize")
	var pageSize, pageNo int = 10, 1
	var err error
	if pageSizeStr != "" {
		pageSize, err = strconv.Atoi(pageSizeStr)
		if err != nil {
			res.Code = 500
			res.Message = fmt.Sprintf("参数解析失败 err:%v", err)
			resp.WriteAsJson(res)
			return
		}
	}
	pageNoStr := req.QueryParameter("pageNo")
	if pageNoStr != "" {
		pageNo, err = strconv.Atoi(pageNoStr)
		if err != nil {
			res.Code = 500
			res.Message = fmt.Sprintf("参数解析失败 err:%v", err)
			resp.WriteAsJson(res)
			return
		}
	}
	sortField := req.QueryParameter("sortField")
	sortType := req.QueryParameter("sortType")
	nodes, total, err := h.svc.QueryNodeList(regionCode, pageSize, pageNo, sortField, sortType)
	if err != nil {
		res.Code = 500
		res.Message = err.Error()
		resp.WriteAsJson(res)
		return
	}
	resMap := make(map[string]interface{})
	resMap["total"] = total
	resMap["dataList"] = nodes
	res.Data = resMap
	resp.WriteAsJson(res)
	return
}

func (h *Handler) UpdateNodeHandler(req *restful.Request, resp *restful.Response) {
	resp.AddHeader(restful.HEADER_AccessControlAllowOrigin, "*")
	res := &models.CommonResult{
		Code:    200,
		Message: "success",
		Data:    nil,
	}
	node := businessManagement.Node{}
	err := req.ReadEntity(&node)
	if err != nil {
		res.Code = 500
		res.Message = fmt.Sprintf("参数解析失败 err:%v", err)
		resp.WriteAsJson(res)
		return
	}

	username := req.HeaderParameter("x-auth-username")
	node.Updater = username

	err = h.svc.UpdateNode(node)
	if err != nil {
		res.Code = 500
		res.Message = err.Error()
		resp.WriteAsJson(res)
		return
	}
	resp.WriteAsJson(res)
	return
}

func (h *Handler) DeleteNodeHandler(req *restful.Request, resp *restful.Response) {
	resp.AddHeader(restful.HEADER_AccessControlAllowOrigin, "*")
	res := &models.CommonResult{
		Code:    200,
		Message: "success",
		Data:    nil,
	}
	idStr := req.PathParameter("id")
	id, err := strconv.Atoi(idStr)
	if err != nil {
		res.Code = 500
		res.Message = fmt.Sprintf("参数解析失败 err:%v", err)
		resp.WriteAsJson(res)
		return
	}
	err = h.svc.DeleteNode(id)
	if err != nil {
		res.Code = 500
		res.Message = err.Error()
		resp.WriteAsJson(res)
		return
	}
	resp.WriteAsJson(res)
	return
}

func (h *Handler) TopologyHandler(req *restful.Request, resp *restful.Response) {
	resp.AddHeader(restful.HEADER_AccessControlAllowOrigin, "*")
	res := &models.CommonResult{
		Code:    200,
		Message: "success",
		Data:    nil,
	}
	treeIdStr := req.QueryParameter("treeId")
	treeId, err := strconv.Atoi(treeIdStr)
	if err != nil {
		res.Code = 500
		res.Message = fmt.Sprintf("参数解析失败 err:%v", err)
		resp.WriteAsJson(res)
		return
	}
	topology, err := h.svc.QueryTopology(treeId)
	if err != nil {
		res.Code = 500
		res.Message = err.Error()
		resp.WriteAsJson(res)
		return
	}
	res.Data = topology
	resp.WriteAsJson(res)
	return
}

func (h *Handler) installNode(req *restful.Request, resp *restful.Response) {
	resp.AddHeader(restful.HEADER_AccessControlAllowOrigin, "*")
	res := &models.CommonResult{
		Code:    200,
		Message: "success",
		Data:    nil,
	}
	noderef := businessManagement.NodeRef{}
	err := req.ReadEntity(&noderef)
	if err != nil {
		res.Code = 500
		res.Message = fmt.Sprintf("参数解析失败 err:%v", err)
		resp.WriteAsJson(res)
		return
	}

	err = h.svc.InstallNode(noderef)
	if err != nil {
		res.Code = 500
		res.Message = err.Error()
		resp.WriteAsJson(res)
		return
	}
	resp.WriteAsJson(res)
	return
}

func (h *Handler) uninstallNode(req *restful.Request, resp *restful.Response) {
	resp.AddHeader(restful.HEADER_AccessControlAllowOrigin, "*")
	res := &models.CommonResult{
		Code:    200,
		Message: "success",
		Data:    nil,
	}
	refIdstr := req.PathParameter("refId")
	refId, err := strconv.Atoi(refIdstr)
	if err != nil {
		res.Code = 500
		res.Message = fmt.Sprintf("参数解析失败 err:%v", err)
		resp.WriteAsJson(res)
		return
	}

	err = h.svc.UninstallNode(refId)
	if err != nil {
		res.Code = 500
		res.Message = err.Error()
		resp.WriteAsJson(res)
		return
	}
	resp.WriteAsJson(res)
	return
}

func (h *Handler) SimplifyTopologyHandler(req *restful.Request, resp *restful.Response) {
	resp.AddHeader(restful.HEADER_AccessControlAllowOrigin, "*")
	res := &models.CommonResult{
		Code:    200,
		Message: "success",
		Data:    nil,
	}
	treeIdStr := req.QueryParameter("treeId")
	treeId, err := strconv.Atoi(treeIdStr)
	if err != nil {
		res.Code = 500
		res.Message = fmt.Sprintf("参数解析失败 err:%v", err)
		resp.WriteAsJson(res)
		return
	}
	simplifyTopology, err := h.svc.QuerySimplifyTopology(treeId)

	if err != nil {
		res.Code = 500
		res.Message = err.Error()
		resp.WriteAsJson(res)
		return
	}
	res.Data = simplifyTopology
	resp.WriteAsJson(res)
	return
}

func (h *Handler) GetEaglesServiceGroupHandler(req *restful.Request, resp *restful.Response) {
	resp.AddHeader(restful.HEADER_AccessControlAllowOrigin, "*")
	res := &models.CommonResult{
		Code:    200,
		Message: "success",
		Data:    nil,
	}
	serviceGroup, err := h.svc.GetEaglesServiceGroup()
	if err != nil {
		res.Code = 500
		res.Message = err.Error()
		resp.WriteAsJson(res)
		return
	}
	res.Data = serviceGroup
	resp.WriteAsJson(res)
	return
}

func (h *Handler) GetServiceInstanceByHostNameHandler(req *restful.Request, resp *restful.Response) {
	resp.AddHeader(restful.HEADER_AccessControlAllowOrigin, "*")
	res := &models.CommonResult{
		Code:    200,
		Message: "success",
		Data:    nil,
	}
	hostname := req.QueryParameter("hostname")
	svcis, err := h.svc.QueryServiceInstanceByHostNameList(hostname)
	if err != nil {
		res.Code = 500
		res.Message = err.Error()
		resp.WriteAsJson(res)
		return
	}
	res.Data = svcis
	resp.WriteAsJson(res)
	return
}

func (h *Handler) latestProcessHandler(request *restful.Request, response *restful.Response) {
	response.AddHeader("Access-Control-Allow-Origin", "*")
	res := &models.CommonResult{
		Code:    200,
		Message: "success",
		Data:    nil,
	}

	f, _ := strconv.Atoi(request.Request.URL.Query().Get("f"))
	list, err := h.svc.LatestProcessList(f)
	if err != nil {
		res.Code = 500
		res.Message = err.Error()
		response.WriteAsJson(res)
		return
	}
	res.Data = list
	response.WriteAsJson(res)
}

func (h *Handler) testHandler(request *restful.Request, response *restful.Response) {
	response.AddHeader("Access-Control-Allow-Origin", "*")
	res := &models.CommonResult{
		Code:    200,
		Message: "success",
		Data:    nil,
	}

	page, err := aggregates.List(h.aggregateService.Novaclient).AllPages()
	if err != nil {
		klog.Errorln("aggregates.List(h.Novaclient).AllPages() err:", err)
		err = nil

	}
	aggs, err := aggregates.ExtractAggregates(page)

	jsons, errs := json.Marshal(aggs) //转换成JSON返回的是byte[]
	if errs != nil {
		fmt.Println(errs.Error())
	}

	klog.Infoln("aggs:", string(jsons))

	//hostArr := [3]string{"qd01-test-yinhe177004202.qd01.ksyun.com", "qd01-cp-compute177009024.qd01.ksyun.com", "qd01-cp-compute177009023.qd01.ksyun.com"}

	//hostArr := [1]string{"qd01-test-yinhe177004202.qd01.ksyun.com"}

	//for _, v := range hostArr {
	//	klog.Info(v)
	//	page, err := servers.List(h.aggregateService.Novaclient, servers.ListOpts{Host: v, AllTenants: true}).AllPages()
	//	if err != nil {
	//		klog.Errorln("servers.List(h.Novaclient, servers.ListOpts{Host: host, AllTenants: true}).AllPages() err:", err)
	//
	//	}
	//	instances, err := servers.ExtractServers(page)
	//	if err != nil {
	//		klog.Errorln("servers.ExtractServers(page) err:", err)
	//
	//	}
	//
	//	jsons, errs := json.Marshal(instances) //转换成JSON返回的是byte[]
	//	if errs != nil {
	//		fmt.Println(errs.Error())
	//	}
	//
	//	klog.Infoln("instances:", string(jsons))
	//
	//}

	response.WriteAsJson(res)
}

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/pkg/api/eip/register.go
```golang
package eip

import (
	"github.com/emicklei/go-restful"
	restfulspec "github.com/emicklei/go-restful-openapi"
	"luban-cmdb-api/pkg/models/eip"
	"luban-cmdb-api/pkg/runtime"
	eip2 "luban-cmdb-api/pkg/service/eip"
)

const APIGroup = "eip"

func AddToContainer(c *restful.Container) error {
	eipTag := []string{"eip"}
	ws := runtime.NewWebService(APIGroup)
	//ToDo: create service
	eipService := eip2.NewService()
	handler := NewHandler(eipService)

	ws.Route(ws.GET("resourcePool/overView/eipUtilization").To(handler.getEipUtilizationHandler).
		Doc("获取弹性ip使用率").
		Param(ws.QueryParameter("region", "region, 全部请传入空")).
		Metadata(restfulspec.KeyOpenAPITags, eipTag).
		Returns(200, "ok", []eip.Utilization{}))

	ws.Route(ws.GET("resourcePool/overView/eipUtilizationTrend").To(handler.getEipUtilizationTrendHandler).
		Doc("获取弹性ip使用率趋势").
		Param(ws.QueryParameter("region", "region, 全部请传入空")).
		Param(ws.QueryParameter("begin", "begin: 开始时间时间戳")).
		Param(ws.QueryParameter("end", "end：结束时间时间戳")).
		Metadata(restfulspec.KeyOpenAPITags, eipTag).
		Returns(200, "ok", []eip.UtilizationTrend{}))

	ws.Route(ws.POST("resourcePool/resourceList").To(handler.getResourceListHandler).
		Doc("基于region获取资源列表").
		Reads(eip.SegParams{}, "PageNo:当前页码\nPageSize：页大小\ncidr:网段模糊查询参数\nRegion:region,若选择全部请传入空字符串\nIpVersion:IP版本，若选择全部直接传入空数组即可，选择某一项直接传入一个长度为一的数组").
		Metadata(restfulspec.KeyOpenAPITags, eipTag).
		Returns(200, "ok", eip.EipResponse{}))

	ws.Route(ws.GET("resourcePool/resourceDetail").To(handler.getDetailHandler).
		Doc("基于region查询基础信息（资源详情、库存页共用）").
		Metadata(restfulspec.KeyOpenAPITags, eipTag).
		Param(ws.QueryParameter("region", "region")).
		Param(ws.QueryParameter("cidr", "cidr")).
		Returns(200, "ok", eip.Segment{}))

	ws.Route(ws.POST("resourcePool/segmentList").To(handler.getSegmentByCidrListHandler).
		Doc("根据cidrs或regions查询网段列表").
		Metadata(restfulspec.KeyOpenAPITags, eipTag).
		Reads(eip.SegByListParams{}, "cidrs:cidr列表\nregions:region列表").
		Returns(200, "ok", eip.EipResponse{}))

	ws.Route(ws.POST("resourcePool/eipList").To(handler.getEipListHandler).
		Doc("根据网段查询eip列表").
		Metadata(restfulspec.KeyOpenAPITags, eipTag).
		Reads(eip.GetEipListParams{}, "Segment:网段\nBoundState:状态\nWayType:线路类型\nIpVersion:Ip类型\nBoundType:绑定实例类型\nPageSize:页大小\nPageNo:页位置").
		Returns(200, "ok", eip.EipResponse{}))

	ws.Route(ws.GET("resourcePool/boundTypeList").
		To(handler.getBoundTypeListHandler).
		Doc("获取eip列表绑定类型").
		Metadata(restfulspec.KeyOpenAPITags, eipTag).
		Returns(200, "ok", []map[string]interface{}{{"fieldCode": "lb", "fieldValue": "负载均衡"}, {"fieldCode": "nat", "fieldValue": "网络地址转换"}, {"fieldCode": "vpc_vm", "fieldValue": "云主机"}}))

	ws.Route(ws.GET("resourcePool/wayTypeList").
		To(handler.getWayTypeListHandler).
		Doc("获取eip列表线路类型").
		Metadata(restfulspec.KeyOpenAPITags, eipTag).
		Returns(200, "ok", []string{"BGP", "console-eip"}))

	ws.Route(ws.GET("cloudProduct/eipOverview").To(handler.getEipOverviewHandler).
		Doc("获取弹性ip概览，包括弹性ip状态、绑定实例类型、弹性ip分布概览").
		Metadata(restfulspec.KeyOpenAPITags, eipTag).
		Param(ws.QueryParameter("region", "region")).
		Returns(200, "OK", eip.EipOverview{}))
	ws.Route(ws.POST("cloudProduct/eipList").To(handler.getEipResourceListHandler).
		Doc("弹性IP资源列表").
		Metadata(restfulspec.KeyOpenAPITags, eipTag).
		Reads(eip.GetEipResourceListParams{}, "cidr:所属网段\nregion:region\nsearchType:搜索类型 (IP地址/租户ID/绑定实例名称)\nsearchValue：搜索值\nboundState:状态\nipVersion:Ip版本\nwayType:线路类型\nboundType:绑定实例状态").
		Returns(200, "OK", eip.EipResponse{}))
	ws.Route(ws.GET("cloudProduct/instanceDetail").To(handler.getInstanceDetailHandler).
		Doc("获取获取资源详情").
		Metadata(restfulspec.KeyOpenAPITags, eipTag).
		Param(ws.QueryParameter("ipAddr", "IP地址")).
		Returns(200, "OK", eip.BoundInstanceResponse{}))

	ws.Route(ws.GET("allSegment").To(handler.allSegment).
		Doc("根据绑定实例获取资源详情").
		Metadata(restfulspec.KeyOpenAPITags, eipTag).
		Returns(200, "OK", []eip.Segment{}))
	ws.Route(ws.GET("cidrList").To(handler.cidrList).
		Doc("通过regionAggregateCode获取到区域下所有网段").
		Metadata(restfulspec.KeyOpenAPITags, eipTag).
		Param(ws.QueryParameter("region", "regionAggregateCode")).
		Returns(200, "OK", []eip.Segment{}))

	ws.Route(ws.GET("ipVersionMapping").To(handler.getIpVersionMapping).
		Doc("获取Ip版本号列表").
		Metadata(restfulspec.KeyOpenAPITags, eipTag).
		Returns(200, "ok", []eip.IpVersionMapping{}))

	ws.Route(ws.GET("boundStateMapping").To(handler.getBoundStateMapping).
		Doc("获取绑定状态列表").
		Metadata(restfulspec.KeyOpenAPITags, eipTag).
		Returns(200, "OK", []eip.BoundStateMapping{}))

	c.Add(ws)
	return nil
}

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/pkg/api/eip/handler.go
```golang
package eip

import (
	"context"
	"errors"
	"luban-cmdb-api/pkg/gredis"
	"luban-cmdb-api/pkg/models"
	"luban-cmdb-api/pkg/models/eip"
	"strconv"
	"time"

	"github.com/emicklei/go-restful"
)

type EipService interface {
	//GetEipUtilization(regions []string) ([]eip.Utilization, error)
	GetEipUtilization(aggregateCode string) (map[string]interface{}, error)
	GetEipUtilizationTrend(begin, end int64, regions []string) ([]eip.UtilizationTrend, error)
	GetSegmentList(params eip.SegParams) (eip.EipResponse, error)
	GetSegmentByCidr(region, cidr string) (eip.Segment, error)
	GetSegmentByCidrList(region, cidr []string) (eip.SegmentSlice, error)
	GetEipListBySeg(params eip.GetEipListParams) (eip.EipResponse, error)
	GetEipOverview(region string) (eip.EipOverview, error)
	GetEipResourceList(params eip.GetEipResourceListParams) (eip.EipResponse, error)
	GetBoundInstanceDetail(ipAddr string) (eip.BoundInstanceResponse, error)
	AllSegment() ([]eip.Segment, error)
	CidrListByRegions(regions []string) (cidrs []string)
}

type Handler struct {
	svc EipService
}

func NewHandler(eipService EipService) *Handler {
	return &Handler{
		svc: eipService,
	}
}

func (h *Handler) getEipUtilizationHandler(req *restful.Request, resp *restful.Response) {
	resp.AddHeader(restful.HEADER_AccessControlAllowOrigin, "*")
	region := req.QueryParameter("region")
	res := &models.CommonResult{
		Code:    200,
		Message: "success",
		Data:    nil,
	}
	//var queryParam []string
	var queryParam string
	//if region == "" {
	//	res.Code = 500
	//	res.Message = "region信息不能为空"
	//	resp.WriteAsJson(res)
	//	return
	//} else
	//if region != "all" {
	if region != "" {
		//queryParam = append(queryParam, region)
		queryParam = region
	}
	//else {
	//	aggregateCodes, err := basic.GetAllRegionAggregateCode()
	//	//aggregateCodes, err := basic.GetRegionList(basic.Region{})
	//	if err != nil {
	//		res.Code = 500
	//		res.Message = err.Error()
	//		resp.WriteAsJson(res)
	//		return
	//	}
	//	queryParam = append(queryParam, aggregateCodes...)
	//}
	data, err := h.svc.GetEipUtilization(queryParam)
	if err != nil {
		res.Code = 500
		res.Message = err.Error()
		resp.WriteAsJson(res)
		return
	}
	res.Data = data
	resp.WriteAsJson(res)
}

func (h *Handler) getEipUtilizationTrendHandler(req *restful.Request, resp *restful.Response) {
	resp.AddHeader(restful.HEADER_AccessControlAllowOrigin, "*")
	res := &models.CommonResult{
		Code:    200,
		Message: "success",
		Data:    nil,
	}
	region := req.QueryParameter("region")
	beginStr := req.QueryParameter("begin")
	endStr := req.QueryParameter("end")
	begin, err := strconv.ParseInt(beginStr, 10, 64)
	end, err := strconv.ParseInt(endStr, 10, 64)

	if err != nil {
		res.Code = 500
		res.Message = err.Error()
		resp.WriteAsJson(res)
		return
	}
	var regionsParams []string
	if region != "" {
		regionsParams = append(regionsParams, region)
	}
	data, err := h.svc.GetEipUtilizationTrend(begin, end, regionsParams)
	if err != nil {
		res.Code = 500
		res.Message = err.Error()
		resp.WriteAsJson(res)
		return
	}
	res.Data = data
	resp.WriteAsJson(res)
}

func (h *Handler) getResourceListHandler(req *restful.Request, resp *restful.Response) {
	resp.AddHeader(restful.HEADER_AccessControlAllowOrigin, "*")
	res := &models.CommonResult{
		Code:    200,
		Message: "success",
		Data:    nil,
	}
	params := eip.SegParams{}
	err := req.ReadEntity(&params)
	if err != nil {
		res.Code = 500
		res.Message = "参数解析错误"
		resp.WriteAsJson(res)
		return
	}
	list, err := h.svc.GetSegmentList(params)
	if err != nil {
		res.Code = 500
		res.Message = err.Error()
		resp.WriteAsJson(res)
		return
	}
	res.Data = list
	resp.WriteAsJson(res)
}

func (h *Handler) getDetailHandler(req *restful.Request, resp *restful.Response) {
	resp.AddHeader(restful.HEADER_AccessControlAllowOrigin, "*")
	res := &models.CommonResult{
		Code:    200,
		Message: "success",
		Data:    nil,
	}
	region := req.QueryParameter("region")
	if region == "" {
		res.Code = 500
		res.Message = "region不能为空"
		resp.WriteAsJson(res)
		return
	}
	cidr := req.QueryParameter("cidr")
	if cidr == "" {
		res.Code = 500
		res.Message = "cidr不能为空"
		resp.WriteAsJson(res)
		return
	}
	segment, err := h.svc.GetSegmentByCidr(region, cidr)
	if err != nil {
		res.Code = 500
		res.Message = err.Error()
		resp.WriteAsJson(res)
		return
	}
	res.Data = segment
	resp.WriteAsJson(res)
}

func (h *Handler) getSegmentByCidrListHandler(req *restful.Request, resp *restful.Response) {
	resp.AddHeader(restful.HEADER_AccessControlAllowOrigin, "*")
	res := &models.CommonResult{
		Code:    200,
		Message: "success",
		Data:    nil,
	}

	params := eip.SegByListParams{}
	err := req.ReadEntity(&params)
	if err != nil {
		res.Code = 500
		res.Message = err.Error()
		resp.WriteAsJson(res)
		return
	}
	//if len(params.RegionList) == 0 && len(params.CidrList) == 0 {
	//	res.Code = 500
	//	res.Message = "regions/cidrs 不能同时为空"
	//	resp.WriteAsJson(res)
	//	return
	//}
	segment, err := h.svc.GetSegmentByCidrList(params.RegionList, params.CidrList)
	if err != nil {
		res.Code = 500
		res.Message = err.Error()
		resp.WriteAsJson(res)
		return
	}
	res.Data = segment
	resp.WriteAsJson(res)
}

func (h *Handler) getEipListHandler(req *restful.Request, resp *restful.Response) {
	resp.AddHeader(restful.HEADER_AccessControlAllowOrigin, "*")
	res := &models.CommonResult{
		Code:    200,
		Message: "success",
		Data:    nil,
	}
	params := eip.GetEipListParams{}
	err := req.ReadEntity(&params)
	if err != nil || params.Segment == "" {
		res.Code = 500
		res.Message = "参数解析错误或segment为空！"
		resp.WriteAsJson(res)
		return
	}
	if params.PageNo < 1 || params.PageSize < 1 {
		res.Code = 500
		res.Message = errors.New("pageNo or pageSize must not less than 1").Error()
		resp.WriteAsJson(res)
		return
	}
	data, err := h.svc.GetEipListBySeg(params)
	if err != nil {
		res.Code = 500
		res.Message = err.Error()
		resp.WriteAsJson(res)
		return
	}
	res.Data = data
	resp.WriteAsJson(res)
}

func (h *Handler) getEipOverviewHandler(req *restful.Request, resp *restful.Response) {
	resp.AddHeader(restful.HEADER_AccessControlAllowOrigin, "*")
	res := &models.CommonResult{
		Code:    200,
		Message: "success",
		Data:    nil,
	}
	region := req.QueryParameter("region")
	overview, err := h.svc.GetEipOverview(region)
	if err != nil {
		res.Code = 500
		res.Message = err.Error()
		resp.WriteAsJson(res)
		return
	}
	res.Data = overview
	resp.WriteAsJson(res)
}

func (h *Handler) getEipResourceListHandler(req *restful.Request, resp *restful.Response) {
	resp.AddHeader(restful.HEADER_AccessControlAllowOrigin, "*")
	res := &models.CommonResult{
		Code:    200,
		Message: "success",
		Data:    nil,
	}
	params := eip.GetEipResourceListParams{}
	err := req.ReadEntity(&params)
	if err != nil {
		res.Code = 500
		res.Message = "参数解析错误"
		resp.WriteAsJson(res)
		return
	}
	if params.PageSize <= 0 {
		params.PageSize = 10
	}
	if params.PageNo < 1 {
		params.PageNo = 1
	}

	data, err := h.svc.GetEipResourceList(params)
	if err != nil {
		res.Code = 500
		res.Message = err.Error()
		resp.WriteAsJson(res)
		return
	}
	res.Data = data
	resp.WriteAsJson(res)
}

func (h *Handler) getInstanceDetailHandler(req *restful.Request, resp *restful.Response) {
	resp.AddHeader(restful.HEADER_AccessControlAllowOrigin, "*")
	res := &models.CommonResult{
		Code:    200,
		Message: "success",
		Data:    nil,
	}
	ipAddr := req.QueryParameter("ipAddr")
	if ipAddr == "" {
		res.Code = 500
		res.Message = "ipAddr不能为空"
		resp.WriteAsJson(res)
		return
	}
	detail, err := h.svc.GetBoundInstanceDetail(ipAddr)
	if err != nil {
		res.Code = 500
		res.Message = err.Error()
		resp.WriteAsJson(res)
		return
	}
	res.Data = detail
	resp.WriteAsJson(res)
}

func (h *Handler) allSegment(req *restful.Request, resp *restful.Response) {
	resp.AddHeader(restful.HEADER_AccessControlAllowOrigin, "*")
	res := models.CommonResult{
		Code: 200,
	}
	ls, err := h.svc.AllSegment()
	if err != nil {
		res.Code = 500
		res.Message = err.Error()
		resp.WriteAsJson(res)
		return
	}
	res.Data = ls
	resp.WriteAsJson(res)
}

func (h *Handler) getIpVersionMapping(req *restful.Request, resp *restful.Response) {
	resp.AddHeader(restful.HEADER_AccessControlAllowOrigin, "*")
	res := models.CommonResult{
		Code:    200,
		Message: "success",
		Data:    []eip.IpVersionMapping{{IpVersionName: "IPv4", IpVersion: "4"}, {IpVersionName: "IPv6", IpVersion: "6"}},
	}
	resp.WriteAsJson(res)
}

func (h *Handler) cidrList(req *restful.Request, resp *restful.Response) {
	resp.AddHeader(restful.HEADER_AccessControlAllowOrigin, "*")
	region := req.QueryParameter("region")
	res := models.CommonResult{
		Code:    200,
		Message: "success",
	}
	cidrList := h.svc.CidrListByRegions([]string{region})
	res.Data = cidrList
	resp.WriteAsJson(res)
}

func (h *Handler) getBoundStateMapping(req *restful.Request, resp *restful.Response) {
	resp.AddHeader(restful.HEADER_AccessControlAllowOrigin, "*")
	res := models.CommonResult{
		Code:    200,
		Message: "success",
		//0:保留；1:未分配；2：已分配未绑定；3已绑定
		Data: []eip.BoundStateMapping{{BoundState: 0, BoundStateName: "保留"}, {BoundState: 1, BoundStateName: "未分配"}, {BoundState: 2, BoundStateName: "已分配未绑定"}, {BoundState: 3, BoundStateName: "已绑定"}},
	}
	resp.WriteAsJson(res)
}

func (h *Handler) getBoundTypeListHandler(req *restful.Request, resp *restful.Response) {
	resp.AddHeader(restful.HEADER_AccessControlAllowOrigin, "*")
	res := models.CommonResult{
		Code:    200,
		Message: "success",
		Data: []map[string]interface{}{
			{"fieldCode": "lb", "fieldValue": "SLB"},
			{"fieldCode": "nat", "fieldValue": "NAT"},
			{"fieldCode": "vpc_vm", "fieldValue": "云主机"},
			{"fieldCode": "notBounded", "fieldValue": "未绑定"}},
	}
	resp.WriteAsJson(res)
}
func (h *Handler) getWayTypeListHandler(req *restful.Request, resp *restful.Response) {
	resp.AddHeader(restful.HEADER_AccessControlAllowOrigin, "*")
	res := models.CommonResult{
		Code: 200,
	}
	ctx, celf := context.WithTimeout(context.Background(), 5*time.Second)
	wayTypes, err := gredis.SMembers(ctx, gredis.WayTypeSetKey)
	celf()
	if err != nil {
		res.Code = 500
		res.Message = err.Error()
		resp.WriteAsJson(res)
		return
	}
	res.Code = 200
	res.Message = "success"
	res.Data = wayTypes
	resp.WriteAsJson(res)
}

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/pkg/apiserver/apiserver.go
```golang
package apiserver

import (
	"context"
	"fmt"
	"luban-cmdb-api/pkg/api/aggregate"
	"luban-cmdb-api/pkg/api/businessManagement"
	"luban-cmdb-api/pkg/api/swagger"
	clientidentity "luban-cmdb-api/pkg/client/identity"
	clientnova "luban-cmdb-api/pkg/client/nova"
	eiptask "luban-cmdb-api/pkg/tasks/eip-task"
	"luban-cmdb-api/pkg/utils"
	"net/http"

	"luban-cmdb-api/pkg/api/deviceroom"
	"luban-cmdb-api/pkg/restfulapi"

	"github.com/emicklei/go-restful"
	"github.com/gophercloud/gophercloud"
	urlruntime "k8s.io/apimachinery/pkg/util/runtime"
	"k8s.io/klog/v2"

	"luban-cmdb-api/pkg/apiserver/config"
	clientdgraph "luban-cmdb-api/pkg/client/dgraph"

	"github.com/dgraph-io/dgo/v200"
)

type APIServer struct {
	Server     *http.Server
	Config     *config.Config
	container  *restful.Container
	NovaClient *gophercloud.ServiceClient
	//20210521 guoyanbo添加
	DgraphClient   *dgo.Dgraph
	IdentityClient *gophercloud.ServiceClient
}

func (s *APIServer) GetContainer() *restful.Container {
	return s.container
}

func (s *APIServer) PrepareRun() error {
	if !s.Config.DisableOpenstackAPI {
		novaClient, err := clientnova.NewClient(*s.Config)
		if err != nil {
			//return errors.Wrap(err, "nova.NewClient()")
			klog.Infoln("nova.NewClient() err:", err)
			err = nil
		} else {
			s.NovaClient = novaClient
		}
		idClient, err := clientidentity.NewClient(*s.Config)
		if err != nil {
			//return errors.Wrap(err, "nova.NewClient()")
			klog.Infoln("nova.idClient() err:", err)
			err = nil
		} else {
			s.IdentityClient = idClient
		}
	}
	//20210521 guoyanbo添加
	dgraphClient, err := clientdgraph.NewClient()
	if err != nil {
		//return errors.Wrap(err, "dgraph.NewClient()")
		klog.Infoln("dgraph.NewClient() err:", err)
		err = nil
	} else {
		s.DgraphClient = dgraphClient
	}
	s.Server = &http.Server{Addr: fmt.Sprintf("%s:%d", s.Config.ListenAddr, s.Config.ListenPort)}
	s.container = restful.NewContainer()
	cors := restful.CrossOriginResourceSharing{
		AllowedDomains: []string{"http://luban.swagger.galaxy.cloud/", "localhost"},
		AllowedMethods: []string{"GET", "POST", "PUT", "DELETE", "OPTIONS", "HEAD"},
		AllowedHeaders: []string{"Content-Type", "Content-Length", "Accept"},
		CookiesAllowed: false,
		Container:      s.container,
	}
	s.container.Router(restful.CurlyRouter{})
	s.container.Filter(cors.Filter)
	s.container.Filter(s.container.OPTIONSFilter)
	s.installAPIs()

	for _, ws := range s.container.RegisteredWebServices() {
		klog.V(0).Infof("%s", ws.RootPath())
	}

	s.Server.Handler = s.container
	return nil
}

func (s *APIServer) Run(stop <-chan struct{}) error {
	ctx, cancel := context.WithCancel(context.Background())
	defer cancel()

	go func() {
		<-stop
		s.Server.Shutdown(ctx)
	}()

	klog.V(0).Infof("Start listening on %s", s.Server.Addr)
	return s.Server.ListenAndServe()
}

func (s *APIServer) installRestfulApi() error {
	container := restfulapi.NewContainer(&restfulapi.ServerContext{
		Config:         s.Config,
		DgraphClient:   s.DgraphClient,
		IdentityClient: s.IdentityClient,
		NovaClient:     s.NovaClient,
	})
	// register restful api
	for _, item := range totalRestfulApi() {
		container.Register(item)
	}
	err := container.Setup(s.container)
	if err != nil {
		return err
	}
	return nil
}

// total api
func totalRestfulApi() []restfulapi.HandlerRegister {
	return []restfulapi.HandlerRegister{
		&deviceroom.Controller{},
	}
}

func (s *APIServer) installAPIs() {
	urlruntime.Must(s.installRestfulApi())
	//urlruntime.Must(server.AddToContainer(s.container, s.DgraphClient))
	//urlruntime.Must(basicmanager.AddToContainer(s.container, s.DgraphClient, s.NovaClient, s.IdentityClient, s.Config))
	//urlruntime.Must(blockStoragePool.AddToContainer(s.container, s.DgraphClient, s.Config))
	//urlruntime.Must(objectStoragePool.AddToContainer(s.container, s.DgraphClient, s.Config))
	//urlruntime.Must(blockStorage.AddToContainer(s.container, s.DgraphClient, s.Config))
	//urlruntime.Must(objectStorage.AddToContainer(s.container, s.Config, s.DgraphClient))
	//urlruntime.Must(handler.AddToContainer(s.container))
	//urlruntime.Must(overview.AddToContainer(s.container, s.DgraphClient, s.NovaClient, s.IdentityClient, s.Config))
	//urlruntime.Must(lab.AddToContainer(s.container, s.DgraphClient))
	//urlruntime.Must(switchMachine.AddToContainer(s.container, s.DgraphClient))
	//urlruntime.Must(cabinet.AddToContainer(s.container, s.DgraphClient))
	//urlruntime.Must(rack.AddToContainer(s.container, s.DgraphClient))
	urlruntime.Must(businessManagement.AddToContainer(s.container, s.NovaClient, s.IdentityClient, *s.Config))
	//urlruntime.Must(eip.AddToContainer(s.container))
	//urlruntime.Must(networkPool.AddToContainer(s.container))
	//urlruntime.Must(lb.AddToContainer(s.container))
	//urlruntime.Must(nat.AddToContainer(s.container))
	//urlruntime.Must(bm.AddToContainer(s.container))
	//urlruntime.Must(bmpool.AddToContainer(s.container))
	//urlruntime.Must(sl.AddToContainer(s.container))
	if !s.Config.DisableOpenstackAPI {
		urlruntime.Must(aggregate.AddToContainer(s.container, s.NovaClient, s.IdentityClient, *s.Config))
		eiptask.InitNovaClient(s.Config, s.NovaClient, s.IdentityClient)
		//// TODO add the remaining containers...
		//go tasks.InitTasks(s.DgraphClient, s.Config, s.NovaClient, s.IdentityClient)
	}
	// 本地开发环境不开启
	if utils.InK8s() {
		////初始化sql执行
		//utils.GoSafe(dao.Construct)
		//
		////switch数据初始化
		//utils.GoSafe(switchdao.FetchSwitchRoles)
		////交换机状态同步
		//utils.GoSafe(tasks.FetchSwitchStatus)
		////服务器状态同步
		//utils.GoSafe(tasks.FetchServerStatus)
		////todo 去除初始化交换机接口表
		////utils.GoSafe(snmptask.InitSwichInterfaceStatus)
		//
		////定时任务
		//utils.GoSafe(func() {
		//	fmt.Printf("task start - 1")
		//	tasks.InitTasks(s.DgraphClient, s.Config, s.NovaClient, s.IdentityClient)
		//	fmt.Printf("task end - 1")
		//
		//})
	}

	urlruntime.Must(swagger.AddToContainer(s.container))
	//go k8slisten.Start()
}

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/pkg/apiserver/config/config.go
```golang
package config

type Config struct {
	ListenAddr string `json:"host"`
	ListenPort uint   `json:"port"`
	Mode       string `json:"mode"`

	CmdbMysql    MySql `json:"cmdbMysql"`
	GalaxyMysql  MySql `json:"galaxyMysql"`
	GalaxyMysql2 MySql `json:"galaxyMysql2"`

	CmdbRedis Redis `json:"cmdbRedis"`

	OpenstackAuth       `json:"openstackAuth,optional"`
	DisableOpenstackAPI bool `json:"disableOpenstackAPI,optional"`
	StorageOptions      `json:"storageOptions,optional"`
	RedisTaskHours      int `json:"redisTaskHours,optional"`
	//NovaInnerApi string `json:"novaInnerApi"`
}

type OpenstackAuth struct {
	AuthURL    string
	Username   string
	Password   string
	TenantName string
	RegionName string
}

type StorageOptions struct {
	CustomerDomain   string
	Ks3DSN           string
	EBSAddr          string
	StorageStateAddr string
	PrometheusAddr   string
	Ks3ServiceAPI    string
}

type MySql struct {
	Host     string `json:"host"`
	UserName string `json:"username"`
	Password string `json:"password"`
}

type Redis struct {
	Host     string `json:"host"`
	UserName string `json:"username"`
	Password string `json:"password"`
	Db       int    `json:"db"`
}

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/pkg/apiserver/config/remote-service-config.go
```golang
package config

import (
	"fmt"
	"luban-cmdb-api/pkg/apiserver/client"
	"os"
)

var (
	PrometheusService    = "prometheus"
	AlertmanagerService  = "alertmanager"
	ElasticsearchService = "elasticsearch"
	DgraphGrpcService    = "dgraph"
	CMDBService          = "CMDB"
	ConfigService        = "Config"

	LocalPrometheusService    = "luban.prometheus.galaxy.cloud"
	LocaltAlertmanagerService = "luban.alert.galaxy.cloud"
	LocalElasticsearchService = "luban.es.galaxy.cloud"
	LocalDgraphGrpcService    = "luban.dgraph9080.galaxy.cloud:80"
	LocalCMDBService          = "luban.cmdb.galaxy.cloud"
	LocalConfigService        = "luban.config.galaxy.cloud"
	TsdbServer                = "moniotortsdb.luban.sdns.galaxy.cloud:4243"

	DefaultPrometheusService    = "pm-kube-prometheus-stack-prometheus.monitoring:9090"
	DefaultAlertmanagerService  = "pm-kube-prometheus-stack-alertmanager.monitoring:9093"
	DefaultElasticsearchService = "elasticsearch-master.elastic-system:9200"
	DefaultDgraphGrpcService    = "dgraph-public-nodeport.dgraph:9080"
	DefaultCMDBService          = "cmdb.luban"
	DefaultConfigService        = "config.luban"
	DefaultK3sEsService         = "ks3es.luban.sdns.galaxy.cloud:9200"
	DefaultK3sServiceAPI        = "serviceapi.kingprivatestorage.com:80"

	DefaultChargeInfoService = "ks3charge.luban.sdns.galaxy.cloud:18080"
	CloudMonitorAlertMySql   = "moniotordb.luban.sdns.galaxy.cloud:3306"

	PhysicalServers = "physical-nodes"
	CurrentRegion   = "CN-SHANGHAI-2" //todo get from environment
	RegionMap       = map[string]string{
		"cn-shanghai-2": "SHPBSRegionOne", //上海2区(VPC)
		"cn-beijing-6":  "TJWQRegion",     //北京6区
	}
	AzMap = map[string]string{
		"cn-shanghai-2a": "ksc_shpbs_zone1001_aggregate_raidssd_1001", //上海可用区(VPC)
	}
	ReasourcePoolMap = map[string]string{
		"ks3":     "ks3",       //上海2区(VPC)ks3,ebs_ssd,ebs3_ssd,ehdd_ehdd
		"ssd3.0":  "ebs3_ssd",  //ebs3_ssd
		"ssd2.0":  "ebs_ssd",   //ebs3_ssd
		"ehdd":    "ehdd_ehdd", //ebs3_ssd
		"sata2.0": "ebs2_sata", //ebs3_ssd
	}

	DefaultSTORAGE_OPTIONS_CUSTOMER_DOMAIN = "cqpcloud.cn"
	DefaultSTORAGE_OPTIONS_KS3_DSN         = "kss:Kingsoft123@tcp(ks3charge.luban.sdns.galaxy.cloud:3306)/ks3api?charset=utf8&parseTime=True&loc=Local" //10.177.9.26
	DefaultSTORAGE_OPTIONS_EBS_ADDR        = fmt.Sprintf("http://ebs.inner.%s", os.Getenv("GALAXY_SUB_DOMAIN"))
)

func GetDefaultUrl(name string) string {
	inCluster := true
	if client.GetClient() == nil {
		inCluster = false
	}
	if PrometheusService == name {
		if inCluster {
			return DefaultPrometheusService
		} else {
			return LocalPrometheusService
		}
	} else if AlertmanagerService == name {
		if inCluster {
			return DefaultAlertmanagerService
		} else {
			return LocaltAlertmanagerService
		}

	} else if ElasticsearchService == name {
		if inCluster {
			return DefaultElasticsearchService
		} else {
			return LocalElasticsearchService
		}

	} else if DgraphGrpcService == name {
		if inCluster {
			return DefaultDgraphGrpcService
		} else {
			return LocalDgraphGrpcService
		}
	} else if CMDBService == name {
		if inCluster {
			return DefaultCMDBService
		} else {
			return LocalCMDBService
		}
	} else if ConfigService == name {
		if inCluster {
			return DefaultConfigService
		} else {
			return LocalConfigService
		}
	} else {
		return ""
	}
}

//获取map所有的key针对region
func GetKeys2(m map[string]string) []string {
	// 数组默认长度为map长度,后面append时,不需要重新申请内存和拷贝,效率很高
	keys := make([]string, 0, len(m))
	for k := range m {
		keys = append(keys, k)
	}
	return keys
}

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/pkg/apiserver/client/outer-client.go
```golang
package client

import (
	"flag"
	"k8s.io/client-go/util/homedir"
	"path/filepath"

	"k8s.io/client-go/kubernetes"
	"k8s.io/client-go/rest"
	"k8s.io/client-go/tools/clientcmd"
	"k8s.io/klog/v2"
)

var (
	OuterClient   *kubernetes.Clientset
	RestfulConfig *rest.Config
	kubeconfig    *string
)

func GetOuterClient() *kubernetes.Clientset {
	if InnerClient != nil {
		return OuterClient
	} else {
		return initOuterClient()
	}
}

func initOuterClient() *kubernetes.Clientset {

	//kubeconfig = flag.String("kubeconfig", "~/.kube/", "absolute path to the kubeconfig file")
	kubeconfig = flag.String("kubeconfig", filepath.Join(homedir.HomeDir(), ".kube", "config"), "absolute path to the kubeconfig file")

	//flag.Parse()

	// use the current context in kubeconfig
	config, err := clientcmd.BuildConfigFromFlags("", *kubeconfig)
	if err != nil {
		klog.Errorf("clientcmd.BuildConfigFromFlags( error: %v", err.Error())
		return nil
	}

	// create the clientset
	clientset, e := kubernetes.NewForConfig(config)
	if e != nil {
		klog.Errorf("kubernetes.NewForConfig(config) error: %v", err.Error())
		return nil
		//panic(e.Error())
	}
	return clientset
}

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/pkg/apiserver/client/inner-client.go
```golang
package client

import (
	"k8s.io/client-go/kubernetes"
	"k8s.io/client-go/rest"
	"k8s.io/klog/v2"
)

var (
	InnerClient *kubernetes.Clientset
	RestConfig  *rest.Config
)

func GetClient() *kubernetes.Clientset {
	if InnerClient != nil {
		return InnerClient
	} else {
		return initClient()
	}
}
func GetToken() string {
	if RestConfig == nil {
		RestConfig, _ = rest.InClusterConfig()
	}
	return RestConfig.BearerToken
}

func initClient() *kubernetes.Clientset {

	config, err := rest.InClusterConfig()

	if err != nil {
		klog.Errorf("init k8s inner client error: %v", err.Error())
		return nil
	}
	// creates the clientset
	clientset, err := kubernetes.NewForConfig(config)
	if err != nil {
		klog.Errorf("get k8s inner client set error: %v", err.Error())
		return nil
	}
	return clientset
}

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/pkg/apiserver/client/prom-client.go
```golang
package client

import (
	"context"
	"github.com/prometheus/client_golang/api"
	"github.com/prometheus/client_golang/api/prometheus/v1"
	"github.com/prometheus/common/model"
	"k8s.io/klog/v2"
	"time"
)

type PromClient struct {
	apiClient v1.API
}

func NewPromClient() *PromClient{
	return &PromClient{
		apiClient: defaultPromQueryApi(),
	}
}

func defaultPromQueryApi() v1.API{
	inCluster := true
	if GetClient() == nil {
		inCluster = false
	}
	promConfig := api.Config{}
	if(inCluster){
		promConfig.Address = "http://pm-kube-prometheus-stack-prometheus.monitoring:9090"
	}else{
		promConfig.Address = "http://luban.prometheus.galaxy.cloud"
	}
	//promConfig := api.Config{
	//	Address: config.GetDefaultUrl(config.PrometheusService),
	//}
	client, err := api.NewClient(promConfig)
	if(err == nil){
		return v1.NewAPI(client)
	}else{
		klog.Errorf("init prometheus client error : %s",err.Error())
		return nil
	}
}

func (c *PromClient) Query(query string, ts time.Time) (model.Value, v1.Warnings, error){
	klog.Infof("prometheus query sql: %s", query)
	ctx := context.Background()
	return c.apiClient.Query(ctx,query,ts)
}


func (c *PromClient) QueryRange(query string, r v1.Range) (model.Value, v1.Warnings, error){
	klog.Infof("prometheus query sql: %s", query)
	ctx := context.Background()
	return c.apiClient.QueryRange(ctx,query,r)
}

//	// Query performs a query for the given time.
//	Query(ctx context.Context, query string, ts time.Time) (model.Value, Warnings, error)
//	// QueryRange performs a query for the given range.
//	QueryRange(ctx context.Context, query string, r Range) (model.Value, Warnings, error)


```

File path: /Users/mac/Desktop/woker_code/cmdb-api/pkg/service/blockStoragePool_test.go
```golang
package service

import (
	"encoding/json"
	"fmt"
	urlParser "net/url"
	"strconv"
	"testing"

	"luban-cmdb-api/pkg/models/storage"
)

type MockEbsHttpClient struct {
	Total int
}

func newMockEbsHttpClient(total int) *MockEbsHttpClient {
	return &MockEbsHttpClient{
		Total: total,
	}
}

func (m *MockEbsHttpClient) SimpleHttpGet(url string) ([]byte, error) {
	u, err := urlParser.Parse(url)
	if err != nil {
		return nil, err
	}
	kv, err := urlParser.ParseQuery(u.RawQuery)
	if err != nil {
		return nil, err
	}
	offset, err := strconv.Atoi(kv.Get("offset"))
	if err != nil {
		offset = 0
	}
	size, err := strconv.Atoi(kv.Get("size"))
	if err != nil {
		size = 20
	}
	res := new(EBSAPIResponse)
	for i := 0; i < m.Total; i++ {
		res.Volumes = append(res.Volumes, EBSVolume{
			Region:     "shanghai-2",
			VolumeId:   fmt.Sprintf("%d", i),
			VolumeName: fmt.Sprintf("test-volume-%d", i),
			VmId:       fmt.Sprintf("%d", i),
			Zone:       fmt.Sprintf("zone-%d", i),
		})
	}

	insId := kv.Get("volumeId")
	if insId != "" {
		var volumes []EBSVolume
		for _, volume := range res.Volumes {
			if volume.VolumeId == insId {
				volumes = append(volumes, volume)
			}
		}
		res.Volumes = volumes
		res.Total = 1
		return json.Marshal(res)
	}

	res.Total = m.Total
	realOffset := offset * size
	limit := realOffset + size
	res.Volumes = res.Volumes[realOffset:limit]
	return json.Marshal(res)
}

type MockStorageStateHttpClient struct {
	TotalGB int
	UsedGB  int
}

func (m *MockStorageStateHttpClient) SimpleHttpGet(url string) ([]byte, error) {
	resp := new(StorageStateResponse)
	resp.TotalGB = m.TotalGB
	resp.UsedGB = m.UsedGB
	return json.Marshal(resp)
}

func TestBlockStoragePool_GetPoolDiskList(t *testing.T) {
	testCases := []struct {
		Name       string
		HttpClient HttpClient
		Total      int
		PageNo     int
		PageSize   int
	}{
		{
			Name:       "regular-test-flow",
			Total:      100,
			HttpClient: newMockEbsHttpClient(100),
			PageNo:     1,
			PageSize:   10,
		},
	}

	for _, testCase := range testCases {
		t.Run(testCase.Name, func(t *testing.T) {
			svc := &BlockStoragePoolService{
				EBSAddr:    "http://ebs.ksyun.com",
				HttpClient: testCase.HttpClient,
			}
			resp, err := svc.GetPoolDiskList("", "", testCase.PageNo, testCase.PageSize, []string{}, []string{}, []string{})
			if err != nil {
				t.Fatalf("%s", err)
			}
			if resp.TotalCount != testCase.Total {
				t.Fatalf("resp.Total should be 100, got %d", resp.TotalCount)
			}
			if len(resp.DataList) != testCase.PageSize {
				t.Fatalf("resp.Returns len should be %d, got %d", testCase.PageSize, len(resp.DataList))
			}
		})
	}
}

func TestBlockStoragePoolService_GetPoolStock(t *testing.T) {
	testCases := []struct {
		Name       string
		HttpClient HttpClient
		PageNo     int
		PageSize   int
		TotalGB    int
		UsedGB     int
	}{
		{
			Name:       "regular-test-flow",
			HttpClient: &MockStorageStateHttpClient{TotalGB: 100, UsedGB: 50},
			TotalGB:    100,
			UsedGB:     50,
		}, {
			Name:       "regular-test-flow-percent-60",
			HttpClient: &MockStorageStateHttpClient{TotalGB: 100, UsedGB: 60},
			TotalGB:    100,
			UsedGB:     60,
		},
	}
	for _, testCase := range testCases {
		t.Run(testCase.Name, func(t *testing.T) {
			svc := &BlockStoragePoolService{
				EBSAddr:          "",
				StorageStateAddr: "http://1.1.1.1",
				HttpClient:       testCase.HttpClient,
			}
			resp, err := svc.GetPoolStock("", testCase.PageNo, testCase.PageSize)
			if err != nil {
				t.Fatalf("get stock error: %s", err)
			}
			usePercent := testCase.UsedGB / testCase.TotalGB
			free := testCase.TotalGB - testCase.UsedGB
			if resp.DataList[0].Total != testCase.TotalGB {
				t.Fatalf("returns total not right: %d", resp.DataList[0].Total)
			}
			if resp.DataList[0].UsedPercent != usePercent {
				t.Fatalf("returns usePercent not right: %d", resp.DataList[0].UsedPercent)
			}
			if resp.DataList[0].Free != free {
				t.Fatalf("returns free not right: %d", resp.DataList[0].Free)
			}
		})
	}
}

func TestBlockStoragePoolService_GetCloudDiskList(t *testing.T) {
	testCases := []struct {
		Name       string
		Req        storage.CloudDiskRequest
		HttpClient *MockEbsHttpClient
		Total      int
	}{
		{
			Name: "regular-test-flow-test-total",
			Req: storage.CloudDiskRequest{
				Pagination: storage.Pagination{
					PageNo:   1,
					PageSize: 10,
				},
			},
			HttpClient: newMockEbsHttpClient(100),
			Total:      100,
		},
	}
	for _, testCase := range testCases {
		t.Run(testCase.Name, func(t *testing.T) {
			svc := &BlockStoragePoolService{
				EBSAddr:    "",
				HttpClient: testCase.HttpClient,
			}
			data, err := svc.GetCloudDiskList(testCase.Req)
			if err != nil {
				t.Fatalf("get cloud disk list error: %s", err)
			}
			if data.TotalCount != testCase.Total {
				t.Fatalf("cloud disk list total not match, got %d, should: %d", data.TotalCount, testCase.Total)
			}
		})
	}
}

func TestBlockStoragePoolService_GetCloudDiskDetail(t *testing.T) {
	testCases := []struct {
		Name       string
		Id         string
		HttpClient *MockEbsHttpClient
	}{
		{
			Name:       "regular-test-flow",
			Id:         "1",
			HttpClient: newMockEbsHttpClient(100),
		},
	}
	for _, testCase := range testCases {
		t.Run(testCase.Name, func(t *testing.T) {
			svc := &BlockStoragePoolService{
				EBSAddr:          "",
				StorageStateAddr: "",
				HttpClient:       testCase.HttpClient,
			}
			data, err := svc.GetCloudDiskDetail(testCase.Id)
			if err != nil {
				t.Fatalf("get cloud disk detail error: %s", err)
			}
			if data.InstanceId != testCase.Id {
				t.Fatalf("instanceId not match, got: %s, should: %s", data.InstanceId, testCase.Id)
			}
		})
	}
}

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/pkg/service/eaglesService.go
```golang
package service

import (
	"luban-cmdb-api/pkg/dao/basic"
	businessManagementDao "luban-cmdb-api/pkg/dao/businessManagement"
	"luban-cmdb-api/pkg/models/businessManagement"
)

var e map[string]string

func init() {
	e = make(map[string]string)
	e["CONTROL"] = "_OPENSTACK_CONTROL"
	e["OPENSTACK-COMPUTE"] = "_OPENSTACK_COMPUTE"
	e["GPU"] = "_OPENSTACK_GPU"
	e["DPVGW"] = "_OPENSTACK_DPVGW"
	e["KTS-MASTER"] = "_KS3_KTS_MASTER"
	e["PROXY"] = "_KS3_KTS_PROXY"
	e["TABLESERVER"] = "_KS3_KTS_TABLESERVER"
	e["NAMESERVER"] = "_KS3_PHENIX_NAMESERVER"
	e["DATASERVER"] = "_KS3_PHENIX_DATASERVER"
	e["KS3-ZOOKEEPER"] = "_KS3_ZOOKEEPER"
	e["KS3-API"] = "_KS3_API"
	e["NGINX"] = "_KS3_NGINX"
	e["DELETEWORKER"] = "_KS3_DELETEWORKER"
	e["KS3-SERVICE"] = "_KS3_SERVICE"
	e["KS3-MYSQL"] = "_KS3_MYSQL"
	e["GLOBALSERVICE"] = "_KS3_GLOBALSERVICE"
	e["KS3-KAFKA"] = "_KS3_KAFKA"
	e["KS3-STORAGE_MONITOR"] = "_KS3_STORAGE-MONITOR"
	e["EBS2.0-SATA-NODE"] = "_EBS_EBS2.0_SATA_NODE"
	e["EBS2.0-SATA-CINDER_VOLUME"] = "_EBS_EBS2.0_SATA_CINDER-VOLUME"
	e["SATA-KICK_NODE"] = "_EBS_EBS2.0_SATA_KICK-NODE"
	e["EBS2.0-SATA-STORAGE_MONITOR"] = "_EBS_EBS2.0_SATA_STORAGE-MONITOR"
	e["EBS2.0-SATA-ZK"] = "_EBS_EBS2.0_SATA_ZK"
	e["EBS2.0-SSD-NODE"] = "_EBS_EBS2.0_SSD_NODE"
	e["EBS2.0-SSD-CINDER_VOLUME"] = "_EBS_EBS2.0_SSD_CINDER-VOLUME"
	e["SSD-KICK_NODE"] = "_EBS_EBS2.0_SSD_KICK-NODE"
	e["EBS2.0-SSD-STORAGE_MONITOR"] = "_EBS_EBS2.0_SSD_STORAGE-MONITOR"
	e["EBS2.0-SSD-ZK"] = "_EBS_EBS2.0_SSD_ZK"
	e["SLA"] = "_EBS_EBS2.0_SLA"
	e["EBS3.0-SSD-NODE"] = "_EBS_EBS3.0_SSD_NODE"
	e["SSD-EBS_MASTER"] = "_EBS_EBS3.0_SSD_EBS-MASTER"
	e["SSD-KYLIN_MASTER"] = "_EBS_EBS3.0_SSD_KYLIN-MASTER"
	e["EBS3.0-SSD-CINDER_VOLUME"] = "_EBS_EBS3.0_SSD_CINDER-VOLUME"
	e["SSD-AUTO_KICK_NODE"] = "_EBS_EBS3.0_SSD_AUTO-KICK-NODE"
	e["SSD-AUTO_KICK_DISK"] = "_EBS_EBS3.0_SSD_AUTO-KICK-DISK"
	e["EBS3.0-SSD-STORAGE_MONITOR"] = "_EBS_EBS3.0_SSD_STORAGE-MONITOR"
	e["EBS3.0-SSD-ZK"] = "_EBS_EBS3.0_SSD_ZK"
	e["SSD_SLA"] = "_EBS_EBS3.0_SSD_SSD-SLA"
	e["EBS3.0-EHDD-NODE"] = "_EBS_EBS3.0_EHDD_NODE"
	e["EHDD-EBS_MASTER"] = "_EBS_EBS3.0_EHDD_EBS-MASTER"
	e["EHDD-KYLIN_MASTER"] = "_EBS_EBS3.0_EHDD_KYLIN-MASTER"
	e["EBS3.0-EHDD-CINDER_VOLUME"] = "_EBS_EBS3.0_EHDD_CINDER-VOLUME"
	e["EHDD-AUTO_KICK_NODE"] = "_EBS_EBS3.0_EHDD_AUTO-KICK-NODE"
	e["EHDD-AUTO_KICK_DISK"] = "_EBS_EBS3.0_EHDD_AUTO-KICK-DISK"
	e["EBS3.0-EHDD-STORAGE_MONITOR"] = "_EBS_EBS3.0_EHDD_STORAGE-MONITOR"
	e["EBS3.0-EHDD-ZK"] = "_EBS_EBS3.0_EHDD_ZK"
	e["EHDD_SLA"] = "_EBS_EBS3.0_EHDD_EHDD-SLA"
	e["KGW"] = "_SDN_KGW"
	e["XGW"] = "_SDN_XGW"
	e["PGW"] = "_SDN_PGW"
	e["NAT"] = "_SDN_NAT"
	e["SGW"] = "_SDN_SGW"
	e["TENGINE"] = "_SDN_TENGINE"
	e["TGW"] = "_SDN_TGW"
	e["DPXGW"] = "_SDN_DPXGW"
	e["SCAN"] = "_SDN_SCAN"
	e["NEUTRON"] = "_SDN_NEUTRON"
	e["DPNAT"] = "_SDN_DPNAT"
	e["DPKGW"] = "_SDN_DPKGW"
	e["DNS"] = "_BASIC_DNS"
	e["NTP"] = "_BASIC_NTP"
	e["PXE"] = "_BASIC_PXE"
	e["MANAGER"] = "_BASIC_MHA_MANAGER"
	e["MHA-MASTER"] = "_BASIC_MHA_MASTER"
	e["SLAVE"] = "_BASIC_MHA_SLAVE"
	e["XTRABACKUP"] = "_BASIC_MHA_XTRABACKUP"
	e["RDS-COMPUTE"] = "_RDS_COMPUTE"
	e["RDS-CONTROL_MASTER"] = "_RDS_CONTROL-MASTER"
	e["RDS-CONTROL_SLAVE"] = "_RDS_CONTROL-SLAVE"
	e["RDS-RABBITMQ"] = "_RDS_RABBITMQ"
	e["KCS-CONTROL_MASTER"] = "_KCS_CONTROL-MASTER"
	e["KCS-CONTROL_SLAVE"] = "_KCS_CONTROL-SLAVE"
	e["KCS-COMPUTE"] = "_KCS_COMPUTE"
	e["KCS-RABBITMQ"] = "_KCS_RABBITMQ"
	e["MONGO-COMPUTE"] = "_MONGO_COMPUTE"
	e["MONGO-RABBITMQ"] = "_MONGO_RABBITMQ"
	e["MONGO-CONTROL_MASTER"] = "_MONGO_CONTROL-MASTER"
	e["MONGO-CONTROL_SLAVE"] = "_MONGO_CONTROL-SLAVE"
	e["BACKUP"] = "_BACKUP_BACKUP"
	e["WAF"] = "_SAFE_WAF"
	e["CA"] = "_SAFE_CA"
	e["DS"] = "_SAFE_DS"
	e["CONSOLE-SERVICE"] = "_CONSOLE_SERVICE"
	e["MIDDLEWARE"] = "_CONSOLE_MIDDLEWARE"
	e["JUMP"] = "_CONSOLE_JUMP"
	e["MONITOR"] = "_CONSOLE_MONITOR"
	e["SCHEDULE"] = "_CONSOLE_SCHEDULE"

}

func (s *BusinessManagementService) GetEaglesServiceGroup() (res []businessManagement.BusinessServiceGroup, err error) {
	queryParams := make([]string, 0, len(e))
	for k, _ := range e {
		queryParams = append(queryParams, k)
	}
	svcs, err := businessManagementDao.QueryServiceByNameGroup(queryParams)
	if err != nil {
		return res, err
	}
	regionColl := make(map[string]string)
	for i := 0; i < len(svcs); i++ {
		regionColl[svcs[i].RegionCode] = "-"
	}
	regionCodes := make([]string, 0, len(regionColl))
	for k, _ := range regionColl {
		regionCodes = append(regionCodes, k)
	}
	regions, err := basic.GetRegionListByRegionCodes(regionCodes)
	for i := 0; i < len(regions); i++ {
		regionColl[regions[i].RegionCode] = regions[i].RegionName
	}
	if err != nil {
		return res, err
	}
	for i := 0; i < len(svcs); i++ {
		res = append(res, businessManagement.BusinessServiceGroup{
			ServiceGroupId:   svcs[i].Id,
			ServiceGroupName: e[svcs[i].Name],
			RegionCode:       svcs[i].RegionCode,
			RegionName:       regionColl[svcs[i].RegionCode],
		})
	}

	return res, nil
}

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/pkg/service/token.go
```golang
package service

import (
	"encoding/json"
	"errors"
	"fmt"
	"io"
	"net/http"

	"github.com/dgrijalva/jwt-go"
)

type UserInfoResponse struct {
	Message string `json:"message"`
	Code    int    `json:"code"`
	Data    struct {
		Total int `json:"total"`
		Data  []struct {
			Name            string `json:"name"`
			Email           string `json:"email"`
			TelephoneNumber string `json:"telephone_number"`
			Type            string `json:"type"`
			CreatedAt       string `json:"created_at"`
			UpdatedAt       string `json:"updated_at"`
			Disable         bool   `json:"disable"`
			Id              string `json:"id"`
		} `json:"data"`
	} `json:"data"`
}

var (
	userInfoApiAddr = "http://idp/idp/v1/users?id=%s&page=1"
	// 以下连接为本地测试环境访问地址
	//userInfoApiAddr = "http://luban.idp.galaxy.cloud/idp/v1/users?id=%s&page=1"
)

// GetUserName 获取userName 注意这里需要使用到其他项目中的接口
// func GetUserName(Authorization string) (string, error) {
// 	if Authorization == "" {
// 		return "", errors.New("header Authorization not found")
// 	}
// 	// 'Authorization: Bearer $BEARER_TOKEN'
// 	idx := strings.Index(Authorization, "Bearer")
// 	if idx == -1 || (idx+7) >= len(Authorization) {
// 		return "", errors.New("header Authorization parse failed")
// 	}
// 	tokenStr := Authorization[idx+7:]
// 	userID, err := validateTokenGetUserId(tokenStr)
// 	if err != nil {
// 		return "", err
// 	}
// 	return getUserInfoFromApi(userID)
// }

func getUserInfoFromApi(userId string) (string, error) {
	response, err := http.Get(fmt.Sprintf(userInfoApiAddr, userId))
	if err != nil {
		return "", err
	}
	defer response.Body.Close()
	bytes, err := io.ReadAll(response.Body)
	if err != nil {
		return "", err
	}
	respInfo := UserInfoResponse{}
	err = json.Unmarshal(bytes, &respInfo)
	if err != nil {
		return "", err
	}
	if len(respInfo.Data.Data) == 0 {
		return "", errors.New("can't get username from api")
	}
	return respInfo.Data.Data[0].Name, nil
}

// 根据token获取payload中的userId，注意，这里的userId存储在Payload中的name段中
func validateTokenGetUserId(tokenStr string) (string, error) {
	token, _, err := new(jwt.Parser).ParseUnverified(tokenStr, jwt.MapClaims{})
	if err != nil {
		return "", errors.New("Invalide token")
	}

	claims, ok := token.Claims.(jwt.MapClaims)
	if !ok {
		return "", errors.New("Invalide token")
	}
	err = claims.Valid()
	if err != nil {
		return "", errors.New("Invalide token")
	}
	if id, ok := claims["name"]; !ok {
		return "", errors.New("user id not found")
	} else {
		return id.(string), nil
	}
}

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/pkg/service/server.go
```golang
package service

import (
	"entgo.io/ent/dialect/sql"
	"fmt"
	"luban-cmdb-api/pkg/dao"
	"luban-cmdb-api/pkg/dao/basic"
	businessManagementDao "luban-cmdb-api/pkg/dao/businessManagement"
	labdao "luban-cmdb-api/pkg/dao/lab"
	"luban-cmdb-api/pkg/dao/rackdao"
	serverdao "luban-cmdb-api/pkg/dao/server"
	"luban-cmdb-api/pkg/dao/switchdao"
	"luban-cmdb-api/pkg/models/aggregate"
	"luban-cmdb-api/pkg/models/hardware"
	"luban-cmdb-api/pkg/models/server"
	"math"
	"strconv"
	"strings"
	"time"

	"gorm.io/gorm"

	"github.com/dgraph-io/dgo/v200"
	"k8s.io/klog/v2"
)

type ServerService struct {
	dgraphClient *dgo.Dgraph
	//aggregateService AggregateService
}

func NewServerService(dgraphClient *dgo.Dgraph) *ServerService {
	return &ServerService{
		dgraphClient: dgraphClient,
		//aggregateService: *NewAggregateService(Novaclient, nil, *config),
	}
}

// 获取服务器所有的列表
func (s *ServerService) GetPhysicalHostList(physicalHostListQuery server.PhysicalHostListQuery) (server.PhysicalHostDataResult, error) {
	res := server.PhysicalHostDataResult{
		PageStruct: server.PageStruct{
			PageNo:     physicalHostListQuery.PageNo,
			PageSize:   physicalHostListQuery.PageSize,
			TotalCount: 0,
		},
		DataList: []server.PhysicalHostData{},
	}
	rows, count, err := serverdao.GetPhysicalHostList(physicalHostListQuery)
	if err != nil {
		klog.Error(err)
		return res, err
	}
	if count <= 0 {
		return res, err
	}
	res.TotalCount = count
	//循环赋值
	defer rows.Close()
	//resourcePoolHostList := s.GetResourcePoolHosts()
	serverList := []server.PhysicalHostData{}
	for rows.Next() {
		var dr server.PhysicalHostData
		dao.AssetDB.ScanRows(rows, &dr)
		serverList = append(serverList, dr)
		// storageType, resourcePool := s.GetResourcePoolByHost(dr.Name, dr.Ip, resourcePoolHostList)
		// dr.ResourcePoolType = storageType
		// dr.ResourcePool = resourcePool
		// if (physicalHostListQuery.StorageType == "" || physicalHostListQuery.StorageType == storageType) &&
		// 	physicalHostListQuery.ResourcePool == "" || physicalHostListQuery.ResourcePool == resourcePool {
		// 	serverList = append(serverList, dr)
		// }
	}

	res.DataList = serverList
	return res, nil
}

// 获取服务器所有的列表
func (s *ServerService) GetPhysicalHostList2(physicalHostListQuery server.PhysicalHostListQuery) (server.PhysicalHostDataResult, error) {
	res := server.PhysicalHostDataResult{
		PageStruct: server.PageStruct{
			PageNo:     physicalHostListQuery.PageNo,
			PageSize:   physicalHostListQuery.PageSize,
			TotalCount: 0,
		},
		DataList: []server.PhysicalHostData{},
	}
	rows, count, err := serverdao.GetPhysicalHostList2(physicalHostListQuery)
	if err != nil {
		klog.Error(err)
		return res, err
	}
	if count <= 0 {
		return res, err
	}
	res.TotalCount = count
	//循环赋值
	defer rows.Close()
	//resourcePoolHostList := s.GetResourcePoolHosts()
	serverList := []server.PhysicalHostData{}
	for rows.Next() {
		var dr server.PhysicalHostData
		dao.AssetDB.ScanRows(rows, &dr)
		serverList = append(serverList, dr)
		// storageType, resourcePool := s.GetResourcePoolByHost(dr.Name, dr.Ip, resourcePoolHostList)
		// dr.ResourcePoolType = storageType
		// dr.ResourcePool = resourcePool
		// if (physicalHostListQuery.StorageType == "" || physicalHostListQuery.StorageType == storageType) &&
		// 	physicalHostListQuery.ResourcePool == "" || physicalHostListQuery.ResourcePool == resourcePool {
		// 	serverList = append(serverList, dr)
		// }
	}

	res.DataList = serverList
	return res, nil
}

// 获取服务器列表根据ips
func (s *ServerService) GetHostListByips(hostListQuery server.HostListQuery) (server.PhysicalHostDataResult, error) {
	res := server.PhysicalHostDataResult{
		PageStruct: server.PageStruct{
			PageNo:     1,
			PageSize:   10,
			TotalCount: 0,
		},
		DataList: []server.PhysicalHostData{},
	}
	pageNo := 1
	pageSize := 100
	//resourcePoolHostList := s.GetResourcePoolHosts()
	serverList := []server.PhysicalHostData{}
	for {
		rows, count, err := serverdao.GetPhysicalHostListByIps(hostListQuery.IpArray, pageNo, pageSize)
		if err != nil {
			klog.Error(err)
			return res, err
		}
		if count <= 0 {
			return res, err
		}
		res.TotalCount = count
		//循环赋值
		defer rows.Close()
		for rows.Next() {
			var dr server.PhysicalHostData
			dao.AssetDB.ScanRows(rows, &dr)
			// storageType, resourcePool := s.GetResourcePoolByHost(dr.Name, dr.Ip, resourcePoolHostList)
			// dr.ResourcePoolType = storageType
			// dr.ResourcePool = resourcePool
			serverList = append(serverList, dr)
		}

		if len(serverList) < pageSize {
			break
		}
		pageNo++
	}
	res.DataList = serverList
	return res, nil
}

// 根据id判断是否存在
func (s *ServerService) CheckHostExist(uid int) (int, error) {
	// 为创建的节点分配的uid将在resp.AssignedUids map中返回。
	//variables := map[string]string{"$id": assigned.Uids["blank-0"]}
	count, err := serverdao.CheckServerExist(uid)
	if err != nil {
		return 0, err
	} else {
		return count, nil
	}
}

// 修改服务器信息
func (s *ServerService) UpdatePhysicalHost(serverEntityNew server.PhysicalHostUpdateEntity) (err error) {

	entityOld, err := serverdao.SelectServerInfo("", "", serverEntityNew.Uid)
	if err != nil {
		return err
	}
	tx := dao.AssetDB.Begin()
	if r := recover(); r != nil {
		tx.Rollback()
	}
	entityMap := make(map[string]interface{})
	entityMap["id"] = serverEntityNew.Uid
	entityMap["out_band_ip"] = serverEntityNew.OutbandIP
	entityMap["assets_number"] = serverEntityNew.Assetsnumber
	entityMap["description"] = serverEntityNew.Description
	entityMap["host_unit_number"] = serverEntityNew.HostUnitNumber
	entityMap["maintenance_due"] = serverEntityNew.MaintenanceDue
	if serverEntityNew.MaintenanceDue != 0 {
		entityMap["maintenance_due"] = time.Unix(serverEntityNew.MaintenanceDue, 0)
	}
	//updateEntity := server.PhysicalServer{
	//	Id: serverEntityNew.Uid,
	//	//LabId:          labInfo.Id,
	//	//RoomId:         serverEntityNew.HostRoomUid,
	//	//CabinetId:      serverEntityNew.HostCabinetUid,
	//	//RackId:         serverEntityNew.HostRackUid,
	//	//HostUnitNumber: serverEntityNew.HostUnitNumber,
	//	OutbandIP:    serverEntityNew.OutbandIP,
	//	Assetsnumber: serverEntityNew.Assetsnumber,
	//	Description:  serverEntityNew.Description,
	//	//MaintenanceDue: serverEntityNew.MaintenanceDue,
	//}
	if serverEntityNew.HostLabCode != "" {
		labInfo, err := labdao.GetLabByCode(serverEntityNew.HostLabCode)
		if err != nil {
			return err
		}
		//updateEntity.LabId = labInfo.Id
		entityMap["lab_id"] = labInfo.Id
	}
	if serverEntityNew.HostRoomUid > 0 {
		//updateEntity.RoomId = serverEntityNew.HostRoomUid
		entityMap["room_id"] = serverEntityNew.HostRoomUid
	}
	if serverEntityNew.HostCabinetUid > 0 {
		//updateEntity.CabinetId = serverEntityNew.HostCabinetUid
		entityMap["cabinet_id"] = serverEntityNew.HostCabinetUid
	}

	if serverEntityNew.HostRackUid > 0 {
		//updateEntity.RackId = serverEntityNew.HostRackUid
		entityMap["rack_id"] = serverEntityNew.HostRackUid
	}
	// if serverEntityNew.HostUnitNumber > 0 {
	// 	//updateEntity.HostUnitNumber = serverEntityNew.HostUnitNumber
	// 	entityMap["host_unit_number"] = serverEntityNew.HostUnitNumber
	// } else {
	// 	entityMap["host_unit_number"] = 0
	// }
	// if serverEntityNew.MaintenanceDue > 0 {
	// 	//updateEntity.MaintenanceDue = serverEntityNew.MaintenanceDue
	// 	entityMap["maintenance_due"] = serverEntityNew.MaintenanceDue
	// } else {
	// 	entityMap["maintenance_due"] = 0
	// }

	err = serverdao.UpdateServerInfo(entityMap, tx)
	if err != nil {
		tx.Rollback()
		return err
	}
	if serverEntityNew.HostRackUid > 0 && serverEntityNew.HostUnitNumber > 0 && serverEntityNew.HostCabinetUid > 0 {
		err = rackdao.UpdateRackStatusByTransactionNew(serverEntityNew.HostRackUid, serverEntityNew.HostUnitNumber, "服务器", entityOld.Name, entityOld.Sn, serverEntityNew.HostCabinetUid, tx)
		if err != nil {
			tx.Rollback()
			return err
		}
	}

	tx.Commit()
	return err
}

// 根据hostName，ip获取资源池类型以及所属资源池
func (s *ServerService) GetResourcePoolByHost(hostName, ip string, resourcePoolHostList []server.ResourcePoolHost) (storageType, resourcePool string) {

	for i := range resourcePoolHostList {
		if hostName == resourcePoolHostList[i].HostName || ip == resourcePoolHostList[i].Ip {
			return resourcePoolHostList[i].StorageType, resourcePoolHostList[i].ResourcePool
		}
	}
	return "", ""

}

// 整合所有资源池对应的服务器列表
func (s *ServerService) GetResourcePoolHosts() []server.ResourcePoolHost {
	//获取所有计算资源池对应的服务器列表
	//aggregateHost := []aggregate.AggregateHost{}
	resourcePoolHostList := []server.ResourcePoolHost{}
	aggregateHost, err := s.GetAggregateHosts() //.AggregateInterface.GetAggregateHosts()
	if err != nil {
		klog.Error(err)
		//return resourcePoolHostList
	} else {
		resourcePoolHostList = append(resourcePoolHostList, aggregateHost...)
	}
	//获取块存储资源池以及对象存储资源池对应的服务器列表
	spList := GetPoolList()
	for i := range spList {
		for j := range spList[i].Addresss {
			resourcePoolHostList = append(resourcePoolHostList, server.ResourcePoolHost{
				StorageType:      spList[i].StorageType,
				ResourcePool:     spList[i].ResourcePool,
				ResourcePoolName: spList[i].Name,
				Ip:               spList[i].Addresss[j],
			})
		}
	}
	return resourcePoolHostList
}

// 获取所有的计算资源池对应的服务器列表用于物理资源管理-服务器 列表获取所属资源池类型以及资源池
func (h *ServerService) GetAggregateHosts() (resList []server.ResourcePoolHost, err error) {
	aggs := aggregate.GetAggregateMap()
	for _, agg := range aggs {
		for i := range agg.Hosts {
			resList = append(resList, server.ResourcePoolHost{
				HostName:         agg.Hosts[i],
				StorageType:      "kec",
				ResourcePool:     agg.Name,
				ResourcePoolName: agg.Name,
			})
		}
	}
	return
}

// 获取单个服务器详情
func (s *ServerService) GetPhysicalHostEntity(name string, id int) (detail server.PhysicalHostDetail, err error) {
	detail.PhysicalServer, err = serverdao.SelectServerInfo(name, "", id)
	if err != nil {
		return
	}
	//获取硬件信息
	sn := detail.PhysicalServer.Sn
	hw := hardware.Hardware{
		Sn: sn,
	}
	hw.FindBySn(dao.AssetDB)
	// cpu信息 不需要根据型号聚合
	for i := 0; i < len(hw.CpuInfo); i++ {
		detail.CpuMessage = append(detail.CpuMessage, server.Cpu{
			CpuType: hw.CpuInfo[i].Model,
			//CpuCore: int32(hw.CpuInfo[i].CoreCount),
			CpuCore: int32(hw.CpuInfo[i].ThreadCount),
			CpuRate: hw.CpuInfo[i].CurrentSpeed,
		})
	}
	// gpu信息 不需要根据型号聚合
	for i := 0; i < len(hw.GpuInfo); i++ {
		detail.GPUMessage = append(detail.GPUMessage, server.Gpu{
			GpuType:  hw.GpuInfo[i].Model,
			Capacity: hw.GpuInfo[i].Size,
		})
	}
	// 网卡信息 需要根据型号聚合 采集时已经聚合
	for i := 0; i < len(hw.NicInfo); i++ {
		detail.NetworkCardMessage = append(detail.NetworkCardMessage, server.Net{
			NetworkCardType: hw.NicInfo[i].Model,
			Count:           int32(hw.NicInfo[i].Count),
		})
	}
	// RAID信息 需要根据型号聚合 采集时已经聚合
	for i := 0; i < len(hw.RaidInfo); i++ {
		detail.RAIDMessage = append(detail.RAIDMessage, server.Raid{
			RaidType: hw.RaidInfo[i].Model,
			Count:    int32(hw.RaidInfo[i].Count),
		})
	}
	// 内存信息
	// [{"size": 16384, "speed": 1600, "assetTag": "", "dataWidth": 64, "deviceSet": 0, "attributes": 2, "formFactor": "DIMM", "memoryType": "DDR3", "partNumber": "713756-081          ", "totalWidth": 72, "typeDetail": "Synchronous,Registered (Buffered)", "bankLocator": "Unknown", "manufacturer": "HP     ", "serialNumber": "Unknown", "deviceLocator": "PROC  1 DIMM  1 ", "configuredVoltage": 0}, {"size": 16384, "speed": 1600, "assetTag": "", "dataWidth": 64, "deviceSet": 3, "attributes": 2, "formFactor": "DIMM", "memoryType": "DDR3", "partNumber": "713756-081          ", "totalWidth": 72, "typeDetail": "Synchronous,Registered (Buffered)", "bankLocator": "Unknown", "manufacturer": "HP     ", "serialNumber": "Unknown", "deviceLocator": "PROC  1 DIMM  4 ", "configuredVoltage": 0}, {"size": 16384, "speed": 1600, "assetTag": "", "dataWidth": 64, "deviceSet": 7, "attributes": 2, "formFactor": "DIMM", "memoryType": "DDR3", "partNumber": "713756-081          ", "totalWidth": 72, "typeDetail": "Synchronous,Registered (Buffered)", "bankLocator": "Unknown", "manufacturer": "HP     ", "serialNumber": "Unknown", "deviceLocator": "PROC  1 DIMM  8 ", "configuredVoltage": 0}, {"size": 16384, "speed": 1600, "assetTag": "", "dataWidth": 64, "deviceSet": 8, "attributes": 2, "formFactor": "DIMM", "memoryType": "DDR3", "partNumber": "713756-081          ", "totalWidth": 72, "typeDetail": "Synchronous,Registered (Buffered)", "bankLocator": "Unknown", "manufacturer": "HP     ", "serialNumber": "Unknown", "deviceLocator": "PROC  1 DIMM  9 ", "configuredVoltage": 0}, {"size": 16384, "speed": 1600, "assetTag": "", "dataWidth": 64, "deviceSet": 10, "attributes": 2, "formFactor": "DIMM", "memoryType": "DDR3", "partNumber": "713756-081          ", "totalWidth": 72, "typeDetail": "Synchronous,Registered (Buffered)", "bankLocator": "Unknown", "manufacturer": "HP     ", "serialNumber": "Unknown", "deviceLocator": "PROC  1 DIMM 11 ", "configuredVoltage": 0}, {"size": 16384, "speed": 1600, "assetTag": "", "dataWidth": 64, "deviceSet": 11, "attributes": 2, "formFactor": "DIMM", "memoryType": "DDR3", "partNumber": "713756-081          ", "totalWidth": 72, "typeDetail": "Synchronous,Registered (Buffered)", "bankLocator": "Unknown", "manufacturer": "HP     ", "serialNumber": "Unknown", "deviceLocator": "PROC  1 DIMM 12 ", "configuredVoltage": 0}, {"size": 16384, "speed": 1600, "assetTag": "", "dataWidth": 64, "deviceSet": 12, "attributes": 2, "formFactor": "DIMM", "memoryType": "DDR3", "partNumber": "713756-081          ", "totalWidth": 72, "typeDetail": "Synchronous,Registered (Buffered)", "bankLocator": "Unknown", "manufacturer": "HP     ", "serialNumber": "Unknown", "deviceLocator": "PROC  2 DIMM  1 ", "configuredVoltage": 0}, {"size": 16384, "speed": 1600, "assetTag": "", "dataWidth": 64, "deviceSet": 15, "attributes": 2, "formFactor": "DIMM", "memoryType": "DDR3", "partNumber": "713756-081          ", "totalWidth": 72, "typeDetail": "Synchronous,Registered (Buffered)", "bankLocator": "Unknown", "manufacturer": "HP     ", "serialNumber": "Unknown", "deviceLocator": "PROC  2 DIMM  4 ", "configuredVoltage": 0}, {"size": 16384, "speed": 1600, "assetTag": "", "dataWidth": 64, "deviceSet": 19, "attributes": 2, "formFactor": "DIMM", "memoryType": "DDR3", "partNumber": "713756-081          ", "totalWidth": 72, "typeDetail": "Synchronous,Registered (Buffered)", "bankLocator": "Unknown", "manufacturer": "HP     ", "serialNumber": "Unknown", "deviceLocator": "PROC  2 DIMM  8 ", "configuredVoltage": 0}, {"size": 16384, "speed": 1600, "assetTag": "", "dataWidth": 64, "deviceSet": 20, "attributes": 2, "formFactor": "DIMM", "memoryType": "DDR3", "partNumber": "713756-081          ", "totalWidth": 72, "typeDetail": "Synchronous,Registered (Buffered)", "bankLocator": "Unknown", "manufacturer": "HP     ", "serialNumber": "Unknown", "deviceLocator": "PROC  2 DIMM  9 ", "configuredVoltage": 0}, {"size": 16384, "speed": 1600, "assetTag": "", "dataWidth": 64, "deviceSet": 22, "attributes": 2, "formFactor": "DIMM", "memoryType": "DDR3", "partNumber": "713756-081          ", "totalWidth": 72, "typeDetail": "Synchronous,Registered (Buffered)", "bankLocator": "Unknown", "manufacturer": "HP     ", "serialNumber": "Unknown", "deviceLocator": "PROC  2 DIMM 11 ", "configuredVoltage": 0}, {"size": 16384, "speed": 1600, "assetTag": "", "dataWidth": 64, "deviceSet": 23, "attributes": 2, "formFactor": "DIMM", "memoryType": "DDR3", "partNumber": "713756-081          ", "totalWidth": 72, "typeDetail": "Synchronous,Registered (Buffered)", "bankLocator": "Unknown", "manufacturer": "HP     ", "serialNumber": "Unknown", "deviceLocator": "PROC  2 DIMM 12 ", "configuredVoltage": 0}]
	memoryIndexer := make(map[string]int)
	for i := 0; i < len(hw.MemoryInfo); i++ {
		// 处理空槽
		if hw.MemoryInfo[i].Size == 0 {
			continue
		}
		if index, ok := memoryIndexer[hw.MemoryInfo[i].PartNumber]; ok {
			detail.MemoryMessage[index].Count++
			detail.MemoryMessage[index].TotalCapacity += int64(hw.MemoryInfo[i].Size)
		} else {
			// 不存在则为不同的内存条
			detail.MemoryMessage = append(detail.MemoryMessage, server.Memory{
				MemoryType:    hw.MemoryInfo[i].PartNumber,
				Count:         1,
				TotalCapacity: int64(hw.MemoryInfo[i].Size),
			})
			memoryIndexer[hw.MemoryInfo[i].PartNumber] = len(detail.MemoryMessage) - 1
		}
	}
	for i := 0; i < len(detail.MemoryMessage); i++ {
		// 单位GB
		//detail.MemoryMessage[i].TotalCapacity /= 1024
		//向上取整
		detail.MemoryMessage[i].TotalCapacity = int64(math.Ceil(float64(detail.MemoryMessage[i].TotalCapacity) / 1024))
	}
	// 硬盘信息
	// [{"size": "598,999,040,000 bytes [598 GB]", "model": "LSI", "serialNumber": "0073415417ac19441ce0cdab90785634"}, {"size": "4,789,989,539,840 bytes [4.78 TB]", "model": "LSI", "serialNumber": "00c1a5be19d419441ce0cdab90785634"}]
	diskIndexer := make(map[string]int)
	for i := 0; i < len(hw.DiskInfo); i++ {
		if index, ok := diskIndexer[hw.DiskInfo[i].Model]; ok {
			detail.DiskMessage[index].Count++
			detail.DiskMessage[index].TotalCapacityByte += typeToRealSize(hw.DiskInfo[i].Size)
		} else {
			// 不存在则为不同型号的硬盘
			detail.DiskMessage = append(detail.DiskMessage, server.Disk{
				DiskType:          hw.DiskInfo[i].Model,
				Count:             1,
				TotalCapacityByte: typeToRealSize(hw.DiskInfo[i].Size),
			})
			diskIndexer[hw.DiskInfo[i].Model] = len(detail.DiskMessage) - 1
		}
	}
	for i := 0; i < len(detail.DiskMessage); i++ {
		value, _ := strconv.ParseFloat(fmt.Sprintf("%.2f", float64(detail.DiskMessage[i].TotalCapacityByte)/float64(1024)/float64(1024)/float64(1024)/float64(1024)), 64)
		detail.DiskMessage[i].TotalCapacity = value
	}
	//获取所属资源池
	resourcePoolHostList := s.GetResourcePoolHosts()
	storageType, resourcePool := s.GetResourcePoolByHost(detail.PhysicalServer.Name, detail.PhysicalServer.Ip, resourcePoolHostList)
	detail.PhysicalServer.ResourcePoolType = storageType
	detail.PhysicalServer.ResourcePool = resourcePool
	return detail, err
}

func typeToRealSize(size string) (res int64) {
	idx := strings.Index(size, "bytes")
	for i := 0; i < idx; i++ {
		if size[i] >= '0' && size[i] <= '9' {
			res *= 10
			res += int64(size[i] - '0')
		}
	}
	return
}

// 根据sn获取单个服务器
func (s *ServerService) GetPhysicalHostEntityBySn(sn string) (detail server.PhysicalServer, err error) {
	detail, err = serverdao.SelectServerInfo("", sn, 0)
	if err != nil {
		return
	}

	return detail, err
}

// 上报信息更新服务器
func (s *ServerService) ReportPhysicalHost(serverEntityNew server.ReportPhysicalHostEntity) (err error) {
	klog.Infof("ReportPhysicalHost_parma : %+v", serverEntityNew)

	if serverEntityNew.Name == "" {
		return fmt.Errorf("hostname信息为空，请检查后添加")
	}
	if serverEntityNew.Ip == "" {
		return fmt.Errorf("ip信息为空，请检查后添加")
	}
	if serverEntityNew.Sn == "" {
		return fmt.Errorf("sn信息为空，请检查后添加")
	}
	if serverEntityNew.Region == "" {
		return fmt.Errorf("region信息为空，请检查后添加")
	}
	if serverEntityNew.Az == "" {
		return fmt.Errorf("az信息为空，请检查后添加")
	}
	if len(serverEntityNew.Node) == 0 {
		return fmt.Errorf("服务器节点信息为空，请检查后添加")
	}

	az, err := basic.GetAz(basic.Az{
		AzCode: serverEntityNew.Az,
	})
	if err != nil {
		return err
	}
	if az.Id == 0 {
		return fmt.Errorf("az信息错误，请检查后添加")
	}
	region, err := basic.GetRegion(basic.Region{
		RegionCode: serverEntityNew.Region,
	})
	if err != nil {
		return err
	}
	if region.Id <= 0 {
		return fmt.Errorf("region信息错误，请检查后添加")
	}

	entityMap := make(map[string]interface{})
	entityMap["sn"] = serverEntityNew.Sn
	entityMap["name"] = serverEntityNew.Name
	entityMap["kind"] = serverEntityNew.Kind
	entityMap["label"] = serverEntityNew.Label
	entityMap["region_id"] = region.Id
	entityMap["region_code"] = region.RegionCode
	entityMap["az_id"] = az.Id
	entityMap["az_code"] = az.AzCode
	entityMap["operate_system"] = serverEntityNew.System
	entityMap["system_sales"] = serverEntityNew.SystemSales
	entityMap["run_status"] = serverEntityNew.Runstatus
	entityMap["cpu_total"] = serverEntityNew.CpuTotal
	entityMap["memory_total"] = serverEntityNew.MemoryTotal
	entityMap["input_method"] = serverEntityNew.InputMethod
	entityMap["cpu_allocation_ratio"] = serverEntityNew.CpuAllocationRatio
	entityMap["ram_allocation_ratio"] = serverEntityNew.RamAllocationRatio
	entityMap["mac_address"] = serverEntityNew.MacAddress
	entityMap["assignment_status"] = serverEntityNew.AssignmentStatus
	// 服务修改成新数据 注意只有上报更新的时候才会查询服务
	//entityMap["service"] = serverEntityNew.Service
	entityMap["server_type"] = serverEntityNew.ServerType
	entityMap["description"] = serverEntityNew.Description
	entityMap["ip"] = serverEntityNew.Ip
	entityMap["last_update_at"] = time.Unix(time.Now().Unix(), 0)
	entityMap["is_vm"] = 0 //默认物理机

	// 判断是否是虚机
	for _, node := range serverEntityNew.Node {
		if node == "vm" {
			entityMap["is_vm"] = 1
		}
	}
	// 获取服务器节点数据
	nodeList, _ := serverdao.GetServerNode(serverEntityNew.Node)
	if len(nodeList) > 0 {
		node := ""
		nodeType := ""
		nodeGroup := ""
		for _, v := range nodeList {
			node += v.Node + ","
			nodeType += v.NodeType + ","
			if v.NodeGroup != "" {
				nodeGroup += v.NodeGroup + ","
			}
		}
		entityMap["node"] = strings.Trim(node, ",")
		entityMap["node_type"] = RemoveDuplicateWords(strings.Trim(nodeType, ","))
		if nodeGroup != "" {
			entityMap["node_group"] = RemoveDuplicateWords(strings.Trim(nodeGroup, ","))
		}
	} else {
		entityMap["node"] = "others"
	}
	//获取上联交换机
	uplink, _ := switchdao.GetUplinkSwitchList(serverEntityNew.Name)
	if len(uplink) > 0 {
		entityMap["uplink_switch"] = strings.Join(uplink, ",")
	}

	//根据服务器名称和sn号获取服务器数据
	serverInfo, err := serverdao.SelectServerInfo(serverEntityNew.Name, serverEntityNew.Sn, 0)
	//插入服务器数据
	if err == gorm.ErrRecordNotFound {
		entityMap["input_time"] = serverEntityNew.InputTime
		_, err = serverdao.InsertServerTransaction(entityMap, serverEntityNew.Ip)
	}
	if err != nil {
		klog.Errorf("ReportPhysicalHost_err %v:", err)
		return err
	}
	entityMap["id"] = serverInfo.Id
	//获取服务实例
	svcis, err := businessManagementDao.QueryServiceInstanceBySn(serverEntityNew.Sn)
	if err != nil {
		klog.Errorf("ReportPhysicalHost - server report err, svcis got err: %v", err)
		//获取服务实例失败只更新服务器主表
		return serverdao.UpdateServer(entityMap)
	}
	svcIds := make([]int, 0, len(svcis))
	for _, svci := range svcis {
		svcIds = append(svcIds, svci.ServiceId)
	}
	nodeRefIds, err := businessManagementDao.QueryNodeRefIdsByServiceIds(svcIds)
	if err != nil {
		klog.Errorf("ReportPhysicalHost - server report err, nodeRefIds got err: %v", err)
		return serverdao.UpdateServer(entityMap)
	}
	svc := make([]string, 0)
	for i := 0; i < len(nodeRefIds); i++ {
		res := businessManagementDao.QueryRouteByRefId(nodeRefIds[i])
		// /.../
		strs := strings.Split(res, "/")
		if len(strs) > 1 {
			svc = append(svc, strs[1])
		}
	}
	entityMap["service"] = strings.Join(svc, " ,")
	err = serverdao.UpdateServer(entityMap)
	if err != nil {
		klog.Errorf("ReportPhysicalHost - server report err, UpdateServer got err: %v , %+v", err, entityMap)
	}
	return
}

func RemoveDuplicateWords(input string) string {
	words := strings.Split(input, ",")
	encountered := map[string]bool{}
	var result []string

	for _, word := range words {
		if encountered[word] == false {
			encountered[word] = true
			result = append(result, word)
		}
	}
	return strings.Join(result, " ")
}

// 获取概览页数据
func (s *ServerService) GetPhysicalHostOverView(physicalHostListQuery server.PhysicalHostListQuery) (hostOverview server.HostOverview, err error) {
	TotalCount := 0
	RunningCount := 0
	ErrorCount := 0

	InsuredCount := 0
	Insured1mCount := 0
	Insured3mCount := 0
	//physicalHostListQuery.PageNo = 1
	//physicalHostListQuery.PageSize = 100
	var serverList []server.PhysicalHostData
	//for {
	//	rows, count, err := serverdao.GetPhysicalHostList(physicalHostListQuery)
	//	if err != nil {
	//		klog.Error(err)
	//		return hostOverview, err
	//	}
	//	if count <= 0 {
	//		return hostOverview, err
	//	}
	//	//循环赋值
	//	defer rows.Close()
	//	for rows.Next() {
	//		var dr server.PhysicalHostData
	//		dao.AssetDB.ScanRows(rows, &dr)
	//		serverList = append(serverList, dr)
	//	}
	//	//var drs []server.PhysicalHostData
	//	//dao.AssetDB.ScanRows(rows, &drs)
	//	//serverList = append(serverList, drs...)
	//	if len(serverList) < physicalHostListQuery.PageSize {
	//		break
	//	}
	//	physicalHostListQuery.PageNo++
	//	//rows.Close()
	//}
	rows, count, err := serverdao.GetPhysicalHostList(physicalHostListQuery)
	if err != nil {
		klog.Error(err)
		return hostOverview, err
	}
	if count <= 0 {
		return hostOverview, err
	}
	if rows.Next() {
		dao.AssetDB.ScanRows(rows, &serverList)
	}
	rows.Close()
	for _, host := range serverList {

		aggHost := host
		exist := false
		for i := range hostOverview.DistributedOverview {
			if hostOverview.DistributedOverview[i].Region == host.HostRegionCode && hostOverview.DistributedOverview[i].Az == host.HostAzCode {
				hostOverview.DistributedOverview[i].Distributed[0].Value++
				exist = true
			}
		}
		if !exist {
			hostOverview.DistributedOverview = append(hostOverview.DistributedOverview, s.DistributionAdd(host))
		}
		//h.DistributionOprate(hostOverview.DistributedOverview, aggHost)
		if strings.ToLower(aggHost.Runstatus) == "up" {
			RunningCount++
		} else {
			ErrorCount++
		}
		//if aggHost.MaintenanceDue > 0 {
		//	i64 := aggHost.MaintenanceDue
		//	cout := (i64 - time.Now().Unix()) / 86400
		//	if err == nil {
		//		switch {
		//		case cout <= 0:
		//			InsuredCount++
		//		case 0 < cout && cout < 30:
		//			Insured1mCount++
		//		case 30 < cout && cout < 90:
		//			Insured3mCount++
		//		}
		//	}
		//}

		//判断维保到期时间是否为空 不为空
		var nullableTime sql.NullTime
		nullableTime.Time = aggHost.MaintenanceDue
		nullableTime.Valid = aggHost.MaintenanceDue != time.Time{}
		if nullableTime.Valid {
			i64 := aggHost.MaintenanceDue.Unix()
			cout := (i64 - time.Now().Unix()) / 86400
			if err == nil {
				switch {
				case cout <= 0:
					InsuredCount++
				case 0 < cout && cout < 30:
					Insured1mCount++
				case 30 < cout && cout < 90:
					Insured3mCount++
				}
			}
		}
		TotalCount++
	}
	hostOverview.HostStateOverview = append(hostOverview.HostStateOverview, server.OverView{
		Name:  "总数量",
		Code:  "TotalCount",
		Value: TotalCount,
	})
	hostOverview.HostStateOverview = append(hostOverview.HostStateOverview, server.OverView{
		Name:  "监控中",
		Code:  "up",
		Value: RunningCount,
	})
	hostOverview.HostStateOverview = append(hostOverview.HostStateOverview, server.OverView{
		Name:  "监控异常",
		Code:  "down",
		Value: ErrorCount,
	})
	hostOverview.HostMaintenanceOverview = append(hostOverview.HostMaintenanceOverview, server.OverView{
		Name:  "已过保",
		Code:  "insured",
		Value: InsuredCount,
	})
	hostOverview.HostMaintenanceOverview = append(hostOverview.HostMaintenanceOverview, server.OverView{
		Name:  "1个月内过保",
		Code:  "insured1m",
		Value: Insured1mCount,
	})
	hostOverview.HostMaintenanceOverview = append(hostOverview.HostMaintenanceOverview, server.OverView{
		Name:  "3个月内过保",
		Code:  "insured3m",
		Value: Insured3mCount,
	})
	return hostOverview, err

}

// 操作柱状图，组装
func (s *ServerService) DistributionAdd(host server.PhysicalHostData) server.DistributedOverView {
	distribution := server.DistributedOverView{}
	overView := []server.OverView{}
	overView = append(overView, server.OverView{
		Name:  "",
		Code:  "",
		Value: 1,
	})
	distribution.Region = host.HostRegionCode
	distribution.Az = host.HostAzCode
	distribution.Name = host.HostRegionName + host.HostAzName
	distribution.Distributed = overView
	return distribution
}
func (s *ServerService) GetAllPhysicalHostList() (physicalServer []server.PhysicalHost, err error) {
	physicalServer, err = serverdao.GetAllHostList()
	return
}

func (s *ServerService) GetPhysicalHostHardware(sn string) hardware.Hardware {
	hw := hardware.Hardware{
		Sn: sn,
	}
	hw.FindBySn(dao.AssetDB)
	return hw
}

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/pkg/service/rack.go
```golang
package service

import (
	"errors"
	"fmt"
	"github.com/dgraph-io/dgo/v200"
	"github.com/go-playground/validator/v10"
	"k8s.io/klog/v2"
	"luban-cmdb-api/pkg/dao/rackdao"
	"luban-cmdb-api/pkg/models/rack"
)

type RackService struct {
	dgraphClient *dgo.Dgraph
	BasicService *BasicService
}

func NewRackService(dgraphClient *dgo.Dgraph, basicService *BasicService) *RackService {
	return &RackService{
		dgraphClient: dgraphClient,
		BasicService: basicService,
	}

}

func (cs *RackService) GetRackListByCabinetId(params rack.QueryRackByCabinetParam) (rack.SimpleSliceResponse, error) {
	racks, err := rackdao.SelectRackByCabinetId(params.CabinetId)
	return rack.SimpleSliceResponse{
		RackSlice: racks,
	}, err
}

func (cs *RackService) GetRackList(params rack.QueryRackParam) (rack.RackListResponse, error) {
	klog.Infof("GetRackList params:%+v", params)
	res := rack.RackListResponse{
		PageNo:   params.PageNo,
		PageSize: params.PageSize,
	}
	if params.PageNo > 0 {
		params.PageNo -= 1
	} else {
		return rack.RackListResponse{}, errors.New("invalid pageNo")
	}
	validate := validator.New()
	err := validate.Struct(params)
	if err != nil {
		fmt.Println(err)
		return res, err
	}

	//过滤条件
	//querys := make([]dao.WhereOpt,0)
	////是否有Region条件
	//if params.Region != "all" && params.Region != "" {
	//	querys = append(querys,dao.WhereOpt{Query:"asset_region.region_name = ?",Args: []interface{}{params.Region}})
	//}
	////是否有机架位名称
	//if params.RackName != "" {
	//	querys = append(querys,dao.WhereOpt{Query:"asset_rack.rack_name = ?",Args: []interface{}{params.RackName}})
	//}
	////是否有可用区列表
	//if len(params.Azs) > 0 {
	//	azArgs := make([]interface{},len(params.Azs))
	//	for i, az := range params.Azs {
	//		azArgs[i] = az
	//	}
	//	querys = append(querys,dao.WhereOpt{Query:"asset_az.name in (?)",Args: azArgs})
	//}
	////是否有所属机房列表
	//if len(params.RackLabs) > 0 {
	//	labArgs := make([]interface{},len(params.RackLabs))
	//	for i, lab := range params.RackLabs {
	//		labArgs[i] = lab
	//	}
	//	querys = append(querys,dao.WhereOpt{Query:"asset_lab.name in (?)",Args: labArgs})
	//}
	////是否有所属机房代号列表
	//if  len(params.RackLabCodes) > 0 {
	//	labCodeArgs := make([]interface{},len(params.RackLabCodes))
	//	for i, code := range params.RackLabCodes {
	//		labCodeArgs[i] = code
	//	}
	//	querys = append(querys,dao.WhereOpt{Query:"asset_lab.code in (?)",Args: labCodeArgs})
	//}
	////是否所属房间列表
	//if len(params.RackRoomCodes) > 0 {
	//	roomCodeArgs := make([]interface{},len(params.RackRoomCodes))
	//	for i, code := range params.RackRoomCodes {
	//		roomCodeArgs[i] = code
	//	}
	//	querys = append(querys,dao.WhereOpt{Query:"asset_device_room.room_code in (?)",Args: roomCodeArgs})
	//}
	////是否有所属机柜列表
	//if len(params.RackCabinetCodes) > 0 {
	//	cabinetNameArgs := make([]interface{},len(params.RackCabinetCodes))
	//	for i, name := range params.RackCabinetCodes {
	//		cabinetNameArgs[i] = name
	//	}
	//	querys = append(querys,dao.WhereOpt{Query:"asset_cabinet.cabinet_name in (?)",Args: cabinetNameArgs})
	//}
	////是否有机架位状态列表
	//if len(params.RackStatus) > 0 {
	//	rackStatusArgs := make([]interface{},len(params.RackStatus))
	//	for i, status := range params.RackStatus {
	//		rackStatusArgs[i] = status
	//	}
	//	querys = append(querys,dao.WhereOpt{Query:"rack.rack_status in (?)",Args: rackStatusArgs})
	//}

	rackInfoList, err := rackdao.SelectRackInfoByCons(params)
	if err != nil {
		return res, err
	}

	if len(rackInfoList) != 0 {
		res.TotalCount = rackInfoList[0].RackCount
	}
	res.DataList = rackInfoList
	return res, nil
}
func (cs *RackService) GetRackListByRackId(rackIdStart, hostUnitNumber int, rackStatus int) (rack.RackList, error) {
	klog.Infof("rackName:%+v", rackIdStart)
	//res := rack.RackListResponse{}
	rackInfoList := rack.RackList{}

	response, err := rackdao.SelectRackListByRackId(rackIdStart, hostUnitNumber, rackStatus)
	if err != nil {
		return rackInfoList, err
	}
	rackInfoList.RackInfoList = response
	return rackInfoList, nil
}

func (cs *RackService) UpdateRack(rackInfoList []rack.RackEntity) (string, error) {
	racks := make([]rackdao.Rack, len(rackInfoList))
	//ids := make([]interface{},len(rackInfoList))
	for i, entity := range rackInfoList {
		//ids[i] = entity.Uid
		r := rackdao.Rack{
			Uid: entity.Uid,
		}
		if entity.RackName != "" {
			r.RackName = entity.RackName
		}
		if entity.RackResourceType != "" {
			r.RackResourceType = entity.RackResourceType
		}
		if entity.RackResourceName != "" {
			r.RackResourceName = entity.RackResourceName
		}
		if entity.RackResourceSn != "" {
			r.RackResourceSn = entity.RackResourceSn
		}
		racks[i] = r
	}

	err := rackdao.UpdateRackStatusByTransaction(racks, "")
	if err != nil {
		return "error", err
	} else {
		return "success", err
	}

}

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/pkg/service/aggregate.go
```golang
package service

import (
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"io"
	"io/ioutil"
	"luban-cmdb-api/cmd/apiserver/app/options"
	"luban-cmdb-api/pkg/apiserver/config"
	basicdao "luban-cmdb-api/pkg/dao/basic"
	serverdao "luban-cmdb-api/pkg/dao/server"
	"luban-cmdb-api/pkg/gredis"
	novaTask "luban-cmdb-api/pkg/tasks/nova-task"
	"luban-cmdb-api/pkg/utils/collection"
	"math"
	"net/http"
	"os"
	"sort"
	"strconv"
	"strings"
	"time"

	"github.com/jinzhu/copier"

	"luban-cmdb-api/pkg/models/aggregate"
	"luban-cmdb-api/pkg/models/server"
	"luban-cmdb-api/pkg/models/storage"

	"github.com/google/uuid"
	"github.com/gophercloud/gophercloud"
	"github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/aggregates"
	"github.com/gophercloud/gophercloud/openstack/compute/v2/extensions/hypervisors"
	"github.com/gophercloud/gophercloud/openstack/compute/v2/servers"
	"github.com/gophercloud/gophercloud/openstack/identity/v2/users"
	"gorm.io/gorm"
	"k8s.io/klog/v2"
)

const (
	Action   = "DescribeInstances"
	Version  = "2016-03-04"
	RequesId = "6cbdfcb0-f62a-46a9-8284-1e8543810547"
)

type AggregateService struct {
	Novaclient              *gophercloud.ServiceClient
	ApiServerConfig         config.Config
	HttpClient              HttpClient
	IdentityClient          *gophercloud.ServiceClient
	blockStoragePoolService *BlockStoragePoolService
}

func NewAggregateService(Novaclient *gophercloud.ServiceClient, IdentityClient *gophercloud.ServiceClient, ApiServerConfig config.Config) *AggregateService {
	return &AggregateService{
		Novaclient:              Novaclient,
		IdentityClient:          IdentityClient,
		ApiServerConfig:         ApiServerConfig,
		HttpClient:              &SimpleHttpClient{},
		blockStoragePoolService: NewBlockStoragePoolService(ApiServerConfig.EBSAddr, ApiServerConfig.StorageStateAddr, nil),
	}
}

func (h *AggregateService) GetHostInstance(host string) ([]servers.Server, error) {
	page, err := servers.List(h.Novaclient, servers.ListOpts{Host: host, AllTenants: true}).AllPages()
	if err != nil {
		klog.Errorln("servers.List(h.Novaclient, servers.ListOpts{Host: host, AllTenants: true}).AllPages() err:", err)
		return []servers.Server{}, nil
	}
	instances, err := servers.ExtractServers(page)
	if err != nil {
		klog.Errorln("servers.ExtractServers(page) err:", err)
		return []servers.Server{}, nil
	}
	return instances, nil
}

func (h *AggregateService) GetAggregateHostsAll(aggregateQ aggregate.AggregateHostListQuery) ([]aggregate.AggregatesHost, error) {
	//aggregateID := request.PathParameter("id")
	res := []aggregate.AggregatesHost{}
	id, err := strconv.Atoi(aggregateQ.Id)

	if err != nil {
		klog.Errorln("strconv.Atoi(aggregateQ.Id) err:", err)
		//api.HandleInternalError(response, err)
		return res, nil
	}
	agg, err := aggregates.Get(h.Novaclient, id).Extract()
	if err != nil {
		//api.HandleInternalError(response, err)
		klog.Errorln("aggregates.Get(h.Novaclient, id).Extract() err:", err)
		return res, nil
	}

	// hostData := DgraphService{
	// 	Code:  "hostname",
	// 	Value: "",
	// }
	for _, host := range agg.Hosts {
		//hostData.Value = host
		//[]model.HostData
		hostD, err := serverdao.SelectServerInfo(host, "", 0)
		//hostList, err := hostData.HostQuery()
		if err != nil && err != gorm.ErrRecordNotFound {
			klog.Errorln("serverdao.SelectServerInfo err:", err)
			err = nil
			continue
		}
		err = nil
		//hostD := hostList[0]

		if (len(aggregateQ.Status) < 1 || BoolTagInArray(aggregateQ.Status, hostD.Runstatus)) &&
			(len(aggregateQ.AssignmentStatus) < 1 || BoolTagInArray(aggregateQ.AssignmentStatus, hostD.AssignmentStatus)) {
			// ips := []string{hostD.Ip}
			// ser := GetServiceByIps(ips)

			aggHost := aggregate.AggregatesHost{
				Id:               strconv.Itoa(hostD.Id), //agg.ID
				Name:             host,
				Ip:               hostD.Ip,
				Status:           hostD.Runstatus, //"unknown",
				AssignmentStatus: hostD.AssignmentStatus,
				ResourcePoolType: "kec",                //hostD.ResourcePoolType, //"kec", //"compute",
				ResourcePool:     agg.Name,             //"kec",                //hostD.ResourcePool,     //agg.Name,
				Service:          hostD.Service,        //hostD.Service,        //"unknown",
				Region:           hostD.RegionName,     //h.ApiServerConfig.RegionName,
				Az:               hostD.AzName,         //.GetAZByOurWay(), //agg.AvailabilityZone,
				Room:             hostD.RoomName,       //"unknown",
				Rack:             hostD.RackName,       //"unknown",
				RackPosition:     hostD.HostUnitNumber, //"unknown",
				SN:               hostD.Sn,             //"unknown",
			}
			res = append(res, aggHost)
		}

	}
	return res, err
}

func (h *AggregateService) GetAggregateHostsOverView(aggregateID, region, az string) (server.HostOverview, error) {
	//aggregateID := request.PathParameter("id")
	id, err := strconv.Atoi(aggregateID)
	//res := []server.PhysicalHostData{}
	var hostOverview server.HostOverview
	TotalCount := 0
	RunningCount := 0
	ErrorCount := 0

	InsuredCount := 0
	Insured1mCount := 0
	Insured3mCount := 0

	regionAz := ""
	if err != nil {
		klog.Errorln("strconv.Atoi(aggregateID) err:", err)
		err = nil
		//api.HandleInternalError(response, err)
		return hostOverview, err
	}
	agg, err := aggregates.Get(h.Novaclient, id).Extract()
	if err != nil {
		klog.Errorln(" aggregates.Get(h.Novaclient, id).Extract() err:", err)
		err = nil
		//api.HandleInternalError(response, err)
		return hostOverview, err
	}

	// hostData := DgraphService{
	// 	Code:  "hostname",
	// 	Value: "",
	// }
	for _, host := range agg.Hosts {
		//hostData.Value = host
		//[]model.HostData
		aggHost, err := serverdao.SelectServerInfo(host, "", 0)
		//hostList, err := hostData.HostQuery()
		if err != nil && err != gorm.ErrRecordNotFound {
			klog.Errorln("serverdao.SelectServerInfo err:", err)
			err = nil
			continue
		}
		err = nil
		//aggHost := hostList[0]
		//aggHost.Name = host
		if region == aggHost.RegionCode && az == aggHost.AzCode {
			//res = append(res, aggHost)

			if regionAz == "" {
				regionAz = aggHost.RegionName + aggHost.AzName
			}
			if strings.ToLower(aggHost.Runstatus) == "up" {
				RunningCount++
			} else {
				ErrorCount++
			}
			//if aggHost.MaintenanceDue > 0 {
			//	i64 := aggHost.MaintenanceDue
			//	cout := i64 - time.Now().Unix()/86400
			//	if err == nil {
			//		switch {
			//		case cout <= 0:
			//			InsuredCount++
			//		case 0 < cout && cout < 30:
			//			Insured1mCount++
			//		case 30 < cout && cout < 90:
			//			Insured3mCount++
			//		}
			//	}
			//
			//}
			TotalCount++
		}

	}
	overView := []server.OverView{}
	overView = append(overView, server.OverView{
		Name:  "",
		Code:  "",
		Value: TotalCount,
	})
	hostOverview.DistributedOverview = append(hostOverview.DistributedOverview, server.DistributedOverView{
		Name:        regionAz,
		Distributed: overView,
	})
	hostOverview.HostStateOverview = append(hostOverview.HostStateOverview, server.OverView{
		Name:  "总数量",
		Code:  "TotalCount",
		Value: TotalCount,
	})
	hostOverview.HostStateOverview = append(hostOverview.HostStateOverview, server.OverView{
		Name:  "运行中",
		Code:  "RunningCount",
		Value: RunningCount,
	})
	hostOverview.HostStateOverview = append(hostOverview.HostStateOverview, server.OverView{
		Name:  "故障",
		Code:  "ErrorCount",
		Value: ErrorCount,
	})
	hostOverview.HostMaintenanceOverview = append(hostOverview.HostMaintenanceOverview, server.OverView{
		Name:  "已过保",
		Code:  "InsuredCount",
		Value: InsuredCount,
	})
	hostOverview.HostMaintenanceOverview = append(hostOverview.HostMaintenanceOverview, server.OverView{
		Name:  "1个月内过保",
		Code:  "Insured1mCount",
		Value: Insured1mCount,
	})
	hostOverview.HostMaintenanceOverview = append(hostOverview.HostMaintenanceOverview, server.OverView{
		Name:  "3个月内过保",
		Code:  "Insured3mCount",
		Value: Insured3mCount,
	})
	return hostOverview, err
}

// 从总的服务器列表中进行分页获取数据
func (h *AggregateService) GetAggregateHostsList(aggregatesHostsQuery aggregate.AggregateHostListQuery) (aggregate.AggregatesHosts, error) {
	aggregatesDataList, err := h.GetAggregateHostsAll(aggregatesHostsQuery)
	//listAll := AggregatesData
	//对查询结果进行分页
	listPageResult := aggregate.AggregatesHosts{}

	low := (aggregatesHostsQuery.PageNo - 1) * aggregatesHostsQuery.PageSize
	high := (aggregatesHostsQuery.PageNo) * aggregatesHostsQuery.PageSize
	if high > len(aggregatesDataList) {
		high = len(aggregatesDataList)
	}

	listPageResult.DataList = aggregatesDataList[low:high]
	listPageResult.TotalCount = len(aggregatesDataList)
	listPageResult.PageNo = aggregatesHostsQuery.PageNo
	listPageResult.PageSize = aggregatesHostsQuery.PageSize
	return listPageResult, err

}

// 从总的Aggregate中进行分页获取数据
func (h *AggregateService) GetAggregateAllList(aggregatesListQuery aggregate.AggregatesListQuery) (aggregate.AggregatesResult, error) {
	//对查询结果进行分页
	listPageResult := aggregate.AggregatesResult{
		PageStruct: aggregate.PageStruct{TotalCount: 0},
		DataList:   []aggregate.Aggregates{},
	}
	//获取查询结果  ---可以进行查询结果的时候就按照分页来获取数据
	//listQueryResult := []aggregate.Aggregates{}
	//if aggregatesListQuery.Region
	listQueryResult, err := h.GetAggregateAllForPage(aggregatesListQuery)
	if err != nil {
		klog.Errorln("h.GetAggregateAllForPage(aggregatesListQuery) err:", err)
		err = nil
		return listPageResult, err
	}
	returnList, err := h.SortAggregateList(aggregatesListQuery, listQueryResult)
	low := (aggregatesListQuery.PageNo - 1) * aggregatesListQuery.PageSize
	high := (aggregatesListQuery.PageNo) * aggregatesListQuery.PageSize
	if high > len(returnList) {
		high = len(returnList)
	}
	listPageResult.TotalCount = len(returnList)
	returnList = returnList[low:high]
	for i := range returnList {
		listPageResult.DataList = append(listPageResult.DataList, returnList[i].(aggregate.Aggregates))
	}

	listPageResult.PageNo = aggregatesListQuery.PageNo
	listPageResult.PageSize = aggregatesListQuery.PageSize
	return listPageResult, err

}

// 获取 Aggregate
func (h *AggregateService) GetAggregateAllForPage(aggregatesListQuery aggregate.AggregatesListQuery) ([]aggregate.Aggregates, error) {
	//获取查询结果  ---可以进行查询结果的时候就按照分页来获取数据
	listQueryResult := []aggregate.Aggregates{}
	list := aggregate.GetAggregateMap()

	for _, aggregate := range list {

		if aggregatesListQuery.Name != "" && aggregatesListQuery.Name != aggregate.Name {
			continue
		}
		if aggregatesListQuery.Region != "" && aggregatesListQuery.Region != "all" && aggregate.RegionCode != aggregatesListQuery.Region {
			continue
		}

		if len(aggregatesListQuery.Az) != 0 && BoolTagInArray(aggregatesListQuery.Az, aggregate.AzCode) == false {
			continue
		}

		//search
		if aggregatesListQuery.SearchType != "" {
			switch aggregatesListQuery.SearchType {
			case "name":
				if !strings.Contains(aggregate.Name, aggregatesListQuery.SearchValue) {
					continue
				}
			}
		}

		listQueryResult = append(listQueryResult, aggregate)
	}
	return listQueryResult, nil
}

// 获取所有的Aggregate
func (h *AggregateService) GetAggregateAll() (aggregate.AggregatesResult, error) {
	klog.Infoln("DEBUG - cloud products vm start  - 1.2.1")

	res := aggregate.AggregatesResult{}
	if h.Novaclient == nil {
		return res, nil
	}
	page, err := aggregates.List(h.Novaclient).AllPages()
	klog.Infoln("DEBUG - cloud products vm start  - 1.2.2")

	if err != nil {
		klog.Errorln("aggregates.List(h.Novaclient).AllPages() err:", err)
		err = nil
		//api.HandleInternalError(response, err)
		return res, err
	}
	aggs, err := aggregates.ExtractAggregates(page)
	klog.Infoln("DEBUG - cloud products vm start  - 1.2.3")

	if err != nil {
		klog.Errorln("aggregates.ExtractAggregates(page) err:", err)
		err = nil
		//api.HandleInternalError(response, err)
		return res, err
	}
	// region := DgraphService{
	// 	Code:  "regionCodeAggregate",
	// 	Value: h.ApiServerConfig.RegionName,
	// }
	// az := DgraphService{
	// 	Code:  "azCodeAggregate",
	// 	Value: "",
	// }
	//regionData := region.GetRegionByOurWay()
	regionData, err := basicdao.GetRegion(basicdao.Region{
		RegionCodeAggregate: h.ApiServerConfig.RegionName,
	})
	if err != nil {
		klog.Errorln("basicdao.GetRegion err:", err)
		err = nil
		//api.HandleInternalError(response, err)
		return res, err
	}
	//ips := []string{}
	for _, agg := range aggs {
		sers := make(map[string]string)
		ser := ""
		allInstannces := []servers.Server{}
		klog.Infoln("agg.Hosts:", agg.Hosts)
		klog.Infoln("DEBUG - cloud products vm start  - 1.2.4 |", agg.Hosts)

		for i := range agg.Hosts {
			//通过服务器获取虚机
			klog.Infoln("DEBUG - cloud products vm start  - 1.2.4 |", agg.Hosts[i])

			instances, err := h.GetHostInstance(agg.Hosts[i])
			klog.Infoln("DEBUG - cloud products vm start  - 1.2.5 |", agg.Hosts[i])
			if err != nil {
				klog.Errorln("aggregates.ExtractAggregates(page) err:", err)
				err = nil
				//api.HandleInternalError(response, err)
				return res, err
			}
			allInstannces = append(allInstannces, instances...)

			klog.Infoln("DEBUG - cloud products vm start  - 1.2.6 |", agg.Hosts[i])
			entity, err := serverdao.SelectServerInfo(agg.Hosts[i], "", 0)
			klog.Infoln("DEBUG - cloud products vm start  - 1.2.7 |", agg.Hosts[i])
			if err != nil && err != gorm.ErrRecordNotFound {
				klog.Errorln("serverdao.SelectServerInfo err:", err)
				err = nil
				continue
			}
			err = nil
			sers[entity.Service] = entity.Service
			//ips = append(ips, ip)

		}
		for key := range sers {
			ser = fmt.Sprintf("%s\n%s", ser, key)
		}
		ser = strings.TrimLeft(ser, "\n")
		//ser = GetServiceByIps(ips)
		//az.Value = agg.AvailabilityZone
		//azData := az.GetAZByOurWay()
		azData, err := basicdao.GetAz(basicdao.Az{
			AzCodeAggregate: agg.AvailabilityZone,
		})
		if err != nil {
			klog.Errorln("basicdao.GetAz err:", err)
			err = nil
			//api.HandleInternalError(response, err)
			return res, err
		}
		res.DataList = append(res.DataList, aggregate.Aggregates{
			Name:       agg.Name,
			Id:         agg.ID,
			Region:     regionData.RegionName, //h.ApiServerConfig.RegionName,
			RegionCode: regionData.RegionCode, //h.ApiServerConfig.RegionName,
			Service:    ser,                   //"",                    //strings.Join(agg.Hosts, "_"), //"unknown",
			Az:         azData.AzName,         //agg.AvailabilityZone,
			AzCode:     azData.AzCode,         //agg.AvailabilityZone,
			HostCount:  len(agg.Hosts),
			Hosts:      agg.Hosts,
			VMCount:    len(allInstannces),
			VMs:        allInstannces,
			Metadata:   agg.Metadata,
			//由于nova中CreateTime取值使用了错误的时区,形如将北京时间2022-07-18 15:29:50 显示为了格林威治时间2022-07-18T15:29:50Z（等于多加了8个小时），实际应该是2022-07-18T07:29:50+08:00/2022-07-18T07:29:50Z，GMS转换为时间戳时需要减去nova错误的8个小时
			CreateTime: agg.CreatedAt.Unix() - 3600*8,
		})
	}
	res.TotalCount = len(res.DataList)
	return res, err
	//response.WriteEntity(res)
}

// 从总的库存中进行分页获取数据
func (h *AggregateService) GetAggregateUsageList(aggregatesUsageQuery aggregate.AggregatesUsageQuery) (aggregate.AggregatesUsageResult, error) {
	aggregatesDataList, err := h.GetAggregateUsageAll(aggregatesUsageQuery)
	listPageResult := aggregate.AggregatesUsageResult{}
	if err != nil {
		klog.Errorln("h.GetAggregateUsageAll(aggregatesUsageQuery) err:", err)
		err = nil
		return listPageResult, err
	}
	//listAll := AggregatesData
	//对查询结果进行分页

	returnList, err := h.SortAggregateUsageList(aggregatesUsageQuery, aggregatesDataList)
	low := (aggregatesUsageQuery.PageNo - 1) * aggregatesUsageQuery.PageSize
	if low > len(returnList) {
		return listPageResult, err
	}
	high := (aggregatesUsageQuery.PageNo) * aggregatesUsageQuery.PageSize
	if high > len(returnList) {
		high = len(returnList)
	}
	listPageResult.TotalCount = len(returnList)

	returnList = returnList[low:high]
	for i := range returnList {
		listPageResult.DataList = append(listPageResult.DataList, returnList[i].(aggregate.AggregatesUsage))
	}

	//listPageResult.DataList = aggregatesDataList[low:high]
	listPageResult.PageNo = aggregatesUsageQuery.PageNo
	listPageResult.PageSize = aggregatesUsageQuery.PageSize
	return listPageResult, err

}

// 对数据进行排序
func (h *AggregateService) SortAggregateUsageList(aggregatesUsageQuery aggregate.AggregatesUsageQuery, list []aggregate.AggregatesUsage) ([]interface{}, error) {
	results := Bucket{}
	sortList := make([]interface{}, len(list))
	for i := range list {
		sortList[i] = list[i]
	}
	results.Slice = sortList

	time_by := func(a, b interface{}) bool {
		return true
	}

	if aggregatesUsageQuery.OrderCode == "" {
		aggregatesUsageQuery.OrderCode = "createTime"
		aggregatesUsageQuery.OrderType = "desc"
	}
	if aggregatesUsageQuery.OrderCode != "" {
		switch aggregatesUsageQuery.OrderCode {
		case "cpuRate":
			if aggregatesUsageQuery.OrderType != "" {
				switch aggregatesUsageQuery.OrderType {
				case "asc":
					time_by = func(a, b interface{}) bool {
						return a.(aggregate.AggregatesUsage).VCPURate < b.(aggregate.AggregatesUsage).VCPURate
					}
				case "desc":
					time_by = func(a, b interface{}) bool {
						return a.(aggregate.AggregatesUsage).VCPURate > b.(aggregate.AggregatesUsage).VCPURate
					}
				}
			}
		case "memoryRate":
			if aggregatesUsageQuery.OrderType != "" {
				switch aggregatesUsageQuery.OrderType {
				case "asc":
					time_by = func(a, b interface{}) bool {
						return a.(aggregate.AggregatesUsage).MemoryRate < b.(aggregate.AggregatesUsage).MemoryRate
					}
				case "desc":
					time_by = func(a, b interface{}) bool {
						return a.(aggregate.AggregatesUsage).MemoryRate > b.(aggregate.AggregatesUsage).MemoryRate
					}
				}
			}
		case "createTime":
			if aggregatesUsageQuery.OrderType != "" {
				switch aggregatesUsageQuery.OrderType {
				case "asc":
					time_by = func(a, b interface{}) bool {
						return a.(aggregate.AggregatesUsage).CreateTime < b.(aggregate.AggregatesUsage).CreateTime
					}
				case "desc":
					time_by = func(a, b interface{}) bool {
						return a.(aggregate.AggregatesUsage).CreateTime > b.(aggregate.AggregatesUsage).CreateTime
					}
				}
			}
		}
	}
	results.By = time_by
	sort.Sort(results)
	return results.Slice, nil
}
func (h *AggregateService) SortAggregateList(aggregatesListQuery aggregate.AggregatesListQuery, list []aggregate.Aggregates) ([]interface{}, error) {
	results := Bucket{}
	sortList := make([]interface{}, len(list))
	for i := range list {
		sortList[i] = list[i]
	}
	results.Slice = sortList
	time_by := func(a, b interface{}) bool {
		return a.(aggregate.Aggregates).CreateTime > b.(aggregate.Aggregates).CreateTime
	}
	results.By = time_by
	sort.Sort(results)
	return results.Slice, nil
}

//获取总库存根据资源池id
// func (h *AggregateService) GetAggregateUsageAll(aggregateID string) ([]aggregate.AggregatesUsage, error) {
// 	var resAll []aggregate.AggregatesUsage
// 	id, err := strconv.Atoi(aggregateID)
// 	if err != nil {
// 		return resAll, err
// 	}
// 	agg, err := aggregates.Get(h.Novaclient, id).Extract()
// 	if err != nil {
// 		return resAll, err
// 	}
// 	page, err := hypervisors.List(h.Novaclient).AllPages()
// 	if err != nil {
// 		return resAll, err
// 	}
// 	hs, err := hypervisors.ExtractHypervisors(page)
// 	if err != nil {
// 		return resAll, err
// 	}
// 	fmt.Println("hs:", hs)
// 	for _, hypervisor := range hs {
// 		freeRam := 0
// 		usedRam := 0
// 		totalRam := 0
// 		usedvCPU := 0
// 		totalvCPU := 0
// 		freeRam += hypervisor.FreeRamMB
// 		usedRam += hypervisor.MemoryMBUsed
// 		totalRam += hypervisor.MemoryMB
// 		usedvCPU += hypervisor.VCPUsUsed
// 		totalvCPU += hypervisor.VCPUs
// 		freevCPU := 0
// 		if free := totalvCPU - usedvCPU; free > 0 {
// 			freevCPU = free
// 		}
// 		region := DgraphService{
// 			Code:  "regionCodeAggregate",
// 			Value: h.ApiServerConfig.RegionName,
// 		}
// 		regionData := region.GetRegionByOurWay()
// 		az := DgraphService{
// 			Code:  "azCodeAggregate",
// 			Value: agg.AvailabilityZone,
// 		}
// 		azData := az.GetAZByOurWay()
// 		res := aggregate.AggregatesUsage{
// 			VCPUTotal:    totalvCPU,
// 			VCPUUsage:    usedvCPU,
// 			VCPURemain:   freevCPU,
// 			VCPURate:     float64(freevCPU) / float64(totalvCPU),
// 			MemoryTotal:  totalRam,
// 			MemoryUsage:  usedRam,
// 			MemoryRemain: freeRam,
// 			MemoryRate:   float64(freeRam) / float64(totalRam),
// 			Name:         hypervisor.HypervisorHostname + "," + hypervisor.HostIP, //agg.Name,
// 			Region:       regionData.RegionName,                                   //h.ApiServerConfig.RegionName,
// 			RegionCode:   regionData.RegionCode,                                   //h.ApiServerConfig.RegionName,
// 			Az:           azData.AZName,                                           //agg.AvailabilityZone,
// 			AzCode:       azData.AZCode,                                           //agg.AvailabilityZone,
// 		}
// 		resAll = append(resAll, res)
// 	}
// 	return resAll, err
// }

// 获取总库存
func (h *AggregateService) GetAggregateUsageAllList() ([]hypervisors.Hypervisor, error) {
	var resAll []hypervisors.Hypervisor
	page, err := hypervisors.List(h.Novaclient).AllPages()
	if err != nil {
		klog.Errorln("hypervisors.List(h.Novaclient).AllPages() err:", err)
		err = nil
		return resAll, err
	}
	hs, err := hypervisors.ExtractHypervisors(page)
	if err != nil {
		klog.Errorln("hypervisors.ExtractHypervisors(page) err:", err)
		err = nil
		return resAll, err
	}
	return hs, err
}

// 获取资源池下的库存
func (h *AggregateService) GetAggregateUsageAll(aggregatesUsageQuery aggregate.AggregatesUsageQuery) (resAll []aggregate.AggregatesUsage, err error) {
	list := aggregate.GetAggregateUsageMap()
	for _, aggregat := range list {

		if (aggregatesUsageQuery.Region == "all" || aggregatesUsageQuery.Region == aggregat.RegionCode) &&
			//(aggregatesUsageQuery.Az == "all" || aggregatesUsageQuery.Az == aggregat.AzCode) &&
			(len(aggregatesUsageQuery.Az) < 1 || BoolTagInArray(aggregatesUsageQuery.Az, aggregat.AzCode)) &&
			(len(aggregatesUsageQuery.Id) < 1 || BoolTagInArray(aggregatesUsageQuery.Id, strconv.Itoa(aggregat.Id))) {
			resAll = append(resAll, aggregat)
		}
	}
	return resAll, err
}

// 获取资源池下的库存并存到redis
func (h *AggregateService) GetAggregateUsageAllNew() ([]aggregate.AggregatesUsage, error) {
	//aggregateID := request.PathParameter("id")
	var resAll []aggregate.AggregatesUsage
	//先获取总的管理程序
	resHypervisorList, err := h.GetAggregateUsageAllList()
	if err != nil {
		klog.Errorln("h.GetAggregateUsageAllList() err:", err)
		err = nil
		//api.HandleInternalError(response, err)
		return resAll, err
	}
	//获取所有的资源池
	AggregatesData, err := h.GetAggregateAll()
	listAll := AggregatesData.DataList
	//获取机型配置信息
	pTypeList := h.GetPTypeList()
	//pTypeList = append(pTypeList, aggregate.PTypeConfig{
	//	PName: "测试类型",
	//	FlavorAggregate: aggregate.FlavorAggregate{
	//		Cluster:     "GA1P",
	//		VmAttr:      "net_inc,common",
	//		StorageType: "ssd",
	//	},
	//})
	for _, aggregat := range listAll {
		// agg, err := aggregates.Get(h.Novaclient, aggregat.Id).Extract()
		// if err != nil {
		// 	continue
		// }
		vCpu := 1

		//freeRam := 0.00
		usedRam := 0.00
		totalRam := 0.00
		usedvCPU := 0
		totalvCPU := 0
		for _, host := range aggregat.Hosts {
			//hostData.Value = host
			//[]model.HostData
			entity, err := serverdao.SelectServerInfo(host, "", 0)
			//hostList, err := hostData.HostQuery()
			if err != nil && err != gorm.ErrRecordNotFound {
				klog.Errorln("serverdao.SelectServerInfo err:", err)
				err = nil
				continue
			}
			err = nil
			// hostD := hostList[0]
			for i := range resHypervisorList {
				if resHypervisorList[i].HypervisorHostname != host {
					continue
				}
				if entity.CpuAllocationRatio > 0 {
					vCpu = entity.CpuAllocationRatio
				}
				vRam := 1.00
				if entity.CpuAllocationRatio > 0 {
					vRam = entity.RamAllocationRatio
				}
				usedRam += float64(resHypervisorList[i].MemoryMBUsed)
				totalRam += float64(resHypervisorList[i].MemoryMB) * vRam
				usedvCPU += resHypervisorList[i].VCPUsUsed
				totalvCPU += resHypervisorList[i].VCPUs * vCpu
			}

		}
		freevCPU := 0
		vCPURate := 0.00
		freeRam := 0.00
		if free := totalvCPU - usedvCPU; free >= 0 && totalvCPU > 0 {
			freevCPU = free
			vCPURate, err = strconv.ParseFloat(fmt.Sprintf("%.2f", (float64(usedvCPU)/float64(totalvCPU))*100), 64)
			if err != nil {
				klog.Infoln("strconv.ParseFloat(fmt.Sprintf(, (float64(usedvCPU)/float64(totalvCPU))*100), 64) err:", err)
				vCPURate = 0.00
				err = nil
			}
		}
		memoryRate := 0.00
		totalRam, err = strconv.ParseFloat(fmt.Sprintf("%.2f", totalRam/1024), 64)
		if err != nil {
			klog.Infoln("strconv.ParseFloat(fmt.Sprintf(, totalRam/1024), 64) err:", err)
			err = nil

		}
		usedRam, err = strconv.ParseFloat(fmt.Sprintf("%.2f", usedRam/1024), 64)
		if free := totalRam - usedRam; free > 0 {
			memoryRate, err = strconv.ParseFloat(fmt.Sprintf("%.2f", (usedRam/totalRam)*100), 64)
			if err != nil {
				klog.Infoln("strconv.ParseFloat(fmt.Sprintf(, (usedRam/totalRam)*100), 64) err:", err)
				err = nil
			}
			freeRam, err = strconv.ParseFloat(fmt.Sprintf("%.2f", free), 64)
			if err != nil {
				klog.Infoln("strconv.ParseFloat(fmt.Sprintf(, free), 64) err:", err)
				err = nil
				freeRam = 0.00
			}
		}
		res := aggregate.AggregatesUsage{
			Id:           aggregat.Id,
			VCPUTotal:    totalvCPU,
			VCPUUsage:    usedvCPU,
			VCPURemain:   freevCPU,
			VCPURate:     vCPURate,
			MemoryTotal:  totalRam,
			MemoryUsage:  usedRam,
			MemoryRemain: freeRam,
			MemoryRate:   memoryRate,          //float64(freeRam) / float64(totalRam),
			Name:         aggregat.Name,       //resHypervisorList[i].HypervisorHostname, //agg.Name,
			Region:       aggregat.Region,     //h.ApiServerConfig.RegionName,
			RegionCode:   aggregat.RegionCode, //h.ApiServerConfig.RegionName,
			Az:           aggregat.Az,         //agg.AvailabilityZone,
			AzCode:       aggregat.AzCode,     //agg.AvailabilityZone,
			PType:        getPTypeName(pTypeList, aggregat.Metadata),
			CreateTime:   aggregat.CreateTime,
		}
		resAll = append(resAll, res)

	}

	return resAll, err
}

func getPTypeName(configs []aggregate.PTypeConfig, metadata map[string]string) string {
	if configs == nil && len(configs) == 0 && metadata != nil {
		return ""
	}
	for _, cfg := range configs {
		if cfg.PName == "" {
			continue
		}
		flavor := cfg.FlavorAggregate
		if flavor.Cluster == "" && flavor.StorageType == "" && flavor.VmAttr == "" {
			continue
		}

		clusterMatch, storageTypeMatch, vmAttrMatch := false, false, false

		if flavor.Cluster != "" {
			if cluster, ok := metadata["cluster"]; ok {
				if strings.Contains(cluster, flavor.Cluster) {
					clusterMatch = true
				}
			}
		} else {
			clusterMatch = true
		}

		if flavor.StorageType != "" {
			if storageType, ok := metadata["storage_type"]; ok {
				if strings.Contains(storageType, flavor.StorageType) {
					storageTypeMatch = true
				}
			}
		} else {
			storageTypeMatch = true
		}

		if flavor.VmAttr != "" {
			if vmAttr, ok := metadata["vm_attr"]; ok {
				if strings.Contains(vmAttr, flavor.VmAttr) {
					vmAttrMatch = true
				}
			}
		} else {
			vmAttrMatch = true
		}

		if clusterMatch && storageTypeMatch && vmAttrMatch {
			return cfg.PName
		}

	}

	return ""
}

func (h *AggregateService) GetPTypeList() []aggregate.PTypeConfig {
	ptypes := make([]aggregate.PTypeConfig, 0)
	var galaxySubDomain string
	if galaxySubDomain = os.Getenv("GALAXY_SUB_DOMAIN"); galaxySubDomain == "" || galaxySubDomain == "sdns.cqpcloud.cn" {
		galaxySubDomain = "sdns.yunyan.com"
	}
	domain := fmt.Sprintf("apollo.inner.%s", galaxySubDomain)

	url := fmt.Sprintf("http://%s:9090/configs/console-kec/default/kec.image", domain)

	client := http.Client{}

	resp, err := client.Get(url)
	if err != nil {
		fmt.Println(err)
		return ptypes
	}
	defer resp.Body.Close()

	bytes, _ := io.ReadAll(resp.Body)
	rst := make(map[string]interface{}, 0)
	err = json.Unmarshal(bytes, &rst)
	if err != nil {
		return ptypes
	}
	if cfgsValue, ok := rst["configurations"]; ok {
		cfgsMap := cfgsValue.(map[string]interface{})
		if pTypeCfgsValue, ok := cfgsMap["p_type_config"]; ok {
			//fmt.Println(pTypeCfgsValue)
			err = json.Unmarshal([]byte(pTypeCfgsValue.(string)), &ptypes)
			if err != nil {
				return ptypes
			}
		}
	}

	return ptypes
}

func (h *AggregateService) GetAggregateVMsAll(aggregateID string, status []string) ([]aggregate.AggregatesVm, error) {
	//aggregateID := request.PathParameter("id")
	res := []aggregate.AggregatesVm{}
	id, err := strconv.Atoi(aggregateID)
	if err != nil {
		klog.Errorln("strconv.Atoi(aggregateID) err:", err)
		err = nil
		//api.HandleInternalError(response, err)
		return res, err
	}
	agg, err := aggregates.Get(h.Novaclient, id).Extract()
	if err != nil {
		klog.Errorln("aggregates.Get(h.Novaclient, id).Extract() err:", err)
		err = nil
		//api.HandleInternalError(response, err)
		return res, err
	}
	// type hostInstance struct {
	// 	hostName     string
	// 	allInstances []servers.Server
	// }
	regionData := basicdao.Region{}
	regionDataR, err := basicdao.GetRegion(basicdao.Region{
		RegionCodeAggregate: h.ApiServerConfig.RegionName,
	})
	if err != nil {
		klog.Errorln("aggregates.Get(h.Novaclient, id).Extract() err:", err)
		err = nil
	} else {
		regionData = regionDataR
	}
	azData := basicdao.Az{}
	azDataR, err := basicdao.GetAz(basicdao.Az{
		AzCodeAggregate: agg.AvailabilityZone,
	})
	if err != nil {
		klog.Errorln("basicdao.GetAz err:", err)
		err = nil
		//api.HandleInternalError(response, err)
		//return res, err
	} else {
		azData = azDataR
	}
	for i := range agg.Hosts {
		//allInstannces := []servers.Server{}
		instances, err := h.GetHostInstance(agg.Hosts[i])
		if err != nil {
			klog.Errorln("h.GetHostInstance(agg.Hosts[i]) err:", err)
			err = nil
			continue
			//api.HandleInternalError(response, err)
			//return res, err
		}
		for _, vm := range instances {
			if len(status) < 1 || BoolTagInArray(status, strings.ToLower(vm.Status)) {
				vmD := aggregate.AggregatesVm{
					ID:   vm.ID,
					Name: vm.Name,
					//Flavor:     vm.Flavor,
					//Flavor:     fmt.Sprintf("%.0f核%.2fG", vm.Flavor["vcpus"].(float64), vm.Flavor["ram"].(float64)/1024), // interfaceToValue(vm.Flavor["cluster"]) + "-" + interfaceToValue(vm.Flavor["vcpus"]) + "-" + interfaceToValue(vm.Flavor["ram"]) + "-" + interfaceToValue(vm.Flavor["storage_type"]) + "-" + interfaceToValue(vm.Flavor["disk"]),
					Status:      strings.ToLower(vm.Status),
					Aggregate:   agg.Name,
					AggregateId: agg.ID,
					Region:      regionData.RegionName, //h.ApiServerConfig.RegionName,
					RegionCode:  regionData.RegionCode, //h.ApiServerConfig.RegionName,
					Az:          azData.AzName,         //agg.AvailabilityZone,
					AzCode:      azData.AzCode,         //agg.AvailabilityZone,
					TenantId:    vm.UserID,             //vm.UserID + "----" +
					//TenantName:  tenant.Name,
					Hypervisor: agg.Hosts[i], //vm.HostID,
					//由于nova中CreateTime取值使用了错误的时区,形如将北京时间2022-07-18 15:29:50 显示为了格林威治时间2022-07-18T15:29:50Z（等于多加了8个小时），实际应该是2022-07-18T07:29:50+08:00/2022-07-18T07:29:50Z，GMS转换为时间戳时需要减去nova错误的8个小时
					CreateTime: vm.Created.Unix() - 3600*8,
					InnerIP:    vm.AccessIPv6, // "unknown",
					PublicIP:   vm.AccessIPv4, //"unknown",
				}
				tenant, err := GetRedisTenantMessage(vm.UserID)
				if err == nil {
					vmD.TenantName = tenant.Name
				}
				res = append(res, vmD)
			}

		}
		// allInstannces = append(allInstannces, instances...)
		// hInstance := hostInstance{}
		// hInstance.hostName = agg.Hosts[i]
		// hInstance.allInstances = append(hInstance.allInstances, allInstannces...)
		// hInstanceList = append(hInstanceList, hInstance)
	}
	// region := DgraphService{
	// 	Code:  "regionCodeAggregate",
	// 	Value: h.ApiServerConfig.RegionName,
	// }
	// regionData, err := basicdao.GetRegion(basicdao.Region{
	// 	RegionCodeAggregate: h.ApiServerConfig.RegionName,
	// })
	//regionData := region.GetRegionByOurWay()
	// az := DgraphService{
	// 	Code:  "azCodeAggregate",
	// 	Value: agg.AvailabilityZone,
	// }
	// azData := az.GetAZByOurWay()
	// azData, err := basicdao.GetAz(basicdao.Az{
	// 	AzCodeAggregate: agg.AvailabilityZone,
	// })
	// if err != nil {
	// 	//api.HandleInternalError(response, err)
	// 	return res, err
	// }
	// for _, hIns := range hInstanceList {
	// 	hostName := hIns.hostName
	// 	for _, vm := range hIns.allInstances {

	// 		if len(status) < 1 || BoolTagInArray(status, strings.ToLower(vm.Status)) {
	// 			vmD := aggregate.AggregatesVm{
	// 				ID:   vm.ID,
	// 				Name: vm.Name,
	// 				//Flavor:     vm.Flavor,
	// 				//Flavor:     fmt.Sprintf("%.0f核%.2fG", vm.Flavor["vcpus"].(float64), vm.Flavor["ram"].(float64)/1024), // interfaceToValue(vm.Flavor["cluster"]) + "-" + interfaceToValue(vm.Flavor["vcpus"]) + "-" + interfaceToValue(vm.Flavor["ram"]) + "-" + interfaceToValue(vm.Flavor["storage_type"]) + "-" + interfaceToValue(vm.Flavor["disk"]),
	// 				Status:      strings.ToLower(vm.Status),
	// 				Aggregate:   agg.Name,
	// 				AggregateId: agg.ID,
	// 				Region:      regionData.RegionName, //h.ApiServerConfig.RegionName,
	// 				RegionCode:  regionData.RegionCode, //h.ApiServerConfig.RegionName,
	// 				Az:          azData.AzName,         //agg.AvailabilityZone,
	// 				AzCode:      azData.AzCode,         //agg.AvailabilityZone,
	// 				TenantId:    vm.UserID,             //vm.UserID + "----" +
	// 				//TenantName:  tenant.Name,
	// 				Hypervisor: hostName, //vm.HostID,
	// 				CreateTime: fmt.Sprintf("%d", vm.Created.Unix()),
	// 				InnerIP:    vm.AccessIPv4, // "unknown",
	// 				PublicIP:   "unknown",
	// 				Test:       vm.Addresses,
	// 			}
	// 			tenant, err := GetRedisTenantMessage(vm.UserID)
	// 			if err == nil {
	// 				vmD.TenantName = tenant.Name
	// 			}
	// 			res = append(res, vmD)
	// 		}

	// 	}
	// }

	return res, err
}

// 对缓存的数据进行分页处理---例如：获取计算资源池所对应的云主机列表
func (h *AggregateService) GetAggregateVMsList(aggregatesVMQuery aggregate.VMListQuery) (aggregate.AggregatesVms, error) {
	listPageResult := aggregate.AggregatesVms{
		PageStruct: aggregate.PageStruct{
			TotalCount: 0,
		},
		DataList: []aggregate.AggregatesVm{},
	}
	//列表可选条件
	allList, err := h.GetVMsList(aggregate.VMListQuery{Region: "all"})
	if err != nil {
		klog.Errorln("h.GetVMsList(aggregatesVMQuery) err:", err)
		err = nil
		return listPageResult, err
	}
	resourcePoolSet := collection.NewSet()
	for _, vm := range allList {
		resourcePoolSet.Add(vm.Aggregate)
	}
	listOptionalCondition := make(map[string][]interface{})
	listOptionalCondition["aggregate"] = resourcePoolSet.Keys()
	listPageResult.ListOptionalCondition = listOptionalCondition

	aggregatesVmDataList, err := h.GetVMsList(aggregatesVMQuery)
	if err != nil {
		klog.Errorln("h.GetVMsList(aggregatesVMQuery) err:", err)
		err = nil
		return listPageResult, err
	}
	//aggregatesVmDataList, err := h.GetAggregateVMsAll(aggregatesVMQuery.Id, aggregatesVMQuery.Status)
	//listAll := AggregatesData
	//对查询结果进行分页
	returnList, err := h.SortVMList(aggregatesVmDataList)
	listPageResult.TotalCount = len(returnList)
	low := (aggregatesVMQuery.PageNo - 1) * aggregatesVMQuery.PageSize
	if low > len(returnList) {
		return listPageResult, err
	}
	high := (aggregatesVMQuery.PageNo) * aggregatesVMQuery.PageSize
	if high > len(returnList) {
		high = len(returnList)
	}
	returnList = returnList[low:high]
	for i := range returnList {
		listPageResult.DataList = append(listPageResult.DataList, returnList[i].(aggregate.AggregatesVm))
	}
	listPageResult.PageNo = aggregatesVMQuery.PageNo
	listPageResult.PageSize = aggregatesVMQuery.PageSize
	return listPageResult, err

}

// 对云主机数据进行排序
func (h *AggregateService) SortVMList(list []aggregate.AggregatesVm) ([]interface{}, error) {
	results := Bucket{}
	sortList := make([]interface{}, len(list))
	for i := range list {
		sortList[i] = list[i]
	}
	results.Slice = sortList
	time_by := func(a, b interface{}) bool {
		return a.(aggregate.AggregatesVm).CreateTime > b.(aggregate.AggregatesVm).CreateTime
	}
	results.By = time_by
	sort.Sort(results)
	return results.Slice, nil
}

func (h *AggregateService) AddVmIpDetail(aggregatesVmList []aggregate.AggregatesVm) []aggregate.AggregatesVm {
	aVmList := []aggregate.AggregatesVm{}
	for index, aggregates := range aggregatesVmList {
		user, err := h.GetUserDetailFromIdentity(aggregates.TenantId)
		if err != nil {
			klog.Infoln("h.GetUserDetailFromIdentity(aggregates.TenantId) err:", err)
			err = nil
			continue
		}

		vmDetail, err := GetOneVMDetail(aggregates.RegionCode, []string{aggregates.ID}, user.Name)
		//networkInterfaceSetData, _, _, _ := GetNetworkInterfaceList(user.Name, aggregates.RegionCode, aggregates.AzCode, vmDetail.NetworkInterfaceSet)
		eip := aggregate.EipData{}
		if len(vmDetail.NetworkInterfaceSet) > 0 {
			eip, err = GetEIPs(user.Name, aggregates.RegionCode, []string{vmDetail.NetworkInterfaceSet[0].NetworkInterfaceId})
			if err != nil {
				klog.Infoln("GetEIPs(user.Name, aggregates.RegionCode, []string{vmDetail.NetworkInterfaceSet[0].NetworkInterfaceId}) err:", err)
				err = nil
				continue
			}
			aggregatesVmList[index].PublicIP = eip.PublicIp
		}
		aggregatesVmList[index].InnerIP = vmDetail.PrivateIpAddress
		aggregatesVmList[index].TenantId = user.Name
		aggregatesVmList[index].Flavor = fmt.Sprintf("%d核%dG", vmDetail.InstanceConfigure.VCPU, vmDetail.InstanceConfigure.MemoryGb)
		tenant, err := GetRedisTenantMessage(user.Name)

		if err == nil {
			aggregatesVmList[index].TenantName = tenant.Name
		} else {
			klog.Infoln("GetRedisTenantMessage(user.Name) err:", err)
			err = nil
			continue
		}

	}
	aVmList = aggregatesVmList
	return aVmList
}

// 从总的云资源列表中进行分页获取数据
func (h *AggregateService) GetPhysicalHostResoursList(aggregatesVMQuery aggregate.HostVMListQuery) (vmList aggregate.AggregatesVms, err error) {
	VMQ := aggregate.VMListQuery{
		//Flavor:   aggregatesVMQuery.ServerName,
		Hypervisor: aggregatesVMQuery.ServerName,
		Status:     aggregatesVMQuery.Status,
		PageNo:     aggregatesVMQuery.PageNo,
		PageSize:   aggregatesVMQuery.PageSize,
	}
	vmList, err = h.GetAggregateVMsList(VMQ)
	return
	//对查询结果进行分页
	// listPageResult := aggregate.AggregatesVms{}
	// page, err := aggregates.List(h.Novaclient).AllPages()
	// if err != nil {
	// 	//api.HandleInternalError(response, err)
	// 	return listPageResult, err
	// }
	// aggs, err := aggregates.ExtractAggregates(page)
	// if err != nil {
	// 	//api.HandleInternalError(response, err)
	// 	return listPageResult, err
	// }
	// aggregateV := ""
	// az := ""
	// for _, agg := range aggs {

	// 	for i := range agg.Hosts {
	// 		//通过服务器获取虚机
	// 		if agg.Hosts[i] == aggregatesVMQuery.ServerName {
	// 			aggregateV = agg.Name
	// 			az = agg.AvailabilityZone
	// 			break
	// 		}
	// 	}
	// }
	// regionData, err := basicdao.GetRegion(basicdao.Region{
	// 	RegionCodeAggregate: h.ApiServerConfig.RegionName,
	// })
	// azData, err := basicdao.GetAz(basicdao.Az{
	// 	AzCodeAggregate: az,
	// })
	// //azData := azD.GetAZByOurWay()
	// ///qd01-cp-compute177009026.qd01.ksyun.com
	// aggregatesVmDataList, err := h.GetHostInstance(aggregatesVMQuery.ServerName)
	// for _, vm := range aggregatesVmDataList {
	// 	list := []aggregate.AggregatesVm{}
	// 	if len(aggregatesVMQuery.Status) < 1 || BoolTagInArray(aggregatesVMQuery.Status, strings.ToLower(vm.Status)) {

	// 		vmN := aggregate.AggregatesVm{
	// 			ID:   vm.ID,
	// 			Name: vm.Name,
	// 			//Flavor:     fmt.Sprintf("%.0f核%.2fG", vm.Flavor["vcpus"].(float64), vm.Flavor["ram"].(float64)/1024), //interfaceToValue(vm.Flavor["cluster"]) + "-" + interfaceToValue(vm.Flavor["vcpus"]) + "-" + interfaceToValue(vm.Flavor["ram"]) + "-" + interfaceToValue(vm.Flavor["storage_type"]) + "-" + interfaceToValue(vm.Flavor["disk"]),
	// 			Status:     strings.ToLower(vm.Status),
	// 			Aggregate:  aggregateV,
	// 			Region:     regionData.RegionName, //h.ApiServerConfig.RegionName,
	// 			RegionCode: regionData.RegionCode, //h.ApiServerConfig.RegionName,
	// 			Az:         azData.AzName,         //az,
	// 			AzCode:     azData.AzCode,         //az,
	// 			TenantId:   vm.UserID,
	// 			//TenantName: tenant.Name,
	// 			Hypervisor: vm.HostID,
	// 			CreateTime: fmt.Sprintf("%d", vm.Created.Unix()),
	// 			InnerIP:    "unknown",
	// 			PublicIP:   "unknown",
	// 		}
	// 		tenant, err := GetRedisTenantMessage(vmN.TenantId)
	// 		if err == nil {
	// 			vmN.TenantName = tenant.Name
	// 		}
	// 		list = append(list, vmN)
	// 		//dataList := h.AddVmIpDetail(list)
	// 		res = append(res, list...)
	// 	}

	// }

	// low := (aggregatesVMQuery.PageNo - 1) * aggregatesVMQuery.PageSize
	// high := (aggregatesVMQuery.PageNo) * aggregatesVMQuery.PageSize
	// if high > len(res) {
	// 	high = len(res)
	// }

	// listPageResult.DataList = res[low:high]
	// listPageResult.TotalCount = len(res)
	// listPageResult.DataList = h.AddVmIpDetail(listPageResult.DataList)
	// listPageResult.PageNo = aggregatesVMQuery.PageNo
	// listPageResult.PageSize = aggregatesVMQuery.PageSize
	//return listPageResult, err

}

// //根据服务器name获取
// func (h *AggregateService) getPhysicalAll(serverName string) ([]AggregatesVm, error) {
// 	AggregatesData, err := h.getAggregateAll()
// 	var aggregatesVmDataList []AggregatesVm
// 	if AggregatesData.TotalCount > 0 {
// 		for _, aggregate := range AggregatesData.DataList {
// 			VmDataList, err := h.getAggregateVMsAll(strconv.Itoa(aggregate.Id))
// 			if err != nil {
// 				return aggregatesVmDataList, err
// 			}
// 			for _, data := range VmDataList {
// 				//查询等于服务器name的云主机列表
// 				if data.Name == serverName {
// 					aggregatesVmDataList = append(aggregatesVmDataList, data)
// 				}

// 			}
// 		}
// 	}
// 	return aggregatesVmDataList, err
// }

// 根据条件从缓存中获取数据
func (h *AggregateService) GetVMsList(vmListQuery aggregate.VMListQuery) ([]aggregate.AggregatesVm, error) {
	var aggregatesVmDataList []aggregate.AggregatesVm
	aggregatesVmMap := aggregate.GetAggregatesVmMap()
	for i, v := range aggregatesVmMap {
		if (vmListQuery.Region == "all" || vmListQuery.Region == "" || aggregatesVmMap[i].RegionCode == vmListQuery.Region) &&
			(len(vmListQuery.Az) <= 0 || BoolTagInArray(vmListQuery.Az, aggregatesVmMap[i].AzCode)) &&
			(len(vmListQuery.Aggregates) <= 0 || BoolTagInArray(vmListQuery.Aggregates, aggregatesVmMap[i].Aggregate)) &&
			(vmListQuery.Aggregate == nil || aggregatesVmMap[i].Aggregate == *vmListQuery.Aggregate) &&
			(vmListQuery.AggregateId < 1 || aggregatesVmMap[i].AggregateId == vmListQuery.AggregateId) &&
			(vmListQuery.Hypervisor == "" || strings.Contains(aggregatesVmMap[i].Host, vmListQuery.Hypervisor)) &&
			(vmListQuery.InnerIP == "" || strings.Contains(aggregatesVmMap[i].InnerIp, vmListQuery.InnerIP)) &&
			(vmListQuery.PublicIP == "" || strings.Contains(aggregatesVmMap[i].EIp, vmListQuery.PublicIP)) &&
			(vmListQuery.Name == "" || strings.Contains(aggregatesVmMap[i].VmName, vmListQuery.Name)) &&
			(vmListQuery.Id == "" || aggregatesVmMap[i].Id == vmListQuery.Id) &&
			(len(vmListQuery.Status) < 1 || BoolTagInArray(vmListQuery.Status, aggregatesVmMap[i].Status)) &&
			(vmListQuery.TenantId == "" || aggregatesVmMap[i].TenantId == vmListQuery.TenantId) {

			//SearchType  string `json:"searchType"`  // 搜索类型 (实例名称 name/实例ID id/租户ID tenantId)
			//SearchValue string `json:"searchValue"` // 搜索值 (注意要支持模糊搜索)
			if vmListQuery.SearchType != "" && vmListQuery.SearchValue != "" {
				switch vmListQuery.SearchType {
				case "name":
					if !strings.Contains(v.VmName, vmListQuery.SearchValue) {
						continue
					}
				case "id":
					if !strings.Contains(v.Id, vmListQuery.SearchValue) {
						continue
					}

				case "tenantId":
					if !strings.Contains(v.TenantId, vmListQuery.SearchValue) {
						continue
					}
				}
			}

			aggregatesVmDataList = append(aggregatesVmDataList, aggregate.AggregatesVm{
				ID:          aggregatesVmMap[i].Id,
				Name:        aggregatesVmMap[i].VmName,
				Flavor:      aggregatesVmMap[i].Size,
				Status:      aggregatesVmMap[i].Status,
				Aggregate:   aggregatesVmMap[i].Aggregate,
				AggregateId: aggregatesVmMap[i].AggregateId,
				Region:      aggregatesVmMap[i].Region,
				RegionCode:  aggregatesVmMap[i].RegionCode,
				Az:          aggregatesVmMap[i].Az,
				AzCode:      aggregatesVmMap[i].AzCode,
				TenantId:    aggregatesVmMap[i].TenantId,
				TenantName:  aggregatesVmMap[i].TenantName,
				Hypervisor:  aggregatesVmMap[i].Host,
				InnerIP:     aggregatesVmMap[i].InnerIp,
				PublicIP:    aggregatesVmMap[i].EIp,
				CreateTime:  aggregatesVmMap[i].CreateTime,
				Tags:        aggregatesVmMap[i].Label,
				ImageId:     aggregatesVmMap[i].ImageId,
				AdminPass:   aggregatesVmMap[i].AdminPass,
			},
			)

		}
	}

	return aggregatesVmDataList, nil

}

// 缓存数据1
func (h *AggregateService) GetVMsListForStorage(vmListQuery aggregate.VMListQuery) (aggregate.AggregatesVms, error) {

	aggregatesVmDataList, err := h.GetVMAll(vmListQuery)
	//对查询结果进行分页
	listPageResult := aggregate.AggregatesVms{}

	low := (vmListQuery.PageNo - 1) * vmListQuery.PageSize
	high := (vmListQuery.PageNo) * vmListQuery.PageSize
	if high > len(aggregatesVmDataList) {
		high = len(aggregatesVmDataList)
	}

	listPageResult.DataList = aggregatesVmDataList[low:high]
	listPageResult.TotalCount = len(aggregatesVmDataList)
	//if vmListQuery.PageSize != listPageResult.TotalCount {
	listPageResult.DataList = h.AddVmIpDetail(listPageResult.DataList)
	//}
	listPageResult.PageNo = vmListQuery.PageNo
	listPageResult.PageSize = vmListQuery.PageSize
	return listPageResult, err

}

// 缓存数据2
func (h *AggregateService) GetVMAll(vmListQuery aggregate.VMListQuery) ([]aggregate.AggregatesVm, error) {
	AggregatesData, err := h.GetAggregateAll()
	var aggregatesVmDataList []aggregate.AggregatesVm
	if AggregatesData.TotalCount > 0 {
		for _, aggregate := range AggregatesData.DataList {
			VmDataList, err := h.GetAggregateVMsAll(strconv.Itoa(aggregate.Id), vmListQuery.Status)
			if err != nil {
				klog.Errorln("h.GetAggregateVMsAll(strconv.Itoa(aggregate.Id), vmListQuery.Status) err:", err)
				err = nil
				return aggregatesVmDataList, err
			}
			for _, data := range VmDataList {
				//查询等于服务器name的云主机列表
				if (vmListQuery.Region == "all" || data.RegionCode == vmListQuery.Region) &&
					(len(vmListQuery.Az) <= 0 || BoolTagInArray(vmListQuery.Az, data.AzCode)) &&
					(vmListQuery.Aggregate == nil || data.Aggregate == *vmListQuery.Aggregate) &&
					(vmListQuery.Hypervisor == "" || data.Hypervisor == vmListQuery.Hypervisor) &&
					(vmListQuery.InnerIP == "" || data.InnerIP == vmListQuery.InnerIP) &&
					(vmListQuery.PublicIP == "" || data.PublicIP == vmListQuery.PublicIP) &&
					(vmListQuery.Name == "" || strings.Contains(data.Name, vmListQuery.Name)) &&
					(vmListQuery.Id == "" || strings.Contains(data.ID, vmListQuery.Id)) &&
					(vmListQuery.TenantId == "" || data.TenantId == vmListQuery.TenantId) {
					aggregatesVmDataList = append(aggregatesVmDataList, data)
				}

			}
		}
	}
	return aggregatesVmDataList, err

}

// 缓存云主机数据带有详情 20211228
func (h *AggregateService) StorageAggregateVm() (vmL []aggregate.VmDetail, err error) {
	klog.Infoln("DEBUG - cloud products vm start  - 4.1")

	InstancesData, err := h.GetInstancesAll()
	klog.Infoln("DEBUG - cloud products vm start  - 4.2")
	if err != nil {
		klog.Errorln("basicdao.GetRegion err:", err)
		err = nil
		return
	}
	if len(InstancesData) > 0 {
		regionData, err := basicdao.GetRegion(basicdao.Region{
			RegionCodeAggregate: h.ApiServerConfig.RegionName,
		})
		if err != nil {
			klog.Errorln("basicdao.GetRegion err:", err)
			err = nil
			return vmL, err
		}
		for _, instances := range InstancesData {
			if len(instances.Server) > 0 {
				for _, instance := range instances.Server {
					res := aggregate.VmDetail{}
					//user, err := h.GetUserDetailFromIdentity(instance.UserID)
					klog.Infoln("DEBUG - cloud products vm start  - 4.3")
					user, err := h.GetUserDetailFromRedis(instance.TenantID)
					if err != nil {
						klog.Errorln("h.GetUserDetailFromIdentity(instance.UserID) err:", err)
						err = nil
						//continue
					}
					// vmDetailQuery := aggregate.VmDetailQuery{
					// 	Region:     regionData.RegionCode,
					// 	InstanceId: []string{instance.ID},
					// 	UserName:   user.Name, // "180000000",
					// }
					//klog.Info("vmDetailQuery:", user.Name)
					vmDetail := aggregate.InstancesSetData{}
					klog.Infoln("DEBUG - cloud products vm start  - 4.4")
					vmDetail, err = GetOneVMDetail(regionData.RegionCode, []string{instance.ID}, user.Name)
					klog.Infoln("DEBUG - cloud products vm start  - 4.5")
					if err != nil {
						klog.Errorln("GetOneVMDetail(regionData.RegionCode, []string{instance.ID}, user.Name) err:", err)
						err = nil
						//return vmL, err
					}
					// if len(vmDetails.InstancesSet) > 0 {
					// 	vmDetail = vmDetails.InstancesSet[0]
					// }
					//klog.Infoln("DEBUG - cloud products vm start  - 4.6")
					//networkInterfaceSetData, networks, securitys, _ := GetNetworkInterfaceList(user.Name, regionData.RegionCode, vmDetail.AvailabilityZone, vmDetail.NetworkInterfaceSet)
					//klog.Infoln("DEBUG - cloud products vm start  - 4.7")
					// networkInterfaceSetData := aggregate.NetworkInterfaceSetData{}
					// if len(vmDetail.NetworkInterfaceSet) > 0 {
					// 	networkInterfaceSetData = vmDetail.NetworkInterfaceSet[0]
					// }
					//dataGurd := ""
					//dataGuardList := []aggregate.DataGuardSetData{}
					//if len(vmDetail.DataGuardSet) > 0 {
					//	for _, dataG := range vmDetail.DataGuardSet {
					//		dataGurd += fmt.Sprintf("%s-%s ", dataG.DataGuardName, dataG.DataGuardId)
					//	}
					//	klog.Infoln("DEBUG - cloud products vm start  - 4.8")
					//	dataGuardList, _ = GetDataGuards(user.Name, regionData.RegionCode, vmDetail.DataGuardSet)
					//	klog.Infoln("DEBUG - cloud products vm start  - 4.9")
					//
					//}
					//dataDisks := ""
					//if len(vmDetail.DataDisks) > 0 {
					//	for _, dataG := range vmDetail.DataDisks {
					//		dataDisks += fmt.Sprintf("%s-%d ", dataG.DiskType, dataG.DiskSize)
					//	}
					//}
					//keyList := []aggregate.KeyData{}
					//keyListR, err := GetKeys(vmDetail.KeySet, user.Name, regionData.RegionCode)
					//if err != nil {
					//	klog.Infoln("GetKeys(vmDetail.KeySet, user.Name, regionData.RegionCode) err:", err)
					//	err = nil
					//} else {
					//	keyList = keyListR
					//}
					//localVolumeList := []aggregate.LocalVolumeSetData{}
					//klog.Infoln("DEBUG - cloud products vm start  - 4.10")
					//localVolumeListR, err := GetLocalVolumes(user.Name, regionData.RegionCode, instance.ID)
					//klog.Infoln("DEBUG - cloud products vm start  - 4.11")
					//if err != nil {
					//	klog.Infoln("GetLocalVolumes(user.Name, regionData.RegionCode, instance.ID) err:", err)
					//	err = nil
					//} else {
					//	localVolumeList = localVolumeListR
					//}
					//eip := aggregate.EipData{}
					//klog.Infoln("DEBUG - cloud products vm start  - 4.12")
					//eipR, err := GetEIPs(user.Name, regionData.RegionCode, []string{networkInterfaceSetData.NetworkInterfaceId})
					//klog.Infoln("DEBUG - cloud products vm start  - 4.13")
					//if err != nil {
					//	klog.Infoln("GetEIPs(user.Name, regionData.RegionCode, []string{networkInterfaceSetData.NetworkInterfaceId}) err:", err)
					//	err = nil
					//} else {
					//	eip = eipR
					//}
					////az.Value = instances.Az
					//image := aggregate.ImageData{}
					//klog.Infoln("DEBUG - cloud products vm start  - 4.14")
					//imageList, err := GetImages(user.Name, regionData.RegionCode, interfaceToValue(instance.Image["id"]))
					//klog.Infoln("DEBUG - cloud products vm start  - 4.15")
					//if err == nil {
					//	if len(imageList) > 0 {
					//		image = imageList[0]
					//	}
					//} else {
					//	klog.Infoln("GetImages err:", err)
					//	err = nil
					//}
					//获取云硬盘列表
					vmVolumeList := []storage.DiskDetail{}
					klog.Infoln("DEBUG - cloud products vm start  - 4.16")
					vmVolumeResult, err := h.blockStoragePoolService.GetVmVolumes(user.Name, instance.ID, "system")
					klog.Infoln("DEBUG - cloud products vm start  - 4.17")

					ebsAPIResp, err := h.blockStoragePoolService.GetEBSDiskList(EBSAPIRequest{
						VmId:   instance.ID,
						UserId: user.Name,
					})
					klog.Infoln("DEBUG - cloud products vm start  - 4.18")
					ebsVolumes := make([]aggregate.EBSVolume, 0)
					for _, vol := range ebsAPIResp.Volumes {
						var ebsVolume aggregate.EBSVolume
						err := copier.Copy(&ebsVolume, &vol)
						if err != nil {
							klog.Error(err)
							continue
						}
						ebsVolumes = append(ebsVolumes, ebsVolume)
					}

					if err == nil {
						vmVolumeList = vmVolumeResult.DataList
					} else {
						klog.Infoln("h.blockStoragePoolService.GetVmVolumes err:", err)
						err = nil
					}
					tenant, err := GetRedisTenantMessage(user.Name)
					if err == nil {
						res.TenantName = tenant.Name
					} else {
						klog.Infoln("h.blockStoragePoolService.GetVmVolumes err:", err)
						err = nil
					}
					tags := instance.Tags
					if tags != nil {
						res.Label = strings.Join(*instance.Tags, ",")
					}
					deleteT, _ := strconv.ParseInt(vmDetail.AutoDeleteTime, 10, 64)
					//if err != nil {
					//	klog.Errorln("strconv.Atoi(vmDetail.AutoDeleteTime):", err)
					//	err = nil
					//}
					if vmDetail.AvailabilityZone == "" || vmDetail.AvailabilityZoneName == "" {
						ctx, cancle := context.WithTimeout(context.Background(), 2*time.Second)
						rs, _ := gredis.HGet(ctx, gredis.AggregatesMapKey, strconv.Itoa(instances.AggregateId))
						cancle()
						var aggregate = aggregate.Aggregates{}
						_ = json.Unmarshal([]byte(rs), &aggregate)
						if aggregate.AzCode != "" {
							vmDetail.AvailabilityZone = aggregate.AzCode
						}
						if aggregate.Az != "" {
							vmDetail.AvailabilityZoneName = aggregate.Az
						}
					}
					res.Id = instance.ID
					res.Name = user.Name
					res.Status = strings.ToLower(instance.Status)
					res.TenantId = user.Name //instance.UserID
					res.Aggregate = instances.Aggregate
					res.AggregateId = instances.AggregateId
					res.Region = regionData.RegionName     //h.ApiServerConfig.RegionName
					res.RegionCode = regionData.RegionCode //h.ApiServerConfig.RegionName
					res.AzCode = vmDetail.AvailabilityZone
					res.Az = vmDetail.AvailabilityZoneName
					res.Host = instances.BelongHost //vmDetail.HostName //instance.HostID
					res.VmName = instance.Name      //vmDetail.HostName  //instance.Name   //vmDetail.HostName
					//res.Business = "unknown"
					//res.OpsLabel = "unknown"
					//res.Label = strings.Join(*instance.Tags, ",")
					res.ImageId = interfaceToValue(instance.Image["id"])
					//res.DataGuardSet = dataGurd //instance.Fault.Details
					res.AdminPass = instance.AdminPass
					res.CreateTime = instance.Created.Unix() - 3600*8
					//res.EndTime = "unknown"
					res.DeleteTime = deleteT                                                                               //"unknown"
					res.InstanceType = vmDetail.InstanceType                                                               //"unknown"
					res.Size = fmt.Sprintf("%d核%dG", vmDetail.InstanceConfigure.VCPU, vmDetail.InstanceConfigure.MemoryGb) //fmt.Sprintf("%.0f核%.2fG", instance.Flavor["vcpus"].(float64), instance.Flavor["ram"].(float64)/1024) // //interfaceToValue(instance.Flavor["cluster"]) + "-" + interfaceToValue(instance.Flavor["vcpus"]) + "-" + interfaceToValue(instance.Flavor["ram"]) + "-" + interfaceToValue(instance.Flavor["storage_type"]) + "-" + interfaceToValue(instance.Flavor["disk"]) // "unknown"
					vcpu, vmem := vmDetail.InstanceConfigure.VCPU, vmDetail.InstanceConfigure.MemoryGb
					if vcpu == 0 {
						if cpus := instance.Flavor["vcpus"].(float64); cpus > 0 {
							vcpu = int(cpus)
						}
					}
					if vmem == 0 {
						if mems := instance.Flavor["ram"].(float64); mems > 0 {
							vmem = int(mems / 1024)
						}
					}
					res.Size = fmt.Sprintf("%d核%dG", vcpu, vmem) //fmt.Sprintf("%.0f核%.2fG", instance.Flavor["vcpus"].(float64), instance.Flavor["ram"].(float64)/1024) // //interfaceToValue(instance.Flavor["cluster"]) + "-" + interfaceToValue(instance.Flavor["vcpus"]) + "-" + interfaceToValue(instance.Flavor["ram"]) + "-" + interfaceToValue(instance.Flavor["storage_type"]) + "-" + interfaceToValue(instance.Flavor["disk"]) // "unknown"
					//res.Os = image.Platform                                                                                //"unknown"
					//res.SysDisk = vmDetail.SystemDisk.DiskType + " (1块" + strconv.Itoa(vmDetail.SystemDisk.DiskSize) + ")" //"unknown"
					//res.DataDisk = dataDisks                                                                               //"unknown"
					//res.INCId = networkInterfaceSetData.NetworkInterfaceId                                                 //"unknown"
					//res.EIp = eip.PublicIp                                                                                 // "unknown"
					//res.DNS1 = networkInterfaceSetData.DNS1                                                                //"unknown"
					//res.DNS2 = networkInterfaceSetData.DNS2                                                                //"unknown"
					//res.InternetIpV4 = eip.PublicIp                                                                        //instance.AccessIPv4
					//res.SecurityGroup = networkInterfaceSetData.SecurityGroupName                                          //instance.SecurityGroups
					//res.VPC = networkInterfaceSetData.VpcName                                                              //vmDetail.NetworkInterfaceSet[0].VpcId //"unknown"
					//res.SubNetwork = networkInterfaceSetData.SubnetName                                                    // "unknown"
					//res.InnerIp = vmDetail.PrivateIpAddress                                                                //"unknown"
					//res.NetworkList = networks
					//res.KeyList = keyList
					//res.SecurityList = securitys
					//res.DataGuardList = dataGuardList
					//res.LocalVolumeSetDataList = localVolumeList
					res.VmVolumeSetDataList = vmVolumeList
					res.HostName = vmDetail.HostName
					res.EBSVolumes = ebsVolumes
					klog.Infoln("DEBUG - cloud products vm start  - 4.19")
					res.MetricDir = getMetricDirectory(regionData.RegionCode, user.Name, instance.ID)
					klog.Infoln("DEBUG - cloud products vm start  - 4.20")
					vmL = append(vmL, res)
				}

			}

		}
	}
	return vmL, err
}

func getMetricDirectory(regionCode, accountId, vmId string) []string {
	dirs := make([]string, 0)
	var galaxySubDomain string
	if galaxySubDomain = os.Getenv("GALAXY_SUB_DOMAIN"); galaxySubDomain == "" {
		galaxySubDomain = "sdns.yunyan.com"
	}
	domain := fmt.Sprintf("monitor.console.%s", galaxySubDomain)
	//instanceId := "5b09313e-052e-4bf3-bd8c-1b63a5b69fac"
	apiUrl := "http://" + domain + "/?Action=ListMetrics&Version=2010-05-25&PageIndex=1&Namespace=kec&InstanceID=" + vmId
	klog.Infoln("DEBUG - cloud products vm api  - ", apiUrl)
	request, err := http.NewRequest("GET", apiUrl, nil)
	if err != nil {
		klog.Errorf("GetVmDetailFromApi err:%v", err)
		return dirs
	}
	request.Header.Add("X-KSC-ACCOUNT-ID", accountId)
	request.Header.Add("X-KSC-REGION", regionCode)
	request.Header.Add("Accept", "application/json")
	request.Header.Add("X-KSC-REQUEST-ID", uuid.New().String())

	//处理返回结果
	client := &http.Client{}
	response, err := client.Do(request)
	if err != nil {
		klog.Errorf("client.Do(request) err:%v/n", err)
		return dirs
	}
	bytes, err := ioutil.ReadAll(response.Body)
	if err != nil {
		klog.Errorf("ioutil.ReadAll(response.Body) err:%v/n", err)
		return dirs
	}
	var rsp aggregate.ListMetricsResponse
	err = json.Unmarshal(bytes, &rsp)
	if err != nil {
		klog.Errorf("json.Unmarshal(response.Body) err:%v/n", err)
		return dirs
	}

	for _, member := range rsp.ListMetricsResult.Members {
		if strings.HasPrefix(member.MetricName, "vfs.fs.size") {
			dirMetric := strings.Replace(member.MetricName, "vfs.fs.size", "", 1)
			dirSlice := strings.Split(strings.Trim(dirMetric, "[]"), ",")
			dirs = append(dirs, dirSlice[0])
		}
	}
	_ = response.Body.Close()
	return dirs
}

// 获取云主机详情 从缓存中获取
func (h *AggregateService) GetVmDetails(vmQuery aggregate.VMQuery) (res aggregate.VmDetail, err error) {
	//res := aggregate.VmDetail{}
	if vmQuery.Id == "" {
		return
	}
	res, err = aggregate.GetAggregateVm(vmQuery.Id)
	return res, err

}

func getAggregatesVmList() (result map[string]struct{}, err error) {
	var keys []string
	ctx, cancel := context.WithTimeout(context.Background(), 2*time.Second)
	keys, err = gredis.HKeys(ctx, gredis.NovaCloudServerHashKey)
	cancel()
	if err != nil {
		return
	}
	result = make(map[string]struct{})
	for _, key := range keys {
		result[key] = struct{}{}
	}
	return
}

// 获取所有的instance
func (h *AggregateService) GetInstancesAll() ([]aggregate.VmFromNova, error) {
	var allInstannces []aggregate.VmFromNova
	var err error
	var result map[string]struct{}
	//page, err := aggregates.List(h.Novaclient).AllPages()
	//if err != nil {
	//	klog.Errorln("aggregates.List(h.Novaclient).AllPages() err:", err)
	//	err = nil
	//	//api.HandleInternalError(response, err)
	//	return allInstannces, err
	//}
	//aggs, err := aggregates.ExtractAggregates(page)
	//if err != nil {
	//	klog.Errorln("aggregates.ExtractAggregates(page) err:", err)
	//	err = nil
	//	//api.HandleInternalError(response, err)
	//	return allInstannces, err
	//}
	//
	//for _, agg := range aggs {
	//	if agg.Deleted {
	//		continue
	//	}
	//	for i := range agg.Hosts {
	//		//通过服务器获取虚机
	//		instances, err := h.GetHostInstance(agg.Hosts[i])
	//		if err != nil {
	//			klog.Errorln(" h.GetHostInstance(agg.Hosts[i]) err:", err)
	//			err = nil
	//			//api.HandleInternalError(response, err)
	//			return allInstannces, err
	//		}
	//		Vm := aggregate.VmFromNova{
	//			Server:      instances,
	//			Az:          agg.AvailabilityZone,
	//			Aggregate:   agg.Name,
	//			AggregateId: agg.ID,
	//			BelongHost:  agg.Hosts[i],
	//		}
	//		allInstannces = append(allInstannces, Vm)
	//	}
	//}
	//result := kec.GetAggregatesVmListByInnerApi()
	result, err = getAggregatesVmList()
	if err != nil {
		return nil, err
	}
	VmMap := make(map[string][]servers.Server)
	for id := range result {
		var novaServer novaTask.NovaServer
		var er error
		var ok bool
		ctx, cancel := context.WithTimeout(context.Background(), 2*time.Second)
		rs, _ := gredis.HGet(ctx, gredis.NovaCloudServerHashKey, id)
		cancel()
		if rs != "" {
			_ = json.Unmarshal([]byte(rs), &novaServer)
		}
		if novaServer.ID == "" {
			token, tokenKey := novaTask.GetTokenAndKey()
			if token == "" || tokenKey == "" {
				klog.Error("fetch nova token failed.")
				continue
			}
			apiUrl := fmt.Sprintf("http://%s:%d/%s/%s/%s/%s", novaTask.NovaDomain, novaTask.NovaPort, novaTask.NovaVersion, tokenKey, novaTask.NovaServersSuffix, id)
			headers := map[string]string{
				"X-Auth-Token":      token,
				"X-Auth-Project-Id": "admin",
				"Accept":            "application/json",
			}
			var (
				serverMap map[string]novaTask.NovaServer
			)
			er = novaTask.GetNovaResult(apiUrl, headers, &serverMap)
			if er != nil {
				klog.Errorf("fetch detail of cloudServer from: %s,failed. err: %+v", apiUrl, err)
				continue
			}
			if novaServer, ok = serverMap["novaServer"]; !ok {
				continue
			}
		}
		host := novaServer.HypervisorHostname
		if host == "" {
			host = novaServer.HostID
		}
		//if host == "" {continue}
		var ser = servers.Server{
			ID:              novaServer.ID,
			TenantID:        novaServer.TenantID,
			UserID:          novaServer.UserID,
			Name:            novaServer.Name,
			Updated:         novaServer.Updated,
			Created:         novaServer.Created,
			HostID:          host,
			Status:          novaServer.Status,
			Progress:        novaServer.Progress,
			AccessIPv4:      novaServer.AccessIPv4,
			AccessIPv6:      novaServer.AccessIPv6,
			Image:           novaServer.Image,
			Flavor:          novaServer.Flavor,
			Addresses:       novaServer.Addresses,
			Metadata:        novaServer.Metadata,
			Links:           novaServer.Links,
			KeyName:         novaServer.KeyName,
			AdminPass:       novaServer.AdminPass,
			SecurityGroups:  novaServer.SecurityGroups,
			AttachedVolumes: novaServer.AttachedVolumes,
			Fault:           novaServer.Fault,
			Tags:            novaServer.Tags,
		}
		VmMap[host] = append(VmMap[host], ser)
	}
	for host, serverList := range VmMap {
		var (
			agg    novaTask.NovaAggregate
			ctx    context.Context
			cancel context.CancelFunc
		)
		Vm := aggregate.VmFromNova{
			Server:     serverList,
			BelongHost: host,
		}
		if host != "" {
			ctx, cancel = context.WithTimeout(context.Background(), 2*time.Second)
			agName, _ := gredis.HGet(ctx, gredis.NovaAggregateAndPhysicalServiceMappingKey, host)
			cancel()
			if agName == "" {
				goto END
			}
			ctx, cancel = context.WithTimeout(context.Background(), 2*time.Second)
			agStr, _ := gredis.HGet(ctx, gredis.NovaAggregateHashKey, agName)
			cancel()
			if agStr == "" {
				goto END
			}
			err = json.Unmarshal([]byte(agStr), &agg)
			if err != nil {
				goto END
			}
		}
		Vm.Az = agg.AvailabilityZone
		Vm.Aggregate = agg.Name
		Vm.AggregateId = agg.Id
	END:
		allInstannces = append(allInstannces, Vm)
	}
	return allInstannces, err
	//response.WriteEntity(res)
}

func (h *AggregateService) GetAggregateDetail(id int) (aggregate.Aggregates, error) {
	res := aggregate.Aggregates{}
	agg, err := aggregates.Get(h.Novaclient, id).Extract()
	if err != nil {
		klog.Errorln(" aggregates.Get(h.Novaclient, id).Extract() err:", err)
		err = nil
		return res, err
	}
	sers := make(map[string]string)
	ser := ""
	allInstannces := []servers.Server{}
	for i := range agg.Hosts {
		instances, err := h.GetHostInstance(agg.Hosts[i])
		if err != nil {
			klog.Errorln("h.GetHostInstance(agg.Hosts[i]) err:", err)
			err = nil
			return res, err
		}
		allInstannces = append(allInstannces, instances...)
		entity, err := serverdao.SelectServerInfo(agg.Hosts[i], "", 0)
		if err != nil && err != gorm.ErrRecordNotFound {
			klog.Errorln("serverdao.SelectServerInfo err:", err)
			err = nil
			continue
		}
		err = nil
		s := entity.Service
		sers[s] = s
	}
	//ser = GetServiceByIps(ips)
	for key := range sers {
		ser = fmt.Sprintf("%s\n%s", ser, key)
	}
	ser = strings.TrimRight(ser, "\n")
	// region := DgraphService{
	// 	Code:  "regionCodeAggregate",
	// 	Value: h.ApiServerConfig.RegionName,
	// }
	// regionData := region.GetRegionByOurWay()
	// az := DgraphService{
	// 	Code:  "azCodeAggregate",
	// 	Value: agg.AvailabilityZone,
	// }
	// azData := az.GetAZByOurWay()
	regionData, err := basicdao.GetRegion(basicdao.Region{
		RegionCodeAggregate: h.ApiServerConfig.RegionName,
	})
	azData, err := basicdao.GetAz(basicdao.Az{
		AzCodeAggregate: agg.AvailabilityZone,
	})
	res = aggregate.Aggregates{
		Name:       agg.Name,
		Id:         agg.ID,
		Region:     regionData.RegionName, //h.apiServerConfig.RegionName,
		RegionCode: regionData.RegionCode, //h.apiServerConfig.RegionName,
		Service:    ser,                   //"unknown",
		Az:         azData.AzName,         //agg.AvailabilityZone,
		AzCode:     azData.AzCode,         //agg.AvailabilityZone,
		HostCount:  len(agg.Hosts),
		VMCount:    len(allInstannces),
	}
	return res, err
}

func (h *AggregateService) GetOverviewData(overviewQuery aggregate.OverviewQuery) (aggregate.AggregateOverview, error) {
	var aggregateOverview aggregate.AggregateOverview
	regionAzOverview := make(map[string]int)
	instanceTotalCount := 0
	instanceRunningCount := 0
	instanceErrorCount := 0
	reasourcePoolData := []aggregate.OverView{}

	//临时处理
	azList := []string{}
	if overviewQuery.Az != "" && overviewQuery.Az != "all" {
		azList = append(azList, overviewQuery.Az)
	}

	VmDataList, err := h.GetVMsList(aggregate.VMListQuery{
		Region: overviewQuery.Region,
		Az:     azList,
	})
	if err != nil {
		klog.Errorln("h.GetVMsList err:", err)
		err = nil
		return aggregateOverview, err
	}

	if len(VmDataList) > 0 {
		aggregateToVmCountMap := make(map[string]int)
		for _, data := range VmDataList {
			//查询等于服务器name的云主机列表
			// if (overviewQuery.Region == "all" || data.RegionCode == overviewQuery.Region) &&
			// 	(overviewQuery.Az == "all" || data.AzCode == overviewQuery.Az) {
			mapString := fmt.Sprintf("%s,%s,%s", data.Region+data.Az, data.RegionCode, data.AzCode)
			if vmCount, ok := regionAzOverview[mapString]; ok {
				regionAzOverview[mapString] = vmCount + 1
			} else {
				regionAzOverview[mapString] = 1
			}
			instanceTotalCount++
			if data.Status == "active" {
				instanceRunningCount++
			} else if data.Status == "error" {
				instanceErrorCount++
			}

			// group by Aggregate
			if count, ok := aggregateToVmCountMap[data.Aggregate]; ok {
				aggregateToVmCountMap[data.Aggregate] = count + 1
			} else {
				aggregateToVmCountMap[data.Aggregate] = 1
			}
		}

		for k, v := range aggregateToVmCountMap {
			//资源池名称为空的不显示
			if k != "" {
				reasourcePoolData = append(reasourcePoolData, aggregate.OverView{
					Name:  k,
					Value: v,
				})
			}
		}

		aggregateOverview.ReasourcePoolOverview.Data = reasourcePoolData
		aggregateOverview.ReasourcePoolOverview.Title = "云主机"
		aggregateOverview.ReasourcePoolOverview.Totle = instanceTotalCount
		aggregateOverview.ReasourcePoolOverview.Unit = "个"

		aggregateOverview.InstanceOverview = append(aggregateOverview.InstanceOverview, aggregate.OverView{
			Name:   "总数量",
			Code:   "TotalCount",
			Status: "",
			Value:  instanceTotalCount,
		})
		aggregateOverview.InstanceOverview = append(aggregateOverview.InstanceOverview, aggregate.OverView{
			Name:   "运行中",
			Code:   "RunningCount",
			Status: "active",
			Value:  instanceRunningCount,
		})
		aggregateOverview.InstanceOverview = append(aggregateOverview.InstanceOverview, aggregate.OverView{
			Name:   "故障",
			Code:   "ErrorCount",
			Status: "error",
			Value:  instanceErrorCount,
		})
		for name, value := range regionAzOverview {
			mapSplit := strings.Split(name, ",")
			overView := []aggregate.OverView{}
			overView = append(overView, aggregate.OverView{
				Name:  "云主机",
				Code:  "",
				Value: value,
			})
			aggregateOverview.DistributedOverview = append(aggregateOverview.DistributedOverview, aggregate.DistributedOverView{
				Name:        mapSplit[0],
				Region:      mapSplit[1],
				Az:          mapSplit[2],
				Distributed: overView,
			})
		}

	} else {
		aggregateOverview.ReasourcePoolOverview.Data = reasourcePoolData
		aggregateOverview.ReasourcePoolOverview.Title = "云主机"
		aggregateOverview.ReasourcePoolOverview.Totle = instanceTotalCount
		aggregateOverview.ReasourcePoolOverview.Unit = "个"

		aggregateOverview.InstanceOverview = append(aggregateOverview.InstanceOverview, aggregate.OverView{
			Name:   "总数量",
			Code:   "TotalCount",
			Status: "",
			Value:  instanceTotalCount,
		})
		aggregateOverview.InstanceOverview = append(aggregateOverview.InstanceOverview, aggregate.OverView{
			Name:   "运行中",
			Code:   "RunningCount",
			Status: "active",
			Value:  instanceRunningCount,
		})
		aggregateOverview.InstanceOverview = append(aggregateOverview.InstanceOverview, aggregate.OverView{
			Name:   "故障",
			Code:   "ErrorCount",
			Status: "error",
			Value:  instanceErrorCount,
		})
		{
			overView := []aggregate.OverView{}
			overView = append(overView, aggregate.OverView{
				Name:  "云主机",
				Code:  "",
				Value: 0,
			})
			aggregateOverview.DistributedOverview = append(aggregateOverview.DistributedOverview, aggregate.DistributedOverView{
				Name:        "",
				Region:      "",
				Az:          "",
				Distributed: overView,
			})
		}
	}
	if len(aggregateOverview.DistributedOverview) > 0 {
		sort.Sort(aggregateOverview.DistributedOverview)
	}
	return aggregateOverview, nil
}

////根据区域，可用区，资源池 获取计算资源池或者云主机概览页面数据
//func (h *AggregateService) GetOverviewData(overviewQuery aggregate.OverviewQuery) (aggregate.AggregateOverview, error) {
//	//AggregatesData, err := h.GetAggregateAll()
//	list := aggregate.GetAggregateMap()
//	//var aggregatesVmDataList []AggregatesVm
//	var aggregateOverview aggregate.AggregateOverview
//	regionAzOverview := make(map[string]int)
//	instanceTotalCount := 0
//	instanceRunningCount := 0
//	instanceErrorCount := 0
//	reasourcePoolData := []aggregate.OverView{}
//
//	//临时处理
//	azList := []string{}
//	if overviewQuery.Az != "" && overviewQuery.Az != "all" {
//		azList = append(azList, overviewQuery.Az)
//	}
//	if len(list) > 0 {
//		for _, aggregat := range list {
//
//			//if overviewQuery.Id == "all" || strconv.Itoa(aggregat.Id) == overviewQuery.Id {
//			//VmDataList, err := h.GetAggregateVMsAll(strconv.Itoa(aggregat.Id), []string{})
//			VmDataList, err := h.GetVMsList(aggregate.VMListQuery{
//				Aggregate: aggregat.Name,
//				Region:    overviewQuery.Region,
//				Az:        azList,
//			})
//			if err != nil {
//				klog.Errorln("h.GetVMsList err:", err)
//				err = nil
//				return aggregateOverview, err
//			}
//			reasourcePoolVMCount := 0
//
//			for _, data := range VmDataList {
//				//查询等于服务器name的云主机列表
//				// if (overviewQuery.Region == "all" || data.RegionCode == overviewQuery.Region) &&
//				// 	(overviewQuery.Az == "all" || data.AzCode == overviewQuery.Az) {
//				mapString := fmt.Sprintf("%s,%s,%s", data.Region+data.Az, data.RegionCode, data.AzCode)
//				if vmCount, ok := regionAzOverview[mapString]; ok {
//					regionAzOverview[mapString] = vmCount + 1
//				} else {
//					regionAzOverview[mapString] = 1
//				}
//				// if vmCount, ok := regionAzOverview[data.Region+data.Az]; ok {
//				// 	regionAzOverview[data.Region+data.Az] = vmCount + 1
//				// } else {
//				// 	regionAzOverview[data.Region+data.Az] = 1
//				// }
//				instanceTotalCount++
//				if data.Status == "active" {
//					instanceRunningCount++
//				} else if data.Status == "error" {
//					instanceErrorCount++
//				}
//				reasourcePoolVMCount++
//				//aggregatesVmDataList = append(aggregatesVmDataList, data)
//				//}
//
//			}
//
//			reasourcePoolData = append(reasourcePoolData, aggregate.OverView{
//				Name:  aggregat.Name,
//				Value: reasourcePoolVMCount,
//			})
//
//			//}
//		}
//		aggregateOverview.ReasourcePoolOverview.Data = reasourcePoolData
//		aggregateOverview.ReasourcePoolOverview.Title = "云主机"
//		aggregateOverview.ReasourcePoolOverview.Totle = instanceTotalCount
//		aggregateOverview.ReasourcePoolOverview.Unit = "个"
//		aggregateOverview.InstanceOverview = append(aggregateOverview.InstanceOverview, aggregate.OverView{
//			Name:   "总数量",
//			Code:   "TotalCount",
//			Status: "",
//			Value:  instanceTotalCount,
//		})
//		aggregateOverview.InstanceOverview = append(aggregateOverview.InstanceOverview, aggregate.OverView{
//			Name:   "运行中",
//			Code:   "RunningCount",
//			Status: "active",
//			Value:  instanceRunningCount,
//		})
//		aggregateOverview.InstanceOverview = append(aggregateOverview.InstanceOverview, aggregate.OverView{
//			Name:   "故障",
//			Code:   "ErrorCount",
//			Status: "error",
//			Value:  instanceErrorCount,
//		})
//		for name, value := range regionAzOverview {
//			mapSplit := strings.Split(name, ",")
//			overView := []aggregate.OverView{}
//			overView = append(overView, aggregate.OverView{
//				Name:  "云主机",
//				Code:  "",
//				Value: value,
//			})
//			aggregateOverview.DistributedOverview = append(aggregateOverview.DistributedOverview, aggregate.DistributedOverView{
//				Name:        mapSplit[0],
//				Region:      mapSplit[1],
//				Az:          mapSplit[2],
//				Distributed: overView,
//			})
//		}
//
//	} else {
//		aggregateOverview.ReasourcePoolOverview.Data = reasourcePoolData
//		aggregateOverview.ReasourcePoolOverview.Title = "云主机"
//		aggregateOverview.ReasourcePoolOverview.Totle = instanceTotalCount
//		aggregateOverview.ReasourcePoolOverview.Unit = "个"
//		aggregateOverview.InstanceOverview = append(aggregateOverview.InstanceOverview, aggregate.OverView{
//			Name:   "总数量",
//			Code:   "TotalCount",
//			Status: "",
//			Value:  instanceTotalCount,
//		})
//		aggregateOverview.InstanceOverview = append(aggregateOverview.InstanceOverview, aggregate.OverView{
//			Name:   "运行中",
//			Code:   "RunningCount",
//			Status: "active",
//			Value:  instanceRunningCount,
//		})
//		aggregateOverview.InstanceOverview = append(aggregateOverview.InstanceOverview, aggregate.OverView{
//			Name:   "故障",
//			Code:   "ErrorCount",
//			Status: "error",
//			Value:  instanceErrorCount,
//		})
//		{
//			overView := []aggregate.OverView{}
//			overView = append(overView, aggregate.OverView{
//				Name:  "云主机",
//				Code:  "",
//				Value: 0,
//			})
//			aggregateOverview.DistributedOverview = append(aggregateOverview.DistributedOverview, aggregate.DistributedOverView{
//				Name:        "",
//				Region:      "",
//				Az:          "",
//				Distributed: overView,
//			})
//		}
//	}
//	if len(aggregateOverview.DistributedOverview) > 0 {
//		sort.Sort(aggregateOverview.DistributedOverview)
//	}
//	return aggregateOverview, nil
//}

func (h *AggregateService) GetCMDBOverView(aggragateListQuery aggregate.CMDBOverViewQuery) (aggregate.CMDBAggregateOverview, error) {
	var aggregateOverview aggregate.CMDBAggregateOverview

	aggregatesUsageQuery := aggregate.AggregatesUsageQuery{
		PageSize: math.MaxInt,
		Region:   aggragateListQuery.Region,
		Az:       []string{aggragateListQuery.Az},
	}
	aggregatesDataList, err := h.GetAggregateUsageAll(aggregatesUsageQuery)
	if err != nil {
		return aggregate.CMDBAggregateOverview{}, err
	}
	for _, aggregat := range aggregatesDataList {
		name := aggregat.Name
		id := aggregat.Id
		cpuRate := aggregat.VCPURate
		memRate := aggregat.MemoryRate
		diskRate := 0.0

		aggregateOverview.CpuRate = append(aggregateOverview.CpuRate, aggregate.DistributedOverView1{
			Name: name,
			Id:   id,
			Distributed: []aggregate.OverView1{
				{
					Name:  "",
					Code:  "",
					Value: cpuRate,
				},
			},
		})
		aggregateOverview.MemaryRate = append(aggregateOverview.MemaryRate, aggregate.DistributedOverView1{
			Name: name,
			Id:   id,
			Distributed: []aggregate.OverView1{
				{
					Name:  "",
					Code:  "",
					Value: memRate,
				},
			},
		})
		aggregateOverview.DiskRate = append(aggregateOverview.DiskRate, aggregate.DistributedOverView1{
			Name: name,
			Id:   id,
			Distributed: []aggregate.OverView1{
				{
					Name:  "",
					Code:  "",
					Value: diskRate,
				},
			},
		})

	}

	//aggregateList := aggregate.GetAggregateMap()
	//aggregateToVmCountMap := make(map[string]int)
	//for _, a := range aggregateList {
	//	if _, ok := aggregateToVmCountMap[a.Name]; !ok {
	//		aggregateToVmCountMap[a.Name] = a.VMCount
	//	}
	//}

	aggregateToVmCountMap := make(map[string]int)
	aggregateList, err := h.GetVMsList(aggregate.VMListQuery{Region: aggragateListQuery.Region, Az: []string{aggragateListQuery.Az}})
	if err == nil && len(aggregateList) > 0 {
		for _, vm := range aggregateList {
			if vm.AzCode != aggragateListQuery.Az {
				continue
			}
			name := vm.Aggregate
			if name == "" {
				name = "--"
			}
			aggregateToVmCountMap[name]++
		}
	}
	//aggregateToVmCountMap = aggregate.GetAggregateVmCount()
	for name, value := range aggregateToVmCountMap {
		aggregateOverview.InstanceOverview = append(aggregateOverview.InstanceOverview, aggregate.OverView1{
			Name:  name,
			Value: value,
		})
	}
	return aggregateOverview, nil
}

// 获取nova user 信息利用identityclient
func (h *AggregateService) GetUserDetailFromIdentity(userId string) (*users.User, error) {
	//h.IdentityClient.Endpoint = "http://keystone.galaxy.cloud:35357/v2.0/"
	opt := options.GlobalConfig
	h.IdentityClient.Endpoint = opt.AuthURL
	var user *users.User
	user, err := users.Get(h.IdentityClient, userId).Extract() //userid
	if err != nil {
		//klog.Error("GetUserDetailFromIdentity err:", err.Error())
		return user, err
	}
	//klog.Info(fmt.Sprintf("tenantId: %s; userName: %s-%s-%s", userId, user.ID, user.Name, user.Username))
	return user, err
}

// 获取nova user 信息利用redis_cache
func (h *AggregateService) GetUserDetailFromRedis(tenantId string) (users.User, error) {
	//var user *keyStone.User
	var user users.User
	var userJson string
	var uid string
	var err error
	var ctx, cancel = context.WithTimeout(context.Background(), 5*time.Second)
	defer cancel()
	uid, err = gredis.HGet(ctx, gredis.TidUidMappingKey, tenantId)
	if err != nil {
		return user, err
	}
	userJson, err = gredis.HGet(ctx, gredis.UserInfoKey, uid)
	err = json.Unmarshal([]byte(userJson), &user)
	if err == nil {
		user.Name = user.ID //之前数据是从接口获取的，name值为当前id，为了兼容之前的逻辑，此处将name赋值为id
	}
	return user, err
}

// 从API中重新拿取虚机详细信息
func GetVmDetailFromApi(vmDetailQuery aggregate.VmDetailQuery) (aggregate.VmDetailFromNova, error) { //(aggregate.AggregateOverview, error) {
	var galaxySubDomain string
	if galaxySubDomain = os.Getenv("GALAXY_SUB_DOMAIN"); galaxySubDomain == "" {
		galaxySubDomain = "sdns.yunyan.com"
	}
	//novaIp := fmt.Sprintf("ecs.inner.%s", os.Getenv("GALAXY_SUB_DOMAIN")) //sdns.cqpcloud.cn"
	novaIp := fmt.Sprintf("ecs.inner.%s", galaxySubDomain) //sdns.cqpcloud.cn"
	//klog.Info("vmDetailQuery:", vmDetailQuery.UserName)
	vmDt := aggregate.VmDetailFromNova{}
	// if !h.ApiServerConfig.DisableOpenstackAPI {
	// 	novaIp = "10.177.152.9"
	// } //http://10.177.152.9/?Action=DescribeInstances&Version=2016-03-04&InstanceId.1=0378c058-ffd0-4d0e-bd69-a0500e7d298f' -H 'X-KSC-ACCOUNT-ID: 180000000' -H 'X-KSC-REGION: cn-shanghai-2'  -H 'Accept: application/json' -H 'X-KSC-REQUEST-ID: 6cbdfcb0-f62a-46a9-8284-1e8543810547'
	// } //http://10.177.152.9/?Action=DescribeInstances&Version=2016-03-04&InstanceId.1=709a5d94-921f-49ad-aea5-b7772b664dc3' -H 'X-KSC-ACCOUNT-ID: 180000000' -H 'X-KSC-REGION: cn-shanghai-2'  -H 'Accept: application/json' -H 'X-KSC-REQUEST-ID: 6cbdfcb0-f62a-46a9-8284-1e8543810547'
	novaInnerApi := "http://" + novaIp + "/?Action=" + Action + "&Version=" + Version
	if len(vmDetailQuery.InstanceId) > 0 {
		for index, instanceId := range vmDetailQuery.InstanceId {
			novaInnerApi += "&InstanceId." + strconv.Itoa(index+1) + "=" + instanceId
		}
	}
	if vmDetailQuery.MaxResults != "" {
		novaInnerApi += "&MaxResults=" + vmDetailQuery.MaxResults
	}
	if vmDetailQuery.Marker != "" {
		novaInnerApi += "&Marker=" + vmDetailQuery.Marker
	}
	if len(vmDetailQuery.Filter) > 0 {
		index := 1
		for key, value := range vmDetailQuery.Filter {
			novaInnerApi += "&Filter." + strconv.Itoa(index) + ".Name=" + key
			novaInnerApi += "&Filter." + strconv.Itoa(index) + ".Value=" + value
			index++
		}
	}
	if vmDetailQuery.Sort != "" {
		novaInnerApi += "&Sort=" + vmDetailQuery.Sort
	}
	if vmDetailQuery.Search != "" {
		novaInnerApi += "&Search=" + vmDetailQuery.Search
	}
	//klog.Infof("Simple get novaInnerApi: %s", novaInnerApi)
	klog.Infoln("DEBUG - cloud products vm api  - ", novaInnerApi)
	request, err := http.NewRequest("GET", novaInnerApi, nil)
	if err != nil {
		klog.Errorf("GetVmDetailFromApi err:%v", err)
		return vmDt, nil
	}
	request.Header.Add("X-KSC-ACCOUNT-ID", vmDetailQuery.UserName)
	request.Header.Add("X-KSC-REGION", vmDetailQuery.Region)
	request.Header.Add("Accept", "application/json")
	//request.Header.Add("X-KSC-REQUEST-ID", uuid.New().Version().String())
	request.Header.Add("X-KSC-REQUEST-ID", uuid.New().String())
	//处理返回结果
	client := &http.Client{}
	response, err := client.Do(request)
	if err != nil {
		klog.Errorf("client.Do(request) err:%v/n", err)
		return aggregate.VmDetailFromNova{}, nil
	}
	bt, err := ioutil.ReadAll(response.Body)
	if err != nil {
		klog.Errorf("ioutil.ReadAll(response.Body) err:%v/n", err)
		return aggregate.VmDetailFromNova{}, nil
	}
	err = json.Unmarshal(bt, &vmDt)
	//klog.Info("response.Body:", response.Body)
	//klog.Info("vmDt:", vmDt)
	_ = response.Body.Close()
	return vmDt, err
}

// 根据region vmid userid获取vm详情
func GetOneVMDetail(region string, vmIds []string, userId string) (aggregate.InstancesSetData, error) {
	vmDetail := aggregate.InstancesSetData{}
	if region == "" || len(vmIds) <= 0 || userId == "" {
		return vmDetail, errors.New("数据有误")
	}
	vmDetailQuery := aggregate.VmDetailQuery{
		Region:     region,
		InstanceId: vmIds,
		UserName:   userId, // "180000000",
	}
	vmDetails, err := GetVmDetailFromApi(vmDetailQuery)

	if err != nil {
		klog.Errorln("GetVmDetailFromApi(vmDetailQuery) err:", err)
		err = nil
		return vmDetail, err
	}
	if len(vmDetails.InstancesSet) > 0 {
		vmDetail = vmDetails.InstancesSet[0]
	}
	return vmDetail, err
}

// 获取网络信息，并返回网络信息，安全组列表，网络列表
func GetNetworkInterfaceList(userName, region, az string, networkList []aggregate.NetworkInterfaceSetData) (aggregate.NetworkInterfaceSetData, []aggregate.NetworkData, []aggregate.SecurityGroupSetData, error) {
	networkData := aggregate.NetworkInterfaceSetData{}
	networks := []aggregate.NetworkData{}
	securitys := []aggregate.SecurityGroupSetData{}
	//securitys := []aggregate.SecurityGroupData{}
	if len(networkList) <= 0 {
		return networkData, networks, securitys, errors.New("")
	}
	for _, nwData := range networkList {
		networkInterface, _ := GetNetworkInterfaces(nwData.NetworkInterfaceId, userName, region)
		if len(networkInterface.NetworkInterfaceSet) <= 0 {
			continue
		}

		for _, newnwData := range networkInterface.NetworkInterfaceSet {
			securityGroupSetResult, err := GetSecuritys(userName, region, []string{newnwData.SecurityGroupId})
			if err == nil && len(securityGroupSetResult) > 0 {
				for _, securityGroupData := range securityGroupSetResult {
					securityGroupData.VpcName = newnwData.VpcName
					for _, securityStatue := range securityGroupData.SecurityGroupEntrySet {
						if securityStatue.Direction == "in" {
							securityGroupData.InCount++
						} else if securityStatue.Direction == "out" {
							securityGroupData.OutCount++
						}
					}

					securitys = append(securitys, securityGroupData)
				}
			}
			network := aggregate.NetworkData{
				NetworkInterfaceId:   newnwData.NetworkInterfaceId,
				NetworkInterfaceType: newnwData.NetworkInterfaceType,
				VpcName:              newnwData.VpcName,
				SubnetName:           newnwData.SubnetName,
				PrivateIpAddress:     newnwData.PrivateIpAddress,
				Az:                   az,
			}
			networks = append(networks, network)
			networkData.VpcName += fmt.Sprintf("%s,/n", newnwData.VpcName)
			networkData.SecurityGroupName += fmt.Sprintf("%s,", newnwData.SecurityGroupName)
			networkData.SubnetName += fmt.Sprintf("%s,", newnwData.SubnetName)
			networkData.DNS1 += fmt.Sprintf("%s,", newnwData.DNS1)
			networkData.DNS2 += fmt.Sprintf("%s,", newnwData.DNS2)
			// networkData.VpcName=newnwData.VpcName
			// networkData.VpcName=newnwData.VpcName
			// networkData.VpcName=newnwData.VpcName
			// networkData.VpcName=newnwData.VpcName
			// networkData.VpcName=newnwData.VpcName
			// networkData.VpcName=newnwData.VpcName
			// networkData.VpcName=newnwData.VpcName
			// networkData.VpcName=newnwData.VpcName
			// networkData.VpcName=newnwData.VpcName
		}
	}
	networkData.NetworkInterfaceId = networkList[0].NetworkInterfaceId
	networkData.VpcName = strings.TrimRight(networkData.VpcName, ",/n")
	networkData.DNS1 = strings.TrimRight(networkData.DNS1, ",")
	networkData.DNS2 = strings.TrimRight(networkData.DNS2, ",")
	networkData.SubnetName = strings.TrimRight(networkData.SubnetName, ",")
	return networkData, networks, securitys, nil
}

// 根据网络ID获取网络信息//（安全组，VPC，DNS1,DNS2,子网）
func GetNetworkInterfaces(networkInterfaceId, userName, region string) (aggregate.NetworkInterfaceData, error) {
	networkInterfaceData := aggregate.NetworkInterfaceData{}

	networkapi := fmt.Sprintf("http://networkapi.inner.%s/?Action=DescribeNetworkInterfaces&Version=%s", os.Getenv("GALAXY_SUB_DOMAIN"), Version) //sdns.cqpcloud.cn
	if networkInterfaceId != "" {
		networkapi += fmt.Sprintf("&NetworkInterfaceId.1=%s", networkInterfaceId)
	}
	request, err := http.NewRequest("GET", networkapi, nil)
	request.Header.Add("X-KSC-ACCOUNT-ID", userName)
	request.Header.Add("X-KSC-REGION", region)
	request.Header.Add("Accept", "application/json")
	request.Header.Add("X-KSC-REQUEST-ID", uuid.New().Version().String())
	if err != nil {
		klog.Errorln(" http.NewRequest err:", err)
		err = nil
		return networkInterfaceData, err
	}
	//处理返回结果
	client := &http.Client{}
	klog.Infoln("DEBUG - cloud products vm api  - ", networkapi)
	response, err := client.Do(request)
	if err != nil {
		klog.Errorln(" client.Do(request) err:", err)
		err = nil
		return networkInterfaceData, err
	}
	bt, err := ioutil.ReadAll(response.Body)
	if err != nil {
		klog.Errorln(" ioutil.ReadAll(response.Body) err:", err)
		err = nil
		return networkInterfaceData, err
	}
	json.Unmarshal(bt, &networkInterfaceData)
	defer response.Body.Close()
	return networkInterfaceData, err
}

// 根据keyid获取key详情
func GetKeys(keyids []string, userName, region string) ([]aggregate.KeyData, error) {
	keyResult := aggregate.KeyResult{}
	keyList := []aggregate.KeyData{}
	networkapi := fmt.Sprintf("http://sks.inner.%s/?Version=2015-11-01&Action=DescribeKeys", os.Getenv("GALAXY_SUB_DOMAIN")) //sdns.cqpcloud.cn
	if len(keyids) <= 0 {
		return keyList, nil
	}
	for index, keyid := range keyids {
		networkapi += fmt.Sprintf("&KeyId.%d=%s", index+1, keyid)
	}
	request, err := http.NewRequest("GET", networkapi, nil)
	if err != nil {
		klog.Errorln("http.NewRequest err:", err)
		err = nil
		return keyList, err
	}
	request.Header.Add("X-KSC-ACCOUNT-ID", userName)
	request.Header.Add("X-KSC-REGION", region)
	request.Header.Add("Accept", "application/json")
	request.Header.Add("X-KSC-REQUEST-ID", uuid.New().Version().String())

	//处理返回结果
	client := &http.Client{}
	response, err := client.Do(request)
	if err != nil {
		klog.Errorln("client.Do(request) err:", err)
		err = nil
		return keyList, err
	}
	bt, err := ioutil.ReadAll(response.Body)
	if err != nil {
		klog.Errorln("ioutil.ReadAll(response.Body) err:", err)
		err = nil
		return keyList, err
	}
	json.Unmarshal(bt, &keyResult)
	defer response.Body.Close()
	return keyResult.KeySet, err
}

// 获取安全组列表信息
func GetSecuritys(userName, region string, securityIds []string) ([]aggregate.SecurityGroupSetData, error) {
	securityGroupResult := aggregate.SecurityGroupResult{}
	networkapi := fmt.Sprintf("http://networkapi.inner.%s/?Version=2016-03-04&Action=DescribeSecurityGroups", os.Getenv("GALAXY_SUB_DOMAIN")) //sdns.cqpcloud.cn
	if len(securityIds) <= 0 {
		return securityGroupResult.SecurityGroupSet, nil
	}
	for index, securityId := range securityIds {
		networkapi += fmt.Sprintf("&SecurityGroupId.%d=%s", index+1, securityId)
	}
	klog.Infoln("DEBUG - cloud products vm api  - ", networkapi)
	bt, err := GetByteFromUrl(networkapi, userName, region)
	if err != nil {
		klog.Errorln("GetByteFromUrl(networkapi, userName, region) err:", err)
		err = nil
		return securityGroupResult.SecurityGroupSet, err
	}
	//处理返回结果
	json.Unmarshal(bt, &securityGroupResult)
	return securityGroupResult.SecurityGroupSet, err
}

// 获取弹性IP信息
func GetEIPs(userName, region string, eips []string) (aggregate.EipData, error) {
	eipResult := aggregate.EipResult{}
	eip := aggregate.EipData{}
	networkapi := fmt.Sprintf("http://networkapi.inner.%s/?Version=2016-03-04&Action=DescribeAddresses", os.Getenv("GALAXY_SUB_DOMAIN")) //sdns.cqpcloud.cn
	if len(eips) <= 0 {
		return eip, nil
	}
	networkapi += fmt.Sprintf("&Filter.1.Name=network-interface-id")
	for index, eip := range eips {
		networkapi += fmt.Sprintf("&Filter.1.Value.%d=%s", index+1, eip)
	}
	klog.Infoln("DEBUG - cloud products vm api  - ", networkapi)
	bt, err := GetByteFromUrl(networkapi, userName, region)
	if err != nil {
		klog.Errorln("GetByteFromUrl(networkapi, userName, region) err:", err)
		err = nil
		return eip, err
	}
	//处理返回结果
	err = json.Unmarshal(bt, &eipResult)
	if err != nil {
		klog.Errorln("GetByteFromUrl(networkapi, userName, region) err:", err)
		err = nil
		return eip, err
	}
	if len(eipResult.AddressesSet) > 0 {
		eip = eipResult.AddressesSet[0]
	}

	return eip, err
}

// 获取容灾组列表信息
func GetDataGuards(userName, region string, dataGuard []aggregate.DataGuardSetData) ([]aggregate.DataGuardSetData, error) {
	securityGroupResult := aggregate.DataGuardResult{}
	dataGuardN := []aggregate.DataGuardSetData{}
	networkapi := fmt.Sprintf("http://ecs.inner.%s/?Action=DescribeDataGuardGroup&Version=2016-03-04", os.Getenv("GALAXY_SUB_DOMAIN")) //sdns.cqpcloud.cn
	if len(dataGuard) <= 0 {
		return dataGuardN, nil
	}
	for _, dataG := range dataGuard {
		networkapi = fmt.Sprintf("%s&DataGuardId=%s", networkapi, dataG.DataGuardId)
		klog.Infoln("DEBUG - cloud products vm api  - ", networkapi)
		bt, err := GetByteFromUrl(networkapi, userName, region)
		if err != nil {
			klog.Errorln("GetByteFromUrl(networkapi, userName, region) err:", err)
			err = nil
			return dataGuardN, err
		}
		//处理返回结果
		json.Unmarshal(bt, &securityGroupResult)
		dataGuardN = append(dataGuardN, securityGroupResult.DataGuardList...)
	}
	return dataGuardN, nil
}

// 获取本地盘列表信息
func GetLocalVolumes(userName, region, instanceId string) ([]aggregate.LocalVolumeSetData, error) {
	localVolumeResult := aggregate.LocalVolumeResult{}
	localVolumeL := []aggregate.LocalVolumeSetData{}
	networkapi := fmt.Sprintf("http://ecs.inner.%s/?Action=DescribeLocalVolumes&Version=2016-03-04", os.Getenv("GALAXY_SUB_DOMAIN")) //sdns.cqpcloud.cn
	if instanceId == "" {
		return localVolumeL, nil
	}
	networkapi = fmt.Sprintf("%s&InstanceId=%s", networkapi, instanceId)
	klog.Infoln("DEBUG - cloud products vm api  - ", networkapi)
	bt, err := GetByteFromUrl(networkapi, userName, region)
	if err != nil {
		klog.Errorln("GetByteFromUrl(networkapi, userName, region) err:", err)
		err = nil
		return localVolumeL, err
	}
	//处理返回结果
	json.Unmarshal(bt, &localVolumeResult)
	//dataGuardN = append(dataGuardN, localVolumeResult.LocalVolumeSetData...)

	return localVolumeResult.LocalVolumeSet, nil
}

// 获取镜像信息以及操作系统信息
func GetImages(userName, region, imageId string) ([]aggregate.ImageData, error) {
	imageResult := aggregate.ImageResult{}
	imageData := []aggregate.ImageData{}
	networkapi := fmt.Sprintf("http://ecs.inner.%s/?Action=DescribeImages&Version=2016-03-04", os.Getenv("GALAXY_SUB_DOMAIN")) //sdns.cqpcloud.cn
	if imageId == "" {
		return imageData, nil
	}
	networkapi = fmt.Sprintf("%s&ImageId=%s", networkapi, imageId)

	klog.Infoln("DEBUG - cloud products vm api  - ", networkapi)
	bt, err := GetByteFromUrl(networkapi, userName, region)
	if err != nil {
		klog.Errorln("GetByteFromUrl(networkapi, userName, region) err:", err)
		err = nil
		return imageData, err
	}
	//处理返回结果
	json.Unmarshal(bt, &imageResult)
	//dataGuardN = append(dataGuardN, localVolumeResult.LocalVolumeSetData...)

	return imageResult.ImagesSet, nil
}
func GetByteFromUrl(apiUrl, userName, region string) ([]byte, error) {
	// if len(keyids) <= 0 {
	// 	return keyResult.KeySet, nil
	// }
	// for index, keyid := range keyids {
	// 	networkapi += fmt.Sprintf("&KeyId.%d=%s", index+1, keyid)
	// }
	request, err := http.NewRequest("GET", apiUrl, nil)
	if err != nil {
		klog.Errorln("http.NewRequest err:", err)
		err = nil
		return []byte{}, err
	}
	request.Header.Add("X-KSC-ACCOUNT-ID", userName)
	request.Header.Add("X-KSC-REGION", region)
	request.Header.Add("Accept", "application/json")
	request.Header.Add("X-KSC-REQUEST-ID", uuid.New().Version().String())

	//处理返回结果
	client := &http.Client{}
	response, err := client.Do(request)
	if err != nil {
		klog.Errorln("client.Do(request) err:", err)
		err = nil
		return []byte{}, nil
	}
	bt, err := ioutil.ReadAll(response.Body)
	if err != nil {
		klog.Errorln("ioutil.ReadAll(response.Body) err:", err)
		err = nil
		return []byte{}, nil
	}
	defer response.Body.Close()
	return bt, err
}

func GetHostEntity(host string) (entity server.PhysicalServer, err error) {
	//aggHost := server.PhysicalHostData{}
	// hostData := DgraphService{
	// 	Code:  "hostname",
	// 	Value: "",
	// }
	// hostData.Value = host
	//[]model.HostData
	entity, err = serverdao.SelectServerInfo(host, "", 0)
	if err != nil && err != gorm.ErrRecordNotFound {
		klog.Errorln("serverdao.SelectServerInfo err:", err)
		err = nil
		return
	}
	err = nil
	// hostList, err := hostData.HostQuery()
	// if err != nil || len(hostList) < 1 {
	// 	return aggHost
	// }
	// aggHost = hostList[0]
	return
}

//curl -X GET -H "X-Auth-Token: d92195c970e64359acd5b8bbd24fe67c:6262a999044a4e2fa0e97aef96a53b17"  http://keystone.galaxy.cloud:35357/v2.0/users
//curl -X GET -H "X-Auth-Token: d92195c970e64359acd5b8bbd24fe67c:cbc36478b0bd8e67e89469c7749d4127"  http://keystone.galaxy.cloud:35357/v2.0/users
//curl -X GET -H "X-Auth-Token: 7a5e0892c33d4fbeaf2bdc1e0b8d9b2b:89a081b7e03c4755ac2a16a17276fc08"  http://keystone.galaxy.cloud:35357/v2.0/users
//curl -X GET -H "X-Auth-Token: 7a5e0892c33d4fbeaf2bdc1e0b8d9b2b:89a081b7e03c4755ac2a16a17276fc08"  http://keystone.galaxy.cloud:35357/v2.0/users

//curl -X GET 'http://ecs.inner.sdns.cqpcloud.cn/?Action=DescribeInstances&Version=2016-03-04' -H 'X-KSC-ACCOUNT-ID: 180000000' -H 'X-KSC-REGION: cn-shanghai-2'  -H 'Accept: application/json' -H 'X-KSC-REQUEST-ID: 6cbdfcb0-f62a-46a9-8284-1e8543810547'
//curl -X GET 'http://ecs.inner.sdns.cqpcloud.cn/?Action=DescribeInstances&Version=2016-03-04&MaxResults=100' -H 'X-KSC-ACCOUNT-ID: 180000000' -H 'X-KSC-REGION: cn-shanghai-2'  -H 'Accept: application/json' -H 'X-KSC-REQUEST-ID: 6cbdfcb0-f62a-46a9-8284-1e8543810547'
//curl -X GET 'http://ecs.inner.sdns.cqpcloud.cn/?Action=DescribeImages&Version=2016-03-04' -H 'X-KSC-ACCOUNT-ID: 180000000' -H 'X-KSC-REGION: cn-shanghai-2'  -H 'Accept: application/json' -H 'X-KSC-REQUEST-ID: 6cbdfcb0-f62a-46a9-8284-1e8543810547'
//curl -X GET 'http://10.177.152.9/?Action=DescribeInstances&Version=2016-03-04&InstanceId.1=0378c058-ffd0-4d0e-bd69-a0500e7d298f' -H 'X-KSC-ACCOUNT-ID: 7a5e0892c33d4fbeaf2bdc1e0b8d9b2b' -H 'X-KSC-REGION: cn-shanghai-2'  -H 'Accept: application/json' -H 'X-KSC-REQUEST-ID: 6cbdfcb0-f62a-46a9-8284-1e8543810547'
//curl -X GET 'http://10.177.152.9/?Action=DescribeInstances&Version=2016-03-04&InstanceId.1=0378c058-ffd0-4d0e-bd69-a0500e7d298f' -H 'X-KSC-ACCOUNT-ID: 180000000' -H 'X-KSC-REGION: cn-shanghai-2'  -H 'Accept: application/json' -H 'X-KSC-REQUEST-ID: 6cbdfcb0-f62a-46a9-8284-1e8543810547'
// const TokenID = "d92195c970e64359acd5b8bbd24fe67c:6262a999044a4e2fa0e97aef96a53b17"
//curl -X GET 'http://ecs.inner.sdns.cqpcloud.cn/?Action=DescribeDataGuardGroup&Version=2016-03-04' -H 'X-KSC-ACCOUNT-ID: 180000000' -H 'X-KSC-REGION: cn-shanghai-2'  -H 'Accept: application/json' -H 'X-KSC-REQUEST-ID: 6cbdfcb0-f62a-46a9-8284-1e8543810547'
//curl -X GET 'http://sks.inner.sdns.cqpcloud.cn/?Version=2015-11-01&Action=DescribeKeys&KeyId.1=38796bce-913d-40d6-831c-62ff87e87e27&KeyId.2=885eecfb-3d3e-4d3a-96da-4d76de49e7fb' -H 'X-KSC-ACCOUNT-ID: 180000053' -H 'X-KSC-REGION: cn-shanghai-2'  -H 'Accept: application/json' -H 'X-KSC-REQUEST-ID: 6cbdfcb0-f62a-46a9-8284-1e8543810547'
//curl -X GET 'http://networkapi.inner.sdns.cqpcloud.cn/?Version=2016-03-04&Action=DescribeSecurityGroups&SecurityGroupId.1=3619bd33-2f36-411c-89d1-d47fb6f10798' -H 'X-KSC-ACCOUNT-ID: 180000053' -H 'X-KSC-REGION: cn-shanghai-2'  -H 'Accept: application/json' -H 'X-KSC-REQUEST-ID: 6cbdfcb0-f62a-46a9-8284-1e8543810547'
//curl -X GET 'http://ecs.inner.sdns.cqpcloud.cn/?Action=DescribeLocalVolumes&Version=2016-03-04&InstanceId=05300b2e-64b7-44a6-889c-ae3e121a5985' -H 'X-KSC-ACCOUNT-ID: 180000000' -H 'X-KSC-REGION: cn-shanghai-2'  -H 'Accept: application/json' -H 'X-KSC-REQUEST-ID: 6cbdfcb0-f62a-46a9-8284-1e8543810547'
//curl -X GET 'http://ecs.inner.sdns.cqpcloud.cn/?Action=DescribeLocalVolumes&Version=2016-03-04&InstanceId=7bc84d0c-25d0-4e8b-b952-ae3303893630' -H 'X-KSC-ACCOUNT-ID: 180000000' -H 'X-KSC-REGION: cn-shanghai-2'  -H 'Accept: application/json' -H 'X-KSC-REQUEST-ID: 6cbdfcb0-f62a-46a9-8284-1e8543810547'
// // ServiceClient returns a generic service client for use in tests.
// func ServiceClient() *gophercloud.ServiceClient {
// 	return &gophercloud.ServiceClient{
// 		ProviderClient: &gophercloud.ProviderClient{TokenID: TokenID},
// 		Endpoint:       "http://10.177.147.1:35357/v2.0/",
// 	}
// }
// listOpts := &tenants.ListOpts{
// 	Limit: 2,
// }

//pager := users.List(ServiceClient())                                //, "7a5e0892c33d4fbeaf2bdc1e0b8d9b2b")
//r := users.Get(h.Novaclient, "89a081b7e03c4755ac2a16a17276fc08") //, "")
//http://keystone.galaxy.cloud:35357/v2.0/users/78cb1d7a87a247689f9015d937832e79
//klog.Info("rrrrrrrrrrrrrr:", pager)
//klog.Info("rrrrrrrrrrrrrr:", &r)
// // page for fetch serverList
// err := pager.EachPage(func(page pagination.Page) (bool, error) {
// 	serverList, err := users.ExtractUsers(page)
// 	if err != nil {
// 		klog.Info("some wrong:", err.Error())
// 		return false, err
// 	}
// 	for _, s := range serverList {
// 		klog.Info(s)
// 	}
// 	return true, nil
// })
// count := 0
// // klog.Info("h.IdentityClient.Endpoint:", h.IdentityClient.Endpoint)
// // klog.Info("h.Novaclient.Endpoint:", h.Novaclient.Endpoint)
// h.IdentityClient.Endpoint = "http://10.177.147.1:35357/v2.0/"
// err := users.List(h.IdentityClient).EachPage(func(page pagination.Page) (bool, error) {
// 	count++
// 	serverList, err := users.ExtractUsers(page)
// 	if err != nil {
// 		klog.Info("some wrong:", err.Error())
// 		return false, err
// 	}
// 	for _, s := range serverList {
// 		klog.Info(s)
// 	}
// 	return true, nil
// })
//curl -X GET 'http://10.177.152.9/?Action=DescribeInstanceTypeConfigs&Version=2016-03-04&Filter.1.Name=availability-zone&Filter.1.Value.1=cn-shanghai-2' -H 'X-KSC-ACCOUNT-ID: 180000000' -H 'X-KSC-REGION: cn-shanghai-2'  -H 'Accept: application/json' -H 'X-KSC-REQUEST-ID: 6cbdfcb0-f62a-46a9-8284-1e8543810547'

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/pkg/service/kgwResourcePool.go
```golang
package service

import (
	"luban-cmdb-api/pkg/models/netPoolModel"
)

// GetXGWPoolMap 获取KGW资源池列表
func GetKGWPoolMap() (map[string]netPoolModel.NetWorkResource, error) {

	netPoolList, err := getNetworkPool() //获取所有网络资源池信息
	if err != nil {
		return nil, err
	}

	//资源池有两个，其中Hosts字段会出现重复值，所以这里使用一个map类型去重，Hosts字段中的的每个值都要获取到
	kgwPoolMap := make(map[string]netPoolModel.NetWorkResource)
	for i := range netPoolList {
		if netPoolList[i].PoolType == "KGW" {
			for j := range netPoolList[i].Hosts {
				kgwPoolMap[netPoolList[i].Hosts[j]] = netPoolList[i]
			}
		}
	}
	//klog.Infof("kgw resource pool: %+v", kgwPoolMap)

	return kgwPoolMap, nil
}

// GetTGWPoolMap 获取TGW资源池列表
func GetTGWPoolMap() (map[string]netPoolModel.NetWorkResource, error) {
	netPoolList, err := getNetworkPool() //获取所有网络资源池信息
	if err != nil {
		return nil, err
	}

	//资源池有两个，其中Hosts字段会出现重复值，所以这里使用一个map类型去重，Hosts字段中的的每个值都要获取到
	tgwPoolMap := make(map[string]netPoolModel.NetWorkResource)
	for i := range netPoolList {
		if netPoolList[i].PoolType == "TGW" {
			for j := range netPoolList[i].Hosts {
				tgwPoolMap[netPoolList[i].Hosts[j]] = netPoolList[i]
			}
		}
	}
	//klog.Infof("kgw resource pool: %+v", kgwPoolMap)

	return tgwPoolMap, nil
}

// GetPGWPoolMap 获取TGW资源池列表
func GetPGWPoolMap() (map[string]netPoolModel.NetWorkResource, error) {
	netPoolList, err := getNetworkPool() //获取所有网络资源池信息
	if err != nil {
		return nil, err
	}

	//资源池有两个，其中Hosts字段会出现重复值，所以这里使用一个map类型去重，Hosts字段中的的每个值都要获取到
	pgwPoolMap := make(map[string]netPoolModel.NetWorkResource)
	for i := range netPoolList {
		if netPoolList[i].PoolType == "PGW" {
			for j := range netPoolList[i].Hosts {
				pgwPoolMap[netPoolList[i].Hosts[j]] = netPoolList[i]
			}
		}
	}
	//klog.Infof("kgw resource pool: %+v", kgwPoolMap)

	return pgwPoolMap, nil
}

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/pkg/service/deviceroom.go
```golang
package service

import (
	"fmt"
	"luban-cmdb-api/pkg/dao/basic"

	"gorm.io/gorm"

	//dgApi "github.com/dgraph-io/dgo/v200/protos/api"
	"luban-cmdb-api/pkg/dao/cabidao"
	"luban-cmdb-api/pkg/dao/contact"
	contactdao "luban-cmdb-api/pkg/dao/contact"
	deviceroomdao "luban-cmdb-api/pkg/dao/deviceroom"
	contactservice "luban-cmdb-api/pkg/service/contact"

	"k8s.io/klog/v2"

	//"luban-cmdb-api/pkg/models"
	"luban-cmdb-api/pkg/models/deviceroom"
)

type DeviceRoomService struct {
}

type MatchQueryParameter struct {
	ComputerRoomName      string
	ComputerRoomCode      string
	DeviceRoomCode        string
	DeviceRoomName        string
	DeviceRoomId          int
	AzCode                string
	RegionCode            string
	ExactComputerRoomCode []string
	ExactAzCode           []string
}

type ExactQueryParameter struct {
	ComputerRoomId   []string
	ComputerRoomCode []string
	DeviceRoomCode   []string
	DeviceRoomId     []string
	AzCode           []string
	RegionCode       []string
}

func NewDeviceRoomService() *DeviceRoomService {
	return &DeviceRoomService{}
}

func (svc *DeviceRoomService) QueryById(id int) deviceroom.RoomFullInfo2 {

	dr, err := deviceroomdao.GetDeviceRoom(id)
	if err != nil || dr.Uid <= 0 {
		klog.Errorf("Can't query target id %d, Error: %s", id, err)
		return dr
	}
	ct, err := contactservice.GetDeviceRoomContacts(id)
	if err != nil {
		klog.Errorf("query deviceroom %d, contact error %s ", id, err)
		return dr
	}
	dr.DeviceRoomMainContact.Uid = ct.Main.Id
	dr.DeviceRoomMainContact.DeviceRoomContactName = ct.Main.Name
	dr.DeviceRoomMainContact.DeviceRoomContactPhoneNumber = ct.Main.Phone
	//其他联系人
	for _, o := range ct.Others {
		ox := deviceroom.Contact{
			Uid:                          o.Id,
			DeviceRoomContactName:        o.Name,
			DeviceRoomContactPhoneNumber: o.Phone,
		}
		dr.DeviceRoomOtherContacts = append(dr.DeviceRoomOtherContacts, ox)
	}
	return dr
}

func (svc *DeviceRoomService) Update(room *deviceroom.DeviceRoom, updater string) error {
	klog.Infof("update device room: %+v", room)
	if room.Uid == 0 {
		return fmt.Errorf("找不到编辑的房间")
	}
	findRoomInfo, err := deviceroomdao.GetDeviceRoom(room.Uid)
	if err != nil {
		return err
	}
	if findRoomInfo.Uid <= 0 {
		return fmt.Errorf("找不到编辑的房间")
	}

	//房间信息只修改描述字段，如果描述变更则需要修改room表
	if findRoomInfo.DeviceRoomDesc != room.DeviceRoomDesc {
		err = deviceroomdao.UpdateRoom(deviceroomdao.DeviceRoom{
			Id:       room.Uid,
			RoomDesc: room.DeviceRoomDesc,
			Updater:  updater,
		})
		if err != nil {
			return err
		}
	}

	//修改联系人
	err = contactservice.UpdateByType(room.Uid, contactdao.TYPE_DEVICE, room.DeviceRoomMainContact, room.DeviceRoomOtherContacts, updater)
	if err != nil {
		return err
	}
	return nil
}

func (svc *DeviceRoomService) Create(room *deviceroom.DeviceRoom) error {
	klog.Infof("create device room: %+v", room)
	//duplicateData, err := svc.QueryIdsByNameOrCode(room.DeviceRoomName, room.DeviceRoomCode)

	hasDr, err := deviceroomdao.GetByCodeOrName(room.DeviceRoomCode, room.DeviceRoomName)
	if err != nil {
		return err
	}
	if hasDr.Id > 0 {
		return fmt.Errorf("房间名称或代号重复，请更换后重试")
	}

	computerRoomId := room.DeviceRoomComputerRoomId
	if computerRoomId == 0 {
		return fmt.Errorf("房间的机房不能为空")
	}
	az, err := basic.GetAz(basic.Az{
		AzCode: room.AzCode,
	})
	if err != nil {
		return err
	}
	if az.Id <= 0 {
		return fmt.Errorf("az信息错误，请检查后添加")
	}
	region, err := basic.GetRegion(basic.Region{
		RegionCode: room.RegionCode,
	})
	if err != nil {
		return err
	}
	if region.Id <= 0 {
		return fmt.Errorf("region信息错误，请检查后添加")
	}

	//插入数据
	dr := deviceroomdao.DeviceRoom{
		RoomName: room.DeviceRoomName,
		RoomCode: room.DeviceRoomCode,
		RoomDesc: room.DeviceRoomDesc,
		AzId:     az.Id,
		RegionId: region.Id,
		LabId:    room.DeviceRoomComputerRoomId,
		Updater:  room.DeviceRoomCreator,
		Creator:  room.DeviceRoomCreator,
	}

	drId, err := deviceroomdao.AddDeviceRoom(dr)
	if err != nil {
		return err
	}
	//组装联系人
	var cs []contact.Contact
	cs = append(cs, contact.Contact{
		Name:     room.DeviceRoomMainContact.DeviceRoomContactName,
		Phone:    room.DeviceRoomMainContact.DeviceRoomContactPhoneNumber,
		TypeId:   drId,
		TypeName: contact.TYPE_DEVICE,  //类型为房间
		Level:    contact.CONTACT_MAIN, //级别为主要联系人
		Creator:  room.DeviceRoomCreator,
		Updater:  room.DeviceRoomCreator,
	})
	for _, c := range room.DeviceRoomOtherContacts {
		cs = append(cs, contact.Contact{
			Name:     c.DeviceRoomContactName,
			Phone:    c.DeviceRoomContactPhoneNumber,
			TypeId:   drId,
			TypeName: contact.TYPE_DEVICE,   //类型为房间
			Level:    contact.CONTACT_OTHER, //级别为次要联系人
			Creator:  room.DeviceRoomCreator,
			Updater:  room.DeviceRoomCreator,
		})
	}

	err = contact.BatchAddContact(cs)
	if err != nil {
		return err
	}

	return nil
}

func (svc *DeviceRoomService) DeleteByIds(ids []int, updater string) error {
	if len(ids) == 0 {
		return nil
	}

	//检查是否有机柜
	cc, err := cabidao.CountCabinetsByRoomIds(ids)
	if err != nil {
		return err
	}

	for _, c := range cc {
		if c.CobinetsTotal > 0 {
			return fmt.Errorf("房间下仍有机柜未删除，请删除机柜后重试操作！")
		}
	}

	//删除房间
	err = deviceroomdao.DelDeviceRoom(ids, updater)
	if err != nil {
		return err
	}
	//删除联系人
	err = contactdao.DelContactByType(ids, contactdao.TYPE_DEVICE, updater)
	if err != nil {
		return err
	}

	return nil
}

func (svc *DeviceRoomService) DeleteById(id int) error {
	return svc.DeleteByIds([]int{id}, "")
}

func (svc *DeviceRoomService) QueryFullInfoByPage(page int, size int, queryParameter MatchQueryParameter) (deviceroom.PageDeviceRoomFullInfo2, error) {
	condition := make(map[string]interface{})
	if len(queryParameter.ExactComputerRoomCode) > 0 {
		condition["lab_code"] = queryParameter.ExactComputerRoomCode
	}
	if len(queryParameter.ExactAzCode) > 0 {
		condition["az_code"] = queryParameter.ExactAzCode
	}
	if queryParameter.RegionCode != "" {
		condition["region_code"] = queryParameter.RegionCode
	}
	if queryParameter.ComputerRoomName != "" {
		condition["lab_name"] = queryParameter.ComputerRoomName
	}
	if queryParameter.DeviceRoomCode != "" {
		condition["room_code"] = queryParameter.DeviceRoomCode
	}
	if queryParameter.DeviceRoomId != 0 {
		condition["id"] = queryParameter.DeviceRoomId
	}
	if queryParameter.DeviceRoomName != "" {
		condition["room_name"] = queryParameter.DeviceRoomName
	}
	pageResult := deviceroom.PageDeviceRoomFullInfo2{
		Page:  page,
		Size:  size,
		Total: 0,
		Rooms: []deviceroom.RoomFullInfo2{},
	}
	drs, count, err := deviceroomdao.PageQueryDeviceRoom(condition, page, size)
	if err != nil {
		return pageResult, err
	}
	pageResult.Total = count

	drs, err = svc.mergeRoomInfo(drs)
	if err != nil {
		return pageResult, err
	}
	pageResult.Rooms = drs
	return pageResult, nil
}

func (svc *DeviceRoomService) QueryWithExactCondition(param ExactQueryParameter) ([]deviceroom.RoomFullInfo2, error) {
	condition := make(map[string]interface{})
	if len(param.ComputerRoomId) > 0 {
		condition["lab_id"] = param.ComputerRoomId
	}
	if len(param.ComputerRoomCode) > 0 {
		condition["lab_code"] = param.ComputerRoomCode
	}
	if len(param.DeviceRoomCode) > 0 {
		condition["room_code"] = param.DeviceRoomCode
	}
	if len(param.DeviceRoomId) > 0 {
		condition["id"] = param.DeviceRoomId
	}
	if len(param.AzCode) > 0 {
		condition["az_code"] = param.AzCode
	}
	if len(param.RegionCode) > 0 {
		condition["region_code"] = param.RegionCode
	}
	drs, err := deviceroomdao.QueryDeviceRoom(condition)
	if err != nil {
		return drs, err
	}
	drs, err = svc.mergeRoomInfo(drs)
	return drs, err
}

//补全room其他信息，机柜/联系人等
func (svc *DeviceRoomService) mergeRoomInfo(drs []deviceroom.RoomFullInfo2) ([]deviceroom.RoomFullInfo2, error) {
	//获取房间对应机柜机架信息
	var drids []int
	for _, v := range drs {
		drids = append(drids, v.Uid)
	}

	if len(drids) > 0 {
		//查询机柜信息等
		cabinetCounters, err := cabidao.CountCabinetsByRoomIds(drids)
		if err != nil && err != gorm.ErrRecordNotFound {
			return drs, err
		}
		var cabinetCountMap = make(map[int]cabidao.CabinetsCounter)
		for _, c := range cabinetCounters {
			cabinetCountMap[c.RoomId] = c
		}

		//联系人
		contactMap, err := contactservice.FindDeviceRoomContacts(drids)
		if err != nil {
			return drs, err
		}

		//循环遍历deviceroom对象，赋值机柜信息等
		for i, v := range drs {
			c, ok := cabinetCountMap[v.Uid]
			if ok {
				v.CabinetNum = c.CobinetsTotal
				v.RackNum = c.RacksTotal
				v.UsedUNum = c.UsedUnitCount
				v.UnusedUNum = c.UnusedUnitCount
			}

			//将数据库中获取到的联系人信息
			contactInfo, ok := contactMap[v.Uid]
			if ok {
				//主要联系人
				v.DeviceRoomMainContact = deviceroom.Contact{
					Uid:                          contactInfo.Main.Id,
					DeviceRoomContactName:        contactInfo.Main.Name,
					DeviceRoomContactPhoneNumber: contactInfo.Main.Phone,
				}
				//次要联系人
				for _, co := range contactInfo.Others {
					v.DeviceRoomOtherContacts = append(v.DeviceRoomOtherContacts, deviceroom.Contact{
						Uid:                          co.Id,
						DeviceRoomContactName:        co.Name,
						DeviceRoomContactPhoneNumber: co.Phone,
					})
				}
			}
			drs[i] = v
		}
	}
	return drs, nil
}

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/pkg/service/switch.go
```golang
package service

import (
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"luban-cmdb-api/pkg/dao/basic"
	"luban-cmdb-api/pkg/dao/cabidao"
	"luban-cmdb-api/pkg/dao/deviceroom"
	"luban-cmdb-api/pkg/dao/lab"
	"luban-cmdb-api/pkg/dao/rackdao"
	"luban-cmdb-api/pkg/dao/switchdao"
	"luban-cmdb-api/pkg/gredis"
	switchMachine "luban-cmdb-api/pkg/models/switch"
	"luban-cmdb-api/pkg/utils"
	"regexp"
	"strconv"
	"strings"
	"sync"
	"time"

	"k8s.io/klog/v2"

	"github.com/dgraph-io/dgo/v200"
)

type SwitchService struct {
	dgraphClient *dgo.Dgraph
}

func NewSwitchService(dgraphClient *dgo.Dgraph) *SwitchService {
	return &SwitchService{
		dgraphClient: dgraphClient,
	}
}

func (s *SwitchService) GetSwitchSales() []string {
	return switchdao.GetAllSystemSales()
}

func (s *SwitchService) GetSwitchInfo(id int) (switchMachine.SwitchNew, error) {
	switchInfo, err := switchdao.SelectSwitchInfoById(id)
	if err != nil {
		return switchMachine.SwitchNew{}, err
	}
	var snmpCpus []switchMachine.SwitchCpu
	ctx, cancel := context.WithTimeout(context.Background(), 2*time.Second)
	defer cancel()
	rs, err := gredis.HGet(ctx, gredis.SnmpSwitchCpusKey, switchInfo.Sn)
	if err != nil {
		return switchInfo, nil
	}
	err = json.Unmarshal([]byte(rs), &snmpCpus)
	if err != nil {
		return switchInfo, nil
	}
	var cpuMap = make(map[string]int)
	for _, cpu := range snmpCpus {
		cpuMap[cpu.CpuType]++
	}
	for k, v := range cpuMap {
		cpu := switchMachine.CPU{
			CPUType:   k,
			CoreCount: v,
		}
		switchInfo.Cpu = append(switchInfo.Cpu, cpu)
	}
	return switchInfo, err
}
func (s *SwitchService) GetSwitchInfoByName(name string) (switchMachine.SwitchNew, error) {
	switchInfo, err := switchdao.SelectSwitchInfoByName(name)
	if err != nil {
		return switchMachine.SwitchNew{}, err
	}
	return switchInfo, err
}

func (s *SwitchService) GetSwitchList(params switchMachine.SwitchListParams) (result switchMachine.SwitchListResult, err error) {
	result.PageSize = params.PageSize
	result.PageNo = params.PageNo
	if params.PageNo > 0 {
		params.PageNo -= 1
	} else {
		return result, errors.New("invalid pageNo")
	}
	switchList, totalCount, err := switchdao.SelectSwitchListByCons(params)
	if err != nil {
		return result, err
	}

	interfaceCount, err := switchdao.GetSwitchInterfaceCount()
	klog.Info("interfaceCount:", interfaceCount)
	interfaceCountMap := make(map[string]int)
	for _, interfaces := range interfaceCount {
		interfaceCountMap[interfaces.Sn] = int(interfaces.InterfaceCount)
	}
	for k, v := range switchList {
		switchList[k].InterfaceCount = interfaceCountMap[v.Sn]
	}

	//var wg = &sync.WaitGroup{}
	//for i, _ := range switchList {
	//	wg.Add(1)
	//	go checkRunStatus(wg,&switchList[i],3,10*time.Millisecond,300*time.Millisecond)
	//}
	//wg.Wait()
	//if len(params.RunStatus) != 0 {
	//	reSwitchList := make([]switchMachine.SwitchNew,0)
	//	for _, switchNew := range switchList {
	//		if filterSlice(switchNew.RunStatus,params.RunStatus) {
	//			reSwitchList = append(reSwitchList,switchNew)
	//		}
	//	}
	//	switchList = reSwitchList
	//}
	//totalCount = len(switchList)
	//if params.PageNo != 0 || params.PageSize != 0 {
	//	offset := params.PageNo * params.PageSize
	//	endIndex := params.PageSize + offset
	//	if offset > len(switchList) {
	//		return result,nil
	//	}
	//	if endIndex > len(switchList) {
	//		endIndex = len(switchList)
	//	}
	//	switchList = switchList[offset:endIndex]
	//}
	result.TotalCount = totalCount
	result.DataList = switchList
	return result, err
}

func checkRunStatus(wg *sync.WaitGroup, machine *switchMachine.SwitchNew, pCount int, interval, timeout time.Duration) {
	if utils.PingHost(machine.ManagementIP, pCount, interval, timeout) {
		machine.RunStatus = "up"
	} else {
		machine.RunStatus = "down"
	}
	wg.Done()
}

func filterSlice(state string, arr []string) bool {
	for _, s := range arr {
		if state == s {
			return true
		}
	}
	return false
}

func (s *SwitchService) DeleteSwitchInfo(params switchMachine.SwitchDeleteParams) error {
	_, err := switchdao.DeleteSwitchInfoByIds(params.Ids)
	return err
}

// TODO: 需要完成对插入Switch的Name唯一性的判断、不确定需求（待完成）
func (s *SwitchService) AddSwitchInfo(params switchMachine.SwitchAddParams) error {
	// 先检索，对有对up、down的边的数据将name 转化为 uid、然后在进行创建（记得将name清除掉）
	//mappings := modelToMapping(params.Switchs)
	// name 转 uid 也许会有name不存在的情况 也许后续会将该部分改为sn检索
	//err := checkSwitchList(params.Switchs)
	//if err != nil {
	//	return err
	//}
	return switchdao.InsertSwitchList(params.Switchs)
}

func (s *SwitchService) UpdateSwitchInfo(params switchMachine.MysqlSwitch) error {
	//fmt.Println(params.i)
	if params.Uid == 0 && params.Sn == "" {
		return errors.New("if you wanna modify switch, id or sn must given one")
	}
	var err error
	//if params.RackId > 0 {
	//	err = switchdao.UpdateSwitchInfoByTransaction(params)
	//} else {
	//	err = switchdao.UpdateSwitchInfo(params)
	//}
	err = switchdao.UpdateSwitchInfoByTransaction(params)
	return err
}

func mappingToModel(mappings []switchMachine.SwitchMapping) []switchMachine.Switch {
	var ss []switchMachine.Switch
	for _, mapping := range mappings {
		ss = append(ss, switchMachine.Switch{
			Uid:                mapping.Uid,
			SwitchName:         mapping.SwitchName,
			AssetNumber:        mapping.AssetNumber,
			RunStatus:          mapping.RunStatus,
			Sn:                 mapping.Sn,
			Role:               mapping.Role,
			UnitNumber:         mapping.UnitNumber,
			SwitchType:         mapping.SwitchType,
			ManagementIP:       mapping.ManagementIP,
			OutBandIP:          mapping.OutBandIP,
			SwitchManufacturer: mapping.SwitchManufacturer,
			//MaintenanceDue:     mapping.MaintenanceDue,
			Maintainer: mapping.Maintainer,
			//CreateTime:         mapping.CreateTime,
			PackForwardingRate: mapping.PackForwardingRate,
			SwapMem:            mapping.SwapMem,
			SlotCount:          mapping.SlotCount,
			SwapSlotCount:      mapping.SwapSlotCount,
			SwitchNo:           mapping.SwitchNo,
			Power:              mapping.Power,
			WorkRate:           mapping.WorkRate,
			Label:              mapping.Label,
			Description:        mapping.Description,
			SwitchRegionName:   mapping.SwitchRegionName,
			SwitchRegionCode:   mapping.SwitchRegionCode,
			SwitchAzName:       mapping.SwitchAzName,
			SwitchAzCode:       mapping.SwitchAzCode,
			SwitchLabName:      mapping.SwitchLabName,
			SwitchLabCode:      mapping.SwitchLabCode,
			SwitchRackName:     mapping.SwitchRackName,
			SwitchRackCode:     mapping.SwitchRackCode,
			SwitchRoomCode:     mapping.SwitchRoomCode,
			SwitchRoomName:     mapping.SwitchRoomName,
			SwitchCabintCode:   mapping.SwitchCabintCode,
			SwitchCabintName:   mapping.SwitchCabintName,
			UplinkSwitch:       mapping.UplinkSwitch,
			DownLinkSwitch:     mapping.DownLinkSwitch,
		})
	}
	return ss
}

func modelToMapping(ss []switchMachine.Switch) []switchMachine.SwitchMapping {
	var mappings []switchMachine.SwitchMapping
	for _, s := range ss {
		mappings = append(mappings, switchMachine.SwitchMapping{
			Uid:                s.Uid,
			SwitchName:         s.SwitchName,
			AssetNumber:        s.AssetNumber,
			RunStatus:          s.RunStatus,
			Sn:                 s.Sn,
			Role:               s.Role,
			UnitNumber:         s.UnitNumber,
			SwitchType:         s.SwitchType,
			ManagementIP:       s.ManagementIP,
			OutBandIP:          s.OutBandIP,
			SwitchManufacturer: s.SwitchManufacturer,
			//MaintenanceDue:     s.MaintenanceDue,
			Maintainer: s.Maintainer,
			//CreateTime:         s.CreateTime,
			PackForwardingRate: s.PackForwardingRate,
			SwapMem:            s.SwapMem,
			SlotCount:          s.SlotCount,
			SwapSlotCount:      s.SwapSlotCount,
			SwitchNo:           s.SwitchNo,
			Power:              s.Power,
			WorkRate:           s.WorkRate,
			Label:              s.Label,
			Description:        s.Description,
			SwitchRegionName:   s.SwitchRegionName,
			SwitchRegionCode:   s.SwitchRegionCode,
			SwitchAzName:       s.SwitchAzName,
			SwitchAzCode:       s.SwitchAzCode,
			SwitchLabName:      s.SwitchLabName,
			SwitchLabCode:      s.SwitchLabCode,
			SwitchRackName:     s.SwitchRackName,
			SwitchRackCode:     s.SwitchRackCode,
			SwitchRoomCode:     s.SwitchRoomCode,
			SwitchRoomName:     s.SwitchRoomName,
			SwitchCabintCode:   s.SwitchCabintCode,
			SwitchCabintName:   s.SwitchCabintName,
			UplinkSwitch:       s.UplinkSwitch,
			DownLinkSwitch:     s.DownLinkSwitch,
		})
	}
	return mappings
}

func checkSwitchList(switchList []switchMachine.MysqlSwitch) error {
	var err error
	for _, swc := range switchList {
		if swc.Name == "" {
			err = errors.New(fmt.Sprintf("交换机名称不可缺失"))
			return err
		}
		if swc.Sn == "" {
			err = errors.New(fmt.Sprintf("交换机SN不可缺失"))
			return err
		}
		if swc.RegionId == 0 {
			err = errors.New(fmt.Sprintf("交换机所属区域ID不可缺失"))
			return err
		}
	}
	return err
}

func (s *SwitchService) SwitchOverview(regionCode, azCode string) (switchMachine.SwitchOverview, error) {
	var (
		err          error
		sum          int64
		downCount    int64
		upCount      int64
		ptoCount     int64
		pto1sCount   int64
		pto3sCount   int64
		locationList []switchMachine.OverviewSlot
		overview     switchMachine.SwitchOverview
	)
	cons := switchMachine.MysqlSwitch{}
	if regionCode != "" && regionCode != "all" {
		region, err := basic.GetRegion(basic.Region{RegionCode: regionCode})
		if err != nil {
			return overview, errors.New("区域不存在")
		}
		cons.RegionId = region.Id

	}
	if azCode != "" && azCode != "all" {
		az, err := basic.GetAz(basic.Az{AzCode: azCode})
		if err != nil {
			return overview, errors.New("可用区不存在")
		}
		cons.AzId = az.Id
	}

	//统计运行状态
	if sum, err = switchdao.CountStateOverview(cons); err != nil {
		return overview, err
	}
	cons.RunStatus = "up"
	if upCount, err = switchdao.CountStateOverview(cons); err != nil {
		return overview, err
	}
	downCount = sum - upCount

	//统计维保状态
	cons.RunStatus = ""
	now := time.Now()
	cons.MaintenanceDue = now
	if ptoCount, err = switchdao.CountMaintenanceDueOverview(cons, "insured"); err != nil {
		return overview, err
	}
	//cons.MaintenanceDue = now.AddDate(0, 1, 0)
	if pto1sCount, err = switchdao.CountMaintenanceDueOverview(cons, "insured1m"); err != nil {
		return overview, err
	}
	//cons.MaintenanceDue = now.AddDate(0, 3, 0)
	if pto3sCount, err = switchdao.CountMaintenanceDueOverview(cons, "insured3m"); err != nil {
		return overview, err
	}

	//统计分布状态
	if locationList, err = switchdao.CountLocationOverview(regionCode, azCode); err != nil {
		return overview, err
	}

	//整合返回值
	overview.SwitchStateOverview = []switchMachine.OverviewSlot{
		switchMachine.OverviewSlot{
			Code:  "TotalCount",
			Name:  "总数量",
			Count: sum,
			Unit:  "个",
		},
		switchMachine.OverviewSlot{
			Code:  "up",
			Name:  "监控中",
			Count: upCount,
			Unit:  "个",
		},
		switchMachine.OverviewSlot{
			Code:  "down",
			Name:  "监控异常",
			Count: downCount,
			Unit:  "个",
		},
	}
	overview.SwitchMaintenanceOverview = []switchMachine.OverviewSlot{
		switchMachine.OverviewSlot{
			Code:  "insured",
			Name:  "已过保",
			Count: ptoCount,
			Unit:  "个",
		},
		switchMachine.OverviewSlot{
			Code: "insured1m",
			Name: "一个月内过保",
			//Count: pto1sCount - ptoCount,
			Count: pto1sCount,
			Unit:  "个",
		},
		switchMachine.OverviewSlot{
			Code: "insured3m",
			Name: "三个月内过保",
			//Count: pto3sCount - ptoCount,
			Count: pto3sCount,
			Unit:  "个",
		},
	}
	var distributed = make([]switchMachine.LocationOverView, len(locationList))
	for i, slot := range locationList {
		distributed[i] = switchMachine.LocationOverView{
			Name:        slot.Name,
			Region:      slot.Region,
			Az:          slot.Az,
			Distributed: []switchMachine.OverviewSlot{slot},
		}
	}
	overview.SwitchLocationOverview = distributed

	return overview, nil
}

func XlsToSwitch(xlsMap []map[string]string, userName string) (switchList []switchMachine.MysqlSwitch, err error) {
	for _, m := range xlsMap {
		switchInfo := switchMachine.MysqlSwitch{}
		//验证名称
		if name, ok := m["name"]; !ok || name == "" {
			return nil, errors.New(fmt.Sprintf("%s: 名称不可为空", switchInfo.Name))
		} else {
			switchInfo.Name = name
		}
		//验证sn
		if sn, ok := m["sn"]; !ok || sn == "" {
			return nil, errors.New(fmt.Sprintf("%s: Sn不可为空", switchInfo.Name))
		} else if len(m["sn"]) > 20 {
			return nil, errors.New("sn is too long. must be less than or equal to 20")
		} else {
			switchInfo.Sn = sn
		}
		//验证region
		if regionName, ok := m["regionName"]; !ok || regionName == "" {
			return nil, errors.New(fmt.Sprintf("%s: 所属区域不可为空", switchInfo.Name))
		} else {
			var cons = basic.Region{RegionName: regionName}
			region, err := basic.GetRegion(cons)
			if err != nil {
				return nil, errors.New(fmt.Sprintf("%s: '所属区域查询失败，err: %s'", switchInfo.Name, err.Error()))
			}
			switchInfo.RegionId = region.Id
		}
		//验证az
		if azName, ok := m["azName"]; !ok || azName == "" {
			return nil, errors.New(fmt.Sprintf("%s: 所属可用区不可为空", switchInfo.Name))
		} else {
			az, err := basic.GetAz(basic.Az{AzName: azName})
			if err != nil {
				return nil, errors.New(fmt.Sprintf("%s: '可用区查询失败，err: %s'", switchInfo.Name, err.Error()))
			}
			switchInfo.AzId = az.Id
		}
		//验证机房
		if labName, ok := m["labName"]; ok && labName != "" {
			labObj, err := lab.GetLabByCodeOrName("", labName)
			if err != nil {
				return nil, errors.New(fmt.Sprintf("%s: '机房查询失败，err: %s'", switchInfo.Name, err.Error()))
			}
			switchInfo.LabId = labObj.Id
		}
		//
		if roomName, ok := m["roomName"]; ok && roomName != "" {
			roomObj, err := deviceroom.GetDeviceRoomByName(roomName)
			if err != nil || roomObj.DeviceRoomName == "" {
				return nil, errors.New(fmt.Sprintf("%s: '房间查询失败，err: %s'", switchInfo.Name, err.Error()))
			}
			switchInfo.RoomId = roomObj.DeviceRoom.Uid
		}
		//验证机柜
		if cabinName, ok := m["cabinName"]; ok && cabinName != "" {
			cabinList, err := cabidao.SelectCabinetByConds(cabidao.Cabinet{CabinetName: cabinName})
			if len(cabinList) == 0 {
				if err == nil {
					err = errors.New("机柜名称不正确")
				}
				return nil, errors.New(fmt.Sprintf("%s: '机柜查询失败，err: %s'", switchInfo.Name, err.Error()))
			}
			cabinObj := cabinList[0]
			switchInfo.CabinetId = cabinObj.Uid
		}
		//验证机架
		if rackName, ok := m["rackName"]; ok && rackName != "" {
			rack, err := rackdao.SelectRackInfoByObj(rackdao.Rack{RackName: rackName})
			if err != nil {
				return nil, errors.New(fmt.Sprintf("%s: '机架位查询失败，err: %s'", switchInfo.Name, err.Error()))
			}
			switchInfo.RackId = rack.Uid
		}

		//验证管理ip
		if mip, ok := m["managementIp"]; !ok || mip == "" {
			return nil, errors.New(fmt.Sprintf("%s: 管理IP不可为空", switchInfo.Name))
		} else {
			switchInfo.Ip = mip
		}
		//验证带外ip
		if outBandIp, ok := m["outBandIp"]; !ok || outBandIp == "" {
			return nil, errors.New(fmt.Sprintf("%s: 带外IP不可为空", switchInfo.OutBandIp))
		} else {
			switchInfo.OutBandIp = outBandIp
		}

		////团体字
		//if community, ok := m["community"]; !ok || community == "" {
		//	return nil, errors.New(fmt.Sprintf("%s: 带外IP不可为空", switchInfo.OutBandIp))
		//} else {
		//	switchInfo.Community = community
		//}

		//验证厂家
		if systemSales, ok := m["systemSales"]; !ok || systemSales == "" {
			return nil, errors.New(fmt.Sprintf("%s: 厂家不可为空", switchInfo.OutBandIp))
		} else {
			switchInfo.SystemSales = systemSales
		}

		//验证角色
		if switchRole, ok := m["switchRole"]; !ok || switchRole == "" {
			return nil, errors.New(fmt.Sprintf("%s: 交换机角色不可为空", switchRole))
		} else {
			enName := strings.Split(m["switchRole"], " ")
			role, err := switchdao.GetSwitchRoleInfo(enName[0])
			if err != nil {
				return nil, errors.New(fmt.Sprintf("%s: 交换机角色查询失败，err: %s'", role, err.Error()))
			}
			switchInfo.SwitchRole = enName[0]
		}

		//验证维保到期时间
		rege := regexp.MustCompile(`(\d{4})-(\d{2})-(\d{2}) (\d{2}):(\d{2}):(\d{2})`)
		if due, _ := m["maintenanceDue"]; due != "" && !rege.MatchString(due) {
			return nil, errors.New(fmt.Sprintf("无效的时间格式。维保到期时间需使用'YYYY-MM-DD HH:mm:ss'格式导入。异常行，名称为：%s", switchInfo.Name))
		}
		if maintenanceDue, ok := time.Parse("2006-01-02 15:04:05", m["maintenanceDue"]); ok == nil {
			switchInfo.MaintenanceDue = maintenanceDue.Add(-8 * time.Hour)
		}

		switchInfo.SwitchUnitNumber, _ = strconv.Atoi(m["switchUnitNumber"]) //所占U位
		switchInfo.SwitchType = m["switchType"]                              // 交换机型号
		switchInfo.InputTime = time.Now()                                    // 录入时间
		switchInfo.MainMaintainer = m["mainMaintainer"]                      //负责人
		switchInfo.AssetsNumber = m["assetsNumber"]                          //资产编号
		switchInfo.Description = m["description"]                            //描述
		switchInfo.CpuModel = m["cpuModel"]                                  //cpu型号
		switchInfo.MemModel = m["memModel"]                                  //内存型号
		switchInfo.RunStatus = "up"
		switchInfo.Creator = userName
		switchInfo.Updater = userName
		switchList = append(switchList, switchInfo)
	}
	return
}

func (s *SwitchService) GetSwitchLayout(sn string) (switchMachine.SwitchInterfaceLayoutListResult, error) {
	var (
		layoutResult = switchMachine.SwitchInterfaceLayoutListResult{}
		err          error
	)
	layoutResult.TotalCount, layoutResult.DataList, err = switchdao.SelectSwitchLayoutListByCons(sn)
	return layoutResult, err

}

func (s *SwitchService) GetSwitchInterfaceInfoList(param switchMachine.SwitchInterfaceLayoutListParams) (int64, []switchMachine.SwitchInterfaceInfo, error) {
	if param.PageSize == 0 {
		return 0, nil, nil
	}
	if param.PageNo > 0 {
		param.PageNo -= 1
	} else {
		return 0, nil, errors.New("invalid pageNo")
	}
	if param.Sn == "" {
		return 0, nil, errors.New("sn cannot be empty")
	}
	return switchdao.SelectSwitchInterfaceInfoListBySn(param)
}
func (s *SwitchService) GetSwitchInterfaceDetails(sn, index string) ([]switchMachine.SwitchInterfaceDetail, error) {
	if sn == "" {
		return nil, errors.New("sn cannot be empty")
	}
	return switchdao.SelectSwitchInterfaceDetailListBySn(sn, index)
}

// GetPhysicalSwitchInfo 获取交换机的总数、运行数、故障数、已过保数、一个月内以过保数、三个月内已过保数
func (s *SwitchService) GetPhysicalSwitchInfo(region, az string) (totalCount, runningCount, errorCount, insuredCount, insured1mCount, insured3mCount int64, err error) {
	cons := switchMachine.MysqlSwitch{}
	if region != "all" && region != "" {
		region, err := basic.GetRegion(basic.Region{RegionCode: region})
		if err == nil {
			cons.RegionId = region.Id
		}
	}
	if az != "all" && az != "" {
		az, err := basic.GetAz(basic.Az{AzCode: az})
		if err == nil {
			cons.AzId = az.Id
		}
	}
	fmt.Println("cons:", cons)
	//统计运行状态
	if totalCount, err = switchdao.CountStateOverview(cons); err != nil {
		return
	}
	cons.RunStatus = "up"
	if runningCount, err = switchdao.CountStateOverview(cons); err != nil {
		return
	}
	errorCount = totalCount - runningCount

	//统计维保状态
	cons.RunStatus = ""
	now := time.Now()
	cons.MaintenanceDue = now
	if insuredCount, err = switchdao.CountMaintenanceDueOverview(cons, "insured"); err != nil {
		return
	}
	//cons.MaintenanceDue = now.AddDate(0, 1, 0)
	if insured1mCount, err = switchdao.CountMaintenanceDueOverview(cons, "insured1m"); err != nil {
		return
	}
	//insured1mCount = insured1mCount - insuredCount
	//cons.MaintenanceDue = now.AddDate(0, 3, 0)
	if insured3mCount, err = switchdao.CountMaintenanceDueOverview(cons, "insured3m"); err != nil {
		return
	}
	//insured3mCount = insured3mCount - insuredCount
	return
}

func (s *SwitchService) GetSwitchPartsAndView(sn string) (result map[string]interface{}, err error) {
	if sn == "" {
		err = errors.New("sn cannot be empty")
		return
	}
	var (
		boards    string
		cpus      string
		mems      string
		powers    string
		fans      string
		view      string
		ctx, celf = context.WithTimeout(context.Background(), 5*time.Second)
	)
	defer celf()
	result = make(map[string]interface{})
	//resMap["boards"], err = gredis.HGet(ctx, gredis.SnmpSwitchBoardsKey, sn)
	boards, err = gredis.HGet(ctx, gredis.SnmpSwitchBoardsKey, sn)
	if err != nil {
		klog.Error(fmt.Sprintf("get boards from redis err: %v", err))
	} else {
		var boardList []switchMachine.SwitchBoard
		_ = json.Unmarshal([]byte(boards), &boardList)
		//处理交换机主板制造日期乱码问题
		defaultManufacturedDate := ""
		for i := range boardList {
			if regexp.MustCompile("\\d{4}-\\d{1,2}-\\d{1,2} \\d{2}:\\d{2}:\\d{2}.\\d").MatchString(boardList[i].ManufacturedDate) {
				defaultManufacturedDate = boardList[i].ManufacturedDate
				break
			}
		}
		for i := range boardList {
			if !regexp.MustCompile("\\d{4}-\\d{1,2}-\\d{1,2} \\d{2}:\\d{2}:\\d{2}.\\d").MatchString(boardList[i].ManufacturedDate) {
				boardList[i].ManufacturedDate = defaultManufacturedDate
			}
		}
		result["boards"] = boardList
		//_ = json.Unmarshal([]byte(boards), resMap["boards"])
	}

	//resMap["cpus"], err = gredis.HGet(ctx, gredis.SnmpSwitchCpusKey, sn)
	cpus, err = gredis.HGet(ctx, gredis.SnmpSwitchCpusKey, sn)
	if err != nil {
		klog.Error(fmt.Sprintf("get cpus from redis err: %v", err))
	} else {
		var cpuList []switchMachine.SwitchCpu
		_ = json.Unmarshal([]byte(cpus), &cpuList)
		result["cpus"] = cpuList
		//_ = json.Unmarshal([]byte(cpus), resMap["cpus"])
	}

	//resMap["mems"], err = gredis.HGet(ctx, gredis.SnmpSwitchMemsKey, sn)
	mems, err = gredis.HGet(ctx, gredis.SnmpSwitchMemsKey, sn)
	if err != nil {
		klog.Error(fmt.Sprintf("get mems from redis err: %v", err))
	} else {
		var memList []switchMachine.SwitchMemory
		_ = json.Unmarshal([]byte(mems), &memList)
		result["mems"] = memList
		//_ = json.Unmarshal([]byte(mems), resMap["mems"])
	}

	//resMap["powers"], err = gredis.HGet(ctx, gredis.SnmpSwitchPowersKey, sn)
	powers, err = gredis.HGet(ctx, gredis.SnmpSwitchPowersKey, sn)
	if err != nil {
		klog.Error(fmt.Sprintf("get powers from redis err: %v", err))
	} else {
		var powerList []switchMachine.SwitchPower
		_ = json.Unmarshal([]byte(powers), &powerList)
		result["powers"] = powerList
		//_ = json.Unmarshal([]byte(powers), resMap["powers"])
	}

	//resMap["fans"], err = gredis.HGet(ctx, gredis.SnmpSwitchFansKey, sn)
	fans, err = gredis.HGet(ctx, gredis.SnmpSwitchFansKey, sn)
	if err != nil {
		klog.Error(fmt.Sprintf("get fans from redis err: %v", err))
	} else {
		var fanList []switchMachine.SwitchFan
		_ = json.Unmarshal([]byte(fans), &fanList)
		result["fans"] = fanList
		//_ = json.Unmarshal([]byte(fans), resMap["fans"])
	}

	//resMap["view"], err = gredis.HGet(ctx, gredis.SnmpSwitchViewsKey, sn)
	view, err = gredis.HGet(ctx, gredis.SnmpSwitchViewsKey, sn)
	if err != nil {
		klog.Error(fmt.Sprintf("get view from redis err: %v", err))
	} else {
		var viewList switchMachine.SwitchView
		_ = json.Unmarshal([]byte(view), &viewList)
		result["view"] = viewList
		//_ = json.Unmarshal([]byte(view), resMap["view"])
	}

	err = nil
	return
}

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/pkg/service/natResourcePool.go
```golang
package service

import (
	"k8s.io/klog/v2"
	"luban-cmdb-api/pkg/models/netPoolModel"
)

//GetNatPool 获取Nat网络资源池
func GetNatPool() (*netPoolModel.NetWorkResource, error) {
	netPoolList, err := getNetworkPool() //获取所有网络资源池信息
	if err != nil {
		klog.Errorf("Get network pool from redis failed, error: %s", err)
		return nil, err
	}

	var natPool = new(netPoolModel.NetWorkResource)

	//网络资源池的Hosts字段底层是一个[]string类型，返回一个资源池再遍历所有的Host
	for i := range netPoolList {
		if netPoolList[i].PoolType == "NAT" {
			natPool = &netPoolList[i]
		}
	}
	return natPool, nil
}

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/pkg/service/dgraph.go
```golang
package service

type DgraphService struct {
	Code  string `json:"code"`
	Value string `json:"value"`
}

// func (h *DgraphService) RegionQuery() ([]model.RegionData, error) {
// 	// 为创建的节点分配的uid将在resp.AssignedUids map中返回。
// 	//variables := map[string]string{"$id": assigned.Uids["blank-0"]}

// 	//variables := map[string]string{"$id": uid}
// 	var dgraphRegionData model.DgraphRegionData
// 	q := `{
// 		region(func:eq(` + h.Code + `,"` + h.Value + `")){
// 			uid
// 			regionCode
// 			regionCodeAggregate
// 			regionName
// 			}
// 		}`
// 	//klog.Infof(q)
// 	resp, err := dgraphClient.Dgraph.NewTxn().Query(context.Background(), q)
// 	if err != nil {
// 		klog.Error("Query dgraph error...")
// 		//fmt.Println(err)
// 		return dgraphRegionData.Region, err
// 	}
// 	//klog.Infof(resp.String())
// 	e := json.Unmarshal(resp.Json, &dgraphRegionData)
// 	if e != nil {
// 		klog.Error("json unmarshal error...." + e.Error())
// 	}
// 	return dgraphRegionData.Region, err
// }

// func (h *DgraphService) AZQuery() ([]model.AZData, error) {
// 	// 为创建的节点分配的uid将在resp.AssignedUids map中返回。
// 	//variables := map[string]string{"$id": assigned.Uids["blank-0"]}

// 	//variables := map[string]string{"$id": uid}
// 	var dgraphAZData model.DgraphAZData
// 	q := `{
// 		az(func:eq(` + h.Code + `,"` + h.Value + `")){
// 			uid
// 			azCode
// 			azCodeAggregate
// 			azName
// 			}
// 		}`
// 	//klog.Infof(q)
// 	resp, err := dgraphClient.Dgraph.NewTxn().Query(context.Background(), q)
// 	if err != nil {
// 		klog.Error("Query dgraph error...")
// 		//fmt.Println(err)
// 		return dgraphAZData.AZ, err
// 	}
// 	//klog.Infof(resp.String())
// 	e := json.Unmarshal(resp.Json, &dgraphAZData)
// 	if e != nil {
// 		klog.Error("json unmarshal error...." + e.Error())
// 	}
// 	return dgraphAZData.AZ, err
// }

// func (h *DgraphService) HostQuery() ([]server.PhysicalHostData, error) {
// 	// 为创建的节点分配的uid将在resp.AssignedUids map中返回。
// 	//variables := map[string]string{"$id": assigned.Uids["blank-0"]}

// 	//variables := map[string]string{"$id": uid}
// 	var dgraphHostData model.DgraphHostData
// 	q := `{
// 		host(func:eq(` + h.Code + `,"` + h.Value + `")){
// 			{
// 				uid
// 				ip
// 				sn
// 				name:hostname
// 				runstatus
// 				assignmentStatus
// 				resourcePoolType:serviceType
// 				resourcePool:serviceType
// 				service
// 				managementIP:ip
// 				outbandIP
// 				power
// 				uplinkSwitch
// 				maintenanceDue
// 				maintenanceStatus
// 				assetsnumber
// 				inputMethod
// 				hostAzCode
// 				hostAzName
// 				hostRegionCode
// 				hostRegionName
// 				hostLabCode
// 				hostLabName
// 				hostRoomUid
// 				hostRoomName
// 				hostCabinetUid
// 				hostCabinetName
// 				hostRackUid
// 				hostRackName
// 				hostUnitUid
// 				hostUnitNumber
// 				description
// 				createTime
// 				cpuAllocationRatio
// 				ramAllocationRatio
// 			  }
// 			}

// 		}`
// 	//klog.Infof(q)
// 	resp, err := dgraphClient.Dgraph.NewTxn().Query(context.Background(), q)
// 	if err != nil {
// 		klog.Error("Query dgraph error...")
// 		//fmt.Println(err)
// 		return dgraphHostData.Host, err
// 	}
// 	//klog.Infof(resp.String())
// 	e := json.Unmarshal(resp.Json, &dgraphHostData)
// 	if e != nil {
// 		klog.Error("json unmarshal error...." + e.Error())
// 	}
// 	return dgraphHostData.Host, err
// }

// GetRegionByOurWay e.g. ebs zone: cn-shanghai-2a, our way got, region: cn-shanghai-2 az: a
// func (h *DgraphService) GetRegionByOurWay() model.RegionData {
// 	regionData := model.RegionData{}
// 	regionDataList, err := h.RegionQuery()
// 	if err != nil || len(regionDataList) < 1 {
// 		return regionData
// 	}
// 	return regionDataList[0]
// }

// func (h *DgraphService) GetAZByOurWay() model.AZData {
// 	azData := model.AZData{}
// 	azDataList, err := h.AZQuery()
// 	if err != nil || len(azDataList) < 1 {
// 		return azData
// 	}
// 	return azDataList[0]
// }
// func (h *DgraphService) RegionList() ([]model.RegionData, error) {
// 	// 为创建的节点分配的uid将在resp.AssignedUids map中返回。
// 	//variables := map[string]string{"$id": assigned.Uids["blank-0"]}

// 	//variables := map[string]string{"$id": uid}
// 	var dgraphRegionData model.DgraphRegionData
// 	q := `{
// 		region(func:has(regionCode)){
// 			uid
// 			regionCode
// 			regionCodeAggregate
// 			regionName
// 			}
// 		}`
// 	//klog.Infof(q)
// 	resp, err := dgraphClient.Dgraph.NewTxn().Query(context.Background(), q)
// 	if err != nil {
// 		klog.Error("Query dgraph error...")
// 		//fmt.Println(err)
// 		return dgraphRegionData.Region, err
// 	}
// 	//klog.Infof(resp.String())
// 	e := json.Unmarshal(resp.Json, &dgraphRegionData)
// 	if e != nil {
// 		klog.Error("json unmarshal error...." + e.Error())
// 	}
// 	return dgraphRegionData.Region, err
// }
// func (h *DgraphService) AzList() ([]model.AZData, error) {
// 	// 为创建的节点分配的uid将在resp.AssignedUids map中返回。
// 	//variables := map[string]string{"$id": assigned.Uids["blank-0"]}

// 	//variables := map[string]string{"$id": uid}
// 	var dgraphAznData model.DgraphAZData
// 	q := `{
// 		az(func:has(azCode)){
// 			uid
// 			azCode
// 			azCodeAggregate
// 			azName
// 			}
// 		}`
// 	//klog.Infof(q)
// 	resp, err := dgraphClient.Dgraph.NewTxn().Query(context.Background(), q)
// 	if err != nil {
// 		klog.Error("Query dgraph error...")
// 		//fmt.Println(err)
// 		return dgraphAznData.AZ, err
// 	}
// 	//klog.Infof(resp.String())
// 	e := json.Unmarshal(resp.Json, &dgraphAznData)
// 	if e != nil {
// 		klog.Error("json unmarshal error...." + e.Error())
// 	}
// 	return dgraphAznData.AZ, err
// }

// func (h *DgraphService) GetRegionMap() (map[string]*model.RegionData, error) {
// 	//regionData := model.RegionData{}
// 	regionMap := make(map[string]*model.RegionData)
// 	regionDataList, err := h.RegionQuery()
// 	if err != nil {
// 		return regionMap, err
// 	}

// 	for i := range regionDataList {
// 		regionMap[regionDataList[i].Uid] = &regionDataList[i]
// 	}
// 	return regionMap, err
// }

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/pkg/service/storagePool.go
```golang
package service

import (
	"context"
	"encoding/json"
	"fmt"
	"gorm.io/gorm/clause"
	"luban-cmdb-api/pkg/dao"
	"luban-cmdb-api/pkg/dao/basic"
	basicdao "luban-cmdb-api/pkg/dao/basic"
	"luban-cmdb-api/pkg/dao/server"
	storagepool "luban-cmdb-api/pkg/dao/storagePool"
	"luban-cmdb-api/pkg/gredis"
	serverModel "luban-cmdb-api/pkg/models/server"
	"luban-cmdb-api/pkg/models/storage"
	"luban-cmdb-api/pkg/models/storagePool"
	"strconv"
	"strings"
	"time"

	"k8s.io/klog/v2"
)

type StoragePool struct {
	Id           int      `json:"id"`
	Name         string   `json:"name"`
	RegionName   string   `json:"regionName"`
	RegionCode   string   `json:"regionCode"`
	AzId         int      `json:"azId"`
	AzName       string   `json:"azName"`
	AzCode       string   `json:"azCode"`
	StorageType  string   `json:"storageType"`
	ResourcePool string   `json:"resourcePool"`
	ClusterUrl   string   `json:"clusterUrl"`
	MetricUrl    string   `json:"metricUrl"`
	SliceUrl     string   `json:"sliceUrl"`
	StockUrl     string   `json:"stockUrl"`
	SubNameSpace string   `json:"subNameSpace"`
	Addresss     []string `json:"addresss"`
	CreateTime   int64    `json:"createTime"`
}

func (sp *StoragePool) GetStoragePoolIps() (storage.Addresss, error) {
	klog.Infof("get %s storage pool cluster information", sp.Name)
	addresss := storage.Addresss{}
	b, err := sp.GetStoragePoolByte()
	if err != nil {
		return addresss, err
	}
	klog.Infof("GetStoragePoolIps %+v", sp)
	switch {
	case sp.StorageType == "ebs":
		hostList := []storage.EbsHost{}
		err = json.Unmarshal(b, &hostList)
		if err != nil {
			return addresss, err
		}
		klog.V(1).Infof("got %s storge pool server list: %+v", sp.Name, hostList)
		klog.Infof("get_storage_EbsHost %+v", sp.Name, hostList)
		for _, host := range hostList {
			if host.Address != "" && !BoolTagInArray(addresss.Address, SubStr(host.Address, ":")) {
				addresss.Address = append(addresss.Address, SubStr(host.Address, ":"))
			}
		}
	case sp.ResourcePool == "ks3":
		hostList := []storage.Ks3Host{}
		err = json.Unmarshal(b, &hostList)
		if err != nil {
			return addresss, err
		}
		klog.V(1).Infof("got %s storge pool server list: %+v", sp.Name, hostList)

		// 将ks3集群信息存入 Redis 中
		hosts := make([]interface{}, 0)
		for _, v := range hostList {
			hosts = append(hosts, v)
		}
		ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
		defer cancel()
		_, err := gredis.SAdd(ctx, gredis.KS3StoragePoolServers, hosts)
		if err != nil {
			klog.Errorf("%s cache failure:", gredis.KS3StoragePoolServers, err.Error())
		}

		for _, host := range hostList {
			if host.Ip != "" && !BoolTagInArray(addresss.Address, SubStr(host.Ip, ":")) {
				addresss.Address = append(addresss.Address, SubStr(host.Ip, ":"))
			}
		}
	}
	return addresss, err
}

func (sp *StoragePool) GetStoragePoolByte() ([]byte, error) {
	simpleHttpClient := SimpleHttpClient{}

	bytes, err := simpleHttpClient.SimpleHttpGet(fmt.Sprintf("%s", sp.ClusterUrl))
	if err != nil {
		return nil, err
	}
	return bytes, err
}

// 获取块存储分片信息
func (sp *StoragePool) GetStoragePoolSliceByte() ([]byte, error) {
	simpleHttpClient := SimpleHttpClient{}
	//sp.SliceUrl = "http://127.0.0.1:8088/ebs/slice"
	bytes, err := simpleHttpClient.SimpleHttpGet(fmt.Sprintf("%s", sp.SliceUrl))
	if err != nil {
		return nil, err
	}
	return bytes, err
}

// 获取存储资源列表
func (sp *StoragePool) GetStoragePoolList(regionArr, azArr, resourcePoolArr []string) ([]StoragePool, error) {

	var storagePoolList []StoragePool
	splmap := GetPoolList()
	for _, spool := range splmap {
		if (sp.StorageType == "all" || sp.StorageType == "" || spool.StorageType == sp.StorageType) &&
			(sp.RegionCode == "all" || sp.RegionCode == "" || spool.RegionCode == sp.RegionCode) &&
			//(sp.AzCode == "all" || storagePool.AzCode == sp.AzCode) &&
			(len(regionArr) < 1 || BoolTagInArray(regionArr, spool.RegionCode)) &&
			(len(azArr) < 1 || BoolTagInArray(azArr, spool.AzCode)) &&
			(sp.Name == "" || spool.Name == sp.Name) &&
			(len(resourcePoolArr) < 1 || BoolTagInArray(resourcePoolArr, spool.ResourcePool)) {
			storagePoolList = append(storagePoolList, spool)
		}
	}
	return storagePoolList, nil
}

// 从mysql中获取存储资源池
func GetPoolList() (spList []StoragePool) {
	stpl, err := storagepool.List()
	if err != nil {
		klog.Infoln("storagepool.List() err:", err)
		return
	}
	regL, err := basic.QueryAllRegion2Map()
	if err != nil {
		klog.Infoln("basic.QueryAllRegion2Map() err:", err)
		return
	}
	azL, err := basic.QueryAllAz2Map()
	if err != nil {
		klog.Infoln("basic.QueryAllAz2Map() err:", err)
		return
	}
	for i := 0; i < len(stpl); i++ {
		region := regL[stpl[i].RegionId]
		az := azL[stpl[i].AzId]
		sp := StoragePool{
			Id:           stpl[i].Id,
			Name:         stpl[i].Name,
			RegionCode:   region.RegionCode,
			RegionName:   region.RegionName,
			AzId:         stpl[i].AzId,
			AzCode:       az.AzCode,
			AzName:       az.AzName,
			StorageType:  stpl[i].StorageType,
			ResourcePool: stpl[i].ResourcePool,
			ClusterUrl:   stpl[i].ClusterUrl,
			MetricUrl:    stpl[i].MetricUrl,
			SliceUrl:     stpl[i].SliceUrl,
			StockUrl:     stpl[i].StockUrl,
			SubNameSpace: stpl[i].SubNameSpace,
			CreateTime:   stpl[i].CreateTime.Unix(),
		}
		addresss := stpl[i].Addresss
		if addresss != "" {
			adList := strings.Split(addresss, ";")
			sp.Addresss = adList
		} else {
			sp.Addresss = []string{}
		}
		spList = append(spList, sp)

	}
	return
}

var timeTemplates = []string{
	"2006-01-02 15:04:05", //常规类型
	//"2006/01/02 15:04:05",
	//"2006-01-02",
	//"2006/01/02",
}

func TimeStringToGoTime(tm string) time.Time {
	for i := range timeTemplates {
		t, err := time.ParseInLocation(timeTemplates[i], tm, time.Local)
		if nil == err && !t.IsZero() {
			return t
		}
	}
	return time.Time{}
}

// 更新数据到mysql (暂时弃用)
func UpdateStoragePoolNew() error {
	//资源池名称
	storageName := []string{
		"ssd3.0",
		"ehdd",
		"ks3",
	}
	poolHosts := serverModel.PoolHostUpdate{}
	serverMap := make(map[string]interface{})

	azs, _ := basicdao.GetAzListByMap(map[string]interface{}{})
	for _, v := range azs {
		ids := strconv.Itoa(v.Id)
		for _, name := range storageName {
			storageInfo := storagePool.StoragePool{}
			var httpPrefix string
			storageInfo.Name = name
			switch name {
			case "ssd3.0":
				httpPrefix = "ssd3.az" + ids
				storageInfo.StorageType = "ebs"
				storageInfo.SubNameSpace = "ebs3_ssd"
				storageInfo.ResourcePool = "ssd3.0"
			case "ehdd":
				httpPrefix = "ehdd.az" + ids
				storageInfo.StorageType = "ebs"
				storageInfo.SubNameSpace = "ehdd_ehdd"
				storageInfo.ResourcePool = "ehdd"
			case "ks3":
				httpPrefix = "kts.ks3.az" + ids
				storageInfo.StorageType = "ks3"
				storageInfo.SubNameSpace = "ks3"
				storageInfo.ResourcePool = "ks3"
			}
			storageInfo.AzId = v.Id
			storageInfo.RegionId = v.RegionId
			storageInfo.ClusterUrl = fmt.Sprintf("http://%s.luban.sdns.galaxy.cloud:9000/%s/cluster", httpPrefix, storageInfo.StorageType)
			storageInfo.MetricUrl = fmt.Sprintf("http://%s.luban.sdns.galaxy.cloud:9000/%s/metric", httpPrefix, storageInfo.StorageType)
			if name == "ks3" { // todo ks3 的cluster数据与metric数据部署在不同的服务器上 需要配置两个域名来获取数据
				httpPrefix = "phenix.ks3.az" + ids
				storageInfo.MetricUrl = fmt.Sprintf("http://%s.luban.sdns.galaxy.cloud:9000/%s/metric", httpPrefix, storageInfo.StorageType)
			}
			storageInfo.SliceUrl = fmt.Sprintf("http://%s.luban.sdns.galaxy.cloud:9000/%s/slice", httpPrefix, storageInfo.StorageType)

			uptime := TimeStringToGoTime(time.Now().Format("2006-01-02 15:04:05"))
			storageInfo.UpdateTime = uptime
			storageInfo.CreateTime = uptime

			sp := StoragePool{
				Name:         name,
				StorageType:  storageInfo.StorageType,
				ResourcePool: storageInfo.ResourcePool,
				ClusterUrl:   storageInfo.ClusterUrl,
				SliceUrl:     storageInfo.SliceUrl,
			}
			//获取资源ip列表
			addresss, getIpErr := sp.GetStoragePoolIps()
			klog.Infof("GetStoragePoolIps %v", addresss)
			if getIpErr != nil {
				klog.Infoln("sp.GetStoragePoolIps() err:", getIpErr)
				continue
			}
			storageInfo.Addresss = strings.Join(addresss.Address, ";")
			//更新资源池列表
			res := dao.AssetDB.Table("asset_storage_pool").Clauses(
				clause.OnConflict{Columns: []clause.Column{{Name: "cluster_url"}}, UpdateAll: true},
				clause.Returning{Columns: []clause.Column{{Name: "id"}}}).
				Create(&storageInfo)
			if res.Error != nil {
				klog.Error(fmt.Sprintf("upsert_asset_storage_pool:%s err: %v", storageInfo.ClusterUrl, res.Error))
				continue
			}
			var result storagePool.StoragePool
			err := res.Scan(&result).Error
			if err != nil {
				klog.Error("get_asset_storage_pool_notes_fail %+v", err)
				continue
			}
			sp.Id = result.Id
			// 更新ebs服务器数据
			poolHosts.IpList = addresss.Address
			serverMap["resource_pool_type"] = storageInfo.StorageType
			serverMap["resource_pool"] = storageInfo.Name
			upServerErr := server.UpdateStorage(poolHosts, serverMap)
			if upServerErr != nil {
				klog.Infoln("storagepool.UpdateStorage(serverMap) err:", err)
				continue
			}
			klog.Infof("up_storagepool_success", result.Id)
			// 更新资源池分片信息
			switch {
			case sp.StorageType == "ebs":
				//获取资源池分片信息
				slice, err := sp.GetStoragePoolSliceByte()
				sliceList := []storagePool.EBSPollSlice{}
				err = json.Unmarshal(slice, &sliceList)
				if err != nil {
					klog.Infoln("sp.GetStoragePoolSliceByte() err:", err)
					continue
				}
				if sliceList == nil {
					klog.Infoln("Failed to obtain fragment information")
					continue
				}
				//更新到存储资源池分片信息
				fmt.Println("=====sliceList======", sliceList)
				poolSlice := []storagePool.StoragePoolSlice{}
				poolId := result.Id
				for _, vv := range sliceList {
					copies := strings.Split(vv.Replicas, ",")
					copiesNum := len(copies)
					sliceInfo := storagePool.StoragePoolSlice{
						PoolId:     poolId,
						TabletName: vv.TabletName,
						Replicas:   vv.Replicas,
						CopyNum:    copiesNum,
						TableName:  vv.TableName,
						TableId:    vv.TableId,
					}
					poolSlice = append(poolSlice, sliceInfo)
				}
				err1 := storagepool.UpdatePoolSliceTransaction(poolSlice, poolId)
				if err1 != nil {
					klog.Infoln("storagepool.UpdatePoolSliceTransaction err:", err1)
				}
			}
		}
	}
	return nil
}

// 更新数据到mysql
func UpdateStoragePool() error {
	storagePoolMap := make(map[string]interface{})
	serverMap := make(map[string]interface{})
	poolHosts := serverModel.PoolHostUpdate{}
	stpl, err := storagepool.List()

	if err != nil {
		klog.Infoln("storagepool.List() err:", err)
		return nil
	}
	for i := 0; i < len(stpl); i++ {
		sp := StoragePool{
			Id:           stpl[i].Id,
			Name:         stpl[i].Name,
			StorageType:  stpl[i].StorageType,
			ResourcePool: stpl[i].Name,
			ClusterUrl:   stpl[i].ClusterUrl,
			SliceUrl:     stpl[i].SliceUrl,
			CreateTime:   stpl[i].CreateTime.Unix(),
		}

		//更新资源池信息
		addresss, err := sp.GetStoragePoolIps()
		if err != nil {
			klog.Infoln("sp.GetStoragePoolIps() err:", err)
			continue
		}
		storagePoolMap["id"] = stpl[i].Id
		storagePoolMap["addresss"] = strings.Join(addresss.Address, ";")
		uptime := TimeStringToGoTime(time.Now().Format("2006-01-02 15:04:05"))
		storagePoolMap["update_time"] = uptime
		//TODO 更新的IP有错误，玉冰先手动改了数据库，待理清逻辑再引入自动更新
		err = storagepool.Update(storagePoolMap)
		if err != nil {
			klog.Infoln("storagepool.Update(storagePoolMap) err:", err)
			continue
		}

		//怀疑下面这行代码有bug，先注释掉
		//serverMap["ip"] = addresss.Address
		poolHosts.IpList = addresss.Address
		serverMap["resource_pool_type"] = stpl[i].StorageType
		serverMap["resource_pool"] = stpl[i].Name
		err = server.UpdateStorage(poolHosts, serverMap)
		if err != nil {
			klog.Infoln("storagepool.UpdateStorage(serverMap) err:", err)
			continue
		}

		// 更新资源池分片信息
		switch {
		case sp.StorageType == "ebs":
			//获取资源池分片信息
			slice, err := sp.GetStoragePoolSliceByte()
			sliceList := []storagePool.EBSPollSlice{}
			err = json.Unmarshal(slice, &sliceList)
			if err != nil {
				klog.Infoln("sp.GetStoragePoolSliceByte() err:", err)
				continue
			}
			if sliceList == nil {
				klog.Infoln("Failed to obtain fragment information")
				continue
			}
			//更新到存储资源池分片信息
			fmt.Println("=====sliceList======", sliceList)
			poolSlice := []storagePool.StoragePoolSlice{}
			poolId := stpl[i].Id
			for _, v := range sliceList {
				copies := strings.Split(v.Replicas, ",")
				copiesNum := len(copies)
				sliceInfo := storagePool.StoragePoolSlice{
					PoolId:     stpl[i].Id,
					TabletName: v.TabletName,
					Replicas:   v.Replicas,
					CopyNum:    copiesNum,
					TableName:  v.TableName,
					TableId:    v.TableId,
				}
				poolSlice = append(poolSlice, sliceInfo)
			}
			err1 := storagepool.UpdatePoolSliceTransaction(poolSlice, poolId)
			if err1 != nil {
				klog.Infoln("storagepool.UpdatePoolSliceTransaction err:", err1)
			}

		}
	}
	return err
}

//func Patch4StoragePool() {
//	token := keyStone.GetAdminToken()
//
//}

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/pkg/service/cmdbSort.go
```golang
package service

//定义一个通用的结构体
type Bucket struct {
	Slice []interface{}               //承载以任意结构体为元素构成的Slice
	By    func(a, b interface{}) bool //排序规则函数,当需要对新的结构体slice进行排序时，只需定义这个函数即可
}

/*
 定义三个必须方法的准则：接收者不能为指针
*/
func (this Bucket) Len() int { return len(this.Slice) }

func (this Bucket) Swap(i, j int) { this.Slice[i], this.Slice[j] = this.Slice[j], this.Slice[i] }

func (this Bucket) Less(i, j int) bool { return this.By(this.Slice[i], this.Slice[j]) }

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/pkg/service/blockStoragePool.go
```golang
package service

import (
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"io/ioutil"
	"luban-cmdb-api/pkg/dao/blockstorage"
	storagepool "luban-cmdb-api/pkg/dao/storagePool"
	"luban-cmdb-api/pkg/models/aggregate"
	"luban-cmdb-api/pkg/models/storagePool"
	"luban-cmdb-api/pkg/utils/ebs"
	"luban-cmdb-api/pkg/utils/keyStone"
	"math"
	"net/http"
	"sort"
	"strconv"
	"strings"
	"time"

	"github.com/google/uuid"
	"k8s.io/klog/v2"

	"github.com/dgraph-io/dgo/v200"
	"github.com/google/go-querystring/query"

	basicdao "luban-cmdb-api/pkg/dao/basic"
	"luban-cmdb-api/pkg/models/storage"
)

type EBSAPIRequest struct {
	Offset              int    `url:"offset,omitempty"`
	Size                int    `url:"size,omitempty"`
	UserId              string `url:"userId,omitempty"`
	Region              string `url:"region,omitempty"`
	VolumeType          string `url:"volumeType,omitempty"`
	VolumeState         string `url:"volumeState,omitempty"`
	Status              int    `url:"status,omitempty"`
	OrderType           int    `url:"OrderType,omitempty"`
	VmId                string `url:"vmId,omitempty"`
	CreateTimeBegin     string `url:"createTimeBegin,omitempty"` // datetime e.g. 2017-03-13 00:00:00
	CreateTimeEnd       string `url:"createTimeEnd,omitempty"`
	ServiceEndTimeBegin string `url:"serviceEndTimeBegin,omitempty"`
	ServiceEndTimeEnd   string `url:"serviceEndTimeEnd,omitempty"`
	VolumeId            string `url:"volumeId,omitempty"`
	VolumeCategory      string `url:"volumeCategory,omitempty"` // "data" or "system"
}

type EBSAPIResponse struct {
	Total   int         `json:"total"`
	Volumes []EBSVolume `json:"volumes"`
}

type EBSVolume struct {
	DirectorName     string `json:"director_name"`
	Region           string `json:"region"`
	PersonName       string `json:"person_name"`
	DeleteTime       string `json:"delete_time"`
	Status           int    `json:"status"`
	VmId             string `json:"vm_id"`
	VolumeType       string `json:"volume_type"`
	VolumeState      string `json:"volume_state"` // 硬盘状态: https://wiki.op.ksyun.com/pages/viewpage.action?pageId=50201463
	VolumeSize       int    `json:"volume_size"`
	BillType         int    `json:"bill_type"`
	VolumeId         string `json:"volume_id"`
	CompanyName      string `json:"company_name"`
	ServiceBeginTime string `json:"service_begin_time"`
	ServiceEndTime   string `json:"service_end_time"`
	VolumeName       string `json:"volume_name"`
	CreateTime       string `json:"create_time"`
	UserId           int    `json:"user_id"`
	Zone             string `json:"zone"`
	VolumeCategory   string `json:"volume_category"`
	OrderType        int    `json:"order_type"`
}

type VolumeEntityAPIRequest struct {
	UserId         string `json:"userId,omitempty"`
	Region         string `json:"region,omitempty"`
	VmId           string `json:"vmId,omitempty"`
	VolumeId       string `json:"volumeId,omitempty"`
	Query          string `json:"query,omitempty"`
	VolumeCategory string `json:"volumeCategory,omitempty"` // "data" or "system"
}
type VolumeEntityAPIResponse struct {
	RequestId string   `json:"RequestId"`
	Volumes   []Volume `json:"Volumes"`
}
type Volume struct {
	VolumeId         string `json:"VolumeId"`
	VolumeName       string `json:"VolumeName"`
	VolumeDesc       string `json:"VolumeDesc"`
	Size             int    `json:"Size"`
	VolumeStatus     string `json:"VolumeStatus"`
	VolumeType       string `json:"VolumeType"`
	VolumeCategory   string `json:"VolumeCategory"`
	InstanceId       string `json:"InstanceId"`
	AvailabilityZone string `json:"AvailabilityZone"`
	CreateTime       string `json:"CreateTime"`
	Attachment       []struct {
		InstanceId         string `json:"InstanceId"`
		MountPoint         string `json:"MountPoint"`
		DeleteWithInstance string `json:"DeleteWithInstance"`
	}
	string    `json:"Attachment"`
	ProjectId string `json:"ProjectId"`
}

// GetRegionByOurWay e.g. ebs zone: cn-shanghai-2a, our way got, region: cn-shanghai-2 az: a
// func (e EBSVolume) GetRegionByOurWay() model.RegionData {
// 	dgraphService := DgraphService{
// 		Code:  "regionCodeAggregate",
// 		Value: e.Region,
// 	}
// 	mRegion := model.RegionData{}
// 	regionDataList, err := dgraphService.RegionQuery()
// 	if err != nil || len(regionDataList) < 1 {
// 		return mRegion
// 	}
// 	return regionDataList[0]
// }

// func (e EBSVolume) GetAZByOurWay() model.AZData {
// 	dgraphService := DgraphService{
// 		Code:  "azCode",
// 		Value: e.Zone,
// 	}
// 	azDataList, err := dgraphService.AZQuery()
// 	mAz := model.AZData{}
// 	if err != nil || len(azDataList) < 1 {
// 		return mAz
// 	}
// 	return azDataList[0]
// }

type StorageStateResponse struct {
	TotalGB int `json:"total_gb"`
	UsedGB  int `json:"used_gb"`
}

type HttpClient interface {
	SimpleHttpGet(url string) ([]byte, error)
}

type BlockStoragePoolService struct {
	EBSAddr          string `json:"EBSAddr"`
	StorageStateAddr string `json:"storage_state_addr"`
	HttpClient       HttpClient
	BasicService     *BasicService
}

func NewBlockStoragePoolService(ebsAddr string, storageStateAddr string, dgraphclient *dgo.Dgraph) *BlockStoragePoolService {
	return &BlockStoragePoolService{
		EBSAddr:          ebsAddr,
		StorageStateAddr: storageStateAddr,
		HttpClient:       &SimpleHttpClient{},
		BasicService:     NewBasicService(dgraphclient, &AggregateService{}),
	}
}

// 获取块存储资源列表
func (bs *BlockStoragePoolService) GetBlockStoragePoolList(blockStoragePoolQuery storage.BlockStoragePoolQuery) ([]storage.BlockRe, error) {
	var BlockReDataList []storage.BlockRe
	spList := GetPoolList()
	for _, storagePool := range spList {

		if (storagePool.StorageType == "ebs") &&
			(blockStoragePoolQuery.RegionCode == "all" || storagePool.RegionCode == blockStoragePoolQuery.RegionCode) &&
			(len(blockStoragePoolQuery.AzCode) <= 0 || BoolTagInArray(blockStoragePoolQuery.AzCode, storagePool.AzCode)) &&
			(blockStoragePoolQuery.Name == "" || storagePool.Name == blockStoragePoolQuery.Name) &&
			(len(blockStoragePoolQuery.ResourcePool) < 1 || BoolTagInArray(blockStoragePoolQuery.ResourcePool, storagePool.ResourcePool)) {

			//search
			if blockStoragePoolQuery.SearchType != "" {
				switch blockStoragePoolQuery.SearchType {
				case "name":
					if !strings.Contains(storagePool.Name, blockStoragePoolQuery.SearchValue) {
						continue
					}
				}
			}

			var BlockReData storage.BlockRe
			BlockReData.Id = storagePool.Id
			BlockReData.Name = storagePool.Name
			BlockReData.RegionCode = storagePool.RegionCode
			BlockReData.RegionName = storagePool.RegionName
			BlockReData.AzId = storagePool.AzId
			BlockReData.AzCode = storagePool.AzCode
			BlockReData.AzName = storagePool.AzName
			BlockReData.ResourcePool = storagePool.ResourcePool
			BlockReData.Addresss = storagePool.Addresss
			BlockReData.HostNumber = len(storagePool.Addresss)
			BlockReData.CreateTime = storagePool.CreateTime
			BlockReData.StockUrl = storagePool.StockUrl
			BlockReData.SliceUrl = storagePool.SliceUrl
			BlockReData.MetricUrl = storagePool.MetricUrl
			// hostList, err := storagePool.GetStoragePoolIps()
			// if err != nil {
			// 	BlockReData.HostNumber = 0
			// } else {
			// 	BlockReData.HostNumber = len(hostList.Address)
			// }
			//klog.Infof("GetStoragePoolIps:%d", len(hostList.Address))
			cloudDiskReq := storage.CloudDiskRequest{
				Region:       storagePool.RegionCode,
				Az:           []string{storagePool.AzCode},
				ResourcePool: storagePool.Name,
			}
			cloudDiskReq.PageNo = 1
			cloudDiskReq.PageSize = 1
			ebsApiResponse, err := bs.GetCloudDiskList(cloudDiskReq)
			if err != nil {
				BlockReData.CloudDiskNumber = 0
				BlockReData.CloudDiskErrNumber = 0
			} else {
				BlockReData.CloudDiskNumber = ebsApiResponse.TotalCount
				BlockReData.CloudDiskErrNumber = GetCloudDiskErrNum(ebsApiResponse.DataList)
			}

			// data, err := bs.GetPoolDiskList(storagePool.RegionCode, storagePool.AzCode, storagePool.Name, 1, 10, []string{}, []string{})
			// if err != nil {
			// 	BlockReData.CloudDiskNumber = 0
			// } else {
			// 	BlockReData.CloudDiskNumber = data.TotalCount
			// }
			BlockReDataList = append(BlockReDataList, BlockReData)
		}
	}

	return BlockReDataList, nil
}

func GetCloudDiskErrNum(list []storage.CloudDiskData) int {
	cnt := 0
	for _, cdisk := range list {
		if strings.Contains(cdisk.UseStatus, "error") {
			cnt++
		}
	}
	return cnt
}

func (bs *BlockStoragePoolService) GetPoolDiskList(regionCode, poolName string, pageNo, pageSize int, azCode, state, cloudType []string) (*storage.BlockStoragePoolDisk, error) {
	blockStoragePoolDisk := new(storage.BlockStoragePoolDisk)
	//cloudTypeN := poolName //等存储有了那么就做资源池名称来

	cloudDiskReq := storage.CloudDiskRequest{
		Region:           regionCode,
		Az:               azCode,
		ResourcePoolType: cloudType,
		ResourcePool:     poolName,
		UseStatus:        state,
	}
	cloudDiskReq.PageNo = pageNo
	cloudDiskReq.PageSize = pageSize
	ebsApiResponse, err := bs.GetCloudDiskList(cloudDiskReq)
	if err != nil {
		return nil, err
	}
	//klog.Infof("ebsapi response: %+v", ebsApiResponse)
	blockStoragePoolDisk.TotalCount = ebsApiResponse.TotalCount
	for _, volume := range ebsApiResponse.DataList {
		tenant, err := GetRedisTenantMessage(volume.TenantId)
		if err != nil {
			return nil, err
		}
		blockStoragePoolDisk.DataList = append(blockStoragePoolDisk.DataList, storage.DiskDetail{
			Name:       volume.Name,             //volume.VolumeName,
			Id:         volume.InstanceId,       //volume.VolumeId,
			UseStatus:  volume.UseStatus,        ////volume.VolumeState,
			Size:       volume.Size,             //volume.VolumeSize,
			Type:       volume.ResourcePoolType, //volume.VolumeType,
			Region:     volume.Region,           //regionData.RegionName,
			Zone:       volume.Az,               //volume.GetAZByOurWay().AZName, //volume.Zone,
			TenantId:   volume.TenantId,         //.UserId,
			TenantName: tenant.Name,
			HostId:     volume.VmId,
			HostName:   volume.Vm,         //vmDetail.HostName,
			CreateTime: volume.CreateTime, //DateTimeToTimestamp(volume.CreateTime),
		})
	}

	//sort
	//默认时间倒序
	lessFunc := func(i, j int) bool {
		return blockStoragePoolDisk.DataList[i].CreateTime > blockStoragePoolDisk.DataList[j].CreateTime
	}
	sort.Slice(blockStoragePoolDisk.DataList, lessFunc)
	return blockStoragePoolDisk, nil
}

func (bs *BlockStoragePoolService) GetEBSDiskList(ebsRequest EBSAPIRequest) (*EBSAPIResponse, error) {
	if ebsRequest.Region != "all" {
		// ds := DgraphService{
		// 	Code:  "regionCode",
		// 	Value: ebsRequest.Region,
		// }
		region, err := basicdao.GetRegion(basicdao.Region{
			RegionCode: strings.ToLower(ebsRequest.Region),
		})
		if err != nil {
			return nil, err
		}
		ebsRequest.Region = region.RegionCodeAggregate
	}
	//  offset start from 0
	v, err := query.Values(ebsRequest)
	if err != nil {
		return nil, err
	}
	url := ""
	if len(v.Encode()) > 0 {
		url = fmt.Sprintf("%s/mq?Action=SearchVolumes&%s", bs.EBSAddr, v.Encode())
	} else {
		url = fmt.Sprintf("%s/mq?Action=SearchVolumes", bs.EBSAddr)
	}
	klog.Infoln("DEBUG - cloud products vm api  - ", url)
	b, err := bs.HttpClient.SimpleHttpGet(url)
	if err != nil {
		return nil, err
	}
	var ebsAPIResponse EBSAPIResponse
	err = json.Unmarshal(b, &ebsAPIResponse)
	return &ebsAPIResponse, err
}

func (bs *BlockStoragePoolService) GetPoolStock(poolName string, pageNo, pageSize int) (*storage.BlockStoragePoolStock, error) {
	b, err := bs.HttpClient.SimpleHttpGet(fmt.Sprintf("%s/%s", bs.StorageStateAddr, poolName))
	if err != nil {
		return nil, err
	}
	storageStateResp := &StorageStateResponse{}
	err = json.Unmarshal(b, storageStateResp)
	if err != nil {
		return nil, err
	}
	//klog.Infof("storageState response: %+v", storageStateResp)
	res := &storage.BlockStoragePoolStock{}
	var usedPercent int
	if storageStateResp.TotalGB == 0 {
		usedPercent = 0
	} else {
		usedPercent = storageStateResp.UsedGB / storageStateResp.TotalGB
	}

	res.DataList = append(res.DataList, storage.BlockStockDetail{
		Region:           "", // instance的region
		StorageType:      "", // instance的存储类型
		ResourcePoolName: poolName,
		Total:            storageStateResp.TotalGB,
		Free:             storageStateResp.TotalGB - storageStateResp.UsedGB,
		UsedPercent:      usedPercent,
	})
	res.TotalCount = len(res.DataList)
	res.PageNo = pageNo
	res.PageSize = pageSize
	return res, nil
}

// 获取块存储资源绑定云硬盘
func (bs *BlockStoragePoolService) GetBlockStoragePool(blockStoragePoolQuery storage.BlockStoragePoolQuery) ([]storage.BlockRe, error) {

	var BlockReDataList []storage.BlockRe
	spList := GetPoolList()
	for _, storagePool := range spList {
		if (storagePool.StorageType == "ebs") &&
			(blockStoragePoolQuery.RegionCode == "all" || storagePool.RegionCode == blockStoragePoolQuery.RegionCode) &&
			(len(blockStoragePoolQuery.AzCode) <= 0 || BoolTagInArray(blockStoragePoolQuery.AzCode, storagePool.AzCode)) &&
			(blockStoragePoolQuery.Name == "" || storagePool.Name == blockStoragePoolQuery.Name) &&
			(len(blockStoragePoolQuery.ResourcePool) < 1 || BoolTagInArray(blockStoragePoolQuery.ResourcePool, storagePool.ResourcePool)) {
			var BlockReData storage.BlockRe
			BlockReData.Id = storagePool.Id
			BlockReData.Name = storagePool.Name
			BlockReData.RegionCode = storagePool.RegionCode
			BlockReData.RegionName = storagePool.RegionName
			BlockReData.AzName = storagePool.AzName
			BlockReData.ResourcePool = storagePool.ResourcePool

			BlockReDataList = append(BlockReDataList, BlockReData)
		}
	}

	return BlockReDataList, nil
}
func (bs *BlockStoragePoolService) GetCloudDiskListForStorage(cloudDiskReq storage.CloudDiskRequest) (*storage.CloudDiskResult, error) {
	useStatus := ""
	volumeType := ""
	if len(cloudDiskReq.UseStatus) > 0 {
		useStatus = cloudDiskReq.UseStatus[0]
	}

	if len(cloudDiskReq.ResourcePoolType) > 0 {
		volumeType = cloudDiskReq.ResourcePoolType[0]
	}
	ebsAPIRequest := EBSAPIRequest{
		VolumeId:    cloudDiskReq.InstanceId,
		UserId:      cloudDiskReq.TenantId,
		VolumeState: useStatus,
		VolumeType:  volumeType,
	}
	if cloudDiskReq.Region != "all" {
		ebsAPIRequest.Region = cloudDiskReq.Region
	}
	cloudDiskReq.PageSize = 100
	cloudDiskReq.PageNo = 1
	var (
		//ebsAPIResp *EBSAPIResponse
		//EBSVolumes      = make(map[string]EBSVolume)
		ebsVolumeDt []ebs.Volume
		//UserIds         = make(map[string]struct{})
		UserIds []string
		//DataTotal       int
		err             error
		cloudDiskResult = &storage.CloudDiskResult{}
	)
	UserIds = keyStone.GetUserIds()
	//cloudDiskResult.DataTotal = DataTotal
	regionDataMap, _ := basicdao.GetRegionMap(basicdao.Region{})
	azDataMap, _ := basicdao.GetAzMap(basicdao.Az{})
	if len(UserIds) > 0 {
		var uids []string
		for _, uid := range UserIds {
			uids = append(uids, uid)
			for _, region := range regionDataMap {
				result := ebs.GetCloudDiskDetailFromApi(uid, region.RegionCode, bs.EBSAddr)
				if len(result.Volumes) > 0 {
					ebsVolumeDt = append(ebsVolumeDt, result.Volumes...)
				}
			}
		}
		keyStone.GetUserList(uids)
	}
	for _, volume := range ebsVolumeDt {
		regionEntity := regionDataMap[volume.Region]
		azEntity := azDataMap[volume.AvailabilityZone]
		mountPoint := ""
		var vmDetail = aggregate.VmDetail{}
		if volume.InstanceId != "" {
			vmDetail, _ = aggregate.GetAggregateVm(volume.InstanceId)
		}

		//获取资源池绑定资源池
		resourPool := []string{strings.ToLower(volume.VolumeType)}
		blockStoragePoolQuery := storage.BlockStoragePoolQuery{
			RegionCode: volume.Region,
			//多az环境，只有A区能查到，其他区查不到数据
			//AzCode:       []string{volume.AvailabilityZone},
			ResourcePool: resourPool,
		}
		blockRe := storage.BlockRe{}
		var storagePoolList []storage.BlockRe
		storagePoolList, err = bs.GetBlockStoragePool(blockStoragePoolQuery)
		if err == nil && len(storagePoolList) > 0 {
			blockRe = storagePoolList[0]
		}
		if len(volume.Attachments) > 0 {
			mountPoint = volume.Attachments[0].MountPoint
		}
		cloudDiskResult.DataList = append(cloudDiskResult.DataList, storage.CloudDiskData{
			Name:             volume.VolumeName,
			InstanceId:       volume.VolumeId,
			Region:           regionEntity.RegionName, //"上海二区",           //regionData.RegionName,
			Az:               azEntity.AzName,         //"可用区A",                  //volume.GetAZByOurWay().AZName,
			RegionCode:       volume.Region,           //regionEntity.RegionCode, //"cn-shanghai-2",  //regionData.RegionCode,
			AzCode:           volume.AvailabilityZone, //"cn-shanghai-2a",        //volume.GetAZByOurWay().AZCode,
			ResourcePool:     blockRe.Name,            // volume.VolumeType,
			ResourcePoolType: blockRe.ResourcePool,    // volume.VolumeType,
			TenantId:         volume.UserId,
			UseStatus:        volume.VolumeStatus,
			CreateTime:       DateTimeToTimestamp(volume.CreateTime),
			Size:             volume.Size,
			VmId:             volume.InstanceId,
			Vm:               vmDetail.VmName,
			MountPoint:       mountPoint,
		})
	}
	cloudDiskResult.TotalCount = len(cloudDiskResult.DataList)
	return cloudDiskResult, nil
}

// 获取云硬盘数据并分页
func (bs *BlockStoragePoolService) GetCloudDiskList(cloudDiskReq storage.CloudDiskRequest) (*storage.CloudDiskResult, error) {
	cloudDiskResult := &storage.CloudDiskResult{}
	list, total, err := blockstorage.ListPage(context.Background(), cloudDiskReq)
	if err != nil {
		return nil, err
	}

	//list to cloudDiskList
	cloudDiskList := []storage.CloudDiskData{}
	for _, v := range list {
		cloudDiskList = append(cloudDiskList, storage.CloudDiskData{
			Name:             v.Name,
			InstanceId:       v.InstanceID,
			Region:           v.Region,
			RegionCode:       v.RegionCode,
			Az:               v.Az,
			AzCode:           v.AzCode,
			ResourcePool:     v.ResourcePool,
			ResourcePoolType: v.ResourcePoolType,
			UseStatus:        v.UseStatus,
			TenantId:         v.TenantID,
			TenantName:       v.TenantName,
			Vm:               v.VM,
			VmId:             v.VMID,
			CreateTime:       int64(v.CreateTime),
			Size:             int(v.Size),
			MountPoint:       v.MountPoint,
		})
	}
	cloudDiskResult.DataList = cloudDiskList
	cloudDiskResult.TotalCount = total
	return cloudDiskResult, nil
}

// 获取全部云硬盘数据
func (bs *BlockStoragePoolService) GetCloudDiskListAll(cloudDiskReq storage.CloudDiskRequest) ([]storage.CloudDiskData, error) {
	cloudDiskReq.PageNo = 1
	cloudDiskReq.PageSize = math.MaxInt
	result, err := bs.GetCloudDiskList(cloudDiskReq)
	if err != nil {
		return nil, err
	}
	return result.DataList, nil
}

// GetBlockStorageCount 获取块存储使用中、异常、挂载中数量
func (bs *BlockStoragePoolService) GetBlockStorageCount(cloudDiskReq storage.CloudDiskRequest) ([]storage.CloudDiskData, error) {
	cloudDiskReq.PageNo = 1
	cloudDiskReq.PageSize = math.MaxInt
	result, err := bs.GetCloudDiskList(cloudDiskReq)
	if err != nil {
		return nil, err
	}
	return result.DataList, nil
}

func (bs *BlockStoragePoolService) GetRegionEntity(regionList []basicdao.Region, region string) basicdao.Region {
	regionData := basicdao.Region{}
	count := len(regionList)
	for i := 0; i < count; i++ {
		if regionList[i].RegionCode == region || regionList[i].RegionCodeAggregate == region {
			return regionList[i]
		}
	}
	return regionData
}
func (bs *BlockStoragePoolService) GetAzEntity(azList []basicdao.Az, az string) basicdao.Az {
	azData := basicdao.Az{}
	count := len(azList)
	for i := 0; i < count; i++ {
		if azList[i].AzCode == az || azList[i].AzCodeAggregate == az {
			return azList[i]
		}
	}
	return azData
}
func (bs *BlockStoragePoolService) GetCloudDiskDetail(insId string) (*storage.CloudDiskDataDetail, error) {
	// ebsAPIRequest := EBSAPIRequest{
	// 	VolumeId: insId,
	// }
	// ebsAPIResponse, err := bs.GetEBSDiskList(ebsAPIRequest)
	// if err != nil {
	// 	return nil, err
	// }
	cloudDiskDetail := &storage.CloudDiskDataDetail{}
	cloudDiskReq := storage.CloudDiskRequest{
		InstanceId: insId,
		Region:     "all",
		//Az:         "all",
	}
	cloudDiskReq.PageNo = 1
	cloudDiskReq.PageSize = 1
	ebsApiResponse, err := bs.GetCloudDiskList(cloudDiskReq)
	if err != nil {
		return cloudDiskDetail, err
	}
	if len(ebsApiResponse.DataList) < 1 {
		//return cloudDiskDetail, errors.New("没有数据")
		return cloudDiskDetail, nil
	}

	ebsVolume := ebsApiResponse.DataList[0]
	// regionData := ebsVolume.GetRegionByOurWay()
	// vmDetail, _ := GetOneVMDetail(regionData.RegionCode, []string{ebsVolume.VmId}, strconv.Itoa(ebsVolume.UserId))
	tenant, err := GetRedisTenantMessage(ebsVolume.TenantId)
	if err != nil {
		return cloudDiskDetail, err
	}
	cloudDiskDetail = &storage.CloudDiskDataDetail{
		CloudDiskData: storage.CloudDiskData{
			Name:             ebsVolume.Name,
			InstanceId:       ebsVolume.InstanceId,
			Region:           ebsVolume.Region,
			Az:               ebsVolume.Az,
			ResourcePool:     ebsVolume.ResourcePool,
			ResourcePoolType: ebsVolume.ResourcePoolType,
			TenantId:         ebsVolume.TenantId,
			TenantName:       tenant.Name,
			CreateTime:       ebsVolume.CreateTime,
			UseStatus:        ebsVolume.UseStatus,
			Size:             ebsVolume.Size,
			VmId:             ebsVolume.VmId,
			Vm:               ebsVolume.Vm,
		},
		//ExpireTime: DateTimeToTimestamp(ebsVolume..ServiceEndTime),
	}
	return cloudDiskDetail, nil
}

// 获取云产品块存储概览
func (bs *BlockStoragePoolService) GetCloudDiskOverviewData(cloudDiskReq storage.CloudDiskRequest) (storage.CloudDiskOverview, error) {
	var cloudDiskOverview storage.CloudDiskOverview
	// cloudDiskOverview.CloudDiskOverview = make(map[string]int)
	// cloudDiskOverview.StorageTypeOverview = make(map[string]int)
	//DistributedOverview := make(map[string][2]int)
	//dbov := []storage.DistributedHistogramOverView{}
	ssd3HistogramOverView := []storage.HistogramOverView{}
	// ssd2HistogramOverView := []storage.HistogramOverView{}
	// sata2HistogramOverView := []storage.HistogramOverView{}
	ehddHistogramOverView := []storage.HistogramOverView{}
	cloudDiskTotalCount := 0
	cloudDiskUsedCount := 0
	cloudDiskAvailableCount := 0
	cloudDiskErrorCount := 0

	ssd3Count := 0
	ehddCount := 0

	cloudDiskList, _ := bs.GetCloudDiskListAll(cloudDiskReq)
	for _, volume := range cloudDiskList {
		if volume.ResourcePool == "ssd3.0" {
			ssd3Count++
			ssd3HistogramOverView, _ = bs.CloudDiskOverviewAdd(ssd3HistogramOverView, volume)
			// exist := false
			// for i := range ssd3HistogramOverView {
			// 	if ssd3HistogramOverView[i].Region == volume.RegionCode && ssd3HistogramOverView[i].Az == volume.AzCode {
			// 		ssd3HistogramOverView[i].Value++
			// 		exist = true
			// 	}
			// }
			// if !exist {
			// 	ssd3HistogramOverView = append(ssd3HistogramOverView, storage.HistogramOverView{
			// 		Name:   volume.Region + volume.Az,
			// 		Az:     volume.AzCode,
			// 		Region: volume.RegionCode,
			// 		Value:  1,
			// 	})
			// }
		} else if volume.ResourcePool == "ehdd" {
			ehddCount++
			ehddHistogramOverView, _ = bs.CloudDiskOverviewAdd(ehddHistogramOverView, volume)
			// exist := false
			// for i := range ehddHistogramOverView {
			// 	if ehddHistogramOverView[i].Region == volume.RegionCode && ehddHistogramOverView[i].Az == volume.AzCode {
			// 		ehddHistogramOverView[i].Value++
			// 		exist = true
			// 	}
			// }
			// if !exist {
			// 	ehddHistogramOverView = append(ehddHistogramOverView, storage.HistogramOverView{
			// 		Name:   volume.Region + volume.Az,
			// 		Az:     volume.AzCode,
			// 		Region: volume.RegionCode,
			// 		Value:  1,
			// 	})
			// }
		}
		if volume.UseStatus == "in-use" {
			cloudDiskUsedCount++
		} else if volume.UseStatus == "available" {
			cloudDiskAvailableCount++
		} else if volume.UseStatus == "error" {
			cloudDiskErrorCount++
		}
		cloudDiskTotalCount++
	}
	cloudDiskOverview.CloudDiskOverview = append(cloudDiskOverview.CloudDiskOverview, storage.OverView{
		Name:  "块存储总数量",
		Code:  "",
		Value: cloudDiskTotalCount,
	})
	cloudDiskOverview.CloudDiskOverview = append(cloudDiskOverview.CloudDiskOverview, storage.OverView{
		Name:  "使用中",
		Code:  "in-use",
		Value: cloudDiskUsedCount,
	})
	cloudDiskOverview.CloudDiskOverview = append(cloudDiskOverview.CloudDiskOverview, storage.OverView{
		Name:  "待挂载",
		Code:  "available",
		Value: cloudDiskAvailableCount,
	})
	cloudDiskOverview.CloudDiskOverview = append(cloudDiskOverview.CloudDiskOverview, storage.OverView{
		Name:  "错误",
		Code:  "error",
		Value: cloudDiskErrorCount,
	})
	cloudDiskOverview.StorageTypeOverview = append(cloudDiskOverview.StorageTypeOverview, storage.OverView{
		Name:  "云硬盘3.0(SSD)",
		Code:  "ssd3.0",
		Value: ssd3Count,
	})
	// cloudDiskOverview.StorageTypeOverview = append(cloudDiskOverview.StorageTypeOverview, storage.OverView{
	// 	Name:  "云硬盘2.0(SSD)",
	// 	Code:  "ssd2.0",
	// 	Value: ssd2Count,
	// })
	// cloudDiskOverview.StorageTypeOverview = append(cloudDiskOverview.StorageTypeOverview, storage.OverView{
	// 	Name:  "云硬盘2.0(SATA)",
	// 	Code:  "sata2.0",
	// 	Value: sata2Count,
	// })

	cloudDiskOverview.StorageTypeOverview = append(cloudDiskOverview.StorageTypeOverview, storage.OverView{
		Name:  "高效云盘",
		Code:  "ehdd",
		Value: ehddCount,
	})
	//cloudDiskOverview.DistributedOverview = dbov
	cloudDiskOverview.DistributedOverview = append(cloudDiskOverview.DistributedOverview, storage.DistributedHistogramOverView{
		Name:        "云硬盘3.0(SSD)",
		Code:        "ssd3.0",
		Distributed: ssd3HistogramOverView,
	})
	cloudDiskOverview.DistributedOverview = append(cloudDiskOverview.DistributedOverview, storage.DistributedHistogramOverView{
		Name:        "高效云盘",
		Code:        "ehdd",
		Distributed: ehddHistogramOverView,
	})
	return cloudDiskOverview, nil

}

// 操作柱状图，组装
func (bs *BlockStoragePoolService) CloudDiskOverviewAdd(histogramList []storage.HistogramOverView, cloudDisk storage.CloudDiskData) ([]storage.HistogramOverView, error) {
	exist := false
	for i := range histogramList {
		if histogramList[i].Region == cloudDisk.RegionCode && histogramList[i].Az == cloudDisk.AzCode {
			histogramList[i].Value++
			exist = true
		}
	}
	if !exist {
		histogramList = append(histogramList, storage.HistogramOverView{
			Name:   cloudDisk.Region + cloudDisk.Az,
			Az:     cloudDisk.AzCode,
			Region: cloudDisk.RegionCode,
			Value:  1,
		})
	}
	return histogramList, nil
}

// 获取本地盘列表信息
func (bs *BlockStoragePoolService) GetVmVolumes(userName, vmId, volumeCategory string) (*storage.BlockStoragePoolDisk, error) {
	blockStoragePoolDisk := new(storage.BlockStoragePoolDisk)
	ebsAPIRequest := EBSAPIRequest{
		VmId:           vmId,
		UserId:         userName,
		VolumeCategory: volumeCategory,
	}

	ebsAPIResp, err := bs.GetEBSDiskList(ebsAPIRequest)
	if err != nil {
		return nil, err
	}
	//blockStoragePoolDisk.TotalCount = ebsApiResponse.Total
	for _, volume := range ebsAPIResp.Volumes {
		//regionData := volume.GetRegionByOurWay()

		blockStoragePoolDisk.DataList = append(blockStoragePoolDisk.DataList, storage.DiskDetail{
			Name:      volume.VolumeName,
			Id:        volume.VolumeId,
			UseStatus: volume.VolumeState,
			Size:      volume.VolumeSize,
			Type:      volume.VolumeType,
			//Region:     regionData.RegionName,
			//Zone:       volume.GetAZByOurWay(), //volume.Zone,
			TenantId: strconv.Itoa(volume.UserId),
			HostId:   volume.VmId,
			//HostName:   vmDetail.HostName,
			CreateTime: DateTimeToTimestamp(volume.CreateTime),
		})
	}
	return blockStoragePoolDisk, nil

}

// 从API中获取云硬盘信息
func (bs *BlockStoragePoolService) GetCloudDiskDetailFromApi(volumelQuery VolumeEntityAPIRequest) (VolumeEntityAPIResponse, error) { //(aggregate.AggregateOverview, error) {

	//klog.Info("vmDetailQuery:", volumelQuery)
	volumeDt := VolumeEntityAPIResponse{}
	if volumelQuery.Region == "" || volumelQuery.VolumeId == "" || volumelQuery.UserId == "" {
		return volumeDt, errors.New("数据有误")
	}
	//curl -X GET 'http://ebs.inner.sdns.cqpcloud.cn/?Action=DescribeVolumes&Version=2016-03-04&VolumeId.1=1fdee1df-fcb8-4f76-9ebf-aaf612943e1a' -H 'X-KSC-ACCOUNT-ID: 180000053' -H 'X-KSC-REGION: cn-shanghai-2'  -H 'Accept: application/json' -H 'X-KSC-SOURCE:ebs' -H 'X-KSC-REQUEST-ID: 6cbdfcb0-f62a-46a9-8284-1e8543810547'
	//novaInnerApi := "http://" + novaIp + "/?Action=" + Action + "&Version=" + Version
	//https://wiki.op.ksyun.com/pages/viewpage.action?pageId=50201472
	volumeApi := fmt.Sprintf("%s/?Action=DescribeVolumes&Version=2016-03-04&VolumeId.1=%s", bs.EBSAddr, volumelQuery.VolumeId)

	//klog.Infof("Simple get volumeApi: %s", volumeApi)
	request, err := http.NewRequest("GET", volumeApi, nil)

	request.Header.Add("X-KSC-ACCOUNT-ID", volumelQuery.UserId)
	request.Header.Add("X-KSC-REGION", volumelQuery.Region)
	request.Header.Add("Accept", "application/json")
	//request.Header.Add("X-KSC-REQUEST-ID", RequesId)
	request.Header.Add("X-KSC-REQUEST-ID", uuid.New().String())
	//request.Header.Add("X-KSC-SOURCE", "ebs")
	request.Header.Add("X-KSC-SOURCE", "user")
	if err != nil {
		return volumeDt, err

	}
	//处理返回结果
	client := &http.Client{}
	response, _ := client.Do(request)
	bt, _ := ioutil.ReadAll(response.Body)
	json.Unmarshal(bt, &volumeDt)
	//klog.Info("response.Body:", response.Body)
	//klog.Info("volumeDt:", volumeDt)
	defer response.Body.Close()
	return volumeDt, err
}

// 从API中获取云硬盘信息
func (bs *BlockStoragePoolService) GetCloudDiskDetailFromApiTT(volumelQuery VolumeEntityAPIRequest) (VolumeEntityAPIResponse, error) { //(aggregate.AggregateOverview, error) {

	//klog.Info("vmDetailQuery:", volumelQuery)
	volumeDt := VolumeEntityAPIResponse{}
	//curl -X GET 'http://ebs.inner.sdns.cqpcloud.cn/?Action=DescribeVolumes&Version=2016-03-04&VolumeId.1=1fdee1df-fcb8-4f76-9ebf-aaf612943e1a' -H 'X-KSC-ACCOUNT-ID: 180000053' -H 'X-KSC-REGION: cn-shanghai-2'  -H 'Accept: application/json' -H 'X-KSC-SOURCE:ebs' -H 'X-KSC-REQUEST-ID: 6cbdfcb0-f62a-46a9-8284-1e8543810547'
	//novaInnerApi := "http://" + novaIp + "/?Action=" + Action + "&Version=" + Version
	//https://wiki.op.ksyun.com/pages/viewpage.action?pageId=50201472
	volumeApi := fmt.Sprintf("%s/?Action=DescribeVolumes&Version=2016-03-04&VolumeId.1=%s", bs.EBSAddr, volumelQuery.VolumeId)

	//klog.Infof("Simple get volumeApi: %s", volumeApi)
	request, err := http.NewRequest("GET", volumeApi, nil)

	request.Header.Add("X-KSC-ACCOUNT-ID", volumelQuery.UserId)
	request.Header.Add("X-KSC-REGION", volumelQuery.Region)
	request.Header.Add("Accept", "application/json")
	request.Header.Add("X-KSC-REQUEST-ID", RequesId)
	request.Header.Add("X-KSC-SOURCE", "ebs")
	if err != nil {
		return volumeDt, err

	}
	//处理返回结果
	client := &http.Client{}
	response, _ := client.Do(request)
	bt, _ := ioutil.ReadAll(response.Body)
	json.Unmarshal(bt, &volumeDt)
	//klog.Info("response.Body:", response.Body)
	//klog.Info("volumeDt:", volumeDt)
	defer response.Body.Close()
	return volumeDt, err
}

// todo 获取资源池分片列表
func (bs *BlockStoragePoolService) GetPoolSliceStock(id, PageNo, PageSize int) ([]storagePool.StoragePoolSlice, error) {

	//获取资源池详情
	ebsInfo, _ := storagepool.Info(id)
	var poolSlice []storagePool.StoragePoolSlice

	if ebsInfo.StorageType == "ebs" {
		//获取资源池分片信息
		sp := StoragePool{
			Id:           id,
			Name:         ebsInfo.Name,
			StorageType:  ebsInfo.StorageType,
			ResourcePool: ebsInfo.Name,
			ClusterUrl:   ebsInfo.ClusterUrl,
			SliceUrl:     ebsInfo.SliceUrl,
			CreateTime:   ebsInfo.CreateTime.Unix(),
		}
		slice, err := sp.GetStoragePoolSliceByte()

		sliceList := []storagePool.EBSPollSlice{}
		err = json.Unmarshal(slice, &sliceList)
		if err != nil {
			klog.Infoln("sp.GetStoragePoolSliceByte() err:", err)
		}
		if sliceList == nil {
			klog.Infoln("Failed to obtain fragment information")
		}
		//更新到存储资源池分片信息
		fmt.Println("=====sliceList======", sliceList)

		for _, v := range sliceList {
			copies := strings.Split(v.Replicas, ",")
			copiesNum := len(copies)
			sliceInfo := storagePool.StoragePoolSlice{
				PoolId:     id,
				TabletName: v.TabletName,
				Replicas:   v.Replicas,
				CopyNum:    copiesNum,
				TableName:  v.TableName,
				TableId:    v.TableId,
			}
			poolSlice = append(poolSlice, sliceInfo)
		}
	}

	//
	//list, err := storagepool.SliceList(id, PageNo, PageSize)
	//if err != nil {
	//	klog.Infoln("storagepool.List() err:", err)
	//	return []storagePool.StoragePoolSlice{}, err
	//}

	return poolSlice, nil
}

//后续处理
// func (bs *BlockStoragePoolService) GetResourcePoolList(blockStoragePoolQuery storage.BlockStoragePoolQuery) ([]model.RegionData, error) {
// 	// 为创建的节点分配的uid将在resp.AssignedUids map中返回。
// 	//variables := map[string]string{"$id": assigned.Uids["blank-0"]}

// 	//variables := map[string]string{"$id": uid}
// 	filter:=`@filter(eq(resourcePoolStorageType,"ebs"))`
// 	filterList:=[]string{}
// 	filterList = append(filterList, `eq(hostRegionCode, %s)`)
// 	if blockStoragePoolQuery.RegionCode != "all" && blockStoragePoolQuery.RegionCode != "" {
// 		filterList = append(filterList, fmt.Sprintf(`eq(hostRegionCode, %s)`,blockStoragePoolQuery.RegionCode))
// 	}
// 	if blockStoragePoolQuery.AzCode != "all" && blockStoragePoolQuery.AzCode != "" {
// 		filterList = append(filterList, fmt.Sprintf(`eq(hostAzCode, %s)`,blockStoragePoolQuery.AzCode))
// 	}
// 	if blockStoragePoolQuery.Name != "all" && blockStoragePoolQuery.Name != "" {
// 		filterList = append(filterList, fmt.Sprintf(`eq(resourcePoolName, %s)`,blockStoragePoolQuery.Name))
// 	}
// 	if len(blockStoragePoolQuery.ResourcePool) > 0  {
// 		resourcePool:=strings.Join(blockStoragePoolQuery.ResourcePool," ")
// 		if strings.Trim(resourcePool, " ") != "" {
// 			filterList = append(filterList, fmt.Sprintf(`anyofterms(resourcePoolCode, %s)`,resourcePool))
// 		}

// 	}
// 	if len(filterList)>0{
// 		filter=fmt.Sprintf("%s ")
// 	}

// 	q := `{
// 		   resoucePool(func:type(resoucePool),orderasc:resourcePoolCode)
// 		    `
// 	if blockStoragePoolQuery.PageSize>0&& blockStoragePoolQuery.PageNo>0{
// 		q = fmt.Sprintf(`{
// 			resoucePool(func:type(resoucePool),orderasc:resourcePoolCode,offset:%d ,first:%d)

// 			 `,(blockStoragePoolQuery.PageNo-1)*blockStoragePoolQuery.PageSize,blockStoragePoolQuery.PageSize )
// 	}
// 	var BlockReDataList []storage.BlockRe
// 	for _, storagePool := range StoragePoolList {

// 		if (storagePool.StorageType == "ebs") &&
// 			(blockStoragePoolQuery.RegionCode == "all" || storagePool.RegionCode == blockStoragePoolQuery.RegionCode) &&
// 			(blockStoragePoolQuery.AzCode == "all" || storagePool.RegionCode == blockStoragePoolQuery.RegionCode) &&
// 			(blockStoragePoolQuery.Name == "" || storagePool.Name == blockStoragePoolQuery.Name) &&
// 			(len(blockStoragePoolQuery.ResourcePool) < 1 || BoolTagInArray(blockStoragePoolQuery.ResourcePool, storagePool.ResourcePool)) {
// 			var BlockReData storage.BlockRe
// 			BlockReData.Id = storagePool.Id
// 			BlockReData.Name = storagePool.Name
// 			BlockReData.RegionCode = storagePool.RegionCode
// 			BlockReData.RegionName = storagePool.RegionName
// 			BlockReData.AzName = storagePool.AzName
// 			BlockReData.ResourcePool = storagePool.ResourcePool
// 			hostList, err := storagePool.GetStoragePoolIps()
// 			if err != nil {
// 				BlockReData.HostNumber = 0
// 			} else {
// 				BlockReData.HostNumber = len(hostList.Address)
// 			}
// 			data, err := bs.GetPoolDiskList(storagePool.ResourcePool, 1, 10, "", storagePool.ResourcePool)
// 			if err != nil {
// 				BlockReData.CloudDiskNumber = 0
// 			} else {
// 				BlockReData.CloudDiskNumber = data.TotalCount
// 			}
// 			BlockReDataList = append(BlockReDataList, BlockReData)
// 		}
// 	}
// 	var dgraphRegionData model.DgraphRegionData
// 	q := `{
// 		region(func:eq(` + h.Code + `,"` + h.Value + `")){
// 			uid
// 			regionCode
// 			regionCodeAggregate
// 			regionName
// 			}
// 		}`
// 	klog.Infof(q)
// 	resp, err := dgraphClient.Dgraph.NewTxn().Query(context.Background(), q)
// 	if err != nil {
// 		klog.Error("Query dgraph error...")
// 		//fmt.Println(err)
// 		return dgraphRegionData.Region, err
// 	}
// 	klog.Infof(resp.String())
// 	e := json.Unmarshal(resp.Json, &dgraphRegionData)
// 	if e != nil {
// 		klog.Error("json unmarshal error...." + e.Error())
// 	}
// 	return dgraphRegionData.Region, err
// }

func DateTimeToTimestamp(datetime string) int64 {
	t, err := time.Parse("2006-01-02 15:04:05", datetime)
	if err != nil {
		return time.Now().Unix()
	}
	return t.Unix()
}

// http://ebs.inner.sdns.cqpcloud.cn/?Action=DescribeVolumes&Version=2016-03-04&VolumeId.1=0d115d95-07e3-44ab-a02c-b4ff13ba7424
//curl -X GET 'http://ebs.inner.sdns.cqpcloud.cn/?Action=DescribeVolumes&Version=2016-03-04' -H 'X-KSC-ACCOUNT-ID: 180000053' -H 'X-KSC-REGION: cn-shanghai-2'  -H 'Accept: application/json' -H 'X-KSC-SOURCE:ebs' -H 'X-KSC-REQUEST-ID: 6cbdfcb0-f62a-46a9-8284-1e8543810547'
//curl -X GET 'http://ebs.inner.sdns.cqpcloud.cn/?Action=DescribeVolumes&Version=2016-03-04&VolumeId.1=1fdee1df-fcb8-4f76-9ebf-aaf612943e1a' -H 'X-KSC-ACCOUNT-ID: 180000053' -H 'X-KSC-REGION: cn-shanghai-2'  -H 'Accept: application/json' -H 'X-KSC-SOURCE:ebs' -H 'X-KSC-REQUEST-ID: 6cbdfcb0-f62a-46a9-8284-1e8543810547'
//curl -X GET '10.177.152.16/?Action=DescribeVolumes&Version=2016-03-04&VolumeId.1=1fdee1df-fcb8-4f76-9ebf-aaf612943e1a' -H 'X-KSC-ACCOUNT-ID: 180000053' -H 'X-KSC-REGION: cn-shanghai-2'  -H 'Accept: application/json' -H 'X-KSC-SOURCE:ebs' -H 'X-KSC-REQUEST-ID: 6cbdfcb0-f62a-46a9-8284-1e8543810547'
//curl -X GET 'http://ebs.inner.sdns.cqpcloud.cn/mq?Action=SearchVolumes&Version=2016-03-04&size=1398'

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/pkg/service/tengineResourcePool.go
```golang
package service

import (
	"luban-cmdb-api/pkg/models/netPoolModel"
)

// GetTenginePool 获取Tengine资源池
func GetTenginePool() (*netPoolModel.NetWorkResource, error) {

	netPoolList, err := getNetworkPool()
	if err != nil {
		return nil, err
	}

	//网络资源池的Hosts字段底层是一个[]string类型，返回一个资源池再遍历所有的Host
	var tenginePool = new(netPoolModel.NetWorkResource)
	for i := range netPoolList {
		if netPoolList[i].PoolType == "Tengine" {
			tenginePool = &netPoolList[i]
		}
	}

	return tenginePool, nil
}

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/pkg/service/common.go
```golang
package service

import (
	"context"
	"encoding/json"
	"fmt"
	"luban-cmdb-api/pkg/gredis"
	"luban-cmdb-api/pkg/models/netPoolModel"
	"strconv"
	"strings"
	"time"

	"k8s.io/klog/v2"
)

func BoolTagInArray(slice []string, tag string) bool {
	for _, item := range slice {
		if item == tag {
			return true
		}
	}
	return false
}
func BoolTagInArrayInt(slice []int, tag int) bool {
	for _, item := range slice {
		if item == tag {
			return true
		}
	}
	return false
}

func interfaceToValue(value interface{}) string {
	res := ""
	switch value.(type) {
	case string:
		// 将interface转为string字符串类型
		op, ok := value.(string)
		if ok {
			res = op
		}
	case int32:
		// 将interface转为int32类型
		op, ok := value.(int32)
		if ok {
			res = string(op)
		}
	case int:
		// 将interface转为int32类型
		op, ok := value.(int)
		if ok {
			res = strconv.Itoa(op)
		}
	case int64:
		// 将interface转为int64类型
		op, ok := value.(int64)
		if ok {
			res = string(rune(op))
		}
	case float64:
		// 将interface转为int64类型
		op, ok := value.(float64)
		if ok {
			res = strconv.FormatFloat(op, 'f', 2, 64)
		}
	default:
		fmt.Println("unknown")
	}
	return res
}

func SubStr(str, start string) string {
	n := strings.Index(str, start)
	if n == -1 {
		n = len(str)
	}
	str = string([]byte(str)[0:n])
	return str
}

//getNetworkPool 获取网络资源池列表
func getNetworkPool() ([]netPoolModel.NetWorkResource, error) {
	ctx, cancel := context.WithTimeout(context.Background(), time.Second*5)
	defer cancel()

	//从redis中取出所有网络资源池对象
	rs, err := gredis.HGetAll(ctx, gredis.NetWorkPoolKey)
	if err != nil {
		klog.Error("network resource pool read from redis failure:", err.Error())
		return nil, err
	}

	//反序列化成结构类型
	var resultStr []string
	for _, v := range rs {
		resultStr = append(resultStr, v)
	}
	poolStr := "[" + strings.Join(resultStr, ",") + "]" //构造成json字符串格式
	var poolList []netPoolModel.NetWorkResource
	err = json.Unmarshal([]byte(poolStr), &poolList)
	if err != nil {
		klog.Errorf("Unmarshal network pool list failed, error: %s", err)
		return nil, err
	}
	return poolList, nil
}

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/pkg/service/basic.go
```golang
package service

import (
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"github.com/zeromicro/go-zero/core/logx"
	"gorm.io/gorm/clause"
	"luban-cmdb-api/pkg/dao"
	basicdao "luban-cmdb-api/pkg/dao/basic"
	businessManagementDao "luban-cmdb-api/pkg/dao/businessManagement"
	"luban-cmdb-api/pkg/dao/cabidao"
	labdao "luban-cmdb-api/pkg/dao/lab"
	serverdao "luban-cmdb-api/pkg/dao/server"
	"luban-cmdb-api/pkg/dao/switchdao"
	"luban-cmdb-api/pkg/gredis"
	"luban-cmdb-api/pkg/models/aggregate"
	"luban-cmdb-api/pkg/models/basic"
	hardwares "luban-cmdb-api/pkg/models/hardware"
	labmodel "luban-cmdb-api/pkg/models/lab"
	"luban-cmdb-api/pkg/models/server"
	switchMachine "luban-cmdb-api/pkg/models/switch"
	"strconv"
	"strings"
	"time"

	eipModel "luban-cmdb-api/pkg/models/eip"
	eipSvc "luban-cmdb-api/pkg/service/eip"

	"github.com/dgraph-io/dgo/v200"
	"github.com/go-redis/redis/v8"
	"k8s.io/klog/v2"
)

type AggregateInterface interface {
	GetAggregateAll() (aggregate.AggregatesResult, error)
	GetAggregateAllForPage(aggregatesListQuery aggregate.AggregatesListQuery) ([]aggregate.Aggregates, error)
}

type BasicService struct {
	DgraphClient       *dgo.Dgraph
	HttpClient         HttpClient
	AggregateInterface AggregateInterface
}

func NewBasicService(DgraphClient *dgo.Dgraph, aggregateService *AggregateService) *BasicService {
	return &BasicService{
		DgraphClient:       DgraphClient,
		HttpClient:         &SimpleHttpClient{},
		AggregateInterface: aggregateService,
	}
}

//获取region、az、lab级联
func (h *BasicService) GetRegions(regionMap, azMap, labMap map[string]interface{}) ([]basic.Region, error) {
	regionResult := []basic.Region{}
	regions, err := basicdao.GetRegionList(basicdao.Region{})
	if err != nil {
		return []basic.Region{}, err
	}
	//azs, err := basicdao.GetAzList(basicdao.Az{})
	//azMap := make(map[string]interface{})
	azs, err := basicdao.GetAzListByMap(azMap)
	if err != nil {
		return []basic.Region{}, err
	}
	//labs, err := labdao.GetLabList(labdao.Lab{})GetLabListByLabMap
	//labMap := make(map[string]interface{})
	labs, err := labdao.GetLabListByLabMap(labMap)
	if err != nil {
		return []basic.Region{}, err
	}
	regionLen := len(regions)

	azLen := len(azs)
	azLabs := []basic.Lab{}
	for i := 0; i < regionLen; i++ {
		azResult := []basic.Az{}
		for j := 0; j < azLen; j++ {
			if regions[i].Id == azs[j].RegionId {
				labs, azLabs = LabForCicle(labs, azs[j].Id)
				azResult = append(azResult, basic.Az{
					AzCode:      azs[j].AzCode,
					AzName:      azs[j].AzName,
					AzId:        azs[j].Id,
					ContainLabs: azLabs,
				})
			}
		}
		regionResult = append(regionResult, basic.Region{
			RegionCode:          regions[i].RegionCode,
			RegionName:          regions[i].RegionName,
			RegionCodeAggregate: regions[i].RegionCodeAggregate,
			ContainAzs:          azResult,
		})
	}
	return regionResult, err
}

//防止lab太多影响效率 进行数据遍历次数缩减
func LabForCicle(labList []labdao.Lab, azId int) (cicleLab []labdao.Lab, azLabs []basic.Lab) {
	j := 0
	ciLen := len(labList)
	if ciLen < 1 {
		return labList, []basic.Lab{}
	}
	for i := 0; i < ciLen; i++ {
		if azId == labList[i].AzId {
			azLabs = append(azLabs, basic.Lab{
				Uid:     labList[i].Id,
				LabCode: labList[i].LabCode,
				LabName: labList[i].LabName,
			})
		} else {
			labList[j] = labList[i]
			j++
		}
	}
	return labList[:j], azLabs
}

func (h *BasicService) GetRegionsForSearch(region string, az []string) ([]basic.Region, error) {
	regionMap := make(map[string]interface{})
	azMap := make(map[string]interface{})
	labMap := make(map[string]interface{})
	if region != "all" {
		regionMap["region_code"] = region
	}
	azMap["az_code"] = az
	return h.GetRegions(regionMap, azMap, labMap)
}

//防止rack太多影响效率 进行数据遍历次数缩减
func RackForCicle(rackList []basicdao.RackMysql, cabinetId int) (cicleRack []basicdao.RackMysql, cabinetRacks []basic.Rack) {
	j := 0
	ciLen := len(rackList)
	if ciLen < 1 {
		return //rackList, []basic.Lab{}
	}
	for i := 0; i < ciLen; i++ {
		if cabinetId == rackList[i].CabinetId {
			cabinetRacks = append(cabinetRacks, basic.Rack{
				RackUid:  rackList[i].Id,
				RackName: rackList[i].RackName,
			})
		} else {
			rackList[j] = rackList[i]
			j++
		}
	}
	return rackList[:j], cabinetRacks
}

//防止cabinet太多影响效率 进行数据遍历次数缩减
func CabinetForCicle(cabinetList []basicdao.CabinetMysql, rackList []basicdao.RackMysql, roomId int) (cicleCabinet []basicdao.CabinetMysql, cicleRack []basicdao.RackMysql, roomCabinets []basic.Cabinet) {
	j := 0
	ciLen := len(cabinetList)
	if ciLen < 1 {
		return //rackList, []basic.Lab{}
	}
	for i := 0; i < ciLen; i++ {
		if roomId == cabinetList[i].RoomId {
			cabinetRacks := []basic.Rack{}
			rackList, cabinetRacks = RackForCicle(rackList, cabinetList[i].Id)
			roomCabinets = append(roomCabinets, basic.Cabinet{
				CabinetUid:   cabinetList[i].Id,
				CabinetName:  cabinetList[i].CabinetName,
				ContainRacks: cabinetRacks,
			})
		} else {
			cabinetList[j] = cabinetList[i]
			j++
		}
	}
	return cabinetList[:j], cicleRack, roomCabinets
}
func (h *BasicService) GetRooms(labCode, sn string) (roomList []basic.Room, err error) {

	rooms, err := basicdao.RoomsByLabCodes([]string{labCode})
	if err != nil {
		return
	}
	if len(rooms) == 0 {
		return nil, errors.New(fmt.Sprintf("机房 '%s' 下不存在房间信息", labCode))
	}
	roomIds := make([]int, len(rooms))
	for i, _ := range rooms {
		roomIds = append(roomIds, rooms[i].Id)
	}
	cabinets, err := basicdao.CabinetsByRoomIds(roomIds)
	if err != nil {
		return
	}
	cabinetsIds := make([]int, len(cabinets))
	for i, _ := range cabinets {
		cabinetsIds = append(cabinetsIds, cabinets[i].Id)
	}
	racks, err := basicdao.RacksByCabinetIds(cabinetsIds, sn)
	if err != nil {
		return
	}
	for _, rm := range rooms {
		roomCabinets := []basic.Cabinet{}
		cabinets, racks, roomCabinets = CabinetForCicle(cabinets, racks, rm.Id)
		//rooms[i].ContainCabinets = roomCabinets
		roomList = append(roomList, basic.Room{
			RoomUid:         rm.Id,
			RoomName:        rm.RoomName,
			ContainCabinets: roomCabinets,
		})
	}
	return
}

func (h *BasicService) GetResourceTree() (rs []basic.ResourceType, err error) {
	all, err := basicdao.QueryAllResource()
	if err != nil {
		return
	}

	//资源子类型 map
	var subMap = make(map[int][]basic.ResourceSubType)

	for _, r := range all {
		if r.ParentId == 0 {
			rs = append(rs, basic.ResourceType{
				Id:                      r.Id,
				ResourceTypeCode:        r.Code,
				ResourceTypeName:        r.Name,
				ContainResourceSubTypes: nil,
			})
			continue
		}

		//子类型，加入map
		if _, ok := subMap[r.ParentId]; !ok {
			subMap[r.ParentId] = make([]basic.ResourceSubType, 0)
		}
		subMap[r.ParentId] = append(subMap[r.ParentId], basic.ResourceSubType{
			Id:                  r.Id,
			ResourceSubTypeCode: r.Code,
			ResourceSubTypeName: r.Name,
		})
	}

	//循环资源类型，加入资源子类型
	for i := 0; i < len(rs); i++ {
		k := rs[i].Id
		if _, ok := subMap[k]; ok {
			rs[i].ContainResourceSubTypes = subMap[k]
		}
	}

	return
}

func (h *BasicService) GetResourceList() (basic.ResourceList, error) {
	resourceList := basic.ResourceList{}
	resourceType := []basic.Resource{}
	resourceSubType := []basic.Resource{}
	resourceResult, err := h.GetResourceTree()
	if err != nil {
		return resourceList, err
	}
	for _, resourceT := range resourceResult {
		resourceType = append(resourceType, basic.Resource{
			ResourceKey:   resourceT.ResourceTypeCode,
			ResourceValue: resourceT.ResourceTypeName,
		})
		for _, resourceSType := range resourceT.ContainResourceSubTypes {
			resourceSubType = append(resourceSubType, basic.Resource{
				ResourceKey:   resourceSType.ResourceSubTypeCode,
				ResourceValue: resourceSType.ResourceSubTypeName,
			})
		}
	}
	resourceList.ResourceType = resourceType
	resourceList.ResourceSubType = resourceSubType
	return resourceList, err
}

//获取主机列表
func (h *BasicService) GetHostTree(region, az, lab []string) (physicalServer []server.PhysicalHostData, err error) {

	physicalHostListQuery := server.PhysicalHostListQuery{
		PageNo: -1,
	}
	physicalHostListQuery.Region = region
	physicalHostListQuery.Az = az
	physicalHostListQuery.Lab = lab // []string{lab}

	rows, count, err := serverdao.GetPhysicalHostList(physicalHostListQuery)
	if err != nil {
		klog.Error(err)
		return
	}
	if count <= 0 {
		klog.Error(err)
		return
	}
	//循环赋值
	defer rows.Close()
	serverList := []server.PhysicalHostData{}
	for rows.Next() {
		var dr server.PhysicalHostData
		dao.AssetDB.ScanRows(rows, &dr)
		serverList = append(serverList, dr)
	}
	return serverList, err
}

//获取交换机列表
func (h *BasicService) GetSwitchTree(region, az, lab []string) (physicalSwitch []switchMachine.SwitchNew, err error) {
	params := switchMachine.SwitchListParams{
		PageNo: -1,
	}

	if len(region) > 0 {
		for i := 0; i < len(region); i++ {
			params.RegionCode = region[i]
			params.AzCode = az
			params.LabCode = lab
			switchList, _, err := switchdao.SelectSwitchListByCons(params)
			if err != nil {
				return physicalSwitch, err
			}
			physicalSwitch = append(physicalSwitch, switchList...)
		}
	} else {
		switchList, _, err := switchdao.SelectSwitchListByCons(params)
		if err != nil {
			return physicalSwitch, err
		}
		physicalSwitch = append(physicalSwitch, switchList...)
	}

	return
}

//获取EIP资源池列表
func (h *BasicService) GetEipResourceTree(region, cidrs []string) (segment []eipModel.Segment, err error) {
	eipService := eipSvc.NewService()
	return eipService.GetSegmentByCidrList(region, cidrs)
}

//获取资源池列表
func (h *BasicService) GetResourcePoolList(resourcePoolQuery basic.ResourcePoolQuery) ([]basic.ResourcePool, error) {
	//regionList := []basic.ResourcePoolRegion{} //aggregate;physicalHost;blockStorage;objectStorage
	resourcePoolList := []basic.ResourcePool{}
	if resourcePoolQuery.ResourceTypeCode == "aggregate" {
		regions, err := h.GetRegionsForSearch(resourcePoolQuery.RegionCode, resourcePoolQuery.AzCode)
		if err != nil {
			return resourcePoolList, err
		}
		// AggregatesData, err := h.AggregateInterface.GetAggregateAll()
		// if err != nil {
		// 	return resourcePoolList, err
		// }
		list := aggregate.GetAggregateMap()
		for _, region := range regions {
			for _, az := range region.ContainAzs {
				//listAll := AggregatesData.DataList
				for _, aggregate := range list {
					if (region.RegionCode == aggregate.RegionCode) &&
						(az.AzCode == aggregate.AzCode) {
						resourcePoolList = append(resourcePoolList, basic.ResourcePool{
							ResourcePoolCode: strconv.Itoa(aggregate.Id),
							ResourcePoolName: aggregate.Name,
						})
					}
				}
			}
		}
	} else if resourcePoolQuery.ResourceTypeCode == "blockStoragePool" {
		blockStoragePoolList, err := h.GetStorageResourcePoolList("ebs", []string{resourcePoolQuery.RegionCode}, resourcePoolQuery.AzCode, resourcePoolQuery.StorageTypeCode)
		if err == nil && len(blockStoragePoolList) > 0 {
			resourcePoolList = append(resourcePoolList, blockStoragePoolList...)
		}
	} else if resourcePoolQuery.ResourceTypeCode == "objectStoragePool" {
		objectStoragePoolList, err := h.GetStorageResourcePoolList("ks3", []string{resourcePoolQuery.RegionCode}, resourcePoolQuery.AzCode, resourcePoolQuery.StorageTypeCode)
		if err == nil && len(objectStoragePoolList) > 0 {
			resourcePoolList = append(resourcePoolList, objectStoragePoolList...)
		}
	}
	return resourcePoolList, nil
}

//获取块存储资源池和对象存储资源池
func (h *BasicService) GetStorageResourcePoolList(storageType string, regionCode, azArr, resourcePoolArr []string) ([]basic.ResourcePool, error) {
	storagePool := StoragePool{
		//RegionCode: regionCode,
		//AzCode:      azCode,
		StorageType: storageType,
		//ResourcePool: ResourcePool,
	}
	storagePoolList, err := storagePool.GetStoragePoolList(regionCode, azArr, resourcePoolArr)
	resourcePoolList := []basic.ResourcePool{}
	if err == nil && len(storagePoolList) > 0 {
		count := len(storagePoolList)
		for i := 0; i < count; i++ {
			resourcePoolList = append(resourcePoolList, basic.ResourcePool{
				ResourcePoolCode: storagePoolList[i].Name,
				ResourcePoolName: storagePoolList[i].Name,
			})
		}
	}
	return resourcePoolList, err
}

//获取块存储资源池和对象存储资源池为了获取容量
func (h *BasicService) GetResourcePoolStorageList(storageType string, regionCode, azArr, resourcePoolArr []string) ([]StoragePool, error) {
	storagePool := StoragePool{
		//RegionCode: regionCode,
		//AzCode:      azCode,
		StorageType: storageType,
		//ResourcePool: ResourcePool,
	}
	storagePoolList, err := storagePool.GetStoragePoolList(regionCode, azArr, resourcePoolArr)
	return storagePoolList, err
}

// GetDynamicColumnList 获取动态列
func (h *BasicService) GetDynamicColumnList(url, userName string) (basic.DynamicColumnList, error) {
	defaultUsername := "ksyun_admin"
	// 查询username、url对应的columnData
	queryFunc := func(fuserName, furl string) (columnData string, uid int, err error) {
		dc, err := basicdao.GetDynamicColumn(fuserName, furl)
		if err != nil {
			return "", 0, err
		}
		return dc.ColumnData, dc.Id, nil
	}
	columnData, uid, err := queryFunc(userName, url)
	if err != nil {
		return basic.DynamicColumnList{}, err
	}
	// 若columnData为空，则使用默认columnData
	if columnData == "" {
		defaultColumnData, uid, err := queryFunc(defaultUsername, url)
		if err != nil {
			return basic.DynamicColumnList{}, err
		}
		return basic.DynamicColumnList{ColumnData: defaultColumnData, Uid: uid}, nil
	}
	return basic.DynamicColumnList{ColumnData: columnData, Uid: uid}, nil
}

// UpdateDynamicColumnList 更新动态列
func (h *BasicService) UpdateDynamicColumnList(url, userName, columnData string, uid int) error {
	return setColumnData(userName, url, columnData)
}

func (h *BasicService) GetLabs(region string, az []string) ([]labmodel.BasicLab, error) {

	return labdao.GetLabByAzs(az)
}

//根据房间list获取机房list
func (h *BasicService) GetLabsByRoomCodes(codes []string) ([]labmodel.BasicLab, error) {
	return labdao.GetLabByRooms(codes)
}

func setColumnData(userName, url, columnData string) error {
	dc, err := basicdao.GetDynamicColumn(userName, url)
	if err != nil {
		return err
	}

	if dc.Id > 0 {
		err = basicdao.SetDynamicColumn(dc.Id, columnData)
	} else {
		_, err = basicdao.AddDynamicColumn(userName, url, columnData)
	}
	return err
}

func (h *BasicService) GetBasicCabinetList(params basic.CabinetQueryParam) ([]basic.CabinetInfo, error) {
	klog.Infof("GetBasicCabinetList params:%+v", params)

	basicCabinetList, err := cabidao.SelectBasicCabinetInfoByCons(params)
	if err != nil {
		return nil, err
	}
	return basicCabinetList, nil
}

//获取资源对象(计算资源池，块存储资源池，对象存储资源池以及服务器) 根据 资源类型和资源子类型
func (h *BasicService) GetObjectOfResourceType(resourceObjectQuery basic.ResourceObjectQuery) ([]basic.ResourceObject, error) {
	// if resourceObjectQuery.Region == "" {
	// 	resourceObjectQuery.Region = "all"
	// }
	// if resourceObjectQuery.Az == "" {
	// 	resourceObjectQuery.Az = "all"
	// }
	resourceObjectList := []basic.ResourceObject{}
	resourceMap, err := h.GetResourceMap()
	if err != nil {
		return resourceObjectList, err
	}
	//计算存储资源池
	if resourceObjectQuery.ResourceTypeCode == "resourcePool" && resourceObjectQuery.ResourceSubTypeCode == "kec" {
		//azList := []string{}
		// if resourceObjectQuery.Az != "all" {
		// 	azList = append(azList, resourceObjectQuery.Az)
		// }

		aggregatesListQuery := aggregate.AggregatesListQuery{
			//Region: resourceObjectQuery.Region,
			Az: resourceObjectQuery.Az,
		}
		aggregateList := []aggregate.Aggregates{}
		if len(resourceObjectQuery.Region) > 0 {
			for i := 0; i < len(resourceObjectQuery.Region); i++ {
				aggregatesListQuery.Region = resourceObjectQuery.Region[i]
				aggregates, err := h.AggregateInterface.GetAggregateAllForPage(aggregatesListQuery)
				if err != nil {
					return resourceObjectList, err
				}
				aggregateList = append(aggregateList, aggregates...)
			}
		} else {
			aggregatesListQuery.Region = "all"
			aggregates, err := h.AggregateInterface.GetAggregateAllForPage(aggregatesListQuery)
			if err != nil {
				return resourceObjectList, err
			}
			aggregateList = append(aggregateList, aggregates...)
		}

		length := len(aggregateList)
		for i := 0; i < length; i++ {
			if len(resourceObjectQuery.ResourceObjects) > 0 && !BoolTagInArray(resourceObjectQuery.ResourceObjects, aggregateList[i].Name) {
				continue
			}
			resourceObjectList = append(resourceObjectList, basic.ResourceObject{
				Key:                 fmt.Sprintf("%v/%v/%v", aggregateList[i].Region, aggregateList[i].Az, aggregateList[i].Name),
				Value:               aggregateList[i].Name,
				Region:              aggregateList[i].RegionCode,
				RegionName:          aggregateList[i].Region,
				Az:                  aggregateList[i].AzCode,
				AzName:              aggregateList[i].Az,
				ResourceTypeName:    resourceMap["resourcePool"],
				ResourceSubTypeName: resourceMap["kec"],
			})
		}
	}
	//块存储，对象存储资源池
	if resourceObjectQuery.ResourceTypeCode == "resourcePool" && resourceObjectQuery.ResourceSubTypeCode != "kec" {
		storagePool := StoragePool{
			// RegionCode:  resourceObjectQuery.Region,
			// AzCode:      resourceObjectQuery.Az,
			StorageType: "all",
			//ResourcePool: resourceObjectQuery.ResourceSubTypeCode,
		}
		storagePoolList, err := storagePool.GetStoragePoolList(resourceObjectQuery.Region, resourceObjectQuery.Az, []string{resourceObjectQuery.ResourceSubTypeCode})
		//resourcePoolList := []basic.ResourcePool{}
		if err == nil && len(storagePoolList) > 0 {
			count := len(storagePoolList)
			for i := 0; i < count; i++ {
				if len(resourceObjectQuery.ResourceObjects) > 0 && !BoolTagInArray(resourceObjectQuery.ResourceObjects, storagePoolList[i].Name) {
					continue
				}
				resourceObjectList = append(resourceObjectList, basic.ResourceObject{
					Key:                 fmt.Sprintf("%v/%v/%v", storagePoolList[i].RegionName, storagePoolList[i].AzName, storagePoolList[i].Name), //storagePoolList[i].Name,
					Value:               storagePoolList[i].Name,
					Region:              storagePoolList[i].RegionCode,
					RegionName:          storagePoolList[i].RegionName,
					Az:                  storagePoolList[i].AzCode,
					AzName:              storagePoolList[i].AzName,
					ResourceTypeName:    resourceMap[resourceObjectQuery.ResourceTypeCode],
					ResourceSubTypeName: resourceMap[resourceObjectQuery.ResourceSubTypeCode],
				})
			}
		}
	}
	//服务器
	if resourceObjectQuery.ResourceTypeCode == "physicalResource" && resourceObjectQuery.ResourceSubTypeCode == "physicalServer" {
		physicalHostList, err := h.GetHostTree(resourceObjectQuery.Region, resourceObjectQuery.Az, resourceObjectQuery.Lab)
		if err != nil {
			return resourceObjectList, err
		}
		if len(physicalHostList) > 0 {
			length := len(physicalHostList)
			for i := 0; i < length; i++ {
				if len(resourceObjectQuery.ResourceObjects) > 0 && !BoolTagInArray(resourceObjectQuery.ResourceObjects, physicalHostList[i].Name) {
					continue
				}
				resourceObjectList = append(resourceObjectList, basic.ResourceObject{
					Key:                 fmt.Sprintf("%v/%v/%v", physicalHostList[i].HostRegionName, physicalHostList[i].HostAzName, physicalHostList[i].Name),
					Value:               physicalHostList[i].Name,
					Region:              physicalHostList[i].HostRegionCode,
					RegionName:          physicalHostList[i].HostRegionName,
					Az:                  physicalHostList[i].HostAzCode,
					AzName:              physicalHostList[i].HostAzName,
					Lab:                 physicalHostList[i].HostLabCode,
					LabName:             physicalHostList[i].HostLabName,
					ResourceTypeName:    resourceMap[resourceObjectQuery.ResourceTypeCode],
					ResourceSubTypeName: resourceMap[resourceObjectQuery.ResourceSubTypeCode],
				})
			}
		}
	}
	//交换机
	if resourceObjectQuery.ResourceTypeCode == "physicalResource" && resourceObjectQuery.ResourceSubTypeCode == "physicalSwitch" {
		physicalSwitchList, err := h.GetSwitchTree(resourceObjectQuery.Region, resourceObjectQuery.Az, resourceObjectQuery.Lab)
		klog.Infof("GetSwitchTree physicalSwitchList:%+v\n", physicalSwitchList)
		if err != nil {
			return resourceObjectList, err
		}
		if len(physicalSwitchList) > 0 {
			length := len(physicalSwitchList)
			for i := 0; i < length; i++ {
				if len(resourceObjectQuery.ResourceObjects) > 0 && !BoolTagInArray(resourceObjectQuery.ResourceObjects, physicalSwitchList[i].Name) {
					continue
				}
				resourceObjectList = append(resourceObjectList, basic.ResourceObject{
					Key: fmt.Sprintf("%v/%v/%v", physicalSwitchList[i].RegionName, physicalSwitchList[i].AzName, physicalSwitchList[i].Name), //physicalSwitchList[i].Name,
					//Value:               physicalSwitchList[i].OutBandIP,
					Value:               physicalSwitchList[i].Name,
					Region:              physicalSwitchList[i].RegionCode,
					RegionName:          physicalSwitchList[i].RegionName,
					Az:                  physicalSwitchList[i].AzCode,
					AzName:              physicalSwitchList[i].AzName,
					Lab:                 physicalSwitchList[i].LabCode,
					LabName:             physicalSwitchList[i].LabName,
					ResourceTypeName:    resourceMap[resourceObjectQuery.ResourceTypeCode],
					ResourceSubTypeName: resourceMap[resourceObjectQuery.ResourceSubTypeCode],
				})
			}
		}

		klog.Infof("resourceObjectList physicalSwitchList:%+v\n", resourceObjectList)
	}

	//获取服务对象列表
	//businessTopoSvc := businessTree.NewBusinessTopologyService()
	if resourceObjectQuery.ResourceTypeCode == "service" && (resourceObjectQuery.ResourceSubTypeCode == "milkyPlatForm" || resourceObjectQuery.ResourceSubTypeCode == "lubanPlatForm") {
		//conditions := make(map[string]interface{})
		treeId := 1
		if resourceObjectQuery.ResourceSubTypeCode == "lubanPlatForm" {
			treeId = 2
		}
		//sns, err := businessManagementDao.QueryServiceListByTreeId(treeId)
		//if err != nil {
		//	return resourceObjectList, err
		//}
		refs, err := businessManagementDao.QueryNodeRefByTreeId(treeId)
		if err != nil {
			return resourceObjectList, err
		}
		// 通过refs获取其路径节点名的拼接nodeA/nodeB/nodeC
		// 注意后面refs获取node可能会存在没有服务的情况，没有服务的node不拼接在最终结果里
		region := basicdao.Region{}

		svcIds := map[int]struct{}{} // 用于去除重复service id

		for _, ref := range refs {
			if ref.RealNodeId < 0 {
				continue
			}
			// 根据noderef的realNodeId值查询对应的node节点及其对应的service
			node, _ := businessManagementDao.QueryNodeDetail(ref.RealNodeId)
			if region.RegionName == "" {
				region.RegionCode = node.RegionCode
				region, _ = basicdao.GetRegion(region)
			}
			//for service
			// 根据noderef的refId值拼接出route名称
			route := businessManagementDao.QueryRouteByRefId(ref.RefId)
			for _, service := range node.Services {
				if len(resourceObjectQuery.ResourceObjects) > 0 && !BoolTagInArray(resourceObjectQuery.ResourceObjects, strconv.Itoa(service.Id)) {
					continue
				}

				// 已经添加过的service不再添加
				if _, ok := svcIds[service.Id]; ok {
					continue
				}

				resourceObjectList = append(resourceObjectList, basic.ResourceObject{
					Key:   fmt.Sprintf("%v%v/%v", region.RegionName, route, service.Name),
					Value: strconv.Itoa(service.Id),
					//Value:               fmt.Sprintf("%s-%d", node.Name, service.Id),
					Region:              node.RegionCode,
					RegionName:          region.RegionName,
					ResourceTypeName:    resourceMap[resourceObjectQuery.ResourceTypeCode],
					ResourceSubTypeName: resourceMap[resourceObjectQuery.ResourceSubTypeCode],
				})

				svcIds[service.Id] = struct{}{}

			}
		}
	}

	//数据库资源池，包括redis mysql资源池
	if resourceObjectQuery.ResourceTypeCode == "resourcePool" && (resourceObjectQuery.ResourceSubTypeCode == "kcs" || resourceObjectQuery.ResourceSubTypeCode == "rds") {

		var dbPoolList []DbResourcePool
		var err error

		switch resourceObjectQuery.ResourceSubTypeCode {
		case "rds":
			dbPoolList, err = GetMysqlPoolList()
		case "kcs":
			dbPoolList, err = GetRedisPoolList()
		default:
			klog.Error("unknow resourceSubType")
			return nil, fmt.Errorf("get db pool failed, unkonw resourceSubType")
		}

		if err != nil {
			return nil, err
		}
		for i := range dbPoolList {

			key := fmt.Sprintf("%s/%s/%s", dbPoolList[i].RegionName, dbPoolList[i].AzName, dbPoolList[i].Name)

			resourceObjectList = append(resourceObjectList, basic.ResourceObject{
				Key:                 strings.Trim(key, "/"),
				Value:               dbPoolList[i].Name,
				Region:              dbPoolList[i].RegionCode,
				RegionName:          dbPoolList[i].RegionName,
				Az:                  dbPoolList[i].AzCode,
				AzName:              dbPoolList[i].AzName,
				ResourceTypeName:    resourceMap[resourceObjectQuery.ResourceTypeCode],
				ResourceSubTypeName: resourceMap[resourceObjectQuery.ResourceSubTypeCode],
			})
		}
	}

	//XGW资源池
	if resourceObjectQuery.ResourceTypeCode == "resourcePool" && resourceObjectQuery.ResourceSubTypeCode == "xgw" {
		xgwPoolMap, err := GetXGWPoolMap()
		if err != nil {
			return nil, err
		}
		for host, pool := range xgwPoolMap {
			key := fmt.Sprintf("%s/%s", pool.RegionName, host)
			resourceObjectList = append(resourceObjectList, basic.ResourceObject{
				Key:                 strings.Trim(key, "/"), //网络资源池没有AZ字段
				Value:               host,
				Region:              pool.RegionCode,
				RegionName:          pool.RegionName,
				ResourceTypeName:    resourceMap[resourceObjectQuery.ResourceTypeCode],
				ResourceSubTypeName: resourceMap[resourceObjectQuery.ResourceSubTypeCode],
			})
		}
	}

	//Tengine资源池
	if resourceObjectQuery.ResourceTypeCode == "resourcePool" && resourceObjectQuery.ResourceSubTypeCode == "tengine" {
		tenginePool, err := GetTenginePool()
		if err != nil {
			return nil, err
		}
		for _, host := range []string(tenginePool.Hosts) {
			if len(resourceObjectQuery.ResourceObjects) > 0 && !BoolTagInArray(resourceObjectQuery.ResourceObjects, host) {
				continue
			}

			resourceObjectList = append(resourceObjectList, basic.ResourceObject{
				Key:                 strings.Trim(fmt.Sprintf("%s/%s", tenginePool.RegionName, host), "/"), //网络资源池没有AZ字段
				Value:               host,
				Region:              tenginePool.RegionCode,
				RegionName:          tenginePool.RegionName,
				ResourceTypeName:    resourceMap[resourceObjectQuery.ResourceTypeCode],
				ResourceSubTypeName: resourceMap[resourceObjectQuery.ResourceSubTypeCode],
			})
		}
	}

	//NAT资源池
	if resourceObjectQuery.ResourceTypeCode == "resourcePool" && resourceObjectQuery.ResourceSubTypeCode == "nat" {
		natPool, err := GetNatPool()
		if err != nil {
			return nil, err
		}
		//遍历资源池中的Host字段，取出元数据
		for _, host := range natPool.Hosts {
			// 指定资源实例
			if len(resourceObjectQuery.ResourceObjects) > 0 && !BoolTagInArray(resourceObjectQuery.ResourceObjects, host) {
				continue
			}
			resourceObjectList = append(resourceObjectList, basic.ResourceObject{
				Key:                 strings.Trim(fmt.Sprintf("%s/%s", natPool.RegionName, host), "/"), //网络资源池没有AZ字段
				Value:               host,
				Region:              natPool.RegionCode,
				RegionName:          natPool.RegionName,
				ResourceTypeName:    resourceMap[resourceObjectQuery.ResourceTypeCode],
				ResourceSubTypeName: resourceMap[resourceObjectQuery.ResourceSubTypeCode],
			})
		}
	}

	//KGW资源池
	if resourceObjectQuery.ResourceTypeCode == "resourcePool" && resourceObjectQuery.ResourceSubTypeCode == "kgw" {
		kgwPoolMap, err := GetKGWPoolMap()
		//klog.Infof("kgw resource pool: %+v", kgwPoolMap)
		if err != nil {
			return nil, err
		}
		for host, pool := range kgwPoolMap {
			resourceObjectList = append(resourceObjectList, basic.ResourceObject{
				Key:                 strings.Trim(fmt.Sprintf("%s/%s", pool.RegionName, host), "/"), //网络资源池没有AZ字段
				Value:               host,
				Region:              pool.RegionCode,
				RegionName:          pool.RegionName,
				ResourceTypeName:    resourceMap[resourceObjectQuery.ResourceTypeCode],
				ResourceSubTypeName: resourceMap[resourceObjectQuery.ResourceSubTypeCode],
			})
		}
	}
	//SGW资源池(目前未实现，先写好逻辑)
	if resourceObjectQuery.ResourceTypeCode == "resourcePool" && resourceObjectQuery.ResourceSubTypeCode == "sgw" {
		sgwPoolMap, err := GetSGWPoolMap()
		if err != nil {
			return nil, err
		}
		for host, pool := range sgwPoolMap {
			resourceObjectList = append(resourceObjectList, basic.ResourceObject{
				Key:                 strings.Trim(fmt.Sprintf("%s/%s", pool.RegionName, host), "/"), //网络资源池没有AZ字段
				Value:               host,
				Region:              pool.RegionCode,
				RegionName:          pool.RegionName,
				ResourceTypeName:    resourceMap[resourceObjectQuery.ResourceTypeCode],
				ResourceSubTypeName: resourceMap[resourceObjectQuery.ResourceSubTypeCode],
			})
		}
	}

	//TGW资源池
	if resourceObjectQuery.ResourceTypeCode == "resourcePool" && resourceObjectQuery.ResourceSubTypeCode == "tgw" {
		sgwPoolMap, err := GetTGWPoolMap()
		if err != nil {
			return nil, err
		}
		for host, pool := range sgwPoolMap {
			resourceObjectList = append(resourceObjectList, basic.ResourceObject{
				Key:                 strings.Trim(fmt.Sprintf("%s/%s", pool.RegionName, host), "/"), //网络资源池没有AZ字段
				Value:               host,
				Region:              pool.RegionCode,
				RegionName:          pool.RegionName,
				ResourceTypeName:    resourceMap[resourceObjectQuery.ResourceTypeCode],
				ResourceSubTypeName: resourceMap[resourceObjectQuery.ResourceSubTypeCode],
			})
		}
	}

	//PGW资源池
	if resourceObjectQuery.ResourceTypeCode == "resourcePool" && resourceObjectQuery.ResourceSubTypeCode == "pgw" {
		sgwPoolMap, err := GetPGWPoolMap()
		if err != nil {
			return nil, err
		}
		for host, pool := range sgwPoolMap {
			resourceObjectList = append(resourceObjectList, basic.ResourceObject{
				Key:                 strings.Trim(fmt.Sprintf("%s/%s", pool.RegionName, host), "/"), //网络资源池没有AZ字段
				Value:               host,
				Region:              pool.RegionCode,
				RegionName:          pool.RegionName,
				ResourceTypeName:    resourceMap[resourceObjectQuery.ResourceTypeCode],
				ResourceSubTypeName: resourceMap[resourceObjectQuery.ResourceSubTypeCode],
			})
		}
	}

	return resourceObjectList, nil

}
func (h *BasicService) GetRegionList() ([]basic.RegionDt, error) {
	var regionListRst []basic.RegionDt
	regionList, err := basicdao.GetRegionList(basicdao.Region{})
	if err != nil {
		return regionListRst, err
	}
	for i, _ := range regionList {
		regionListRst = append(regionListRst, basic.RegionDt{
			RegionCode:          regionList[i].RegionCode,
			RegionCodeAggregate: regionList[i].RegionCodeAggregate,
			RegionName:          regionList[i].RegionName,
		})
	}
	return regionListRst, err
}
func (h *BasicService) GetAzList(region string) ([]basic.AzDt, error) {
	regionMap := make(map[string]interface{})
	var azDt []basic.AzDt
	regions, err := h.GetRegions(regionMap, make(map[string]interface{}), make(map[string]interface{})) //([]basic.Region, error)
	if err != nil {
		return azDt, err
	}
	if len(regions) <= 0 {
		return azDt, err
	}
	//azDt=regions[0].ContainAzs
	azLen := len(regions[0].ContainAzs)
	for i := 0; i < azLen; i++ {
		azDt = append(azDt, basic.AzDt{
			AzCode: regions[0].ContainAzs[i].AzCode,
			AzName: regions[0].ContainAzs[i].AzName,
			AzId:   regions[0].ContainAzs[i].AzId,
		})
	}
	// azs, err := basicdao.GetAzListByMap(azMap)
	// if err != nil {
	// 	return []basic.Region{}, err
	// }
	// q := `{
	// 	dataList(func:has(region_azs) )%s
	// 	   {
	// 		containAzs: region_azs{
	// 		  azName
	// 		  azCode
	// 		}
	// 	  }
	//     }`
	// if region == "all" || region == "" {
	// 	region = ""
	// } else {
	// 	region = fmt.Sprintf(`@filter(eq(regionCode, "%s"))`, region)
	// }
	// q = fmt.Sprintf(q, region)
	// fmt.Println(q)
	// var azDataResult basic.AzList
	// var azDt []basic.AzDt
	// resp, err := h.DgraphClient.NewTxn().Query(context.Background(), q)
	// err = json.Unmarshal(resp.Json, &azDataResult)
	// if len(azDataResult.DataList) > 0 {
	// 	azDt = azDataResult.DataList[0].ContainAzs
	// }
	return azDt, err
}

//获取资源类型map
func (h *BasicService) GetResourceMap() (resourceMap map[string]string, err error) {
	all, err := basicdao.QueryAllResource()
	if err != nil {
		return
	}
	resourceMap = make(map[string]string)
	for i := 0; i < len(all); i++ {
		resourceMap[all[i].Code] = all[i].Name
	}
	return
}

// func (h *BasicService) GetAzRegionInfo(regionCodes []string) (basic.AzRegionInfo, error) {
// 	klog.Infof("GetAzRegionInfo params:%+v", regionCodes)
// 	azRegionin := basic.AzRegionInfo{}
// 	if len(regionCodes) <= 0 {
// 		return azRegionin, errors.New("region信息查询入参为空")
// 	}
// 	q := `{
// 	azRegionInfo(func: has(region_azs))%s {
// 		regionName
// 		regionCode
// 		containAzs: region_azs {
// 			azName
// 			azCode
// 		}
// 	}
// }`
// 	queryInfo := " @filter(%s)"
// 	regionInput := "%s"

// 	var regionCodeList []string
// 	for _, regionCode := range regionCodes {
// 		regionCodeList = append(regionCodeList, fmt.Sprintf(" eq(regionCode,\"%s\")", regionCode))
// 	}
// 	regionInput = fmt.Sprintf(regionInput, strings.Join(regionCodeList, "or"))
// 	queryInfo = fmt.Sprintf(queryInfo, regionInput)
// 	q = fmt.Sprintf(q, queryInfo)
// 	response, err := h.DgraphClient.NewTxn().Query(context.TODO(), q)
// 	if err != nil {
// 		return azRegionin, err
// 	}
// 	err = json.Unmarshal(response.Json, &azRegionin)
// 	if err != nil {
// 		return azRegionin, err
// 	}
// 	return azRegionin, nil
// }

// 上报物理服务器的硬件信息
func (h *BasicService) ReportHardwareMess(hardwareMess basic.HardwareMess) error {
	cpuList, err := basicdao.GetCpuMessage(basicdao.Cpu{Sn: hardwareMess.Sn})
	if err != nil {
	} else if len(cpuList) > 0 {
		basicdao.UpdateCpuMessage(basicdao.Cpu{
			Sn:   hardwareMess.Sn,
			Info: hardwareMess.CpuInfo,
		})
	} else {
		basicdao.InsertCpuMessage(basicdao.Cpu{
			Sn:   hardwareMess.Sn,
			Info: hardwareMess.CpuInfo,
		})
	}
	memList, err := basicdao.GetMemMessage(basicdao.Mem{Sn: hardwareMess.Sn})
	if err != nil {
	} else if len(memList) > 0 {
		basicdao.UpdateMemMessage(basicdao.Mem{
			Sn:   hardwareMess.Sn,
			Info: hardwareMess.MemInfo,
		})
	} else {
		basicdao.InsertMemMessage(basicdao.Mem{
			Sn:   hardwareMess.Sn,
			Info: hardwareMess.MemInfo,
		})
	}
	diskList, err := basicdao.GetDiskMessage(basicdao.Disk{Sn: hardwareMess.Sn})
	if err != nil {
	} else if len(diskList) > 0 {
		basicdao.UpdateDiskMessage(basicdao.Disk{
			Sn:   hardwareMess.Sn,
			Info: hardwareMess.DiskInfo,
		})
	} else {
		basicdao.InsertDiskMessage(basicdao.Disk{
			Sn:   hardwareMess.Sn,
			Info: hardwareMess.DiskInfo,
		})
	}
	raidList, err := basicdao.GetRaidMessage(basicdao.Raid{Sn: hardwareMess.Sn})
	if err != nil {
	} else if len(raidList) > 0 {
		basicdao.UpdateRaidMessage(basicdao.Raid{
			Sn:   hardwareMess.Sn,
			Info: hardwareMess.RaidInfo,
		})
	} else {
		basicdao.InsertRaidMessage(basicdao.Raid{
			Sn:   hardwareMess.Sn,
			Info: hardwareMess.RaidInfo,
		})
	}
	return nil
}

func (h *BasicService) ReportHardware(hardware hardwares.Hardware) error {
	//logx.Debugf("hardware %+v", hardware)
	if len(hardware.SysInfo) == 0 {
		return nil
	}
	hardware.Sn = hardware.SysInfo[0].SerialNumber
	//hardware.Sn = hardware.SysInfo[0].UUID

	if hardware.CheckExistBySn(dao.AssetDB) {
		// 更新
		logx.Debugf("hardware_update", "更新")
		err := hardware.UpdateBySn(dao.AssetDB)
		if err != nil {
			return err
		}
	} else {
		// 新增
		logx.Debugf("hardware_insert", "新增")
		err := hardware.Create(dao.AssetDB)
		if err != nil {
			return err
		}
	}
	//更新服务器物理网卡数据
	var serverNetwork []server.AssetPhysicalServerNetwork
	for _, v := range hardware.WorkInfo {
		netWorkInfo := server.AssetPhysicalServerNetwork{
			Sn:           hardware.Sn,
			HostName:     hardware.HostName,
			NetWork:      v.Name,
			Mac:          v.Mac,
			Speed:        v.Size / 1000,
			LastUpdateAt: time.Unix(time.Now().Unix(), 0),
		}
		serverNetwork = append(serverNetwork, netWorkInfo)
	}

	//查询历史服务器网卡数据
	var oldServerNetwork []server.AssetPhysicalServerNetwork
	err := dao.AssetDB.Table("asset_physical_server_network").Where("sn = ?", hardware.Sn).Find(&oldServerNetwork).Error
	if err != nil {
		return fmt.Errorf("history network failed; err: %v", err)
	}

	//将现有网卡转成map
	listMap := make(map[string]server.AssetPhysicalServerNetwork, len(serverNetwork))
	for _, v := range serverNetwork {
		listMap[v.Sn+v.Mac] = v
	}

	//将历史网卡内多余的网卡写入deleteMap
	var deleteMap map[string]string
	for _, v := range oldServerNetwork {
		_, ok := listMap[v.Sn+v.Mac]
		if !ok {
			deleteMap = map[string]string{
				v.Sn: v.Mac,
			}
		}
	}
	if len(deleteMap) > 0 {
		// 删除delete
		for k, v := range deleteMap {
			err := dao.AssetDB.Debug().Table("asset_physical_server_network").Where("sn = ? and  mac = ? ", k, v).Delete(&server.AssetPhysicalServerNetwork{}).Error
			if err != nil {
				return fmt.Errorf("delete network failed; err: %v", err)
			}
		}
	}

	err1 := dao.AssetDB.Debug().Table("asset_physical_server_network").Clauses(clause.OnConflict{
		Columns:   []clause.Column{{Name: "sn"}, {Name: "mac"}},
		UpdateAll: true,
	}).Create(&serverNetwork).Error
	if err1 != nil {
		return fmt.Errorf("create network failed; err: %v", err)
	}

	return nil
}

func (h *BasicService) GetRacksByCabinetId(sn string, cabinetsId int) (rackList []basic.Rack, err error) {
	racks, err := basicdao.RacksByCabinetIds([]int{cabinetsId}, sn)
	if err != nil {
		return
	}
	racksLen := len(racks)
	rackList = make([]basic.Rack, 0, racksLen)
	if racksLen > 0 {
		for i := 0; i < racksLen; i++ {
			rackList = append(rackList, basic.Rack{
				RackUid:  racks[i].Id,
				RackName: racks[i].RackName,
			})
		}
	}
	return
}

//获取用户信息
func GetRedisTenantMessage(tenantId string) (tenant basic.Tenant, err error) {
	ctx, cefl := context.WithTimeout(context.Background(), 5*time.Second)
	defer cefl()
	//rs, err := gredis.SMembers(ctx, gredis.AggregatesVmMapKey)
	//klog.Infoln("tenantId:", tenantId)
	rs, err := gredis.HGet(ctx, gredis.UserInfoKey, tenantId)
	if err == redis.Nil {
		return tenant, nil
	}
	if err != nil {
		klog.Error("gredis.HGet read from redis failure:", err.Error())
		return
	}
	err = json.Unmarshal([]byte(rs), &tenant)
	if err != nil {
		klog.Error("gredis.HGet Unmarshal failure:", err.Error())
		return
	}
	return
}

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/pkg/service/businessManagement.go
```golang
package service

import (
	"context"
	"errors"
	"fmt"
	"luban-cmdb-api/pkg/apiserver/client"
	"luban-cmdb-api/pkg/dao"
	"luban-cmdb-api/pkg/dao/basic"
	businessManagementDao "luban-cmdb-api/pkg/dao/businessManagement"
	"luban-cmdb-api/pkg/dao/server"
	serverDao "luban-cmdb-api/pkg/dao/server"
	"luban-cmdb-api/pkg/models/aggregate"
	"luban-cmdb-api/pkg/models/businessManagement"
	serverModel "luban-cmdb-api/pkg/models/server"
	"luban-cmdb-api/pkg/service/k8sresource"
	"luban-cmdb-api/pkg/utils"
	"luban-cmdb-api/pkg/utils/collection"
	"sort"
	"strings"
	"sync"
	"time"

	"github.com/zeromicro/go-zero/core/logx"

	"k8s.io/klog/v2"
)

type BusinessManagementService struct {
}

func NewBusinessManagementService() *BusinessManagementService {
	return &BusinessManagementService{}
}

func (s *BusinessManagementService) QueryContainerList(ns, pod string) (containers []businessManagement.Container, err error) {
	cl := client.GetClient()
	if cl == nil {
		cl = client.GetOuterClient()
		if cl == nil {
			return
		}
	}
	ds := k8sresource.K8sResource{Client: cl}
	ctx := context.Background()

	//podDetail, err := ds.GetPodOne(ctx, ns, pod)
	//podDetail.Spec.Containers
	klog.Infof("ns is %s,pod is %s", ns, pod)

	podMetric, err := ds.GetMetrics(ctx, ns, pod)
	defer ctx.Done()
	if len(podMetric.Containers) > 0 {
		for _, ctn := range podMetric.Containers {
			var container businessManagement.Container
			container.Name = ctn.Name
			container.CpuUsage = ctn.Usage.Cpu
			container.MemoryUsage = ctn.Usage.Memory
			container.Status = "normal"
			containers = append(containers, container)
		}
	}
	return containers, err
}

func (s *BusinessManagementService) CreateServiceInstance(svci businessManagement.ServiceInstance) error {
	return businessManagementDao.CreateServiceInstance(&svci)
}

func (s *BusinessManagementService) UpdateServiceInstance(svci businessManagement.ServiceInstance) error {
	return businessManagementDao.UpdateServiceInstance(svci)
}

func (s *BusinessManagementService) QueryServiceInstance(id int, aggregateService *AggregateService) (svci businessManagement.ServiceInstance, err error) {
	svci, err = businessManagementDao.QueryServiceInstanceDetail(id)
	region, err := basic.GetRegion(basic.Region{
		RegionCode: svci.RegionCode,
	})
	az, err := basic.GetAz(basic.Az{
		AzCode: svci.AzCode,
	})
	svci.RegionName = region.RegionName
	svci.AzName = az.AzName
	if svci.HostType == 0 { // 物理机
		ip, _ := server.QueryIpById(svci.HostId)
		svci.HostIp = ip.Ip
		svci.HostName = ip.Name
		svci.OutIp = ip.OutBandIp
	} else if svci.HostType == 1 { // 云主机
		vmDetail, err := aggregateService.GetVmDetails(aggregate.VMQuery{
			Id: svci.VmId,
		})
		if err != nil {
			return svci, err
		}
		svci.HostIp = vmDetail.InnerIp
		svci.OutIp = vmDetail.InternetIpV4
	}
	return
}
func (s *BusinessManagementService) QueryServiceInstanceList(params businessManagement.QueryServiceInstanceListParams, aggregateService *AggregateService) (svcis []businessManagement.ServiceInstance, total int, err error) {
	start := time.Now()
	//svcInstances := []businessManagement.ServiceInstance{}
	svcInstancesAll := []businessManagement.ServiceInstance{}

	svcInstance, t, err := s.QueryServiceInstanceAll(params, aggregateService)
	if err != nil {
		klog.Errorf("ServiceInstanceList QueryServiceInstanceAll error: %v", err)
		return
	}
	//klog.Infof("svcInstance: %+v", svcInstance)
	svcInstancesAll = append(svcInstancesAll, svcInstance...)
	klog.Infof("ServiceInstanceList - QueryServiceInstanceAll time is %v", time.Since(start).Seconds())
	klog.Infof("ServiceInstanceList - QueryServiceInstanceAll len is %v", len(svcInstance))

	total = int(t)
	svcis = svcInstancesAll
	fmt.Println("QueryServiceInstanceAll总花费时间:", time.Since(start).Seconds())
	return
}
func (s *BusinessManagementService) QueryServiceInstanceAll(params businessManagement.QueryServiceInstanceListParams, aggregateService *AggregateService) (svcis []businessManagement.ServiceInstance, total int64, err error) {
	params.SortField = utils.SnakeString(params.SortField)

	hostId := 0
	if params.HostName != "" {
		hostId, err = serverDao.GetHostIdByHostName(params.HostName)
		if err != nil {
			return
		}
	}

	svcis, total, err = businessManagementDao.QueryServiceInstances(params.Region, params.Az, params.SearchName,
		params.SearchSvcIds, params.PageSize, params.PageNo, params.SortField, params.SortType, hostId)

	svcidSet := collection.NewSet()
	svcids := make([]int, 0)
	for i := 0; i < len(svcis); i++ {
		svcidSet.Add(svcis[i].ServiceId)
		svcids = append(svcids, svcis[i].ServiceId)
	}
	svcs, _ := businessManagementDao.QueryServicesByIds(svcidSet.KeysInt())
	nameMapping := make(map[int]string)
	for i := 0; i < len(svcs); i++ {
		nameMapping[svcs[i].Id] = svcs[i].Name
	}

	regionCode2Map, err := basic.QueryAllRegionCode2Map()
	if err != nil {
		klog.Errorf("QueryAllRegionCode2Map error: %v", err)
		return
	}

	azCode2Map, err := basic.QueryAllAzCode2Map()
	if err != nil {
		klog.Errorf("QueryAllAzCode2Map error: %v", err)
		return
	}

	hostIdsSet := collection.NewSet()
	vmIdsSet := collection.NewSet()
	for i := 0; i < len(svcis); i++ {
		////内置服务为POD
		//if svcis[i].BuiltIn == businessManagement.BUILT_IN_YES {
		//	continue
		//}

		if svcis[i].HostType == 0 { // 物理机
			hostIdsSet.Add(svcis[i].HostId)
		} else if svcis[i].HostType == 1 { // 虚拟机
			vmIdsSet.Add(svcis[i].HostId)
		}
	}
	physicalHosts, err := server.QueryIpByIds(hostIdsSet.KeysInt())
	if err != nil {
		klog.Errorf("QueryIpByIds error: %v", err)
		return
	}
	physicalHostsId2Map := make(map[int]server.IpStruct)
	for i := 0; i < len(physicalHosts); i++ {
		physicalHostsId2Map[physicalHosts[i].Id] = physicalHosts[i]
	}

	for i := 0; i < len(svcis); i++ {
		////内置服务为POD
		//if svcis[i].BuiltIn == businessManagement.BUILT_IN_YES {
		//	continue
		//}
		region, _ := regionCode2Map[svcis[i].RegionCode]
		svcis[i].RegionName = region.RegionName

		az, _ := azCode2Map[svcis[i].AzCode]
		svcis[i].AzName = az.AzName
		if svcis[i].HostType == 0 { // 物理机
			//ip, _ := server.QueryIpById(svcis[i].HostId)
			ip, _ := physicalHostsId2Map[svcis[i].HostId]
			svcis[i].HostIp = ip.Ip
			svcis[i].HostName = ip.Name
			svcis[i].OutIp = ip.OutBandIp
		} else if svcis[i].HostType == 1 { // 云主机
			vmDetail, err := aggregateService.GetVmDetails(aggregate.VMQuery{
				Id: svcis[i].VmId,
			})
			if err != nil {
				klog.Errorf("ServiceInstanceList - QueryServiceInstanceAll GetVmDetails vmid: %v  error: %v", svcis[i].VmId, err)
				continue
			}
			svcis[i].HostIp = vmDetail.InnerIp
			svcis[i].OutIp = vmDetail.InternetIpV4
		}
		svcis[i].ServiceName = nameMapping[svcis[i].ServiceId]

		////数据库添加了字段
		//svcis[i].BuiltIn = businessManagement.BUILT_IN_NO
	}
	return
}

func (s *BusinessManagementService) DeleteServiceInstances(ids []int) error {
	return businessManagementDao.DeleteServiceInstances(ids)
}

func (s *BusinessManagementService) CreateService(svc businessManagement.Service) error {
	svc.BuiltIn = businessManagement.BUILT_IN_NO
	return businessManagementDao.CreateService(&svc)
}

func (s *BusinessManagementService) QueryService(id int) (svc businessManagement.Service, err error) {
	svc, err = businessManagementDao.QueryServiceDetail(id)
	region, err := basic.GetRegion(basic.Region{
		RegionCode: svc.RegionCode,
	})
	svc.RegionName = region.RegionName
	return
}

func (s *BusinessManagementService) QueryServiceList(regionCode, SearchName string, builtIn, pageSize, pageNo int, sortField, sortType string) (services []businessManagement.Service, total int64, err error) {
	sortField = utils.SnakeString(sortField)
	services, total, err = businessManagementDao.QueryServiceList(regionCode, SearchName, int8(builtIn), pageSize, pageNo, sortField, sortType)
	for i := 0; i < len(services); i++ {
		region, _ := basic.GetRegion(basic.Region{
			RegionCode: services[i].RegionCode,
		})
		services[i].RegionName = region.RegionName
	}
	return
}

func (s *BusinessManagementService) UpdateService(svc businessManagement.Service) error {
	return businessManagementDao.UpdateService(svc)
}

func (s *BusinessManagementService) DeleteService(id int) error {
	return businessManagementDao.DeleteService(id)
}

func (s *BusinessManagementService) CreateTree(tree businessManagement.Tree) error {
	tree.BuiltIn = businessManagement.BUILT_IN_NO
	return businessManagementDao.CreateTree(tree)
}

func (s *BusinessManagementService) QueryTree(id int) (tree businessManagement.Tree, err error) {
	tree, err = businessManagementDao.QueryTreeDetail(id)
	if err != nil {
		return
	}
	region, err := basic.GetRegion(basic.Region{
		RegionCode: tree.RegionCode,
	})
	tree.RegionName = region.RegionName
	return
}

func (s *BusinessManagementService) QueryTreeList(regionCode string, status []int, pageSize, pageNo int, sortField, sortType string) (trees []businessManagement.Tree, count int64, err error) {
	sortField = utils.SnakeString(sortField)
	trees, count, err = businessManagementDao.QueryTreeList(regionCode, status, pageSize, pageNo, sortField, sortType)
	for i := 0; i < len(trees); i++ {
		region, _ := basic.GetRegion(basic.Region{
			RegionCode: trees[i].RegionCode,
		})
		trees[i].RegionName = region.RegionName
	}
	return
}

func (s *BusinessManagementService) UpdateTree(tree businessManagement.Tree) error {
	return businessManagementDao.UpdateTree(tree)
}

func (s *BusinessManagementService) DeleteTree(id int) error {
	return businessManagementDao.DeleteTree(id)
}

func (s *BusinessManagementService) CreateNode(node businessManagement.Node) error {
	node.BuiltIn = businessManagement.BUILT_IN_NO
	return businessManagementDao.CreateNode(node)
}

func (s *BusinessManagementService) QueryNode(id int) (node businessManagement.Node, err error) {
	node, err = businessManagementDao.QueryNodeDetail(id)
	region, err := basic.GetRegion(basic.Region{
		RegionCode: node.RegionCode,
	})
	node.RegionName = region.RegionName
	// 这里需要再组合一下路径
	refs, err := businessManagementDao.QueryNodeRefByNodeId(id)
	if err != nil {
		return node, err
	}
	for i := 0; i < len(refs); i++ {
		route, treeId := businessManagementDao.QueryRouteAndTreeIdByRefId(refs[i].RefId)
		// 再查一下树
		treeDetail, err := businessManagementDao.QueryTreeDetail(treeId)
		if err != nil {
			continue
		}
		node.Routes = append(node.Routes, businessManagement.R{
			TreeName: treeDetail.Name,
			Route:    treeDetail.Name + route,
		})
	}
	return
}

func (s *BusinessManagementService) QueryNodeList(regionCode string, pageSize, pageNo int, sortField, sortType string) (nodes []businessManagement.Node, total int64, err error) {
	sortField = utils.SnakeString(sortField)
	nodes, total, err = businessManagementDao.QueryNodeList(regionCode, pageSize, pageNo, sortField, sortType)
	for i := 0; i < len(nodes); i++ {
		region, _ := basic.GetRegion(basic.Region{
			RegionCode: nodes[i].RegionCode,
		})
		nodes[i].RegionName = region.RegionName
	}
	return
}

func (s *BusinessManagementService) UpdateNode(node businessManagement.Node) error {
	return businessManagementDao.UpdateNode(node)
}

func (s *BusinessManagementService) DeleteNode(id int) error {
	return businessManagementDao.DeleteNode(id)
}

func (s *BusinessManagementService) QueryTopology(treeId int) (nodeRef businessManagement.NodeRef, err error) {
	refs, err := businessManagementDao.QueryNodeRefByTreeId(treeId)
	if err != nil {
		return nodeRef, err
	}
	makeStruct := make(map[int][]*businessManagement.NodeRef)
	for i := 0; i < len(refs); i++ {
		if v, ok := makeStruct[refs[i].ParentId]; !ok {
			makeStruct[refs[i].ParentId] = []*businessManagement.NodeRef{&refs[i]}
		} else {
			makeStruct[refs[i].ParentId] = append(v, &refs[i])
		}
	}
	v, ok := makeStruct[-treeId]
	if !ok {
		return nodeRef, errors.New("tree root node not found")
	}
	queue := make([]*businessManagement.NodeRef, 0, len(makeStruct))
	for i := 0; i < len(v); i++ {
		queue = append(queue, v[i])
	}
	for len(queue) != 0 {
		nowStep := queue[0]
		nowStep.Children = makeStruct[nowStep.RefId]
		queue = append(queue, nowStep.Children...)
		if nowStep.RealNodeId < 0 {
			queue = queue[1:]
			continue
		}
		detail, _ := businessManagementDao.QueryNodeDetail(nowStep.RealNodeId)
		nowStep.Data = detail
		queue = queue[1:]
	}
	v[0].Data.Name = businessManagement.ROOT_NODEREF_NAME
	return *v[0], nil
}

func (s *BusinessManagementService) QuerySimplifyTopology(treeId int) (topology businessManagement.Topology, err error) {
	start := time.Now()
	refs, err := businessManagementDao.QueryNodeRefByTreeId(treeId)
	logx.WithDuration(time.Since(start)).Debugf("QuerySimplifyTopology -1  refs %v   err %+v", utils.StructToJsonString(refs), err)
	if err != nil {
		return topology, err
	}

	tops := make([]businessManagement.Topology, 0, len(refs))
	for i := 0; i < len(refs); i++ {
		tops = append(tops, businessManagement.Topology{
			RefId:      refs[i].RefId,
			RealNodeId: refs[i].RealNodeId,
			ParentId:   refs[i].ParentId,
			IsLeaf:     false,
		})
	}
	// parent_id : []nodeRef
	// -2 鲁班根节点
	// -1 银河根节点
	// 然后找到ref_id的节点加入子节点列表中
	makeStruct := make(map[int][]*businessManagement.Topology)
	for i := 0; i < len(tops); i++ {
		if v, ok := makeStruct[tops[i].ParentId]; !ok {
			makeStruct[tops[i].ParentId] = []*businessManagement.Topology{&tops[i]}
		} else {
			makeStruct[tops[i].ParentId] = append(v, &tops[i])
		}
	}
	v, ok := makeStruct[-treeId]
	if !ok {
		return topology, errors.New("tree root node not found")
	}
	logx.WithDuration(time.Since(start)).Debugf("QuerySimplifyTopology -1 -1  v %v   err %+v", utils.StructToJsonString(v), err)

	queue := make([]*businessManagement.Topology, 0, len(makeStruct))
	for i := 0; i < len(v); i++ {
		v[i].Key = fmt.Sprintf("%v", v[i].RefId)
		queue = append(queue, v[i])
	}

	logx.WithDuration(time.Since(start)).Debugf("QuerySimplifyTopology -1 -2  v %v   err %+v", utils.StructToJsonString(v), err)

	logx.WithDuration(time.Since(start)).Debugf("QuerySimplifyTopology -2  makeStruct %v   err %+v", utils.StructToJsonString(makeStruct), err)
	count := 0
	for len(queue) != 0 {
		count++
		nowStep := queue[0]
		nowStep.Children = makeStruct[nowStep.RefId]
		for i := 0; i < len(nowStep.Children); i++ {
			nowStep.Children[i].Key = fmt.Sprintf("%s_%v", nowStep.Key, nowStep.Children[i].RefId)
		}
		queue = append(queue, nowStep.Children...)
		logx.WithDuration(time.Since(start)).Debugf("QuerySimplifyTopology -2 -1   nowStep %v   err %+v", utils.StructToJsonString(nowStep), err)
		if nowStep.RealNodeId < 0 {
			queue = queue[1:]
			continue
		}

		nodeDetail, _ := businessManagementDao.QueryNodeDetail(nowStep.RealNodeId)
		//logx.WithDuration(time.Since(start)).Debugf("QuerySimplifyTopology -1 - %+v   err %+v", count, err)

		nowStep.RealNodeId = nodeDetail.Id
		nowStep.Name = nodeDetail.Name
		for i := 0; i < len(nodeDetail.Services); i++ {
			key := fmt.Sprintf("%s_%v", nowStep.Key, nodeDetail.Services[i].Id)
			t := &businessManagement.Topology{
				Key:       key,
				IsLeaf:    true,
				ServiceId: nodeDetail.Services[i].Id,
				Name:      nodeDetail.Services[i].Name,
			}
			nowStep.Children = append(nowStep.Children, t)
		}
		queue = queue[1:]
	}

	v[0].Name = businessManagement.ROOT_NODEREF_NAME
	logx.WithDuration(time.Since(start)).Debugf("QuerySimplifyTopology -3  end   err %+v", err)
	return *v[0], nil
}

func (s *BusinessManagementService) InstallNode(nodeRef businessManagement.NodeRef) error {
	return businessManagementDao.CreateNodeRef(nodeRef)
}

func (s *BusinessManagementService) UninstallNode(refId int) error {
	return businessManagementDao.DeleteNodeRef(refId)
}

func (s *BusinessManagementService) QueryServiceInstanceByHostNameList(hostname string) (svcis []businessManagement.ServiceInstance, err error) {
	// 先用hostname查询出hostId，再用hostId查询所有的服务实例
	hostId, err := server.GetHostIdByHostName(hostname)
	if err != nil {
		return
	}
	if hostId == 0 {
		err = fmt.Errorf("未找到主机信息")
		return
	}
	svcis, err = businessManagementDao.QueryServiceInstancesByHostId(hostId)
	return
}

func (s *BusinessManagementService) LatestProcessList(full int) (result []businessManagement.ProcessLatest, err error) {
	//var processList []business.ServiceProcess
	var processList []businessManagement.ServiceProcess

	if full == 1 {
		//获取到全部远端进程
		//processList, err = business.RemoteProcessList()
		processList, err = businessManagementDao.RemoteProcessList()
		if err != nil {
			return
		}
	} else {
		//获取到最新11分钟的process数据
		t := time.Now().Add(-time.Minute * 11)
		//processList, err = business.QueryRemoteProcessByTime(t)
		processList, err = businessManagementDao.QueryRemoteProcessByTime(t)
		if err != nil {
			return
		}
	}

	//查询对应服务实例，根据服务实例查询ip等信息
	var svciIds []int
	for _, v := range processList {
		svciIds = append(svciIds, v.SvcInstanceId)
	}
	//instanceList, err := business.QueryInstanceByIds(svcIds)
	instanceList, err := businessManagementDao.QueryServiceInstancesByIds(svciIds)
	if err != nil {
		return
	}

	var svciMap = make(map[int]businessManagement.ServiceInstance)
	//todo 暂时无云主机
	var hostIds []int
	for _, v := range instanceList {
		if v.HostType == businessManagement.HOST_TYPE_PHYSICAL {
			hostIds = append(hostIds, v.HostId)
		}
		svciMap[v.Id] = v
	}

	type hostInfo struct {
		Id   int
		Ip   string
		Name string
	}

	var host2ip = make(map[int]hostInfo)
	hostList, err := server.QueryIpByIds(hostIds)
	klog.Infof("blackbox-debug ids: %+v hostList:%+v", hostIds, hostList)
	for _, v := range hostList {
		host2ip[v.Id] = hostInfo{
			Id:   v.Id,
			Ip:   v.Ip,
			Name: v.Name,
		}
	}

	//region && az
	//azList, err := basic.GetAzList(basic.Az{})
	//var azMap = make(map[int]basic.Az)
	//for _, v := range azList {
	//	azMap[v.Id] = v
	//}
	//regionList, err := basic.GetRegionList(basic.Region{})
	//var regionMap = make(map[int]basic.Region)
	//for _, v := range regionList {
	//	regionMap[v.Id] = v
	//}

	result = make([]businessManagement.ProcessLatest, len(processList))
	for i, v := range processList {
		svcInstance := svciMap[v.SvcInstanceId]
		//az := azMap[svcInstance.AzId].AzCode
		//region := regionMap[svcInstance.RegionId].RegionCode
		result[i] = businessManagement.ProcessLatest{
			Id:            v.Id,
			Name:          v.Name,
			Port:          v.Port,
			Protocol:      v.Protocol,
			SvcInstanceId: v.SvcInstanceId,
			Ip:            host2ip[svcInstance.HostId].Ip,
			//AzCode:        az,
			//RegionCode:    region,
			AzCode:     svcInstance.AzCode,
			RegionCode: svcInstance.RegionCode,
			SvcId:      svcInstance.ServiceId,
			HostName:   host2ip[svcInstance.HostId].Name,
		}
	}

	klog.Infof("blackbox-debug result:%+v", result)

	return
}
func (s *BusinessManagementService) GetAllPodsByNSandDeploy(params businessManagement.QueryServiceInstanceListParams) (svcs []businessManagement.ServiceInstance, err error) {
	klog.Errorf("GetAllPodsByNSandDeploy method begin, params: %+v", params)
	cl := client.GetClient()
	if cl == nil {
		cl = client.GetOuterClient()
		if cl == nil {
			return
		}
	}
	ds := k8sresource.K8sResource{Client: cl}
	ctx := context.Background()

	defer ctx.Done()
	wg := sync.WaitGroup{}
	wg.Add(2)
	q, err := s.QuerySimplifyTopology(2)
	// klog.Infof("QuerySimplifyTopology result is %v", q)
	if err != nil {
		klog.Errorf("querySimplifyTopology err is not nil : %v", err)
		return
	}
	if len(q.Children) <= 0 {
		klog.Errorf("querySimplifyTopology children len is 0")
		return
	}
	rows, count, err := server.GetPhysicalHostListByIps([]string{}, 0, 0)
	if err != nil || rows == nil {
		klog.Errorf("GetPhysicalHostListByIps error: %v", err)
		return
	}
	klog.Infof("PersistPodInstance serverlist  rows len: %d", count)

	serverlist := []serverModel.PhysicalHostData{}
	defer rows.Close()
	for rows.Next() {
		var dr serverModel.PhysicalHostData
		err := dao.AssetDB.ScanRows(rows, &dr)
		if err != nil {
			klog.Errorf("scan error: %v", err)
			continue
		}
		serverlist = append(serverlist, dr)
	}
	klog.Infof("PersistPodInstance serverlist len: %d", len(serverlist))
	start := time.Now()

	aggregatesVmMap := aggregate.GetAggregatesVmMap()
	//klog.Infof("GetAggregatesVmMap: %+v", aggregatesVmMap)

	var lock sync.Mutex
	var wg1 sync.WaitGroup
	for _, ns := range q.Children {
		wg1.Add(1)
		// klog.Infof("ns is: %v", ns)
		go func(ns *businessManagement.Topology) {
			defer wg1.Done()
			klog.Infof("Pod namespace: %s", ns.Name)
			if len(ns.Children) <= 0 {
				klog.Errorf("ns children length is 0")
				return
			}
			de, err := ds.GetDeploymentList(ctx, strings.ToLower(ns.Name))
			if err != nil {
				klog.Errorf("GetDeploymentList fail, err: %v", err)
				return
			}
			// klog.Infof("ds.GetDeploymentList: %+v", de)
			rs, err := ds.GetRsList(ctx, strings.ToLower(ns.Name))
			if err != nil {
				klog.Errorln(err)
				return
			}
			ps, err := ds.GetPodList(ctx, strings.ToLower(ns.Name))
			//klog.Infof("ds.GetPodList: %+v", ps)
			if err != nil {
				klog.Errorln(err)
				return
			}

			klog.Infof("Pod num: %d, namespace : %+v", len(ps.Items), ns.Name)

			var wg2 sync.WaitGroup
			for _, svc := range ns.Children {
				wg2.Add(1)
				go func(svc *businessManagement.Topology) {
					defer wg2.Done()

					klog.Infof("svc.Name : %s", svc.Name)
					poss, err := ds.GetPodsOfRsOfDeploy(ctx, ps, rs, de, svc.ServiceId, svc.Name, params, serverlist, aggregatesVmMap)
					if err != nil {
						klog.Errorf("GetPodsOfRsOfDeploy err: %v", err)
						return
					}
					klog.Infof("GetPodsOfRsOfDeploy pod: %+v", poss)
					klog.Infof("GetPodsOfRsOfDeploy: len : %v", len(poss))
					// de, err := ds.GetDeployment(ctx, strings.ToLower(svc.Name), strings.ToLower(ns.Name))
					// if err != nil {
					// 	klog.Errorln(err)
					// 	continue
					// }
					// //fmt.Printf("%#v", de)
					// rs, err := ds.GetRs(ctx, de)
					// if err != nil {
					// 	klog.Errorln(err)
					// 	continue
					// }
					// ps, err := ds.GetPodsTT(ctx, strings.ToLower(ns.Name), svc.ServiceId, svc.Name, params, rows, aggregatesVmMap)
					// if err != nil {
					// 	klog.Errorln(err)
					// 	continue
					// }
					// poss, err := ds.GetPodsOfRs(ctx, ps, rs, svc.ServiceId, svc.Name, params, rows, aggregatesVmMap)
					// if err != nil {
					// 	klog.Errorln(err)
					// 	continue
					// }
					// pods, err := ds.GetPods(ctx, rs, svc.ServiceId, svc.Name, params, rows, aggregatesVmMap)
					// if err != nil {
					// 	klog.Errorln(err)
					// 	continue
					// }
					lock.Lock()
					svcs = append(svcs, poss...)
					lock.Unlock()

				}(svc)
			}
			wg2.Wait()

		}(ns)
	}
	wg1.Wait()
	fmt.Println("花费时间:", time.Since(start).Seconds())
	return
}

// 对数据进行排序（按创建时间戳降序）
func (s *BusinessManagementService) SortServiceInstanceList(list []businessManagement.ServiceInstance) ([]interface{}, error) {
	results := Bucket{}
	sortList := make([]interface{}, len(list))
	for i := range list {
		sortList[i] = list[i]
	}
	results.Slice = sortList
	time_by := func(a, b interface{}) bool {
		return a.(businessManagement.ServiceInstance).CreateTime.Unix() > b.(businessManagement.ServiceInstance).CreateTime.Unix()
	}
	results.By = time_by
	sort.Sort(results)
	return results.Slice, nil
}

// 对数据进行排序（按创建时间戳升序）
func (s *BusinessManagementService) AscSortServiceInstanceList(list []businessManagement.ServiceInstance) ([]interface{}, error) {
	results := Bucket{}
	sortList := make([]interface{}, len(list))
	for i := range list {
		sortList[i] = list[i]
	}
	results.Slice = sortList
	time_by := func(a, b interface{}) bool {
		return a.(businessManagement.ServiceInstance).CreateTime.Unix() < b.(businessManagement.ServiceInstance).CreateTime.Unix()
	}
	results.By = time_by
	sort.Sort(results)
	return results.Slice, nil
}

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/pkg/service/cabinet.go
```golang
package service

import (
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"luban-cmdb-api/pkg/dao/cabidao"
	"luban-cmdb-api/pkg/dao/rackdao"
	"luban-cmdb-api/pkg/models/cabinet"
	"luban-cmdb-api/pkg/models/rack"
	"luban-cmdb-api/pkg/utils"
	"strconv"

	"github.com/dgraph-io/dgo/v200"
	"github.com/go-playground/validator/v10"
	"k8s.io/klog/v2"

	"gorm.io/gorm"
)

type CabinetService struct {
	//dgraphClient *dgo.Dgraph
	LabService   *LabService
	BasicService *BasicService
}

//func NewCabinetService(dgraphClient *dgo.Dgraph, labService *LabService, basicService *BasicService) *CabinetService {
func NewCabinetService(labService *LabService, basicService *BasicService) *CabinetService {
	return &CabinetService{
		//dgraphClient: dgraphClient,
		LabService:   labService,
		BasicService: basicService,
	}

}

func (cs *CabinetService) GetCabinetList(params cabinet.QueryCabinetParam) (cabinet.CabinetListResponse, error) {
	klog.Infof("GetCabinetList params:%+v", params)
	res := cabinet.CabinetListResponse{
		PageNo:   params.PageNo,
		PageSize: params.PageSize,
	}
	if params.PageNo > 0 {
		params.PageNo -= 1
	} else {
		return res, errors.New("invalid pageNo")
	}
	if params.ID != nil {
		if idStr, ok := params.ID.(string); ok {
			if idInt, err := strconv.Atoi(idStr); err == nil {
				params.ID = idInt
			} else {
				return res, err
			}
		} else if _, ok := params.ID.(int); !ok {
			return res, errors.New("invalid id")
		}
	}
	validate := validator.New()
	err := validate.Struct(params)
	if err != nil {
		fmt.Println(err)
		return res, err
	}
	cabinetInfoList, err := cabidao.SelectCabinetInfoByCons(params)
	if err != nil || len(cabinetInfoList) == 0 {
		return res, err
	}
	res.TotalCount = cabinetInfoList[0].CabinetCount
	res.DataList = cabinetInfoList
	return res, nil
}

func (cs *CabinetService) CreateCabinet(params cabinet.CabinetParam, userName string) error {
	klog.Infof("CreateCabinet params:%+v", params)
	validate := validator.New()
	err := validate.Struct(params)
	if err != nil {
		klog.Errorf("CreateCabinet数据校验未通过:%+v", err)
		return errors.New("创建机柜异常")
	}
	klog.Info("CreateCabinet - debug 1")

	//查询房间和机房信息
	roomInfo, err := cabidao.SelectChimeraByRoomCode(params.CabinetRoomCode)
	if err != nil {
		//return err
		klog.Infof("CreateCabinet - debug 2 %+v", roomInfo)
		return errors.New("未查到房间或者机房信息")
	}
	klog.Infof("CreateCabinet - debug 3 %+v", roomInfo)
	if roomInfo.LabCode == "" {
		//return err
		klog.Infof("CreateCabinet - debug 4 %+v", roomInfo)
		return errors.New("未查到机房信息")
	}

	//校验机柜名称
	checkName, nameError := cs.checkCabinetName(params.CabinetName, roomInfo.RoomId)
	if nameError != nil {
		klog.Errorf("CreateCabinet.checkCabinetName校验未通过:%+v", nameError)
		return errors.New("创建机柜异常")
	}
	if !checkName {
		return errors.New("机柜名称重复")
	}

	klog.Info("CreateCabinet - debug 5")

	// userName, err := GetUserName(Authorization)
	// if err != nil {
	// 	return err
	// }

	var racks []*rackdao.Rack
	for i := 0; i < params.CabinetCapacity; i++ {
		//机架位名称:机房代码-房间代码-机柜名称-机架位号，例如HZ01-13F-cabnit02-6
		rackName := fmt.Sprintf("%s-%s-%s-%d", roomInfo.LabCode, roomInfo.DeviceRoomCode, params.CabinetName, i)
		racks = append(racks, &rackdao.Rack{
			RackName:    rackName,
			AzId:        roomInfo.AzId,
			RegionId:    roomInfo.RegionId,
			LabId:       roomInfo.LabId,
			RoomId:      roomInfo.RoomId,
			RackCreator: userName,
			RackUpdater: userName,
		})
	}
	cabinetEntity := &cabidao.Cabinet{
		RegionId:           roomInfo.RegionId,
		AzId:               roomInfo.AzId,
		RoomId:             roomInfo.RoomId,
		LabId:              roomInfo.LabId,
		CabinetName:        params.CabinetName,
		CabinetCapacity:    params.CabinetCapacity,
		CabinetElectricity: params.CabinetElectricity,
		CabinetPower:       params.CabinetPower,
		PDUJackNum:         params.PDUJackNum,
		PDUJackType:        params.PDUJackType,
		CabinetBrand:       params.CabinetBrand,
		CabinetType:        params.CabinetType,
		CabinetCreator:     userName,
		CabinetUpdater:     userName,
	}
	err = cabidao.InsertCabinetAndRacksByTransaction(cabinetEntity, racks)
	if err != nil {
		return err
	}
	return nil
}

func (cs *CabinetService) checkCabinetName(cabinetName string, roomId int) (bool, error) {
	klog.Infof("checkCabinetName params:%+v, %+v", cabinetName, roomId)
	//同一个房间内不允许机柜重名，不同房间可以存在同名机柜
	cabinetInfoList, err := cabidao.SelectCabinetByConds(cabidao.Cabinet{CabinetName: cabinetName, RoomId: roomId})
	if err != nil {
		return false, err
	}

	if len(cabinetInfoList) == 0 {
		return true, nil
	} else {
		return false, nil
	}
}

func (cs *CabinetService) DeleteCabinets(params cabinet.DeleteCabinetParam) error {
	klog.Infof("DeleteCabinets params:%+v", params)
	validate := validator.New()
	err := validate.Struct(params)
	if err != nil {
		fmt.Println(err)
		return err
	}

	//先查询是否存在机柜下有被占用的机架位
	cantRemoveCabinets, err := rackdao.SelectCabinetIdByConds("deleted = 0 and rack_status = 1 and cabinet_id in (?)", params.CabinetIds)
	if err != nil {
		return errors.New(fmt.Sprintf("DeleteCabinets,query error: %s", err.Error()))
	}

	//总的删除实体
	removeCabinets := utils.IntSliceDifference(params.CabinetIds, cantRemoveCabinets)
	if len(removeCabinets) > 0 {
		_, err = cabidao.DeleteCabinetsAndRacksByTransaction(removeCabinets)
		if err != nil {
			klog.Error("机柜删除失败", err)
			//return fmt.Errorf("机柜删除失败")
			return err
		}
	}

	if len(cantRemoveCabinets) > 0 {
		cantRemoveCabinetNames, err := cabidao.SelectCabinetNameByIds(cantRemoveCabinets)
		if err != nil {
			klog.Error("SelectCabinetNameByIds err :", err)
			return err
		}
		return errors.New(fmt.Sprintf("These Cabinets has occupied racks. DeleteCabinets failed. CabinetNames: %v", cantRemoveCabinetNames))
	}

	return nil
}

func (cs *CabinetService) CabinetDetail(id int) (cabinet.CabinetInfo, error) {
	klog.Infof("CabinetDetail id:%s", id)
	cabinetInfo, err := cabidao.SelectCabinetInfo(id)
	if err != nil {
		return cabinetInfo, err
	}
	return cabinetInfo, nil
}

func (cs *CabinetService) UpdateCabinet(params cabinet.CabinetParam) error {
	klog.Infof("UpdateCabinet params:%+v", params)
	//_, queryE := cs.CabinetDetail(params.Uid)
	_, queryE := cabidao.SelectCabinetById(params.Uid)
	if queryE == gorm.ErrRecordNotFound {
		return errors.New("未查到原机柜信息")
	} else if queryE != nil {
		return queryE
	}
	updateInfo := &cabidao.Cabinet{
		CabinetElectricity: params.CabinetElectricity,
		CabinetPower:       params.CabinetPower,
		CabinetName:        params.CabinetName,
		CabinetBrand:       params.CabinetBrand,
		CabinetType:        params.CabinetType,
		CabinetUpdater:     params.CabinetUpdater,
		CabinetDesc:        params.CabinetDesc,
		Uid:                params.Uid,
		AzId:               params.AzId,
		RegionId:           params.RegionId,
		LabId:              params.LabId,
		RoomId:             params.RoomId,
		CabinetCapacity:    params.CabinetCapacity,
		PDUJackNum:         params.PDUJackNum,
		PDUJackType:        params.PDUJackType,
	}
	_, err := cabidao.UpdateCabinetById(updateInfo)
	if err != nil {
		return err
	}
	return nil
}

func queryRoomByCode(roomId int) (cabidao.Chimera, error) {
	chimera, err := cabidao.SelectChimeraByRoomId(roomId)
	if err != nil {
		return chimera, err
	}
	return chimera, nil
}

func queryRackByCabinetName(client *dgo.Dgraph, cabinetName string) ([]rack.RackInfo, error) {
	var racks []rack.RackInfo
	q := `
			{
				rackInfoList(func: type(Rack)) %s{
						uid             
						rackName        
						rackLab         
						rackLabCode
			  }
			}
			`
	queryInfo := " @filter(%s)"
	queryInfo = fmt.Sprintf(queryInfo, fmt.Sprintf(`eq(rackCabinetCode,"%s")`, cabinetName))
	q = fmt.Sprintf(q, queryInfo)
	response, err := client.NewTxn().Query(context.TODO(), q)
	if err != nil {
		return racks, err
	}
	rackInfoList := rack.GetRackList{}
	err = json.Unmarshal(response.Json, &rackInfoList)
	if err != nil {
		return racks, err
	}
	if len(rackInfoList.RackInfoList) != 0 {
		racks = rackInfoList.RackInfoList
	}
	return racks, nil
}

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/pkg/service/dbResourcePool.go
```golang
package service

import (
	"context"
	"encoding/json"
	"luban-cmdb-api/pkg/gredis"
	"strings"
	"time"

	"k8s.io/klog/v2"
)

//DbResourcePool 数据库资源池
type DbResourcePool struct {
	ID                 string `json:"id"`
	Name               string `json:"name"`
	RegionCode         string `json:"regionCode"`
	RegionName         string `json:"regionName"`
	AzCode             string `json:"azCode"`
	AzName             string `json:"azName"`
	CreatedAt          int64  `json:"createdAt"`
	DBCount            int64  `json:"dbCount"`
	DBType             string `json:"dbType"`
	DiskAvailableLeast int64  `json:"diskAvailableLeast"`
	LocalGb            int64  `json:"localGb"`
	LocalGbFree        int64  `json:"localGbFree"`
	LocalGbUsed        int64  `json:"localGbUsed"`
	MemoryMb           int64  `json:"memoryMb"`
	MemoryMbFree       int64  `json:"memoryMbFree"`
	MemoryMbUsed       int64  `json:"memoryMbUsed"`
	RunningVms         int64  `json:"runningVms"`
	SvrCount           int64  `json:"svrCount"`
	Vcpus              int64  `json:"vcpus"`
	VcpusUsed          int64  `json:"vcpusUsed"`
}

//从缓存中取出资源池
func getDbPoolList() ([]DbResourcePool, error) {
	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
	defer cancel()

	rs, err := gredis.HGetAll(ctx, gredis.DbMapKey)
	if err != nil {
		klog.Error("database resource pool read from redis failure:", err.Error())
		return nil, err
	}
	var resultList []string
	dbPoolList := []DbResourcePool{}
	for _, str := range rs {
		resultList = append(resultList, str)
	}
	rsStr := "[" + strings.Join(resultList, ",") + "]"
	err = json.Unmarshal([]byte(rsStr), &dbPoolList)
	if err != nil {
		klog.Error("AggregatesVmMap Unmarshal failure:", err.Error())
		return nil, err
	}
	return dbPoolList, nil
}

//GetMysqlPoolList 获取mysql资源池列表
func GetMysqlPoolList() ([]DbResourcePool, error) {
	mysqlPoolList := []DbResourcePool{}

	dbPoolList, err := getDbPoolList()
	if err != nil {
		return nil, err
	}
	for i := range dbPoolList {
		if dbPoolList[i].DBType == "mysql" {
			mysqlPoolList = append(mysqlPoolList, dbPoolList[i])
		}
	}

	return mysqlPoolList, nil
}

//GetRedisPoolList 获取redis资源池列表
func GetRedisPoolList() ([]DbResourcePool, error) {
	mysqlPoolList := []DbResourcePool{}

	dbPoolList, err := getDbPoolList()
	if err != nil {
		return nil, err
	}
	for i := range dbPoolList {
		if dbPoolList[i].DBType == "redis" {
			mysqlPoolList = append(mysqlPoolList, dbPoolList[i])
		}
	}

	return mysqlPoolList, nil
}

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/pkg/service/overview.go
```golang
package service

import (
	"context"
	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/schema/field"
	"luban-cmdb-api/data/ent/ebsvolume"
	"luban-cmdb-api/pkg/apiserver/config"
	"luban-cmdb-api/pkg/dao"
	"luban-cmdb-api/pkg/handler"
	"luban-cmdb-api/pkg/models/aggregate"
	"luban-cmdb-api/pkg/models/server"
	"luban-cmdb-api/pkg/models/storage"
	"strings"
	"time"

	"k8s.io/klog/v2"

	"github.com/dgraph-io/dgo/v200"
	"github.com/gophercloud/gophercloud"
)

type OverviewService struct {
	serverService            *ServerService
	aggregateService         *AggregateService
	blockStoragePoolService  *BlockStoragePoolService
	objectStoragePoolService *ObjectStoragePool
	handler.ObjectStorageBucketService
}

func NewOverviewService(dgraphclient *dgo.Dgraph, novaclient *gophercloud.ServiceClient, identityClient *gophercloud.ServiceClient, config *config.Config) *OverviewService {
	return &OverviewService{
		serverService:            NewServerService(dgraphclient),
		aggregateService:         NewAggregateService(novaclient, identityClient, *config),
		blockStoragePoolService:  NewBlockStoragePoolService(config.EBSAddr, config.StorageStateAddr, dgraphclient),
		objectStoragePoolService: NewObjectStoragePoolService(config.StorageStateAddr, config.PrometheusAddr, config.CustomerDomain, dgraphclient),
	}
}

// GetObjectStorageInfo 获取对象存储bucket
func (s *OverviewService) GetObjectStorageInfo(region string) (bucketCount int, err error) {

	bucketRequest := storage.BucketRequest{}
	if region == "all" {
		bucketRequest.Region = ""
	}
	bucketList, err := s.objectStoragePoolService.GetBucketListAll(bucketRequest)
	if err != nil {
		klog.Errorln("o.GetBucketListAll(bucketRequest) err:", err)
		return 0, err
	}
	bucketCount = len(bucketList)
	return
}

// GetObjectStorageCount 获取对象存储bucket数量
func (s *OverviewService) GetObjectStorageCount(region string) (bucketCount int, err error) {
	bucketRequest := storage.BucketRequest{}
	if region == "all" {
		bucketRequest.Region = ""
	}
	bucketCount, err = s.objectStoragePoolService.GetObjectStorageCount(bucketRequest)

	if err != nil {
		klog.Errorln("o.GetObjectStorageCount(bucketRequest) err:", err)
		return 0, err
	}

	return
}

// GetPhysicalHostInfo 获取服务器的总数、运行数、故障数、已过保数、一个月内以过保数、三个月内已过保数
func (s *OverviewService) GetPhysicalHostInfo(region, az string) (totalCount, runningCount, errorCount, insuredCount, insured1mCount, insured3mCount int, err error) {
	var physicalHostListQuery server.PhysicalHostListQuery
	physicalHostListQuery.PageNo = 0
	//physicalHostListQuery.Region = region
	if region != "" && region != "all" {
		physicalHostListQuery.Region = []string{region}
	}
	if az != "" && az != "all" {
		physicalHostListQuery.Az = []string{az}
	}
	HostDistributionOverview := make(map[string]int)
	totalCount, runningCount, errorCount, insuredCount, insured1mCount, insured3mCount = 0, 0, 0, 0, 0, 0
	physicalHostAll, err := s.serverService.GetPhysicalHostList(physicalHostListQuery)
	if err != nil {
		return 0, 0, 0, 0, 0, 0, err
	}
	for _, host := range physicalHostAll.DataList {

		aggHost := host
		if vmCount, ok := HostDistributionOverview[aggHost.HostRegionName+aggHost.HostAzName]; ok {
			HostDistributionOverview[aggHost.HostRegionName+aggHost.HostAzName] = vmCount + 1
		} else {
			HostDistributionOverview[aggHost.HostRegionName+aggHost.HostAzName] = 1
		}
		if strings.ToLower(aggHost.Runstatus) == "up" {
			runningCount++
		} else {
			errorCount++
		}
		//if aggHost.MaintenanceDue > 0 {
		//	i64 := aggHost.MaintenanceDue.Unix()
		//	cout := (i64 - time.Now().Unix()) / 86400
		//	if err == nil {
		//		switch {
		//		case cout <= 0:
		//			insuredCount++
		//		case 0 < cout && cout < 30:
		//			insured1mCount++
		//		case 30 < cout && cout < 90:
		//			insured3mCount++
		//		}
		//	}
		//}

		//判断维保到期时间是否为空 不为空
		var nullableTime sql.NullTime
		nullableTime.Time = aggHost.MaintenanceDue
		nullableTime.Valid = aggHost.MaintenanceDue != time.Time{}
		if nullableTime.Valid {
			i64 := aggHost.MaintenanceDue.Unix()
			cout := (i64 - time.Now().Unix()) / 86400
			if err == nil {
				switch {
				case cout <= 0:
					insuredCount++
				case 0 < cout && cout < 30:
					insured1mCount++
				case 30 < cout && cout < 90:
					insured3mCount++
				}
			}
		}

		totalCount++
	}
	return
}

// GetInstanceInfo 获取云主机的总数、运行数、故障数
func (s *OverviewService) GetInstanceInfo(region, az string) (instanceTotalCount, instanceRunningCount, instanceErrorCount int, err error) {
	//临时处理
	// azList := []string{}
	// if az != "" && az != "all" {
	// 	azList = append(azList, az)
	// }
	//aggregatesData, err := s.aggregateService.GetAggregateAllForPage(aggregate.AggregatesListQuery{Region: region, Az: azList})
	// if len(aggregatesData) <= 0 || err != nil {
	// 	return
	// }
	// for _, aggregat := range aggregatesData {

	// 	//VmDataList, err := s.aggregateService.GetAggregateVMsAll(strconv.Itoa(aggregat.Id), []string{})
	// 	VmDataList, err := s.aggregateService.GetVMsList(aggregate.VMListQuery{AggregateId: aggregat.Id, Region: region, Az: azList})
	// 	if err != nil {
	// 		return 0, 0, 0, err
	// 	}
	// 	for _, data := range VmDataList {
	// 		//查询等于服务器name的云主机列表
	// 		// if (region == "all" || data.RegionCode == region) &&
	// 		// 	(az == "all" || data.AzCode == az) {
	// 		instanceTotalCount++
	// 		if data.Status == "active" {
	// 			instanceRunningCount++
	// 		} else if data.Status == "error" {
	// 			instanceErrorCount++
	// 		}
	// 		//}

	// 	}
	// }
	azList := []string{}
	if az != "" && az != "all" {
		azList = append(azList, az)
	}
	VmDataList, err := s.aggregateService.GetVMsList(aggregate.VMListQuery{Region: region, Az: azList})
	if err != nil {
		return 0, 0, 0, err
	}
	for _, data := range VmDataList {
		//查询等于服务器name的云主机列表
		// if (region == "all" || data.RegionCode == region) &&
		// 	(az == "all" || data.AzCode == az) {
		instanceTotalCount++
		if data.Status == "active" {
			instanceRunningCount++
		} else if data.Status == "error" {
			instanceErrorCount++
		}
		//}

	}
	return
}

// GetCloudDiskInfo 获取云硬盘的总数、运行数、故障数、待挂载数
func (s *OverviewService) GetCloudDiskInfo(region, az string) (cloudDiskTotalCount, cloudDiskUsedCount, cloudDiskErrorCount, cloudDiskAvailableCount int, err error) {
	//ebsAPIRequest := EBSAPIRequest{}
	//临时处理
	azList := []string{}
	if az != "" && az != "all" {
		azList = append(azList, az)
	}
	cloudDiskReq := storage.CloudDiskRequest{
		Region: region,
		Az:     azList,
	}
	// if region != "all" {
	// 	ebsAPIRequest.Region = region
	// }
	// ebsAPIRequest.Size = 10000
	cloudDiskList, err := s.blockStoragePoolService.GetCloudDiskListAll(cloudDiskReq)
	if err != nil {
		return 0, 0, 0, 0, err
	}
	for _, volume := range cloudDiskList {
		//if az == "all" || az == volume.Zone {
		if volume.UseStatus == "in-use" {
			cloudDiskUsedCount++
		} else if volume.UseStatus == "available" {
			cloudDiskAvailableCount++
		} else if volume.UseStatus == "error" {
			cloudDiskErrorCount++
		}
		cloudDiskTotalCount++
		//}
	}
	return
}

// GetBlockStorageCount  获取块存储数量
func (s *OverviewService) GetBlockStorageCount(region, az string) (cloudDiskTotalCount, cloudDiskUsedCount, cloudDiskErrorCount, cloudDiskAvailableCount int, err error) {
	// 参数处理
	var azList []string
	if az != "" && az != "all" {
		azList = append(azList, az)
	}
	cloudDiskReq := storage.CloudDiskRequest{
		Region: region,
		Az:     azList,
	}
	// 组装sql
	query := dao.BusinessDB.EbsVolume.Query()
	if cloudDiskReq.Region != "" && cloudDiskReq.Region != "all" {
		query = query.Where(ebsvolume.Region(cloudDiskReq.Region))
	}
	if len(cloudDiskReq.Az) > 0 {
		query = query.Where(ebsvolume.AzIn(cloudDiskReq.Az...))
	}

	cloudDiskTotalCount, err = query.Count(context.Background())
	if err != nil {
		return 0, 0, 0, 0, err
	}
	cloudDiskUsedCount, err = query.Where(ebsvolume.Status("in-use")).Count(context.Background())
	if err != nil {
		return cloudDiskTotalCount, 0, 0, 0, err
	}
	cloudDiskErrorCount, err = query.Where(ebsvolume.Status("error")).Count(context.Background())
	if err != nil {
		return cloudDiskTotalCount, cloudDiskUsedCount, 0, 0, err
	}
	cloudDiskAvailableCount, err = query.Where(ebsvolume.Status("available")).Count(context.Background())
	if err != nil {
		return cloudDiskTotalCount, cloudDiskUsedCount, cloudDiskErrorCount, 0, err
	}
	return cloudDiskTotalCount, cloudDiskUsedCount, cloudDiskErrorCount, cloudDiskAvailableCount, nil
}

// Fields of the EBSVolume.
func (EBSVolume) Fields() []ent.Field {
	return []ent.Field{
		field.String("type"),
	}
}

// Edges of the EBSVolume.
func (EBSVolume) Edges() []ent.Edge {
	return nil
}

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/pkg/service/yamlservice.go
```golang
package service

import (
	"fmt"
	"io/ioutil"
	"net/http"
	"strings"

	yamlmodel "luban-cmdb-api/pkg/models/yaml"

	"gopkg.in/yaml.v2"
)

func GetServiceFromYaml() ([]yamlmodel.Service, error) {
	resp, err := http.Get("http://config.luban/luban_on_k8s/process/config.yaml")
	if err != nil {
		fmt.Println(err)
	}
	defer resp.Body.Close()
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		fmt.Println(err)
	}
	newProcess := &yamlmodel.ServiceData{}
	err = yaml.Unmarshal(body, &newProcess)
	if err != nil {
		fmt.Println(err)
	}
	fmt.Println("newProcess")
	fmt.Println(newProcess)
	return newProcess.ProcessNames, err
}
func GetServiceByIp(ips []string) string {
	serviceList, _ := GetServiceFromYaml()
	count := len(serviceList)
	serviceMap := make(map[string]string)
	ipsString := strings.Join(ips, ",")
	for i := 0; i < count; i++ {
		ipsCount := len(ips)
		for j := 0; j < ipsCount; j++ {
			if BoolTagInArray(serviceList[i].Hosts, ips[j]) {
				serviceMap[serviceList[i].ServiceName] = ipsString
			}
		}
	}
	responseService := ""
	for key := range serviceMap {
		responseService = fmt.Sprintf("%s,%s", responseService, key)
	}
	if responseService != "" {
		responseService = strings.TrimLeft(responseService, ",")
	}
	return responseService
}

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/pkg/service/xgwResourcePool.go
```golang
package service

import "luban-cmdb-api/pkg/models/netPoolModel"

// NetResourcePool 网络资源池
// type NetResourcePool struct {
// 	Hosts       []string `json:"hosts"`
// 	PoolName    string   `json:"poolName"`
// 	PoolType    string   `json:"poolType"`
// 	RegionCode  string   `json:"regionCode"`
// 	RegionName  string   `json:"regionName"`
// 	ServerCount int64    `json:"serverCount"`
// 	EipCount    int64    `json:"eipCount"`
// 	LbCount     int64    `json:"lbCount"`
// 	NatCount    int64    `json:"natCount"`
// 	CreatedAt   int64    `json:"createdAt"`
// }

// GetXGWPoolMap 获取XGW资源池列表
func GetXGWPoolMap() (map[string]netPoolModel.NetWorkResource, error) {

	netPoolList, err := getNetworkPool()
	if err != nil {
		return nil, err
	}

	//XGW资源池有两个，其中Hosts字段会出现重复值，所以这里使用一个map类型去重，Hosts字段中的的每个值都要获取到
	xgwPoolMap := make(map[string]netPoolModel.NetWorkResource)
	for i := range netPoolList {
		if netPoolList[i].PoolType == "XGW" {
			for j := range netPoolList[i].Hosts {
				xgwPoolMap[netPoolList[i].Hosts[j]] = netPoolList[i]
			}
		}
	}

	return xgwPoolMap, nil
}

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/pkg/service/thirdCalls.go
```golang
package service

import (
	"errors"
	"fmt"
	"io/ioutil"
	"net/http"
	"strings"

	"k8s.io/klog/v2"
)

type SimpleHttpClient struct{}

func (s *SimpleHttpClient) SimpleHttpGet(url string) ([]byte, error) {
	//klog.Infof("Simple get url: %s", url)
	resp, err := http.Get(url)
	// TODO check response code,  4xx 5xx, make error
	if err != nil {
		klog.Errorf("Error when get url: %s, %s", url, err)
		return nil, err
	}
	if strings.HasPrefix(resp.Status, "5") || strings.HasPrefix(resp.Status, "4") {
		err = errors.New(fmt.Sprintf("Error when Get url=(%s) with %s status", url, resp.Status))
		klog.Error(err)
		return nil, err
	}
	defer resp.Body.Close()
	return ioutil.ReadAll(resp.Body)
}

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/pkg/service/businessManagementInit_test.go
```golang
package service_test

import (
	"luban-cmdb-api/pkg/service"
	"testing"
)

type Example struct {
}

func (e Example) LoadData() []service.ServiceSlot {
	return []service.ServiceSlot{
		{Name: "test-init-1", RegionCode: "cn-shanghai-2", Instances: []service.InstanceSlot{
			{
				HostName:   "redis-03.yunyan.com",
				RegionCode: "cn-shanghai-2",
				AzCode:     "cn-shanghai-2a",
				HostType:   0,
			},
			{
				HostName:   "redis-02.yunyan.com",
				RegionCode: "cn-shanghai-2",
				AzCode:     "cn-shanghai-2a",
				HostType:   0,
			},
			{
				Ip:         "10.178.224.103",
				RegionCode: "cn-shanghai-2",
				AzCode:     "cn-shanghai-2a",
				HostType:   0,
			},
		}},
		{Name: "test-init-2", RegionCode: "cn-shanghai-2", Instances: []service.InstanceSlot{
			{
				Name:       "test-init-2-node",
				HostName:   "rds-compute-01",
				RegionCode: "cn-shanghai-2",
				AzCode:     "cn-shanghai-2a",
				HostType:   0,
			},
			{
				HostName:   "rds-compute-02",
				RegionCode: "cn-shanghai-2",
				AzCode:     "cn-shanghai-2a",
				HostType:   0,
			},
			{
				Ip:         "10.178.224.148",
				RegionCode: "cn-shanghai-2",
				AzCode:     "cn-shanghai-2a",
				HostType:   0,
			},
		}},
	}
}

func TestInitBusinessModule(t *testing.T) {
	//klog.Infof("start server")
	//service.InitBusinessModule(Example{})
	//klog.Infof("server end")
}

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/pkg/service/lab.go
```golang
package service

import (
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"luban-cmdb-api/pkg/dao"
	basicdao "luban-cmdb-api/pkg/dao/basic"
	contactdao "luban-cmdb-api/pkg/dao/contact"
	deviceroomdao "luban-cmdb-api/pkg/dao/deviceroom"
	labdao "luban-cmdb-api/pkg/dao/lab"
	"luban-cmdb-api/pkg/models/deviceroom"
	"luban-cmdb-api/pkg/models/lab"
	"luban-cmdb-api/pkg/service/contact"
	contactservice "luban-cmdb-api/pkg/service/contact"

	"github.com/dgraph-io/dgo/v200"
	"gorm.io/gorm"
	"k8s.io/klog/v2"
)

type LabService struct {
	dgraphClient *dgo.Dgraph
}

func NewLabService(dgraphClient *dgo.Dgraph) *LabService {
	return &LabService{
		dgraphClient: dgraphClient,
	}
}

func (ls *LabService) GetLabList(params lab.LabQueryParams) (lab.LabListResponse, error) {
	res := lab.LabListResponse{
		PageNo:     params.PageNo,
		PageSize:   params.PageSize,
		TotalCount: 0,
	}
	rows, count, err := labdao.GetLabPageList(params)
	if err != nil {
		klog.Error(err)
		return res, err
	}
	if count <= 0 {
		return res, err
	}
	res.TotalCount = count
	//循环赋值
	defer rows.Close()
	labList := []lab.LabInfo{}
	labIds := []int{}
	for rows.Next() {
		var dr lab.LabInfo
		dao.AssetDB.ScanRows(rows, &dr)
		labList = append(labList, dr)
		labIds = append(labIds, dr.Uid)
	}
	labContactMap, err := contact.FindLabContacts(labIds)
	if err == nil {
		labLen := len(labList)
		for i := 0; i < labLen; i++ {
			mainC, otherC := LabContact(labContactMap[labList[i].Uid])
			labList[i].MainContact = mainC
			labList[i].OtherContacts = otherC
		}
	}
	res.DataList = labList
	return res, nil
}

func LabContact(labContact contact.Contact) (mainC lab.ContactsMapping, otherC []lab.ContactsMapping) {
	//fmt.Printf("labContactMap:%#v", labContact)
	if labContact.Main.Id > 0 {
		mainC.Uid = labContact.Main.Id
		mainC.LinkName = labContact.Main.Name
		mainC.LinkPhoneNumber = labContact.Main.Phone
	}
	if len(labContact.Others) > 0 {
		otherLen := len(labContact.Others)
		for i := 0; i < otherLen; i++ {
			otherC = append(otherC, lab.ContactsMapping{
				Uid:             labContact.Others[i].Id,
				LinkName:        labContact.Others[i].Name,
				LinkPhoneNumber: labContact.Others[i].Phone,
			})
		}
	}
	return
}

func (ls *LabService) CreateLab(params lab.CreateLabQuery, userName string) error {

	hasDr, err := labdao.GetLabByCodeOrName(params.LabCode, params.LabName)
	if err != gorm.ErrRecordNotFound && err != nil {
		return err
	}
	if hasDr.Id > 0 {
		return fmt.Errorf("机房中文或代号重复，请更换后重试")
	}
	if params.AzCode == "" {
		return fmt.Errorf("可用区不能为空")
	}
	azInfo, err := basicdao.GetAz(basicdao.Az{
		AzCode: params.AzCode,
	})
	if err != nil {
		return err
	}
	// userName, err := GetUserName(Authorization)
	// //userName := "system"
	// if err != nil {
	// 	return err
	// }

	//插入数据
	labInfo := labdao.Lab{
		LabName:         params.LabName,
		LabCode:         params.LabCode,
		AzId:            azInfo.Id,
		RegionId:        azInfo.RegionId,
		Address:         params.LabAddress,
		ServiceProvider: params.ServiceProvider,
		Description:     params.Description,
		Power:           params.Power,
		SparePower:      params.SparePower,
		Creator:         userName,
		Updater:         userName,
	}
	drId, err := labdao.AddLab(labInfo)
	if err != nil {
		return err
	}
	//组装联系人
	var cs []contactdao.Contact
	cs = append(cs, contactdao.Contact{
		Name:     params.MainContact.LinkName,
		Phone:    params.MainContact.LinkPhoneNumber,
		TypeId:   drId,
		TypeName: contactdao.TYPE_LAB,     //类型为房间
		Level:    contactdao.CONTACT_MAIN, //级别为主要联系人
		Creator:  userName,
		Updater:  userName,
	})
	for _, c := range params.OtherContacts {
		cs = append(cs, contactdao.Contact{
			Name:     c.LinkName,
			Phone:    c.LinkPhoneNumber,
			TypeId:   drId,
			TypeName: contactdao.TYPE_LAB,      //类型为房间
			Level:    contactdao.CONTACT_OTHER, //级别为次要联系人
			Creator:  userName,
			Updater:  userName,
		})
	}

	err = contactdao.BatchAddContact(cs)

	return nil
}

func (ls *LabService) DeleteLabs(params lab.DeleteParams, userName string) (msg string, err error) {
	idsInt := len(params.LabIds)
	if idsInt == 0 {
		return "", fmt.Errorf("请选择要删除的机房")
	}

	//检查是否有房间
	cc, err := deviceroomdao.CountByLab(params.LabIds)
	if err != nil {
		return "", fmt.Errorf("获取房间出错")
	}

	if len(cc) > 0 {
		return "", fmt.Errorf("机房下还有房间未删除，请删除房间后重试操作！")
	}
	// userName, err := GetUserName(Authorization)
	// //userName := "system"
	// if err != nil {
	// 	return "", err
	// }
	//删除机房
	err = labdao.DeleteLab(params.LabIds, userName)
	if err != nil {
		return "", err
	}
	//删除联系人
	err = contactdao.DelContactByType(params.LabIds, contactdao.TYPE_LAB, userName)
	if err != nil {
		return "", err
	}
	return "", err
}

func (ls *LabService) UpdateLab(params lab.UpdateParams, userName string) error {
	if params.Id <= 0 {
		return fmt.Errorf("找不到编辑的机房")
	}
	findLabInfo, err := labdao.GetLab(params.Id)
	if err != nil {
		return err
	}
	if findLabInfo.Id <= 0 {
		return fmt.Errorf("找不到编辑的房间")
	}
	// userName, err := GetUserName(Authorization)
	// //userName := "system"
	// if err != nil {
	// 	return err
	// }
	//修改机房信息
	findLabInfo.Description = params.Description
	findLabInfo.Address = params.LabAddress
	findLabInfo.Power = params.Power
	findLabInfo.SparePower = params.SparePower
	findLabInfo.ServiceProvider = params.ServiceProvider
	findLabInfo.Updater = userName
	err = labdao.UpdateLab(findLabInfo)
	if err != nil {
		return err
	}

	//修改联系人
	mainContact := deviceroom.Contact{
		Uid:                          params.MainContact.Uid,
		DeviceRoomContactName:        params.MainContact.LinkName,
		DeviceRoomContactPhoneNumber: params.MainContact.LinkPhoneNumber,
	}
	otherLen := len(params.OtherContacts)
	otherContact := make([]deviceroom.Contact, 0, otherLen)
	for i := 0; i < otherLen; i++ {
		otherContact = append(otherContact, deviceroom.Contact{
			Uid:                          params.OtherContacts[i].Uid,
			DeviceRoomContactName:        params.OtherContacts[i].LinkName,
			DeviceRoomContactPhoneNumber: params.OtherContacts[i].LinkPhoneNumber,
		})
	}
	err = contactservice.UpdateByType(findLabInfo.Id, contactdao.TYPE_LAB, mainContact, otherContact, userName)
	if err != nil {
		return err
	}
	// info := lab.UpdateLabMapping{
	// 	Uid:             params.Uid,
	// 	Description:     params.Description,
	// 	LabAddress:      params.LabAddress,
	// 	ServiceProvider: params.ServiceProvider,
	// 	Power:           params.Power,
	// 	SparePower:      params.SparePower,
	// 	MainContact:     params.MainContact,
	// 	OtherContacts:   params.OtherContacts,
	// }
	// bytes, err := json.Marshal(info)
	// if err != nil {
	// 	return err
	// }
	// todo := context.TODO()
	// txn := ls.dgraphClient.NewTxn()
	// defer txn.Discard(todo)
	// mu := &api.Mutation{
	// 	SetJson: bytes,
	// }
	// _, err = txn.Mutate(todo, mu)
	// if err != nil {
	// 	return err
	// }
	// // 再执行联系人的删除逻辑
	// if len(params.DeleteContactUids) == 0 {
	// 	return txn.Commit(todo)
	// }
	// info = lab.UpdateLabMapping{
	// 	Uid: params.Uid,
	// }
	// for _, uid := range params.DeleteContactUids {
	// 	info.OtherContacts = append(info.OtherContacts, lab.ContactsMapping{
	// 		Uid: uid,
	// 	})
	// }
	// bytes, err = json.Marshal(info)
	// mu = &api.Mutation{
	// 	DeleteJson: bytes,
	// }
	// _, err = txn.Mutate(todo, mu)
	// if err != nil {
	// 	return err
	// }
	// err = txn.Commit(todo)
	return err
}

func (ls *LabService) LabDetail(id int) (lab.LabInfo, error) {
	labInfo := lab.LabInfo{}
	labList, err := ls.GetLabList(lab.LabQueryParams{
		PageNo:      1,
		PageSize:    1,
		SearchType:  "ID",
		SearchValue: id,
	})
	if err != nil {
		return labInfo, err
	}
	if labList.TotalCount <= 0 {
		return labInfo, errors.New("数据不存在")
	}
	return labList.DataList[0], nil
}

func queryUidByAzCode(client *dgo.Dgraph, azCode string) (uid string, err error) {
	q := `{
	queryAzUid(func: eq(azCode, "%s")) {
    	azCode,
    	uid
	}
}`
	q = fmt.Sprintf(q, azCode)
	response, err := client.NewTxn().Query(context.TODO(), q)
	if err != nil {
		return "", err
	}
	resultMapping := struct {
		QueryAzUid []struct {
			Uid    string `json:"uid"`
			AzCode string `json:"azCode"`
		} `json:"queryAzUid"`
	}{}
	err = json.Unmarshal(response.Json, &resultMapping)
	if err != nil {
		return "", err
	}
	if len(resultMapping.QueryAzUid) == 0 {
		return "", errors.New("azCode does not exist in database")
	}
	return resultMapping.QueryAzUid[0].Uid, nil
}

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/pkg/service/sgwResourcePool.go
```golang
package service

import (
	"luban-cmdb-api/pkg/models/netPoolModel"
)

// GetSGWPoolMap 获取SGW资源池列表
func GetSGWPoolMap() (map[string]netPoolModel.NetWorkResource, error) {

	netPoolList, err := getNetworkPool() //获取所有网络资源池信息
	if err != nil {
		return nil, err
	}

	//资源池有两个，其中Hosts字段会出现重复值，所以这里使用一个map类型去重，Hosts字段中的的每个值都要获取到
	kgwPoolMap := make(map[string]netPoolModel.NetWorkResource)
	for i := range netPoolList {
		if netPoolList[i].PoolType == "SGW" {
			for j := range netPoolList[i].Hosts {
				kgwPoolMap[netPoolList[i].Hosts[j]] = netPoolList[i]
			}
		}
	}

	return kgwPoolMap, nil
}

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/pkg/service/businessManagementInit.go
```golang
package service

import (
	"fmt"
	"k8s.io/klog/v2"
	businessManagementDao "luban-cmdb-api/pkg/dao/businessManagement"
	serverdao "luban-cmdb-api/pkg/dao/server"
	"luban-cmdb-api/pkg/models/businessManagement"
	"luban-cmdb-api/pkg/utils"
)

type (
	ServiceSlot struct {
		Name       string         // 必须
		RegionCode string         // 必须
		Instances  []InstanceSlot // 必须

		// 如果需要和上层节点连接 可以直接对 business_management_node_service表进行操作
	}
	InstanceSlot struct {
		Name       string //  非必须
		HostName   string //  与IP二选一必须
		Ip         string //  与HOSTNAME二选一必须
		RegionCode string // 必须
		AzCode     string // 必须
		HostType   int    //  必须			物理机：0 云主机：1
	}
)

const USER_ADMIN = "admin"

type LoadData interface {
	LoadData() []ServiceSlot
}

// InitBusinessModule
// 记得调用该方法,记得改成加参数启动该方法的那种，否则重启会重复调用
// TODO:  注意！！！记得先装agent！
// TODO： 现在只能初始化服务/服务实例的内容
func InitBusinessModule(ld LoadData) {
	svcs := ld.LoadData()
	for _, svc := range svcs {
		svcmodel := businessManagement.Service{
			Name:       svc.Name,
			BuiltIn:    businessManagement.BUILT_IN_YES,
			RegionCode: svc.RegionCode,
			Creator:    USER_ADMIN,
			Updater:    USER_ADMIN,
		}
		err := businessManagementDao.CreateService(&svcmodel)
		if err != nil {
			// 继续执行
			klog.Errorf("InitBusinessModule: svc make err:", err)
			continue
		}
		for _, svci := range svc.Instances {
			svcimodel := businessManagement.ServiceInstance{
				ServiceId:  svcmodel.Id,
				RegionCode: svci.RegionCode,
				AzCode:     svci.AzCode,
				HostType:   svci.HostType,
				Creator:    USER_ADMIN,
				Updater:    USER_ADMIN,
			}
			if svci.Name == "" {
				svcimodel.Name = fmt.Sprintf("%s-%s", svc.Name, utils.RandomString(8))
			} else {
				svcimodel.Name = svci.Name
			}

			if svci.HostName == "" && svci.Ip == "" {
				// 继续执行
				klog.Errorf("InitBusinessModule svci make err: service [%s] has unknown instance", svc.Name)
				continue
			}
			switch svci.HostType {
			case 0:
				// 查询物理机的ID
				server, err := serverdao.SelectServerByHostnameOrIp(svci.HostName, svci.Ip)
				if err != nil || server.Id == 0 {
					// 继续执行
					klog.Errorf("InitBusinessModule svci make err: service [%s] has unknown instance(host without agent or ?), err: %v", svc.Name, err)
					continue
				}
				svcimodel.HostId = server.Id

			case 1:
				// 查询云主机的ID
			}
			err := businessManagementDao.CreateServiceInstance(&svcimodel)
			if err != nil {
				klog.Errorf("InitBusinessModule svci make err:", err)
				continue
			}
		}
	}
	return
}

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/pkg/service/objectStoragePool.go
```golang
package service

import (
	"context"
	"encoding/json"
	"fmt"
	"luban-cmdb-api/data/ent"
	"luban-cmdb-api/data/ent/objectstorage"
	"luban-cmdb-api/data/ent/objectstoragebucket"
	"luban-cmdb-api/pkg/apiserver/config"
	"luban-cmdb-api/pkg/dao"
	"luban-cmdb-api/pkg/models/server"
	"luban-cmdb-api/pkg/service/esmanager"
	"luban-cmdb-api/pkg/utils"
	"math"
	"strings"
	"time"

	"github.com/dgraph-io/dgo/v200"
	"k8s.io/klog/v2"

	basicdao "luban-cmdb-api/pkg/dao/basic"
	"luban-cmdb-api/pkg/dao/ks3"
	"luban-cmdb-api/pkg/gredis"
	"luban-cmdb-api/pkg/models/storage"
)

const (
	Day = iota
	Week
	Month
)

type Metric struct {
	Name      string `json:"__name__"`
	Endpoint  string `json:"endpoint"`
	Instance  string `json:"instance"`
	Job       string `json:"job"`
	Namespace string `json:"namespace"`
	Pod       string `json:"pod"`
	Region    string `json:"region"`
	Service   string `json:"service"`
}

type Value struct {
	Time  int64  `json:"time"`
	Value string `json:"value"`
}

type Result struct {
	Metric Metric        `json:"metric"`
	Value  []interface{} `json:"value"`
}

type Data struct {
	ResultType string   `json:"resultType"`
	Result     []Result `json:"result"`
}

type PrometheusResponse struct {
	Status string `json:"status"`
	Data   Data   `json:"data"`
}

type Ks3APIDao interface {
	//FindBuckets(page, pageSize int) (*ks3.BucketsResult, error)
	FindBucketsWithOptions(page, pageSize int, region string, name string, id string, userId string, bucketType []string) (*ks3.BucketsResult, error)
	Buckets() (*ks3.BucketsResult, error)
	FindBucketById(id string) (*ks3.Bucket, error)
}

type ObjectStoragePool struct {
	StorageStateAddr string
	HttpClient       HttpClient
	PrometheusAddr   string
	CustomerDomain   string
	BasicService     *BasicService
}

func NewObjectStoragePoolService(storageStateAddr string, prometheusAddr string, customerDomain string, dgraphclient *dgo.Dgraph) *ObjectStoragePool {
	return &ObjectStoragePool{
		StorageStateAddr: storageStateAddr,
		HttpClient:       &SimpleHttpClient{},
		PrometheusAddr:   prometheusAddr,
		CustomerDomain:   customerDomain,
		BasicService:     NewBasicService(dgraphclient, &AggregateService{}),
	}
}

//获取对象存储资源池列表
func (o *ObjectStoragePool) GetobjectStoragePoolList(objectStoragePoolQuery storage.BlockStoragePoolQuery) ([]storage.ObjectRe, error) {
	var ObjectReDataList []storage.ObjectRe
	spList := GetPoolList()
	for _, storagePool := range spList {

		if (storagePool.StorageType == "ks3") &&
			(objectStoragePoolQuery.RegionCode == "all" || storagePool.RegionCode == objectStoragePoolQuery.RegionCode) &&
			(objectStoragePoolQuery.Name == "" || storagePool.Name == objectStoragePoolQuery.Name) {

			//search
			if objectStoragePoolQuery.SearchType != "" {
				switch objectStoragePoolQuery.SearchType {
				case "name":
					if !strings.Contains(storagePool.Name, objectStoragePoolQuery.SearchValue) {
						continue
					}
				}
			}

			//服务器数量从列表处获取，避免两处不一致的情况
			hostNumber := 0
			serverSvc := NewServerService(nil)
			physicalHostListQuery := server.PhysicalHostListQuery{
				ResourcePool: "ks3",
			}
			rsp, err := serverSvc.GetPhysicalHostList(physicalHostListQuery)
			if err != nil {
				klog.Errorln("serverSvc.GetPhysicalHostList(physicalHostListQuery) err:", err)
			}
			hostNumber = rsp.TotalCount

			var ObjectReData storage.ObjectRe
			ObjectReData.Id = storagePool.Id
			ObjectReData.Name = storagePool.Name
			ObjectReData.RegionCode = storagePool.RegionCode
			ObjectReData.RegionName = storagePool.RegionName
			ObjectReData.ResourcePool = storagePool.ResourcePool
			ObjectReData.HostNumber = hostNumber
			ObjectReData.CreateTime = storagePool.CreateTime
			ObjectReData.MetricUrl = storagePool.MetricUrl
			ObjectReData.AzCode = storagePool.AzCode

			bucketRequest := storage.BucketRequest{
				Region:     storagePool.RegionCode,
				Pagination: storage.Pagination{PageNo: 1, PageSize: 1},
			}
			data, err := o.GetBucketList(bucketRequest)
			if err != nil {
				ObjectReData.HostNumber = 0
			} else {
				ObjectReData.BucketNumber = data.TotalCount
			}

			// 获取资源池服务器状态信息
			ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
			defer cancel()
			servers, err := gredis.SMembers(ctx, gredis.KS3StoragePoolServers)
			if err != nil {
				klog.Error("get ks3 storage pool server info by redis key(%s) error: %s", gredis.KS3StoragePoolServers, err)
			}
			statusCode := 0
			ks3hosts := []storage.Ks3Host{}
			for _, s := range servers {
				host := storage.Ks3Host{}
				err := json.Unmarshal([]byte(s), &host)
				if err != nil {
					return nil, err
				}
				statusCode += host.Status
				ks3hosts = append(ks3hosts, host)
			}
			ObjectReData.Servers = ks3hosts
			ObjectReData.Status = "bad"
			if statusCode == 0 {
				ObjectReData.Status = "ok"
			}

			ObjectReDataList = append(ObjectReDataList, ObjectReData)
		}
	}

	return ObjectReDataList, nil
}

//不用了
func (o *ObjectStoragePool) GetPoolStock(poolName string, pageNo, pageSize int) (*storage.ObjectStoragePoolStock, error) {
	res := &storage.ObjectStoragePoolStock{}
	return res, nil
}

// 使用查mysql替换查redis的List方法
func (o *ObjectStoragePool) GetBucketList(bucketRequest storage.BucketRequest) (result *storage.ObjectStoragePoolBucket, err error) {
	query := dao.EntDB.ObjectStorage.Query()
	if bucketRequest.Region != "" && bucketRequest.Region != "all" {
		query = query.Where(objectstorage.RegionCode(bucketRequest.Region))
	}
	if bucketRequest.Name != "" {
		query = query.Where(objectstorage.Name(bucketRequest.Name))
	}
	if bucketRequest.Id != "" {
		query = query.Where(objectstorage.ID(bucketRequest.Id))
	}
	if bucketRequest.TenantId != "" {
		query = query.Where(objectstorage.TenantID(bucketRequest.TenantId))
	}
	if len(bucketRequest.StorageType) > 0 {
		query = query.Where(objectstorage.StorageTypeIn(bucketRequest.StorageType...))
	}

	//search
	if bucketRequest.SearchType != "" {
		switch bucketRequest.SearchType {
		case "name":
			query = query.Where(objectstorage.NameContains(bucketRequest.SearchValue))
		case "id":
			query = query.Where(objectstorage.IDEQ(bucketRequest.SearchValue))
		case "tenantId":
			query = query.Where(objectstorage.TenantIDContains(bucketRequest.SearchValue))
		}
	}

	//total count
	totalCount, err := query.Count(context.Background())

	//sort
	//默认时间倒序
	query = query.Order(ent.Desc(objectstorage.FieldCreateTime))
	//page
	if bucketRequest.PageNo > 0 && bucketRequest.PageSize > 0 {
		query = query.Offset((bucketRequest.PageNo - 1) * bucketRequest.PageSize).Limit(bucketRequest.PageSize)
	}

	list, err := query.All(context.Background())
	if err != nil {
		return nil, err
	}

	//list to buckets
	var buckets []storage.BucketDetail
	for _, v := range list {
		var domains []storage.BucketDomain
		err := utils.UnmarshalFromString(v.BucketDomains, &domains)
		if err != nil {
			return nil, err
		}

		buckets = append(buckets, storage.BucketDetail{
			Id:               v.ID,
			Name:             v.Name,
			Size:             v.Size,
			StorageType:      v.StorageType,
			Region:           v.RegionCode,
			RegionCode:       v.RegionCode,
			AzName:           v.Az,
			AzCode:           v.AzCode,
			TenantId:         v.TenantID,
			TenantName:       v.TenantName,
			InnerDomainName:  v.InnerDomainName,
			OuterDomainName:  v.OuterDomainName,
			CreateTime:       int64(v.CreateTime),
			Policy:           v.Policy,
			Domains:          domains,
			ResourcePoolId:   v.ResourcePoolID,
			ResourcePoolName: v.ResourcePoolName,
			ObjectCount:      int64(v.ObjectCount),
		})
	}

	result = &storage.ObjectStoragePoolBucket{}
	result.TotalCount = totalCount
	result.DataList = buckets
	return
}

func (o *ObjectStoragePool) GetObjectStorageCount(bucketRequest storage.BucketRequest) (int, error) {
	query := dao.BusinessDB.ObjectstorageBucket.Query()
	if bucketRequest.Region != "" && bucketRequest.Region != "all" {
		query = query.Where(objectstoragebucket.Region(bucketRequest.Region))
	}
	//total count
	totalCount, err := query.Count(context.Background())
	return totalCount, err
}

//数据不分页
func (o *ObjectStoragePool) GetBucketListAll(bucketRequest storage.BucketRequest) (buckets []storage.BucketDetail, err error) {
	bucketRequest.PageNo = 1
	bucketRequest.PageSize = math.MaxInt

	bucketResult, err := o.GetBucketList(bucketRequest)
	if err != nil {
		return nil, err
	}
	return bucketResult.DataList, nil
}

//func (o *ObjectStoragePool) GetBucketList(bucketRequest storage.BucketRequest) (*storage.ObjectStoragePoolBucket, error) {
//	bucketResult := &storage.ObjectStoragePoolBucket{}
//	bucketList, err := o.GetBucketListAll(bucketRequest)
//	if err != nil {
//		klog.Errorln("o.GetBucketListAll(bucketRequest) err:", err)
//		err = nil
//		return bucketResult, err
//	}
//
//	//sort
//	//默认时间倒序
//	lessFunc := func(i, j int) bool {
//		return bucketList[i].CreateTime > bucketList[j].CreateTime
//	}
//	sort.Slice(bucketList, lessFunc)
//
//	bucketResult.TotalCount = len(bucketList)
//	bucketResult.DataList = bucketList
//	if bucketRequest.PageNo <= 0 || bucketRequest.PageSize <= 0 {
//		return bucketResult, nil
//	}
//	low := (bucketRequest.PageNo - 1) * bucketRequest.PageSize
//	high := (bucketRequest.PageNo) * bucketRequest.PageSize
//	if high > len(bucketList) {
//		high = len(bucketList)
//	}
//	bucketResult.DataList = bucketList[low:high]
//	return bucketResult, nil
//}
//func (o *ObjectStoragePool) GetBucketListAll(bucketRequest storage.BucketRequest) (buckets []storage.BucketDetail, err error) {
//	bucketMap := storage.GetBucketMap()
//	for i := range bucketMap {
//		if (bucketRequest.Region == "all" || bucketRequest.Region == "" || bucketRequest.Region == bucketMap[i].RegionCode) &&
//			(bucketRequest.Name == "" || bucketRequest.Name == bucketMap[i].Name) &&
//			(bucketRequest.Id == "" || bucketRequest.Id == bucketMap[i].Id) &&
//			(bucketRequest.TenantId == "" || bucketRequest.TenantId == bucketMap[i].TenantId) &&
//			(len(bucketRequest.StorageType) <= 0 || BoolTagInArray(bucketRequest.StorageType, bucketMap[i].StorageType)) {
//
//			//SearchType  string `json:"searchType"`  // 搜索类型 (实例名称 name/实例ID id)
//			if bucketRequest.SearchType != "" {
//				switch bucketRequest.SearchType {
//				case "name":
//					if !strings.Contains(bucketMap[i].Name, bucketRequest.SearchValue) {
//						continue
//					}
//				case "id":
//					if !strings.Contains(bucketMap[i].Id, bucketRequest.SearchValue) {
//						continue
//					}
//				case "tenantId":
//					if !strings.Contains(bucketMap[i].TenantId, bucketRequest.SearchValue) {
//						continue
//					}
//				}
//			}
//
//			buckets = append(buckets, bucketMap[i])
//		}
//	}
//	return
//}

func (o *ObjectStoragePool) GetBucketDetail(insId string) (res storage.BucketDetail, err error) {
	buckets, err := o.GetBucketListAll(storage.BucketRequest{Id: insId})
	if err != nil {
		return res, nil
	}
	if len(buckets) > 0 {
		res = buckets[0]
	}
	res.BucketUsage = getBucketUsage(insId)
	//size, _ := strconv.ParseFloat(fmt.Sprintf("%.2f", float64(res.Size)/(1024*1024)), 64)
	res.BucketUsage.CurrentSize = res.Size //统一按B返回，前端根据大小显示 B，KB，MB，GB。 同列表逻辑
	return
}

func getBucketUsage(bucketId string) (usage storage.BucketUsage) {
	usage.Last30DayDownload = int(esmanager.Get30DownloadNum(bucketId))
	usage.Last30DayAPICallTimes = int(esmanager.Get30ApiTimes(bucketId))
	return
}

//缓存bucket到redis
//func (o *ObjectStoragePool) StorageBucketList() (*storage.ObjectStoragePoolBucket, error) {
//
//	//这是ks3的库，不是我们自己的
//	bucketResult, err := o.dao.Buckets()
//	if err != nil {
//		return nil, err
//	}
//	// dgraphService := DgraphService{
//	// 	Code:  "regionCode",
//	// 	Value: "",
//	// }
//	sp := StoragePool{StorageType: "ks3"}
//	stoPoolList, err := sp.GetStoragePoolList([]string{}, []string{}, []string{})
//	if err != nil {
//		klog.Infoln(err)
//		err = nil
//	}
//	res := new(storage.ObjectStoragePoolBucket)
//	res.TotalCount = int(bucketResult.Total)
//	//storeMap, err := o.GetBucketMap()
//	// if err != nil {
//	// 	return res, err
//	// }
//	bucketStorages, err := o.GetBucketMap() //o.GetBucketMap()
//
//	//klog.Infof("GetBucketMap result is %v+:", bucketStorages)
//
//	if err != nil {
//		return nil, err
//	}
//	for _, bucket := range bucketResult.Buckets {
//		//dgraphService.Value = strings.ToLower(bucket.Region)
//		storageType := ""
//		if bucket.Type == "NORMAL" || bucket.Type == "" {
//			storageType = "STANDARD"
//		} else {
//			storageType = bucket.Type
//		}
//		//region := dgraphService.GetRegionByOurWay()
//		region, err := basicdao.GetRegion(basicdao.Region{
//			RegionCode: strings.ToLower(bucket.Region),
//		})
//		if err != nil {
//			return res, err
//		}
//		// key := fmt.Sprintf("%d,%s,%s,%s", bucket.Id, strings.ToUpper(region.RegionCode), storageType, bucket.UserId)
//		// size := o.GetBucketCap(key, storeMap)
//		size := o.GetBucketCap(bucket.Id, strings.ToUpper(region.RegionCode), bucket.UserId, storageType, bucketStorages)
//
//		tenant, err := GetRedisTenantMessage(bucket.UserId)
//		if err != nil {
//			klog.Infoln(err)
//			err = nil
//			continue
//		}
//		resourcePool, err := o.GetResourcePool(region.RegionCode, stoPoolList)
//		if err != nil {
//			klog.Infoln(err)
//			err = nil
//			continue
//		}
//		domains := []storage.BucketDomain{}
//		domains = append(domains, storage.BucketDomain{
//			AccessType: "内网访问",
//			Endpoint:   o.MakeKs3Endpoint(bucket.Region),
//			Domain:     o.MakeKs3InnerDomain(bucket.Name, bucket.Region),
//		}, storage.BucketDomain{
//			AccessType: "外网访问",
//			Endpoint:   o.MakeKs3Endpoint(bucket.Region),
//			Domain:     o.MakeKs3OuterDomain(bucket.Name, bucket.Region),
//		})
//		res.DataList = append(res.DataList, storage.BucketDetail{
//			Id:          strconv.Itoa(int(bucket.Id)),
//			Name:        bucket.Name,
//			Size:        size,              //0,
//			StorageType: storageType,       //bucket.Type,
//			Region:      region.RegionName, //bucket.Region,
//			RegionCode:  region.RegionCode, //bucket.Region,
//			//AzName:           resourcePool.AzName,
//			//AzCode:           resourcePool.AzCode,
//			TenantId:         bucket.UserId,
//			TenantName:       tenant.Name,
//			InnerDomainName:  o.MakeKs3InnerDomain(bucket.Name, bucket.Region),
//			OuterDomainName:  o.MakeKs3OuterDomain(bucket.Name, bucket.Region),
//			CreateTime:       bucket.CreateTime.Unix(), //DateTimeToTimestamp(string(bucket.CreateTime)),
//			ResourcePoolId:   resourcePool.Id,
//			ResourcePoolName: resourcePool.Name,
//			Domains:          domains,
//			ObjectCount:      getBucketObjectCnt(strconv.Itoa(int(bucket.Id)), region.RegionCode),
//		})
//
//	}
//	return res, nil
//}
func getBucketObjectCnt(bucketId, regionCode string) int64 {
	var bucketCountTotal int64 = 0
	countList, err := esmanager.GetBucketObjectCountById(strings.ToUpper(regionCode), time.Now().Add(time.Duration(-24*time.Hour)).Format("20060102"), bucketId)
	if err == nil {
		for _, cnt := range countList {
			bucketCountTotal += cnt.TotalCount
		}
	}
	return bucketCountTotal
}

func (o *ObjectStoragePool) GetBucketOverView(bucketRequest storage.BucketRequest) (storage.ObjectStorageOverview, error) {
	if bucketRequest.Region == "all" {
		bucketRequest.Region = ""
	}
	//bucketRequest.Type = "ks3"
	bucketRequest.PageNo = 1
	//bucketRequest.PageSize = 10000
	var objectStorageOverview storage.ObjectStorageOverview
	bucketList, err := o.GetBucketListAll(bucketRequest)
	if err != nil {
		klog.Errorln("o.GetBucketListAll(bucketRequest) err:", err)
		err = nil
		return objectStorageOverview, err
	}

	bucketCount := len(bucketList)
	//Bucket总数量
	objectStorageOverview.StorageCountOverview = append(objectStorageOverview.StorageCountOverview, storage.OverView{
		Name:  "Bucket数量",
		Code:  "BucketCount",
		Value: bucketCount,
	})

	var (
		STANDARDCount   = 0 //标准存储数量
		STANDARDIACount = 0 //低频存储数量
		ARCHIVECount    = 0 //归档存储数量
	)
	//存储类型概览
	STANDARDDistributedOverview := make(map[string]int)
	ARCHIVEDistributedOverview := make(map[string]int)
	STANDARD_IADistributedOverview := make(map[string]int)

	STANDARDHistogramOverView := []storage.HistogramOverView{}
	ARCHIVEHistogramOverView := []storage.HistogramOverView{}
	STANDARD_IAHistogramOverView := []storage.HistogramOverView{}

	for _, bucket := range bucketList {
		//dgraphService.Value = strings.ToLower(bucket.Region)
		region, err := basicdao.GetRegion(basicdao.Region{
			RegionCode: strings.ToLower(bucket.RegionCode),
		})
		if err != nil {
			continue
		}
		mapString := fmt.Sprintf("%s,%s", region.RegionName, region.RegionCode)
		//if bucket.Type == "ks3" {//目前type 没有值，并且不区分归档和标准，所有的都暂定标准
		// STANDARDDistributedOverview[mapString] = 0
		// ARCHIVEDistributedOverview[mapString] = 0
		// STANDARD_IADistributedOverview[mapString] = 0
		if _, ok := STANDARDDistributedOverview[mapString]; !ok {
			STANDARDDistributedOverview[mapString] = 0
		}
		if _, ok := ARCHIVEDistributedOverview[mapString]; !ok {
			ARCHIVEDistributedOverview[mapString] = 0
		}
		if _, ok := STANDARD_IADistributedOverview[mapString]; !ok {
			STANDARD_IADistributedOverview[mapString] = 0
		}
		if bucket.StorageType == "STANDARD" || bucket.StorageType == "" {
			STANDARDDistributedOverview[mapString] = STANDARDDistributedOverview[mapString] + 1
			STANDARDCount++
		} else if bucket.StorageType == "ARCHIVE" {
			ARCHIVEDistributedOverview[mapString] = ARCHIVEDistributedOverview[mapString] + 1
			ARCHIVECount++
		} else if bucket.StorageType == "STANDARD_IA" {
			STANDARD_IADistributedOverview[mapString] = STANDARD_IADistributedOverview[mapString] + 1
			STANDARDIACount++
		}

	}
	//存储类型概览
	storageTypeOverview := []storage.OverView{
		storage.OverView{
			Name:  "标准存储",
			Code:  "STANDARD",
			Value: STANDARDCount,
		},
		storage.OverView{
			Name:  "归档存储",
			Code:  "ARCHIVE",
			Value: ARCHIVECount,
		},
		storage.OverView{
			Name:  "低频存储",
			Code:  "STANDARD_IA",
			Value: STANDARDIACount,
		},
	}
	objectStorageOverview.StorageTypeOverview = append(objectStorageOverview.StorageTypeOverview, storageTypeOverview...)

	for name, value := range STANDARDDistributedOverview {
		mapSplit := strings.Split(name, ",")
		STANDARDHistogramOverView = append(STANDARDHistogramOverView, storage.HistogramOverView{
			Name:   mapSplit[0],
			Region: mapSplit[1],
			Value:  value,
		})
	}

	for name, value := range ARCHIVEDistributedOverview {
		mapSplit := strings.Split(name, ",")
		ARCHIVEHistogramOverView = append(ARCHIVEHistogramOverView, storage.HistogramOverView{
			Name:   mapSplit[0],
			Region: mapSplit[1],
			Value:  value,
		})
	}

	for name, value := range STANDARD_IADistributedOverview {
		mapSplit := strings.Split(name, ",")
		STANDARD_IAHistogramOverView = append(STANDARD_IAHistogramOverView, storage.HistogramOverView{
			Name:   mapSplit[0],
			Region: mapSplit[1],
			Value:  value,
		})
	}

	//bucket分布概览
	distributedOverview := []storage.DistributedHistogramOverView{
		storage.DistributedHistogramOverView{
			Name:        "标准存储",
			Code:        "STANDARD",
			Distributed: STANDARDHistogramOverView,
		},
		storage.DistributedHistogramOverView{
			Name:        "归档存储",
			Code:        "ARCHIVE",
			Distributed: ARCHIVEHistogramOverView,
		},
		storage.DistributedHistogramOverView{
			Name:        "低频存储",
			Code:        "STANDARD_IA",
			Distributed: STANDARD_IAHistogramOverView,
		},
	}
	objectStorageOverview.DistributedOverview = append(objectStorageOverview.DistributedOverview, distributedOverview...)

	return objectStorageOverview, nil
}

//从bucketMap中获取对应的数据并汇总size
func (o *ObjectStoragePool) GetBucketCap(id int64, region, userId string, storageClass string, bucketStorages []storage.BucketStore) int {
	size := 0
	storageTypes := []string{}
	if storageClass == "STANDARD" {
		storageTypes = append(storageTypes, "STANDARD", "STANDARD_IA")
	} else if storageClass == "ARCHIVE" {
		storageTypes = append(storageTypes, "ARCHIVE")
	}
	if id <= 0 || region == "" || region == "all" || userId == "" || len(storageClass) <= 0 {
		return 0
	}
	bucketStorages, err := o.GetBucketByQuery(id, region, userId, storageTypes, bucketStorages)
	if err != nil {
		return 0
	}
	length := len(bucketStorages)
	for i := 0; i < length; i++ {
		size += bucketStorages[i].Total
	}
	return size
}

//根据条件从bucket中获取数据
func (o *ObjectStoragePool) GetBucketByQuery(id int64, region, userId string, storageClass []string, bucketStorages []storage.BucketStore) ([]storage.BucketStore, error) {
	bucketStoragesResult := []storage.BucketStore{}
	// bucketStorages, err := bucketStorages//o.GetBucketMap()
	// if err != nil {
	// 	return bucketStoragesResult, err
	// }
	length := len(bucketStorages)
	for i := 0; i < length; i++ {
		if (id <= 0 || id == bucketStorages[i].Id) &&
			(region == "" || region == "all" || region == bucketStorages[i].Region) &&
			(userId == "" || userId == bucketStorages[i].UserId) &&
			(len(storageClass) <= 0 || BoolTagInArray(storageClass, bucketStorages[i].StorageClass)) {
			bucketStoragesResult = append(bucketStoragesResult, bucketStorages[i])
		}
	}
	return bucketStoragesResult, nil
}

//获取所有bucket存储容量从KTS数据库中
func (o *ObjectStoragePool) GetBucketMap() ([]storage.BucketStore, error) {

	bucketStorages := []storage.BucketStore{}
	regions, err := o.BasicService.GetRegions(make(map[string]interface{}), make(map[string]interface{}), make(map[string]interface{}))
	if err != nil {
		klog.Errorln("Error when call getregions :", err)
		return bucketStorages, nil
	}
	for j := range regions {
		//beforeData, err := o.HttpClient.SimpleHttpGet(fmt.Sprintf("http://ks3charge.luban.sdns.galaxy.cloud:18080/chargeInfo/store?region=%s&date=%s", strings.ToUpper(regions[j].RegionCode), time.Now().Format("20060102")))
		beforeData, err := o.HttpClient.SimpleHttpGet(fmt.Sprintf("http://%s/chargeInfo/store?region=%s&date=%s", config.DefaultChargeInfoService, strings.ToUpper(regions[j].RegionCode), time.Now().Add(time.Duration(-24*time.Hour)).Format("20060102")))
		if err != nil {
			klog.Errorf("Error when call prometheus error with range: %s", err)
			return bucketStorages, nil
		}
		beforeDataString := strings.ReplaceAll(string(beforeData), `}`, `}'`)
		beforeDataSlice := strings.Split(beforeDataString, "'")
		for i := range beforeDataSlice {
			if i < len(beforeDataSlice)-1 { //beforeDataSlice[i] != ""
				bucketStorage := storage.BucketStore{}
				err = json.Unmarshal([]byte(beforeDataSlice[i]), &bucketStorage)
				if err != nil {
					fmt.Println(beforeDataSlice[i])
					return bucketStorages, nil
				}
				// key := fmt.Sprintf("%d,%s,%s,%s", bucketStorage.Id, bucketStorage.Region, bucketStorage.StorageClass, bucketStorage.UserId)
				// bucketStorages[key] = bucketStorage
				bucketStorages = append(bucketStorages, bucketStorage)
			}
		}
	}

	return bucketStorages, err
}

func (o *ObjectStoragePool) GetResourcePool(region string, poolList []StoragePool) (pool StoragePool, err error) {
	length := len(poolList)
	for i := 0; i < length; i++ {
		if poolList[i].RegionCode == region {
			return poolList[i], err
		}
	}
	return
}
func (o *ObjectStoragePool) MakeKs3InnerDomain(name, region string) string {
	return fmt.Sprintf("%s.ks3-%s.%s", name, strings.ToLower(region), o.CustomerDomain)
}

func (o *ObjectStoragePool) MakeKs3Endpoint(region string) string {
	return fmt.Sprintf("ks3-%s.%s", strings.ToLower(region), o.CustomerDomain)
}

func (o *ObjectStoragePool) MakeKs3OuterDomain(name, region string) string {
	return fmt.Sprintf("%s.ks3-external-%s.%s", name, strings.ToLower(region), o.CustomerDomain)
}

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/pkg/service/objectStoragePool_test.go
```golang
package service

import (
	"encoding/json"
	"errors"
	"fmt"
	"strconv"
	"strings"
	"testing"
	"time"

	"luban-cmdb-api/pkg/dao/ks3"
	"luban-cmdb-api/pkg/models/storage"
)

type MockKs3APIDao struct {
	Total   int
	Buckets []ks3.Bucket
}

func newMockKs3APIDao(total int) *MockKs3APIDao {
	return &MockKs3APIDao{
		Total: total,
	}
}

func (m *MockKs3APIDao) FindBuckets(page, pageSize int) (*ks3.BucketsResult, error) {
	var buckets []ks3.Bucket
	if len(m.Buckets) == 0 {
		buckets = m.defaultBuckets()
	} else {
		buckets = m.Buckets
	}
	offset := (page - 1) * pageSize
	limit := pageSize
	return &ks3.BucketsResult{
		Buckets: buckets[offset : offset+limit],
		Total:   int64(len(buckets)),
	}, nil
}

func randomType(i int) string {
	if i%2 == 0 {
		return "a"
	} else {
		return "b"
	}
}

func (m *MockKs3APIDao) defaultBuckets() []ks3.Bucket {
	var buckets []ks3.Bucket
	for i := 0; i < m.Total; i++ {
		buckets = append(buckets, ks3.Bucket{
			Id:         int64(i),
			Name:       fmt.Sprintf("mock-ks3-api-%d", i),
			UserId:     fmt.Sprintf("mock-user-id-%d", i),
			Type:       randomType(i),
			Region:     "shanghai-2",
			CreateTime: time.Now(), //.Format("2006-01-02 15:04:05"),
		})
	}
	return buckets
}

func (m *MockKs3APIDao) FindBucketsWithOptions(page, pageSize int, region string, name string, id string, userId string, bucketType []string) (*ks3.BucketsResult, error) {
	return m.FindBuckets(page, pageSize)
}

func (m *MockKs3APIDao) FindBucketById(id string) (*ks3.Bucket, error) {
	buckets := m.defaultBuckets()
	intId, err := strconv.Atoi(id)
	if err != nil {
		return nil, err
	}
	for _, bucket := range buckets {
		if bucket.Id == int64(intId) {
			return &bucket, nil
		}
	}
	return nil, nil
}

/* func TestObjectStoragePool_ListBuckets(t *testing.T) {
	testCases := []struct {
		Name     string
		Page     int
		PageSize int
		Dao      Ks3APIDao
	}{
		{
			Name:     "regular-test-flow",
			Page:     1,
			PageSize: 10,
			Dao:      newMockKs3APIDao(100),
		}, {
			Name:     "regular-test-flow2",
			Page:     2,
			PageSize: 20,
			Dao:      newMockKs3APIDao(100),
		},
	}
	for _, testCase := range testCases {
		t.Run(testCase.Name, func(t *testing.T) {
			svc := &ObjectStoragePool{
				dao: testCase.Dao,
			}
			bs, err := svc.ListBuckets("", testCase.Page, testCase.PageSize, []string{})
			if err != nil {
				t.Fail()
			}
			if bs == nil || len(bs.DataList) != testCase.PageSize {
				t.Fail()
			}
		})
	}
} */

type MockGetPoolStockHttpClient struct {
	TotalGB int
	UsedGB  int
}

func (m *MockGetPoolStockHttpClient) SimpleHttpGet(url string) ([]byte, error) {
	if strings.Contains(url, "state") {
		res := &StorageStateResponse{
			TotalGB: m.TotalGB,
			UsedGB:  m.UsedGB,
		}
		return json.Marshal(res)
	}
	if strings.Contains(url, "prometheus") {
		res := &PrometheusResponse{
			Data: Data{
				Result: []Result{
					{
						Value: []interface{}{
							strconv.Itoa(int(time.Now().Unix())),
							"120",
						},
					},
				},
			},
		}
		return json.Marshal(res)
	}
	return nil, errors.New("not match url")
}

func TestObjectStoragePool_GetPoolStock(t *testing.T) {
	testCases := []struct {
		Name     string
		insId    string
		pageNo   int
		pageSize int
		totalGB  int
		usedGB   int
		poolName string
	}{
		{
			Name:     "regular-tet-flow",
			insId:    "",
			pageNo:   1,
			pageSize: 10,
			totalGB:  100,
			usedGB:   50,
			poolName: "",
		},
	}
	for _, testCase := range testCases {
		t.Run(testCase.Name, func(t *testing.T) {
			svc := &ObjectStoragePool{
				dao:              nil,
				StorageStateAddr: "http://storagestate.com",
				HttpClient: &MockGetPoolStockHttpClient{
					TotalGB: testCase.totalGB,
					UsedGB:  testCase.usedGB,
				},
				PrometheusAddr: "http://prometheus.com",
			}
			res, err := svc.GetPoolStock(testCase.insId, testCase.pageNo, testCase.pageSize)
			if err != nil {
				t.Fatalf("failed with error: %s", err)
			}
			onlyOneReturns := res.DataList[0]
			if onlyOneReturns.Total != testCase.totalGB {
				t.Fatalf("failed with totalGB, except: %d, got: %d", testCase.totalGB, onlyOneReturns.Total)
			}
			if onlyOneReturns.Free != testCase.totalGB-testCase.usedGB {
				t.Fatalf("failed with free, except: %d. got: %d", onlyOneReturns.Free, testCase.totalGB-testCase.usedGB)
			}
			usedPercent := testCase.usedGB / testCase.totalGB
			if onlyOneReturns.UsedPercent != usedPercent {
				t.Fatalf("failed with usePercent, except: %d, got: %d", usedPercent, onlyOneReturns.UsedPercent)
			}
		})
	}
}

func TestObjectStoragePool_GetBucketList(t *testing.T) {
	testCases := []struct {
		Name     string
		Req      storage.BucketRequest
		MockData ks3.BucketsResult
		Total    int // MockBucketTotal same with MockKs3ApiDao.Total
		Dao      Ks3APIDao
	}{
		{
			Name: "regular-test-flow",
			Req: storage.BucketRequest{
				Pagination: storage.Pagination{
					PageSize: 10,
					PageNo:   1,
				},
			},
			//Dao:   newMockKs3APIDao(101),
			Total: 101,
		},
	}
	for _, testCase := range testCases {
		t.Run(testCase.Name, func(t *testing.T) {
			svc := &ObjectStoragePool{
				dao: testCase.Dao,
			}
			data, err := svc.GetBucketList(testCase.Req)
			if err != nil {
				t.Fatalf("get bucket list err: %s", err)
			}
			if data.TotalCount != testCase.Total {
				t.Fatalf("response data total not right, shuold 100, got: %d", data.TotalCount)
			}
		})
	}
}

func TestObjectStoragePool_GetBucketDetail(t *testing.T) {
	testCases := []struct {
		Name string
		Id   string
		Dao  Ks3APIDao
	}{
		{
			Name: "regular-test-flow",
			Id:   "1",
			//Dao:  newMockKs3APIDao(100),
		},
	}
	for _, testCase := range testCases {
		t.Run(testCase.Name, func(t *testing.T) {
			svc := &ObjectStoragePool{
				dao: testCase.Dao,
			}
			bucket, err := svc.GetBucketDetail(testCase.Id)
			if err != nil {
				t.Fatalf("get bucket detail error: %s", err)
			}
			if bucket.Id != testCase.Id {
				t.Fatalf("get bucket id not match, got %s, case: %s", bucket.Id, testCase.Id)
			}
		})
	}
}

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/pkg/service/sl/sl.go
```golang
package sl

import (
	"context"
	"encoding/json"
	"errors"
	"luban-cmdb-api/pkg/gredis"
	"luban-cmdb-api/pkg/models/sl"
	"luban-cmdb-api/pkg/utils/collection"
	"sort"
	"strings"
	"time"

	"k8s.io/klog/v2"
)

type Service struct {
}

func NewService() *Service {
	return &Service{}
}

func (s Service) SlDetail(instanceId string) (sl.SlInfo, error) {
	hashKey := gredis.SLCloudHashKey
	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
	defer cancel()
	slInfoStr, err := gredis.HGet(ctx, hashKey, instanceId)
	if err != nil {
		return sl.SlInfo{}, err
	}
	var slInfo sl.SlInfo
	err = json.Unmarshal([]byte(slInfoStr), &slInfo)
	if err != nil {
		return sl.SlInfo{}, err
	}

	return slInfo, err
}

func (s Service) GetSlOverview(req sl.SlOverviewReq) (sl.SlOverviewRsp, error) {
	queryRegion := req.Region
	queryAz := req.Az

	sllist, err := getSlListFromCache()
	if err != nil {
		return sl.SlOverviewRsp{}, err
	}

	//filter
	queryList := []sl.SlInfo{}
	if queryRegion != "" || queryAz != "" {
		for _, v := range sllist {
			if queryRegion != "" && v.Region != queryRegion {
				continue
			}
			if queryAz != "" && v.Az != queryAz {
				continue
			}
			queryList = append(queryList, v)
		}
		sllist = queryList
	}

	runningCount := 0
	shanghaiCount := 0
	typeToCountMap := make(map[string]int)
	for _, v := range sllist {
		if v.Status == "active" {
			runningCount++
		}
		if v.Region == "cn-shanghai-2" {
			shanghaiCount++
		}

		if _, ok := typeToCountMap[v.Type]; !ok {
			typeToCountMap[v.Type] = 1
		} else {
			typeToCountMap[v.Type] += 1
		}
	}

	//实例概览
	instanceOverview := make([]sl.OverView, 0)
	total := sl.OverView{
		Name:   "总数量",
		Code:   "TotalCount",
		Status: "",
		Value:  len(sllist),
	}

	running := sl.OverView{
		Name:   "Pending",
		Code:   "PendingCount",
		Status: "",
		Value:  len(sllist) - runningCount,
	}

	closed := sl.OverView{
		Name:   "Active",
		Code:   "ActiveCount",
		Status: "",
		Value:  runningCount,
	}
	instanceOverview = append(instanceOverview, total, running, closed)

	//实例类型概览
	typeOverviewData := sl.OverviewSlot{
		Info: sl.SlotInfo{
			Name:     "总数",
			Value:    len(sllist),
			UnitType: "number",
			Unit:     "个",
		},
		Values: []sl.SlotValue{
			{
				Code:     "t1",
				Name:     "同城裸纤",
				Value:    typeToCountMap[""],
				Unit:     "",
				UnitType: "number",
				Kind:     "",
			},
			{
				Code:     "t2",
				Name:     "跨城电路",
				Value:    typeToCountMap[""],
				Unit:     "",
				UnitType: "number",
				Kind:     "",
			},
			{
				Code:     "t3",
				Name:     "KIS裸纤",
				Value:    typeToCountMap[""],
				Unit:     "",
				UnitType: "number",
				Kind:     "",
			},
			{
				Code:     "t4",
				Name:     "DX",
				Value:    typeToCountMap[""],
				Unit:     "",
				UnitType: "number",
				Kind:     "",
			},
		},
	}

	//实例分布概览
	distributedOverview := sl.OverviewSlot{
		Info: sl.SlotInfo{
			Name:     "实例分布概览",
			Value:    0,
			UnitType: "number",
			Unit:     "个",
		},
		Values: []sl.SlotValue{
			{
				Code:     "cn-shanghai-2a",
				Name:     "上海二区",
				Value:    shanghaiCount,
				Unit:     "",
				UnitType: "number",
				Kind:     "",
			},
			//{
			//	Code:     "cn-shanghai-2b",
			//	Name:     "上海二区可用区B",
			//	Value:    0,
			//	Unit:     "",
			//	UnitType: "number",
			//	Kind:     "",
			//},
		},
	}

	return sl.SlOverviewRsp{
		TypeOverview:        []sl.OverviewSlot{typeOverviewData},
		DistributedOverview: []sl.OverviewSlot{distributedOverview},
		InstanceOverview:    instanceOverview,
	}, nil
}

func (s Service) GetListOptionalCondition() (map[string][]interface{}, error) {

	slList, err := getSlListFromCache()
	if err != nil {
		return nil, err
	}

	stateSet := collection.NewSet()
	typeSet := collection.NewSet()
	for _, v := range slList {
		stateSet.Add(v.Status)
		typeSet.Add(v.Type)
	}

	result := map[string][]interface{}{
		"state": stateSet.Keys(),
		"type":  typeSet.Keys(),
	}
	return result, nil
}

func (s Service) GetSlResourceList(params sl.GetSlResourceListReq) (sl.GetSlResourceListRsp, error) {
	sllist, err := getSlListFromCache()
	if err != nil {
		return sl.GetSlResourceListRsp{}, err
	}

	klog.Infof("GetSlResourceListReq : %+v", params)

	sllist = filter(params, sllist)
	//sort 时间倒序
	lessFunc := parseOrder(params, sllist)
	sort.Slice(sllist, lessFunc)

	//page
	total := len(sllist)
	offset := (params.PageNo - 1) * params.PageSize
	limit := offset + params.PageSize

	if offset > total {
		return sl.GetSlResourceListRsp{}, errors.New("pageNo. is too large")
	}
	if limit > total {
		limit = total
	}
	sllist = sllist[offset:limit]

	return sl.GetSlResourceListRsp{
		TotalCount: total,
		PageNo:     params.PageNo,
		PageSize:   params.PageSize,
		DataList:   sllist,
	}, nil
}

func parseOrder(params sl.GetSlResourceListReq, sllist []sl.SlInfo) func(i int, j int) bool {
	var lessFunc func(i, j int) bool
	if params.OrderCode == "createTime" {
		if params.OrderType == "ascending" { //正序
			lessFunc = func(i, j int) bool {
				return sllist[i].CreateTime < sllist[j].CreateTime
			}
		}
		if params.OrderType == "descending" { //逆序
			lessFunc = func(i, j int) bool {
				return sllist[i].CreateTime > sllist[j].CreateTime
			}
		}
	}

	//默认按照创建时间倒序
	if lessFunc == nil {
		lessFunc = func(i, j int) bool {
			return sllist[i].CreateTime > sllist[j].CreateTime
		}
	}
	return lessFunc
}

func filter(params sl.GetSlResourceListReq, sllist []sl.SlInfo) []sl.SlInfo {

	isFilter := params.ResourcePoolName != "" || params.Region != "" || params.Az != "" ||
		len(params.TenantId) > 0 || len(params.TenantName) > 0 || len(params.ProjectName) > 0 ||
		params.SearchType != ""
	if !isFilter {
		return sllist
	}

	filterList := make([]sl.SlInfo, 0)
	for _, v := range sllist {
		if params.ResourcePoolName != "" {
			if v.ResourcePoolName != params.ResourcePoolName {
				continue
			}
		}

		if params.Region != "" {
			if v.Region != params.Region {
				continue
			}
		}

		if params.Az != "" {
			if v.Az != params.Az {
				continue
			}
		}

		//TenantId     []string `json:"tenantId"`
		//TenantName   []string `json:"tenantName"`
		//ProjectName  []string `json:"projectName"`
		if len(params.TenantId) > 0 {
			matchNum := 0
			for _, ti := range params.TenantId {
				if v.TenantId == ti {
					matchNum++
				}
			}
			if matchNum < 1 {
				continue
			}
		}

		if len(params.TenantName) > 0 {
			matchNum := 0
			for _, tn := range params.TenantName {
				if v.TenantName == tn {
					matchNum++
				}
			}
			if matchNum < 1 {
				continue
			}
		}

		if len(params.ProjectName) > 0 {
			matchNum := 0
			for _, pn := range params.ProjectName {
				if v.ProjectName == pn {
					matchNum++
				}
			}
			if matchNum < 1 {
				continue
			}
		}

		//search  搜索类型 (名称)
		if params.SearchType != "" {
			switch params.SearchType {
			case "name":
				if !strings.Contains(v.Name, params.SearchValue) {
					continue
				}
			}
		}
		filterList = append(filterList, v)
	}
	return filterList
}

func getSlListFromCache() (slList []sl.SlInfo, err error) {
	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
	defer cancel()
	slInstanceMap, err := gredis.HGetAll(ctx, gredis.SLCloudHashKey)
	if err != nil {
		return
	}
	var resultList []string
	for _, slStr := range slInstanceMap {
		resultList = append(resultList, slStr)
	}
	rsStr := "[" + strings.Join(resultList, ",") + "]"
	err = json.Unmarshal([]byte(rsStr), &slList)
	if err != nil {
		klog.Error("slInstanceMap Unmarshal failure:", err.Error())
		return
	}
	return
}

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/pkg/service/contact/contact.go
```golang
package contact

import (
	"k8s.io/klog/v2"
	contactdao "luban-cmdb-api/pkg/dao/contact"
	"luban-cmdb-api/pkg/models/deviceroom"
)

type Contact struct {
	Main   contactdao.Contact
	Others []contactdao.Contact
}

//查询房间联系人
func GetDeviceRoomContacts(roomId int) (c Contact, err error) {
	return getContacts(roomId, contactdao.TYPE_DEVICE)
}

//查询机房联系人
func GetLabContacts(roomId int) (m Contact, err error) {
	return getContacts(roomId, contactdao.TYPE_LAB)
}

//批量查询房间联系人
func FindDeviceRoomContacts(roomIds []int) (map[int]Contact, error) {
	return findContacts(roomIds, contactdao.TYPE_DEVICE)
}

//批量查询机房联系人
func FindLabContacts(labIds []int) (map[int]Contact, error) {
	return findContacts(labIds, contactdao.TYPE_LAB)
}

//前端调用机房/房间修改信息时传递的机房信息，需要统一做过滤处理
//根据现存信息判断是否需要新增或者删除或者修改
func UpdateByType(typeId int, typeName int8, main deviceroom.Contact, others []deviceroom.Contact, op string) (err error) {
	curr, err := getContacts(typeId, typeName)
	currMain := curr.Main
	currOthers := curr.Others
	//校验是否需要修改main
	if currMain.Phone != main.DeviceRoomContactPhoneNumber || currMain.Name != main.DeviceRoomContactPhoneNumber {
		currMain.Phone = main.DeviceRoomContactPhoneNumber
		currMain.Name = main.DeviceRoomContactName
		currMain.Updater = op
		err = contactdao.UpdateContact(contactdao.Contact{
			Id:      currMain.Id,
			Name:    currMain.Name,
			Phone:   currMain.Phone,
			Updater: op,
		})
		if err != nil {
			klog.Warningln("update main contact error, main=", main, err)
			return
		}
	}

	//遍历判断新增、修改、删除三种场景
	var (
		addContacts []contactdao.Contact
		delIds      []int
		currIds     = make(map[int]struct{})
	)

	for _, v := range currOthers {
		currIds[v.Id] = struct{}{}
	}

	for _, v := range others {
		o := contactdao.Contact{
			Id:    v.Uid,
			Name:  v.DeviceRoomContactName,
			Phone: v.DeviceRoomContactPhoneNumber,
		}
		//新增
		if o.Id <= 0 {
			o.Creator = op
			o.Updater = op
			o.TypeId = typeId
			o.TypeName = typeName
			o.Level = contactdao.CONTACT_OTHER //这里新增只能为次要联系人
			addContacts = append(addContacts, o)
		} else {
			delete(currIds, o.Id)
			uc := contactdao.Contact{
				Id:      o.Id,
				Name:    o.Name,
				Phone:   o.Phone,
				Updater: op,
			}
			err = contactdao.UpdateContact(uc)
			if err != nil {
				klog.Warningln("update other contact error, main=", main, err)
				return
			}
		}
	}
	if len(addContacts) > 0 {
		err = contactdao.BatchAddContact(addContacts)
		if err != nil {
			klog.Warningln("batch add contact error ", err)
			return
		}
	}

	//表示当前联系人有需要删除的
	if len(currIds) > 0 {
		for id, _ := range currIds {
			delIds = append(delIds, id)
		}
		err = contactdao.BatchDelContact(delIds, op)
		if err != nil {
			klog.Warningln("batch delete contact error ", err)
			return
		}
	}
	return
}

func findContacts(typeIds []int, typeName int8) (map[int]Contact, error) {
	m := make(map[int]Contact)
	cs, err := contactdao.FindContactByType(typeIds, typeName)
	if err != nil {
		return m, err
	}
	for _, id := range typeIds {
		m[id] = Contact{}
	}

	for _, c := range cs {
		tempContact := m[c.TypeId]
		if c.Level == contactdao.CONTACT_MAIN {
			tempContact.Main = c
		} else {
			tempContact.Others = append(tempContact.Others, c)
		}
		m[c.TypeId] = tempContact
	}
	return m, err
}

func getContacts(typeId int, typeName int8) (c Contact, err error) {
	cs, err := contactdao.GetContactByType(typeId, typeName)
	if err != nil {
		return
	}
	var main contactdao.Contact
	var others []contactdao.Contact
	for _, c := range cs {
		if c.Level == contactdao.CONTACT_MAIN {
			main = c
		} else {
			others = append(others, c)
		}
	}
	c.Main = main
	c.Others = others
	return
}

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/pkg/service/monitor/monitor.go
```golang
package monitor

import (
	"context"
	"fmt"
	"luban-cmdb-api/pkg/dao/basic"
	"luban-cmdb-api/pkg/dao/switchdao"
	"luban-cmdb-api/pkg/models/businessManagement"
	"os"
	"strings"
	"time"

	serverModel "luban-cmdb-api/pkg/models/server"
	serverService "luban-cmdb-api/pkg/service"

	"github.com/dgraph-io/dgo/v200"
	"k8s.io/client-go/kubernetes"
	restclient "k8s.io/client-go/rest"
	"k8s.io/client-go/tools/clientcmd"
	"k8s.io/klog/v2"
)

func RegisterRun(dgraphclient *dgo.Dgraph) {
	if !hasInK8s() {
		klog.Infoln("monitoring not running k8s")
		return
	}
	klog.Infoln("monitoring task start")
	ServerRegister(dgraphclient) //服务器信息注册
	SwitchRegister()             //交换机信息注册
	BlackboxRegister()           //blackbox
	IpmiRegister(dgraphclient)   //ipmi
}

//同步服务器数据到k8s endpoints 给prometheus监控侧使用
func ServerRegister(dgraphclient *dgo.Dgraph) {
	defer func() {
		if err := recover(); err != nil {
			klog.Errorf("monitoring ServerRegister task error %v", err)
		}
	}()
	serverService := serverService.NewServerService(dgraphclient)
	var physicalHostListQuery serverModel.PhysicalHostListQuery
	physicalHostListQuery.PageNo = -1
	serverList, err := serverService.GetPhysicalHostList2(physicalHostListQuery)
	if err != nil {
		klog.Errorf("monitor ServerRegister 获取所有服务器信息失败,err=%v", err)
		return
	}

	if serverList.TotalCount <= 0 {
		klog.Warning("monitor ServerRegister server list is empty")
		return
	}

	//使用服务id,将进程信息拆分成map[int][]Process
	var m = make(map[string][]serverModel.PhysicalHostData)

	var serverOtherList []serverModel.PhysicalHostData
	for _, v := range serverList.DataList {
		serverOtherList = append(serverOtherList, v)
		if v.HostRegionCode != "" {
			mapString := strings.TrimRight(fmt.Sprintf("%v-%v-%v-%v-%v", PhysicalNodes, v.HostRegionCode, v.HostAzCode, strings.ReplaceAll(v.ResourcePoolType, ",", "-"),
				strings.ReplaceAll(strings.ReplaceAll(strings.ReplaceAll(v.ResourcePool, "_", "-"), ".", "-"), ",", "-")), "-")
			if len(mapString) > 63 {
				mapString = mapString[:63]
				if mapString[62:] == "-" { //不能以 - 结尾
					mapString = mapString[:62]
				}
			}
			m[mapString] = append(m[mapString], v)
		}
	}
	//注册servicemonitoring： physical-nodes，galaxy-nodes，process-nodes
	rp := NewRegisterPmService([]serverModel.PhysicalHostData{}, "", "", "", "")
	rp.RegisterPmServiceMonitor(true, true, true, context.TODO())
	//注册endpoint
	if len(serverOtherList) > 0 {
		rp.physicalHosts = serverOtherList
		//注册process-nodes和galaxy-nodes
		rp.Register(false, true, true, context.TODO())
	}
	if len(m) > 0 {
		for k, v := range m {
			rp.region = v[0].HostRegionCode
			rp.az = v[0].HostAzCode

			pooltype := strings.ToLower(v[0].ResourcePoolType)
			//常州环境 pool_type 有字符串拼接的值 XGW,NAT，所以不能用 == 判断。
			if strings.Contains(pooltype, "xgw") || strings.Contains(pooltype, "tengine") || strings.Contains(pooltype, "sgw") ||
				strings.Contains(pooltype, "nat") || strings.Contains(pooltype, "kgw") || strings.Contains(pooltype, "pgw") ||
				strings.Contains(pooltype, "tgw") {
				if strings.Contains(v[0].ResourcePool, ",") {
					rp.resourcePool = fmt.Sprintf("%v-o", strings.ReplaceAll(strings.ToLower(v[0].ResourcePool), ",", "-o-"))
				} else {
					rp.resourcePool = fmt.Sprintf("%v-o", strings.ToLower(v[0].ResourcePool))
				}
			} else {
				rp.resourcePool = v[0].ResourcePool
			}

			rp.resourcePoolType = strings.ReplaceAll(strings.ToLower(v[0].ResourcePoolType), ",", "-")
			rp.name = strings.ToLower(k)
			rp.physicalHosts = v
			//分开创建physical-nodes
			rp.Register(true, false, false, context.TODO())
		}
	}
	klog.Infof("monitor task ServerRegister finish")
}

//注册交换机信息到k8s, 给prometheus使用
func SwitchRegister() {

	defer func() {
		if err := recover(); err != nil {
			klog.Errorf("monitoring RegisterSwitch task error %v", err)
		}
	}()

	switchList, err := switchdao.GetAllSwitchList()
	klog.Infof("switchList %v", switchList)
	if err != nil {
		klog.Errorf("monitoring RegisterSwitch task error %v", err)
		return
	}
	regionMap, err := basic.QueryAllRegion2Map()
	if err != nil {
		klog.Errorf("monitoring RegisterSwitch task query region error %v", err)
		return
	}
	azMap, err := basic.QueryAllAz2Map()
	if err != nil {
		klog.Errorf("monitoring RegisterSwitch task query az error %v", err)
		return
	}

	var registerList = make([]SwitchInfo, 0)
	for _, v := range switchList {
		if len(v.Ip) > 0 {
			region := regionMap[v.RegionId].RegionCode
			az := azMap[v.AzId].AzCode
			registerList = append(registerList, SwitchInfo{
				name:          v.Name,
				ip:            v.Ip,
				region:        region,
				az:            az,
				mib:           v.Mib,
				interval:      v.IntervalTime,
				scrapeTimeout: v.ScrapeTimeout,
			})
		}
	}
	if len(registerList) == 0 {
		return
	}

	klog.Infof("switcRegisterList %v", registerList)

	svc := NewRegisterSwitchService(registerList)
	err = svc.Register()
	if err != nil {
		klog.Errorf("monitor ServerRegister error, %v", err)
		return
	}

	klog.Infof("monitor task SwitchRegister finish")

	//klog.Infof("Start updating  Switch config file")

	//var cm11 core.ConfigMap
	//yaml.Unmarshal([]byte(aa),&cm11)
	//fmt.Printf("cm11cm11 %+v",cm11.Data)

	//v1client := kubernetes.NewForConfigOrDie(k8sConfig())
	//
	//var cm core.ConfigMap
	//
	//community := os.Getenv("COMMUNITY")
	//klog.Infof("env community",community)
	//if community == ""{
	//	community = "wpskingsoft123"
	//}

	//auth := Auth{
	//	Community: community,
	//}
	//// 获取交换机数据
	//switchMibList, err := switchdao.GetAllSwitchMIbList()
	//if err != nil {
	//	klog.Error("Failed to get switch MIB")
	//}
	//if len(switchMibList) == 0 {
	//	klog.Error("Failed to get switch MIB")
	//}
	//
	//var ifMibMetricsList []Metrics
	//var hwMibMetricsList []Metrics
	//var h3cMibMetricsList []Metrics
	//
	//for _, v := range switchMibList {
	//	mibInfo := Metrics{
	//		Name:       v.Name,
	//		Oid:        v.Oid,
	//		Type:       v.Type,
	//		Help:       v.Help,
	//		Indexes:    nil,
	//		Lookups:    nil,
	//		EnumValues: EnumValues{},
	//	}
	//	switch v.MibType {
	//	case "if_mib":
	//		ifMibMetricsList = append(ifMibMetricsList,mibInfo)
	//	case "hw_mib":
	//		hwMibMetricsList = append(hwMibMetricsList,mibInfo)
	//	case "h3c_mib":
	//		h3cMibMetricsList = append(h3cMibMetricsList,mibInfo)
	//	}
	//}
	//
	//mib22 := MibList{
	//	IfMib: Mib{
	//		Get: []string{"1.3.6.1.2.1.1.3.0","1.3.6.1.4.1.4881.1.1.10.2.36.1.1.2.0"},
	//		Metrics: ifMibMetricsList,
	//		Auth: auth,
	//		Walk: []string{"1.3.6.1.2.1.2", "1.3.6.1.2.1.31.1.1","1.3.6.1.4.1.4881.1.1.10.2.35.1.1.1.3"},
	//	},
	//	HwMib: Mib{
	//		Get: []string{},
	//		Metrics: hwMibMetricsList,
	//		Auth: auth,
	//		Walk: []string{"1.3.6.1.4.1"},
	//	},
	//	H3cMib: Mib{
	//		Get: []string{},
	//		Metrics: h3cMibMetricsList,
	//		Auth: auth,
	//		Walk: []string{"1.3.6.1.4.1"},
	//	},
	//}
	//
	//mibList,_ := yaml.Marshal(mib22)
	//
	////klog.Infof("====mibList====",mibList)
	//
	//labels := map[string]string{
	//	"app.kubernetes.io/instance":"prometheus-snmp-exporter",
	//	"app.kubernetes.io/managed-by":"Helm",
	//	"app.kubernetes.io/name":"prometheus-snmp-exporter",
	//	"helm.sh/chart":"prometheus-snmp-exporter-0.1.3",
	//}
	//
	//annotations := map[string]string{
	//	"meta.helm.sh/release-name":"prometheus-snmp-exporter",
	//	"meta.helm.sh/release-namespace":"monitoring",
	//}
	//cm.APIVersion = "v1"
	//cm.Data = map[string]string{
	//	"snmp.yaml": string(mibList),
	//}
	//cm.Kind = "ConfigMap"
	//cm.Name = "prometheus-snmp-exporter"
	//cm.Namespace = "monitoring"
	//cm.Labels = labels
	//cm.Annotations = annotations
	//
	//
	//opt := metav1.UpdateOptions{FieldManager: "application/apply-patch"}
	//_ ,err1 :=v1client.CoreV1().ConfigMaps("monitoring").Update(context.Background(), &cm, opt)
	//if err1 != nil{
	//	klog.Errorf("updating  Switch config file fail err : %v",err1)
	//}

}

// 注册带端口的进程信息至 serviceMonitors
func BlackboxRegister() {
	defer func() {
		if err := recover(); err != nil {
			klog.Errorf("monitoring RegisterSwitch task error %v", err)
		}
	}()
	svc := serverService.NewBusinessManagementService()
	processList, err := svc.LatestProcessList(1)
	if err != nil {
		klog.Errorf("query process list error %v", err)
		return
	}
	//使用服务id,将进程信息拆分成map[int][]Process
	var m = make(map[int][]businessManagement.ProcessLatest)
	for _, v := range processList {
		m[v.SvcId] = append(m[v.SvcId], v)
	}

	for id, l := range m {
		blackboxService := NewRegisterBlackboxService(id, l)
		err = blackboxService.Register()
		if err != nil {
			klog.Errorf("register blackbox error %v, svcId %d, list %v", err, id, l)
		}
	}
	klog.Infoln("monitoring task BlackboxRegister finish")
}

//注册服务器硬件信息到k8s, 给prometheus使用
func IpmiRegister(dgraphclient *dgo.Dgraph) {
	defer func() {
		if err := recover(); err != nil {
			klog.Errorf("monitoring RegisterIpmi task error %v", err)
		}
	}()

	serverService := serverService.NewServerService(dgraphclient)
	var physicalHostListQuery serverModel.PhysicalHostListQuery
	physicalHostListQuery.PageNo = -1
	serverList, err := serverService.GetPhysicalHostList2(physicalHostListQuery)
	//serverList, err := server.AllServer()
	if err != nil {
		klog.Errorf("monitor ServerRegister 获取所有服务器信息失败,err=%v", err)
		return
	}

	if serverList.TotalCount <= 0 {
		klog.Warning("monitor ServerRegister server list is empty")
		return
	}

	var registerList = make([]IpmiInfo, 0)
	for _, v := range serverList.DataList {
		if len(v.Ip) > 0 {
			if v.OutbandIP == "" {
				continue
			}
			registerList = append(registerList, IpmiInfo{
				ip:       v.OutbandIP,
				region:   v.HostRegionCode,
				az:       v.HostAzCode,
				hostName: v.Name,
				module:   v.OutbandUser,
			})
		}
	}
	if len(registerList) == 0 {
		return
	}
	klog.Infof("ipmiRegisterList", registerList)
	svc := NewRegisterIpmiService(registerList)
	err = svc.Register()
	if err != nil {
		klog.Errorf("monitor ServerRegister error, %v", err)
		return
	}
	klog.Infof("monitor task IpmiRegister finish-------------------------------------")
}

func hasInK8s() bool {
	host, port := os.Getenv("KUBERNETES_SERVICE_HOST"), os.Getenv("KUBERNETES_SERVICE_PORT")
	if len(host) == 0 || len(port) == 0 {
		klog.Infof("monitor ServerRegister task running stop, unable to load in-cluster configuration")
		return false
	}
	return true
}

func InitClientSet() *kubernetes.Clientset {
	// creates the clientset
	clientset, err := kubernetes.NewForConfig(k8sConfig())
	if err != nil {
		panic(err.Error())
	}
	return clientset
}

func k8sConfig() *restclient.Config {
	var (
		config *restclient.Config
		err    error
	)
	if hasInK8s() {
		config, err = restclient.InClusterConfig()
	} else {
		home, _ := os.UserHomeDir()
		configFile := home + "/.kube/config"
		config, err = clientcmd.BuildConfigFromFlags("", configFile)
	}

	if err != nil {
		panic(err.Error())
	}
	config.Timeout = time.Minute
	return config
}

func StringToSlice(param, divisio string) []string {
	var externalUserid []string
	for _, v := range strings.Split(param, divisio) {
		v = strings.TrimSpace(v)
		externalUserid = append(externalUserid, v)
	}
	return externalUserid
}

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/pkg/service/monitor/mib.go
```golang
package monitor

var mib=`if_mib:
  auth:
    community: wpskingsoft123
  walk:
    - 1.3.6.1.2.1.2
    - 1.3.6.1.2.1.31.1.1
  get:
    - 1.3.6.1.2.1.1.3.0
  metrics:
    - name: cpuUsageRate
      oid: 1.3.6.1.4.1.4881.1.1.10.2.36.1.1.2
      type: gauge
      help: Cpu usage rate (1 min)
    - name: memoryUsageRate
      oid: 1.3.6.1.4.1.4881.1.1.10.2.35.1.1.1.3.1
      type: gauge
      help: Cpu usage rate (1 min)
    - name: sysUpTime
      oid: 1.3.6.1.2.1.1.3
      type: gauge
      help: The time (in hundredths of a second) since the network management portion
        of the system was last re-initialized. - 1.3.6.1.2.1.1.3
    - name: ifNumber
      oid: 1.3.6.1.2.1.2.1
      type: gauge
      help: The number of network interfaces (regardless of their current state) present
        on this system. - 1.3.6.1.2.1.2.1
    - name: ifIndex
      oid: 1.3.6.1.2.1.2.2.1.1
      type: gauge
      help: A unique value, greater than zero, for each interface - 1.3.6.1.2.1.2.2.1.1
      indexes:
        - labelname: ifIndex
          type: gauge
      lookups:
        - labels:
            - ifIndex
          labelname: ifAlias
          oid: 1.3.6.1.2.1.31.1.1.1.18
          type: DisplayString
        - labels:
            - ifIndex
          labelname: ifDescr
          oid: 1.3.6.1.2.1.2.2.1.2
          type: DisplayString
        - labels:
            - ifIndex
          labelname: ifName
          oid: 1.3.6.1.2.1.31.1.1.1.1
          type: DisplayString
    - name: ifType
      oid: 1.3.6.1.2.1.2.2.1.3
      type: EnumAsInfo
      help: The type of interface - 1.3.6.1.2.1.2.2.1.3
      indexes:
        - labelname: ifIndex
          type: gauge
      lookups:
        - labels:
            - ifIndex
          labelname: ifAlias
          oid: 1.3.6.1.2.1.31.1.1.1.18
          type: DisplayString
        - labels:
            - ifIndex
          labelname: ifDescr
          oid: 1.3.6.1.2.1.2.2.1.2
          type: DisplayString
        - labels:
            - ifIndex
          labelname: ifName
          oid: 1.3.6.1.2.1.31.1.1.1.1
          type: DisplayString
      enum_values:
        1: other
        2: regular1822
        3: hdh1822
        4: ddnX25
        5: rfc877x25
        6: ethernetCsmacd
        7: iso88023Csmacd
        8: iso88024TokenBus
        9: iso88025TokenRing
        10: iso88026Man
        11: starLan
        12: proteon10Mbit
        13: proteon80Mbit
        14: hyperchannel
        15: fddi
        16: lapb
        17: sdlc
        18: ds1
        19: e1
        20: basicISDN
        21: primaryISDN
        22: propPointToPointSerial
        23: ppp
        24: softwareLoopback
        25: eon
        26: ethernet3Mbit
        27: nsip
        28: slip
        29: ultra
        30: ds3
        31: sip
        32: frameRelay
        33: rs232
        34: para
        35: arcnet
        36: arcnetPlus
        37: atm
        38: miox25
        39: sonet
        40: x25ple
        41: iso88022llc
        42: localTalk
        43: smdsDxi
        44: frameRelayService
        45: v35
        46: hssi
        47: hippi
        48: modem
        49: aal5
        50: sonetPath
        51: sonetVT
        52: smdsIcip
        53: propVirtual
        54: propMultiplexor
        55: ieee80212
        56: fibreChannel
        57: hippiInterface
        58: frameRelayInterconnect
        59: aflane8023
        60: aflane8025
        61: cctEmul
        62: fastEther
        63: isdn
        64: v11
        65: v36
        66: g703at64k
        67: g703at2mb
        68: qllc
        69: fastEtherFX
        70: channel
        71: ieee80211
        72: ibm370parChan
        73: escon
        74: dlsw
        75: isdns
        76: isdnu
        77: lapd
        78: ipSwitch
        79: rsrb
        80: atmLogical
        81: ds0
        82: ds0Bundle
        83: bsc
        84: async
        85: cnr
        86: iso88025Dtr
        87: eplrs
        88: arap
        89: propCnls
        90: hostPad
        91: termPad
        92: frameRelayMPI
        93: x213
        94: adsl
        95: radsl
        96: sdsl
        97: vdsl
        98: iso88025CRFPInt
        99: myrinet
        100: voiceEM
        101: voiceFXO
        102: voiceFXS
        103: voiceEncap
        104: voiceOverIp
        105: atmDxi
        106: atmFuni
        107: atmIma
        108: pppMultilinkBundle
        109: ipOverCdlc
        110: ipOverClaw
        111: stackToStack
        112: virtualIpAddress
        113: mpc
        114: ipOverAtm
        115: iso88025Fiber
        116: tdlc
        117: gigabitEthernet
        118: hdlc
        119: lapf
        120: v37
        121: x25mlp
        122: x25huntGroup
        123: transpHdlc
        124: interleave
        125: fast
        126: ip
        127: docsCableMaclayer
        128: docsCableDownstream
        129: docsCableUpstream
        130: a12MppSwitch
        131: tunnel
        132: coffee
        133: ces
        134: atmSubInterface
        135: l2vlan
        136: l3ipvlan
        137: l3ipxvlan
        138: digitalPowerline
        139: mediaMailOverIp
        140: dtm
        141: dcn
        142: ipForward
        143: msdsl
        144: ieee1394
        145: if-gsn
        146: dvbRccMacLayer
        147: dvbRccDownstream
        148: dvbRccUpstream
        149: atmVirtual
        150: mplsTunnel
        151: srp
        152: voiceOverAtm
        153: voiceOverFrameRelay
        154: idsl
        155: compositeLink
        156: ss7SigLink
        157: propWirelessP2P
        158: frForward
        159: rfc1483
        160: usb
        161: ieee8023adLag
        162: bgppolicyaccounting
        163: frf16MfrBundle
        164: h323Gatekeeper
        165: h323Proxy
        166: mpls
        167: mfSigLink
        168: hdsl2
        169: shdsl
        170: ds1FDL
        171: pos
        172: dvbAsiIn
        173: dvbAsiOut
        174: plc
        175: nfas
        176: tr008
        177: gr303RDT
        178: gr303IDT
        179: isup
        180: propDocsWirelessMaclayer
        181: propDocsWirelessDownstream
        182: propDocsWirelessUpstream
        183: hiperlan2
        184: propBWAp2Mp
        185: sonetOverheadChannel
        186: digitalWrapperOverheadChannel
        187: aal2
        188: radioMAC
        189: atmRadio
        190: imt
        191: mvl
        192: reachDSL
        193: frDlciEndPt
        194: atmVciEndPt
        195: opticalChannel
        196: opticalTransport
        197: propAtm
        198: voiceOverCable
        199: infiniband
        200: teLink
        201: q2931
        202: virtualTg
        203: sipTg
        204: sipSig
        205: docsCableUpstreamChannel
        206: econet
        207: pon155
        208: pon622
        209: bridge
        210: linegroup
        211: voiceEMFGD
        212: voiceFGDEANA
        213: voiceDID
        214: mpegTransport
        215: sixToFour
        216: gtp
        217: pdnEtherLoop1
        218: pdnEtherLoop2
        219: opticalChannelGroup
        220: homepna
        221: gfp
        222: ciscoISLvlan
        223: actelisMetaLOOP
        224: fcipLink
        225: rpr
        226: qam
        227: lmp
        228: cblVectaStar
        229: docsCableMCmtsDownstream
        230: adsl2
        231: macSecControlledIF
        232: macSecUncontrolledIF
        233: aviciOpticalEther
        234: atmbond
        235: voiceFGDOS
        236: mocaVersion1
        237: ieee80216WMAN
        238: adsl2plus
        239: dvbRcsMacLayer
        240: dvbTdm
        241: dvbRcsTdma
        242: x86Laps
        243: wwanPP
        244: wwanPP2
        245: voiceEBS
        246: ifPwType
        247: ilan
        248: pip
        249: aluELP
        250: gpon
        251: vdsl2
        252: capwapDot11Profile
        253: capwapDot11Bss
        254: capwapWtpVirtualRadio
        255: bits
        256: docsCableUpstreamRfPort
        257: cableDownstreamRfPort
        258: vmwareVirtualNic
        259: ieee802154
        260: otnOdu
        261: otnOtu
        262: ifVfiType
        263: g9981
        264: g9982
        265: g9983
        266: aluEpon
        267: aluEponOnu
        268: aluEponPhysicalUni
        269: aluEponLogicalLink
        270: aluGponOnu
        271: aluGponPhysicalUni
        272: vmwareNicTeam
        277: docsOfdmDownstream
        278: docsOfdmaUpstream
        279: gfast
        280: sdci
        281: xboxWireless
        282: fastdsl
        283: docsCableScte55d1FwdOob
        284: docsCableScte55d1RetOob
        285: docsCableScte55d2DsOob
        286: docsCableScte55d2UsOob
        287: docsCableNdf
        288: docsCableNdr
        289: ptm
        290: ghn
        291: otnOtsi
        292: otnOtuc
        293: otnOduc
        294: otnOtsig
        295: microwaveCarrierTermination
        296: microwaveRadioLinkTerminal
        297: ieee8021axDrni
        298: ax25
        299: ieee19061nanocom
        300: cpri
        301: omni
        302: roe
        303: p2pOverLan
    - name: ifMtu
      oid: 1.3.6.1.2.1.2.2.1.4
      type: gauge
      help: The size of the largest packet which can be sent/received on the interface,
        specified in octets - 1.3.6.1.2.1.2.2.1.4
      indexes:
        - labelname: ifIndex
          type: gauge
      lookups:
        - labels:
            - ifIndex
          labelname: ifAlias
          oid: 1.3.6.1.2.1.31.1.1.1.18
          type: DisplayString
        - labels:
            - ifIndex
          labelname: ifDescr
          oid: 1.3.6.1.2.1.2.2.1.2
          type: DisplayString
        - labels:
            - ifIndex
          labelname: ifName
          oid: 1.3.6.1.2.1.31.1.1.1.1
          type: DisplayString
    - name: ifSpeed
      oid: 1.3.6.1.2.1.2.2.1.5
      type: gauge
      help: An estimate of the interface's current bandwidth in bits per second - 1.3.6.1.2.1.2.2.1.5
      indexes:
        - labelname: ifIndex
          type: gauge
      lookups:
        - labels:
            - ifIndex
          labelname: ifAlias
          oid: 1.3.6.1.2.1.31.1.1.1.18
          type: DisplayString
        - labels:
            - ifIndex
          labelname: ifDescr
          oid: 1.3.6.1.2.1.2.2.1.2
          type: DisplayString
        - labels:
            - ifIndex
          labelname: ifName
          oid: 1.3.6.1.2.1.31.1.1.1.1
          type: DisplayString
    - name: ifPhysAddress
      oid: 1.3.6.1.2.1.2.2.1.6
      type: PhysAddress48
      help: The interface's address at its protocol sub-layer - 1.3.6.1.2.1.2.2.1.6
      indexes:
        - labelname: ifIndex
          type: gauge
      lookups:
        - labels:
            - ifIndex
          labelname: ifAlias
          oid: 1.3.6.1.2.1.31.1.1.1.18
          type: DisplayString
        - labels:
            - ifIndex
          labelname: ifDescr
          oid: 1.3.6.1.2.1.2.2.1.2
          type: DisplayString
        - labels:
            - ifIndex
          labelname: ifName
          oid: 1.3.6.1.2.1.31.1.1.1.1
          type: DisplayString
    - name: ifAdminStatus
      oid: 1.3.6.1.2.1.2.2.1.7
      type: gauge
      help: The desired state of the interface - 1.3.6.1.2.1.2.2.1.7
      indexes:
        - labelname: ifIndex
          type: gauge
      lookups:
        - labels:
            - ifIndex
          labelname: ifAlias
          oid: 1.3.6.1.2.1.31.1.1.1.18
          type: DisplayString
        - labels:
            - ifIndex
          labelname: ifDescr
          oid: 1.3.6.1.2.1.2.2.1.2
          type: DisplayString
        - labels:
            - ifIndex
          labelname: ifName
          oid: 1.3.6.1.2.1.31.1.1.1.1
          type: DisplayString
      enum_values:
        1: up
        2: down
        3: testing
    - name: ifOperStatus
      oid: 1.3.6.1.2.1.2.2.1.8
      type: gauge
      help: The current operational state of the interface - 1.3.6.1.2.1.2.2.1.8
      indexes:
        - labelname: ifIndex
          type: gauge
      lookups:
        - labels:
            - ifIndex
          labelname: ifAlias
          oid: 1.3.6.1.2.1.31.1.1.1.18
          type: DisplayString
        - labels:
            - ifIndex
          labelname: ifDescr
          oid: 1.3.6.1.2.1.2.2.1.2
          type: DisplayString
        - labels:
            - ifIndex
          labelname: ifName
          oid: 1.3.6.1.2.1.31.1.1.1.1
          type: DisplayString
      enum_values:
        1: up
        2: down
        3: testing
        4: unknown
        5: dormant
        6: notPresent
        7: lowerLayerDown
    - name: ifLastChange
      oid: 1.3.6.1.2.1.2.2.1.9
      type: gauge
      help: The value of sysUpTime at the time the interface entered its current operational
        state - 1.3.6.1.2.1.2.2.1.9
      indexes:
        - labelname: ifIndex
          type: gauge
      lookups:
        - labels:
            - ifIndex
          labelname: ifAlias
          oid: 1.3.6.1.2.1.31.1.1.1.18
          type: DisplayString
        - labels:
            - ifIndex
          labelname: ifDescr
          oid: 1.3.6.1.2.1.2.2.1.2
          type: DisplayString
        - labels:
            - ifIndex
          labelname: ifName
          oid: 1.3.6.1.2.1.31.1.1.1.1
          type: DisplayString
    - name: ifInOctets
      oid: 1.3.6.1.2.1.2.2.1.10
      type: counter
      help: The total number of octets received on the interface, including framing
        characters - 1.3.6.1.2.1.2.2.1.10
      indexes:
        - labelname: ifIndex
          type: gauge
      lookups:
        - labels:
            - ifIndex
          labelname: ifAlias
          oid: 1.3.6.1.2.1.31.1.1.1.18
          type: DisplayString
        - labels:
            - ifIndex
          labelname: ifDescr
          oid: 1.3.6.1.2.1.2.2.1.2
          type: DisplayString
        - labels:
            - ifIndex
          labelname: ifName
          oid: 1.3.6.1.2.1.31.1.1.1.1
          type: DisplayString
    - name: ifInUcastPkts
      oid: 1.3.6.1.2.1.2.2.1.11
      type: counter
      help: The number of packets, delivered by this sub-layer to a higher (sub-)layer,
        which were not addressed to a multicast or broadcast address at this sub-layer
        - 1.3.6.1.2.1.2.2.1.11
      indexes:
        - labelname: ifIndex
          type: gauge
      lookups:
        - labels:
            - ifIndex
          labelname: ifAlias
          oid: 1.3.6.1.2.1.31.1.1.1.18
          type: DisplayString
        - labels:
            - ifIndex
          labelname: ifDescr
          oid: 1.3.6.1.2.1.2.2.1.2
          type: DisplayString
        - labels:
            - ifIndex
          labelname: ifName
          oid: 1.3.6.1.2.1.31.1.1.1.1
          type: DisplayString
    - name: ifInNUcastPkts
      oid: 1.3.6.1.2.1.2.2.1.12
      type: counter
      help: The number of packets, delivered by this sub-layer to a higher (sub-)layer,
        which were addressed to a multicast or broadcast address at this sub-layer -
        1.3.6.1.2.1.2.2.1.12
      indexes:
        - labelname: ifIndex
          type: gauge
      lookups:
        - labels:
            - ifIndex
          labelname: ifAlias
          oid: 1.3.6.1.2.1.31.1.1.1.18
          type: DisplayString
        - labels:
            - ifIndex
          labelname: ifDescr
          oid: 1.3.6.1.2.1.2.2.1.2
          type: DisplayString
        - labels:
            - ifIndex
          labelname: ifName
          oid: 1.3.6.1.2.1.31.1.1.1.1
          type: DisplayString
    - name: ifInDiscards
      oid: 1.3.6.1.2.1.2.2.1.13
      type: counter
      help: The number of inbound packets which were chosen to be discarded even though
        no errors had been detected to prevent their being deliverable to a higher-layer
        protocol - 1.3.6.1.2.1.2.2.1.13
      indexes:
        - labelname: ifIndex
          type: gauge
      lookups:
        - labels:
            - ifIndex
          labelname: ifAlias
          oid: 1.3.6.1.2.1.31.1.1.1.18
          type: DisplayString
        - labels:
            - ifIndex
          labelname: ifDescr
          oid: 1.3.6.1.2.1.2.2.1.2
          type: DisplayString
        - labels:
            - ifIndex
          labelname: ifName
          oid: 1.3.6.1.2.1.31.1.1.1.1
          type: DisplayString
    - name: ifInErrors
      oid: 1.3.6.1.2.1.2.2.1.14
      type: counter
      help: For packet-oriented interfaces, the number of inbound packets that contained
        errors preventing them from being deliverable to a higher-layer protocol - 1.3.6.1.2.1.2.2.1.14
      indexes:
        - labelname: ifIndex
          type: gauge
      lookups:
        - labels:
            - ifIndex
          labelname: ifAlias
          oid: 1.3.6.1.2.1.31.1.1.1.18
          type: DisplayString
        - labels:
            - ifIndex
          labelname: ifDescr
          oid: 1.3.6.1.2.1.2.2.1.2
          type: DisplayString
        - labels:
            - ifIndex
          labelname: ifName
          oid: 1.3.6.1.2.1.31.1.1.1.1
          type: DisplayString
    - name: ifInUnknownProtos
      oid: 1.3.6.1.2.1.2.2.1.15
      type: counter
      help: For packet-oriented interfaces, the number of packets received via the interface
        which were discarded because of an unknown or unsupported protocol - 1.3.6.1.2.1.2.2.1.15
      indexes:
        - labelname: ifIndex
          type: gauge
      lookups:
        - labels:
            - ifIndex
          labelname: ifAlias
          oid: 1.3.6.1.2.1.31.1.1.1.18
          type: DisplayString
        - labels:
            - ifIndex
          labelname: ifDescr
          oid: 1.3.6.1.2.1.2.2.1.2
          type: DisplayString
        - labels:
            - ifIndex
          labelname: ifName
          oid: 1.3.6.1.2.1.31.1.1.1.1
          type: DisplayString
    - name: ifOutOctets
      oid: 1.3.6.1.2.1.2.2.1.16
      type: counter
      help: The total number of octets transmitted out of the interface, including framing
        characters - 1.3.6.1.2.1.2.2.1.16
      indexes:
        - labelname: ifIndex
          type: gauge
      lookups:
        - labels:
            - ifIndex
          labelname: ifAlias
          oid: 1.3.6.1.2.1.31.1.1.1.18
          type: DisplayString
        - labels:
            - ifIndex
          labelname: ifDescr
          oid: 1.3.6.1.2.1.2.2.1.2
          type: DisplayString
        - labels:
            - ifIndex
          labelname: ifName
          oid: 1.3.6.1.2.1.31.1.1.1.1
          type: DisplayString
    - name: ifOutUcastPkts
      oid: 1.3.6.1.2.1.2.2.1.17
      type: counter
      help: The total number of packets that higher-level protocols requested be transmitted,
        and which were not addressed to a multicast or broadcast address at this sub-layer,
        including those that were discarded or not sent - 1.3.6.1.2.1.2.2.1.17
      indexes:
        - labelname: ifIndex
          type: gauge
      lookups:
        - labels:
            - ifIndex
          labelname: ifAlias
          oid: 1.3.6.1.2.1.31.1.1.1.18
          type: DisplayString
        - labels:
            - ifIndex
          labelname: ifDescr
          oid: 1.3.6.1.2.1.2.2.1.2
          type: DisplayString
        - labels:
            - ifIndex
          labelname: ifName
          oid: 1.3.6.1.2.1.31.1.1.1.1
          type: DisplayString
    - name: ifOutNUcastPkts
      oid: 1.3.6.1.2.1.2.2.1.18
      type: counter
      help: The total number of packets that higher-level protocols requested be transmitted,
        and which were addressed to a multicast or broadcast address at this sub-layer,
        including those that were discarded or not sent - 1.3.6.1.2.1.2.2.1.18
      indexes:
        - labelname: ifIndex
          type: gauge
      lookups:
        - labels:
            - ifIndex
          labelname: ifAlias
          oid: 1.3.6.1.2.1.31.1.1.1.18
          type: DisplayString
        - labels:
            - ifIndex
          labelname: ifDescr
          oid: 1.3.6.1.2.1.2.2.1.2
          type: DisplayString
        - labels:
            - ifIndex
          labelname: ifName
          oid: 1.3.6.1.2.1.31.1.1.1.1
          type: DisplayString
    - name: ifOutDiscards
      oid: 1.3.6.1.2.1.2.2.1.19
      type: counter
      help: The number of outbound packets which were chosen to be discarded even though
        no errors had been detected to prevent their being transmitted - 1.3.6.1.2.1.2.2.1.19
      indexes:
        - labelname: ifIndex
          type: gauge
      lookups:
        - labels:
            - ifIndex
          labelname: ifAlias
          oid: 1.3.6.1.2.1.31.1.1.1.18
          type: DisplayString
        - labels:
            - ifIndex
          labelname: ifDescr
          oid: 1.3.6.1.2.1.2.2.1.2
          type: DisplayString
        - labels:
            - ifIndex
          labelname: ifName
          oid: 1.3.6.1.2.1.31.1.1.1.1
          type: DisplayString
    - name: ifOutErrors
      oid: 1.3.6.1.2.1.2.2.1.20
      type: counter
      help: For packet-oriented interfaces, the number of outbound packets that could
        not be transmitted because of errors - 1.3.6.1.2.1.2.2.1.20
      indexes:
        - labelname: ifIndex
          type: gauge
      lookups:
        - labels:
            - ifIndex
          labelname: ifAlias
          oid: 1.3.6.1.2.1.31.1.1.1.18
          type: DisplayString
        - labels:
            - ifIndex
          labelname: ifDescr
          oid: 1.3.6.1.2.1.2.2.1.2
          type: DisplayString
        - labels:
            - ifIndex
          labelname: ifName
          oid: 1.3.6.1.2.1.31.1.1.1.1
          type: DisplayString
    - name: ifOutQLen
      oid: 1.3.6.1.2.1.2.2.1.21
      type: gauge
      help: The length of the output packet queue (in packets). - 1.3.6.1.2.1.2.2.1.21
      indexes:
        - labelname: ifIndex
          type: gauge
      lookups:
        - labels:
            - ifIndex
          labelname: ifAlias
          oid: 1.3.6.1.2.1.31.1.1.1.18
          type: DisplayString
        - labels:
            - ifIndex
          labelname: ifDescr
          oid: 1.3.6.1.2.1.2.2.1.2
          type: DisplayString
        - labels:
            - ifIndex
          labelname: ifName
          oid: 1.3.6.1.2.1.31.1.1.1.1
          type: DisplayString
    - name: ifSpecific
      oid: 1.3.6.1.2.1.2.2.1.22
      type: OctetString
      help: A reference to MIB definitions specific to the particular media being used
        to realize the interface - 1.3.6.1.2.1.2.2.1.22
      indexes:
        - labelname: ifIndex
          type: gauge
      lookups:
        - labels:
            - ifIndex
          labelname: ifAlias
          oid: 1.3.6.1.2.1.31.1.1.1.18
          type: DisplayString
        - labels:
            - ifIndex
          labelname: ifDescr
          oid: 1.3.6.1.2.1.2.2.1.2
          type: DisplayString
        - labels:
            - ifIndex
          labelname: ifName
          oid: 1.3.6.1.2.1.31.1.1.1.1
          type: DisplayString
    - name: ifInMulticastPkts
      oid: 1.3.6.1.2.1.31.1.1.1.2
      type: counter
      help: The number of packets, delivered by this sub-layer to a higher (sub-)layer,
        which were addressed to a multicast address at this sub-layer - 1.3.6.1.2.1.31.1.1.1.2
      indexes:
        - labelname: ifIndex
          type: gauge
      lookups:
        - labels:
            - ifIndex
          labelname: ifAlias
          oid: 1.3.6.1.2.1.31.1.1.1.18
          type: DisplayString
        - labels:
            - ifIndex
          labelname: ifDescr
          oid: 1.3.6.1.2.1.2.2.1.2
          type: DisplayString
        - labels:
            - ifIndex
          labelname: ifName
          oid: 1.3.6.1.2.1.31.1.1.1.1
          type: DisplayString
    - name: ifInBroadcastPkts
      oid: 1.3.6.1.2.1.31.1.1.1.3
      type: counter
      help: The number of packets, delivered by this sub-layer to a higher (sub-)layer,
        which were addressed to a broadcast address at this sub-layer - 1.3.6.1.2.1.31.1.1.1.3
      indexes:
        - labelname: ifIndex
          type: gauge
      lookups:
        - labels:
            - ifIndex
          labelname: ifAlias
          oid: 1.3.6.1.2.1.31.1.1.1.18
          type: DisplayString
        - labels:
            - ifIndex
          labelname: ifDescr
          oid: 1.3.6.1.2.1.2.2.1.2
          type: DisplayString
        - labels:
            - ifIndex
          labelname: ifName
          oid: 1.3.6.1.2.1.31.1.1.1.1
          type: DisplayString
    - name: ifOutMulticastPkts
      oid: 1.3.6.1.2.1.31.1.1.1.4
      type: counter
      help: The total number of packets that higher-level protocols requested be transmitted,
        and which were addressed to a multicast address at this sub-layer, including
        those that were discarded or not sent - 1.3.6.1.2.1.31.1.1.1.4
      indexes:
        - labelname: ifIndex
          type: gauge
      lookups:
        - labels:
            - ifIndex
          labelname: ifAlias
          oid: 1.3.6.1.2.1.31.1.1.1.18
          type: DisplayString
        - labels:
            - ifIndex
          labelname: ifDescr
          oid: 1.3.6.1.2.1.2.2.1.2
          type: DisplayString
        - labels:
            - ifIndex
          labelname: ifName
          oid: 1.3.6.1.2.1.31.1.1.1.1
          type: DisplayString
    - name: ifOutBroadcastPkts
      oid: 1.3.6.1.2.1.31.1.1.1.5
      type: counter
      help: The total number of packets that higher-level protocols requested be transmitted,
        and which were addressed to a broadcast address at this sub-layer, including
        those that were discarded or not sent - 1.3.6.1.2.1.31.1.1.1.5
      indexes:
        - labelname: ifIndex
          type: gauge
      lookups:
        - labels:
            - ifIndex
          labelname: ifAlias
          oid: 1.3.6.1.2.1.31.1.1.1.18
          type: DisplayString
        - labels:
            - ifIndex
          labelname: ifDescr
          oid: 1.3.6.1.2.1.2.2.1.2
          type: DisplayString
        - labels:
            - ifIndex
          labelname: ifName
          oid: 1.3.6.1.2.1.31.1.1.1.1
          type: DisplayString
    - name: ifHCInOctets
      oid: 1.3.6.1.2.1.31.1.1.1.6
      type: counter
      help: The total number of octets received on the interface, including framing
        characters - 1.3.6.1.2.1.31.1.1.1.6
      indexes:
        - labelname: ifIndex
          type: gauge
      lookups:
        - labels:
            - ifIndex
          labelname: ifAlias
          oid: 1.3.6.1.2.1.31.1.1.1.18
          type: DisplayString
        - labels:
            - ifIndex
          labelname: ifDescr
          oid: 1.3.6.1.2.1.2.2.1.2
          type: DisplayString
        - labels:
            - ifIndex
          labelname: ifName
          oid: 1.3.6.1.2.1.31.1.1.1.1
          type: DisplayString
    - name: ifHCInUcastPkts
      oid: 1.3.6.1.2.1.31.1.1.1.7
      type: counter
      help: The number of packets, delivered by this sub-layer to a higher (sub-)layer,
        which were not addressed to a multicast or broadcast address at this sub-layer
        - 1.3.6.1.2.1.31.1.1.1.7
      indexes:
        - labelname: ifIndex
          type: gauge
      lookups:
        - labels:
            - ifIndex
          labelname: ifAlias
          oid: 1.3.6.1.2.1.31.1.1.1.18
          type: DisplayString
        - labels:
            - ifIndex
          labelname: ifDescr
          oid: 1.3.6.1.2.1.2.2.1.2
          type: DisplayString
        - labels:
            - ifIndex
          labelname: ifName
          oid: 1.3.6.1.2.1.31.1.1.1.1
          type: DisplayString
    - name: ifHCInMulticastPkts
      oid: 1.3.6.1.2.1.31.1.1.1.8
      type: counter
      help: The number of packets, delivered by this sub-layer to a higher (sub-)layer,
        which were addressed to a multicast address at this sub-layer - 1.3.6.1.2.1.31.1.1.1.8
      indexes:
        - labelname: ifIndex
          type: gauge
      lookups:
        - labels:
            - ifIndex
          labelname: ifAlias
          oid: 1.3.6.1.2.1.31.1.1.1.18
          type: DisplayString
        - labels:
            - ifIndex
          labelname: ifDescr
          oid: 1.3.6.1.2.1.2.2.1.2
          type: DisplayString
        - labels:
            - ifIndex
          labelname: ifName
          oid: 1.3.6.1.2.1.31.1.1.1.1
          type: DisplayString
    - name: ifHCInBroadcastPkts
      oid: 1.3.6.1.2.1.31.1.1.1.9
      type: counter
      help: The number of packets, delivered by this sub-layer to a higher (sub-)layer,
        which were addressed to a broadcast address at this sub-layer - 1.3.6.1.2.1.31.1.1.1.9
      indexes:
        - labelname: ifIndex
          type: gauge
      lookups:
        - labels:
            - ifIndex
          labelname: ifAlias
          oid: 1.3.6.1.2.1.31.1.1.1.18
          type: DisplayString
        - labels:
            - ifIndex
          labelname: ifDescr
          oid: 1.3.6.1.2.1.2.2.1.2
          type: DisplayString
        - labels:
            - ifIndex
          labelname: ifName
          oid: 1.3.6.1.2.1.31.1.1.1.1
          type: DisplayString
    - name: ifHCOutOctets
      oid: 1.3.6.1.2.1.31.1.1.1.10
      type: counter
      help: The total number of octets transmitted out of the interface, including framing
        characters - 1.3.6.1.2.1.31.1.1.1.10
      indexes:
        - labelname: ifIndex
          type: gauge
      lookups:
        - labels:
            - ifIndex
          labelname: ifAlias
          oid: 1.3.6.1.2.1.31.1.1.1.18
          type: DisplayString
        - labels:
            - ifIndex
          labelname: ifDescr
          oid: 1.3.6.1.2.1.2.2.1.2
          type: DisplayString
        - labels:
            - ifIndex
          labelname: ifName
          oid: 1.3.6.1.2.1.31.1.1.1.1
          type: DisplayString
    - name: ifHCOutUcastPkts
      oid: 1.3.6.1.2.1.31.1.1.1.11
      type: counter
      help: The total number of packets that higher-level protocols requested be transmitted,
        and which were not addressed to a multicast or broadcast address at this sub-layer,
        including those that were discarded or not sent - 1.3.6.1.2.1.31.1.1.1.11
      indexes:
        - labelname: ifIndex
          type: gauge
      lookups:
        - labels:
            - ifIndex
          labelname: ifAlias
          oid: 1.3.6.1.2.1.31.1.1.1.18
          type: DisplayString
        - labels:
            - ifIndex
          labelname: ifDescr
          oid: 1.3.6.1.2.1.2.2.1.2
          type: DisplayString
        - labels:
            - ifIndex
          labelname: ifName
          oid: 1.3.6.1.2.1.31.1.1.1.1
          type: DisplayString
    - name: ifHCOutMulticastPkts
      oid: 1.3.6.1.2.1.31.1.1.1.12
      type: counter
      help: The total number of packets that higher-level protocols requested be transmitted,
        and which were addressed to a multicast address at this sub-layer, including
        those that were discarded or not sent - 1.3.6.1.2.1.31.1.1.1.12
      indexes:
        - labelname: ifIndex
          type: gauge
      lookups:
        - labels:
            - ifIndex
          labelname: ifAlias
          oid: 1.3.6.1.2.1.31.1.1.1.18
          type: DisplayString
        - labels:
            - ifIndex
          labelname: ifDescr
          oid: 1.3.6.1.2.1.2.2.1.2
          type: DisplayString
        - labels:
            - ifIndex
          labelname: ifName
          oid: 1.3.6.1.2.1.31.1.1.1.1
          type: DisplayString
    - name: ifHCOutBroadcastPkts
      oid: 1.3.6.1.2.1.31.1.1.1.13
      type: counter
      help: The total number of packets that higher-level protocols requested be transmitted,
        and which were addressed to a broadcast address at this sub-layer, including
        those that were discarded or not sent - 1.3.6.1.2.1.31.1.1.1.13
      indexes:
        - labelname: ifIndex
          type: gauge
      lookups:
        - labels:
            - ifIndex
          labelname: ifAlias
          oid: 1.3.6.1.2.1.31.1.1.1.18
          type: DisplayString
        - labels:
            - ifIndex
          labelname: ifDescr
          oid: 1.3.6.1.2.1.2.2.1.2
          type: DisplayString
        - labels:
            - ifIndex
          labelname: ifName
          oid: 1.3.6.1.2.1.31.1.1.1.1
          type: DisplayString
    - name: ifLinkUpDownTrapEnable
      oid: 1.3.6.1.2.1.31.1.1.1.14
      type: gauge
      help: Indicates whether linkUp/linkDown traps should be generated for this interface
        - 1.3.6.1.2.1.31.1.1.1.14
      indexes:
        - labelname: ifIndex
          type: gauge
      lookups:
        - labels:
            - ifIndex
          labelname: ifAlias
          oid: 1.3.6.1.2.1.31.1.1.1.18
          type: DisplayString
        - labels:
            - ifIndex
          labelname: ifDescr
          oid: 1.3.6.1.2.1.2.2.1.2
          type: DisplayString
        - labels:
            - ifIndex
          labelname: ifName
          oid: 1.3.6.1.2.1.31.1.1.1.1
          type: DisplayString
      enum_values:
        1: enabled
        2: disabled
    - name: ifHighSpeed
      oid: 1.3.6.1.2.1.31.1.1.1.15
      type: gauge
      help: An estimate of the interface's current bandwidth in units of 1,000,000 bits
        per second - 1.3.6.1.2.1.31.1.1.1.15
      indexes:
        - labelname: ifIndex
          type: gauge
      lookups:
        - labels:
            - ifIndex
          labelname: ifAlias
          oid: 1.3.6.1.2.1.31.1.1.1.18
          type: DisplayString
        - labels:
            - ifIndex
          labelname: ifDescr
          oid: 1.3.6.1.2.1.2.2.1.2
          type: DisplayString
        - labels:
            - ifIndex
          labelname: ifName
          oid: 1.3.6.1.2.1.31.1.1.1.1
          type: DisplayString
    - name: ifPromiscuousMode
      oid: 1.3.6.1.2.1.31.1.1.1.16
      type: gauge
      help: This object has a value of false(2) if this interface only accepts packets/frames
        that are addressed to this station - 1.3.6.1.2.1.31.1.1.1.16
      indexes:
        - labelname: ifIndex
          type: gauge
      lookups:
        - labels:
            - ifIndex
          labelname: ifAlias
          oid: 1.3.6.1.2.1.31.1.1.1.18
          type: DisplayString
        - labels:
            - ifIndex
          labelname: ifDescr
          oid: 1.3.6.1.2.1.2.2.1.2
          type: DisplayString
        - labels:
            - ifIndex
          labelname: ifName
          oid: 1.3.6.1.2.1.31.1.1.1.1
          type: DisplayString
      enum_values:
        1: "true"
        2: "false"
    - name: ifConnectorPresent
      oid: 1.3.6.1.2.1.31.1.1.1.17
      type: gauge
      help: This object has the value 'true(1)' if the interface sublayer has a physical
        connector and the value 'false(2)' otherwise. - 1.3.6.1.2.1.31.1.1.1.17
      indexes:
        - labelname: ifIndex
          type: gauge
      lookups:
        - labels:
            - ifIndex
          labelname: ifAlias
          oid: 1.3.6.1.2.1.31.1.1.1.18
          type: DisplayString
        - labels:
            - ifIndex
          labelname: ifDescr
          oid: 1.3.6.1.2.1.2.2.1.2
          type: DisplayString
        - labels:
            - ifIndex
          labelname: ifName
          oid: 1.3.6.1.2.1.31.1.1.1.1
          type: DisplayString
      enum_values:
        1: "true"
        2: "false"
    - name: ifCounterDiscontinuityTime
      oid: 1.3.6.1.2.1.31.1.1.1.19
      type: gauge
      help: The value of sysUpTime on the most recent occasion at which any one or more
        of this interface's counters suffered a discontinuity - 1.3.6.1.2.1.31.1.1.1.19
      indexes:
        - labelname: ifIndex
          type: gauge
      lookups:
        - labels:
            - ifIndex
          labelname: ifAlias
          oid: 1.3.6.1.2.1.31.1.1.1.18
          type: DisplayString
        - labels:
            - ifIndex
          labelname: ifDescr
          oid: 1.3.6.1.2.1.2.2.1.2
          type: DisplayString
        - labels:
            - ifIndex
          labelname: ifName
          oid: 1.3.6.1.2.1.31.1.1.1.1
          type: DisplayString
`

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/pkg/service/monitor/switch.go
```golang
package monitor

import (
	"context"

	v12 "github.com/prometheus-operator/prometheus-operator/pkg/apis/monitoring/v1"
	"k8s.io/klog/v2"

	//"k8s.io/api/core/v1"
	k8serr "k8s.io/apimachinery/pkg/api/errors"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

const (
	//serviceMonitor name
	SwitchServiceName = "prometheus-snmp-exporter"
)

var Selector = metav1.LabelSelector{
	MatchLabels: map[string]string{
		"app.kubernetes.io/instance": "prometheus-snmp-exporter",
		"app.kubernetes.io/name":     "prometheus-snmp-exporter",
	},
}

var relabel = []*v12.RelabelConfig{
	{
		Action:       "replace",
		SourceLabels: []string{"__param_target"},
		TargetLabel:  "instance",
	},
	{
		Action:       "replace",
		SourceLabels: []string{"__param_region"},
		TargetLabel:  "region",
	},
	{
		Action:       "replace",
		SourceLabels: []string{"__param_az"},
		TargetLabel:  "az",
	},
	{
		Action:       "replace",
		SourceLabels: []string{"__param_name"},
		TargetLabel:  "identifier",
	},
	{
		Action:       "replace",
		SourceLabels: []string{"__param_name"},
		TargetLabel:  "hostname",
	},
}

var switchModule = []string{
	"if_mib",
}

var defaultEndpoint = v12.Endpoint{
	Port:           "http",
	Path:           "/snmp",
	Scheme:         "",
	Params:         nil,
	Interval:       "180s",
	ScrapeTimeout:  "180s",
	HonorLabels:    true,
	RelabelConfigs: relabel,
}

var defaultServiceMonitor = v12.ServiceMonitor{
	TypeMeta: metav1.TypeMeta{
		Kind:       "ServiceMonitor",
		APIVersion: "monitoring.coreos.com/v1",
	},
	ObjectMeta: metav1.ObjectMeta{
		Name:      SwitchServiceName,
		Namespace: MetricsNamespace,
		Labels: map[string]string{
			"release":                      "pm",
			"app.kubernetes.io/managed-by": "Helm",
			"prometheus":                   "kube-prometheus",
		},
	},
	Spec: v12.ServiceMonitorSpec{
		TargetLabels: []string{
			"region", "az", "identifier",
		},
		Selector:  Selector,
		Endpoints: []v12.Endpoint{defaultEndpoint},
	},
}

type SwitchInfo struct {
	name          string // 交换机的名称
	ip            string
	region        string
	az            string
	mib           string
	interval      string
	scrapeTimeout string
}

type RegisterSwitchService struct {
	switchList []SwitchInfo
	monitor    *ServiceMonitors
}

func NewRegisterSwitchService(switchList []SwitchInfo) *RegisterSwitchService {
	rp := &RegisterSwitchService{
		monitor:    NewServiceMonitors(),
		switchList: switchList,
	}
	return rp
}

func (r *RegisterSwitchService) Register() error {
	monitor, err := r.Init()
	if err != nil {
		klog.Errorf("Get ServiceMonitors %s Error %v", SwitchServiceName, err)
		return err
	}
	monitor.Spec.Endpoints = make([]v12.Endpoint, len(r.switchList))
	for i, s := range r.switchList {
		point := defaultEndpoint

		point.Params = map[string][]string{
			"name":     {s.name},
			"target":   {s.ip},
			"module":   {s.mib}, //switchModule //todo 暂不支持动态module
			"region":   {s.region},
			"az":       {s.az},
			"hostname": {s.name},
		}
		point.Interval = s.interval
		point.ScrapeTimeout = s.scrapeTimeout
		monitor.Spec.Endpoints[i] = point
	}

	klog.Infof("Switch monitor==== %v", monitor)
	_, err = r.monitor.Update(context.TODO(), monitor)
	if err != nil {
		klog.Errorf("Update ServiceMonitors %s Error %v", SwitchServiceName, err)
		return err
	}
	klog.Infof("Register Switch ip list %v", r.switchList)
	return err
}

//初始化服务，存在则返回，不存在则创建
func (r *RegisterSwitchService) Init() (monitor *v12.ServiceMonitor, err error) {
	monitor, err = r.Get()
	if err == nil {
		return
	}
	//不存在serviceMonitor则创建
	if k8serr.IsNotFound(err) {
		monitor, err = r.Create(SwitchServiceName)
	}
	return
}

func (r *RegisterSwitchService) Get() (*v12.ServiceMonitor, error) {
	return r.monitor.Get(context.TODO(), SwitchServiceName)
}

func (r *RegisterSwitchService) Create(name string) (*v12.ServiceMonitor, error) {
	klog.Infoln("Create Switch ServiceMonitor 11111111111111")
	var sr = defaultServiceMonitor
	sr.Name = name
	return r.monitor.Create(context.TODO(), &sr)
}

func (r *RegisterSwitchService) Update(sr *v12.ServiceMonitor) (*v12.ServiceMonitor, error) {
	klog.Infoln("Update Switch ServiceMonitor 11111111111111")
	return r.monitor.Update(context.TODO(), sr)
}

type MibList struct {
	IfMib  Mib `yaml:"if_mib"`
	HwMib  Mib `yaml:"hw_mib"`
	H3cMib Mib `yaml:"h3c_mib"`
}

type Mib struct {
	Get     []string  `yaml:"get"`
	Metrics []Metrics `yaml:"metrics"`
	Auth    Auth      `yaml:"auth"`
	Walk    []string  `yaml:"walk"`
}

type Metrics struct {
	Name       string     `yaml:"name"`
	Oid        string     `yaml:"oid"`
	Type       string     `yaml:"type"`
	Help       string     `yaml:"help"`
	Indexes    []Indexes  `yaml:"indexes"`
	Lookups    []Lookups  `yaml:"lookups"`
	EnumValues EnumValues `yaml:"enum_values"`
}

type Indexes struct {
	Labelname string `yaml:"labelname"`
	Type      string `yaml:"type"`
}

type Lookups struct {
	Labels    []string `yaml:"labels"`
	Labelname string   `yaml:"labelname"`
	Oid       string   `yaml:"oid"`
	Type      string   `yaml:"type"`
}

type Auth struct {
	Community string `yaml:"community"`
}

type EnumValues struct {
}

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/pkg/service/monitor/servicemonitor.go
```golang
package monitor

import (
	"context"
	"time"

	v12 "github.com/prometheus-operator/prometheus-operator/pkg/apis/monitoring/v1"
	v1 "github.com/prometheus-operator/prometheus-operator/pkg/client/versioned/typed/monitoring/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

const (
	ServiceMonitorTimeout = 10 * time.Second
	MetricsNamespace      = "monitoring"
)

type ServiceMonitors struct {
	client *v1.MonitoringV1Client
}

func NewServiceMonitors() *ServiceMonitors {
	v1client := v1.NewForConfigOrDie(k8sConfig())
	rp := &ServiceMonitors{
		client: v1client,
	}
	return rp
}

func (r *ServiceMonitors) Get(ctx context.Context, name string) (*v12.ServiceMonitor, error) {
	var opts metav1.GetOptions
	ctx, cancel := context.WithTimeout(ctx, ServiceMonitorTimeout)
	defer cancel()
	return r.client.ServiceMonitors(MetricsNamespace).Get(ctx, name, opts)
}

func (r *ServiceMonitors) Create(ctx context.Context, monitor *v12.ServiceMonitor) (*v12.ServiceMonitor, error) {
	var opts metav1.CreateOptions
	ctx, cancel := context.WithTimeout(ctx, ServiceMonitorTimeout)
	defer cancel()
	return r.client.ServiceMonitors(MetricsNamespace).Create(ctx, monitor, opts)
}

func (r *ServiceMonitors) Update(ctx context.Context, monitor *v12.ServiceMonitor) (*v12.ServiceMonitor, error) {
	var opts metav1.UpdateOptions
	ctx, cancel := context.WithTimeout(ctx, ServiceMonitorTimeout)
	defer cancel()
	return r.client.ServiceMonitors(MetricsNamespace).Update(ctx, monitor, opts)
}

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/pkg/service/monitor/ipmi.go
```golang
package monitor

import (
	"context"

	v12 "github.com/prometheus-operator/prometheus-operator/pkg/apis/monitoring/v1"
	"k8s.io/klog/v2"

	//"k8s.io/api/core/v1"
	k8serr "k8s.io/apimachinery/pkg/api/errors"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

const (
	//serviceMonitor name
	IpmiServiceName = "ipmi-exporter"
)

var SelectorIpmi = metav1.LabelSelector{
	MatchLabels: map[string]string{
		"app": "ipmi-exporter",
		//"app.kubernetes.io/name":     "ipmi-exporter",
	},
}

var relabelIpmi = []*v12.RelabelConfig{
	{
		Action:       "replace",
		Regex:        "(.*)",
		Replacement:  "$1",
		SourceLabels: []string{"__param_target"},
		TargetLabel:  "instance",
	},
	{
		Action:       "replace",
		Regex:        "(.*)",
		Replacement:  "$1",
		SourceLabels: []string{"__param_region"},
		TargetLabel:  "region",
	},
	{
		Action:       "replace",
		Regex:        "(.*)",
		Replacement:  "$1",
		SourceLabels: []string{"__param_az"},
		TargetLabel:  "az",
	},
	{
		Action:       "replace",
		Regex:        "(.*)",
		Replacement:  "$1",
		SourceLabels: []string{"__param_lab"},
		TargetLabel:  "lab",
	},
	{
		Action:       "replace",
		Regex:        "(.*)",
		Replacement:  "$1",
		SourceLabels: []string{"__param_hostname"},
		TargetLabel:  "hostname",
	},
}

var ipmiModule = []string{
	//"default",
	"luban",
}

var defaultEndpointIpmi = v12.Endpoint{
	Port:           "ipmi-exporter",
	Path:           "/ipmi",
	Scheme:         "",
	Params:         nil,
	Interval:       "180s",
	ScrapeTimeout:  "180s",
	RelabelConfigs: relabelIpmi,
}

var defaultServiceMonitorIpmi = v12.ServiceMonitor{
	TypeMeta: metav1.TypeMeta{
		Kind:       "ServiceMonitor",
		APIVersion: "monitoring.coreos.com/v1",
	},
	ObjectMeta: metav1.ObjectMeta{
		Name:      IpmiServiceName,
		Namespace: MetricsNamespace,
		Labels: map[string]string{
			"release": "pm",
			"app":     "ipmi-exporter",
		},
		Annotations: map[string]string{
			"kubectl.kubernetes.io/last-applied-configuration": `|
			{"apiVersion":"monitoring.coreos.com/v1","kind":"ServiceMonitor","metadata":{"annotations":{},"labels":{"app":"ipmi-exporter","release":"pm"},"name":"ipmi-exporter","namespace":"monitoring"},"spec":{"endpoints":[{"interval":"60s","params":{"module":["default"],"target":["10.178.251.225"]},"path":"/ipmi","port":"ipmi-exporter","relabelings":[{"action":"replace","sourceLabels":["__param_target"],"targetLabel":"instance"}],"scrapeTimeout":"60s"}],"namespaceSelector":{},"selector":{"matchLabels":{"app":"ipmi-exporter"}}}}`,
		},
	},
	Spec: v12.ServiceMonitorSpec{
		TargetLabels: []string{
			"region", "az", "lab",
		},
		Selector:  SelectorIpmi,
		Endpoints: []v12.Endpoint{defaultEndpointIpmi},
	},
}

type IpmiInfo struct {
	ip       string
	region   string
	az       string
	lab      string
	hostName string
	module   string
}

type RegisterIpmiService struct {
	ipmiList []IpmiInfo
	monitor  *ServiceMonitors
}

func NewRegisterIpmiService(ipmiList []IpmiInfo) *RegisterIpmiService {
	rp := &RegisterIpmiService{
		monitor:  NewServiceMonitors(),
		ipmiList: ipmiList,
	}
	return rp
}

func (r *RegisterIpmiService) Register() error {
	monitor, err := r.Init()
	if err != nil {
		klog.Errorf("Get ServiceMonitors %s Error %v", IpmiServiceName, err)
		return err
	}
	monitor.Spec.Endpoints = make([]v12.Endpoint, len(r.ipmiList))
	for i, s := range r.ipmiList {
		point := defaultEndpointIpmi
		point.Params = map[string][]string{
			"target":   {s.ip},
			"module":   {s.module}, //todo 暂不支持动态module
			"region":   {s.region},
			"az":       {s.az},
			"lab":      {s.lab},
			"hostname": {s.hostName},
		}
		monitor.Spec.Endpoints[i] = point
	}
	klog.Infof("ipmiModule", ipmiModule)
	klog.Infof("ipmiMonitor", monitor)
	_, err = r.monitor.Update(context.TODO(), monitor)
	klog.Infof("Register Ipmi ip list %v", r.ipmiList)
	return err
}

//初始化服务，存在则返回，不存在则创建
func (r *RegisterIpmiService) Init() (monitor *v12.ServiceMonitor, err error) {
	monitor, err = r.Get()
	if err == nil {
		return
	}
	//不存在serviceMonitor则创建
	if k8serr.IsNotFound(err) {
		monitor, err = r.Create(IpmiServiceName)
	}
	return
}

func (r *RegisterIpmiService) Get() (*v12.ServiceMonitor, error) {
	return r.monitor.Get(context.TODO(), IpmiServiceName)
}

func (r *RegisterIpmiService) Create(name string) (*v12.ServiceMonitor, error) {
	var sr = defaultServiceMonitorIpmi
	sr.Name = name
	return r.monitor.Create(context.TODO(), &sr)
}

func (r *RegisterIpmiService) Update(sr *v12.ServiceMonitor) (*v12.ServiceMonitor, error) {
	return r.monitor.Update(context.TODO(), sr)
}

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/pkg/service/monitor/blackbox.go
```golang
package monitor

import (
	"context"
	"fmt"
	"luban-cmdb-api/pkg/models/businessManagement"

	v12 "github.com/prometheus-operator/prometheus-operator/pkg/apis/monitoring/v1"
	k8serr "k8s.io/apimachinery/pkg/api/errors"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/klog/v2"
)

//同步进程数据到blackbox exporter

const (
	//服务级记录, 后缀为服务id
	BlackboxMonitorName = "blackbox-exporter-%d"
)

var blackboxSelector = metav1.LabelSelector{
	MatchLabels: map[string]string{
		"name": "blackbox-exporter",
	},
}

var blackboxRelabel = []*v12.RelabelConfig{
	{
		Action:       "replace",
		SourceLabels: []string{"__param_target"},
		TargetLabel:  "target",
	},
	{
		Action:       "replace",
		SourceLabels: []string{"__meta_kubernetes_service_label_cluster"},
		TargetLabel:  "cluster",
	},
	{
		Action:       "replace",
		SourceLabels: []string{"__param_module"},
		TargetLabel:  "module",
	},
	{
		Action:       "replace",
		SourceLabels: []string{"__param_region"},
		TargetLabel:  "region",
	},
	{
		Action:       "replace",
		SourceLabels: []string{"__param_az"},
		TargetLabel:  "az",
	},
	{
		Action:       "replace",
		SourceLabels: []string{"__param_service"},
		TargetLabel:  "service",
	},
	{
		Action:       "replace",
		SourceLabels: []string{"__param_hostname"},
		TargetLabel:  "hostname",
	},
}

var tcpModule = []string{
	"tcp_connect",
}

var blackboxEndpoint = v12.Endpoint{
	Port:           "http-metrics",
	Path:           "/probe",
	Params:         nil,
	Interval:       "60s",
	ScrapeTimeout:  "60s",
	HonorLabels:    true,
	RelabelConfigs: blackboxRelabel,
}

var blackboxServiceMonitor = v12.ServiceMonitor{
	TypeMeta: metav1.TypeMeta{
		Kind:       "ServiceMonitor",
		APIVersion: "monitoring.coreos.com/v1",
	},
	ObjectMeta: metav1.ObjectMeta{
		Name:      "",
		Namespace: MetricsNamespace,
		Labels: map[string]string{
			"release":                      "pm",
			"app.kubernetes.io/managed-by": "Helm",
			"prometheus":                   "kube-prometheus",
			"exporter-name":                "blackbox-exporter",
		},
	},
	Spec: v12.ServiceMonitorSpec{
		NamespaceSelector: v12.NamespaceSelector{
			MatchNames: []string{"monitoring"},
		},
		Selector:  blackboxSelector,
		Endpoints: []v12.Endpoint{blackboxEndpoint},
	},
}

type RegisterBlackboxService struct {
	monitor     *ServiceMonitors
	id          int
	processList []businessManagement.ProcessLatest
}

func NewRegisterBlackboxService(svcId int, processList []businessManagement.ProcessLatest) *RegisterBlackboxService {
	return &RegisterBlackboxService{
		monitor:     NewServiceMonitors(),
		id:          svcId,
		processList: processList,
	}
}

func (r *RegisterBlackboxService) Register() error {
	monitor, err := r.Init()
	if err != nil {
		klog.Errorf("Get ServiceMonitors %s Error %v", SwitchServiceName, err)
		return err
	}
	monitor.Spec.Endpoints = make([]v12.Endpoint, len(r.processList))
	for i, v := range r.processList {
		//todo 暂不支持UDP协议
		if v.Protocol == businessManagement.PROTOCOL_UDP {
			klog.Warningf("udp protocol is not supported, name=%s,instance=%s:%s", v.Name, v.Ip, v.Port)
			continue
		}
		//todo 暂时只做了最基础的区分，后期需根据业务需求改造
		//支持的module通过blackbox exporter的configMap配置
		module := tcpModule
		if v.Protocol == businessManagement.PROTOCOL_ICMP {
			module = []string{"icmp"}
		}

		point := blackboxEndpoint
		target := fmt.Sprintf("%s:%s", v.Ip, v.Port)
		point.Params = map[string][]string{
			"target":   {target},
			"module":   module,
			"service":  {v.Name},
			"region":   {v.RegionCode},
			"az":       {v.AzCode},
			"hostname": {v.HostName},
		}
		monitor.Spec.Endpoints[i] = point
	}
	_, err = r.monitor.Update(context.TODO(), monitor)
	klog.Infof("Register Blackbox list %v", r.processList)
	return err
}

//初始化服务，存在则返回，不存在则创建
func (r *RegisterBlackboxService) Init() (monitor *v12.ServiceMonitor, err error) {
	monitor, err = r.monitor.Get(context.TODO(), r.name())
	if err == nil {
		return
	}
	//不存在serviceMonitor则创建
	if k8serr.IsNotFound(err) {
		newMonitor := blackboxServiceMonitor
		newMonitor.Name = r.name()
		newMonitor.ObjectMeta.Name = r.name()
		monitor, err = r.monitor.Create(context.TODO(), &newMonitor)
	}
	return
}

func (r *RegisterBlackboxService) name() string {
	return fmt.Sprintf(BlackboxMonitorName, r.id)
}

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/pkg/service/monitor/node.go
```golang
package monitor

import (
	"context"
	serverModel "luban-cmdb-api/pkg/models/server"
	"os"
	"strconv"

	v12 "github.com/prometheus-operator/prometheus-operator/pkg/apis/monitoring/v1"
	v1 "k8s.io/api/core/v1"
	k8serr "k8s.io/apimachinery/pkg/api/errors"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/util/intstr"
	"k8s.io/client-go/kubernetes"
	"k8s.io/klog/v2"
)

//物理机级别监控
var (
	PhysicalNodes = "physical-nodes"
	ProcessNodes  = "process-nodes"
	GalaxyNodes   = "galaxy-nodes"
)

type RegisterPmService struct {
	client           *kubernetes.Clientset
	physicalHosts    []serverModel.PhysicalHostData
	monitor          *ServiceMonitors
	region           string
	az               string
	resourcePool     string
	resourcePoolType string
	name             string
}

func NewRegisterPmService(physicalHosts []serverModel.PhysicalHostData, region, az, resourcePool, resourcePoolType string) *RegisterPmService {
	rp := &RegisterPmService{
		client:           InitClientSet(),
		physicalHosts:    physicalHosts,
		monitor:          NewServiceMonitors(),
		region:           region,
		az:               az,
		resourcePool:     resourcePool,
		resourcePoolType: resourcePoolType,
	}
	return rp
}

func (r *RegisterPmService) CheckService(serviceName string) error {
	_, err := r.client.CoreV1().Services(MetricsNamespace).Get(context.Background(), serviceName, metav1.GetOptions{})
	return err
}

func (r *RegisterPmService) CreateService(name string, port, target int32, ctx context.Context) {
	s := &v1.Service{
		ObjectMeta: metav1.ObjectMeta{
			Name: r.name,
			Labels: map[string]string{
				"k8s-app": name,
			},
		},
		Spec: v1.ServiceSpec{
			Ports: []v1.ServicePort{
				{
					Name:       "metrics",
					Protocol:   "TCP",
					Port:       port,
					TargetPort: intstr.IntOrString{Type: intstr.Int, IntVal: target},
				},
			},
		},
	}
	if r.region != "" {
		s.ObjectMeta.SetLabels(map[string]string{
			"k8s-app":          name,
			"region":           r.region,
			"az":               r.az,
			"resourcePool":     r.resourcePool,
			"resourcePoolType": r.resourcePoolType,
		})
	}
	_, err := r.client.CoreV1().Services(MetricsNamespace).Create(ctx, s, metav1.CreateOptions{})
	if err != nil {
		klog.Errorf("create prometheus service failed: %s", err.Error())
	}
}
func (r *RegisterPmService) CreateEndpoint(name string, ctx context.Context, port int32) {
	if err := r.CheckService(r.name); err != nil {
		switch {
		case name == PhysicalNodes:
			r.CreateService(name, port, port, ctx)
		case name == ProcessNodes:
			r.CreateService(name, port, port, ctx)
		case name == GalaxyNodes:
			r.CreateService(name, port, port, ctx)
		}
	}

	e := &v1.Endpoints{
		ObjectMeta: metav1.ObjectMeta{
			Name: r.name,
			Labels: map[string]string{
				"k8s-app": name,
			},
		},
		Subsets: []v1.EndpointSubset{
			{
				Addresses: r.getEndpointAddress(),
				Ports: []v1.EndpointPort{
					{
						Name:     "metrics",
						Port:     port,
						Protocol: "TCP",
					},
				},
			},
		},
	}
	_, err := r.client.CoreV1().Endpoints(MetricsNamespace).Create(ctx, e, metav1.CreateOptions{})
	if err != nil {
		klog.Errorf("create prometheus endpoint failed: %s", err.Error())
	}
}

func (r *RegisterPmService) Register(node, proccess, luban bool, ctx context.Context) {
	if node {
		r.RegisterPmPhycialEndpoint(ctx)
	}
	if proccess {
		r.RegisterPmProcessEndpoint(ctx)
	}
	if luban {
		r.RegisterPmLubanEndpoint(ctx)
	}
}

func (r *RegisterPmService) RegisterPmPhycialEndpoint(ctx context.Context) {
	r.RegisterPmEndpoint(PhysicalNodes, ctx, 9100) //PhysicalNodes
}
func (r *RegisterPmService) RegisterPmProcessEndpoint(ctx context.Context) {
	r.name = ProcessNodes
	r.RegisterPmEndpoint(ProcessNodes, ctx, 9256)
}
func (r *RegisterPmService) RegisterPmLubanEndpoint(ctx context.Context) {
	r.name = GalaxyNodes
	portStr := os.Getenv("GALAXY_EXPORTER_PORT")
	if portStr == "" {
		portStr = "1989"
	}
	port, err := strconv.ParseInt(portStr, 10, 32)
	if err != nil {
		port = 1989
	}
	//r.RegisterPmEndpoint(GalaxyNodes, ctx, 1988)
	r.RegisterPmEndpoint(GalaxyNodes, ctx, int32(port))
}

func (r *RegisterPmService) RegisterPmEndpoint(epName string, ctx context.Context, port int32) {
	if !r.checkConfig() {
		return
	}
	eps, err := r.client.CoreV1().Endpoints(MetricsNamespace).Get(context.TODO(), r.name, metav1.GetOptions{})
	if err != nil {
		klog.Errorf("get endpoint list error : %v", err)
		r.CreateEndpoint(epName, ctx, port)
		return
	}

	eps.Subsets[0].Addresses = r.getEndpointAddress()
	_, err = r.client.CoreV1().Endpoints(MetricsNamespace).Update(context.TODO(), eps, metav1.UpdateOptions{})
	if err != nil {
		klog.Errorf("update endpoint success ip : %s", err)
	}
}

func (r *RegisterPmService) getEndpointAddress() []v1.EndpointAddress {
	var endAddressList []v1.EndpointAddress
	for i, ip := range r.physicalHosts {
		endAddressList = append(endAddressList, v1.EndpointAddress{
			IP: ip.Ip,
			NodeName: &r.physicalHosts[i].Name,
		})
	}
	return endAddressList
}

func (r *RegisterPmService) checkConfig() bool {
	if r.client != nil {
		return true
	}
	return InitClientSet() != nil
}
func (r *RegisterPmService) RegisterPmServiceMonitor(node, proccess, luban bool, ctx context.Context) {
	if node {
		r.RegisterPmSvcMonitor(PhysicalNodes, []string{"region", "az", "resourcePool", "resourcePoolType"}, ctx)
	}
	if proccess {
		r.RegisterPmSvcMonitor(ProcessNodes, []string{}, ctx)
	}
	if luban {
		r.RegisterPmSvcMonitor(GalaxyNodes, []string{}, ctx)
	}
}
func (r *RegisterPmService) RegisterPmSvcMonitor(epName string, targetLabels []string, ctx context.Context) (monitor *v12.ServiceMonitor, err error) {
	if !r.checkConfig() {
		return
	}
	monitor, err = r.monitor.Get(ctx, epName)
	if err == nil {
		return
	}
	//不存在serviceMonitor则创建
	if k8serr.IsNotFound(err) {
		r.CreateServiceMonitor(epName, targetLabels, ctx)
	}
	return
}
func (r *RegisterPmService) CreateServiceMonitor(serviceMonitorName string, targetLabels []string, ctx context.Context) {

	var s = v12.ServiceMonitor{
		TypeMeta: metav1.TypeMeta{
			Kind:       "ServiceMonitor",
			APIVersion: "monitoring.coreos.com/v1",
		},
		ObjectMeta: metav1.ObjectMeta{
			Name:      serviceMonitorName,
			Namespace: MetricsNamespace,
			Labels: map[string]string{
				"release": "pm",
				"k8s-app": serviceMonitorName,
			},
		},
		Spec: v12.ServiceMonitorSpec{
			NamespaceSelector: v12.NamespaceSelector{
				MatchNames: []string{"monitoring"},
			},
			Selector: metav1.LabelSelector{
				MatchLabels: map[string]string{
					"k8s-app": serviceMonitorName,
				},
			},
			Endpoints: []v12.Endpoint{
				{
					Port:     "metrics",
					Interval: "60s",
					RelabelConfigs: []*v12.RelabelConfig{
						{
							Action: "replace",
							SourceLabels: []string{"__meta_kubernetes_endpoint_node_name"},
							TargetLabel: "hostname",
						},
					},
				},
			},
		},
	}
	if len(targetLabels) > 0 {
		s.Spec.TargetLabels = targetLabels
	}
	_, err := r.monitor.Create(context.TODO(), &s)
	if err != nil {
		klog.Errorf("create prometheus servicemonitor failed: %s", err.Error())
	}
}

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/pkg/service/esmanager/k3sEs.go
```golang
package esmanager

import (
	"bytes"
	"encoding/json"
	"fmt"
	"io"
	"io/ioutil"
	"k8s.io/klog/v2"
	"luban-cmdb-api/pkg/apiserver/config"
	"net/http"
	"strconv"
	"strings"
	"time"
)

var (
	esIndexDateFormat = "060102.15:04:05"
)

type EsKs3Wide struct {
	Hits struct {
		Total int       `json:"total"`
		Hits  []WideHit `json:"hits"`
	} `json:"hits"`
}

type WideHit struct {
	Index  string     `json:"_index"`
	Type   string     `json:"_type"`
	Source WideSource `json:"_source"`
}

type WideSource struct {
	D                 string  `json:"d"`
	UserId            string  `json:"userid"`
	BucketName        string  `json:"bucketname"`
	BucketId          string  `json:"bucketid"`
	Ks3Region         string  `json:"ks3region"`
	Time              int64   `json:"time"`
	StorageClass      string  `json:"storageclass"`
	AddTime           int64   `json:"addtime"`
	Times             int64   `json:"times"`
	Code              string  `json:"code"`
	Remoteipprovince  string  `json:"remoteipprovince"`
	Remoteipisp       string  `json:"remoteipisp"`
	Operation         string  `json:"operation"`
	Isinner           string  `json:"isinner"`
	Usertype          string  `json:"usertype"`
	Traffic_down      int64   `json:"traffic_down"`
	Traffic_up        int64   `json:"traffic_up"`
	Object_size       int64   `json:"object_size"`
	ReadSuccessTimes  float64 `json:"read_success_times"`
	WriteSuccessTimes float64 `json:"write_success_times"`
	ReadErrorTimes    float64 `json:"read_error_times"`
	WriteErrorTimes   float64 `json:"write_error_times"`
}

type BucketObjectCountInfo struct {
	BucketCreatedTime      string `json:"bucketCreatedTime"`
	BucketDeletedFlag      bool   `json:"bucketDeletedFlag"`
	BucketLastModifiedTime string `json:"bucketLastModifiedTime"`
	Date                   string `json:"date"`
	DeleteCount            int64  `json:"deleteSize"`
	ID                     int64  `json:"id"`
	Name                   string `json:"name"`
	PutCount               int64  `json:"putSize"`
	Region                 string `json:"region"`
	StorageClass           string `json:"storageClass"`
	TotalCount             int64  `json:"totalCount"`
	UserID                 string `json:"userId"`
}

func Get30DownloadNum(bucketId string) int64 {
	var downTotal int64 = 0
	for i := 30; i > 0; i-- {
		hourTime := -24 * i
		Ago := time.Now().Add(time.Duration(hourTime) * time.Hour).Format(esIndexDateFormat)
		AgoDate := strings.Split(Ago, ".")
		subIndex := AgoDate[0]
		_, down := GetBucketFlowById(bucketId, subIndex)
		downTotal += down
	}
	return downTotal
}

//基于id的前一天流量统计
func GetBucketFlowById(id, subIndex string) (int64, int64) {
	url := fmt.Sprintf("http://%s/col.ks3_wide.%s/_search?from=0&size=1&q=bucketid:%s", config.DefaultK3sEsService, subIndex, id)
	result, err := GetEsWideData(url)
	if err != nil {
		klog.Info(err)
		return 0, 0
	}
	total := result.Hits.Total

	totalUrl := fmt.Sprintf("http://%s/col.ks3_wide.%s/_search?from=0&size=%s&q=bucketid:%s", config.DefaultK3sEsService, subIndex, strconv.Itoa(total), id)
	totalResult, er := GetEsWideData(totalUrl)
	if er != nil {
		klog.Info(er)
		return 0, 0
	}
	count := len(totalResult.Hits.Hits)

	var up, down int64
	for i := 0; i < count; i++ {
		j := totalResult.Hits.Hits[i]
		up += j.Source.Traffic_up
		down += j.Source.Traffic_down
	}
	return up, down
}

func Get30ApiTimes(bucketId string) int64 {
	var timesTotal int64 = 0
	for i := 30; i > 0; i-- {
		hourTime := -24 * i
		Ago := time.Now().Add(time.Duration(hourTime) * time.Hour).Format(esIndexDateFormat)
		AgoDate := strings.Split(Ago, ".")
		subIndex := AgoDate[0]
		timesTotal += GetApiTimesById(bucketId, subIndex)
	}
	return timesTotal
}

func GetApiTimesById(id, subIndex string) int64 {
	url := fmt.Sprintf("http://%s/col.ks3_wide.%s/_search?from=0&size=1&q=bucketid:%s", config.DefaultK3sEsService, subIndex, id)
	result, err := GetEsWideData(url)
	if err != nil {
		klog.Info(err)
		return 0
	}
	total := result.Hits.Total

	totalUrl := fmt.Sprintf("http://%s/col.ks3_wide.%s/_search?from=0&size=%s&q=bucketid:%s", config.DefaultK3sEsService, subIndex, strconv.Itoa(total), id)
	totalResult, er := GetEsWideData(totalUrl)
	if er != nil {
		klog.Info(er)
		return 0
	}
	count := len(totalResult.Hits.Hits)

	var times int64
	for i := 0; i < count; i++ {
		j := totalResult.Hits.Hits[i]
		times += j.Source.Times
	}
	return times
}

//get es wide
func GetEsWideData(url string) (EsKs3Wide, error) {
	result := EsKs3Wide{}
	c := http.Client{}
	resp, err := c.Get(url)
	if err != nil {
		return result, err
	}
	b, er := io.ReadAll(resp.Body)
	if er != nil {
		fmt.Println(er.Error())
	}
	json.Unmarshal(b, &result)
	return result, nil
}

func GetBucketObjectCountById(region, date, bucketId string) ([]BucketObjectCountInfo, error) {
	bucketAggregationChargeInfoResp := BucketObjectCountInfo{}
	var bucketList []BucketObjectCountInfo
	c := http.Client{}
	// nowDate := time.Now().Format("20060102")
	// region := strings.ToUpper(os.Getenv("DEFAULT_BUCKET_REGION"))
	if region == "" {
		region = "CN-SHANGHAI-2"
	}

	url := fmt.Sprintf("http://%s/chargeInfo/count?date=%s&region=%s&bucketId=%s", config.DefaultChargeInfoService, date, region, bucketId)

	res, err := c.Get(url)
	if err != nil {
		return nil, err
	}
	if res.StatusCode != 200 {
		return nil, fmt.Errorf("res.StatusCode: %d", res.StatusCode)
	}
	bucketBytes, err := ioutil.ReadAll(res.Body)
	if err != nil {
		klog.Error(err)
	}

	bucketArr := bytes.Fields(bucketBytes)
	for _, bucket := range bucketArr {
		err = json.NewDecoder(bytes.NewReader(bucket)).Decode(&bucketAggregationChargeInfoResp)
		if err != nil {
			klog.Errorf("bucket entry decode err: %s", err.Error())
			continue
		}
		bucketList = append(bucketList, bucketAggregationChargeInfoResp)
	}
	return bucketList, err
}

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/pkg/service/sdn/sdn.go
```golang
package sdn

import (
	"context"
	v12 "github.com/prometheus-operator/prometheus-operator/pkg/apis/monitoring/v1"
	v1 "github.com/prometheus-operator/prometheus-operator/pkg/client/versioned/typed/monitoring/v1"
	v11 "k8s.io/api/core/v1"
	k8serr "k8s.io/apimachinery/pkg/api/errors"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/client-go/kubernetes"
	restclient "k8s.io/client-go/rest"
	"k8s.io/client-go/tools/clientcmd"
	"k8s.io/klog/v2"
	"os"
	"time"
)

const (
	ServiceMonitorTimeout = 10 * time.Second
	MetricsNamespace      = "monitoring"
	SdnNodes              = "sdn-exporter"
)

// InitClientSet 连接k8s集群，初始化客户端
func InitClientSet() *kubernetes.Clientset {
	clientset, err := kubernetes.NewForConfig(k8sConfig())
	if err != nil {
		panic(err.Error())
	}
	return clientset
}

// CreateService 创建sdn-exporter的service
func (r *RegisterPmService) CreateService(name string, port, target int32, ctx context.Context) {
	s := &v11.Service{
		ObjectMeta: metav1.ObjectMeta{
			Name: r.Name,
			Labels: map[string]string{
				"k8s-app": name,
			},
		},
		Spec: v11.ServiceSpec{
			Ports: []v11.ServicePort{
				{
					Name:     "metrics",
					Protocol: "TCP",
					Port:     port,
				},
			},
		},
	}
	_, err := r.Client.CoreV1().Services(MetricsNamespace).Create(ctx, s, metav1.CreateOptions{})
	if err != nil {
		klog.Errorf("create prometheus service failed: %s", err.Error())
	}
}

// CheckService 判断sdn-exporter service是否存在
func (r *RegisterPmService) CheckService(serviceName string) error {
	_, err := r.Client.CoreV1().Services(MetricsNamespace).Get(context.Background(), serviceName, metav1.GetOptions{})
	return err
}

// 连接k8s集群关于config的配置文件
func k8sConfig() *restclient.Config {
	var (
		config *restclient.Config
		err    error
	)
	if hasInK8s() {
		config, err = restclient.InClusterConfig()
	} else {
		home, _ := os.UserHomeDir()
		configFile := home + "/.kube/config"
		config, err = clientcmd.BuildConfigFromFlags("", configFile)
	}

	if err != nil {
		panic(err.Error())
	}
	config.Timeout = time.Minute
	return config
}

// 判断当前环境是否在k8s集群中
func hasInK8s() bool {
	host, port := os.Getenv("KUBERNETES_SERVICE_HOST"), os.Getenv("KUBERNETES_SERVICE_PORT")
	if len(host) == 0 || len(port) == 0 {
		klog.Infof("monitor ServerRegister task running stop, unable to load in-cluster configuration")
		return false
	}
	return true
}

// NewRegisterPmService 初始化RegisterPmService
func NewRegisterPmService(sdnAddressList []SdnAddressInfo) *RegisterPmService {
	rp := &RegisterPmService{
		Client:         InitClientSet(),
		SdnAddressList: sdnAddressList,
		Monitor:        NewServiceMonitors(),
		Name:           SdnNodes,
	}
	return rp
}

// NewServiceMonitors 初始化ServiceMonitors
func NewServiceMonitors() *ServiceMonitors {
	v1client := v1.NewForConfigOrDie(k8sConfig())
	rp := &ServiceMonitors{
		client: v1client,
	}
	return rp
}

// getEndpointAddress 将sdnList的参数放入endAddressList，以备使用
func (r *RegisterPmService) getEndpointAddress() []v11.EndpointAddress {
	var endAddressList []v11.EndpointAddress
	for _, ip := range r.SdnAddressList {
		endAddressList = append(endAddressList, v11.EndpointAddress{
			IP: ip.Ip,
		})
	}
	return endAddressList
}

// CreateEndPoint 创建endpoint,检查service是否存在，如果不存在，则同时创建snd的endpoints,service
func (r *RegisterPmService) CreateEndPoint(name string, ctx context.Context, port int32) {
	if err := r.CheckService(r.Name); err != nil {
		r.CreateService(name, port, port, ctx)
	}
	e := &v11.Endpoints{
		ObjectMeta: metav1.ObjectMeta{
			Name: r.Name,
			Labels: map[string]string{
				"k8s-app": name,
			},
		},
		Subsets: []v11.EndpointSubset{
			{
				Addresses: r.getEndpointAddress(),
				Ports: []v11.EndpointPort{
					{
						Name:     "metrics",
						Port:     port,
						Protocol: "TCP",
					},
				},
			},
		},
	}
	_, err := r.Client.CoreV1().Endpoints(MetricsNamespace).Create(ctx, e, metav1.CreateOptions{})
	if err != nil {
		klog.Errorf("create prometheus endpoint failed: %s", err.Error())
	}
}

// 判断集群是否已经初始化连接，如果没有，重新初始化一下，目的就是得到可用的clientSet
func (r *RegisterPmService) checkConfig() bool {
	if r.Client != nil {
		return true
	}
	return InitClientSet() != nil
}

// Get 判断集群中sdn的ServiceMonitor是否存在
func (r *ServiceMonitors) Get(ctx context.Context, name string) (*v12.ServiceMonitor, error) {
	var opts metav1.GetOptions
	ctx, cancel := context.WithTimeout(ctx, ServiceMonitorTimeout)
	defer cancel()
	return r.client.ServiceMonitors(MetricsNamespace).Get(ctx, name, opts)
}

// CreateServiceMonitor 创建sdn 的ServiceMonitor
func (r *RegisterPmService) CreateServiceMonitor(serviceMonitorName string, targetLabels []string, ctx context.Context) {

	var s = v12.ServiceMonitor{
		TypeMeta: metav1.TypeMeta{
			Kind:       "ServiceMonitor",
			APIVersion: "monitoring.coreos.com/v1",
		},
		ObjectMeta: metav1.ObjectMeta{
			Name:      serviceMonitorName,
			Namespace: MetricsNamespace,
			Labels: map[string]string{
				"release": "pm",
				"k8s-app": serviceMonitorName,
			},
		},
		Spec: v12.ServiceMonitorSpec{
			NamespaceSelector: v12.NamespaceSelector{
				MatchNames: []string{"monitoring"},
			},
			Selector: metav1.LabelSelector{
				MatchLabels: map[string]string{
					"k8s-app": serviceMonitorName,
				},
			},
			Endpoints: []v12.Endpoint{
				{
					Path:     "/metrics",
					Interval: "60s",
				},
			},
		},
	}
	if len(targetLabels) > 0 {
		s.Spec.TargetLabels = targetLabels
	}
	_, err := r.Monitor.Create(context.TODO(), &s)
	if err != nil {
		klog.Errorf("create prometheus servicemonitor failed: %s", err.Error())
	}
}
func (r *ServiceMonitors) Create(ctx context.Context, monitor *v12.ServiceMonitor) (*v12.ServiceMonitor, error) {
	var opts metav1.CreateOptions
	ctx, cancel := context.WithTimeout(ctx, ServiceMonitorTimeout)
	defer cancel()
	return r.client.ServiceMonitors(MetricsNamespace).Create(ctx, monitor, opts)
}

// RegisterPmSvcMonitor 这里是调用创建ServiceMonitor的接口，先用check判断是否存在，不存在再创建，避免重复创建
func (r *RegisterPmService) RegisterPmSvcMonitor(epName string, targetLabels []string, ctx context.Context) (monitor *v12.ServiceMonitor, err error) {
	if !r.checkConfig() {
		return
	}
	monitor, err = r.Monitor.Get(ctx, epName)
	if err == nil {
		return
	}
	//不存在serviceMonitor则创建
	if k8serr.IsNotFound(err) {
		r.CreateServiceMonitor(epName, targetLabels, ctx)
	}
	return
}

func (r *RegisterPmService) RegisterPmSdnEndpoint(ctx context.Context) {
	r.RegisterPmEndpoint(SdnNodes, ctx, 9200)
}

func (r *RegisterPmService) RegisterPmEndpoint(epName string, ctx context.Context, port int32) {
	if !r.checkConfig() {
		return
	}
	eps, err := r.Client.CoreV1().Endpoints(MetricsNamespace).Get(context.TODO(), r.Name, metav1.GetOptions{})
	if err != nil {
		klog.Errorf("get endpoint list error : %v", err)
		r.CreateEndPoint(epName, ctx, port)
		return
	}

	eps.Subsets[0].Addresses = r.getEndpointAddress()
	_, err = r.Client.CoreV1().Endpoints(MetricsNamespace).Update(context.TODO(), eps, metav1.UpdateOptions{})
	if err != nil {
		klog.Errorf("update endpoint success ip : %s", err)
	}
}
func (r *RegisterPmService) RegisterPfmSdnEndpoint(ctx context.Context) {
	r.RegisterPmEndpoint(SdnNodes, ctx, 9200) //PhysicalNodes
}

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/pkg/service/sdn/model.go
```golang
package sdn

import (
	v1 "github.com/prometheus-operator/prometheus-operator/pkg/client/versioned/typed/monitoring/v1"
	"k8s.io/client-go/kubernetes"
)

type SdnAddressInfo struct {
	Ip string
}
type ServiceMonitors struct {
	client *v1.MonitoringV1Client
}
type RegisterPmService struct {
	Client         *kubernetes.Clientset
	SdnAddressList []SdnAddressInfo
	Monitor        *ServiceMonitors
	Name           string
}

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/pkg/service/bm/bm.go
```golang
package lb

import (
	"context"
	"encoding/json"
	"errors"
	"fmt"
	basicdao "luban-cmdb-api/pkg/dao/basic"
	"luban-cmdb-api/pkg/gredis"
	"luban-cmdb-api/pkg/models/bm"
	bmtask "luban-cmdb-api/pkg/tasks/bm-task"
	taskcommen "luban-cmdb-api/pkg/tasks/commen"
	"luban-cmdb-api/pkg/utils/collection"
	"sort"
	"strconv"
	"strings"
	"time"

	"k8s.io/klog/v2"
)

type Service struct {
}

func NewService() *Service {
	return &Service{}
}

func (s Service) GetBmOverview(region, az string) (bm.OverviewRsp, error) {

	data, err := getbmListFromCache()
	if err != nil {
		return bm.OverviewRsp{}, err
	}
	azCodeAggregateMap, err := basicdao.GetAzCodeAggregateMap(basicdao.Az{})
	if err != nil {
		return bm.OverviewRsp{}, err
	}

	azCodeMap, err := basicdao.GetAzCodeMap(basicdao.Az{})
	if err != nil {
		return bm.OverviewRsp{}, err
	}

	for i, v := range data {
		//az字段转为 cn-shanghai-2a 的形式
		vaz := azCodeAggregateMap[v.AvailabilityZone]
		data[i].AvailabilityZone = vaz.AzCode
	}

	//filter
	list := []bmtask.BmAll{}
	if region != "" || az != "" {
		for _, v := range data {
			if region != "" && v.Region != region {
				continue
			}
			if az != "" && v.AvailabilityZone != az {
				continue
			}
			list = append(list, v)
		}
	} else {
		list = data
	}

	runningCount := 0
	closedCount := 0
	installFailedCount := 0
	reinstallFailedCount := 0
	//实例状态 0:运行中 3:已关闭 12:创建失败 14:重装失败
	for _, l := range list {
		if l.BmInfo.Status == 0 {
			runningCount++
		}
		if l.BmInfo.Status == 3 {
			closedCount++
		}
		if l.BmInfo.Status == 12 {
			installFailedCount++
		}
		if l.BmInfo.Status == 14 {
			reinstallFailedCount++
		}
	}

	//实例概览
	//状态值文档 https://wiki.op.ksyun.com/pages/viewpage.action?pageId=180181587
	instanceOverview := make([]bm.OverView, 0)
	total := bm.OverView{
		Name:   "总数量",
		Code:   "TotalCount",
		Status: "",
		Value:  len(list),
	}
	running := bm.OverView{
		Name:   "运行中",
		Code:   "RunningCount",
		Status: 0,
		Value:  runningCount,
	}
	closed := bm.OverView{
		Name:   "已关闭",
		Code:   "ClosedCount",
		Status: 3,
		Value:  closedCount,
	}
	installFailed := bm.OverView{
		Name:   "创建失败",
		Code:   "InstallFailedCount",
		Status: 12,
		Value:  installFailedCount,
	}
	reinstallFailed := bm.OverView{
		Name:   "重装失败",
		Code:   "ReinstallFailedCount",
		Status: 14,
		Value:  reinstallFailedCount,
	}
	instanceOverview = append(instanceOverview, total, running, closed, installFailed, reinstallFailed)

	//eg :计算效能型:10
	cpuTypeCountMap := make(map[string]int)
	gpuTypeCountMap := make(map[string]int)
	//cn-shanghai-2a:10
	azCountMap := make(map[string]int)

	cpuList := make([]bmtask.BmAll, 0)
	gpuList := make([]bmtask.BmAll, 0)
	for _, l := range list {
		if l.BmType.Gpu != "" {
			gpuList = append(gpuList, l)
			if _, ok := gpuTypeCountMap[l.BmType.HostName]; !ok {
				gpuTypeCountMap[l.BmType.HostName] = 1
			} else {
				gpuTypeCountMap[l.BmType.HostName] += 1
			}

		} else {
			if l.BmType.HostName != "" {
				cpuList = append(cpuList, l)
				if _, ok := cpuTypeCountMap[l.BmType.HostName]; !ok {
					cpuTypeCountMap[l.BmType.HostName] = 1
				} else {
					cpuTypeCountMap[l.BmType.HostName] += 1
				}
			}
		}

		if _, ok := azCountMap[l.AvailabilityZone]; !ok {
			azCountMap[l.AvailabilityZone] = 1
		} else {
			azCountMap[l.AvailabilityZone] += 1
		}
	}

	//CPU
	cpuOverviewData := bm.OverviewSlot{
		Info: bm.OverviewSlotInfo{
			Name:     "总数",
			Value:    len(cpuList),
			UnitType: "number",
			Unit:     "个",
		},
		//Values: []bm.OverviewSlotValue{
		//	{
		//		Code:     "1",
		//		Name:     "计算效能型",
		//		Value:    5,
		//		Unit:     "",
		//		UnitType: "number",
		//	},
		//	{
		//		Code:     "2",
		//		Name:     "标准计算存储II型",
		//		Value:    5,
		//		Unit:     "",
		//		UnitType: "number",
		//	},
		//},
	}
	cpuTypeValues := make([]bm.OverviewSlotValue, 0)
	for k, v := range cpuTypeCountMap {
		cpuTypeValues = append(cpuTypeValues, bm.OverviewSlotValue{
			Code:     k,
			Name:     k,
			Value:    v,
			Unit:     "个",
			UnitType: "number",
		})
	}
	cpuOverviewData.Values = cpuTypeValues

	//GPU
	gpuOverviewData := bm.OverviewSlot{
		Info: bm.OverviewSlotInfo{
			Name:     "总数",
			Value:    len(gpuList),
			UnitType: "number",
			Unit:     "个",
		},
		//Values: []bm.OverviewSlotValue{
		//	{
		//		Code:     "1",
		//		Name:     "GPU物理实例效能型",
		//		Value:    5,
		//		Unit:     "",
		//		UnitType: "number",
		//	},
		//	{
		//		Code:     "2",
		//		Name:     "训练I型",
		//		Value:    5,
		//		Unit:     "",
		//		UnitType: "number",
		//	},
		//},
	}

	gpuTypeValues := make([]bm.OverviewSlotValue, 0)
	for k, v := range gpuTypeCountMap {
		gpuTypeValues = append(gpuTypeValues, bm.OverviewSlotValue{
			Code:     k,
			Name:     k,
			Value:    v,
			Unit:     "个",
			UnitType: "number",
		})
	}
	gpuOverviewData.Values = gpuTypeValues

	//实例分布概览
	distributedOverview := bm.OverviewSlot{
		Info: bm.OverviewSlotInfo{
			Name:     "裸金属分布概览",
			Value:    len(list),
			UnitType: "number",
			Unit:     "个",
		},
	}

	for k, v := range azCountMap {
		distributedOverview.Values = append(distributedOverview.Values, bm.OverviewSlotValue{
			Code:     k,
			Name:     azCodeMap[k].RegionName + azCodeMap[k].AzName,
			Unit:     "",
			UnitType: "number",
			Value:    v,
		})
	}

	return bm.OverviewRsp{
		InstanceOverview: instanceOverview,
		CPUOverview:      cpuOverviewData,
		GPUOverview:      gpuOverviewData,
		Distribution:     distributedOverview,
	}, nil
}

func divide(a, b int) float64 {
	if b == 0 {
		return 0
	}
	num, _ := strconv.ParseFloat(fmt.Sprintf("%.2f", float64(a)/float64(b)), 64) // 保留2位小数
	return num
}

func (s Service) GetBmResourceList(params bm.ListReq) (bm.ListRsp, error) {
	//fetch
	dataList, err := getList()
	if err != nil {
		return bm.ListRsp{}, err
	}
	//filter
	dataList = filter(params, dataList)
	//sort 时间倒序
	sort.Slice(dataList, func(i, j int) bool {
		return dataList[i].CreateTime > dataList[j].CreateTime
	})
	//page
	total := len(dataList)
	offset := (params.PageNo - 1) * params.PageSize
	limit := offset + params.PageSize

	if offset > total {
		return bm.ListRsp{}, errors.New("pageNo. is too large")
	}
	if limit > total {
		limit = total
	}
	dataList = dataList[offset:limit]

	rsp := bm.ListRsp{
		TotalCount: total,
		PageNo:     params.PageNo,
		PageSize:   params.PageSize,
		DataList:   dataList,
	}
	return rsp, nil
}

func filter(params bm.ListReq, bmlist []bm.ListInfo) []bm.ListInfo {

	isFilter := params.Region != "" ||
		len(params.Id) > 0 || len(params.InstanceStates) > 0 || len(params.InstanceType) > 0 || len(params.Az) > 0 ||
		len(params.TenantId) > 0 || len(params.TenantName) > 0 || len(params.ProjectName) > 0 ||
		params.SearchType != ""
	if !isFilter {
		return bmlist
	}

	filterList := make([]bm.ListInfo, 0)
	for _, v := range bmlist {

		if params.Region != "" {
			if v.Region != params.Region {
				continue
			}
		}

		if len(params.Id) > 0 {
			matchNum := 0
			for _, id := range params.Id {
				if v.Id == id {
					matchNum++
				}
			}
			if matchNum < 1 {
				continue
			}
		}

		if len(params.InstanceStates) > 0 {
			matchNum := 0
			for _, state := range params.InstanceStates {
				if v.InstanceStates == state {
					matchNum++
				}
			}
			if matchNum < 1 {
				continue
			}
		}

		if len(params.InstanceType) > 0 {
			matchNum := 0
			for _, it := range params.InstanceType {
				if v.InstanceType == it {
					matchNum++
				}
			}
			if matchNum < 1 {
				continue
			}
		}

		if len(params.Az) > 0 {
			matchNum := 0
			for _, az := range params.Az {
				if v.Az == az {
					matchNum++
				}
			}
			if matchNum < 1 {
				continue
			}
		}

		if len(params.TenantId) > 0 {
			matchNum := 0
			for _, ti := range params.TenantId {
				if v.TenantId == ti {
					matchNum++
				}
			}
			if matchNum < 1 {
				continue
			}
		}

		if len(params.TenantName) > 0 {
			matchNum := 0
			for _, tn := range params.TenantName {
				if v.TenantName == tn {
					matchNum++
				}
			}
			if matchNum < 1 {
				continue
			}
		}

		if len(params.ProjectName) > 0 {
			matchNum := 0
			for _, pn := range params.ProjectName {
				if v.ProjectName == pn {
					matchNum++
				}
			}
			if matchNum < 1 {
				continue
			}
		}

		//SearchType  string `json:"searchType"`  // 搜索类型 (实例名称 name/实例ID id)
		if params.SearchType != "" {
			switch params.SearchType {
			case "name":
				if !strings.Contains(v.Name, params.SearchValue) {
					continue
				}
			case "id":
				if !strings.Contains(v.Id, params.SearchValue) {
					continue
				}

			}
		}
		if v.InstanceType != "" {
			filterList = append(filterList, v)
		}
	}
	return filterList
}

func getList() ([]bm.ListInfo, error) {
	bmList, err := getbmListFromCache()
	if err != nil {
		return nil, err
	}

	dataList := []bm.ListInfo{}
	azCodeAggregateMap, err := basicdao.GetAzCodeAggregateMap(basicdao.Az{})
	if err != nil {
		return nil, err
	}

	for _, b := range bmList {
		userId := strconv.FormatInt(b.UserId, 10)
		az := azCodeAggregateMap[b.AvailabilityZone]
		rspInfo := bm.ListInfo{
			BmConf:           parseBmConf(b.BmType),
			Id:               b.Uuid,
			Name:             b.BmName,
			InstanceStates:   strconv.FormatInt(int64(b.BmInfo.Status), 10),
			InstanceType:     b.HostName,
			SN:               b.BmSn,
			Region:           b.Region,
			RegionName:       "上海二区",
			Az:               az.AzCode,
			AzName:           az.AzName,
			TenantId:         userId,
			TenantName:       taskcommen.GetUserNameByUserId(userId),
			ProjectName:      "默认项目",
			VpcName:          "",
			IntranetIP:       "",
			NetworkIP:        "",
			Bound:            b.Bm.Bond,
			LineType:         "",
			AlarmNum:         0,
			CreateTime:       b.Bm.CreateTime.Format("2006-01-02 15:04:05"),
			ResourcePoolName: "PGW-BM", //PGW-BM 与 PGW-BGP-BM 区分，待确认
		}
		if rspInfo.InstanceType != "" {
			dataList = append(dataList, rspInfo)
		}
	}
	return dataList, nil
}

func (s Service) GetListOptionalCondition() (map[string][]interface{}, error) {

	list, err := getList()
	if err != nil {
		return nil, err
	}
	stateSet := collection.NewSet()
	instanceTypeSet := collection.NewSet()
	azSet := collection.NewSet()
	tenantIdsSet := collection.NewSet()
	tenantNamesSet := collection.NewSet()
	projectNamesSet := collection.NewSet()

	for _, v := range list {
		stateSet.Add(v.InstanceStates)
		instanceTypeSet.Add(v.InstanceType)
		azSet.Add(v.Az)
		tenantIdsSet.Add(v.TenantId)
		tenantNamesSet.Add(v.TenantName)
		projectNamesSet.Add(v.ProjectName)
	}

	result := map[string][]interface{}{
		"instanceStates":   stateSet.Keys(),
		"instanceType":     instanceTypeSet.Keys(),
		"az":               azSet.Keys(),
		"tenantId":         tenantIdsSet.Keys(),
		"tenantName":       tenantNamesSet.Keys(),
		"projectName":      projectNamesSet.Keys(),
		"resourcePoolName": []interface{}{"PGW-BM"},
	}
	return result, nil
}

func (s Service) GetBmDetail(params bm.DetailReq) (bm.DetailRsp, error) {
	info, err := getBm(params.Id)
	if err != nil {
		return bm.DetailRsp{}, err
	}
	userId := strconv.FormatInt(info.UserId, 10)
	az, err := basicdao.QueryAzByAzCodeAggregate(info.AvailabilityZone)
	if err != nil {
		klog.Error()
	}
	rsp := bm.DetailRsp{
		Id:             info.Uuid,
		Name:           info.BmName,
		InstanceStates: strconv.FormatInt(int64(info.BmInfo.Status), 10),
		InstanceType:   info.HostType,
		Region:         info.Region,
		RegionName:     "上海二区",
		Az:             az.AzCode,
		AzName:         az.AzName,
		TenantId:       userId,
		TenantName:     taskcommen.GetUserNameByUserId(userId),
		ProjectName:    "默认项目",
		CreateTime:     info.BmInfo.CreateTime.String(),
		BmConf:         parseBmConf(info.BmType),
		Eip:            "",
		EipBandwidth:   "",
		IntranetIP:     "",
		NetworkIP:      "",
		Bound:          info.BmInfo.Bond,
		LineType:       "",
		SN:             info.Sn,
		HostName:       "",
		VpcName:        "",
		SubNet:         "",
		Attribute:      info.BondAttribute,
		SecurityGroup:  "",
		Mac:            info.Mac,
		RaidType:       info.Raid,
		Cabinet:        info.Bm.CabinetUuid,
		Rack:           info.Rack,
		ImageId:        info.BmInfo.ImageId,
		OsName:         "",
	}

	return rsp, nil
}

func getbmListFromCache() (bmList []bmtask.BmAll, err error) {
	ctx, celf := context.WithTimeout(context.Background(), 5*time.Second)
	defer celf()
	bmInstanceMap, err := gredis.HGetAll(ctx, gredis.BMCloudHashKey)
	if err != nil {
		return
	}
	var resultList []string
	for _, bmStr := range bmInstanceMap {
		resultList = append(resultList, bmStr)
	}
	rsStr := "[" + strings.Join(resultList, ",") + "]"
	err = json.Unmarshal([]byte(rsStr), &bmList)
	if err != nil {
		klog.Error("bmInstanceMap Unmarshal failure:", err.Error())
		return
	}
	return
}

func getBm(uuid string) (bm bmtask.BmAll, err error) {
	hashKey := gredis.BMCloudHashKey
	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
	defer cancel()
	infoStr, err := gredis.HGet(ctx, hashKey, uuid)
	if err != nil {
		return
	}
	err = json.Unmarshal([]byte(infoStr), &bm)
	if err != nil {
		return
	}
	return
}

func parseBmConf(bmType bmtask.BmType) bm.BmConf {
	return bm.BmConf{
		Cpu:    bmType.Cpu + " " + "(" + strconv.Itoa(bmType.CpuCount) + "核" + strconv.Itoa(bmType.CpuCorecount) + "线程" + ")",
		Memory: bmType.Memory,
		Storage: bmType.SystemDiskSize + "*" + strconv.Itoa(bmType.SystemDiskCount) + "(" + bmType.SystemDiskType + ")" +
			" " + bmType.DataDiskSize + "*" + strconv.Itoa(bmType.DataDiskCount) + "(" + bmType.DataDiskType + ")",
	}
}

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/pkg/service/objectstorageBucket/objectstorage_bucket.go
```golang
package objectstorageBucket

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/pkg/service/nat/nat.go
```golang
package nat

import (
	"context"
	"encoding/json"
	"errors"
	"luban-cmdb-api/pkg/dao/basic"
	"luban-cmdb-api/pkg/gredis"
	"luban-cmdb-api/pkg/models/nat"
	"luban-cmdb-api/pkg/utils/collection"
	"sort"
	"strings"
	"time"

	"k8s.io/klog/v2"
)

type Service struct {
}

func (s Service) NatipList(instanceId string, req nat.NatPartListReq) (*nat.NatPartListRsp, error) {

	hashKey := gredis.NATHashKey
	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
	defer cancel()
	natInfoStr, err := gredis.HGet(ctx, hashKey, instanceId)
	if err != nil {
		return nil, err
	}
	var natInfo nat.NatInfo
	err = json.Unmarshal([]byte(natInfoStr), &natInfo)
	if err != nil {
		return nil, err
	}

	natIpList := natInfo.Natipallocations
	//page
	total := len(natIpList)
	offset := (req.PageNo - 1) * req.PageSize
	limit := offset + req.PageSize
	if offset > total {
		return nil, errors.New("pageNo. is too large")
	}
	if limit > total {
		limit = total
	}
	natIpList = natIpList[offset:limit]

	return &nat.NatPartListRsp{
		TotalCount: total,
		PageNo:     req.PageSize,
		PageSize:   req.PageSize,
		DataList:   natIpList,
	}, nil
}
func (s Service) SnatipList(instanceId string, req nat.NatPartListReq) (*nat.NatPartListRsp, error) {
	hashKey := gredis.NATHashKey
	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
	defer cancel()
	natInfoStr, err := gredis.HGet(ctx, hashKey, instanceId)
	if err != nil {
		return nil, err
	}
	var natInfo nat.NatInfo
	err = json.Unmarshal([]byte(natInfoStr), &natInfo)
	if err != nil {
		return nil, err
	}

	snatList := natInfo.Snats
	//page
	total := len(snatList)
	offset := (req.PageNo - 1) * req.PageSize
	limit := offset + req.PageSize
	if offset > total {
		return nil, errors.New("pageNo. is too large")
	}
	if limit > total {
		limit = total
	}
	snatList = snatList[offset:limit]

	return &nat.NatPartListRsp{
		TotalCount: total,
		PageNo:     req.PageSize,
		PageSize:   req.PageSize,
		DataList:   snatList,
	}, nil
}

func (s Service) DnatipList(instanceId string, req nat.NatPartListReq) (*nat.NatPartListRsp, error) {

	hashKey := gredis.NATHashKey
	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
	defer cancel()
	natInfoStr, err := gredis.HGet(ctx, hashKey, instanceId)
	if err != nil {
		return nil, err
	}
	var natInfo nat.NatInfo
	err = json.Unmarshal([]byte(natInfoStr), &natInfo)
	if err != nil {
		return nil, err
	}

	dnatipList := natInfo.Dnatrules
	//page
	total := len(dnatipList)
	offset := (req.PageNo - 1) * req.PageSize
	limit := offset + req.PageSize
	if offset > total {
		return nil, errors.New("pageNo. is too large")
	}
	if limit > total {
		limit = total
	}
	dnatipList = dnatipList[offset:limit]

	return &nat.NatPartListRsp{
		TotalCount: total,
		PageNo:     req.PageSize,
		PageSize:   req.PageSize,
		DataList:   dnatipList,
	}, nil
}

func (s Service) ServeLimitList(instanceId string, req nat.NatPartListReq) (*nat.NatPartListRsp, error) {
	hashKey := gredis.NATHashKey
	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
	defer cancel()
	natInfoStr, err := gredis.HGet(ctx, hashKey, instanceId)
	if err != nil {
		return nil, err
	}
	var natInfo nat.NatInfo
	err = json.Unmarshal([]byte(natInfoStr), &natInfo)
	if err != nil {
		return nil, err
	}

	data := natInfo.ServerLimits
	var limitList []nat.ServerLimit
	//filter
	if req.EgressType != nil {
		for _, limit := range data {
			if limit.EgressType != *req.EgressType {
				continue
			}
			limitList = append(limitList, limit)
		}
	} else {
		limitList = data
	}

	//page
	total := len(limitList)
	offset := (req.PageNo - 1) * req.PageSize
	limit := offset + req.PageSize
	if offset > total {
		return nil, errors.New("pageNo. is too large")
	}
	if limit > total {
		limit = total
	}
	limitList = limitList[offset:limit]

	return &nat.NatPartListRsp{
		TotalCount: total,
		PageNo:     req.PageSize,
		PageSize:   req.PageSize,
		DataList:   limitList,
	}, nil
}

func (s Service) NatDetail(instanceId string) (nat.NatInfo, error) {
	hashKey := gredis.NATHashKey
	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
	defer cancel()
	natInfoStr, err := gredis.HGet(ctx, hashKey, instanceId)
	if err != nil {
		return nat.NatInfo{}, err
	}
	var natInfo nat.NatInfo
	err = json.Unmarshal([]byte(natInfoStr), &natInfo)
	if err != nil {
		return nat.NatInfo{}, err
	}
	return natInfo, err
}

func (s Service) GetNatOverview(region string) (nat.NatOverviewRsp, error) {
	//queryRegion := req.Region
	lblist, err := GetNatListFromCache()
	if err != nil {
		return nat.NatOverviewRsp{}, err
	}

	//TODO 暂未支持多region
	regionCode2Map, err := basic.QueryAllRegionCode2Map()
	if err != nil {
		klog.Errorf("QueryAllRegionCode2Map error: %v", err)
		return nat.NatOverviewRsp{}, err
	}
	var regionName string
	rm, ok := regionCode2Map["cn-shanghai-2"]
	if ok {
		regionName = rm.RegionName
	}

	totalCount := len(lblist)
	publicCount := 0
	shanghaiCount := 0
	for _, v := range lblist {
		if v.NatType == "public" {
			publicCount++
		}

		if v.Region == "cn-shanghai-2" {
			shanghaiCount++
		}
	}

	instanceOverview := make([]nat.OverView, 0)
	total := nat.OverView{
		Name:   "总数量",
		Code:   "TotalCount",
		Status: "",
		Value:  totalCount,
	}

	public := nat.OverView{
		Name:   "公网",
		Code:   "PublicCount",
		Status: "public",
		Value:  publicCount,
	}

	private := nat.OverView{
		Name:   "金山云内网",
		Code:   "PrivateCount",
		Status: "private",
		Value:  totalCount - publicCount,
	}
	instanceOverview = append(instanceOverview, total, public, private)

	shanghai := nat.DistributedOverView{
		Name:   regionName,
		Region: "cn-shanghai-2",
		Az:     "",
		Distributed: []nat.OverView{
			{
				Name:   "NAT",
				Code:   "cn-shanghai-2",
				Status: "",
				Value:  shanghaiCount,
			},
		},
	}
	//shanghai2a := nat.DistributedOverView{
	//	Name:   "上海二区可用区A",
	//	Region: "cn-shanghai-2",
	//	Az:     "cn-shanghai-2a",
	//	Distributed: []nat.OverView{
	//		{
	//			Name:   "NAT",
	//			Code:   "cn-shanghai-2a",
	//			Status: "",
	//			Value:  shanghaiCount,
	//		},
	//	},
	//}
	//shanghai2b := nat.DistributedOverView{
	//	Name:   "上海二区可用区B",
	//	Region: "cn-shanghai-2",
	//	Az:     "cn-shanghai-2b",
	//	Distributed: []nat.OverView{
	//		{
	//			Name:   "NAT",
	//			Code:   "cn-shanghai-2b",
	//			Status: "",
	//			Value:  0,
	//		},
	//	},
	//}
	distributedOverview := []nat.DistributedOverView{shanghai}

	return nat.NatOverviewRsp{
		//TypeOverview:        typeOverviewData,
		DistributedOverview: distributedOverview,
		InstanceOverview:    instanceOverview,
	}, nil
}

func (s Service) GetListOptionalCondition() (map[string][]interface{}, error) {

	natlist, err := GetNatListFromCache()
	if err != nil {
		return nil, err
	}

	scopeSet := collection.NewSet()
	natTypeSet := collection.NewSet()
	vpcNamesSet := collection.NewSet()
	tenantIdsSet := collection.NewSet()
	tenantNamesSet := collection.NewSet()
	projectNamesSet := collection.NewSet()
	for _, v := range natlist {
		scopeSet.Add(v.Scope)
		natTypeSet.Add(v.NatType)
		vpcNamesSet.Add(v.VpcName)
		tenantIdsSet.Add(v.TenantId)
		tenantNamesSet.Add(v.TenantName)
		projectNamesSet.Add(v.ProjectName)
	}

	////单选
	//Scope            []string `json:"scope"`            //作用范围  [classic,custom] 所属的vpc,绑定的子网
	//NatType          []string `json:"natType"`          //类型 ['public', 'private']
	//
	////多选
	//VpcName     []string `json:"vpcNames"`     //所属VPC
	//TenantId    []string `json:"tenantId"`    //租户ID
	//TenantName  []string `json:"tenantName"`  //租户名称
	//ProjectName []string `json:"projectName"` //所属项目名称 默认项目

	result := map[string][]interface{}{
		"scope":            []interface{}{"classic", "custom"},
		"natType":          []interface{}{"public", "private"},
		"resourcePoolName": []interface{}{"NAT"},
		"projectName":      projectNamesSet.Keys(),
		"vpcName":          vpcNamesSet.Keys(),
		"tenantId":         tenantIdsSet.Keys(),
		"tenantName":       tenantNamesSet.Keys(),
	}
	return result, nil
}

func (s Service) GetNatResourceList(params nat.GetNatResourceListReq) (nat.GetNatResourceListRsp, error) {
	natlist, err := GetNatListFromCache()
	if err != nil {
		return nat.GetNatResourceListRsp{}, err
	}
	//filter and search
	natlist = filter(params, natlist)

	//sort
	lessFunc := parseOrder(params, natlist)
	sort.Slice(natlist, lessFunc)

	//page
	total := len(natlist)
	offset := (params.PageNo - 1) * params.PageSize
	limit := offset + params.PageSize
	if offset > total {
		return nat.GetNatResourceListRsp{}, errors.New("pageNo. is too large")
	}
	if limit > total {
		limit = total
	}
	if offset < 0 || limit > total {
		klog.Error("pageNo %v, pageSize %v, offset %v, limit %v", params.PageNo, params.PageSize, offset, limit)
		return nat.GetNatResourceListRsp{}, errors.New("page error")
	}
	natlist = natlist[offset:limit]

	return nat.GetNatResourceListRsp{
		TotalCount: total,
		PageNo:     params.PageNo,
		PageSize:   params.PageSize,
		DataList:   natlist,
	}, nil
}

func parseOrder(params nat.GetNatResourceListReq, natlist []nat.NatInfo) func(i int, j int) bool {
	klog.Infof("orderCode %s , orderType %s", params.OrderCode, params.OrderType)
	var lessFunc func(i, j int) bool
	if params.OrderCode == "createTime" {
		if params.OrderType == "ascending" { //正序
			lessFunc = func(i, j int) bool {
				return natlist[i].CreateTime < natlist[j].CreateTime
			}
		}
		if params.OrderType == "descending" { //逆序
			lessFunc = func(i, j int) bool {
				return natlist[i].CreateTime > natlist[j].CreateTime
			}
		}
	}

	if params.OrderCode == "bandwidth" {
		if params.OrderType == "ascending" {
			lessFunc = func(i, j int) bool {
				return natlist[i].Bandwidth < natlist[j].Bandwidth
			}
		}
		if params.OrderType == "descending" {
			lessFunc = func(i, j int) bool {
				return natlist[i].Bandwidth > natlist[j].Bandwidth
			}
		}
	}

	if lessFunc == nil {
		lessFunc = func(i, j int) bool {
			return natlist[i].CreateTime > natlist[j].CreateTime
		}
	}
	return lessFunc
}

func GetNatListFromCache() ([]nat.NatInfo, error) {
	key := gredis.NATSetKey
	//Get Count
	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
	totalCount, err := gredis.ZCard(ctx, key)
	defer cancel()
	if err != nil {
		klog.Error(err)
		return nil, err
	}

	ctx, cancel = context.WithTimeout(context.Background(), 5*time.Second)
	strLbList, err := gredis.ZRange(ctx, key, 0, totalCount)
	defer cancel()
	if err != nil {
		klog.Error(err)
		return nil, err
	}

	natlist := make([]nat.NatInfo, 0, len(strLbList))
	sliceStr := "[" + strings.Join(strLbList, ",") + "]"
	err = json.Unmarshal([]byte(sliceStr), &natlist)
	//klog.Infof("%+v", natlist[0].InstanceId)
	return natlist, nil
}

func filter(params nat.GetNatResourceListReq, natlist []nat.NatInfo) []nat.NatInfo {
	klog.Infof("GetNatResourceListReq : %+v", params)
	isFilter := params.ResourcePoolName != "" || params.Region != "" || params.SearchType != "" ||
		len(params.Scope) > 0 || len(params.NatType) > 0 || //单选
		len(params.VpcName) > 0 || len(params.TenantId) > 0 || len(params.TenantName) > 0 || len(params.ProjectName) > 0 //多选

	filterList := make([]nat.NatInfo, 0)
	if !isFilter {
		return natlist
	}
	for _, v := range natlist {
		if params.ResourcePoolName != "" {
			if v.ResourcePoolName != params.ResourcePoolName {
				continue
			}
		}

		if params.Region != "" {
			if v.Region != params.Region {
				continue
			}
		}

		if len(params.Scope) > 0 {
			matchNum := 0
			for _, Scope := range params.Scope {
				if v.Scope == Scope {
					matchNum++
				}
			}
			if matchNum < 1 {
				continue
			}
		}

		if len(params.NatType) > 0 {
			matchNum := 0
			for _, NatType := range params.NatType {
				if v.NatType == NatType {
					matchNum++
				}
			}
			if matchNum < 1 {
				continue
			}
		}

		if len(params.VpcName) > 0 {
			matchNum := 0
			for _, vpcName := range params.VpcName {
				if v.VpcName == vpcName {
					matchNum++
				}
			}
			if matchNum < 1 {
				continue
			}
		}

		if len(params.TenantId) > 0 {
			matchNum := 0
			for _, tenantId := range params.TenantId {
				if v.TenantId == tenantId {
					matchNum++
				}
			}
			if matchNum < 1 {
				continue
			}
		}

		if len(params.TenantName) > 0 {
			matchNum := 0
			for _, tenantName := range params.TenantName {
				if v.TenantName == tenantName {
					matchNum++
				}
			}
			if matchNum < 1 {
				continue
			}
		}

		if len(params.ProjectName) > 0 {
			matchNum := 0
			for _, projectName := range params.ProjectName {
				if v.ProjectName == projectName {
					matchNum++
				}
			}

			if matchNum < 1 {
				continue
			}
		}

		//search  搜索类型 (实例名称)
		if params.SearchType != "" {
			switch params.SearchType {
			case "instanceName":
				if !strings.Contains(v.InstanceName, params.SearchValue) {
					continue
				}
			}
		}

		filterList = append(filterList, v)
	}
	return filterList
}

func NewService() *Service {
	return &Service{}
}

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/pkg/service/lb/lb.go
```golang
package lb

import (
	"context"
	"encoding/json"
	"errors"
	"luban-cmdb-api/pkg/dao/basic"
	"luban-cmdb-api/pkg/gredis"
	"luban-cmdb-api/pkg/models/lb"
	"luban-cmdb-api/pkg/utils/collection"
	"sort"
	"strings"
	"time"

	"k8s.io/klog/v2"
)

type Service struct {
}

func NewService() *Service {
	return &Service{}
}

func (s Service) LbListenerList(instanceId string, req lb.LbPartListReq) (*lb.LbPartListRsp, error) {
	hashKey := gredis.LBHashKey
	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
	defer cancel()
	lbInfoStr, err := gredis.HGet(ctx, hashKey, instanceId)
	if err != nil {
		return nil, err
	}
	var lbInfo lb.LbInfo
	err = json.Unmarshal([]byte(lbInfoStr), &lbInfo)
	if err != nil {
		return nil, err
	}

	Listeners := lbInfo.Listeners
	//page
	total := len(Listeners)
	offset := (req.PageNo - 1) * req.PageSize
	limit := offset + req.PageSize
	if offset > total {
		return nil, errors.New("pageNo. is too large")
	}
	if limit > total {
		limit = total
	}
	Listeners = Listeners[offset:limit]

	return &lb.LbPartListRsp{
		TotalCount: total,
		PageNo:     req.PageSize,
		PageSize:   req.PageSize,
		DataList:   Listeners,
	}, nil
}

func (s Service) LbDetail(instanceId string) (lb.LbInfo, error) {
	hashKey := gredis.LBHashKey
	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
	defer cancel()
	lbInfoStr, err := gredis.HGet(ctx, hashKey, instanceId)
	if err != nil {
		return lb.LbInfo{}, err
	}
	var lbInfo lb.LbInfo
	err = json.Unmarshal([]byte(lbInfoStr), &lbInfo)
	if err != nil {
		return lb.LbInfo{}, err
	}

	return lbInfo, err
}

func (s Service) GetLbOverview(req lb.LbOverviewReq) (lb.LbOverviewRsp, error) {
	//queryRegion := req.Region
	lblist, err := getLbListFromCache()
	if err != nil {
		return lb.LbOverviewRsp{}, err
	}

	//TODO 暂未支持多region
	regionCode2Map, err := basic.QueryAllRegionCode2Map()
	if err != nil {
		klog.Errorf("QueryAllRegionCode2Map error: %v", err)
		return lb.LbOverviewRsp{}, err
	}
	var regionName string
	region, ok := regionCode2Map["cn-shanghai-2"]
	if ok {
		regionName = region.RegionName
	}

	runningCount := 0
	applicationTypeCount := 0
	defaultTypeCount := 0
	shanghaiCount := 0
	for _, v := range lblist {
		if v.State == "active" {
			runningCount++
		}
		if v.InstanceType == "default" {
			defaultTypeCount++
		}
		if v.InstanceType == "application" {
			applicationTypeCount++
		}
		if v.Region == "cn-shanghai-2" {
			shanghaiCount++
		}
	}

	//实例概览
	instanceOverview := make([]lb.OverView, 0)
	total := lb.OverView{
		Name:   "总数量",
		Code:   "TotalCount",
		Status: "",
		Value:  len(lblist),
	}

	running := lb.OverView{
		Name:   "运行中",
		Code:   "RunningCount",
		Status: "",
		Value:  runningCount,
	}

	closed := lb.OverView{
		Name:   "已关闭",
		Code:   "ClosedCount",
		Status: "",
		Value:  len(lblist) - runningCount,
	}
	instanceOverview = append(instanceOverview, total, running, closed)

	//实例类型概览
	typeOverviewData := lb.OverviewSlot{
		Info: lb.SlotInfo{
			Name:     "总数",
			Value:    len(lblist),
			UnitType: "number",
			Unit:     "个",
		},
		Values: []lb.SlotValue{
			{
				Code:     "application",
				Name:     "应用型",
				Value:    applicationTypeCount,
				Unit:     "",
				UnitType: "number",
				Kind:     "",
			},
			{
				Code:     "default",
				Name:     "经典型",
				Value:    defaultTypeCount,
				Unit:     "",
				UnitType: "number",
				Kind:     "",
			},
		},
	}

	//实例分布概览
	distributedOverview := lb.OverviewSlot{
		Info: lb.SlotInfo{
			Name:     "实例分布概览",
			Value:    0,
			UnitType: "number",
			Unit:     "个",
		},
		Values: []lb.SlotValue{
			{
				Code:     "cn-shanghai-2a",
				Name:     regionName,
				Value:    shanghaiCount,
				Unit:     "",
				UnitType: "number",
				Kind:     "",
			},
			//{
			//	Code:     "cn-shanghai-2b",
			//	Name:     "上海二区可用区B",
			//	Value:    0,
			//	Unit:     "",
			//	UnitType: "number",
			//	Kind:     "",
			//},
		},
	}

	return lb.LbOverviewRsp{
		TypeOverview:        []lb.OverviewSlot{typeOverviewData},
		DistributedOverview: []lb.OverviewSlot{distributedOverview},
		InstanceOverview:    instanceOverview,
	}, nil
}

func (s Service) GetListOptionalCondition() (map[string][]interface{}, error) {

	lbList, err := getLbListFromCache()
	if err != nil {
		return nil, err
	}

	stateSet := collection.NewSet()
	instanceTypeSet := collection.NewSet()
	netTypeSet := collection.NewSet()
	tenantIdsSet := collection.NewSet()
	tenantNamesSet := collection.NewSet()
	projectNamesSet := collection.NewSet()
	lineTypeSet := collection.NewSet()
	//resourcePoolNameSet := collection.NewSet()
	for _, v := range lbList {
		stateSet.Add(v.State)
		instanceTypeSet.Add(v.InstanceType)
		netTypeSet.Add(v.NetType)
		tenantIdsSet.Add(v.TenantId)
		tenantNamesSet.Add(v.TenantName)
		projectNamesSet.Add(v.ProjectName)
		lineTypeSet.Add(v.LineType)
		//resourcePoolNameSet.Add(v.ResourcePoolName)
	}

	result := map[string][]interface{}{
		"state":            stateSet.Keys(),
		"instanceType":     instanceTypeSet.Keys(),
		"netType":          netTypeSet.Keys(),
		"tenantId":         tenantIdsSet.Keys(),
		"tenantName":       tenantNamesSet.Keys(),
		"projectName":      projectNamesSet.Keys(),
		"lineType":         lineTypeSet.Keys(),
		"resourcePoolName": []interface{}{"XGW-LB", "KGW-LB", "Tengine-LB"},
	}
	return result, nil
}

func (s Service) GetLbResourceList(params lb.GetLbResourceListReq) (lb.GetLbResourceListRsp, error) {
	lblist, err := getLbListFromCache()
	if err != nil {
		return lb.GetLbResourceListRsp{}, err
	}

	klog.Infof("GetLbResourceListReq : %+v", params)

	lblist = filter(params, lblist)
	//sort 时间倒序
	lessFunc := parseOrder(params, lblist)
	sort.Slice(lblist, lessFunc)

	//page
	total := len(lblist)
	offset := (params.PageNo - 1) * params.PageSize
	limit := offset + params.PageSize

	if offset > total {
		return lb.GetLbResourceListRsp{}, errors.New("pageNo. is too large")
	}
	if limit > total {
		limit = total
	}
	lblist = lblist[offset:limit]

	return lb.GetLbResourceListRsp{
		TotalCount: total,
		PageNo:     params.PageNo,
		PageSize:   params.PageSize,
		DataList:   lblist,
	}, nil
}

func parseOrder(params lb.GetLbResourceListReq, lblist []lb.LbInfo) func(i int, j int) bool {
	var lessFunc func(i, j int) bool
	if params.OrderCode == "createTime" {
		if params.OrderType == "ascending" { //正序
			lessFunc = func(i, j int) bool {
				return lblist[i].CreateTime < lblist[j].CreateTime
			}
		}
		if params.OrderType == "descending" { //逆序
			lessFunc = func(i, j int) bool {
				return lblist[i].CreateTime > lblist[j].CreateTime
			}
		}
	}

	//默认按照创建时间倒序
	if lessFunc == nil {
		lessFunc = func(i, j int) bool {
			return lblist[i].CreateTime > lblist[j].CreateTime
		}
	}
	return lessFunc
}

func filter(params lb.GetLbResourceListReq, lblist []lb.LbInfo) []lb.LbInfo {

	isFilter := params.ResourcePoolName != "" || params.Region != "" ||
		len(params.State) > 0 || len(params.InstanceType) > 0 || len(params.NetType) > 0 ||
		len(params.TenantId) > 0 || len(params.TenantName) > 0 || len(params.ProjectName) > 0 || len(params.LineType) > 0 ||
		params.SearchType != ""
	if !isFilter {
		return lblist
	}

	filterList := make([]lb.LbInfo, 0)
	for _, v := range lblist {
		if params.ResourcePoolName != "" {
			if v.ResourcePoolName != params.ResourcePoolName {
				continue
			}
		}

		if params.Region != "" {
			if v.Region != params.Region {
				continue
			}
		}

		//State        []string `json:"state"` //状态 开启 已停止 [active,stop]
		//InstanceType []string `json:"instanceType"`//实例类型 ['default', 'application']  经典型， 应用型
		//NetType      []string `json:"netType"`//网络类型  公网 私网 [public,private]
		//TenantId     []string `json:"tenantId"`
		//TenantName   []string `json:"tenantName"`
		//ProjectName  []string `json:"projectName"`
		//LineType     []string `json:"lineType"`//线路类型 [bgp,private]
		if len(params.State) > 0 {
			matchNum := 0
			for _, state := range params.State {
				if v.State == state {
					matchNum++
				}
			}
			if matchNum < 1 {
				continue
			}
		}

		if len(params.InstanceType) > 0 {
			matchNum := 0
			for _, it := range params.InstanceType {
				if v.InstanceType == it {
					matchNum++
				}
			}
			if matchNum < 1 {
				continue
			}
		}

		if len(params.NetType) > 0 {
			matchNum := 0
			for _, nt := range params.NetType {
				if v.NetType == nt {
					matchNum++
				}
			}
			if matchNum < 1 {
				continue
			}
		}

		if len(params.TenantId) > 0 {
			matchNum := 0
			for _, ti := range params.TenantId {
				if v.TenantId == ti {
					matchNum++
				}
			}
			if matchNum < 1 {
				continue
			}
		}

		if len(params.TenantName) > 0 {
			matchNum := 0
			for _, tn := range params.TenantName {
				if v.TenantName == tn {
					matchNum++
				}
			}
			if matchNum < 1 {
				continue
			}
		}

		if len(params.ProjectName) > 0 {
			matchNum := 0
			for _, pn := range params.ProjectName {
				if v.ProjectName == pn {
					matchNum++
				}
			}
			if matchNum < 1 {
				continue
			}
		}

		if len(params.LineType) > 0 {
			matchNum := 0
			for _, lt := range params.LineType {
				if v.LineType == lt {
					matchNum++
				}
			}
			if matchNum < 1 {
				continue
			}
		}

		//search  搜索类型 (实例名称/后端服务ID/后端服务内网IP)
		if params.SearchType != "" {
			switch params.SearchType {
			case "instanceName":
				if !strings.Contains(v.InstanceName, params.SearchValue) {
					continue
				}
				//case "serverId":
				//	if strings.Contains(v.TenantId, params.SearchValue) {
				//		searchList = append(searchList, v)
				//	}
				//case "serverIp":
				//	if strings.Contains(v.BoundId, params.SearchValue) {
				//		searchList = append(searchList, v)
				//	}
			}
		}
		filterList = append(filterList, v)
	}
	return filterList
}

func getLbListFromCache() ([]lb.LbInfo, error) {
	key := gredis.LBSetKey
	//Get Count
	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
	totalCount, err := gredis.ZCard(ctx, key)
	defer cancel()
	if err != nil {
		klog.Error(err)
		return nil, err
	}

	ctx, cancel = context.WithTimeout(context.Background(), 5*time.Second)
	strLbList, err := gredis.ZRange(ctx, key, 0, totalCount)
	defer cancel()
	if err != nil {
		klog.Error(err)
		return nil, err
	}

	lblist := make([]lb.LbInfo, 0, len(strLbList))
	lbSliceStr := "[" + strings.Join(strLbList, ",") + "]"
	err = json.Unmarshal([]byte(lbSliceStr), &lblist)
	return lblist, nil
}

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/pkg/service/networkPool/networkPool.go
```golang
package networkPool

import (
	"context"
	"database/sql"
	"encoding/json"
	"fmt"
	"luban-cmdb-api/pkg/dao"
	serverDao "luban-cmdb-api/pkg/dao/server"
	"luban-cmdb-api/pkg/gredis"
	eipModel "luban-cmdb-api/pkg/models/eip"
	"luban-cmdb-api/pkg/models/netPoolModel"
	"luban-cmdb-api/pkg/models/server"
	"luban-cmdb-api/pkg/service"
	"luban-cmdb-api/pkg/service/eip"
	"sort"
	"strings"
	"time"

	"k8s.io/klog/v2"
)

var NeutronApiUrl = "http://neutron.galaxy.cloud:9696/v2.0"

type HttpClient interface {
	SimpleHttpGet(url string) ([]byte, error)
}

type Service struct {
	HttpClient HttpClient
}

func NewService() *Service {
	return &Service{
		HttpClient: &service.SimpleHttpClient{},
	}
}

func (s Service) GetNetworkPoolResourceList(params netPoolModel.NetWorkResourceQuery) (netList netPoolModel.NetWorkList, err error) {
	var (
		ctx        context.Context
		celf       context.CancelFunc
		rs4Keys    string
		keys       []string
		filterKeys []string
		rs4Pools   []interface{}
	)
	ctx, celf = context.WithTimeout(context.Background(), 5*time.Second)
	rs4Keys, err = gredis.HGet(ctx, gredis.NetWorkTypeMapKey, params.ResourceType)
	celf()
	if err != nil {
		klog.Error(fmt.Sprintf("redis read data from hash:%s field:%s error. err: %+v", gredis.NetWorkTypeMapKey, params.ResourceType, err))
		return
	}
	err = json.Unmarshal([]byte(rs4Keys), &keys)
	if err != nil {
		klog.Error(fmt.Sprintf("unmarshal %s to []string error. err: %+v", rs4Keys, err))
		return
	}
	if params.RegionCode != "" {
		for _, key := range keys {
			if strings.Contains(key, params.RegionCode) {
				filterKeys = append(filterKeys, key)
			}
		}
		keys = filterKeys
		filterKeys = make([]string, 0)
	}
	if len(params.PoolTypes) > 0 {
		for _, key := range keys {
			for _, poolType := range params.PoolTypes {
				if strings.Contains(key, poolType) {
					filterKeys = append(filterKeys, key)
				}
			}
		}
		keys = filterKeys
		filterKeys = make([]string, 0)
	}
	if len(keys) == 0 {
		return
	}
	ctx, celf = context.WithTimeout(context.Background(), 5*time.Second)
	rs4Pools, err = gredis.HMGet(ctx, gredis.NetWorkPoolKey, keys)
	celf()
	if err != nil {
		klog.Error(fmt.Sprintf("redis read data from hash:%s fields:%+v error. err: %+v", gredis.NetWorkPoolKey, keys, err))
		return
	}
	for _, poolIntfes := range rs4Pools {
		var (
			pool = netPoolModel.NetWorkResource{}
		)
		poolStr, ok := poolIntfes.(string)
		if !ok {
			continue
		}
		err = json.Unmarshal([]byte(poolStr), &pool)
		if err != nil {
			continue
		}
		if params.PoolName != "" && !strings.Contains(pool.PoolName, params.PoolName) {
			continue
		}
		netList = append(netList, pool)
	}
	//默认按照创建时间倒序
	switch params.OrderType {
	case "descending":
		sort.Slice(netList, func(i, j int) bool {
			return netList[i].CreatedAt.After(netList[j].CreatedAt)
		})
	case "ascending":
		sort.Slice(netList, func(i, j int) bool {
			return netList[i].CreatedAt.Before(netList[j].CreatedAt)
		})
	default:
		sort.Slice(netList, func(i, j int) bool {
			return netList[i].CreatedAt.After(netList[j].CreatedAt)
		})
	}

	if params.PageNo > 0 && params.PageSize > 0 {
		offset := (params.PageNo - 1) * params.PageSize
		limit := offset + params.PageSize
		if limit > len(netList) {
			limit = len(netList)
		}
		netList = netList[offset:limit]
	}
	return
}

func (s *Service) GetNetworkPoolOverview(region string) (overview netPoolModel.NetworkPoolOverview, err error) {
	ctx, cancelFunc := context.WithTimeout(context.Background(), time.Second*5)
	defer cancelFunc()
	rs, err := gredis.HGetAll(ctx, gredis.NetWorkPoolKey)
	if err != nil {
		klog.Errorf("GetNetworkPoolOverview err:", err)
		return overview, err
	}
	xgw := netPoolModel.OverviewSlot{
		Info: netPoolModel.OverviewSlotInfo{
			Name:        "XGW集群",
			Description: "提供四层负载均衡、弹性IP服务",
			UnitType:    "number",
			Unit:        "个",
			PoolType:    "XGW",
		},
		Values: []netPoolModel.OverviewSlotValue{
			{Name: "负载均衡4层数量", Type: "LB"},
			{Name: "弹性IP数量", Type: "EIP"},
		},
	}
	tengine := netPoolModel.OverviewSlot{
		Info: netPoolModel.OverviewSlotInfo{
			Name:        "Tengine集群",
			Description: "提供七层负载均衡服务",
			UnitType:    "number",
			Unit:        "个",
			PoolType:    "Tengine",
		},
		Values: []netPoolModel.OverviewSlotValue{
			{Name: "负载均衡7层数量", Type: "LB"},
		},
	}
	kgw := netPoolModel.OverviewSlot{
		Info: netPoolModel.OverviewSlotInfo{
			Name:        "KGW集群",
			Description: "提供OpenStack服务四层负载均衡服务",
			UnitType:    "number",
			Unit:        "个",
			PoolType:    "KGW",
		},
		Values: []netPoolModel.OverviewSlotValue{
			{Name: "负载均衡4层数量", Type: "LB"},
		},
	}
	sgw := netPoolModel.OverviewSlot{
		Info: netPoolModel.OverviewSlotInfo{
			Name:        "SGW集群",
			Description: "提供弹性IP限速服务",
			UnitType:    "number",
			Unit:        "个",
			PoolType:    "SGW",
		},
		Values: []netPoolModel.OverviewSlotValue{
			{Name: "弹性IP数量", Type: "EIP"},
		},
	}
	nat := netPoolModel.OverviewSlot{
		Info: netPoolModel.OverviewSlotInfo{
			Name:        "NAT集群",
			Description: "提供NAT服务",
			UnitType:    "number",
			Unit:        "个",
			PoolType:    "NAT",
		},
		Values: []netPoolModel.OverviewSlotValue{
			{Name: "NAT数量", Type: "NAT"},
		},
	}

	pgw := netPoolModel.OverviewSlot{
		Info: netPoolModel.OverviewSlotInfo{
			Name:        "PGW集群",
			Description: "提供裸金属网关服务",
			UnitType:    "number",
			Unit:        "个",
			PoolType:    "PGW",
		},
		Values: []netPoolModel.OverviewSlotValue{
			{Name: "裸金属数量", Type: "BM"},
		},
	}

	tgw := netPoolModel.OverviewSlot{
		Info: netPoolModel.OverviewSlotInfo{
			Name:        "TGW集群",
			Description: "提供专线、对等连接、VPN服务",
			UnitType:    "number",
			Unit:        "个",
			PoolType:    "TGW",
		},
		Values: []netPoolModel.OverviewSlotValue{
			{Name: "专线数量", Type: "SL"},
			{Name: "对等连接数量", Type: "P2P"},
			{Name: "VPN数量", Type: "VPN"},
		},
	}

	for _, v := range rs {
		info := make(map[string]interface{})
		err := json.Unmarshal([]byte(v), &info)
		if err != nil {
			klog.Errorf("GetNetworkPoolOverview err:", err)
			return overview, err
		}
		if region != "" && info["regionCode"] != region {
			continue
		}

		clusterCount := int(info["clusterCount"].(float64))
		// PGW、TGW先不做
		switch info["poolType"] {
		case "XGW":
			// 注意serverCount只能加LB或者EIP其中一个的，必须是+=，因为还有多region的情况
			if strings.Contains(info["poolName"].(string), "LB") {
				//xgw.Info.Value += int(info["serverCount"].(float64))
				xgw.Info.Value = clusterCount
				xgw.Values[0].Value += int(info["lbCount"].(float64))
			} else {
				xgw.Values[1].Value += int(info["eipCount"].(float64))
			}
		case "Tengine":
			tengine.Info.Value = clusterCount
			tengine.Values[0].Value += int(info["lbCount"].(float64))
		case "KGW":
			kgw.Info.Value = clusterCount
			kgw.Values[0].Value += int(info["lbCount"].(float64))
		case "SGW":
			sgw.Info.Value = clusterCount
			sgw.Values[0].Value += int(info["eipCount"].(float64))
		case "NAT":
			nat.Info.Value = clusterCount
			nat.Values[0].Value += int(info["natCount"].(float64))
		case "PGW":
			pgw.Info.Value = clusterCount
			pgw.Values[0].Value += int(info["bmCount"].(float64))
		case "TGW":
			tgw.Info.Value = clusterCount
			tgw.Values[0].Value = int(info["slCount"].(float64))  //专线
			tgw.Values[1].Value = int(info["p2pCount"].(float64)) //对等连接
			tgw.Values[2].Value = int(info["vpnCount"].(float64)) //vpn
		}
	}

	//EIP数量特殊处理，列表与资源池中的数量不一致，直接取列表数量来赋值，避免不一致情况
	xgwCount := 0
	params := eipModel.GetEipResourceListParams{
		PageNo:   1,
		PageSize: 1,
		//Region:   region, //列表的region筛选有问题，取全部
		PoolName: "XGW-EIP",
	}
	svc := eip.NewService()
	list, err := svc.GetEipResourceList(params)
	if err != nil {
		klog.Errorf("GetEipResourceList err:", err)
		xgwCount = 0
	}
	xgwCount = list.TotalCount
	xgw.Values[1].Value = xgwCount

	//sgwCount := 0
	//params = eipModel.GetEipResourceListParams{
	//	PageNo:   1,
	//	PageSize: 1,
	//	Region:   region,
	//	PoolName: "XGW-EIP",
	//}
	//list, err = svc.GetEipResourceList(params)
	//if err != nil {
	//	klog.Errorf("GetEipResourceList err:", err)
	//	sgwCount = 0
	//}
	//sgwCount = list.TotalCount
	//sgw.Values[0].Value = sgwCount

	//sgw的弹性ip与xgw是通用的
	sgw.Values[0].Value = xgwCount

	return netPoolModel.NetworkPoolOverview{
		PoolOverview: []netPoolModel.OverviewSlot{xgw, tengine, kgw, sgw, nat, pgw, tgw},
	}, nil
}

func (s Service) GetNetworkPoolResourceInfo(region, poolName string) (netResult netPoolModel.NetWorkResource, err error) {
	var (
		field   string
		ctx     context.Context
		celf    context.CancelFunc
		rs4Pool string
	)
	field = fmt.Sprintf("%s_%s", poolName, region)
	ctx, celf = context.WithTimeout(context.Background(), 5*time.Second)
	rs4Pool, err = gredis.HGet(ctx, gredis.NetWorkPoolKey, field)
	celf()
	if err != nil {
		klog.Error(fmt.Sprintf("redis read data from hash:%s field:%s error. err: %+v", gredis.NetWorkPoolKey, field, err))
		return
	}
	err = json.Unmarshal([]byte(rs4Pool), &netResult)
	if err != nil {
		klog.Error(fmt.Sprintf("unmarshal %s to NetWorkResource error. err: %+v", rs4Pool, err))
		return
	}
	return
}

func (s Service) GetNetWorkPoolType() []string {
	var (
		poolTypes []string
		rs        []string
		typeMap   = make(map[string]struct{})
		ctx       context.Context
		celf      context.CancelFunc
	)
	ctx, celf = context.WithTimeout(context.Background(), 5*time.Second)
	rs, _ = gredis.HKeys(ctx, gredis.NetWorkPoolKey)
	celf()
	if len(rs) == 0 {
		return poolTypes
	}
	for _, key := range rs {
		poolType := strings.Split(strings.Split(key, "_")[0], "-")[0]
		typeMap[poolType] = struct{}{}
	}
	for poolType := range typeMap {
		if poolType != "" {
			poolTypes = append(poolTypes, poolType)
		}
	}
	return poolTypes
}

func (s Service) GetNetWorkPoolInventory(param netPoolModel.NetWorkInventoryQuery) (result netPoolModel.InventoryList, total int, err error) {
	var (
		ctx  context.Context
		celf context.CancelFunc
		rs   = make(map[string]string)
	)
	ctx, celf = context.WithTimeout(context.Background(), 5*time.Second)
	defer celf()
	if param.RegionCode == "" {
		rs, err = gredis.HGetAll(ctx, gredis.NetWorkInventoryMapKey)
	} else {
		var temp string
		temp, err = gredis.HGet(ctx, gredis.NetWorkInventoryMapKey, param.RegionCode)
		if err != nil {
			return
		}
		rs[param.RegionCode] = temp
	}
	if len(rs) == 0 || err != nil {
		return
	}
	for _, v := range rs {
		var temp []netPoolModel.NetWorkInventory
		err = json.Unmarshal([]byte(v), &temp)
		if err != nil {
			return
		}
		result = append(result, temp...)
	}

	sort.Sort(result)
	total = len(result)
	if param.PageNo > 0 && param.PageSize > 0 {
		offset := (param.PageNo - 1) * param.PageSize
		limit := offset + param.PageSize
		if limit > len(result) {
			limit = len(result)
		}
		result = result[offset:limit]
	}
	return
}

func (s *Service) GetNetWorkPoolPhsicalServers(query netPoolModel.PhsicalServerQuery) (result netPoolModel.PhsicalServerList, total int, err error) {
	param := server.PhysicalHostListQuery{
		ResourcePool: query.PoolName,
		MixDeploy:    true,
		PageNo:       query.PageNo,
		PageSize:     query.PageSize,
	}
	if query.RegionCode != "" {
		param.Region = []string{query.RegionCode}
	}
	var rows *sql.Rows
	rows, total, err = serverDao.GetPhysicalHostList(param)
	if err != nil || total == 0 {
		return
	}
	if rows.Next() {
		err = dao.AssetDB.ScanRows(rows, &result)
		if err != nil {
			return
		}
	}
	sort.Sort(result)
	offset := (param.PageNo - 1) * param.PageSize
	limit := offset + param.PageSize
	if limit > len(result) {
		limit = len(result)
	}
	result = result[offset:limit]
	return
}

func (s *Service) NeutronAgents(agentType string) (*interface{}, error) {
	url := fmt.Sprintf("%s/agents", NeutronApiUrl)
	b, err := s.HttpClient.SimpleHttpGet(url)
	if err != nil {
		return nil, err
	}
	var result interface{}
	err = json.Unmarshal(b, &result)
	return &result, err
}

func (s *Service) NeutronLBServers(agentType string) (*interface{}, error) {
	url := fmt.Sprintf("%s/lb/servers", NeutronApiUrl)
	b, err := s.HttpClient.SimpleHttpGet(url)
	if err != nil {
		return nil, err
	}
	var result interface{}
	err = json.Unmarshal(b, &result)
	return &result, err
}

func (s *Service) NeutronFloatingips(agentType string) (*interface{}, error) {
	url := fmt.Sprintf("%s/floatingips", NeutronApiUrl)
	b, err := s.HttpClient.SimpleHttpGet(url)
	if err != nil {
		return nil, err
	}
	var result interface{}
	err = json.Unmarshal(b, &result)
	return &result, err
}

func (s *Service) NeutronVpcNatPools(agentType string) (*interface{}, error) {
	url := fmt.Sprintf("%s/vpc/nat_pools", NeutronApiUrl)
	b, err := s.HttpClient.SimpleHttpGet(url)
	if err != nil {
		return nil, err
	}
	var result interface{}
	err = json.Unmarshal(b, &result)
	return &result, err
}

func (s *Service) NeutronDirectConnects(agentType string) (*interface{}, error) {
	url := fmt.Sprintf("%s/direct_connects", NeutronApiUrl)
	b, err := s.HttpClient.SimpleHttpGet(url)
	if err != nil {
		return nil, err
	}
	var result interface{}
	err = json.Unmarshal(b, &result)
	return &result, err
}

func (s *Service) NeutronPeerings(agentType string) (*interface{}, error) {
	url := fmt.Sprintf("%s/peerings", NeutronApiUrl)
	b, err := s.HttpClient.SimpleHttpGet(url)
	if err != nil {
		return nil, err
	}
	var result interface{}
	err = json.Unmarshal(b, &result)
	return &result, err
}

func (s *Service) NeutronVpnTunnals(agentType string) (*interface{}, error) {
	url := fmt.Sprintf("%s/vpn_tunnals", NeutronApiUrl)
	b, err := s.HttpClient.SimpleHttpGet(url)
	if err != nil {
		return nil, err
	}
	var result interface{}
	err = json.Unmarshal(b, &result)
	return &result, err
}

// GetPoolManagementIps 根据poolName切片去查询IP,返回一个IP列表，其中调用的函数是cmdb中的physicalServers
func (s *Service) GetPoolManagementIps(param netPoolModel.PhyIpListQuery) ([]string, error) {
	request := netPoolModel.PhsicalServerQuery{
		PageNo:     1,
		PageSize:   65535,
		RegionCode: "",
	}
	var resIpList = make([]string, 0)
	var mp = make(map[string]struct{})
	for _, v := range param.PoolNameSlice {
		request.PoolName = v
		data, total, err := s.GetNetWorkPoolPhsicalServers(request)
		if err != nil {
			klog.Errorf(err.Error())
			return nil, err
		}
		for i := 0; i < total; i++ {
			mp[data[i].Ip] = struct{}{}
		}
	}
	for k, _ := range mp {
		resIpList = append(resIpList, k)
	}
	return resIpList, nil
}

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/pkg/service/ebsVolume/ebs_volume.go
```golang
package ebsVolume

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/pkg/service/bmpool/bmpool.go
```golang
package bmpool

import (
	"context"
	"encoding/json"
	"fmt"
	"luban-cmdb-api/pkg/gredis"
	bmpoolModel "luban-cmdb-api/pkg/models/bmpool"
	bmtask "luban-cmdb-api/pkg/tasks/bm-task"
	"luban-cmdb-api/pkg/utils/collection"
	"sort"
	"strconv"
	"strings"
	"time"

	"k8s.io/klog/v2"
)

type Service struct {
}

func (s Service) GetBmPoolOverview(region, az string) (overview bmpoolModel.OverviewRsp, err error) {
	ctx, cancelFunc := context.WithTimeout(context.Background(), time.Second*5)
	defer cancelFunc()
	instance, err := gredis.HGetAll(ctx, gredis.BMInstanceKey)
	inventory, err := gredis.HGetAll(ctx, gredis.BMInventoryKey)
	bmType, err := gredis.HGetAll(ctx, gredis.BMtypeKey) // map[string(typeId)]interface{}
	bmTypeMap := make(map[string]bmtask.BmConfig)
	if err != nil {
		klog.Errorf("GetBmPoll Overview error", err)
		return
	}
	// 由于数据库和reids的bm库存里面都没有az_code这个字段，只有available_zone字段，所以这里先从简做个map
	azMap := make(map[interface{}]string)
	for i := 1; i < 9; i++ { // 这里假设了不超过9个az
		azMap[fmt.Sprintf("ksc_shpbs_zone100%v_aggregate_raidssd_100%v", i, i)] =
			"cn-shanghai-2" + string(byte('a'+i-1))
	}
	// bmTypeMap map[string]string
	for i, v := range bmType {
		var bmtype bmtask.BmConfig
		err := json.Unmarshal([]byte(v), &bmtype)
		if err != nil {
			klog.Info("反序列化失败")
		}
		bmTypeMap[i] = bmtype
	}

	typeNameMap := make(map[interface{}]string)
	for i, v := range bmTypeMap {
		typeNameMap[i] = v.InstanceType
	}
	bmInstance := bmpoolModel.OverviewSlot{
		Info: bmpoolModel.OverviewSlotInfo{
			Name:     "裸金属实例总量统计",
			UnitType: "number",
			Unit:     "个",
		},
		Servers: []bmpoolModel.OverviewSlotValue{},
	}
	bmInventory := bmpoolModel.OverviewSlot{
		Info: bmpoolModel.OverviewSlotInfo{
			Name:     "裸金属库存总量统计",
			UnitType: "number",
			Unit:     "个",
		},
		Servers: []bmpoolModel.OverviewSlotValue{},
	}

	inventoryExist := make(map[interface{}]bool)
	inventoryType := make(map[int]int) // 存放现在库存里面有的裸金属种类，是一个裸金属种类到第几个结构体的映射
	index := 0                         // 用于保存裸金属种类出现的顺序
	// 库存开始赋值
	for k, v := range inventory {
		inventoryExist[k] = true
		info := make(map[string]interface{})
		err := json.Unmarshal([]byte(v), &info)
		if err != nil {
			klog.Errorf("GetBMPool Inventory Overview error:", err)
		}
		//TODO 分区数据暂时没有
		//// 分地区
		//if region != "" && info["Region"] != region {
		//	continue
		//}
		//// 分可用区
		//if az != "" && azMap[info["AvailabilityZone"]] != az {
		//	continue
		//}
		// 先筛选出可售卖的类型（即库存里有的类型）
		typeInt, err2 := strconv.Atoi(info["Type"].(string))
		if err2 != nil {
			klog.Errorf("stringToInt error")
		}
		if _, ok := inventoryType[typeInt]; !ok {
			inventoryType[typeInt] = index
			index++
			var typeName string
			if name, ok2 := typeNameMap[info["Type"]]; ok2 {
				typeName = name
			} else {
				typeName = "其他类型"
			}
			bmInventory.Servers = append(bmInventory.Servers, bmpoolModel.OverviewSlotValue{
				Code:     strconv.Itoa(index),
				Name:     typeName,
				UnitType: "number",
				Unit:     "个",
			})
			bmInstance.Servers = append(bmInstance.Servers, bmpoolModel.OverviewSlotValue{
				Code:     strconv.Itoa(index),
				Name:     typeName,
				UnitType: "number",
				Unit:     "个",
			})
		}
		// 库存总量计算和分类型计算
		if az == "" {
			bmInventory.Info.Value++
			bmInventory.Servers[inventoryType[typeInt]].Value++
		} else if az != "" {
			if azMap[info["AvailabilityZone"].(string)] == az {
				bmInventory.Info.Value++
				bmInventory.Servers[inventoryType[typeInt]].Value++
			}
		}
	}

	// 实例开始赋值
	for _, v := range instance {
		info := make(map[string]interface{})
		err := json.Unmarshal([]byte(v), &info)
		if err != nil {
			klog.Errorf("GetBMPool Instance Overview error:", err)
		}
		//TODO 分区数据暂时没有
		//// 分地区
		//if region != "" && info["Region"] != region {
		//	continue
		//}
		//// 分可用区
		//if az != "" && azMap[info["AvailabilityZone"]] != az {
		//	continue
		//}
		// 分库存
		if inventoryExist[info["BmSn"]] == false {
			continue
		}
		// 实例总量计算和分类型计算
		if info["BmType"] == nil {
			continue
		}
		typeInt, err2 := strconv.Atoi(info["BmType"].(string))
		if err2 != nil {
			klog.Errorf("stringToInt error")
		}
		if az == "" {
			bmInstance.Info.Value++
			bmInstance.Servers[inventoryType[typeInt]].Value++
		} else if az != "" {
			if azMap[info["AZ"].(string)] == az {
				bmInstance.Info.Value++
				bmInstance.Servers[inventoryType[typeInt]].Value++
			}
		}
	}

	return bmpoolModel.OverviewRsp{
		BMInstanceOverview:  bmInstance,
		BMInventoryOverview: bmInventory,
	}, nil
}

func (s Service) GetBmResourceList(params bmpoolModel.ListReq) (bmList bmpoolModel.ListRsp, err error) {
	// fetch
	bmInstanceList, err := getbmInstanceList()
	// bmInstanceList = [ [bm1, bm2] ]
	if err != nil {
		return
	}
	// filter
	dataList := make([]bmpoolModel.ListInfo, 0)
	RegionMap := map[string]string{"cn-shanghai-2": "上海2区"}
	AZMap := map[string]string{"ksc_shpbs_zone1001_aggregate_raidssd_1001": "可用区A", "ksc_shpbs_zone1002_aggregate_raidssd_1002": "可用区B"}
	AZcMap := map[string]string{"cn-shanghai-2a": "可用区A", "cn-shanghai-2b": "可用区B"}
	for _, v := range bmInstanceList {
		status := "未出售"
		if v.InventoryStatus == 1 {
			status = "已售卖"
		}
		info := bmpoolModel.ListInfo{
			SN:                v.BmSn,              // bminfo  BmSn
			Region:            RegionMap[v.Region], // bm region
			AZ:                AZMap[v.AZ],
			InventoryStatus:   status,                                                                                                                                                                       // bm is_sale
			UserID:            v.UserID,                                                                                                                                                                     // bm_remoting use_id
			UserName:          v.UserName,                                                                                                                                                                   // bm_remoting username
			MachinePackage:    v.MachinePackage,                                                                                                                                                             // bm name
			InstanceType:      v.InstanceType,                                                                                                                                                               // bm_type hostname
			InstanceConf:      fmt.Sprintf("CPU:%s\n内存:%s\n存储:%s*%d(%s)%s*%d(%s)", v.CPU, v.Memory, v.SystemDiskSize, v.SystemDiskCount, v.SystemDiskType, v.DataDiskSize, v.DataDiskCount, v.DataDiskType), // bm_type 组合
			CPU:               fmt.Sprintf("%s", v.CPU),
			Memory:            fmt.Sprintf("%s", v.Memory),
			Storage:           fmt.Sprintf("%s*%d(%s)%s*%d(%s)", v.SystemDiskSize, v.SystemDiskCount, v.SystemDiskType, v.DataDiskSize, v.DataDiskCount, v.DataDiskType),
			OutIP:             v.OutIp, // 带外IP
			Room:              v.Region,
			Rack:              "机架位" + v.Rack,
			IP:                v.Ip,
			Port:              v.Port,
			Mac:               v.Mac,         // bm mac
			InboundTime:       v.InboundTime, // bminfo create_time
			ReservationStatus: "",
			ReservedUserID:    v.ReservedUserID,
			ReservedUserName:  "",
			ReservedTime:      v.ReservedTime,
		}
		dataList = append(dataList, info)
	}

	//filter
	if len(dataList) == 0 {
		return
	}
	filterList := make([]bmpoolModel.ListInfo, 0)
	// 进行模糊查询
	//if params.SearchType == "SN" {
	if len(params.SN) > 0 {
		for _, v := range dataList {
			if strings.Contains(v.SN, params.SN) {
				filterList = append(filterList, v)
			}
		}
		dataList = filterList
		filterList = []bmpoolModel.ListInfo{}
	}
	// 所属可用区
	if len(params.AZ) != 0 {
		filterList := make([]bmpoolModel.ListInfo, 0)
		for _, v := range dataList {
			for _, t := range params.AZ {
				if v.AZ == AZcMap[t] {
					filterList = append(filterList, v)
				}
			}
		}
		dataList = filterList
		filterList = []bmpoolModel.ListInfo{}
	}
	// 库存状态
	if len(params.InventoryStatus) != 0 {
		for _, v := range dataList {
			for _, t := range params.InventoryStatus {
				if v.InventoryStatus == t {
					filterList = append(filterList, v)
				}
			}
		}
		dataList = filterList
		filterList = []bmpoolModel.ListInfo{}
	}
	// 实例类型
	if len(params.InstanceType) != 0 {
		for _, v := range dataList {
			for _, t := range params.InstanceType {
				if v.InstanceType == t {
					filterList = append(filterList, v)
				}
			}
		}
		dataList = filterList
		filterList = []bmpoolModel.ListInfo{}
	}
	// 租户ID
	if len(params.UserID) != 0 {
		for _, v := range dataList {
			for _, t := range params.UserID {
				if v.UserID == t {
					filterList = append(filterList, v)
				}
			}
		}
		dataList = filterList
		filterList = []bmpoolModel.ListInfo{}
	}
	// 售卖租户
	if len(params.UserName) != 0 {
		for _, v := range dataList {
			for _, t := range params.UserName {
				if v.UserName == t {
					filterList = append(filterList, v)
				}
			}
		}
		dataList = filterList
		filterList = []bmpoolModel.ListInfo{}
	}

	// sort
	if params.OrderType == "" {
		params.OrderType = "descending"
	}
	if params.OrderType == "descending" {
		sort.Slice(dataList, func(i, j int) bool {
			return dataList[i].InboundTime.After(dataList[j].InboundTime)
		})
	} else {
		sort.Slice(dataList, func(i, j int) bool {
			return dataList[i].InboundTime.Before(dataList[j].InboundTime)
		})
	}
	bmList.TotalCount = len(dataList)
	// page
	if params.PageNo > 0 && params.PageSize > 0 {
		offset := (params.PageNo - 1) * params.PageSize
		limit := offset + params.PageSize
		if limit > len(dataList) {
			limit = len(dataList)
		}
		dataList = dataList[offset:limit]
	}
	bmList.PageNo = params.PageNo
	bmList.PageSize = params.PageSize
	bmList.DataList = dataList
	return
}

func getbmInstanceList() (bml []bmtask.BmList, err error) {
	ctx, celf := context.WithTimeout(context.Background(), 5*time.Second)
	defer celf()
	bmInstanceMap, err := gredis.HGetAll(ctx, gredis.BMListKey)
	if err != nil {
		return
	}
	var resultList []string
	for _, bmStr := range bmInstanceMap {
		resultList = append(resultList, bmStr)
	}
	rsStr := "[" + strings.Join(resultList, ",") + "]"
	err = json.Unmarshal([]byte(rsStr), &bml)
	if err != nil {
		klog.Error("bmInstanceMap Unmarshal failure:", err.Error())
		return
	}
	return
}

func getbmInstanceMap() (map[string]bmtask.BmType, error) {
	ctx, celf := context.WithTimeout(context.Background(), 5*time.Second)
	defer celf()
	bmInstanceMap, err := gredis.HGetAll(ctx, gredis.BMTypeKey)
	if err != nil {
		return nil, err
	}
	bmInstanceStructMap := make(map[string]bmtask.BmType, len(bmInstanceMap))
	var bmt bmtask.BmType
	for _, bm := range bmInstanceMap {
		err = json.Unmarshal([]byte(bm), &bmt)
		if err != nil {
			klog.Error("bmInstanceMap Unmarshal failure:", err.Error())
			return nil, err
		}
	}
	return bmInstanceStructMap, nil
}

func (s Service) GetInventory(params bmpoolModel.InventoryReq) (result bmpoolModel.InventoryRsp, err error) {
	//fetch
	bmInventoryList, err := getBmInventoryList() //库存列表
	if err != nil {
		return
	}
	ctx, cancelFunc := context.WithTimeout(context.Background(), time.Second*5)
	defer cancelFunc()
	bmType, err := gredis.HGetAll(ctx, gredis.BMtypeKey) // map[string(typeId)]interface{}
	bmTypeMap := make(map[string]bmtask.BmConfig)
	for i, v := range bmType {
		var bmtype bmtask.BmConfig
		err := json.Unmarshal([]byte(v), &bmtype)
		if err != nil {
			klog.Info("反序列化失败")
		}
		bmTypeMap[i] = bmtype
	}
	//group by type
	typeInventoryMap := make(map[string]bmpoolModel.InventoryInfo)
	for _, v := range bmInventoryList {
		bmType := bmTypeMap[v.Type]
		typeName := bmType.InstanceType
		info, ok := typeInventoryMap[typeName]
		if !ok {
			info = bmpoolModel.InventoryInfo{
				InstanceType:   typeName,
				Region:         v.Region,
				RegionName:     "上海2区",
				Az:             v.Region + "a",
				AzName:         "可用区A",
				InventoryTotal: 0,
				SoldNum:        0,
				ReservedNum:    0,
				ForSaleNum:     0,
			}
			info.BmConf = ParseBmConf(bmType)
		}

		if v.IsSale == 1 {
			info.SoldNum++
		}
		info.InventoryTotal++
		typeInventoryMap[typeName] = info
	}
	dataList := make([]bmpoolModel.InventoryInfo, 0, len(typeInventoryMap))
	for _, v := range typeInventoryMap {
		v.ForSaleNum = v.InventoryTotal - v.SoldNum
		dataList = append(dataList, v)
	}

	//filter
	dataList = filter(params, dataList)
	//sort
	sort.Slice(dataList, parseOrder(params, dataList))
	//page
	total := len(dataList)
	if params.PageNo > 0 && params.PageSize > 0 {
		offset := (params.PageNo - 1) * params.PageSize
		limit := offset + params.PageSize
		if limit > len(dataList) {
			limit = len(dataList)
		}
		dataList = dataList[offset:limit]
	}

	result = bmpoolModel.InventoryRsp{
		TotalCount: total,
		PageNo:     params.PageNo,
		PageSize:   params.PageSize,
		DataList:   dataList,
	}
	return
}

func (s Service) GetInventoryOptionalCondition() (map[string][]interface{}, error) {

	result := map[string][]interface{}{}
	bmInventoryList, err := getBmInventoryList()
	if err != nil {
		return result, err
	}
	bmTypeMap, err := getBmTypeMap()
	if err != nil {
		return result, err
	}
	instanceType := collection.NewSet()
	for _, v := range bmInventoryList {
		instanceType.Add(bmTypeMap[v.Type].HostName)
	}

	result["instanceType"] = instanceType.Keys()

	return result, nil
}

func (s Service) GetbmListOptionalCondition() (rsp bmpoolModel.ListOpInfo, err error) {
	bmInstanceList, err := getbmInstanceList()
	// bmInstanceList = [ [bm1, bm2] ]
	if err != nil {
		return
	}
	// filter
	az := collection.NewSet()
	userID := collection.NewSet()
	userName := collection.NewSet()
	instanceType := collection.NewSet()
	AZMap := map[string]string{"ksc_shpbs_zone1001_aggregate_raidssd_1001": "可用区A", "ksc_shpbs_zone1002_aggregate_raidssd_1002": "可用区B"}
	for _, v := range bmInstanceList {
		az.Add(AZMap[v.AZ])
		userID.Add(v.UserID)
		userName.Add(v.UserName)
		instanceType.Add(v.InstanceType)
	}
	for _, v := range az.Keys() {
		if v.(string) != "" {
			rsp.AZ = append(rsp.AZ, v.(string))
		}
	}
	for _, v := range userID.Keys() {
		if v.(int64) != 0 {
			rsp.UserID = append(rsp.UserID, v.(int64))
		}
	}
	for _, v := range userName.Keys() {
		if v != "" {
			rsp.UserName = append(rsp.UserName, v.(string))
		}
	}
	for _, v := range instanceType.Keys() {
		if v != "" {
			rsp.InstanceType = append(rsp.InstanceType, v.(string))
		}
	}
	rsp.InventoryStatus = []string{"未出售", "已售卖"}
	rsp.ReservedUserID = []int{}
	rsp.ReservationStatus = []string{}
	rsp.ReservedUserName = []string{}
	return
}

func ParseBmConf(bmType bmtask.BmConfig) bmpoolModel.BmConf {
	return bmpoolModel.BmConf{
		Cpu:    bmType.Cpu,
		Memory: bmType.Memory,
		Storage: bmType.SystemDiskSize + "*" + strconv.Itoa(int(bmType.SystemDiskCount)) + "(" + bmType.SystemDiskType + ")" +
			" " + bmType.DataDiskSize + "*" + strconv.Itoa(int(bmType.DataDiskCount)) + "(" + bmType.DataDiskType + ")",
	}
}

func filter(params bmpoolModel.InventoryReq, list []bmpoolModel.InventoryInfo) []bmpoolModel.InventoryInfo {

	//单选
	//Region string `json:"region"`
	////多选
	//Az           []string `json:"az"`
	//InstanceType []string `json:"instanceType"`

	klog.Infof("InventoryReq : %+v", params)
	isFilter := params.Region != "" ||
		len(params.Az) > 0 ||
		len(params.InstanceType) > 0

	if !isFilter {
		return list
	}

	filterList := make([]bmpoolModel.InventoryInfo, 0, len(list))
	for _, v := range list {
		if params.Region != "" {
			if v.Region != params.Region {
				continue
			}
		}

		if len(params.Az) > 0 {
			matchNum := 0
			for _, Az := range params.Az {
				if v.Az == Az {
					matchNum++
				}
			}
			if matchNum < 1 {
				continue
			}
		}

		if len(params.InstanceType) > 0 {
			matchNum := 0
			for _, InstanceType := range params.InstanceType {
				if v.InstanceType == InstanceType {
					matchNum++
				}
			}
			if matchNum < 1 {
				continue
			}
		}

		filterList = append(filterList, v)
	}

	return filterList
}

func parseOrder(params bmpoolModel.InventoryReq, list []bmpoolModel.InventoryInfo) func(i int, j int) bool {
	klog.Infof("orderCode %s , orderType %s", params.OrderCode, params.OrderType)

	//OrderCode string `json:"orderCode"` //inventoryTotal(库存总量),soldNum(已卖),reservedNum(已预留),forSaleNum(可卖量)
	//OrderType string `json:"orderType"` //ascending, descending

	asc := "ascending"  //正序
	des := "descending" //逆序
	var lessFunc func(i, j int) bool
	if params.OrderCode == "inventoryTotal" {
		if params.OrderType == asc {
			lessFunc = func(i, j int) bool {
				return list[i].InventoryTotal < list[j].InventoryTotal
			}
		}
		if params.OrderType == des {
			lessFunc = func(i, j int) bool {
				return list[i].InventoryTotal > list[j].InventoryTotal
			}
		}
	}

	if params.OrderCode == "soldNum" {
		if params.OrderType == asc {
			lessFunc = func(i, j int) bool {
				return list[i].SoldNum < list[j].SoldNum
			}
		}
		if params.OrderType == des {
			lessFunc = func(i, j int) bool {
				return list[i].SoldNum > list[j].SoldNum
			}
		}
	}

	if params.OrderCode == "reservedNum" {
		if params.OrderType == asc {
			lessFunc = func(i, j int) bool {
				return list[i].ReservedNum < list[j].ReservedNum
			}
		}
		if params.OrderType == des {
			lessFunc = func(i, j int) bool {
				return list[i].ReservedNum > list[j].ReservedNum
			}
		}
	}

	if params.OrderCode == "forSaleNum" {
		if params.OrderType == asc {
			lessFunc = func(i, j int) bool {
				return list[i].ForSaleNum < list[j].ForSaleNum
			}
		}
		if params.OrderType == des {
			lessFunc = func(i, j int) bool {
				return list[i].ForSaleNum > list[j].ForSaleNum
			}
		}
	}

	if lessFunc == nil {
		lessFunc = func(i, j int) bool {
			return list[i].InventoryTotal < list[j].InventoryTotal
		}
	}
	return lessFunc
}

func getBmTypeMap() (map[string]bmtask.BmType, error) {
	ctx, cefl := context.WithTimeout(context.Background(), 5*time.Second)
	defer cefl()
	bmInventoryMap, err := gredis.HGetAll(ctx, gredis.BMTypeKey)
	if err != nil {
		return nil, err
	}

	bmInventoryStructMap := make(map[string]bmtask.BmType, len(bmInventoryMap))
	var bmt bmtask.BmType
	for i, bm := range bmInventoryMap {
		err = json.Unmarshal([]byte(bm), &bmt)
		if err != nil {
			klog.Error("bmInventoryMap Unmarshal failure:", err.Error())
			return nil, err
		}
		bmInventoryStructMap[i] = bmt
	}
	return bmInventoryStructMap, nil
}

func getBmInventoryList() (bml []bmtask.Bm, err error) {
	ctx, cefl := context.WithTimeout(context.Background(), 5*time.Second)
	defer cefl()
	bmInventoryMap, err := gredis.HGetAll(ctx, gredis.BMInventoryKey)
	if err != nil {
		return
	}
	var resultList []string
	for _, bmiStr := range bmInventoryMap {
		resultList = append(resultList, bmiStr)
	}
	rsStr := "[" + strings.Join(resultList, ",") + "]"
	err = json.Unmarshal([]byte(rsStr), &bml)
	if err != nil {
		klog.Error("bmInventoryMap Unmarshal failure:", err.Error())
		return
	}
	return
}

func NewService() *Service {
	return &Service{}
}

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/pkg/service/k8sresource/k8sresource.go
```golang
package k8sresource

import (
	"context"
	"database/sql"
	"encoding/json"
	"fmt"
	"luban-cmdb-api/pkg/models/aggregate"
	"luban-cmdb-api/pkg/models/businessManagement"
	serverModel "luban-cmdb-api/pkg/models/server"
	"strings"
	"time"

	coreV1 "k8s.io/api/core/v1"
	"k8s.io/client-go/kubernetes"

	v1 "k8s.io/api/apps/v1"
	"k8s.io/apimachinery/pkg/labels"
	"k8s.io/klog/v2"

	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

const (
	ServiceMonitorTimeout = 10 * time.Second
)

// var clientSet = client.GetClient()
// var outClientSet = client.GetOuterClient()

type K8sResource struct {
	Client *kubernetes.Clientset
}

func (r *K8sResource) GetDeployment(ctx context.Context, name, nameSpace string) (*v1.Deployment, error) {
	ctx, cancel := context.WithTimeout(ctx, ServiceMonitorTimeout)
	defer cancel()
	return r.Client.AppsV1().Deployments(nameSpace).Get(ctx, name, metav1.GetOptions{})
}
func (r *K8sResource) GetDeploymentList(ctx context.Context, nameSpace string) (*v1.DeploymentList, error) {
	ctx, cancel := context.WithTimeout(ctx, ServiceMonitorTimeout)
	defer cancel()
	return r.Client.AppsV1().Deployments(nameSpace).List(ctx, metav1.ListOptions{})
}
func (r *K8sResource) GetRsList(ctx context.Context, nameSpace string) (*v1.ReplicaSetList, error) {
	ctx, cancel := context.WithTimeout(ctx, ServiceMonitorTimeout)
	defer cancel()
	return r.Client.AppsV1().ReplicaSets(nameSpace).List(ctx, metav1.ListOptions{})
}
func (r *K8sResource) GetPodList(ctx context.Context, nameSpace string) (*coreV1.PodList, error) {
	ctx, cancel := context.WithTimeout(ctx, ServiceMonitorTimeout)
	defer cancel()
	return r.Client.CoreV1().Pods(nameSpace).List(ctx, metav1.ListOptions{})
}
func (p *K8sResource) GetPodsOfRsOfDeploy(ctx context.Context, podL *coreV1.PodList, rs *v1.ReplicaSetList, deployL *v1.DeploymentList, svcId int, serviceName string, q businessManagement.QueryServiceInstanceListParams,
	rows []serverModel.PhysicalHostData, vmDL []aggregate.VmDetail) (svcs []businessManagement.ServiceInstance, err error) {
	// ctx, cancel := context.WithTimeout(ctx, ServiceMonitorTimeout)
	// defer cancel()
	svcname := strings.ToLower(serviceName)
	if svcname == "server" || svcname == "cmdb" {
		klog.Infof("GetPodsOfRsOfDeploy begin: %s", svcname)
	}

	for m := 0; m < len(deployL.Items); m++ {
		if svcname == "server" || svcname == "cmdb" {
			klog.Infof("deployment name: %s", deployL.Items[m].Name)
		}

		if deployL.Items[m].Name != strings.ToLower(serviceName) {
			continue
		}

		dmMatchMap := deployL.Items[m].Spec.Selector.MatchLabels
		//deployMatchSelector := metav1.LabelSelector{MatchLabels: deployL.Items[m].Spec.Selector.MatchLabels}
		//dmSelecter := labels.Set(deployMatchSelector.MatchLabels).String()

		if svcname == "server" || svcname == "cmdb" {
			klog.Infof("dmMatchMap %+v", dmMatchMap)
		}

		for j := 0; j < len(rs.Items); j++ {
			//rsSelecter := labels.Set(rs.Items[j].Labels).String()
			rsMap := rs.Items[j].Labels
			rsMatchMap := rs.Items[j].Spec.Selector.MatchLabels

			if BoolTagMapInArrMap(dmMatchMap, rsMap) && rs.Items[j].Namespace == deployL.Items[m].Namespace {

				if svcname == "server" || svcname == "cmdb" {
					klog.Infof("rsMap: %+v", rsMap)
					klog.Infof("rsMatchMap: %+v", rsMatchMap)
				}

				for i := 0; i < len(podL.Items); i++ {
					//podSelecter := labels.Set(podL.Items[i].Labels).String()
					podMap := podL.Items[i].Labels
					status := -1
					if podL.Items[i].Status.Phase == "Running" {
						status = 1
					}
					if !BoolTagMapInArrMap(rsMatchMap, podMap) || rs.Items[j].Namespace != podL.Items[i].Namespace {
						continue
					}

					hostIp, _, outIp, regionCode, regionName, azCode, azName, vmId, hostType, hostId := GetHost(rows, vmDL, podL.Items[i].Spec.NodeName)
					if svcname == "server" || svcname == "cmdb" {
						klog.Infof("podMap: %+v", podMap)
						klog.Infof("podL.Items.Spec.NodeName: %s", podL.Items[i].Spec.NodeName)
						klog.Infof("hostIp: %s,regionCode: %s,azCode: %s, vmId: %s,hostId: %d", hostIp, regionCode, azCode, vmId, hostId)
						for _, vm := range vmDL {
							if strings.HasPrefix(vm.HostName, "vm") {
								klog.Infof("vm hostname: %s", vm.HostName)
							}
						}
					}

					if hostIp != "" && BoolTagMapInArrMap(rsMatchMap, podMap) &&
						rs.Items[j].Namespace == podL.Items[i].Namespace &&
						(q.Region == "" || regionCode == q.Region) &&
						(len(q.Az) <= 0 || BoolTagInArray(q.Az, azCode)) &&
						(len(q.SearchSvcIds) <= 0 || BoolTagInArrayInt(q.SearchSvcIds, svcId)) &&
						(q.SearchName == "" || strings.Contains(podL.Items[i].Name, q.SearchName)) {
						svcs = append(svcs, businessManagement.ServiceInstance{
							//Id: pod.UID,
							Name:        podL.Items[i].Name, // + ":" + string(pod.UID),
							HostName:    podL.Items[i].Spec.NodeName,
							HostIp:      podL.Items[i].Status.HostIP,
							OutIp:       outIp,
							RegionCode:  regionCode,
							RegionName:  regionName,
							AzCode:      azCode,
							AzName:      azName,
							HostId:      hostId,
							ServiceId:   svcId,
							ServiceName: serviceName,
							VmId:        vmId,
							HostType:    hostType,
							CreateTime:  podL.Items[i].Status.StartTime.Time,
							Creator:     "system",
							State:       int8(status),
							BuiltIn:     1,
						})
					}
				}
			}
		}

		// for i := 0; i < len(podL.Items); i++ {
		// 	//podSelecter := labels.Set(podL.Items[i].Labels).String()
		// 	podMap := podL.Items[i].Labels

		// 	for j := 0; j < len(rs.Items); j++ {
		// 		//rsSelecter := labels.Set(rs.Items[j].Labels).String()
		// 		rsMap := rs.Items[j].Labels
		// 		status := -1
		// 		if podL.Items[i].Status.Phase == "Running" {
		// 			status = 1
		// 		}
		// 		hostIp, _, outIp, regionCode, regionName, azCode, azName, vmId, hostType, hostId := GetHost(rows, vmDL, podL.Items[i].Spec.NodeName)
		// 		//labelMatchSelector := metav1.LabelSelector{MatchLabels: rs.Items[j].Spec.Selector.MatchLabels}
		// 		rsMatchMap := rs.Items[j].Spec.Selector.MatchLabels
		// 		if hostIp != "" && BoolTagMapInArrMap(dmMatchMap, rsMap) && BoolTagMapInArrMap(rsMatchMap, podMap) &&
		// 			(q.Region == "" || regionCode == q.Region) &&
		// 			(len(q.Az) <= 0 || BoolTagInArray(q.Az, azCode)) &&
		// 			(len(q.SearchSvcIds) <= 0 || BoolTagInArrayInt(q.SearchSvcIds, svcId)) &&
		// 			(q.SearchName == "" || strings.Contains(podL.Items[i].Name, q.SearchName)) {
		// 			svcs = append(svcs, businessManagement.ServiceInstance{
		// 				//Id: pod.UID,
		// 				Name:        podL.Items[i].Name, // + ":" + string(pod.UID),
		// 				HostName:    podL.Items[i].Spec.NodeName,
		// 				HostIp:      podL.Items[i].Status.HostIP,
		// 				OutIp:       outIp,
		// 				RegionCode:  regionCode,
		// 				RegionName:  regionName,
		// 				AzCode:      azCode,
		// 				AzName:      azName,
		// 				HostId:      hostId,
		// 				ServiceId:   svcId,
		// 				ServiceName: serviceName,
		// 				VmId:        vmId,
		// 				HostType:    hostType,
		// 				CreateTime:  podL.Items[i].Status.StartTime.Time,
		// 				Creator:     "system",
		// 				State:       int8(status),
		// 			})
		// 		}
		// 		//rmSelecter := labels.Set(labelMatchSelector.MatchLabels).String()

		// 		// if strings.Contains(podSelecter, rmSelecter) && strings.Contains(rsSelecter, dmSelecter) {
		// 		// 	svcs = append(svcs, businessManagement.ServiceInstance{
		// 		// 		//Id: pod.UID,
		// 		// 		Name:        podL.Items[i].Name, // + ":" + string(pod.UID),
		// 		// 		HostName:    podL.Items[i].Spec.NodeName,
		// 		// 		HostIp:      podL.Items[i].Status.HostIP,
		// 		// 		ServiceId:   svcId,
		// 		// 		ServiceName: serviceName,
		// 		// 	})
		// 		// }
		// 	}
		// }
	}

	return
}
func (r *K8sResource) GetRs(ctx context.Context, deployment *v1.Deployment) (*v1.ReplicaSetList, error) {
	ctx, cancel := context.WithTimeout(ctx, ServiceMonitorTimeout)
	labelSelector := metav1.LabelSelector{MatchLabels: deployment.Spec.Selector.MatchLabels}
	//selecter, _ := metav1.LabelSelectorAsSelector(deployment.Spec.Selector)
	option := metav1.ListOptions{
		LabelSelector: labels.Set(labelSelector.MatchLabels).String(), //selecter.String(),
	}
	defer cancel()
	return r.Client.AppsV1().ReplicaSets(deployment.Namespace).List(ctx, option)
}

// func (p *K8sResource) GetPods(ctx context.Context, rs *v1.ReplicaSetList, svcId int, serviceName string, q businessManagement.QueryServiceInstanceListParams,
// 	rows *sql.Rows, vmDL []aggregate.VmDetail) (svcs []businessManagement.ServiceInstance, err error) {
// 	ctx, cancel := context.WithTimeout(ctx, ServiceMonitorTimeout)
// 	defer cancel()

// 	for _, r := range rs.Items {
// 		// selecter, _ := metav1.LabelSelector{
// 		// 	MatchLabels:      map[string]string{"app": "demo"},
// 		// 	MatchExpressions: []metav1.LabelSelectorRequirement{},
// 		// }
// 		//selecter, _ := metav1.LabelSelectorAsSelector(r.Spec.Selector)
// 		//labelMap, _ := metav1.LabelSelectorAsMap(r.Spec.Selector)

// 		labelSelector := metav1.LabelSelector{MatchLabels: r.Spec.Selector.MatchLabels}
// 		option := metav1.ListOptions{
// 			LabelSelector: labels.Set(labelSelector.MatchLabels).String(),
// 		}
// 		podL, _ := p.Client.CoreV1().Pods(r.Namespace).List(ctx, option)
// 		for _, pod := range podL.Items {
// 			status := -1
// 			if pod.Status.Phase == "Running" {
// 				status = 1
// 			}
// 			_, _, outIp, regionCode, regionName, azCode, azName, vmId, hostType, hostId := GetHost(rows, vmDL, pod.Spec.NodeName)
// 			if (q.Region == "" || regionCode == q.Region) &&
// 				(len(q.Az) <= 0 || BoolTagInArray(q.Az, azCode)) &&
// 				(len(q.SearchSvcIds) <= 0 || BoolTagInArrayInt(q.SearchSvcIds, svcId)) &&
// 				(q.SearchName == "" || strings.Contains(pod.Name, q.SearchName)) {
// 				svcs = append(svcs, businessManagement.ServiceInstance{
// 					//Id: pod.UID,
// 					Name:        pod.Name, // + ":" + string(pod.UID),
// 					HostName:    pod.Spec.NodeName,
// 					HostIp:      pod.Status.HostIP,
// 					OutIp:       outIp,
// 					RegionCode:  regionCode,
// 					RegionName:  regionName,
// 					AzCode:      azCode,
// 					AzName:      azName,
// 					HostId:      hostId,
// 					ServiceId:   svcId,
// 					ServiceName: serviceName,
// 					VmId:        vmId,
// 					HostType:    hostType,
// 					CreateTime:  pod.Status.StartTime.Time,
// 					Creator:     "system",
// 					State:       int8(status),
// 				})
// 			}

// 		}
// 		//pods = append(pods, podL.Items...)
// 	}
// 	return svcs, nil
// }
func (p *K8sResource) GetPodsTT(ctx context.Context, rs string, svcId int, serviceName string, q businessManagement.QueryServiceInstanceListParams,
	rows *sql.Rows, vmDL []aggregate.VmDetail) (podL *coreV1.PodList, err error) {
	ctx, cancel := context.WithTimeout(ctx, ServiceMonitorTimeout)
	defer cancel()
	podL, _ = p.Client.CoreV1().Pods(rs).List(ctx, metav1.ListOptions{})

	return podL, nil
}

// func (p *K8sResource) GetPodsOfRs(ctx context.Context, podL *coreV1.PodList, rs *v1.ReplicaSetList, svcId int, serviceName string, q businessManagement.QueryServiceInstanceListParams,
// 	rows *sql.Rows, vmDL []aggregate.VmDetail) (svcs []businessManagement.ServiceInstance, err error) {
// 	ctx, cancel := context.WithTimeout(ctx, ServiceMonitorTimeout)
// 	defer cancel()
// 	for i := 0; i < len(podL.Items); i++ {
// 		podSelecter := labels.Set(podL.Items[i].Labels).String()

// 		for j := 0; j < len(rs.Items); j++ {
// 			//rsSelecter := labels.Set(rs.Items[j].Labels).String()
// 			labelSelector := metav1.LabelSelector{MatchLabels: rs.Items[j].Spec.Selector.MatchLabels}

// 			rsSelecter := labels.Set(labelSelector.MatchLabels).String()

// 			if podSelecter == rsSelecter {
// 				svcs = append(svcs, businessManagement.ServiceInstance{
// 					//Id: pod.UID,
// 					Name:        podL.Items[i].Name, // + ":" + string(pod.UID),
// 					HostName:    podL.Items[i].Spec.NodeName,
// 					HostIp:      podL.Items[i].Status.HostIP,
// 					ServiceId:   svcId,
// 					ServiceName: serviceName,
// 				})
// 			}
// 		}
// 	}

// 	return
// }
func BoolTagInArray(slice []string, tag string) bool {
	for _, item := range slice {
		if item == tag {
			return true
		}
	}
	return false
}
func BoolTagInArrayInt(slice []int, tag int) bool {
	for _, item := range slice {
		if item == tag {
			return true
		}
	}
	return false
}
func BoolTagMapInArrMap(tagMap, arrMap map[string]string) bool {
	for tagKey, tagValue := range tagMap {
		selectValue, ok := arrMap[tagKey]
		if ok && tagValue == selectValue {

		} else {
			return false
		}
	}
	return true
}
func (p *K8sResource) GetPod(ctx context.Context, name, nameSpace string) (svcs []businessManagement.ServiceInstance, err error) {
	ctx, cancel := context.WithTimeout(ctx, ServiceMonitorTimeout)
	//pods := []corev1.Pod{}
	defer cancel()
	podL, err := p.Client.CoreV1().Pods(nameSpace).Get(ctx, name, metav1.GetOptions{})

	s, _ := json.Marshal(podL)
	klog.Infof("pod info: %s", s)

	if err != nil {
		klog.Error("p.client.CoreV1().Pods(nameSpace).Get name:%s,err=%s", name, err)
		return svcs, err
	}
	svcs = append(svcs, businessManagement.ServiceInstance{
		//Id: pod.UID,
		Name: podL.Name + ":" + string(podL.UID),
	})

	return svcs, nil
}
func GetAllPodsByNSandDeploy() {

}
func GetHost(rows []serverModel.PhysicalHostData, vmDL []aggregate.VmDetail, hostName string) (hostIp, hName, outIp, regionCode, regionName, azCode, azName, vmId string, hostType, hostId int) {
	//循环赋值
	// defer rows.Close()
	// for rows.Next() {
	// 	var dr serverModel.PhysicalHostData
	// 	dao.AssetDB.ScanRows(rows, &dr)
	// 	if dr.Name == hostName {
	// 		return dr.Ip, dr.Name, dr.OutbandIP, dr.HostRegionCode, dr.HostRegionName, dr.HostAzCode, dr.HostAzName, "", 0, dr.Uid
	// 	}
	// }
	for _, host := range rows {
		if host.Name == hostName {
			return host.Ip, host.Name, host.OutbandIP, host.HostRegionCode, host.HostRegionName, host.HostAzCode, host.HostAzName, "", 0, host.Uid
		}
	}
	for _, vm := range vmDL {
		if vm.HostName == hostName || (vm.HostName+".cloud.local") == hostName {
			return vm.InnerIp, "", vm.InternetIpV4, vm.RegionCode, vm.Region, vm.AzCode, vm.Az, vm.Id, 1, 0
		}
	}
	return
}

func (p *K8sResource) GetMetrics(ctx context.Context, ns, podName string) (podMetric businessManagement.PodMetrics, err error) {
	//data, err := p.Client.RESTClient().Get().AbsPath("apis/metrics.k8s.io/v1beta1/pods").DoRaw(ctx)
	url := fmt.Sprintf("apis/metrics.k8s.io/v1beta1/namespaces/%s/pods/%s", ns, podName)
	data, err := p.Client.RESTClient().Get().AbsPath(url).DoRaw(ctx)
	if err != nil {
		return podMetric, err
	}
	klog.Info("Get metrics start:")
	klog.Info(string(data))

	err = json.Unmarshal(data, &podMetric)
	return podMetric, err
}

func (p *K8sResource) GetPodOne(ctx context.Context, nameSpace, name string) (pd *coreV1.Pod, err error) {
	ctx, cancel := context.WithTimeout(ctx, ServiceMonitorTimeout)
	defer cancel()
	pod, err := p.Client.CoreV1().Pods(nameSpace).Get(ctx, name, metav1.GetOptions{})

	s, _ := json.Marshal(pod)
	if err != nil {
		klog.Error("p.client.CoreV1().Pods(nameSpace).Get name:%s,err=%s", name, err)
		return pod, err
	}
	klog.Infof("pod info: %s", string(s))

	return pod, nil
}

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/pkg/service/eip/segment.go
```golang
package eip

import (
	"context"
	"encoding/json"
	"fmt"
	"k8s.io/klog/v2"
	"luban-cmdb-api/pkg/dao/basic"
	"luban-cmdb-api/pkg/gredis"
	"luban-cmdb-api/pkg/models/eip"
	"strings"
	"time"
)

func (s *Service) AllSegment() (ls []eip.Segment, err error) {
	//获取region list
	regionList, err := basic.GetRegionList(basic.Region{})
	if err != nil {
		return
	}
	//根据region_code_aggregate 获取到segments列表
	for _, region := range regionList {
		results, err := s.RegionSegment(region)
		if err != nil {
			klog.Errorf("eip region list get error %v", err)
			continue
		}
		ls = append(ls, results...)
	}
	return
}

//从redis中获取eip某个区域的网段信息
func (s *Service) RegionSegment(region basic.Region) (ls []eip.Segment, err error) {
	results, err := gredis.HGetAll(context.TODO(), fmt.Sprintf("cmdb_eip_region_%s", region.RegionCodeAggregate))
	if err != nil {
		return
	}
	for _, v := range results {
		var seg eip.Segment
		err = json.Unmarshal([]byte(v), &seg)
		if err != nil {
			klog.Errorf("eip region info Unmarshal error %v, data=%s", err, v)
			continue
		}
		seg.RegionCode = region.RegionCode
		seg.RegionName = region.RegionName
		//计算使用率
		seg.UsedRatio = float64(seg.UsedIpCount) / float64(seg.IpCount)
		ls = append(ls, seg)
	}
	return
}

// CidrListByRegions 根据region下的cidr列表
func (s *Service) CidrListByRegions(regions []string) (cidrs []string) {
	for _, reg := range regions {
		key := gredis.RegSegMappingKeyPrefix + reg
		ctx, celf := context.WithTimeout(context.Background(), 5*time.Second)
		defer celf()
		cidrList, err := gredis.SMembers(ctx, key)
		if err != nil {
			continue
		}
		cidrs = append(cidrs, cidrList...)
	}
	return cidrs
}

func (s *Service) EipListByCidrs(cidrs []string) (eips []eip.Eip, err error) {
	for _, cidr := range cidrs {
		key := gredis.SegEipKeyPrefix + cidr
		total := int64(0)
		ctx, celf := context.WithTimeout(context.Background(), 5*time.Second)
		defer celf()
		total, err = gredis.ZCard(ctx, key)
		if err != nil {
			return eips, err
		}
		var eipListStr []string
		ctx, celf = context.WithTimeout(context.Background(), 5*time.Second)
		defer celf()
		eipListStr, err = gredis.ZRange(ctx, key, 0, total)
		if err != nil {
			return eips, err
		}
		var eipListTemp = make(eip.EipSlice, len(eipListStr))
		eipSliceStr := "[" + strings.Join(eipListStr, ",") + "]"
		err = json.Unmarshal([]byte(eipSliceStr), &eipListTemp)
		if err != nil {
			return eips, err
		}
		eips = append(eips, eipListTemp...)
	}
	return eips, nil
}

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/pkg/service/eip/eip.go
```golang
package eip

import (
	"context"
	"encoding/json"
	"errors"
	"luban-cmdb-api/pkg/dao/basic"
	"luban-cmdb-api/pkg/gredis"
	"luban-cmdb-api/pkg/models/eip"
	"luban-cmdb-api/pkg/utils/collection"
	"sort"
	"strings"
	"time"

	"k8s.io/klog/v2"
)

type Service struct {
}

// func (s *Service) GetEipUtilization(regions []string) ([]eip.Utilization, error) {
func (s *Service) GetEipUtilization(aggregateCode string) (map[string]interface{}, error) {
	//panic("implement me")
	var (
		//utilizationList = make([]eip.Utilization, 0)
		err             error
		overViewMap     = make(map[string]interface{})
		overViewContent = make([]interface{}, 0)
		aggregateCodes  []string
		regionList      []basic.Region
	)
	utilizationMap := map[string]interface{}{
		"info": map[string]string{
			"unitType": "percent",
		},
	}
	//if len(regions) > 1 {
	if aggregateCode == "" {
		aggregateCodes, err = basic.GetAllRegionAggregateCode()
		if err != nil {
			return overViewMap, err
		}
		sqlFilter := map[string]interface{}{
			"region_code_aggregate": aggregateCodes,
		}
		regionList, err = basic.GetRegionListByRegionMap(sqlFilter)
		for _, region := range regionList {
			var (
				subSegList eip.SegmentSlice
				//utilization eip.Utilization
				ipCount     = 0
				usedIpCount = 0
			)
			subSegList, err = s.RegionSegment(region)
			if err != nil {
				//return utilizationList, err
				return overViewMap, err
			}
			if len(subSegList) == 0 {
				continue
			}
			for _, segment := range subSegList {
				ipCount += segment.IpCount
				usedIpCount += segment.UsedIpCount
			}
			//utilization = eip.Utilization{
			//	Id:         region.RegionCodeAggregate,
			//	RegionCode: region.RegionCode,
			//	RegionName: region.RegionName,
			//	UsedRatio:  float64(usedIpCount) / float64(ipCount),
			//}
			//utilizationList = append(utilizationList, utilization)
			utilizationValue := map[string]interface{}{
				"name":  region.RegionName,
				"value": float64(usedIpCount) / float64(ipCount),
				"unit":  "%",
			}
			overViewContent = append(overViewContent, utilizationValue)
		}
		utilizationMap["values"] = overViewContent
		overViewMap["resourcePoolAllRegionOverview"] = []interface{}{utilizationMap}
	} else {
		var region basic.Region
		region, err = basic.GetRegion(basic.Region{RegionCodeAggregate: aggregateCode})
		if err != nil {
			return overViewMap, err
		}
		var (
			subSegList eip.SegmentSlice
		)
		subSegList, err = s.RegionSegment(region)
		if err != nil {
			//return utilizationList, err
			return overViewMap, err
		}
		for _, segment := range subSegList {
			//utilization := eip.Utilization{
			//	Id:         segment.Id,
			//	RegionCode: region.RegionCode,
			//	RegionName: region.RegionName,
			//	Date:       segment.CreateTime,
			//	Cidr:       segment.Cidr,
			//	UsedRatio:  segment.UsedRatio,
			//}
			//utilizationList = append(utilizationList, utilization)
			utilizationValue := map[string]interface{}{
				"name":  segment.Cidr,
				"value": segment.UsedRatio,
				"unit":  "%",
			}
			overViewContent = append(overViewContent, utilizationValue)
		}
		utilizationMap["values"] = overViewContent
		overViewMap["resourcePoolAllRegionOverview"] = []interface{}{utilizationMap}
	}
	//return utilizationList, err
	return overViewMap, err
}

func (s *Service) GetEipUtilizationTrend(begin, end int64, regions []string) ([]eip.UtilizationTrend, error) {
	//panic("implement me")
	return nil, nil
}

func (s *Service) GetSegmentList(params eip.SegParams) (eip.EipResponse, error) {
	if params.PageNo < 1 || params.PageSize < 1 {
		return eip.EipResponse{}, errors.New("PageNo or PageSize must not less than 1")
	}
	var (
		eipResponse = eip.EipResponse{
			PageNo:   params.PageNo,
			PageSize: params.PageSize,
		}
		reg      = params.Region
		segSlice = make(eip.SegmentSlice, 0)
		err      error
	)
	if reg == "" {
		segSlice, err = s.AllSegment()
		if err != nil {
			klog.Errorf("eip region list get error %v", err)
			return eipResponse, err
		}
	} else {
		region := basic.Region{RegionCodeAggregate: reg}
		segSlice, err = s.RegionSegment(region)
		if err != nil {
			klog.Errorf("eip region list get error %v", err)
			return eipResponse, err
		}
	}
	// 这里对结果进行一下IP版本以及网段的筛选
	if (len(params.IpVersion) != 0 && len(params.IpVersion) != 2) || params.Cidr != "" {
		temp := make(eip.SegmentSlice, 0, len(segSlice))
		for i := 0; i < len(segSlice); i++ {
			if params.Cidr != "" && !strings.Contains(segSlice[i].Cidr, params.Cidr) {
				continue
			}
			if len(params.IpVersion) != 0 && len(params.IpVersion) != 2 && segSlice[i].IpVersion != params.IpVersion[0] {
				continue
			}
			temp = append(temp, segSlice[i])
		}
		segSlice = temp
	}
	//if params.Cidr != "" {
	//	subSegSlice := make(eip.SegmentSlice, 0)
	//	for _, segment := range segSlice {
	//		if segment.Cidr == params.Cidr {
	//			subSegSlice = append(subSegSlice,segment)
	//		}
	//	}
	//	segSlice = subSegSlice
	//}
	sort.Sort(segSlice)
	eipResponse.TotalCount = len(segSlice)
	limit := (eipResponse.PageNo - 1) * eipResponse.PageSize
	offset := limit + eipResponse.PageSize
	if offset > eipResponse.TotalCount {
		offset = eipResponse.TotalCount
	}
	eipResponse.DataList = segSlice[limit:offset]

	return eipResponse, err
}

func (s *Service) GetSegmentByCidr(region, cidr string) (segment eip.Segment, err error) {
	searchKey := gredis.SegsRegKeyPrefix + region
	ctx, celf := context.WithTimeout(context.Background(), 5*time.Second)
	//result, err := gredis.HGet(ctx, fmt.Sprintf("cmdb_eip_region_%s", region), cidr)
	result, err := gredis.HGet(ctx, searchKey, cidr)
	celf()
	if err != nil {
		return
	}
	err = json.Unmarshal([]byte(result), &segment)
	if err != nil {
		return
	}
	return
}

func (s *Service) GetSegmentByCidrList(region, cidrList []string) (eip.SegmentSlice, error) {
	var (
		segmentSlice = make(eip.SegmentSlice, 0)
		err          error
	)

	if len(region) > 0 {
		segmentSlice, err = getSegmentsByAggregateCodes(region, []string{})
		return segmentSlice, err
	} else {
		codes, err := basic.GetAllRegionAggregateCode()
		if err != nil {
			return nil, err
		}
		segmentSlice, err = getSegmentsByAggregateCodes(codes, cidrList)
		return segmentSlice, err
	}
}

func (s *Service) GetEipListBySeg(params eip.GetEipListParams) (eip.EipResponse, error) {
	//panic("implement me")
	var (
		eipResponse = eip.EipResponse{
			PageNo:   params.PageNo,
			PageSize: params.PageSize,
		}
		//setKey   = "cmdb_eip_subnet_" + params.Segment
		setKey   = gredis.SegEipKeyPrefix + params.Segment
		ctx      context.Context
		celf     context.CancelFunc
		total    int64
		offset   int
		limit    int
		sIndex   int64
		eIndex   int64
		err      error
		isFilter = len(params.BoundState) > 0 || len(params.BoundType) > 0 || len(params.WayType) > 0 || len(params.IpVersion) > 0
	)
	//获取数据总量
	ctx, celf = context.WithTimeout(context.Background(), 5*time.Second)
	total, err = gredis.ZCard(ctx, setKey)
	celf()
	if err != nil {
		return eipResponse, err
	}
	//此处若params.PageNo为0，则认为非接口请求,而是其他函数在共用此函数逻辑
	if params.PageNo == 0 {
		offset = 0
		limit = int(total)
	} else {
		offset = (params.PageNo - 1) * params.PageSize
		limit = offset + params.PageSize
	}
	//sIndex, eIndex = int64(offset), int64(limit)
	sIndex, eIndex = 0, total
	//if isFilter {
	//	sIndex = 0
	//	eIndex = total
	//}
	ctx, celf = context.WithTimeout(context.Background(), 5*time.Second)
	eipListStr, err := gredis.ZRange(ctx, setKey, sIndex, eIndex)
	celf()
	if err != nil {
		return eipResponse, err
	}
	var eipList = make(eip.EipSlice, len(eipListStr))
	//for i, str := range eipListStr {
	//	elsticip := &eip.Eip{}
	//	json.Unmarshal([]byte(str))
	//}
	eipSliceStr := "[" + strings.Join(eipListStr, ",") + "]"
	err = json.Unmarshal([]byte(eipSliceStr), &eipList)
	if err != nil {
		return eipResponse, err
	}
	sort.Sort(eipList)
	if isFilter {
		eipList = eipFilter(eipList, params)
	}
	//if len(eipList) > limit {
	//	limit = len(eipList)
	//}
	//eipResponse.TotalCount = int(total)
	eipResponse.TotalCount = len(eipList)
	if offset > len(eipList) {
		return eipResponse, errors.New("pageNo. is too large")
	}
	if limit > len(eipList) {
		limit = len(eipList)
	}
	eipResponse.DataList = eipList[offset:limit]
	return eipResponse, err
}

func (s *Service) GetEipOverview(region string) (eip.EipOverview, error) {
	var (
		res     eip.EipOverview
		regList []string
		cidrs   []string
		eipList eip.EipSlice
		err     error
	)
	if region == "" {
		regList, err = basic.GetAllRegionAggregateCode()
		if err != nil {
			return res, err
		}
	} else {
		regList = append(regList, region)
	}
	cidrs = s.CidrListByRegions(regList)

	eipList, err = s.EipListByCidrs(cidrs)

	stateOverview := eip.EipOverviewSlot{
		Info: eip.EipOverviewSlotInfo{Name: "弹性IP状态", UnitType: "number", Unit: "个"},
	}
	stateOverview.Values = []eip.EipOverviewSlotValue{
		{Name: "保留", Code: "0"},
		{Name: "未分配", Code: "1"},
		{Name: "已分配未绑定", Code: "2"},
		{Name: "已绑定", Code: "3"},
	}
	boundTypeOverview := eip.EipOverviewSlot{
		Info: eip.EipOverviewSlotInfo{Name: "绑定实例类型", UnitType: "number", Unit: "个"},
	}
	boundTypeOverview.Values = []eip.EipOverviewSlotValue{
		{Name: "SLB", Code: "lb"},
		{Name: "NAT", Code: "nat"},
		{Name: "云主机", Code: "vpc_vm"},
		{Name: "未绑定", Code: "notBounded"},
	}
	distributionOverview := eip.EipOverviewSlot{
		Info: eip.EipOverviewSlotInfo{Name: "弹性IP分布概览", UnitType: "number", Unit: "个"},
	}
	bucket := make(map[string]eip.EipOverviewSlotValue)

	for _, e := range eipList {
		//stateOverview.Values[3-e.BoundState].Value++ // 注意这里BoundState加了新东西修改的话可能会panic
		// 对已绑定的资源进行绑定实例类型统计
		switch e.BoundType {
		case "vpc_vm":
			boundTypeOverview.Values[2].Value++
			//stateOverview.Values[3].Value++
		case "nat":
			boundTypeOverview.Values[1].Value++
			//stateOverview.Values[3].Value++
		case "lb":
			boundTypeOverview.Values[0].Value++
			//stateOverview.Values[3].Value++
		default:
			boundTypeOverview.Values[3].Value++
		}
		stateOverview.Values[e.BoundState].Value++

		if slot, ok := bucket[e.RegionCode]; ok {
			slot.Value++
			bucket[e.RegionCode] = slot
		} else {
			bucket[e.RegionCode] = eip.EipOverviewSlotValue{
				Name:  e.RegionName,
				Code:  e.RegionAggregateCode,
				Value: 1,
			}
		}
	}
	distributionOverview.Values = make([]eip.EipOverviewSlotValue, 0, len(bucket))
	for _, values := range bucket {
		distributionOverview.Values = append(distributionOverview.Values, values)
	}
	stateOverview.Info.Value = stateOverview.Values[0].Value + stateOverview.Values[1].Value + stateOverview.Values[2].Value + stateOverview.Values[3].Value
	boundTypeOverview.Info.Value = boundTypeOverview.Values[0].Value + boundTypeOverview.Values[1].Value + boundTypeOverview.Values[2].Value + boundTypeOverview.Values[3].Value
	res.StateOverview = append(res.StateOverview, stateOverview)
	res.BoundTypeOverview = append(res.BoundTypeOverview, boundTypeOverview)
	res.DistributionOverview = append(res.DistributionOverview, distributionOverview)
	return res, nil
}

func (s *Service) GetEipResourceList(params eip.GetEipResourceListParams) (eip.EipResponse, error) {
	var (
		regList     = params.Regions
		eipResponse = eip.EipResponse{}
		err         error
		eipList     eip.EipSlice
		cidrs       []string
	)
	filter := eip.GetEipListParams{
		//Segment:    params.Cidr,
		BoundType:   params.BoundType,
		WayType:     params.WayType,
		IpVersion:   params.IpVersion,
		BoundState:  params.BoundState,
		PoolName:    params.PoolName,
		SearchType:  params.SearchType,
		SearchValue: params.SearchValue,
	}
	//if params.Cidr != "" {
	//	eipResponse, err = s.GetEipListBySeg(filter)
	//	if err != nil {
	//		return eipResponse, err
	//	}
	//	eipList = eipResponse.DataList.(eip.EipSlice)
	//} else {
	//	if params.Region == "" {
	//		regList, err = basic.GetAllRegionAggregateCode()
	//		if err != nil {
	//			return eipResponse, err
	//		}
	//	} else {
	//		regList = append(regList, params.Region)
	//	}
	//	cidrs = s.CidrListByRegions(regList)
	//	eipList, err = s.EipListByCidrs(cidrs)
	//
	//	isFilter := len(params.BoundState) > 0 || len(params.BoundType) > 0 || len(params.WayType) > 0 || len(params.IpVersion) > 0
	//	if isFilter {
	//		eipList = eipFilter(eipList, filter)
	//	}
	//}
	//TODO  region: "SHPBSRegionOne" ,为啥要用这种样式，搞不懂
	if params.Region == "" {
		regList, err = basic.GetAllRegionAggregateCode()
		if err != nil {
			return eipResponse, err
		}
	} else {
		regList = append(regList, params.Region)
	}
	cidrs = s.CidrListByRegions(regList)
	eipList, err = s.EipListByCidrs(cidrs)

	//XGW与SGW通用，属于XGW也属于SGW集群。数据源没有，为了列表能搜索到，硬编码添加
	for i, e := range eipList {
		for _, p := range e.PoolNames {
			if p == "XGW-EIP" {
				eipList[i].PoolNames = append(eipList[i].PoolNames, "SGW-EIP")
				break
			}
		}
	}

	//列表可选条件
	resourcePoolSet := collection.NewSet()
	for _, e := range eipList {
		for _, name := range e.PoolNames {
			resourcePoolSet.Add(name)
		}
	}
	listOptionalCondition := make(map[string][]interface{})
	listOptionalCondition["poolName"] = resourcePoolSet.Keys()

	sort.Sort(eipList)
	isFilter := len(params.BoundState) > 0 || len(params.BoundType) > 0 || len(params.WayType) > 0 ||
		len(params.IpVersion) > 0 || params.PoolName != "" || params.SearchType != ""
	if isFilter {
		eipList = eipFilter(eipList, filter)
	}

	// 接着过滤cidr
	if len(params.Cidr) != 0 {
		tempEipList := make(eip.EipSlice, 0, len(eipList))
		for _, c := range params.Cidr {
			for i := 0; i < len(eipList); i++ {
				if eipList[i].Cidr == c {
					tempEipList = append(tempEipList, eipList[i])
				}
			}
		}
		eipList = tempEipList
	}

	//模糊搜索
	//SearchType  string `json:"searchType"`  // 搜索类型 (ipAddr/tenantId/boundName)
	//SearchValue string `json:"searchValue"` // 搜索值 (注意要支持模糊搜索)
	if params.SearchType != "" && params.SearchValue != "" {
		eipListTemp := make(eip.EipSlice, 0)
		for _, e := range eipList {
			switch params.SearchType {
			case "ipAddr":
				if strings.Contains(e.IpAddr, params.SearchValue) {
					eipListTemp = append(eipListTemp, e)
				}
			case "tenantId":
				if strings.Contains(e.TenantId, params.SearchValue) {
					eipListTemp = append(eipListTemp, e)
				}
			case "boundId":
				if strings.Contains(e.BoundId, params.SearchValue) {
					eipListTemp = append(eipListTemp, e)
				}
			case "boundName":
				if strings.Contains(e.BoundName, params.SearchValue) {
					eipListTemp = append(eipListTemp, e)
				}
			}
		}
		eipList = eipListTemp
	}

	eipResponse.PageNo = params.PageNo
	eipResponse.PageSize = params.PageSize

	eipResponse.TotalCount = len(eipList)
	offset := (params.PageNo - 1) * params.PageSize
	limit := offset + params.PageSize
	if len(eipList) < limit {
		limit = len(eipList)
	}
	if offset > limit {
		offset = 0
	}

	eipResponse.DataList = eipList[offset:limit]
	eipResponse.ListOptionalCondition = listOptionalCondition
	return eipResponse, nil
}

func (s *Service) GetBoundInstanceDetail(ipAddr string) (eip.BoundInstanceResponse, error) {
	var res eip.BoundInstanceResponse
	ctx, celf := context.WithTimeout(context.Background(), 5*time.Second)
	defer celf()
	jsonStr, err := gredis.HGet(ctx, gredis.AllIpEntityKey, ipAddr)
	if err != nil {
		return res, err
	}
	err = json.Unmarshal([]byte(jsonStr), &res)
	if err != nil {
		return res, err
	}
	boundId := res.BoundId
	instance, err := s.GetBoundInstance(boundId)
	//if err != nil {
	//	return res, err
	//}
	res.Id = instance.Id
	res.Name = instance.Name
	res.Flavor = instance.Flavor
	res.Status = instance.Status
	res.Aggregate = instance.Aggregate
	res.Hypervisor = instance.Hypervisor
	//return res, err
	return res, nil
}

func (s *Service) GetBoundInstance(boundId string) (eip.BoundInstance, error) {
	var res eip.BoundInstance
	ctx, celf := context.WithTimeout(context.Background(), 5*time.Second)
	defer celf()
	jsonStr, err := gredis.HGet(ctx, gredis.AggregatesVmMapKey, boundId)
	if err != nil {
		return res, err
	}
	err = json.Unmarshal([]byte(jsonStr), &res)
	return res, err
}

func NewService() *Service {
	return &Service{}
}

func eipFilter(eipList eip.EipSlice, params eip.GetEipListParams) eip.EipSlice {

	//TODO 特殊处理，监控页面只返回已绑定和已分配未绑定的数据
	tempList := make(eip.EipSlice, 0)
	for _, e := range eipList {
		//0:保留；1:未分配；2：已分配未绑定；3已绑定
		if e.BoundState == 2 || e.BoundState == 3 {
			tempList = append(tempList, e)
		}
	}
	eipList = tempList

	if len(params.BoundState) > 0 {
		eList := make(eip.EipSlice, 0)
		for _, e := range eipList {
			for _, state := range params.BoundState {
				if e.BoundState == state {
					eList = append(eList, e)
				}
			}
		}
		eipList = eList
	}
	if len(params.BoundType) > 0 {
		eList := make(eip.EipSlice, 0)
		for _, e := range eipList {
			for _, bty := range params.BoundType {
				//notBounded 选择boundType为空的值
				if bty == "notBounded" && e.BoundType == "" {
					eList = append(eList, e)
				}
				//其他绑定类型
				if e.BoundType == bty {
					eList = append(eList, e)
				}
			}
		}
		eipList = eList
	}
	if len(params.WayType) > 0 {
		eList := make(eip.EipSlice, 0)
		for _, e := range eipList {
			for _, wty := range params.WayType {
				if e.WayType == wty {
					eList = append(eList, e)
				}
			}
		}
		eipList = eList
	}
	if len(params.IpVersion) > 0 {
		eList := make(eip.EipSlice, 0)
		for _, e := range eipList {
			for _, ipv := range params.IpVersion {
				if e.IpVersion == ipv {
					eList = append(eList, e)
				}
			}
		}
		eipList = eList
	}
	if params.PoolName != "" {
		eList := make(eip.EipSlice, 0)
		for _, e := range eipList {
			var ok bool
			for _, name := range e.PoolNames {
				ok = name == params.PoolName
				if ok {
					break
				}
			}
			if ok {
				eList = append(eList, e)
			}
		}
		eipList = eList
	}
	return eipList
}

func getSegmentsByAggregateCodes(codes, cidrList []string) (eip.SegmentSlice, error) {
	var (
		segStrList   = make([]string, 0)
		segmentSlice = make(eip.SegmentSlice, 0)
		err          error
	)
	for _, reg := range codes {
		segsKey := gredis.SegsRegKeyPrefix + reg
		ctx, celf := context.WithTimeout(context.Background(), 5*time.Second)
		if len(cidrList) > 0 {
			segmentList, err := gredis.HMGet(ctx, segsKey, cidrList)
			celf()
			if err != nil {
				return nil, err
			}
			for _, inter := range segmentList {
				if str, ok := inter.(string); ok {
					segStrList = append(segStrList, str)
				}
			}
		} else {
			segmentMap, err := gredis.HGetAll(ctx, segsKey)
			celf()
			if err != nil {
				return nil, err
			}
			for _, seg := range segmentMap {
				segStrList = append(segStrList, seg)
			}
		}
		celf()
		if err != nil {
			return nil, err
		}

	}
	segStr := "[" + strings.Join(segStrList, ",") + "]"
	err = json.Unmarshal([]byte(segStr), &segmentSlice)
	if err != nil {
		return nil, err
	}
	return segmentSlice, err
}

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/pkg/client/dgraph/dgraph.go
```golang
package dgraph

import (
	"os"
	"sync"

	"github.com/dgraph-io/dgo/v200"
	"github.com/dgraph-io/dgo/v200/protos/api"
	"google.golang.org/grpc"
	"k8s.io/klog/v2"
)

var (
	once                sync.Once
	Dgraph              *dgo.Dgraph
	defaultDgraphServer string
)

func NewClient() (*dgo.Dgraph, error) {
	var err error
	defaultDgraphServer = os.Getenv("DefaultDgraphServer")
	if defaultDgraphServer == "" {
		defaultDgraphServer = "luban.dgraph9080.galaxy.cloud:80"
	}
	once.Do(func() {
		//con, err := grpc.Dial("10.177.152.168:9080", grpc.WithInsecure())
		con, err := grpc.Dial(defaultDgraphServer, grpc.WithInsecure())
		if err != nil {
			klog.Error("connect grpc error")
		}
		//defer con.Close()
		Dgraph = dgo.NewDgraphClient(api.NewDgraphClient(con))
	})
	return Dgraph, err
}

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/pkg/client/idp/idp.go
```golang
package idp

import (
	"encoding/json"
	"io"
	"net/http"

	"github.com/zeromicro/go-zero/rest/httpc"

	"github.com/pkg/errors"
)

type (
	Client struct {
		Host string
	}

	Config struct {
		Host string
	}
)

func NewClient(conf Config) *Client {
	if conf.Host == "" {
		//conf.Host = "http://luban.cloud.lakala.com"
		conf.Host = "http://idp.luban"

	}
	return &Client{
		Host: conf.Host,
	}
}

func (c *Client) GetUserInfo(authSessionStr string) (UserInfo, error) {
	var userInfo UserInfo
	tag := "x-auth-session"

	//curl --location --request GET 'http://luban.cloud.lakala.com/idp/v1/userInfo' \
	//> --header 'Accept: */*' \
	//> --header 'Accept-Language: zh-CN,zh;q=0.9,en;q=0.8,en-US;q=0.7' \
	//> --header 'Cookie: x-auth-session=84675b6a-a8bb-49c6-ad32-0e460f0ae5e1'

	//http://luban.cloud.lakala.com/idp/v1/userInfo
	req, err := http.NewRequest("GET", c.Host+"/idp/v1/userInfo", nil)
	if err != nil {
		return userInfo, errors.Wrap(err, "GetUserInfo - NewRequest idp fail")
	}
	req.Header.Set("Accept", "*/*")
	req.Header.Set("Cookie", tag+"="+authSessionStr)
	resp, err := http.DefaultClient.Do(req)
	if err != nil {
		return userInfo, errors.Wrap(err, "GetUserInfo - req idp fail")
	}
	defer resp.Body.Close()

	body, err := io.ReadAll(resp.Body)
	if err != nil {
		return userInfo, errors.Wrap(err, "GetUserInfo - ReadAll idp fail")
	}

	var idpRsp IdpRsp
	err = json.Unmarshal(body, &idpRsp)
	if err != nil {
		return userInfo, errors.Wrap(err, "GetUserInfo - Unmarshal idp fail")
	}

	if idpRsp.Code != 200 {
		return userInfo, errors.Wrap(err, "GetUserInfo - http code idp fail:"+idpRsp.Message)
	}

	// convert map to json
	jsonString, err := json.Marshal(idpRsp.Data)
	if err != nil {
		return userInfo, errors.Wrap(err, "GetUserInfo - idpRsp.Data marshal fail")
	}

	// convert json to struct
	u := UserInfo{}
	err = json.Unmarshal(jsonString, &u)
	if err != nil {
		return userInfo, errors.Wrap(err, "GetUserInfo - idpRsp.Data Unmarshal fail")
	}
	return u, nil
}

func (c *Client) GetUserInfo1(authSessionStr string) (UserInfo, error) {
	var userInfo UserInfo
	tag := "x-auth-session"

	//curl --location --request GET 'http://luban.cloud.lakala.com/idp/v1/userInfo' \
	//> --header 'Accept: */*' \
	//> --header 'Accept-Language: zh-CN,zh;q=0.9,en;q=0.8,en-US;q=0.7' \
	//> --header 'Cookie: x-auth-session=84675b6a-a8bb-49c6-ad32-0e460f0ae5e1'

	//http://luban.cloud.lakala.com/idp/v1/userInfo
	req, err := http.NewRequest("GET", c.Host+"/idp/v1/userInfo", nil)
	if err != nil {
		return userInfo, errors.Wrap(err, "GetUserInfo - NewRequest idp fail")
	}
	req.Header.Set("Accept", "*/*")
	req.Header.Set("Cookie", tag+"="+authSessionStr)
	resp, err := httpc.DoRequest(req)
	if err != nil {
		return userInfo, errors.Wrap(err, "GetUserInfo - req idp fail")
	}

	type Info struct {
		IdpRsp
		Data UserInfo `json:"data"`
	}

	idpRsp := Info{}
	err = httpc.ParseJsonBody(resp, &idpRsp)
	if err != nil {
		return userInfo, errors.Wrap(err, "GetUserInfo - Unmarshal idp fail")
	}

	if idpRsp.Code != 200 {
		return userInfo, errors.Wrap(err, "GetUserInfo - http code idp fail:"+idpRsp.Message)
	}
	userInfo = idpRsp.Data
	return userInfo, nil
}

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/pkg/client/idp/types.go
```golang
package idp

type IdpRsp struct {
	Message string `json:"message"`
	Code    int    `json:"code"`
	Data    any    `json:"data"`
}

type UserInfo struct {
	UserID          string `json:"user_id"`
	RefreshToken    string `json:"refresh_token"`
	AccessToken     string `json:"access_token"`
	Username        string `json:"username"`
	Email           string `json:"email"`
	TelephoneNumber string `json:"telephone_number"`
	DepartmentID    string `json:"department_id"`
}

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/pkg/client/idp/idp_test.go
```golang
package idp

import (
	"testing"
)

func Test1(t *testing.T) {
	client := NewClient(Config{})
	userinfo, err := client.GetUserInfo("")
	if err != nil {
		t.Fatal(err)
	}
	t.Logf("%+v", userinfo)
}

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/pkg/client/identity/identity.go
```golang
package identity

import (
	"luban-cmdb-api/pkg/apiserver/config"

	"github.com/gophercloud/gophercloud"
	"github.com/gophercloud/gophercloud/openstack"
	"k8s.io/klog/v2"
)

func NewClient(config config.Config) (*gophercloud.ServiceClient, error) {
	opts := gophercloud.AuthOptions{
		IdentityEndpoint: config.AuthURL,
		Username:         config.Username,
		Password:         config.Password,
		TenantName:       config.TenantName,
	}
	klog.Infoln("opts:", opts)
	klog.Infoln("opts:", opts.IdentityEndpoint)
	provider, err := openstack.AuthenticatedClient(opts)
	if err != nil {
		return nil, err
	}
	klog.Infoln("IdentityEndpoint:", provider.IdentityEndpoint)
	client, err := openstack.NewIdentityV2(provider, gophercloud.EndpointOpts{Region: config.RegionName})
	if err != nil {
		return nil, err
	}
	return client, nil
}

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/pkg/client/nova/nova.go
```golang
package nova

import (
	"luban-cmdb-api/pkg/apiserver/config"

	"github.com/gophercloud/gophercloud"
	"github.com/gophercloud/gophercloud/openstack"
)

func NewClient(config config.Config) (*gophercloud.ServiceClient, error) {
	opts := gophercloud.AuthOptions{
		IdentityEndpoint: config.AuthURL,
		Username:         config.Username,
		Password:         config.Password,
		TenantName:       config.TenantName,
	}

	provider, err := openstack.AuthenticatedClient(opts)
	if err != nil {
		return nil, err
	}
	client, err := openstack.NewComputeV2(provider, gophercloud.EndpointOpts{Region: config.RegionName})
	if err != nil {
		return nil, err
	}
	return client, nil
}

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/pkg/signal/signal.go
```golang
package signal

import (
	"context"
	"os"
	"os/signal"
)

var onlyOneSignalHandler = make(chan struct{})
var shutdownHandler chan os.Signal

func SetupSignalHandler() <-chan struct{} {
	return SetupSignalContext().Done()
}

func SetupSignalContext() context.Context {
	close(onlyOneSignalHandler) // panics when called twice
	shutdownHandler = make(chan os.Signal, 2)

	ctx, cancel := context.WithCancel(context.Background())
	signal.Notify(shutdownHandler, shutdownSignals...)
	go func() {
		<-shutdownHandler
		cancel()
		<-shutdownHandler
		os.Exit(1) // second signal
	}()

	return ctx
}

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/pkg/signal/signal_posix.go
```golang
/*
Copyright 2017 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package signal

import (
	"os"
	"syscall"
)

var shutdownSignals = []os.Signal{os.Interrupt, syscall.SIGTERM}

```

File path: /Users/mac/Desktop/woker_code/cmdb-api/pkg/k8slisten/listen.go
```golang
package k8slisten

import (
	"luban-cmdb-api/pkg/apiserver/client"
	"luban-cmdb-api/pkg/dao"
	serverdao "luban-cmdb-api/pkg/dao/server"
	"luban-cmdb-api/pkg/models/businessManagement"
	"strings"
	"sync"
	"time"

	apps "k8s.io/api/apps/v1"
	core "k8s.io/api/core/v1"
	"k8s.io/client-go/informers"
	"k8s.io/client-go/kubernetes"
	"k8s.io/client-go/tools/cache"
	"k8s.io/klog/v2"
)

var mu sync.Mutex

const (
	DEFAULT_REGION = "cn-shanghai-2"
	DEFAULT_AZ     = "cn-shanghai-2a"
	DEFAULT_USER   = "admin"
)

//k8s informer监听
func Start() {
	var cli *kubernetes.Clientset
	if cli = client.GetClient(); cli == nil {
		cli = client.GetOuterClient()
	}
	if cli == nil {
		klog.Errorf("kubernetes client nil")
		return
	}
	stop := make(chan struct{})
	defer close(stop)
	Ns(cli, stop)
	Deploy(cli, stop)
	//Pod(cli, stop)
	<-stop // 永不停止
}

func Pod(cli *kubernetes.Clientset, stop <-chan struct{}) {
	factory := informers.NewSharedInformerFactory(cli, 0)
	podInformer := factory.Core().V1().Pods().Informer()
	go factory.Start(stop)
	podInformer.AddEventHandler(cache.ResourceEventHandlerFuncs{
		AddFunc:    addPod,
		UpdateFunc: nil,
		DeleteFunc: deletePod,
	})
}

func deletePod(obj interface{}) {
	if p, ok := obj.(*core.Pod); ok {
		p.Name = strings.ToUpper(p.Name)
		if len(p.OwnerReferences) == 0 || p.OwnerReferences[0].Kind != "ReplicaSet" { // 只处理Deployment管理的pod
			return
		}
		klog.Infof("delete pod [%s]", p.Name)
		tx := dao.AssetDB.Begin()
		defer tx.Commit()
		klog.Infof("delete pod [%s]", p.Name)
		err := tx.Where("name = ? and region_code = ?", p.Name, DEFAULT_REGION).Delete(&businessManagement.ServiceInstance{}).Error
		if err != nil {
			klog.Errorf("instance (pod) delete failed, err: %s", err)
			tx.Rollback()
			return
		}
		klog.Infof("delete pod [%s] success", p.Name)
	}
}

func addPod(obj interface{}) {
	if p, ok := obj.(*core.Pod); ok {
		mu.Lock()
		defer mu.Unlock()
		p.Name = strings.ToUpper(p.Name)
		if len(p.OwnerReferences) == 0 || p.OwnerReferences[0].Kind != "ReplicaSet" { // 只处理Deployment管理的pod
			return
		}
		tx := dao.AssetDB.Begin()
		defer tx.Commit()
		var count int64
		tx.Model(&businessManagement.ServiceInstance{}).
			Where("name = ?", p.Name).Count(&count)
		if count > 0 {
			return
		}
		klog.Infof("add pod [%s]", p.Name)
		service := businessManagement.Service{}
		if p.Labels["app"] != "" {
			tx.Where("name = ?", strings.ToUpper(p.Labels["app"])).Find(&service) // 约定大家部属的时候app写deploy名
		} else if len(p.Spec.Containers) != 0 {
			tx.Where("name = ?", strings.ToUpper(p.Spec.Containers[0].Name)).Find(&service)
		}
		if service.Id == 0 {
			klog.Errorf("serviceInstance(pod) add failed, deploy not found")
			tx.Rollback()
			return
		}

		now := time.Now()
		newInstance := businessManagement.ServiceInstance{
			Name:       p.Name,
			ServiceId:  service.Id,
			RegionCode: DEFAULT_REGION,
			AzCode:     DEFAULT_AZ,
			Creator:    DEFAULT_USER,
			Updater:    DEFAULT_USER,
			CreateTime: now,
			UpdateTime: now,
		}
		hostId, err := serverdao.GetHostIdByHostName(p.Spec.NodeName)
		if err == nil && hostId != 0 {
			newInstance.HostType = 0
			newInstance.HostId = hostId
		}
		err = tx.Create(&newInstance).Error
		if err != nil {
			klog.Errorf("serviceInstance(pod) add failed, err: %s", err)
			tx.Rollback()
			return
		}
		klog.Infof("add pod [%s] success", p.Name)
	}
}

func Deploy(cli *kubernetes.Clientset, stop <-chan struct{}) {
	factory := informers.NewSharedInformerFactory(cli, 0)
	deployInformer := factory.Apps().V1().Deployments().Informer()
	go factory.Start(stop)
	deployInformer.AddEventHandler(cache.ResourceEventHandlerFuncs{
		AddFunc:    addDeploy,
		UpdateFunc: nil,
		DeleteFunc: deleteDeploy,
	})
}

func deleteDeploy(obj interface{}) {
	deploy := obj.(*apps.Deployment)
	deploy.Name = strings.ToUpper(deploy.Name)
	tx := dao.AssetDB.Begin()
	defer tx.Commit()
	klog.Infof("delete deployment [%s]", deploy.Name)
	oldService := businessManagement.Service{}
	err := tx.Where("name = ? and region_code = ?", deploy.Name, DEFAULT_REGION).Find(&oldService).Error
	if err != nil {
		klog.Errorf("service(deployment) delete failed, err: %s", err)
		tx.Rollback()
		return
	}
	err = tx.Delete(&oldService).Error
	if err != nil {
		klog.Errorf("service(deployment) delete failed, err: %s", err)
		tx.Rollback()
		return
	}

	err = tx.Where("service_id = ?", oldService.Id).Delete(&businessManagement.NodeServices{}).Error
	if err != nil {
		klog.Errorf("service(deployment) delete failed, err: %s", err)
		tx.Rollback()
		return
	}
	klog.Infof("delete deployment [%s] success", deploy.Name)
}

func addDeploy(obj interface{}) {
	mu.Lock()
	defer mu.Unlock()
	var count int64
	deploy := obj.(*apps.Deployment)
	deploy.Name = strings.ToUpper(deploy.Name)
	tx := dao.AssetDB.Begin()
	defer tx.Commit()
	tx.Model(&businessManagement.Service{}).
		Where("name = ?", deploy.Name).Count(&count)
	if count > 0 {
		return
	}
	klog.Infof("add deployment [%s]", deploy.Name)
	now := time.Now()
	newService := businessManagement.Service{
		Name:       deploy.Name,
		RegionCode: DEFAULT_REGION,
		BuiltIn:    1,
		Creator:    DEFAULT_USER,
		CreateTime: now,
		Updater:    DEFAULT_USER,
		UpdateTime: now,
	}
	err := tx.Create(&newService).Error
	if err != nil {
		klog.Errorf("service(deployment) create failed, err: %s", err)
		tx.Rollback()
		return
	}
	node := businessManagement.Node{}
	err = tx.Where("name = ? and region_code = ?", deploy.Namespace, DEFAULT_REGION).Find(&node).Error
	if err != nil {
		klog.Errorf("service(deployment) create failed, err: %s", err)
		tx.Rollback()
		return
	}
	newNodeService := businessManagement.NodeServices{
		ServiceId: newService.Id,
		NodeId:    node.Id,
	}
	err = tx.Create(&newNodeService).Error
	if err != nil {
		klog.Errorf("service(deployment) create failed, err: %s", err)
		tx.Rollback()
		return
	}
	klog.Infof("add deployment [%s] success", deploy.Name)
}

func Ns(cli *kubernetes.Clientset, stop <-chan struct{}) {
	factory := informers.NewSharedInformerFactory(cli, 0)
	nsInformer := factory.Core().V1().Namespaces().Informer()
	go factory.Start(stop)
	nsInformer.AddEventHandler(cache.ResourceEventHandlerFuncs{
		AddFunc:    addNS,
		UpdateFunc: nil,
		DeleteFunc: deleteNS,
	})
}

func deleteNS(obj interface{}) {
	ns := obj.(*core.Namespace)
	ns.Name = strings.ToUpper(ns.Name)
	klog.Infof("delete namespace [%s]", ns.Name)
	tx := dao.AssetDB.Begin()
	defer tx.Commit()
	oldNode := businessManagement.Node{}
	err := tx.Where("name = ? and region_code = ?", ns.Name, DEFAULT_REGION).Find(&oldNode).Error
	//err := tx.Where("name = ? and region_code = ?", oldNode.Name, DEFAULT_REGION).Delete(&oldNode).Error
	if err != nil {
		klog.Errorf("node(namespace) delete failed, err: %s", err)
		tx.Rollback()
		return
	}
	err = tx.Delete(&oldNode).Error
	if err != nil {
		klog.Errorf("node(namespace) delete failed, err: %s", err)
		tx.Rollback()
		return
	}

	err = tx.Where("real_node_id = ?", oldNode.Id).Delete(&businessManagement.NodeRef{}).Error
	if err != nil {
		klog.Errorf("node(namespace) delete failed, err: %s", err)
		tx.Rollback()
		return
	}
	klog.Infof("delete namespace [%s] success", ns.Name)
}

func addNS(obj interface{}) {
	var count int64
	ns := obj.(*core.Namespace)
	ns.Name = strings.ToUpper(ns.Name)
	tx := dao.AssetDB.Begin()
	defer tx.Commit()
	tx.Model(&businessManagement.Node{}).
		Where("name = ? and region_code = ?", ns.Name, DEFAULT_REGION).Count(&count)
	if count > 0 {
		return
	}
	klog.Infof("add namespace [%s]", ns.Name)
	now := time.Now()
	newNode := businessManagement.Node{
		Name:       ns.Name,
		RegionCode: DEFAULT_REGION,
		BuiltIn:    1,
		Creator:    DEFAULT_USER,
		CreateTime: now,
		Updater:    DEFAULT_USER,
		UpdateTime: now,
	}
	err := tx.Create(&newNode).Error
	if err != nil {
		klog.Errorf("node(ns) create failed, err: %s", err)
		tx.Rollback()
		return
	}
	newRefNode := businessManagement.NodeRef{
		RealNodeId: newNode.Id,
		ParentId:   1, // 鲁班树头RefID sql中有写
		TreeId:     2, // 鲁班树ID sql中有写
	}
	err = tx.Create(&newRefNode).Error
	if err != nil {
		tx.Rollback()
		klog.Errorf("node(ns) create failed, err: %s", err)
		return
	}
	klog.Infof("add namespace [%s] success", ns.Name)
}

```

