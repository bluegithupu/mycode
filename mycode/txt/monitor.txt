File path: /Users/mac/Desktop/woker_code/monitor/main.go
```golang
package main

import (
	"ezone.ksyun.com/ezone/luban/monitor/common/cmd"
)

// @title Monitor API Swagger
// @version 2.0
// @BasePath /monitor/v2
// @host    luban.console.galaxy.cloud
func main() {
	cmd.Execute()
}

```

File path: /Users/mac/Desktop/woker_code/monitor/response/response.go
```golang
package response

import (
	"net/http"

	"ezone.ksyun.com/ezone/luban/communal/lib"
	"ezone.ksyun.com/ezone/luban/monitor/common/consts"
	"github.com/gin-gonic/gin"
)

// Response 封装返回的代码
func Response(c *gin.Context, httpStatus, code int, msg string, data interface{}) {
	c.JSON(httpStatus, gin.H{"Code": code, "Message": msg, "Data": data, "RequestID": lib.GetTraceContext(c).TraceId})
	return
}

// Success 成功时的响应
func Success(c *gin.Context, data interface{}) {
	Response(c, http.StatusOK, consts.Success, "success", data)
}

// Failed 失败时的响应
func Failed(c *gin.Context, httpStatus, code int, msg string) {
	Response(c, httpStatus, code, msg, nil)
}

```

File path: /Users/mac/Desktop/woker_code/monitor/docs/docs.go
```golang
// Package docs GENERATED BY SWAG; DO NOT EDIT
// This file was generated by swaggo/swag
package docs

import "github.com/swaggo/swag"

const docTemplate = `{
    "schemes": {{ marshal .Schemes }},
    "swagger": "2.0",
    "info": {
        "description": "{{escape .Description}}",
        "title": "{{.Title}}",
        "contact": {},
        "version": "{{.Version}}"
    },
    "host": "{{.Host}}",
    "basePath": "{{.BasePath}}",
    "paths": {
        "/block_storage/ebs_pool/detail_metric_lines": {
            "post": {
                "description": "Get EbsPool DetailMetricLine",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "EbsPool"
                ],
                "summary": "EbsPool DetailMetricLine",
                "parameters": [
                    {
                        "description": "ebsPool DetailMetricLine Request",
                        "name": "body",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/dto.EbsPoolDetailMetricLineReq"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/dto.EbsPoolDetailMetricLineRsp"
                        }
                    }
                }
            }
        },
        "/block_storage/ebs_pool/detail_metric_overview": {
            "post": {
                "description": "Get EbsPool DetailMetricOverview",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "EbsPool"
                ],
                "summary": "EbsPool DetailMetricOverview",
                "parameters": [
                    {
                        "description": "ebsPool DetailMetricOverview Request",
                        "name": "body",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/dto.EbsPoolDetailMetricReq"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/dto.EbsPoolDetailMetricRsp"
                        }
                    }
                }
            }
        },
        "/block_storage/ebs_pool/list": {
            "post": {
                "description": "Get EbsPool List",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "EbsPool"
                ],
                "summary": "EbsPool List",
                "parameters": [
                    {
                        "description": "ebsPool List Request",
                        "name": "body",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/dto.EbsPoolListReq"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/dto.EbsPoolListReq"
                        }
                    }
                }
            }
        },
        "/block_storage/ebs_pool/list_optional_condition": {
            "get": {
                "description": "Get EbsPool ListOptionalCondition",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "EbsPool"
                ],
                "summary": "EbsPool ListOptionalCondition",
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/dto.OptionalEbsPoolResult"
                        }
                    }
                }
            }
        },
        "/block_storage/ebs_pool/overview": {
            "post": {
                "description": "Get EbsPool  Overview",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "EbsPool"
                ],
                "summary": "EbsPool  Overview",
                "parameters": [
                    {
                        "description": "ebsPool Overview Request",
                        "name": "body",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/dto.EbsPoolOverviewReq"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/dto.EbsPoolOverviewRsp"
                        }
                    }
                }
            }
        },
        "/block_storage/ebs_pool/overview_alert": {
            "post": {
                "description": "Get EbsPool Alert Overview",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "EbsPool"
                ],
                "summary": "EbsPool Alert Overview",
                "parameters": [
                    {
                        "description": "ebsPool Overview Alert Request",
                        "name": "body",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/dto.EbsPoolOverviewAlertReq"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/dto.EbsPoolOverviewAlertRsp"
                        }
                    }
                }
            }
        },
        "/block_storage/ebs_pool/overview_line": {
            "post": {
                "description": "Get EbsPool Overview",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "EbsPool"
                ],
                "summary": "EbsPool OverviewLine",
                "parameters": [
                    {
                        "description": "ebsPool OverviewLine Request",
                        "name": "body",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/dto.EbsPoolOverviewLineReq"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/dto.EbsPoolOverviewLineRsp"
                        }
                    }
                }
            }
        },
        "/block_storage/ebs_volume/detail_metric": {
            "post": {
                "description": "Get EbsVolume DetailMetric",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "EbsVolume"
                ],
                "summary": "EbsVolume DetailMetric",
                "parameters": [
                    {
                        "description": "ebsVolume detail metric Request",
                        "name": "body",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/dto.EbsVolumeDetailMetricReq"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/dto.EbsVolumeDetailMetricRsp"
                        }
                    }
                }
            }
        },
        "/block_storage/ebs_volume/detail_metric_lines": {
            "post": {
                "description": "Get EbsVolume DetailMetricLine",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "EbsVolume"
                ],
                "summary": "EbsVolume DetailMetricLine",
                "parameters": [
                    {
                        "description": "ebsVolume detail metric Request",
                        "name": "body",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/dto.EbsVolumeDetailMetricLineReq"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/dto.EbsVolumeDetailMetricLineRsp"
                        }
                    }
                }
            }
        },
        "/block_storage/ebs_volume/overview": {
            "post": {
                "description": "Get EbsVolume Overview",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "EbsVolume"
                ],
                "summary": "EbsVolume Overview",
                "parameters": [
                    {
                        "description": "ebsVolume Overview Request",
                        "name": "body",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/dto.EbsVolumeOverviewReq"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/dto.EbsVolumeOverviewRsp"
                        }
                    }
                }
            }
        },
        "/block_storage/ebs_volume/overview_top": {
            "post": {
                "description": "Get EbsVolume OverviewTop",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "EbsVolume"
                ],
                "summary": "EbsVolume OverviewTop",
                "parameters": [
                    {
                        "description": "ebsVolume Overview Top Request",
                        "name": "body",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/dto.EbsVolumeOverviewTopReq"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/dto.EbsVolumeOverviewTopRsp"
                        }
                    }
                }
            }
        },
        "/compute/compute_pool/detail_line": {
            "post": {
                "description": "Get ComputePool Monitor DetailLine",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "computePool"
                ],
                "summary": "ComputePool Monitor DetailLine",
                "parameters": [
                    {
                        "description": "ComputePool Detail Line Request",
                        "name": "body",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/dto.ComputePoolDetailLineReq"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/dto.ComputePoolDetailLineRsp"
                        }
                    }
                }
            }
        },
        "/compute/compute_pool/list": {
            "post": {
                "description": "Get ComputePool Monitor List",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "computePool"
                ],
                "summary": "ComputePool Monitor List",
                "parameters": [
                    {
                        "description": "ComputePool List Request",
                        "name": "body",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/dto.ComputePoolListReq"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/dto.ComputePoolListRsp"
                        }
                    }
                }
            }
        },
        "/compute/compute_pool/overview_alert": {
            "post": {
                "description": "Get ComputePool Alert Overview",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "computePool"
                ],
                "summary": "ComputePool Alert Overview",
                "parameters": [
                    {
                        "description": "ComputePool Overview Alert Request",
                        "name": "body",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/dto.ComputePoolOverviewAlertReq"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/dto.ComputePoolOverviewAlertRsp"
                        }
                    }
                }
            }
        },
        "/compute/compute_pool/overview_line": {
            "post": {
                "description": "Get ComputePool Monitor OverviewLine",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "computePool"
                ],
                "summary": "ComputePool Monitor OverviewLine",
                "parameters": [
                    {
                        "description": "ComputePool Overview Line Request",
                        "name": "body",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/dto.ComputePoolOverviewLineReq"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/dto.ComputePoolOverviewLineRsp"
                        }
                    }
                }
            }
        },
        "/compute/compute_pool/overview_monitor": {
            "post": {
                "description": "Get ComputePool Monitor Overview",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "computePool"
                ],
                "summary": "ComputePool Monitor Overview",
                "parameters": [
                    {
                        "description": "ComputePool Overview Monitor Request",
                        "name": "body",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/dto.ComputePoolOverviewMonitorReq"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/dto.ComputePoolOverviewMonitorRsp"
                        }
                    }
                }
            }
        },
        "/compute/product/vm/detail_metric_lines": {
            "post": {
                "description": "Compute Product Vm detail MetricLines",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "vm"
                ],
                "summary": "Vm Detail MetricLines",
                "parameters": [
                    {
                        "description": "Vm Detail Metrics Request",
                        "name": "body",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/dto.VmDetailMetricLinesReq"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/dto.VmDetailMetricLinesRsp"
                        }
                    }
                }
            }
        },
        "/compute/product/vm/detail_metrics": {
            "post": {
                "description": "Compute Product Vm detail Metrics",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "vm"
                ],
                "summary": "Vm Detail Metrics",
                "parameters": [
                    {
                        "description": "Vm Detail Metrics Request",
                        "name": "body",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/dto.VmDetailMetricsReq"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/dto.VmDetailMetricsRsp"
                        }
                    }
                }
            }
        },
        "/compute/product/vm/overview_monitor": {
            "post": {
                "description": "Compute Product Vm Monitor Overview",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "vm"
                ],
                "summary": "Vm Monitor Overview",
                "parameters": [
                    {
                        "description": "Vm Overview Monitor Request",
                        "name": "body",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/dto.VmOverviewMonitorReq"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/dto.VmOverviewMonitorRsp"
                        }
                    }
                }
            }
        },
        "/compute/product/vm/overview_top": {
            "post": {
                "description": "Compute Product Vm topK Overview",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "vm"
                ],
                "summary": "Vm TopK Overview",
                "parameters": [
                    {
                        "description": "Vm Overview TopK Request",
                        "name": "body",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/dto.VmOverviewTopReq"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/dto.VmOverviewTopRsp"
                        }
                    }
                }
            }
        },
        "/dashboard/compute_pool_line": {
            "post": {
                "description": "Get Dashboard ComputePoolLine",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "dashBoard"
                ],
                "summary": "Dashboard ComputePoolLine",
                "parameters": [
                    {
                        "description": " Dashboard ComputePoolLine Request",
                        "name": "body",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/dto.ComputePoolLineReq"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/dto.ComputePoolLineRsp"
                        }
                    }
                }
            }
        },
        "/dashboard/ebs_pool_line": {
            "post": {
                "description": "Get Dashboard EbsPoolLine",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "dashBoard"
                ],
                "summary": "Dashboard EbsPoolLine",
                "parameters": [
                    {
                        "description": " Dashboard EbsPoolLine Request",
                        "name": "body",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/dto.EbsPoolLineReq"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/dto.EbsPoolLineRsp"
                        }
                    }
                }
            }
        },
        "/dashboard/object_pool_line": {
            "post": {
                "description": "Get Dashboard ObjectPoolLine",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "dashBoard"
                ],
                "summary": "Dashboard ObjectPoolLine",
                "parameters": [
                    {
                        "description": " Dashboard ObjectPoolLine Request",
                        "name": "body",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/dto.ObjectPoolLineReq"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/dto.ObjectPoolLineRsp"
                        }
                    }
                }
            }
        },
        "/object_storage/object_pool/detail_metric_lines": {
            "post": {
                "description": "资源池-对象存储-监控详情-折线图",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "ObjectPool"
                ],
                "summary": "ObjectPool Monitor DetailMetricLines",
                "parameters": [
                    {
                        "description": "object pool detail metric lines request",
                        "name": "body",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/dto.ObjectPoolDetailMetricLineReq"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/dto.ObjectPoolDetailMetricLineRes"
                        }
                    }
                }
            }
        },
        "/object_storage/object_pool/detail_metric_overview": {
            "post": {
                "description": "资源池-对象存储-监控详情-概览",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "ObjectPool"
                ],
                "summary": "ObjectPool Monitor DetailMetricOverview",
                "parameters": [
                    {
                        "description": "object pool detail metric overview request",
                        "name": "body",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/dto.ObjectPoolDetailMetricReq"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/dto.ObjectPoolDetailMetricRes"
                        }
                    }
                }
            }
        },
        "/object_storage/object_pool/list": {
            "post": {
                "description": "资源池-对象存储-监控列表",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "ObjectPool"
                ],
                "summary": "ObjectPool Monitor List",
                "parameters": [
                    {
                        "description": "object pool monitor request",
                        "name": "body",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/dto.ListReq"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/dto.ListRes"
                        }
                    }
                }
            }
        },
        "/object_storage/object_pool/list_optional_condition": {
            "get": {
                "description": "资源池-对象存储-监控详情-可选条件",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "ObjectPool"
                ],
                "summary": "ObjectPool Monitor List optional condition",
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/dto.OptionalObjectPoolResult"
                        }
                    }
                }
            }
        },
        "/object_storage/object_pool/overview_alert": {
            "post": {
                "description": "资源池-对象存储-告警概览",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "ObjectPool"
                ],
                "summary": "ObjectPool Monitor OverviewAlert",
                "parameters": [
                    {
                        "description": "object pool monitor overview alert request",
                        "name": "body",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/dto.OverViewAlertReq"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/dto.OverViewAlertRes"
                        }
                    }
                }
            }
        },
        "/object_storage/object_pool/overview_line": {
            "post": {
                "description": "资源池-对象存储-概览折线图",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "ObjectPool"
                ],
                "summary": "ObjectPool Monitor OverviewLine",
                "parameters": [
                    {
                        "description": "object pool monitor overview line request",
                        "name": "body",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/dto.OverviewLineReq"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/dto.OverViewLineRes"
                        }
                    }
                }
            }
        },
        "/object_storage/object_pool/overview_monitor": {
            "post": {
                "description": "资源池-对象存储-概览",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "ObjectPool"
                ],
                "summary": "ObjectPool Monitor OverviewMonitor",
                "parameters": [
                    {
                        "description": "object pool monitor Overview monitor request",
                        "name": "body",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/dto.OverviewReq"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/dto.OverViewRes"
                        }
                    }
                }
            }
        },
        "/object_storage/object_volume/detail_metric": {
            "post": {
                "description": "云产品-对象存储-监控详情",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "ObjectVolume"
                ],
                "summary": "ObjectVolume Monitor DetailMetric",
                "parameters": [
                    {
                        "description": "object volume monitor detail metric request",
                        "name": "body",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/dto.ObjectVolumeDetailMetricReq"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/dto.ObjectVolumeDetailMetricRes"
                        }
                    }
                }
            }
        },
        "/object_storage/object_volume/detail_metric_lines": {
            "post": {
                "description": "云产品-对象存储-监控详情折线图",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "ObjectVolume"
                ],
                "summary": "ObjectVolume Monitor DetailMetricLines",
                "parameters": [
                    {
                        "description": "object volume monitor detail metric lines request",
                        "name": "body",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/dto.ObjectVolumeDetailMetricLineReq"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/dto.ObjectVolumeDetailMetricLineRes"
                        }
                    }
                }
            }
        },
        "/object_storage/object_volume/overview": {
            "post": {
                "description": "云产品-对象存储-概览",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "ObjectVolume"
                ],
                "summary": "ObjectVolume Monitor Overview",
                "parameters": [
                    {
                        "description": "object volume monitor overview request",
                        "name": "body",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/dto.ObjectVolumeOverviewReq"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/dto.ObjectVolumeOverviewRes"
                        }
                    }
                }
            }
        },
        "/object_storage/object_volume/overview_top": {
            "post": {
                "description": "云产品-对象存储-概览Top",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "ObjectVolume"
                ],
                "summary": "ObjectVolume Monitor OverviewTop",
                "parameters": [
                    {
                        "description": "object volume monitor overview top request",
                        "name": "body",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/dto.ObjectVolumeOverviewTopReq"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/dto.ObjectVolumeOverviewTopRes"
                        }
                    }
                }
            }
        }
    },
    "definitions": {
        "dto.ComputePoolDetailLineReq": {
            "type": "object",
            "properties": {
                "End": {
                    "type": "integer"
                },
                "MetricName": {
                    "type": "string"
                },
                "Name": {
                    "type": "string"
                },
                "Region": {
                    "type": "string"
                },
                "Start": {
                    "type": "integer"
                }
            }
        },
        "dto.ComputePoolDetailLineRsp": {
            "type": "object",
            "properties": {
                "Lines": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/types.BasicOverviewSlot"
                    }
                }
            }
        },
        "dto.ComputePoolLineReq": {
            "type": "object",
            "properties": {
                "Region": {
                    "type": "string"
                }
            }
        },
        "dto.ComputePoolLineRsp": {
            "type": "object",
            "properties": {
                "CpuRate": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/types.BasicOverviewSlot"
                    }
                },
                "DiskRate": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/types.BasicOverviewSlot"
                    }
                },
                "MemoryRate": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/types.BasicOverviewSlot"
                    }
                }
            }
        },
        "dto.ComputePoolListReq": {
            "type": "object",
            "properties": {
                "Az": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "Name": {
                    "type": "string"
                },
                "OrderCode": {
                    "type": "string"
                },
                "OrderType": {
                    "type": "string"
                },
                "PageNo": {
                    "type": "integer"
                },
                "PageSize": {
                    "type": "integer",
                    "maximum": 1000
                },
                "Query": {
                    "$ref": "#/definitions/dto.Query"
                },
                "Region": {
                    "type": "string"
                }
            }
        },
        "dto.ComputePoolListRsp": {
            "type": "object",
            "properties": {
                "DataList": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/dto.ComputePoolMonitor"
                    }
                },
                "PageNo": {
                    "type": "integer"
                },
                "PageSize": {
                    "type": "integer"
                },
                "TotalCount": {
                    "type": "integer"
                }
            }
        },
        "dto.ComputePoolMonitor": {
            "type": "object",
            "properties": {
                "AlertCount": {
                    "type": "integer"
                },
                "Az": {
                    "type": "string"
                },
                "CpuRate": {
                    "type": "number"
                },
                "CpuRemain": {
                    "type": "integer"
                },
                "CpuTotal": {
                    "type": "integer"
                },
                "CpuUsedTotal": {
                    "type": "integer"
                },
                "CreateTime": {
                    "type": "string"
                },
                "DiskRate": {
                    "type": "number"
                },
                "HostCount": {
                    "type": "integer"
                },
                "Id": {
                    "type": "string"
                },
                "MemoryRate": {
                    "type": "number"
                },
                "MemoryRemain": {
                    "type": "number"
                },
                "MemoryTotal": {
                    "type": "number"
                },
                "MemoryUsedTotal": {
                    "type": "number"
                },
                "Name": {
                    "type": "string"
                },
                "PType": {
                    "type": "string"
                },
                "Region": {
                    "type": "string"
                },
                "VmCount": {
                    "type": "integer"
                }
            }
        },
        "dto.ComputePoolOverviewAlertReq": {
            "type": "object",
            "properties": {
                "Az": {
                    "type": "string"
                },
                "Region": {
                    "type": "string"
                }
            }
        },
        "dto.ComputePoolOverviewAlertRsp": {
            "type": "object",
            "properties": {
                "Alerts": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/types.BasicOverviewSlot"
                    }
                }
            }
        },
        "dto.ComputePoolOverviewLineReq": {
            "type": "object",
            "properties": {
                "Az": {
                    "type": "string"
                },
                "End": {
                    "type": "integer"
                },
                "HasPrediction": {
                    "type": "boolean"
                },
                "MetricName": {
                    "type": "string"
                },
                "Region": {
                    "type": "string"
                },
                "Start": {
                    "type": "integer"
                }
            }
        },
        "dto.ComputePoolOverviewLineRsp": {
            "type": "object",
            "properties": {
                "Lines": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/types.BasicOverviewSlot"
                    }
                }
            }
        },
        "dto.ComputePoolOverviewMonitorReq": {
            "type": "object",
            "properties": {
                "Az": {
                    "type": "string"
                },
                "Region": {
                    "type": "string"
                }
            }
        },
        "dto.ComputePoolOverviewMonitorRsp": {
            "type": "object",
            "properties": {
                "Monitors": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/types.BasicOverviewSlot"
                    }
                }
            }
        },
        "dto.EbsPoolDetailMetric": {
            "type": "object",
            "properties": {
                "Kind": {
                    "type": "string"
                },
                "Name": {
                    "type": "string"
                },
                "PoolId": {
                    "type": "string"
                },
                "Unit": {
                    "type": "string"
                },
                "UnitType": {
                    "type": "string"
                },
                "Value": {}
            }
        },
        "dto.EbsPoolDetailMetricLineReq": {
            "type": "object",
            "properties": {
                "Az": {
                    "type": "string"
                },
                "End": {
                    "type": "integer"
                },
                "MetricName": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "PoolType": {
                    "type": "string"
                },
                "Region": {
                    "type": "string"
                },
                "Start": {
                    "type": "integer"
                }
            }
        },
        "dto.EbsPoolDetailMetricLineRsp": {
            "type": "object",
            "properties": {
                "Lines": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/types.BasicOverviewSlot"
                    }
                }
            }
        },
        "dto.EbsPoolDetailMetricReq": {
            "type": "object",
            "properties": {
                "PoolId": {
                    "type": "string"
                }
            }
        },
        "dto.EbsPoolDetailMetricRsp": {
            "type": "object",
            "properties": {
                "ResourceOverview": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/dto.EbsPoolDetailMetric"
                    }
                }
            }
        },
        "dto.EbsPoolLineReq": {
            "type": "object",
            "properties": {
                "Region": {
                    "type": "string"
                }
            }
        },
        "dto.EbsPoolLineRsp": {
            "type": "object",
            "properties": {
                "CapRate": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/types.BasicOverviewSlot"
                    }
                }
            }
        },
        "dto.EbsPoolListReq": {
            "type": "object",
            "properties": {
                "Az": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "OrderCode": {
                    "type": "string"
                },
                "OrderType": {
                    "type": "string"
                },
                "PageNo": {
                    "type": "integer"
                },
                "PageSize": {
                    "type": "integer"
                },
                "PoolType": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "Query": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    }
                },
                "Region": {
                    "type": "string"
                }
            }
        },
        "dto.EbsPoolOverviewAlertReq": {
            "type": "object",
            "properties": {
                "Az": {
                    "type": "string"
                },
                "PoolType": {
                    "type": "string"
                },
                "Region": {
                    "type": "string"
                }
            }
        },
        "dto.EbsPoolOverviewAlertRsp": {
            "type": "object",
            "properties": {
                "Alerts": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/types.BasicOverviewSlot"
                    }
                }
            }
        },
        "dto.EbsPoolOverviewLineReq": {
            "type": "object",
            "properties": {
                "Az": {
                    "type": "string"
                },
                "End": {
                    "type": "integer"
                },
                "HasPrediction": {
                    "type": "boolean"
                },
                "MetricName": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "PoolType": {
                    "type": "string"
                },
                "Region": {
                    "type": "string"
                },
                "Start": {
                    "type": "integer"
                }
            }
        },
        "dto.EbsPoolOverviewLineRsp": {
            "type": "object",
            "properties": {
                "Lines": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/types.BasicOverviewSlot"
                    }
                }
            }
        },
        "dto.EbsPoolOverviewReq": {
            "type": "object",
            "properties": {
                "Az": {
                    "type": "string"
                },
                "PoolType": {
                    "type": "string"
                },
                "Region": {
                    "type": "string"
                }
            }
        },
        "dto.EbsPoolOverviewRsp": {
            "type": "object",
            "properties": {
                "EbsPools": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/types.BasicOverviewSlot"
                    }
                },
                "EbsVolumeBusinessCounts": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/types.BasicOverviewSlot"
                    }
                },
                "EbsVolumePlatformCounts": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/types.BasicOverviewSlot"
                    }
                }
            }
        },
        "dto.EbsVolumeDetailMetric": {
            "type": "object",
            "properties": {
                "Kind": {
                    "type": "string"
                },
                "Name": {
                    "type": "string"
                },
                "PoolId": {
                    "type": "string"
                },
                "Unit": {
                    "type": "string"
                },
                "UnitType": {
                    "type": "string"
                },
                "Value": {}
            }
        },
        "dto.EbsVolumeDetailMetricLineReq": {
            "type": "object",
            "properties": {
                "End": {
                    "type": "integer"
                },
                "Id": {
                    "type": "string"
                },
                "MetricName": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "Start": {
                    "type": "integer"
                }
            }
        },
        "dto.EbsVolumeDetailMetricLineRsp": {
            "type": "object",
            "properties": {
                "Lines": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/types.BasicOverviewSlot"
                    }
                }
            }
        },
        "dto.EbsVolumeDetailMetricReq": {
            "type": "object",
            "properties": {
                "Id": {
                    "type": "string"
                }
            }
        },
        "dto.EbsVolumeDetailMetricRsp": {
            "type": "object",
            "properties": {
                "ResourceOverview": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/dto.EbsVolumeDetailMetric"
                    }
                }
            }
        },
        "dto.EbsVolumeOverviewReq": {
            "type": "object",
            "properties": {
                "Az": {
                    "type": "string"
                },
                "DiskType": {
                    "type": "string"
                },
                "Region": {
                    "type": "string"
                }
            }
        },
        "dto.EbsVolumeOverviewRsp": {
            "type": "object",
            "properties": {
                "EbsStorageUse": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/types.BasicOverviewSlot"
                    }
                },
                "EbsVolumeBusinessCounts": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/types.BasicOverviewSlot"
                    }
                },
                "EbsVolumePlatformCounts": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/types.BasicOverviewSlot"
                    }
                }
            }
        },
        "dto.EbsVolumeOverviewTopReq": {
            "type": "object",
            "properties": {
                "Az": {
                    "type": "string"
                },
                "DiskType": {
                    "type": "string"
                },
                "End": {
                    "type": "integer"
                },
                "MetricName": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "Region": {
                    "type": "string"
                },
                "Start": {
                    "type": "integer"
                },
                "topK": {
                    "type": "integer"
                }
            }
        },
        "dto.EbsVolumeOverviewTopRsp": {
            "type": "object",
            "properties": {
                "Tops": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/types.BasicOverviewSlot"
                    }
                }
            }
        },
        "dto.ListReq": {
            "type": "object",
            "properties": {
                "OrderCode": {
                    "type": "string"
                },
                "OrderType": {
                    "type": "string"
                },
                "PageNo": {
                    "type": "integer"
                },
                "PageSize": {
                    "type": "integer"
                },
                "PoolType": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "Query": {
                    "type": "object",
                    "additionalProperties": {
                        "type": "string"
                    }
                },
                "Region": {
                    "type": "string"
                }
            }
        },
        "dto.ListRes": {
            "type": "object",
            "properties": {
                "DataList": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/dto.ObjectStorageMonitor"
                    }
                },
                "PageNo": {
                    "type": "integer"
                },
                "PageSize": {
                    "type": "integer"
                },
                "TotalCount": {
                    "type": "integer"
                }
            }
        },
        "dto.ObjectPoolDetailMetricLineReq": {
            "type": "object",
            "properties": {
                "End": {
                    "type": "integer"
                },
                "MetricName": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "PoolId": {
                    "type": "integer"
                },
                "PoolType": {
                    "type": "string"
                },
                "Region": {
                    "type": "string"
                },
                "Start": {
                    "type": "integer"
                }
            }
        },
        "dto.ObjectPoolDetailMetricLineRes": {
            "type": "object",
            "properties": {
                "Lines": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/types.BasicOverviewSlot"
                    }
                }
            }
        },
        "dto.ObjectPoolDetailMetricReq": {
            "type": "object",
            "properties": {
                "MetricName": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "PoolId": {
                    "type": "integer"
                },
                "PoolType": {
                    "type": "string"
                },
                "Region": {
                    "type": "string"
                }
            }
        },
        "dto.ObjectPoolDetailMetricRes": {
            "type": "object",
            "properties": {
                "Lines": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/types.BasicOverviewSlot"
                    }
                }
            }
        },
        "dto.ObjectPoolLineReq": {
            "type": "object",
            "properties": {
                "Region": {
                    "type": "string"
                }
            }
        },
        "dto.ObjectPoolLineRsp": {
            "type": "object",
            "properties": {
                "CapRate": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/types.BasicOverviewSlot"
                    }
                }
            }
        },
        "dto.ObjectStorageMonitor": {
            "type": "object",
            "properties": {
                "AlertAmount": {
                    "description": "告警数量 TODO",
                    "type": "integer"
                },
                "BucketNumber": {
                    "description": "桶数量",
                    "type": "integer"
                },
                "CapacityAvailable": {
                    "description": "可用容量",
                    "type": "number"
                },
                "CapacityTotal": {
                    "description": "总容量",
                    "type": "number"
                },
                "CapacityUsedRate": {
                    "description": "使用率",
                    "type": "number"
                },
                "CapacityUsedTotal": {
                    "description": "已使用容量",
                    "type": "number"
                },
                "CreateTime": {
                    "description": "创建时间",
                    "type": "integer"
                },
                "DiskType": {
                    "description": "存储类型",
                    "type": "string"
                },
                "DownloadBandwidth": {
                    "description": "下载带宽 TODO",
                    "type": "integer"
                },
                "HostNumber": {
                    "description": "主机数量",
                    "type": "integer"
                },
                "HttpRequestAmount": {
                    "description": "UploadFlow         int64   ` + "`" + `json:\"UploadFlow\"` + "`" + `         // 上传流量 TODO\nDownloadFlow       int64   ` + "`" + `json:\"DownloadFlow\"` + "`" + `       // 下载流量 TODO\nAPIRequestAmount   int64   ` + "`" + `json:\"APIRequestAmount\"` + "`" + `   // API请求次数 TODO\nErrorReturnAmount  int64   ` + "`" + `json:\"ErrorReturnAmount\"` + "`" + `  // 错误返回次数 TODO",
                    "type": "integer"
                },
                "HttpsRequestAmount": {
                    "description": "HTTPS请求次数 TODO",
                    "type": "integer"
                },
                "Id": {
                    "description": "资源池ID",
                    "type": "integer"
                },
                "MonitorStatus": {
                    "description": "集群状态 1:正常 2:异常",
                    "type": "integer"
                },
                "Name": {
                    "description": "资源池名称",
                    "type": "string"
                },
                "Region": {
                    "description": "区域",
                    "type": "string"
                },
                "RegionCode": {
                    "description": "区域编码",
                    "type": "string"
                },
                "UploadBandwidth": {
                    "description": "上传带宽 TODO",
                    "type": "integer"
                }
            }
        },
        "dto.ObjectVolumeDetailMetric": {
            "type": "object",
            "properties": {
                "Kind": {
                    "type": "string"
                },
                "Name": {
                    "type": "string"
                },
                "PoolId": {
                    "type": "string"
                },
                "Unit": {
                    "type": "string"
                },
                "UnitType": {
                    "type": "string"
                },
                "Value": {}
            }
        },
        "dto.ObjectVolumeDetailMetricLineReq": {
            "type": "object",
            "required": [
                "BucketId",
                "End",
                "MetricName",
                "Start"
            ],
            "properties": {
                "BucketId": {
                    "type": "integer"
                },
                "End": {
                    "type": "integer"
                },
                "MetricName": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "Start": {
                    "type": "integer"
                }
            }
        },
        "dto.ObjectVolumeDetailMetricLineRes": {
            "type": "object",
            "properties": {
                "Lines": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/types.BasicOverviewSlot"
                    }
                }
            }
        },
        "dto.ObjectVolumeDetailMetricReq": {
            "type": "object",
            "required": [
                "BucketId"
            ],
            "properties": {
                "BucketId": {
                    "type": "integer"
                }
            }
        },
        "dto.ObjectVolumeDetailMetricRes": {
            "type": "object",
            "properties": {
                "CreationTimestamp": {
                    "type": "integer"
                },
                "ResourceOverview": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/dto.ObjectVolumeDetailMetric"
                    }
                }
            }
        },
        "dto.ObjectVolumeOverviewReq": {
            "type": "object",
            "required": [
                "MetricName"
            ],
            "properties": {
                "DiskType": {
                    "type": "string"
                },
                "MetricName": {
                    "type": "array",
                    "items": {
                        "type": "array",
                        "items": {
                            "type": "string"
                        }
                    }
                },
                "Region": {
                    "type": "string"
                }
            }
        },
        "dto.ObjectVolumeOverviewRes": {
            "type": "object",
            "properties": {
                "Overviews": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/types.BasicOverviewSlot"
                    }
                }
            }
        },
        "dto.ObjectVolumeOverviewTopReq": {
            "type": "object",
            "required": [
                "End",
                "MetricName",
                "Start",
                "TopK"
            ],
            "properties": {
                "DiskType": {
                    "type": "string"
                },
                "End": {
                    "type": "integer"
                },
                "MetricName": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "Region": {
                    "type": "string"
                },
                "Start": {
                    "type": "integer"
                },
                "TopK": {
                    "type": "integer"
                }
            }
        },
        "dto.ObjectVolumeOverviewTopRes": {
            "type": "object",
            "properties": {
                "Tops": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/types.BasicOverviewSlot"
                    }
                }
            }
        },
        "dto.OptionalEbsPoolResult": {
            "type": "object",
            "additionalProperties": {
                "type": "any"
            }
        },
        "dto.OptionalObjectPoolResult": {
            "type": "object",
            "additionalProperties": {
                "type": "any"
            }
        },
        "dto.OverViewAlertReq": {
            "type": "object",
            "properties": {
                "PoolType": {
                    "type": "string"
                },
                "Region": {
                    "type": "string"
                }
            }
        },
        "dto.OverViewAlertRes": {
            "type": "object",
            "properties": {
                "Alerts": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/types.BasicOverviewSlot"
                    }
                }
            }
        },
        "dto.OverViewLineRes": {
            "type": "object",
            "properties": {
                "Lines": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/types.BasicOverviewSlot"
                    }
                }
            }
        },
        "dto.OverViewRes": {
            "type": "object",
            "properties": {
                "ObjectPools": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/types.BasicOverviewSlot"
                    }
                },
                "ObjectVolumeCounts": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/types.BasicOverviewSlot"
                    }
                }
            }
        },
        "dto.OverviewLineReq": {
            "type": "object",
            "properties": {
                "End": {
                    "type": "integer"
                },
                "HasPrediction": {
                    "type": "boolean"
                },
                "MetricName": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "PoolType": {
                    "type": "string"
                },
                "Region": {
                    "type": "string"
                },
                "Start": {
                    "type": "integer"
                }
            }
        },
        "dto.OverviewReq": {
            "type": "object",
            "properties": {
                "PoolType": {
                    "type": "string"
                },
                "Region": {
                    "type": "string"
                }
            }
        },
        "dto.Query": {
            "type": "object",
            "additionalProperties": {
                "type": "string"
            }
        },
        "dto.VmDetailMetricLinesReq": {
            "type": "object",
            "properties": {
                "End": {
                    "type": "integer"
                },
                "Id": {
                    "type": "string"
                },
                "MetricName": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "Start": {
                    "type": "integer"
                }
            }
        },
        "dto.VmDetailMetricLinesRsp": {
            "type": "object",
            "properties": {
                "Lines": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/types.BasicOverviewSlot"
                    }
                }
            }
        },
        "dto.VmDetailMetricsReq": {
            "type": "object",
            "properties": {
                "Id": {
                    "type": "string"
                },
                "MetricName": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                }
            }
        },
        "dto.VmDetailMetricsRsp": {
            "type": "object",
            "properties": {
                "Metrics": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/types.BasicOverviewSlot"
                    }
                }
            }
        },
        "dto.VmOverviewMonitorReq": {
            "type": "object",
            "properties": {
                "Az": {
                    "type": "string"
                },
                "Region": {
                    "type": "string"
                }
            }
        },
        "dto.VmOverviewMonitorRsp": {
            "type": "object",
            "properties": {
                "Business": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/types.BasicOverviewSlot"
                    }
                },
                "Platform": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/types.BasicOverviewSlot"
                    }
                },
                "TotalCount": {
                    "type": "integer"
                }
            }
        },
        "dto.VmOverviewTopReq": {
            "type": "object",
            "properties": {
                "Az": {
                    "type": "string"
                },
                "End": {
                    "type": "integer"
                },
                "Name": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "Region": {
                    "type": "string"
                },
                "Start": {
                    "type": "integer"
                },
                "TopK": {
                    "type": "integer"
                }
            }
        },
        "dto.VmOverviewTopRsp": {
            "type": "object",
            "properties": {
                "Tops": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/types.BasicOverviewSlot"
                    }
                }
            }
        },
        "types.BasicOverviewSlot": {
            "type": "object",
            "properties": {
                "Info": {
                    "$ref": "#/definitions/types.BasicOverviewSlotInfo"
                },
                "Values": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/types.BasicOverviewSlotValue"
                    }
                }
            }
        },
        "types.BasicOverviewSlotInfo": {
            "type": "object",
            "properties": {
                "Avg": {},
                "Code": {
                    "type": "string"
                },
                "Description": {
                    "type": "string"
                },
                "Kind": {
                    "type": "string"
                },
                "Max": {},
                "Min": {},
                "Name": {
                    "type": "string"
                },
                "Prognosis": {
                    "description": "预测值索引",
                    "type": "integer"
                },
                "Unit": {
                    "type": "string"
                },
                "UnitType": {
                    "type": "string"
                },
                "Value": {},
                "_Index": {
                    "description": "多y坐标轴标识",
                    "type": "integer"
                }
            }
        },
        "types.BasicOverviewSlotValue": {
            "type": "object",
            "properties": {
                "Code": {
                    "type": "string"
                },
                "Description": {
                    "type": "string"
                },
                "Kind": {
                    "type": "string"
                },
                "Name": {
                    "type": "string"
                },
                "SubName": {
                    "type": "string"
                },
                "Unit": {
                    "type": "string"
                },
                "UnitType": {
                    "type": "string"
                },
                "Value": {}
            }
        }
    }
}`

// SwaggerInfo holds exported Swagger Info so clients can modify it
var SwaggerInfo = &swag.Spec{
	Version:          "2.0",
	Host:             "luban.console.galaxy.cloud",
	BasePath:         "/monitor/v2",
	Schemes:          []string{},
	Title:            "Monitor API Swagger",
	Description:      "",
	InfoInstanceName: "swagger",
	SwaggerTemplate:  docTemplate,
}

func init() {
	swag.Register(SwaggerInfo.InstanceName(), SwaggerInfo)
}

```

File path: /Users/mac/Desktop/woker_code/monitor/common/middleware/middleware.go
```golang
package middleware

import (
	"bytes"
	"encoding/json"
	"ezone.ksyun.com/ezone/luban/communal/lib"
	"ezone.ksyun.com/ezone/luban/monitor/common/consts"
	"ezone.ksyun.com/ezone/luban/monitor/common/trace"
	"ezone.ksyun.com/ezone/luban/monitor/response"
	"github.com/gin-contrib/cors"
	"github.com/gin-gonic/gin"
	uuid "github.com/satori/go.uuid"
	"io/ioutil"
	"net/http"
	"strings"
	"time"

	"go.opentelemetry.io/otel"
	"go.opentelemetry.io/otel/attribute"
	"go.opentelemetry.io/otel/propagation"
	semconv "go.opentelemetry.io/otel/semconv/v1.4.0"
	oteltrace "go.opentelemetry.io/otel/trace"
)

const (
	maxAge        = 12
	XRequestIDKey = "X-Request-ID"
)

type BaseParams struct {
	Action string `json:"Action" form:"Action" binding:"required"`
}

func OtlTrace(service string) gin.HandlerFunc {
	tracer := otel.Tracer(trace.TraceName)
	propagator := otel.GetTextMapPropagator()

	return func(c *gin.Context) {
		spanName := c.Request.URL.Path

		ctx := propagator.Extract(c.Request.Context(), propagation.HeaderCarrier(c.Request.Header))
		spanCtx, span := tracer.Start(
			ctx,
			spanName,
			oteltrace.WithSpanKind(oteltrace.SpanKindServer),
			oteltrace.WithAttributes(semconv.HTTPServerAttributesFromHTTPRequest(
				service, spanName, c.Request)...),
		)
		defer span.End()

		// pass the span through the request context
		c.Request = c.Request.WithContext(spanCtx)

		// serve the request to the next middleware
		c.Next()

		span.SetAttributes(semconv.HTTPAttributesFromHTTPStatusCode(c.Writer.Status())...)

		if len(c.Errors) > 0 {
			span.SetAttributes(attribute.String("gin.errors", c.Errors.String()))
		}

	}
}

// Cors 跨域中间件
func Cors() gin.HandlerFunc {
	return cors.New(cors.Config{
		AllowOrigins:     []string{"*"},
		AllowMethods:     []string{"PUT", "PATCH", "GET", "POST", "OPTIONS", "DELETE"},
		AllowHeaders:     []string{"Origin", "Authorization", "Content-Type", "Accept"},
		AllowCredentials: false,
		MaxAge:           time.Hour * maxAge,
		AllowOriginFunc: func(origin string) bool {
			return true
		},
	})
}

// RequestID 插入'X-Request-ID'到上下文和每个request/response的header中
func RequestID() gin.HandlerFunc {
	return func(c *gin.Context) {
		rid := c.GetHeader(XRequestIDKey)
		if rid == "" {
			// 在header和上下文中设置请求id
			rid := uuid.NewV4().String()
			c.Request.Header.Set(XRequestIDKey, rid)
			c.Set(XRequestIDKey, rid)
		}
		// 在响应header中设置同样的id
		c.Writer.Header().Set(XRequestIDKey, rid)
		c.Next()
	}
}

// Tracing 创建trace实例并将其放入上下文中
func Tracing() gin.HandlerFunc {
	return func(c *gin.Context) {
		// 创建新追踪实例
		trace := lib.NewTrace()
		// 将追踪实例放入 Gin 的上下文中
		if err := lib.SetGinTraceContext(c, trace); err != nil {
			_ = c.AbortWithError(http.StatusInternalServerError, err)
			return
		}
		// 继续处理请求
		c.Next()
	}
}

// RequestValidation 中间件函数，用于校验请求
func RequestValidation() gin.HandlerFunc {
	return func(c *gin.Context) {
		// 校验请求方法
		if c.Request.Method != http.MethodGet && c.Request.Method != http.MethodPost {
			lib.Log.TagError(lib.GetTraceContext(c), lib.DLTagRequestOut, map[string]interface{}{"Method": c.Request.Method})
			response.Failed(c, http.StatusBadRequest, consts.MethodNotSupported, "不支持的请求方式")
			c.Abort()
			return
		}
		var baseParams BaseParams
		// 校验GET请求的参数
		if c.Request.Method == http.MethodGet {
			if c.Request.URL.Query().Encode() == "" {
				lib.Log.TagError(lib.GetTraceContext(c), lib.DLTagRequestOut, map[string]interface{}{"Query": c.Request.URL.Query().Encode()})
				response.Failed(c, http.StatusBadRequest, consts.ParModeNotSupported, "无效的参数模式")
				c.Abort()
				return
			} else {
				if err := c.ShouldBind(&baseParams); err != nil {
					lib.Log.TagError(lib.GetTraceContext(c), lib.DLTagRequestOut, map[string]interface{}{"error": err.Error(), "base_params": baseParams})
					response.Failed(c, http.StatusBadRequest, consts.InvalidRequest, "无效的请求体")
					c.Abort()
					return
				}
			}
		}

		// 校验POST请求的参数
		if c.Request.Method == http.MethodPost {
			if !strings.Contains(c.Request.Header.Get("Content-Type"), "application/json") {
				lib.Log.TagInfo(lib.GetTraceContext(c), lib.DLTagRequestOut, map[string]interface{}{"if_content_type": c.Request.Header.Get("Content-Type")})
				if err := c.ShouldBind(&baseParams); err != nil {
					lib.Log.TagError(lib.GetTraceContext(c), lib.DLTagRequestOut, map[string]interface{}{"error": err.Error(), "base_params": baseParams, "content_type": c.Request.Header.Get("Content-Type")})
					response.Failed(c, http.StatusBadRequest, consts.InvalidRequest, "无效的请求体")
					c.Abort()
					return
				}
			} else {
				lib.Log.TagInfo(lib.GetTraceContext(c), lib.DLTagRequestOut, map[string]interface{}{"else_content_type": c.Request.Header.Get("Content-Type")})
				bodyBytes, err := ioutil.ReadAll(c.Request.Body)
				if err != nil {
					lib.Log.TagError(lib.GetTraceContext(c), lib.DLTagRequestOut, map[string]interface{}{"error": err.Error(), "body_bytes": bodyBytes})
					response.Failed(c, http.StatusBadRequest, consts.GainFail, "无效的请求体")
					c.Abort()
					return
				}

				if err = json.Unmarshal(bodyBytes, &baseParams); err != nil {
					lib.Log.TagError(lib.GetTraceContext(c), lib.DLTagRequestOut, map[string]interface{}{"error": err.Error(), "base_params": baseParams})
					response.Failed(c, http.StatusBadRequest, consts.InvalidRequest, "无效的请求体")
					c.Abort()
					return
				}

				// 重置请求体
				c.Request.Body = ioutil.NopCloser(bytes.NewBuffer(bodyBytes))
			}
		}

		// 将解析得到的参数存储到上下文中，供后续处理函数使用
		c.Set("action", baseParams.Action)

		c.Next()
	}
}

// BusinessPack 路由中间件模版
func BusinessPack(handler func(*gin.Context) (interface{}, error)) gin.HandlerFunc {
	return func(c *gin.Context) {
		defer func() {
			if err := recover(); err != nil {
				//TODO 加飞书告警
				c.JSON(http.StatusInternalServerError, gin.H{"code": consts.ServiceInternalError, "msg": err, "data": []string{}})
			}
		}()
		body, err := handler(c)
		if err != nil {
			//TODO 加飞书告警
			c.JSON(http.StatusOK, gin.H{"code": consts.RequestFail, "msg": err, "data": body})
		} else {
			c.JSON(http.StatusOK, gin.H{"code": consts.Success, "msg": "success", "data": body})
		}
	}
}

```

File path: /Users/mac/Desktop/woker_code/monitor/common/cmd/root.go
```golang
package cmd

import (
	"context"
	"fmt"
	"log"
	"net"
	"os"
	"strings"
	"time"

	alarmv1alpha "ezone.ksyun.com/ezone/luban/luban_api/alarmapis/alarm/v1alpha/gen"
	resource_network1alpha "ezone.ksyun.com/ezone/luban/luban_api/resourceapis/resource_network/v1alpha/gen"
	resource_serverv1alpha "ezone.ksyun.com/ezone/luban/luban_api/resourceapis/resource_server/v1alpha/gen"
	blockstorage_rpc "ezone.ksyun.com/ezone/luban/monitor/modules/blockstorage/rpc"
	compute_rpc "ezone.ksyun.com/ezone/luban/monitor/modules/compute/rpc"
	server_rpc "ezone.ksyun.com/ezone/luban/monitor/modules/server/rpc"
	switch_rpc "ezone.ksyun.com/ezone/luban/monitor/modules/switch/rpc"

	monitor_blockstroagev1alpha "ezone.ksyun.com/ezone/luban/luban_api/monitorapis/blockstorage/v1alpha/gen"
	monitor_computev1alpha "ezone.ksyun.com/ezone/luban/luban_api/monitorapis/compute/v1alpha/gen"
	monitor_serverv1alpha "ezone.ksyun.com/ezone/luban/luban_api/monitorapis/server/v1alpha/gen"
	monitor_switchv1alpha "ezone.ksyun.com/ezone/luban/luban_api/monitorapis/switch/v1alpha/gen"
	"ezone.ksyun.com/ezone/luban/monitor/common/client/grpcx"
	"ezone.ksyun.com/ezone/luban/monitor/common/client/grpcx/serverinterceptors"
	_ "ezone.ksyun.com/ezone/luban/monitor/common/init_conf"
	"ezone.ksyun.com/ezone/luban/monitor/common/middleware"
	"ezone.ksyun.com/ezone/luban/monitor/common/rpc_client/resource"
	"ezone.ksyun.com/ezone/luban/monitor/common/trace"
	"ezone.ksyun.com/ezone/luban/monitor/common/version"
	"ezone.ksyun.com/ezone/luban/monitor/router"
	"github.com/gin-gonic/gin"
	"github.com/grpc-ecosystem/go-grpc-middleware/v2/interceptors/recovery"
	"github.com/spf13/cobra"
	"google.golang.org/grpc"
	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/status"
)

var RootCmd = &cobra.Command{
	Use:           "Monitor",
	Short:         "Resource Monitor Manager System",
	Long:          "Resource Monitor Manager System",
	SilenceErrors: true,
	SilenceUsage:  true,
	Run: func(cmd *cobra.Command, args []string) {
		run()
	},
}

func Execute() {
	if err := RootCmd.Execute(); err != nil {
		fmt.Println(err)
		os.Exit(-1)
	}
}

func init() {
	RootCmd.Version = version.Info()
}

func run() {

	// 获取当前时间
	now := time.Now()
	thirtySeconds := time.Now().Add(-30 * time.Second)

	// 输出秒时间戳
	seconds := now.Unix()
	fmt.Printf("当前秒时间戳：%v\n", seconds)

	// 输出毫秒时间戳
	fmt.Printf("30分钟前毫秒时间戳: %v\n", thirtySeconds.UnixMilli())
	fmt.Printf("当前毫秒时间戳：%v\n", now.UnixMilli())

	serverName := "monitor"

	//go func() {
	//	testCallResourece()
	//	testCallAlarm()
	//}()

	//t := lib.GetStringMapStringConf("telemetry")
	//fmt.Printf("t: %+v\n", t)
	//
	//serverName := lib.GetStringConf("telemetry.name")
	//fmt.Printf("serverName: %s\n", serverName)
	//endPoint := lib.GetStringConf("telemetry.endpoint")
	//sampler := lib.GetStringConf("telemetry.sampler")
	//batcher := lib.GetStringConf("telemetry.batcher")

	//telemetryConf := trace.Config{
	//	Name:     serverName,
	//	Endpoint: endPoint,
	//	Sampler:  feetFloat,
	//	Batcher:  batcher,
	//}

	//fmt.Printf("telemetryConf: %+v\n", telemetryConf)

	jaegerCfg := trace.Config{
		Name: serverName,
		//Endpoint: "http://jaeger-api.luban.galaxy.cloud/api/traces",
		Endpoint:     "http://jaeger-all-in-one.opentelemetry:14268/api/traces",
		Sampler:      1,
		Batcher:      "jaeger",
		OtlpHeaders:  nil,
		OtlpHttpPath: "",
		Disabled:     false,
	}

	//初始化otr trace
	trace.StartAgent(jaegerCfg)

	//路由注册
	gin.SetMode(gin.ReleaseMode)
	engine := gin.Default()
	// 中间件定义
	engine.Use(gin.Recovery())
	engine.Use(middleware.RequestID())
	engine.Use(middleware.Cors())
	engine.Use(middleware.Tracing())
	engine.Use(middleware.OtlTrace("monitor"))
	//engine.Use(middleware.RequestValidation())
	// 路由定义
	router.InitRouter(engine)
	//Grpc Server
	RunGrpcServer(":9083")

	if err := engine.Run(":8083"); err != nil {
		log.Fatal(err)
	}
}

func RunGrpcServer(addr string) {
	grpcx := NewGrpcServer()
	monitor_blockstroagev1alpha.RegisterEbsPoolServiceServer(grpcx.server, blockstorage_rpc.NewBlockStorageRpcServer())
	monitor_computev1alpha.RegisterComputePoolServiceServer(grpcx.server, compute_rpc.NewComputeRpcServer())
	monitor_serverv1alpha.RegisterPhysicalServiceServer(grpcx.server, server_rpc.NewServerRpcServer())
	monitor_switchv1alpha.RegisterSwitchServiceServer(grpcx.server, switch_rpc.NewSwitchRpcServer())
	go func() {
		err := grpcx.Start(addr)
		if err != nil {
			log.Fatal(err.Error())
			return
		}
	}()
}

type GrpcServer struct {
	server   *grpc.Server
	listener net.Listener
}

func NewGrpcServer() *GrpcServer {
	return &GrpcServer{
		server: grpc.NewServer(
			//一元拦截器链
			grpc.ChainUnaryInterceptor(
				serverinterceptors.UnaryTracingInterceptor,
				recovery.UnaryServerInterceptor(recovery.WithRecoveryHandler(func(p any) (err error) {
					return status.Errorf(codes.Unknown, "panic triggered: %v", p)
				})),
			),
			//流式拦截器链
			grpc.ChainStreamInterceptor(),
		),
	}
}

// Start 启动gRPC服务器，监听指定地址。
func (s *GrpcServer) Start(address string) error {
	lis, err := net.Listen("tcp", address)
	if err != nil {
		return err
	}
	s.listener = lis
	return s.server.Serve(lis)
}

// Stop 停止gRPC服务器。
func (s *GrpcServer) Stop() {
	if s.listener != nil {
		s.listener.Close()
	}
}

// GracefulStop 优雅地停止gRPC服务器。
func (s *GrpcServer) GracefulStop() {
	s.server.GracefulStop()
}

func testCallResourece() {

	conn, err := grpcx.NewGrpcClientConn("resource.luban.galaxy.cloud")
	defer conn.Close()
	if err != nil {
		log.Fatalf("grpc.Dial err: %v", err)
	}

	client := resource.NewNetworkClient(conn)
	resp, err := client.Test(context.Background(), &resource_network1alpha.TestRequest{
		ID: "ID",
	})
	if err != nil {
		log.Fatalf("client.Search err: %v", err)
	}
	log.Printf("%+v", resp)

	serverClient := resource.NewServerClient(conn)
	//服务器列表
	serverList, err := serverClient.PhysicalServerList(context.Background(), &resource_serverv1alpha.PhysicalHostListRequest{
		PageSize: -1, //all
		Region:   "cn-shanghai-2",
		//NodeType:         []string{"network"},
		ResourcePoolType: []string{"XGW"},
		//ResourcePoolName: "XGW-LB",
	})
	if err != nil {
		log.Fatalf("client. serverList err: %v", err)
	}
	log.Printf("server list %+v", serverList)

}

func testCallAlarm() {
	//conn, err := grpcx.NewGrpcClientConn("alarmv2.luban.galaxy.cloud:8081")

	//conn, err := grpcx.NewGrpcClientConn("localhost:52609")
	//10.177.10.1
	conn, err := grpcx.NewGrpcClientConn("10.177.10.1:9830")

	defer conn.Close()
	if err != nil {
		log.Fatalf("grpc.Dial err: %v", err)
	}

	ipList := []string{"10.177.15.8"}
	newIpList := []string{}
	for _, ip := range ipList {
		newIpList = append(newIpList, ip+":9100")
	}

	req := &alarmv1alpha.ListPromQLsRequest{
		Name:            "up",
		ResourceSubType: "physicalServer",
		Labels: []*alarmv1alpha.Label{
			{
				Key:       "instance",
				Value:     strings.Join(newIpList, "|"),
				Operation: "=~",
			}},
	}
	log.Printf("DEBUG req:  %+v", req)

	resp, err := alarmv1alpha.NewAlarmServiceClient(conn).ListPromQLs(context.Background(), req)
	if err != nil {
		log.Fatalf("client.ListPromQLs err: %v", err)
	}
	log.Printf("%+v", resp)

}

```

File path: /Users/mac/Desktop/woker_code/monitor/common/tools/time.go
```golang
package tools

import (
	"time"
)

// time.Time to 毫秒时间戳
func UnixMilliToInt64(t time.Time) int64 {
	return t.UnixMilli()
}

// 毫秒时间戳 to time.Time
func Int64ToUnixMilli(i int64) time.Time {
	return time.UnixMilli(i)
}

// 秒时间戳 to 毫秒时间戳
func UnixToUnixMilli(i int64) int64 {
	t := time.Unix(i, 0)
	return t.UnixMilli()
}

// 毫秒时间戳 to 秒时间戳
func UnixMilliToUnix(i int64) int64 {
	t := time.UnixMilli(i)
	return t.Unix()
}

```

File path: /Users/mac/Desktop/woker_code/monitor/common/tools/tools.go
```golang
package tools

import (
	"bufio"
	"encoding/json"
	"fmt"
	"golang.org/x/net/html/charset"
	"golang.org/x/text/encoding"
	_ "golang.org/x/text/transform"
	"io"
	"math"
	"math/rand"
	"reflect"
	"runtime"
	"sort"
	"strconv"
	"strings"
	"time"
)

// DetermineEncoding 确定站点编码
func DetermineEncoding(r io.Reader) encoding.Encoding {
	bytes, err := bufio.NewReader(r).Peek(1024)
	if err != nil {
		panic(err)
	}
	e, _, _ := charset.DetermineEncoding(bytes, "")
	return e
}

// MicsSlice 字符串数组随机取值
func MicsSlice(origin []string, count int) []string {
	tmpOrigin := make([]string, len(origin))
	copy(tmpOrigin, origin)
	rand.Shuffle(len(tmpOrigin), func(i, j int) {
		tmpOrigin[i], tmpOrigin[j] = tmpOrigin[j], tmpOrigin[i]
	})
	result := make([]string, 0, count)
	for index, value := range tmpOrigin {
		if index == count {
			break
		}
		result = append(result, value)
	}
	return result
}

// RandomArr 随机打乱数组顺序返回字符串数组
func RandomArr(strings []string) []string {
	for i := len(strings) - 1; i > 0; i-- {
		num := rand.Intn(i + 1)
		strings[i], strings[num] = strings[num], strings[i]
	}
	var arr []string
	for i := 0; i < len(strings); i++ {
		arr = append(arr, strings[i])
	}
	return arr
}

// Contains 字符串数组中是否包含某元素，包含返回其下标--string
func Contains(slice []string, s string) int {
	if slice != nil && s != "" {
		for index, value := range slice {
			if value == s {
				return index
			}
		}
	}
	return -1
}

// ContainsInt 字符串数组中是否包含某元素，包含返回其值-- int
func ContainsInt(slice []int64, s int64) int64 {
	if slice != nil && s >= 0 {
		for _, value := range slice {
			if value == s {
				return value
			}
		}
	}
	return -1
}

// Different 判断切片中是否有重复值，如果有返回重复值
func Different(arr []string) []string {
	m := make(map[string]int)
	for _, val := range arr {
		m[val]++
	}
	var res []string
	for key, val := range m {
		if val > 1 {
			res = append(res, key)
		}
	}
	return res
}

// DelRepeatElem 删除数组中的重复元素返回剩余数组长度
func DelRepeatElem(nums []string) int {
	fmt.Println(nums, &nums[0])
	for i := 0; i < len(nums)-1; i++ {
		if nums[i] == nums[i+1] { // 重复元素执行异或操作等于0.
			nums = append(nums[:i], nums[i+1:]...) //删除重复元素
		}
	}
	fmt.Println(nums, &nums[0])
	return len(nums)
}

// SliceRemoveDuplicates 删除数组中的重复元素返回剩余数组
func SliceRemoveDuplicates(slice []string) []string {
	sort.Strings(slice)
	i := 0
	var j int
	for {
		if i >= len(slice)-1 {
			break
		}
		for j = i + 1; j < len(slice) && slice[i] == slice[j]; j++ {
		}
		slice = append(slice[:i+1], slice[j:]...)
		i++
	}
	return slice
}

// ArrayToString string数组转为字符串(（追加形式)
func ArrayToString(arr []string) string {
	var result string
	if arr != nil {
		for _, i := range arr {
			result += i
		}
	}
	return result
}

// StrArrayToString string 数组转为字符串 （追加形式）
func StrArrayToString(arr []string) string {
	var result string
	if arr != nil {
		for _, i := range arr {
			result += i + ","
		}
	}
	return result
}

// ArrayToStr int64数组转为字符串(追加形式)
func ArrayToStr(arr []int64) string {
	var result string
	if arr != nil {
		for _, i := range arr {
			result += strconv.FormatInt(i, 10) + ","
		}
	}
	return result
}

// MapToJson map 转 string
func MapToJson(param map[string]interface{}) string {
	dataType, _ := json.Marshal(param)
	dataString := string(dataType)
	return dataString
}

// JsonToMap string 转 map
func JsonToMap(str string) map[string]interface{} {
	var tempMap map[string]interface{}
	err := json.Unmarshal([]byte(str), &tempMap)
	if err != nil {
		panic(err)
	}
	return tempMap
}

// UidToPid UID标准转PID
func UidToPid(uid int64) int64 {
	return uid & 0x0000FFFFFFFFFFFF
}

// GenerateRangeNum 指定区间随机数
func GenerateRangeNum(min, max int) int {
	rand.Seed(time.Now().Unix())
	randNum := rand.Intn(max-min) + min
	return randNum
}

// Randint64 指定区间随机数
func Randint64(min, max int64) int64 {
	if min >= max || min == 0 || max == 0 {
		return max
	}
	return rand.Int63n(max-min) + min
}

// RandomString 生成指定长度的字符串
func RandomString(len int) string {
	rand.Seed(time.Now().UnixNano())
	bytes := make([]byte, len)
	for i := 0; i < len; i++ {
		bytes[i] = byte(randomlnt(65, 90))
	}
	return string(bytes)
}

// int >= min, < max
func randomlnt(min, max int) int {
	return min + rand.Intn(max-min)
}

// SortMap map按值从小到大排序
func SortMap(s map[int64]int64) []int64 {
	var rank []int64
	for key := range s {
		rank = append(rank, key)
	}
	for i := 0; i < len(rank); i++ {
		for j := i + 1; j < len(rank); j++ {
			if s[rank[i]] < s[rank[j]] {
				rank[i], rank[j] = rank[j], rank[i]
			}
		}
	}
	return rank
}

// ArgMax Argmax 返回最大值
func ArgMax(arr []int) int {
	maxVal := arr[0]
	maxIndex := 0
	for i := 1; i < len(arr); i++ {
		if arr[i] > maxVal {
			maxVal = arr[i]
			maxIndex = i
		}
	}
	return maxIndex
}

// TypeOf 获取类型
func TypeOf(v interface{}) string {
	switch v.(type) {
	case int:
		return "int"
	case int8:
		return "int8"
	case int16:
		return "int16"
	case int32:
		return "int32"
	case int64:
		return "int64"
	case uint:
		return "uint"
	case uint8:
		return "uint8"
	case uint16:
		return "uint16"
	case uint32:
		return "uint32"
	case uint64:
		return "uint64"
	case float32:
		return "float32"
	case float64:
		return "float64"
	case string:
		return "string"
	case bool:
		return "bool"
	case []byte:
		return "[]byte"
	case []interface{}:
		return "[]interface{}"
	case map[string]interface{}:
		return "map[string]interface{}"
	case []map[string]interface{}:
		return "map[string]interface{}"
	default:
		return "unknown"
	}
}

// Wrap float64转int
func Wrap(num float64, retain int) int {
	return int(num * math.Pow10(retain))
}

//os.Getwd() 获取项目根目录

// CurrentFile 获取当前文件的详细路径
func CurrentFile() string {
	_, file, _, ok := runtime.Caller(1)
	if !ok {
		panic("can_not_get_current_file_info")
	}
	return file
}

func FormatTime(fileSize float64) (size string) {
	if fileSize >= 0 {

		if fileSize < 3600.0*24.0 {
			//return strconv.FormatInt(fileSize, 10) + "B"
			return fmt.Sprintf("30m")
		} else if fileSize < (3600.0 * 24.0 * 2) {
			return fmt.Sprintf("1d")
		} else if fileSize < (3600.0 * 24.0 * 8) {
			return fmt.Sprintf("1w")
		} else {
			return fmt.Sprintf("30d")
		}
	}

	if fileSize < 0 {
		fileSize = -fileSize
		if fileSize < 1024.0 {
			return fmt.Sprintf("%.2fB", -fileSize)
		} else if fileSize < (1024.0 * 1024.0) {
			return fmt.Sprintf("%.2fKB", -fileSize/1024.0)
		} else if fileSize < (1024.0 * 1024.0 * 1024.0) {
			return fmt.Sprintf("%.2fMB", -fileSize/1024.0/1024.0)
		} else if fileSize < (1024.0 * 1024.0 * 1024.0 * 1024.0) {
			return fmt.Sprintf("%.2fGB", -fileSize/1024.0/1024.0/1024.0)
		} else if fileSize < (1024.0 * 1024.0 * 1024.0 * 1024.0 * 1024.0) {
			return fmt.Sprintf("%.2fTB", -fileSize/1024.0/1024.0/1024.0/1024.0)
		} else { //if fileSize < (1024 * 1024 * 1024 * 1024 * 1024 * 1024)
			return fmt.Sprintf("%.2fEB", -fileSize/1024.0/1024.0/1024.0/1024.0/1024.0)
		}
	}
	return ""

}

func FormPercent(r interface{}) float64 {
	switch r.(type) {
	case string:
		vv, _ := strconv.ParseFloat(r.(string), 64)
		ss, _ := strconv.ParseFloat(fmt.Sprintf("%.4f", vv), 64)
		return ss
	case float64:
		ss, _ := strconv.ParseFloat(fmt.Sprintf("%.4f", r.(float64)), 64)
		return ss
	}
	return 0
}

func TimeToStepForInt(fileSize int64) (size int) {
	//处理的单位是秒
	if fileSize >= 0 {
		if fileSize <= 3600.0*24.0*2 {
			return 60 //1m
		} else if fileSize <= (3600.0 * 24.0 * 7) {
			return 3600 //1h fixme 3600 7天间隔特定bug
		} else {
			return 86400 //1d
		}
	}
	return 0
}

func GetAvg(vals []float64) float64 {
	if len(vals) == 0 {
		return 0
	}
	l := len(vals)
	sum := 0.0
	for _, val := range vals {
		sum += val / float64(l)
	}
	return sum
}

func GetMax(slice []float64) float64 {
	if len(slice) == 0 {
		return 0
	}

	maxNum := slice[0]
	for _, value := range slice {
		if value > maxNum {
			maxNum = value
		}
	}
	return maxNum
}

func GetMin(slice []float64) float64 {
	if len(slice) == 0 {
		return 0
	}

	minNum := slice[0]
	for _, value := range slice {
		if value < minNum {
			minNum = value
		}
	}
	return minNum
}

// Strval 获取变量的字符串值
// 浮点型 3.0将会转换成字符串3, "3"
// 非数值或字符类型的变量将会被转换成JSON格式字符串
func Strval(value interface{}) string {
	// interface 转 string
	var key string
	if value == nil {
		return key
	}

	switch value.(type) {
	case float64:
		ft := value.(float64)
		key = strconv.FormatFloat(ft, 'f', 2, 64)
	case float32:
		ft := value.(float32)
		key = strconv.FormatFloat(float64(ft), 'f', 2, 64)
	case int:
		it := value.(int)
		key = strconv.Itoa(it)
	case uint:
		it := value.(uint)
		key = strconv.Itoa(int(it))
	case int8:
		it := value.(int8)
		key = strconv.Itoa(int(it))
	case uint8:
		it := value.(uint8)
		key = strconv.Itoa(int(it))
	case int16:
		it := value.(int16)
		key = strconv.Itoa(int(it))
	case uint16:
		it := value.(uint16)
		key = strconv.Itoa(int(it))
	case int32:
		it := value.(int32)
		key = strconv.Itoa(int(it))
	case uint32:
		it := value.(uint32)
		key = strconv.Itoa(int(it))
	case int64:
		it := value.(int64)
		key = strconv.FormatInt(it, 10)
	case uint64:
		it := value.(uint64)
		key = strconv.FormatUint(it, 10)
	case string:
		key = value.(string)
	case []byte:
		key = string(value.([]byte))
	case []interface{}:
		float, _ := strconv.ParseFloat(Strval(value.([]interface{})[1]), 64)
		key = string(Strval(float))
	default:
		newValue, _ := json.Marshal(value)
		key = string(newValue)
	}

	return key
}

func FormCMDBStorage(fileSize int) string {
	if fileSize >= 0 {
		if fileSize < 1024 {
			return fmt.Sprintf("%dMB", fileSize)
		} else if fileSize < (1024.0 * 1024.0) {
			return fmt.Sprintf("%.2fKB", fileSize/1024.0)
		} else if fileSize < (1024.0 * 1024.0 * 1024.0) {
			return fmt.Sprintf("%.2fMB", fileSize/1024.0/1024.0)
		} else if fileSize < (1024.0 * 1024.0 * 1024.0 * 1024.0) {
			return fmt.Sprintf("%.2fGB", fileSize/1024.0/1024.0/1024.0)
		} else if fileSize < (1024.0 * 1024.0 * 1024.0 * 1024.0 * 1024.0) {
			return fmt.Sprintf("%.2fTB", fileSize/1024.0/1024.0/1024.0/1024.0)
		} else { //if fileSize < (1024 * 1024 * 1024 * 1024 * 1024 * 1024)
			return fmt.Sprintf("%.2fEB", fileSize/1024.0/1024.0/1024.0/1024.0/1024.0)
		}
	}
	return ""
}

func FormCMDBStorageM(fileSize int) string {

	if fileSize >= 0 {
		if fileSize < 1024 {
			return fmt.Sprintf("%dMB", fileSize)
		} else if fileSize < (1024 * 1024) {
			return fmt.Sprintf("%.2dGB", fileSize/1024)
		} else if fileSize < (1024 * 1024 * 1024) {
			return fmt.Sprintf("%.2dTB", fileSize/1024/1024)
		} else {
			return fmt.Sprintf("%.2fEB", fileSize/1024.0/1024.0/1024.0/1024.0/1024.0)
		}
	}
	return ""
}

func FormatBytes(bytes int) string {
	const (
		KB = 1024.0
		MB = KB * 1024.0
		GB = MB * 1024.0
		TB = GB * 1024.0
		EB = TB * 1024.0
	)

	size := float64(bytes)

	switch {
	case size < KB:
		return fmt.Sprintf("%d B", bytes)
	case size < MB:
		return fmt.Sprintf("%.2f KB", size/KB)
	case size < GB:
		return fmt.Sprintf("%.2f MB", size/MB)
	case size < TB:
		return fmt.Sprintf("%.2f GB", size/GB)
	case size < EB:
		return fmt.Sprintf("%.2f TB", size/TB)
	default:
		return fmt.Sprintf("%.2f EB", size/EB)
	}
}

func TypeToRealSize(size string) (res int64) {
	idx := strings.Index(size, "bytes")
	for i := 0; i < idx; i++ {
		if size[i] >= '0' && size[i] <= '9' {
			res *= 10
			res += int64(size[i] - '0')
		}
	}
	return
}

func In(haystack interface{}, needle interface{}) bool {
	sVal := reflect.ValueOf(haystack)
	kind := sVal.Kind()
	if kind == reflect.Slice || kind == reflect.Array {
		for i := 0; i < sVal.Len(); i++ {
			if sVal.Index(i).Interface() == needle {
				return true
			}
		}
		return false
	}
	return false
}

```

File path: /Users/mac/Desktop/woker_code/monitor/common/tools/collection/set.go
```golang
package collection

import (
	"fmt"
)

const (
	unmanaged = iota
	untyped
	intType
	int64Type
	uintType
	uint64Type
	stringType
)

// PlaceholderType represents a placeholder type.
type PlaceholderType = struct{}

// Set is not thread-safe, for concurrent use, make sure to use it with synchronization.
type Set struct {
	data map[interface{}]PlaceholderType
	tp   int
}

// NewSet returns a managed Set, can only put the values with the same type.
func NewSet() *Set {
	return &Set{
		data: make(map[interface{}]PlaceholderType),
		tp:   untyped,
	}
}

// NewUnmanagedSet returns a unmanaged Set, which can put values with different types.
func NewUnmanagedSet() *Set {
	return &Set{
		data: make(map[interface{}]PlaceholderType),
		tp:   unmanaged,
	}
}

// Add adds i into s.
func (s *Set) Add(i ...interface{}) {
	for _, each := range i {
		s.add(each)
	}
}

// AddInt adds int values ii into s.
func (s *Set) AddInt(ii ...int) {
	for _, each := range ii {
		s.add(each)
	}
}

// AddInt64 adds int64 values ii into s.
func (s *Set) AddInt64(ii ...int64) {
	for _, each := range ii {
		s.add(each)
	}
}

// AddUint adds uint values ii into s.
func (s *Set) AddUint(ii ...uint) {
	for _, each := range ii {
		s.add(each)
	}
}

// AddUint64 adds uint64 values ii into s.
func (s *Set) AddUint64(ii ...uint64) {
	for _, each := range ii {
		s.add(each)
	}
}

// AddStr adds string values ss into s.
func (s *Set) AddStr(ss ...string) {
	for _, each := range ss {
		s.add(each)
	}
}

// Contains checks if i is in s.
func (s *Set) Contains(i interface{}) bool {
	if len(s.data) == 0 {
		return false
	}

	s.validate(i)
	_, ok := s.data[i]
	return ok
}

// Keys returns the keys in s.
func (s *Set) Keys() []interface{} {
	var keys []interface{}

	for key := range s.data {
		keys = append(keys, key)
	}

	return keys
}

// KeysInt returns the int keys in s.
func (s *Set) KeysInt() []int {
	var keys []int

	for key := range s.data {
		if intKey, ok := key.(int); ok {
			keys = append(keys, intKey)
		}
	}

	return keys
}

// KeysInt64 returns int64 keys in s.
func (s *Set) KeysInt64() []int64 {
	var keys []int64

	for key := range s.data {
		if intKey, ok := key.(int64); ok {
			keys = append(keys, intKey)
		}
	}

	return keys
}

// KeysUint returns uint keys in s.
func (s *Set) KeysUint() []uint {
	var keys []uint

	for key := range s.data {
		if intKey, ok := key.(uint); ok {
			keys = append(keys, intKey)
		}
	}

	return keys
}

// KeysUint64 returns uint64 keys in s.
func (s *Set) KeysUint64() []uint64 {
	var keys []uint64

	for key := range s.data {
		if intKey, ok := key.(uint64); ok {
			keys = append(keys, intKey)
		}
	}

	return keys
}

// KeysStr returns string keys in s.
func (s *Set) KeysStr() []string {
	var keys []string

	for key := range s.data {
		if strKey, ok := key.(string); ok {
			keys = append(keys, strKey)
		}
	}

	return keys
}

// Remove removes i from s.
func (s *Set) Remove(i interface{}) {
	s.validate(i)
	delete(s.data, i)
}

// Count returns the number of items in s.
func (s *Set) Count() int {
	return len(s.data)
}

func (s *Set) add(i interface{}) {
	switch s.tp {
	case unmanaged:
		// do nothing
	case untyped:
		s.setType(i)
	default:
		s.validate(i)
	}
	s.data[i] = PlaceholderType{}
}

func (s *Set) setType(i interface{}) {
	// s.tp can only be untyped here
	switch i.(type) {
	case int:
		s.tp = intType
	case int64:
		s.tp = int64Type
	case uint:
		s.tp = uintType
	case uint64:
		s.tp = uint64Type
	case string:
		s.tp = stringType
	}
}

func (s *Set) validate(i interface{}) {
	if s.tp == unmanaged {
		return
	}

	switch i.(type) {
	case int:
		if s.tp != intType {
			fmt.Errorf("Error: element is int, but set contains elements with type %d", s.tp)
		}
	case int64:
		if s.tp != int64Type {
			fmt.Errorf("Error: element is int64, but set contains elements with type %d", s.tp)
		}
	case uint:
		if s.tp != uintType {
			fmt.Errorf("Error: element is uint, but set contains elements with type %d", s.tp)
		}
	case uint64:
		if s.tp != uint64Type {
			fmt.Errorf("Error: element is uint64, but set contains elements with type %d", s.tp)
		}
	case string:
		if s.tp != stringType {
			fmt.Errorf("Error: element is string, but set contains elements with type %d", s.tp)
		}
	}
}

```

File path: /Users/mac/Desktop/woker_code/monitor/common/types/overview.go
```golang
package types

const (
	//percent【百分比】、number【数值】，storage【bytes数值，2进制】,storage_bit【bit数值】
	TypePercent    = "percent"
	TypeNumber     = "number"
	TypeStorage    = "storage"
	TypeStorageBit = "storage_bit"

	//error、warn、success、info、disabled
	KindError    = "error"
	KindWarn     = "warn"
	KindSuccess  = "success"
	KindMinor    = "minor"
	KindInfo     = "info"
	KindDisabled = "disabled"
)

// 基础结构
type BasicOverviewSlot struct {
	Info   BasicOverviewSlotInfo    `json:"Info"`
	Values []BasicOverviewSlotValue `json:"Values"`
}

type BasicOverviewSlotInfo struct {
	Index       int         `json:"_Index"` //多y坐标轴标识
	Code        string      `json:"Code,omitempty"`
	Name        string      `json:"Name"`
	Value       interface{} `json:"Value"`
	Avg         interface{} `json:"Avg,omitempty"`
	Min         interface{} `json:"Min,omitempty"`
	Max         interface{} `json:"Max,omitempty"`
	UnitType    string      `json:"UnitType"`
	Unit        string      `json:"Unit"`
	Kind        string      `json:"Kind"`
	Prognosis   int         `json:"Prognosis"` //预测值索引
	Description string      `json:"Description"`
}

type BasicOverviewSlotValue struct {
	Name        string      `json:"Name"`
	SubName     string      `json:"SubName,omitempty"`
	Code        string      `json:"Code"`
	Value       interface{} `json:"Value"`
	Unit        string      `json:"Unit"`
	UnitType    string      `json:"UnitType"`
	Kind        string      `json:"Kind"`
	Description string      `json:"Description"`
}

// 分布概览的扩展结构
type DistributionOverviewSlot struct {
	Info   BasicOverviewSlotInfo           `json:"Info"`
	Values []DistributionOverviewSlotValue `json:"Values"`
}

type DistributionOverviewSlotValue struct {
	BasicOverviewSlotValue
	Region string   `json:"Region"`
	Az     []string `json:"Az"`
}

// OverviewAlert 概览页告警
type OverviewAlert struct {
	Prefix string `json:"prefix"`
	Level  string `json:"level"`
	Unit   string `json:"unit"`
	Number int    `json:"number"`
	Name   string `json:"name"`
	Kind   string `json:"kind"`
	Type   string `json:"type"`
}

func ParseUnitTypeByUnit(unit string) string {
	switch unit {
	case "%":
		return TypePercent
	case "B", "KB", "MB", "GB":
		return TypeStorage
	case "bps", "Kbps", "Mbps", "Gbps":
		return TypeStorageBit
	default:
		return TypeNumber
	}
}

```

File path: /Users/mac/Desktop/woker_code/monitor/common/trace/attributes.go
```golang
package trace

import (
	"go.opentelemetry.io/otel/attribute"
	semconv "go.opentelemetry.io/otel/semconv/v1.4.0"
	gcodes "google.golang.org/grpc/codes"
)

const (
	// GRPCStatusCodeKey is convention for numeric status code of a gRPC request.
	GRPCStatusCodeKey = attribute.Key("rpc.grpc.status_code")
	// RPCNameKey is the name of message transmitted or received.
	RPCNameKey = attribute.Key("name")
	// RPCMessageTypeKey is the type of message transmitted or received.
	RPCMessageTypeKey = attribute.Key("message.type")
	// RPCMessageIDKey is the identifier of message transmitted or received.
	RPCMessageIDKey = attribute.Key("message.id")
	// RPCMessageCompressedSizeKey is the compressed size of the message transmitted or received in bytes.
	RPCMessageCompressedSizeKey = attribute.Key("message.compressed_size")
	// RPCMessageUncompressedSizeKey is the uncompressed size of the message
	// transmitted or received in bytes.
	RPCMessageUncompressedSizeKey = attribute.Key("message.uncompressed_size")
)

// Semantic conventions for common RPC attributes.
var (
	// RPCSystemGRPC is the semantic convention for gRPC as the remoting system.
	RPCSystemGRPC = semconv.RPCSystemKey.String("grpc")
	// RPCNameMessage is the semantic convention for a message named message.
	RPCNameMessage = RPCNameKey.String("message")
	// RPCMessageTypeSent is the semantic conventions for sent RPC message types.
	RPCMessageTypeSent = RPCMessageTypeKey.String("SENT")
	// RPCMessageTypeReceived is the semantic conventions for the received RPC message types.
	RPCMessageTypeReceived = RPCMessageTypeKey.String("RECEIVED")
)

// StatusCodeAttr returns an attribute.KeyValue that represents the give c.
func StatusCodeAttr(c gcodes.Code) attribute.KeyValue {
	return GRPCStatusCodeKey.Int64(int64(c))
}

```

File path: /Users/mac/Desktop/woker_code/monitor/common/trace/config.go
```golang
package trace

// TraceName represents the tracing name.
const TraceName = "luban"

// A Config is an opentelemetry config.
type Config struct {
	Name     string  `json:",optional"`
	Endpoint string  `json:",optional"`
	Sampler  float64 `json:",default=1.0"`
	Batcher  string  `json:",default=jaeger,options=jaeger|zipkin|otlpgrpc|otlphttp|file"`
	// OtlpHeaders represents the headers for OTLP gRPC or HTTP transport.
	// For example:
	//  uptrace-dsn: 'http://project2_secret_token@localhost:14317/2'
	OtlpHeaders map[string]string `json:",optional"`
	// OtlpHttpPath represents the path for OTLP HTTP transport.
	// For example
	// /v1/traces
	OtlpHttpPath string `json:",optional"`
	// Disabled indicates whether StartAgent starts the agent.
	Disabled bool `json:",optional"`
}

```

File path: /Users/mac/Desktop/woker_code/monitor/common/trace/utils_test.go
```golang
package trace

import (
	"context"
	"net"
	"testing"

	"github.com/stretchr/testify/assert"
	"go.opentelemetry.io/otel"
	"go.opentelemetry.io/otel/attribute"
	"go.opentelemetry.io/otel/sdk/resource"
	sdktrace "go.opentelemetry.io/otel/sdk/trace"
	semconv "go.opentelemetry.io/otel/semconv/v1.4.0"
	"go.opentelemetry.io/otel/trace"
	"google.golang.org/grpc/peer"
)

func TestPeerFromContext(t *testing.T) {
	addrs, err := net.InterfaceAddrs()
	assert.Nil(t, err)
	assert.NotEmpty(t, addrs)
	tests := []struct {
		name  string
		ctx   context.Context
		empty bool
	}{
		{
			name:  "empty",
			ctx:   context.Background(),
			empty: true,
		},
		{
			name:  "nil",
			ctx:   peer.NewContext(context.Background(), nil),
			empty: true,
		},
		{
			name: "with value",
			ctx: peer.NewContext(context.Background(), &peer.Peer{
				Addr: addrs[0],
			}),
		},
	}

	for _, test := range tests {
		test := test
		t.Run(test.name, func(t *testing.T) {
			t.Parallel()
			addr := PeerFromCtx(test.ctx)
			assert.Equal(t, test.empty, len(addr) == 0)
		})
	}
}

func TestParseFullMethod(t *testing.T) {
	tests := []struct {
		fullMethod string
		name       string
		attr       []attribute.KeyValue
	}{
		{
			fullMethod: "/grpc.test.EchoService/Echo",
			name:       "grpc.test.EchoService/Echo",
			attr: []attribute.KeyValue{
				semconv.RPCServiceKey.String("grpc.test.EchoService"),
				semconv.RPCMethodKey.String("Echo"),
			},
		}, {
			fullMethod: "/com.example.ExampleRmiService/exampleMethod",
			name:       "com.example.ExampleRmiService/exampleMethod",
			attr: []attribute.KeyValue{
				semconv.RPCServiceKey.String("com.example.ExampleRmiService"),
				semconv.RPCMethodKey.String("exampleMethod"),
			},
		}, {
			fullMethod: "/MyCalcService.Calculator/Add",
			name:       "MyCalcService.Calculator/Add",
			attr: []attribute.KeyValue{
				semconv.RPCServiceKey.String("MyCalcService.Calculator"),
				semconv.RPCMethodKey.String("Add"),
			},
		}, {
			fullMethod: "/MyServiceReference.ICalculator/Add",
			name:       "MyServiceReference.ICalculator/Add",
			attr: []attribute.KeyValue{
				semconv.RPCServiceKey.String("MyServiceReference.ICalculator"),
				semconv.RPCMethodKey.String("Add"),
			},
		}, {
			fullMethod: "/MyServiceWithNoPackage/theMethod",
			name:       "MyServiceWithNoPackage/theMethod",
			attr: []attribute.KeyValue{
				semconv.RPCServiceKey.String("MyServiceWithNoPackage"),
				semconv.RPCMethodKey.String("theMethod"),
			},
		}, {
			fullMethod: "/pkg.svr",
			name:       "pkg.svr",
			attr:       []attribute.KeyValue(nil),
		}, {
			fullMethod: "/pkg.svr/",
			name:       "pkg.svr/",
			attr: []attribute.KeyValue{
				semconv.RPCServiceKey.String("pkg.svr"),
			},
		},
	}

	for _, test := range tests {
		n, a := ParseFullMethod(test.fullMethod)
		assert.Equal(t, test.name, n)
		assert.Equal(t, test.attr, a)
	}
}

func TestSpanInfo(t *testing.T) {
	val, kvs := SpanInfo("/fullMethod", "remote")
	assert.Equal(t, "fullMethod", val)
	assert.NotEmpty(t, kvs)
}

func TestPeerAttr(t *testing.T) {
	tests := []struct {
		name   string
		addr   string
		expect []attribute.KeyValue
	}{
		{
			name: "empty",
		},
		{
			name: "port only",
			addr: ":8080",
			expect: []attribute.KeyValue{
				semconv.NetPeerIPKey.String(localhost),
				semconv.NetPeerPortKey.String("8080"),
			},
		},
		{
			name: "port only",
			addr: "192.168.0.2:8080",
			expect: []attribute.KeyValue{
				semconv.NetPeerIPKey.String("192.168.0.2"),
				semconv.NetPeerPortKey.String("8080"),
			},
		},
	}

	for _, test := range tests {
		test := test
		t.Run(test.name, func(t *testing.T) {
			t.Parallel()
			kvs := PeerAttr(test.addr)
			assert.EqualValues(t, test.expect, kvs)
		})
	}
}

func TestTracerFromContext(t *testing.T) {
	traceFn := func(ctx context.Context, hasTraceId bool) {
		spanContext := trace.SpanContextFromContext(ctx)
		assert.Equal(t, spanContext.IsValid(), hasTraceId)
		parentTraceId := spanContext.TraceID().String()

		tracer := TracerFromContext(ctx)
		_, span := tracer.Start(ctx, "b")
		defer span.End()

		spanContext = span.SpanContext()
		assert.True(t, spanContext.IsValid())
		if hasTraceId {
			assert.Equal(t, parentTraceId, spanContext.TraceID().String())
		}

	}

	t.Run("context", func(t *testing.T) {
		opts := []sdktrace.TracerProviderOption{
			// Set the sampling rate based on the parent span to 100%
			sdktrace.WithSampler(sdktrace.ParentBased(sdktrace.TraceIDRatioBased(1))),
			// Record information about this application in a Resource.
			sdktrace.WithResource(resource.NewSchemaless(semconv.ServiceNameKey.String("test"))),
		}
		tp = sdktrace.NewTracerProvider(opts...)
		otel.SetTracerProvider(tp)
		ctx, span := tp.Tracer(TraceName).Start(context.Background(), "a")

		defer span.End()
		traceFn(ctx, true)
	})

	t.Run("global", func(t *testing.T) {
		opts := []sdktrace.TracerProviderOption{
			// Set the sampling rate based on the parent span to 100%
			sdktrace.WithSampler(sdktrace.ParentBased(sdktrace.TraceIDRatioBased(1))),
			// Record information about this application in a Resource.
			sdktrace.WithResource(resource.NewSchemaless(semconv.ServiceNameKey.String("test"))),
		}
		tp = sdktrace.NewTracerProvider(opts...)
		otel.SetTracerProvider(tp)

		traceFn(context.Background(), false)
	})
}

```

File path: /Users/mac/Desktop/woker_code/monitor/common/trace/vars.go
```golang
package trace

import "net/http"

// TraceIdKey is the trace id header.
// https://www.w3.org/TR/trace-context/#trace-id
// May change it to trace-id afterwards.
var TraceIdKey = http.CanonicalHeaderKey("x-trace-id")

```

File path: /Users/mac/Desktop/woker_code/monitor/common/trace/message.go
```golang
package trace

import (
	"context"

	"go.opentelemetry.io/otel/attribute"
	"go.opentelemetry.io/otel/trace"
	"google.golang.org/protobuf/proto"
)

const messageEvent = "message"

var (
	// MessageSent is the type of sent messages.
	MessageSent = messageType(RPCMessageTypeSent)
	// MessageReceived is the type of received messages.
	MessageReceived = messageType(RPCMessageTypeReceived)
)

type messageType attribute.KeyValue

// Event adds an event of the messageType to the span associated with the
// passed context with id and size (if message is a proto message).
func (m messageType) Event(ctx context.Context, id int, message any) {
	span := trace.SpanFromContext(ctx)
	if p, ok := message.(proto.Message); ok {
		span.AddEvent(messageEvent, trace.WithAttributes(
			attribute.KeyValue(m),
			RPCMessageIDKey.Int(id),
			RPCMessageUncompressedSizeKey.Int(proto.Size(p)),
		))
	} else {
		span.AddEvent(messageEvent, trace.WithAttributes(
			attribute.KeyValue(m),
			RPCMessageIDKey.Int(id),
		))
	}
}

```

File path: /Users/mac/Desktop/woker_code/monitor/common/trace/resource.go
```golang
package trace

import "go.opentelemetry.io/otel/attribute"

var attrResources = make([]attribute.KeyValue, 0)

// AddResources add more resources in addition to configured trace name.
func AddResources(attrs ...attribute.KeyValue) {
	attrResources = append(attrResources, attrs...)
}

```

File path: /Users/mac/Desktop/woker_code/monitor/common/trace/tracer_test.go
```golang
package trace

import (
	"context"
	"testing"

	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
	"go.opentelemetry.io/otel"
	"go.opentelemetry.io/otel/propagation"
	"go.opentelemetry.io/otel/trace"
	"google.golang.org/grpc/metadata"
)

const (
	traceIDStr = "4bf92f3577b34da6a3ce929d0e0e4736"
	spanIDStr  = "00f067aa0ba902b7"
)

var (
	traceID = mustTraceIDFromHex(traceIDStr)
	spanID  = mustSpanIDFromHex(spanIDStr)
)

func mustTraceIDFromHex(s string) (t trace.TraceID) {
	var err error
	t, err = trace.TraceIDFromHex(s)
	if err != nil {
		panic(err)
	}
	return
}

func mustSpanIDFromHex(s string) (t trace.SpanID) {
	var err error
	t, err = trace.SpanIDFromHex(s)
	if err != nil {
		panic(err)
	}
	return
}

func TestExtractValidTraceContext(t *testing.T) {
	stateStr := "key1=value1,key2=value2"
	state, err := trace.ParseTraceState(stateStr)
	require.NoError(t, err)

	tests := []struct {
		name        string
		traceparent string
		tracestate  string
		sc          trace.SpanContext
	}{
		{
			name:        "not sampled",
			traceparent: "00-4bf92f3577b34da6a3ce929d0e0e4736-00f067aa0ba902b7-00",
			sc: trace.NewSpanContext(trace.SpanContextConfig{
				TraceID: traceID,
				SpanID:  spanID,
				Remote:  true,
			}),
		},
		{
			name:        "sampled",
			traceparent: "00-4bf92f3577b34da6a3ce929d0e0e4736-00f067aa0ba902b7-01",
			sc: trace.NewSpanContext(trace.SpanContextConfig{
				TraceID:    traceID,
				SpanID:     spanID,
				TraceFlags: trace.FlagsSampled,
				Remote:     true,
			}),
		},
		{
			name:        "valid tracestate",
			traceparent: "00-4bf92f3577b34da6a3ce929d0e0e4736-00f067aa0ba902b7-00",
			tracestate:  stateStr,
			sc: trace.NewSpanContext(trace.SpanContextConfig{
				TraceID:    traceID,
				SpanID:     spanID,
				TraceState: state,
				Remote:     true,
			}),
		},
		{
			name:        "invalid tracestate perserves traceparent",
			traceparent: "00-4bf92f3577b34da6a3ce929d0e0e4736-00f067aa0ba902b7-00",
			tracestate:  "invalid$@#=invalid",
			sc: trace.NewSpanContext(trace.SpanContextConfig{
				TraceID: traceID,
				SpanID:  spanID,
				Remote:  true,
			}),
		},
		{
			name:        "future version not sampled",
			traceparent: "02-4bf92f3577b34da6a3ce929d0e0e4736-00f067aa0ba902b7-00",
			sc: trace.NewSpanContext(trace.SpanContextConfig{
				TraceID: traceID,
				SpanID:  spanID,
				Remote:  true,
			}),
		},
		{
			name:        "future version sampled",
			traceparent: "02-4bf92f3577b34da6a3ce929d0e0e4736-00f067aa0ba902b7-01",
			sc: trace.NewSpanContext(trace.SpanContextConfig{
				TraceID:    traceID,
				SpanID:     spanID,
				TraceFlags: trace.FlagsSampled,
				Remote:     true,
			}),
		},
		{
			name:        "future version sample bit set",
			traceparent: "02-4bf92f3577b34da6a3ce929d0e0e4736-00f067aa0ba902b7-09",
			sc: trace.NewSpanContext(trace.SpanContextConfig{
				TraceID:    traceID,
				SpanID:     spanID,
				TraceFlags: trace.FlagsSampled,
				Remote:     true,
			}),
		},
		{
			name:        "future version sample bit not set",
			traceparent: "02-4bf92f3577b34da6a3ce929d0e0e4736-00f067aa0ba902b7-08",
			sc: trace.NewSpanContext(trace.SpanContextConfig{
				TraceID: traceID,
				SpanID:  spanID,
				Remote:  true,
			}),
		},
		{
			name:        "future version additional data",
			traceparent: "02-4bf92f3577b34da6a3ce929d0e0e4736-00f067aa0ba902b7-00-XYZxsf09",
			sc: trace.NewSpanContext(trace.SpanContextConfig{
				TraceID: traceID,
				SpanID:  spanID,
				Remote:  true,
			}),
		},
		{
			name:        "B3 format ending in dash",
			traceparent: "00-4bf92f3577b34da6a3ce929d0e0e4736-00f067aa0ba902b7-00-",
			sc: trace.NewSpanContext(trace.SpanContextConfig{
				TraceID: traceID,
				SpanID:  spanID,
				Remote:  true,
			}),
		},
		{
			name:        "future version B3 format ending in dash",
			traceparent: "03-4bf92f3577b34da6a3ce929d0e0e4736-00f067aa0ba902b7-00-",
			sc: trace.NewSpanContext(trace.SpanContextConfig{
				TraceID: traceID,
				SpanID:  spanID,
				Remote:  true,
			}),
		},
	}
	otel.SetTextMapPropagator(propagation.NewCompositeTextMapPropagator(
		propagation.TraceContext{}, propagation.Baggage{}))
	propagator := otel.GetTextMapPropagator()

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			ctx := context.Background()
			md := metadata.MD{}
			md.Set("traceparent", tt.traceparent)
			md.Set("tracestate", tt.tracestate)
			_, spanCtx := Extract(ctx, propagator, &md)
			assert.Equal(t, tt.sc, spanCtx)
		})
	}
}

func TestExtractInvalidTraceContext(t *testing.T) {
	tests := []struct {
		name   string
		header string
	}{
		{
			name:   "wrong version length",
			header: "0000-00000000000000000000000000000000-0000000000000000-01",
		},
		{
			name:   "wrong trace ID length",
			header: "00-ab00000000000000000000000000000000-cd00000000000000-01",
		},
		{
			name:   "wrong span ID length",
			header: "00-ab000000000000000000000000000000-cd0000000000000000-01",
		},
		{
			name:   "wrong trace flag length",
			header: "00-ab000000000000000000000000000000-cd00000000000000-0100",
		},
		{
			name:   "bogus version",
			header: "qw-00000000000000000000000000000000-0000000000000000-01",
		},
		{
			name:   "bogus trace ID",
			header: "00-qw000000000000000000000000000000-cd00000000000000-01",
		},
		{
			name:   "bogus span ID",
			header: "00-ab000000000000000000000000000000-qw00000000000000-01",
		},
		{
			name:   "bogus trace flag",
			header: "00-ab000000000000000000000000000000-cd00000000000000-qw",
		},
		{
			name:   "upper case version",
			header: "A0-00000000000000000000000000000000-0000000000000000-01",
		},
		{
			name:   "upper case trace ID",
			header: "00-AB000000000000000000000000000000-cd00000000000000-01",
		},
		{
			name:   "upper case span ID",
			header: "00-ab000000000000000000000000000000-CD00000000000000-01",
		},
		{
			name:   "upper case trace flag",
			header: "00-ab000000000000000000000000000000-cd00000000000000-A1",
		},
		{
			name:   "zero trace ID and span ID",
			header: "00-00000000000000000000000000000000-0000000000000000-01",
		},
		{
			name:   "trace-flag unused bits set",
			header: "00-ab000000000000000000000000000000-cd00000000000000-09",
		},
		{
			name:   "missing options",
			header: "00-4bf92f3577b34da6a3ce929d0e0e4736-00f067aa0ba902b7",
		},
		{
			name:   "empty options",
			header: "00-4bf92f3577b34da6a3ce929d0e0e4736-00f067aa0ba902b7-",
		},
	}
	otel.SetTextMapPropagator(propagation.NewCompositeTextMapPropagator(
		propagation.TraceContext{}, propagation.Baggage{}))
	propagator := otel.GetTextMapPropagator()

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			ctx := context.Background()
			md := metadata.MD{}
			md.Set("traceparent", tt.header)
			_, spanCtx := Extract(ctx, propagator, &md)
			assert.Equal(t, trace.SpanContext{}, spanCtx)
		})
	}
}

func TestInjectValidTraceContext(t *testing.T) {
	stateStr := "key1=value1,key2=value2"
	state, err := trace.ParseTraceState(stateStr)
	require.NoError(t, err)

	tests := []struct {
		name        string
		traceparent string
		tracestate  string
		sc          trace.SpanContext
	}{
		{
			name:        "not sampled",
			traceparent: "00-4bf92f3577b34da6a3ce929d0e0e4736-00f067aa0ba902b7-00",
			sc: trace.NewSpanContext(trace.SpanContextConfig{
				TraceID: traceID,
				SpanID:  spanID,
				Remote:  true,
			}),
		},
		{
			name:        "sampled",
			traceparent: "00-4bf92f3577b34da6a3ce929d0e0e4736-00f067aa0ba902b7-01",
			sc: trace.NewSpanContext(trace.SpanContextConfig{
				TraceID:    traceID,
				SpanID:     spanID,
				TraceFlags: trace.FlagsSampled,
				Remote:     true,
			}),
		},
		{
			name:        "unsupported trace flag bits dropped",
			traceparent: "00-4bf92f3577b34da6a3ce929d0e0e4736-00f067aa0ba902b7-01",
			sc: trace.NewSpanContext(trace.SpanContextConfig{
				TraceID:    traceID,
				SpanID:     spanID,
				TraceFlags: 0xff,
				Remote:     true,
			}),
		},
		{
			name:        "with tracestate",
			traceparent: "00-4bf92f3577b34da6a3ce929d0e0e4736-00f067aa0ba902b7-00",
			tracestate:  stateStr,
			sc: trace.NewSpanContext(trace.SpanContextConfig{
				TraceID:    traceID,
				SpanID:     spanID,
				TraceState: state,
				Remote:     true,
			}),
		},
	}
	otel.SetTextMapPropagator(propagation.NewCompositeTextMapPropagator(
		propagation.TraceContext{}, propagation.Baggage{}))
	propagator := otel.GetTextMapPropagator()

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			ctx := context.Background()
			ctx = trace.ContextWithRemoteSpanContext(ctx, tt.sc)

			want := metadata.MD{}
			want.Set("traceparent", tt.traceparent)
			if len(tt.tracestate) > 0 {
				want.Set("tracestate", tt.tracestate)
			}

			md := metadata.MD{}
			Inject(ctx, propagator, &md)
			assert.Equal(t, want, md)

			mm := &metadataSupplier{
				metadata: &md,
			}
			assert.NotEmpty(t, mm.Keys())
		})
	}
}

func TestInvalidSpanContextDropped(t *testing.T) {
	invalidSC := trace.SpanContext{}
	require.False(t, invalidSC.IsValid())
	ctx := trace.ContextWithRemoteSpanContext(context.Background(), invalidSC)

	otel.SetTextMapPropagator(propagation.NewCompositeTextMapPropagator(
		propagation.TraceContext{}, propagation.Baggage{}))
	propagator := otel.GetTextMapPropagator()

	md := metadata.MD{}
	Inject(ctx, propagator, &md)
	mm := &metadataSupplier{
		metadata: &md,
	}
	assert.Empty(t, mm.Keys())
	assert.Equal(t, "", mm.Get("traceparent"), "injected invalid SpanContext")
}

```

File path: /Users/mac/Desktop/woker_code/monitor/common/trace/message_test.go
```golang
package trace

import (
	"context"
	"testing"

	"github.com/stretchr/testify/assert"
	"go.opentelemetry.io/otel/attribute"
	"go.opentelemetry.io/otel/codes"
	"go.opentelemetry.io/otel/trace"
	"google.golang.org/protobuf/reflect/protoreflect"
	"google.golang.org/protobuf/types/dynamicpb"
)

func TestMessageType_Event(t *testing.T) {
	var span mockSpan
	ctx := trace.ContextWithSpan(context.Background(), &span)
	MessageReceived.Event(ctx, 1, "foo")
	assert.Equal(t, messageEvent, span.name)
	assert.NotEmpty(t, span.options)
}

func TestMessageType_EventProtoMessage(t *testing.T) {
	var span mockSpan
	var message mockMessage
	ctx := trace.ContextWithSpan(context.Background(), &span)
	MessageReceived.Event(ctx, 1, message)
	assert.Equal(t, messageEvent, span.name)
	assert.NotEmpty(t, span.options)
}

type mockSpan struct {
	name    string
	options []trace.EventOption
}

func (m *mockSpan) End(options ...trace.SpanEndOption) {
}

func (m *mockSpan) AddEvent(name string, options ...trace.EventOption) {
	m.name = name
	m.options = options
}

func (m *mockSpan) IsRecording() bool {
	return false
}

func (m *mockSpan) RecordError(err error, options ...trace.EventOption) {
}

func (m *mockSpan) SpanContext() trace.SpanContext {
	panic("implement me")
}

func (m *mockSpan) SetStatus(code codes.Code, description string) {
}

func (m *mockSpan) SetName(name string) {
}

func (m *mockSpan) SetAttributes(kv ...attribute.KeyValue) {
}

func (m *mockSpan) TracerProvider() trace.TracerProvider {
	return nil
}

type mockMessage struct{}

func (m mockMessage) ProtoReflect() protoreflect.Message {
	return new(dynamicpb.Message)
}

```

File path: /Users/mac/Desktop/woker_code/monitor/common/trace/attributes_test.go
```golang
package trace

import (
	"testing"

	"github.com/stretchr/testify/assert"
	gcodes "google.golang.org/grpc/codes"
)

func TestStatusCodeAttr(t *testing.T) {
	assert.Equal(t, GRPCStatusCodeKey.Int(int(gcodes.DataLoss)), StatusCodeAttr(gcodes.DataLoss))
}

```

File path: /Users/mac/Desktop/woker_code/monitor/common/trace/agent.go
```golang
package trace

import (
	"context"
	"ezone.ksyun.com/ezone/luban/monitor/common/lang"
	"fmt"
	"net/url"
	"os"
	"sync"

	"go.opentelemetry.io/otel"
	"go.opentelemetry.io/otel/exporters/jaeger"
	"go.opentelemetry.io/otel/exporters/otlp/otlptrace/otlptracegrpc"
	"go.opentelemetry.io/otel/exporters/otlp/otlptrace/otlptracehttp"
	"go.opentelemetry.io/otel/exporters/stdout/stdouttrace"
	"go.opentelemetry.io/otel/exporters/zipkin"
	"go.opentelemetry.io/otel/sdk/resource"
	sdktrace "go.opentelemetry.io/otel/sdk/trace"
	semconv "go.opentelemetry.io/otel/semconv/v1.4.0"
)

const (
	kindJaeger   = "jaeger"
	kindZipkin   = "zipkin"
	kindOtlpGrpc = "otlpgrpc"
	kindOtlpHttp = "otlphttp"
	kindFile     = "file"
	kindStdout   = "stdout"
	protocolUdp  = "udp"
)

var (
	agents = make(map[string]lang.PlaceholderType)
	lock   sync.Mutex
	tp     *sdktrace.TracerProvider
)

// StartAgent starts an opentelemetry agent.
func StartAgent(c Config) {
	if c.Disabled {
		return
	}

	lock.Lock()
	defer lock.Unlock()

	_, ok := agents[c.Endpoint]
	if ok {
		return
	}

	// if error happens, let later calls run.
	if err := startAgent(c); err != nil {
		return
	}

	agents[c.Endpoint] = lang.Placeholder
}

// StopAgent shuts down the span processors in the order they were registered.
func StopAgent() {
	_ = tp.Shutdown(context.Background())
}

func createExporter(c Config) (sdktrace.SpanExporter, error) {
	// Just support jaeger and zipkin now, more for later
	switch c.Batcher {
	case kindJaeger:
		u, err := url.Parse(c.Endpoint)
		if err == nil && u.Scheme == protocolUdp {
			return jaeger.New(jaeger.WithAgentEndpoint(jaeger.WithAgentHost(u.Hostname()),
				jaeger.WithAgentPort(u.Port())))
		}
		return jaeger.New(jaeger.WithCollectorEndpoint(jaeger.WithEndpoint(c.Endpoint)))
	case kindZipkin:
		return zipkin.New(c.Endpoint)
	case kindOtlpGrpc:
		// Always treat trace exporter as optional component, so we use nonblock here,
		// otherwise this would slow down app start up even set a dial timeout here when
		// endpoint can not reach.
		// If the connection not dial success, the global otel ErrorHandler will catch error
		// when reporting data like other exporters.
		opts := []otlptracegrpc.Option{
			otlptracegrpc.WithInsecure(),
			otlptracegrpc.WithEndpoint(c.Endpoint),
		}
		if len(c.OtlpHeaders) > 0 {
			opts = append(opts, otlptracegrpc.WithHeaders(c.OtlpHeaders))
		}
		return otlptracegrpc.New(context.Background(), opts...)
	case kindOtlpHttp:
		// Not support flexible configuration now.
		opts := []otlptracehttp.Option{
			otlptracehttp.WithInsecure(),
			otlptracehttp.WithEndpoint(c.Endpoint),
		}
		if len(c.OtlpHeaders) > 0 {
			opts = append(opts, otlptracehttp.WithHeaders(c.OtlpHeaders))
		}
		if len(c.OtlpHttpPath) > 0 {
			opts = append(opts, otlptracehttp.WithURLPath(c.OtlpHttpPath))
		}
		return otlptracehttp.New(context.Background(), opts...)
	case kindFile:
		f, err := os.OpenFile(c.Endpoint, os.O_WRONLY|os.O_CREATE|os.O_APPEND, 0666)
		if err != nil {
			return nil, fmt.Errorf("file exporter endpoint error: %s", err.Error())
		}
		return stdouttrace.New(stdouttrace.WithWriter(f))
	case kindStdout:
		return stdouttrace.New(stdouttrace.WithPrettyPrint())
	default:
		return nil, fmt.Errorf("unknown exporter: %s", c.Batcher)
	}
}

func startAgent(c Config) error {
	AddResources(semconv.ServiceNameKey.String(c.Name))

	opts := []sdktrace.TracerProviderOption{
		// Set the sampling rate based on the parent span to 100%
		//sdktrace.WithSampler(sdktrace.ParentBased(sdktrace.TraceIDRatioBased(c.Sampler))),
		sdktrace.WithSampler(sdktrace.AlwaysSample()),

		// Record information about this application in a Resource.
		sdktrace.WithResource(resource.NewSchemaless(attrResources...)),
	}

	if len(c.Endpoint) > 0 {
		exp, err := createExporter(c)
		if err != nil {
			fmt.Println(err)
			return err
		}

		// Always be sure to batch in production.
		opts = append(opts, sdktrace.WithBatcher(exp))
	}

	tp = sdktrace.NewTracerProvider(opts...)
	otel.SetTracerProvider(tp)
	otel.SetErrorHandler(otel.ErrorHandlerFunc(func(err error) {
		fmt.Errorf("[otel] error: %v", err)
	}))

	return nil
}

```

File path: /Users/mac/Desktop/woker_code/monitor/common/trace/propagation.go
```golang
package trace

import (
	"go.opentelemetry.io/otel"
	"go.opentelemetry.io/otel/propagation"
)

func init() {
	otel.SetTextMapPropagator(propagation.NewCompositeTextMapPropagator(
		propagation.TraceContext{}, propagation.Baggage{}))
}

```

File path: /Users/mac/Desktop/woker_code/monitor/common/trace/utils.go
```golang
package trace

import (
	"context"
	"net"
	"strings"

	"go.opentelemetry.io/otel"
	"go.opentelemetry.io/otel/attribute"
	semconv "go.opentelemetry.io/otel/semconv/v1.4.0"
	"go.opentelemetry.io/otel/trace"
	"google.golang.org/grpc/peer"
)

const localhost = "127.0.0.1"

// ParseFullMethod returns the method name and attributes.
func ParseFullMethod(fullMethod string) (string, []attribute.KeyValue) {
	name := strings.TrimLeft(fullMethod, "/")
	parts := strings.SplitN(name, "/", 2)
	if len(parts) != 2 {
		// Invalid format, does not follow `/package.service/method`.
		return name, []attribute.KeyValue(nil)
	}

	var attrs []attribute.KeyValue
	if service := parts[0]; service != "" {
		attrs = append(attrs, semconv.RPCServiceKey.String(service))
	}
	if method := parts[1]; method != "" {
		attrs = append(attrs, semconv.RPCMethodKey.String(method))
	}

	return name, attrs
}

// PeerAttr returns the peer attributes.
func PeerAttr(addr string) []attribute.KeyValue {
	host, port, err := net.SplitHostPort(addr)
	if err != nil {
		return nil
	}

	if len(host) == 0 {
		host = localhost
	}

	return []attribute.KeyValue{
		semconv.NetPeerIPKey.String(host),
		semconv.NetPeerPortKey.String(port),
	}
}

// PeerFromCtx returns the peer from ctx.
func PeerFromCtx(ctx context.Context) string {
	p, ok := peer.FromContext(ctx)
	if !ok || p == nil {
		return ""
	}

	return p.Addr.String()
}

// SpanInfo returns the span info.
func SpanInfo(fullMethod, peerAddress string) (string, []attribute.KeyValue) {
	attrs := []attribute.KeyValue{RPCSystemGRPC}
	name, mAttrs := ParseFullMethod(fullMethod)
	attrs = append(attrs, mAttrs...)
	attrs = append(attrs, PeerAttr(peerAddress)...)
	return name, attrs
}

// TracerFromContext returns a tracer in ctx, otherwise returns a global tracer.
func TracerFromContext(ctx context.Context) (tracer trace.Tracer) {
	if span := trace.SpanFromContext(ctx); span.SpanContext().IsValid() {
		tracer = span.TracerProvider().Tracer(TraceName)
	} else {
		tracer = otel.Tracer(TraceName)
	}

	return
}

func SpanIDFromContext(ctx context.Context) string {
	spanCtx := trace.SpanContextFromContext(ctx)
	if spanCtx.HasSpanID() {
		return spanCtx.SpanID().String()
	}

	return ""
}

func TraceIDFromContext(ctx context.Context) string {
	spanCtx := trace.SpanContextFromContext(ctx)
	if spanCtx.HasTraceID() {
		return spanCtx.TraceID().String()
	}

	return ""
}

```

File path: /Users/mac/Desktop/woker_code/monitor/common/trace/agent_test.go
```golang
package trace

import (
	"testing"

	"github.com/stretchr/testify/assert"
)

func TestStartAgent(t *testing.T) {

	const (
		endpoint1  = "localhost:1234"
		endpoint2  = "remotehost:1234"
		endpoint3  = "localhost:1235"
		endpoint4  = "localhost:1236"
		endpoint5  = "udp://localhost:6831"
		endpoint6  = "localhost:1237"
		endpoint71 = "/tmp/trace.log"
		endpoint72 = "/not-exist-fs/trace.log"
	)
	c1 := Config{
		Name: "foo",
	}
	c2 := Config{
		Name:     "bar",
		Endpoint: endpoint1,
		Batcher:  kindJaeger,
	}
	c3 := Config{
		Name:     "any",
		Endpoint: endpoint2,
		Batcher:  kindZipkin,
	}
	c4 := Config{
		Name:     "bla",
		Endpoint: endpoint3,
		Batcher:  "otlp",
	}
	c5 := Config{
		Name:     "otlpgrpc",
		Endpoint: endpoint3,
		Batcher:  kindOtlpGrpc,
		OtlpHeaders: map[string]string{
			"uptrace-dsn": "http://project2_secret_token@localhost:14317/2",
		},
	}
	c6 := Config{
		Name:     "otlphttp",
		Endpoint: endpoint4,
		Batcher:  kindOtlpHttp,
		OtlpHeaders: map[string]string{
			"uptrace-dsn": "http://project2_secret_token@localhost:14318/2",
		},
		OtlpHttpPath: "/v1/traces",
	}
	c7 := Config{
		Name:     "UDP",
		Endpoint: endpoint5,
		Batcher:  kindJaeger,
	}
	c8 := Config{
		Disabled: true,
		Endpoint: endpoint6,
		Batcher:  kindJaeger,
	}
	c9 := Config{
		Name:     "file",
		Endpoint: endpoint71,
		Batcher:  kindFile,
	}
	c10 := Config{
		Name:     "file",
		Endpoint: endpoint72,
		Batcher:  kindFile,
	}

	StartAgent(c1)
	StartAgent(c1)
	StartAgent(c2)
	StartAgent(c3)
	StartAgent(c4)
	StartAgent(c5)
	StartAgent(c6)
	StartAgent(c7)
	StartAgent(c8)
	StartAgent(c9)
	StartAgent(c10)
	defer StopAgent()

	lock.Lock()
	defer lock.Unlock()

	// because remotehost cannot be resolved
	assert.Equal(t, 6, len(agents))
	_, ok := agents[""]
	assert.True(t, ok)
	_, ok = agents[endpoint1]
	assert.True(t, ok)
	_, ok = agents[endpoint2]
	assert.False(t, ok)
	_, ok = agents[endpoint5]
	assert.True(t, ok)
	_, ok = agents[endpoint6]
	assert.False(t, ok)
	_, ok = agents[endpoint71]
	assert.True(t, ok)
	_, ok = agents[endpoint72]
	assert.False(t, ok)
}

```

File path: /Users/mac/Desktop/woker_code/monitor/common/trace/tracer.go
```golang
package trace

import (
	"context"

	"go.opentelemetry.io/otel/baggage"
	"go.opentelemetry.io/otel/propagation"
	sdktrace "go.opentelemetry.io/otel/trace"
	"google.golang.org/grpc/metadata"
)

// assert that metadataSupplier implements the TextMapCarrier interface
var _ propagation.TextMapCarrier = (*metadataSupplier)(nil)

type metadataSupplier struct {
	metadata *metadata.MD
}

func (s *metadataSupplier) Get(key string) string {
	values := s.metadata.Get(key)
	if len(values) == 0 {
		return ""
	}

	return values[0]
}

func (s *metadataSupplier) Set(key, value string) {
	s.metadata.Set(key, value)
}

func (s *metadataSupplier) Keys() []string {
	out := make([]string, 0, len(*s.metadata))
	for key := range *s.metadata {
		out = append(out, key)
	}

	return out
}

// Inject injects cross-cutting concerns from the ctx into the metadata.
func Inject(ctx context.Context, p propagation.TextMapPropagator, metadata *metadata.MD) {
	p.Inject(ctx, &metadataSupplier{
		metadata: metadata,
	})
}

// Extract extracts the metadata from ctx.
func Extract(ctx context.Context, p propagation.TextMapPropagator, metadata *metadata.MD) (
	baggage.Baggage, sdktrace.SpanContext) {
	ctx = p.Extract(ctx, &metadataSupplier{
		metadata: metadata,
	})

	return baggage.FromContext(ctx), sdktrace.SpanContextFromContext(ctx)
}

```

File path: /Users/mac/Desktop/woker_code/monitor/common/trace/tracetest/tracetest.go
```golang
package tracetest

import (
	"testing"

	"go.opentelemetry.io/otel"
	"go.opentelemetry.io/otel/sdk/trace"
	"go.opentelemetry.io/otel/sdk/trace/tracetest"
)

// NewInMemoryExporter returns a new InMemoryExporter
// and sets it as the global for tests.
func NewInMemoryExporter(t *testing.T) *tracetest.InMemoryExporter {
	me := tracetest.NewInMemoryExporter()
	t.Cleanup(func() {
		me.Reset()
	})
	otel.SetTracerProvider(trace.NewTracerProvider(trace.WithSyncer(me)))

	return me
}

```

File path: /Users/mac/Desktop/woker_code/monitor/common/rpc_client/resource/client.go
```golang
package resource

import (
	resource_networkv1alpha "ezone.ksyun.com/ezone/luban/luban_api/resourceapis/resource_network/v1alpha/gen"
	resource_serverv1alpha "ezone.ksyun.com/ezone/luban/luban_api/resourceapis/resource_server/v1alpha/gen"
	"google.golang.org/grpc"
)

type NetworkClient struct {
}

func NewNetworkClient(cc grpc.ClientConnInterface) resource_networkv1alpha.ResourceNetworkClient {
	return resource_networkv1alpha.NewResourceNetworkClient(cc)
}

func NewServerClient(cc grpc.ClientConnInterface) resource_serverv1alpha.ResourceServiceClient {
	return resource_serverv1alpha.NewResourceServiceClient(cc)
}

```

File path: /Users/mac/Desktop/woker_code/monitor/common/mr/mapreduce_fuzz_test.go
```golang
//go:build go1.18
// +build go1.18

package mr

import (
	"fmt"
	"math/rand"
	"runtime"
	"strings"
	"testing"
	"time"

	"github.com/stretchr/testify/assert"
	"go.uber.org/goleak"
)

func FuzzMapReduce(f *testing.F) {
	rand.Seed(time.Now().UnixNano())

	f.Add(uint(10), uint(runtime.NumCPU()))
	f.Fuzz(func(t *testing.T, num uint, workers uint) {
		n := int64(num)%5000 + 5000
		genPanic := rand.Intn(100) == 0
		mapperPanic := rand.Intn(100) == 0
		reducerPanic := rand.Intn(100) == 0
		genIdx := rand.Int63n(n)
		mapperIdx := rand.Int63n(n)
		reducerIdx := rand.Int63n(n)
		squareSum := (n - 1) * n * (2*n - 1) / 6

		fn := func() (interface{}, error) {
			defer goleak.VerifyNone(t, goleak.IgnoreCurrent())

			return MapReduce(func(source chan<- interface{}) {
				for i := int64(0); i < n; i++ {
					source <- i
					if genPanic && i == genIdx {
						panic("foo")
					}
				}
			}, func(item interface{}, writer Writer, cancel func(error)) {
				v := item.(int64)
				if mapperPanic && v == mapperIdx {
					panic("bar")
				}
				writer.Write(v * v)
			}, func(pipe <-chan interface{}, writer Writer, cancel func(error)) {
				var idx int64
				var total int64
				for v := range pipe {
					if reducerPanic && idx == reducerIdx {
						panic("baz")
					}
					total += v.(int64)
					idx++
				}
				writer.Write(total)
			}, WithWorkers(int(workers)%50+runtime.NumCPU()/2))
		}

		if genPanic || mapperPanic || reducerPanic {
			var buf strings.Builder
			buf.WriteString(fmt.Sprintf("n: %d", n))
			buf.WriteString(fmt.Sprintf(", genPanic: %t", genPanic))
			buf.WriteString(fmt.Sprintf(", mapperPanic: %t", mapperPanic))
			buf.WriteString(fmt.Sprintf(", reducerPanic: %t", reducerPanic))
			buf.WriteString(fmt.Sprintf(", genIdx: %d", genIdx))
			buf.WriteString(fmt.Sprintf(", mapperIdx: %d", mapperIdx))
			buf.WriteString(fmt.Sprintf(", reducerIdx: %d", reducerIdx))
			assert.Panicsf(t, func() { fn() }, buf.String())
		} else {
			val, err := fn()
			assert.Nil(t, err)
			assert.Equal(t, squareSum, val.(int64))
		}
	})
}

```

File path: /Users/mac/Desktop/woker_code/monitor/common/mr/mapreduce.go
```golang
package mr

import (
	"context"
	"errors"
	"sync"
	"sync/atomic"

	"ezone.ksyun.com/ezone/luban/monitor/common/errorx"
	"ezone.ksyun.com/ezone/luban/monitor/common/lang"
)

const (
	defaultWorkers = 16
	minWorkers     = 1
)

var (
	// ErrCancelWithNil is an error that mapreduce was cancelled with nil.
	ErrCancelWithNil = errors.New("mapreduce cancelled with nil")
	// ErrReduceNoOutput is an error that reduce did not output a value.
	ErrReduceNoOutput = errors.New("reduce not writing value")
)

type (
	// ForEachFunc is used to do element processing, but no output.
	ForEachFunc func(item interface{})
	// GenerateFunc is used to let callers send elements into source.
	GenerateFunc func(source chan<- interface{})
	// MapFunc is used to do element processing and write the output to writer.
	MapFunc func(item interface{}, writer Writer)
	// MapperFunc is used to do element processing and write the output to writer,
	// use cancel func to cancel the processing.
	MapperFunc func(item interface{}, writer Writer, cancel func(error))
	// ReducerFunc is used to reduce all the mapping output and write to writer,
	// use cancel func to cancel the processing.
	ReducerFunc func(pipe <-chan interface{}, writer Writer, cancel func(error))
	// VoidReducerFunc is used to reduce all the mapping output, but no output.
	// Use cancel func to cancel the processing.
	VoidReducerFunc func(pipe <-chan interface{}, cancel func(error))
	// Option defines the method to customize the mapreduce.
	Option func(opts *mapReduceOptions)

	mapperContext struct {
		ctx       context.Context
		mapper    MapFunc
		source    <-chan interface{}
		panicChan *onceChan
		collector chan<- interface{}
		doneChan  <-chan lang.PlaceholderType
		workers   int
	}

	mapReduceOptions struct {
		ctx     context.Context
		workers int
	}

	// Writer interface wraps Write method.
	Writer interface {
		Write(v interface{})
	}
)

// Finish runs fns parallelly, cancelled on any error.
func Finish(fns ...func() error) error {
	if len(fns) == 0 {
		return nil
	}

	return MapReduceVoid(func(source chan<- interface{}) {
		for _, fn := range fns {
			source <- fn
		}
	}, func(item interface{}, writer Writer, cancel func(error)) {
		fn := item.(func() error)
		if err := fn(); err != nil {
			cancel(err)
		}
	}, func(pipe <-chan interface{}, cancel func(error)) {
	}, WithWorkers(len(fns)))
}

// FinishVoid runs fns parallelly.
func FinishVoid(fns ...func()) {
	if len(fns) == 0 {
		return
	}

	ForEach(func(source chan<- interface{}) {
		for _, fn := range fns {
			source <- fn
		}
	}, func(item interface{}) {
		fn := item.(func())
		fn()
	}, WithWorkers(len(fns)))
}

// ForEach maps all elements from given generate but no output.
func ForEach(generate GenerateFunc, mapper ForEachFunc, opts ...Option) {
	options := buildOptions(opts...)
	panicChan := &onceChan{channel: make(chan interface{})}
	source := buildSource(generate, panicChan)
	collector := make(chan interface{})
	done := make(chan lang.PlaceholderType)

	go executeMappers(mapperContext{
		ctx: options.ctx,
		mapper: func(item interface{}, _ Writer) {
			mapper(item)
		},
		source:    source,
		panicChan: panicChan,
		collector: collector,
		doneChan:  done,
		workers:   options.workers,
	})

	for {
		select {
		case v := <-panicChan.channel:
			panic(v)
		case _, ok := <-collector:
			if !ok {
				return
			}
		}
	}
}

// MapReduce maps all elements generated from given generate func,
// and reduces the output elements with given reducer.
func MapReduce(generate GenerateFunc, mapper MapperFunc, reducer ReducerFunc,
	opts ...Option) (interface{}, error) {
	panicChan := &onceChan{channel: make(chan interface{})}
	source := buildSource(generate, panicChan)
	return mapReduceWithPanicChan(source, panicChan, mapper, reducer, opts...)
}

// MapReduceChan maps all elements from source, and reduce the output elements with given reducer.
func MapReduceChan(source <-chan interface{}, mapper MapperFunc, reducer ReducerFunc,
	opts ...Option) (interface{}, error) {
	panicChan := &onceChan{channel: make(chan interface{})}
	return mapReduceWithPanicChan(source, panicChan, mapper, reducer, opts...)
}

// MapReduceChan maps all elements from source, and reduce the output elements with given reducer.
func mapReduceWithPanicChan(source <-chan interface{}, panicChan *onceChan, mapper MapperFunc,
	reducer ReducerFunc, opts ...Option) (interface{}, error) {
	options := buildOptions(opts...)
	// output is used to write the final result
	output := make(chan interface{})
	defer func() {
		// reducer can only write once, if more, panic
		for range output {
			panic("more than one element written in reducer")
		}
	}()

	// collector is used to collect data from mapper, and consume in reducer
	collector := make(chan interface{}, options.workers)
	// if done is closed, all mappers and reducer should stop processing
	done := make(chan lang.PlaceholderType)
	writer := newGuardedWriter(options.ctx, output, done)
	var closeOnce sync.Once
	// use atomic.Value to avoid data race
	var retErr errorx.AtomicError
	finish := func() {
		closeOnce.Do(func() {
			close(done)
			close(output)
		})
	}
	cancel := once(func(err error) {
		if err != nil {
			retErr.Set(err)
		} else {
			retErr.Set(ErrCancelWithNil)
		}

		drain(source)
		finish()
	})

	go func() {
		defer func() {
			drain(collector)
			if r := recover(); r != nil {
				panicChan.write(r)
			}
			finish()
		}()

		reducer(collector, writer, cancel)
	}()

	go executeMappers(mapperContext{
		ctx: options.ctx,
		mapper: func(item interface{}, w Writer) {
			mapper(item, w, cancel)
		},
		source:    source,
		panicChan: panicChan,
		collector: collector,
		doneChan:  done,
		workers:   options.workers,
	})

	select {
	case <-options.ctx.Done():
		cancel(context.DeadlineExceeded)
		return nil, context.DeadlineExceeded
	case v := <-panicChan.channel:
		panic(v)
	case v, ok := <-output:
		if err := retErr.Load(); err != nil {
			return nil, err
		} else if ok {
			return v, nil
		} else {
			return nil, ErrReduceNoOutput
		}
	}
}

// MapReduceVoid maps all elements generated from given generate,
// and reduce the output elements with given reducer.
func MapReduceVoid(generate GenerateFunc, mapper MapperFunc, reducer VoidReducerFunc, opts ...Option) error {
	_, err := MapReduce(generate, mapper, func(input <-chan interface{}, writer Writer, cancel func(error)) {
		reducer(input, cancel)
	}, opts...)
	if errors.Is(err, ErrReduceNoOutput) {
		return nil
	}

	return err
}

// WithContext customizes a mapreduce processing accepts a given ctx.
func WithContext(ctx context.Context) Option {
	return func(opts *mapReduceOptions) {
		opts.ctx = ctx
	}
}

// WithWorkers customizes a mapreduce processing with given workers.
func WithWorkers(workers int) Option {
	return func(opts *mapReduceOptions) {
		if workers < minWorkers {
			opts.workers = minWorkers
		} else {
			opts.workers = workers
		}
	}
}

func buildOptions(opts ...Option) *mapReduceOptions {
	options := newOptions()
	for _, opt := range opts {
		opt(options)
	}

	return options
}

func buildSource(generate GenerateFunc, panicChan *onceChan) chan interface{} {
	source := make(chan interface{})
	go func() {
		defer func() {
			if r := recover(); r != nil {
				panicChan.write(r)
			}
			close(source)
		}()

		generate(source)
	}()

	return source
}

// drain drains the channel.
func drain(channel <-chan interface{}) {
	// drain the channel
	for range channel {
	}
}

func executeMappers(mCtx mapperContext) {
	var wg sync.WaitGroup
	defer func() {
		wg.Wait()
		close(mCtx.collector)
		drain(mCtx.source)
	}()

	var failed int32
	pool := make(chan lang.PlaceholderType, mCtx.workers)
	writer := newGuardedWriter(mCtx.ctx, mCtx.collector, mCtx.doneChan)
	for atomic.LoadInt32(&failed) == 0 {
		select {
		case <-mCtx.ctx.Done():
			return
		case <-mCtx.doneChan:
			return
		case pool <- lang.Placeholder:
			item, ok := <-mCtx.source
			if !ok {
				<-pool
				return
			}

			wg.Add(1)
			go func() {
				defer func() {
					if r := recover(); r != nil {
						atomic.AddInt32(&failed, 1)
						mCtx.panicChan.write(r)
					}
					wg.Done()
					<-pool
				}()

				mCtx.mapper(item, writer)
			}()
		}
	}
}

func newOptions() *mapReduceOptions {
	return &mapReduceOptions{
		ctx:     context.Background(),
		workers: defaultWorkers,
	}
}

func once(fn func(error)) func(error) {
	once := new(sync.Once)
	return func(err error) {
		once.Do(func() {
			fn(err)
		})
	}
}

type guardedWriter struct {
	ctx     context.Context
	channel chan<- interface{}
	done    <-chan lang.PlaceholderType
}

func newGuardedWriter(ctx context.Context, channel chan<- interface{},
	done <-chan lang.PlaceholderType) guardedWriter {
	return guardedWriter{
		ctx:     ctx,
		channel: channel,
		done:    done,
	}
}

func (gw guardedWriter) Write(v interface{}) {
	select {
	case <-gw.ctx.Done():
		return
	case <-gw.done:
		return
	default:
		gw.channel <- v
	}
}

type onceChan struct {
	channel chan interface{}
	wrote   int32
}

func (oc *onceChan) write(val interface{}) {
	if atomic.CompareAndSwapInt32(&oc.wrote, 0, 1) {
		oc.channel <- val
	}
}

```

File path: /Users/mac/Desktop/woker_code/monitor/common/mr/mapreduce_test.go
```golang
package mr

import (
	"context"
	"errors"
	"io/ioutil"
	"log"
	"runtime"
	"sync/atomic"
	"testing"
	"time"

	"github.com/stretchr/testify/assert"
	"go.uber.org/goleak"
)

var errDummy = errors.New("dummy")

func init() {
	log.SetOutput(ioutil.Discard)
}

func TestFinish(t *testing.T) {
	defer goleak.VerifyNone(t)

	var total uint32
	err := Finish(func() error {
		atomic.AddUint32(&total, 2)
		return nil
	}, func() error {
		atomic.AddUint32(&total, 3)
		return nil
	}, func() error {
		atomic.AddUint32(&total, 5)
		return nil
	})

	assert.Equal(t, uint32(10), atomic.LoadUint32(&total))
	assert.Nil(t, err)
}

func TestFinishNone(t *testing.T) {
	defer goleak.VerifyNone(t)

	assert.Nil(t, Finish())
}

func TestFinishVoidNone(t *testing.T) {
	defer goleak.VerifyNone(t)

	FinishVoid()
}

func TestFinishErr(t *testing.T) {
	defer goleak.VerifyNone(t)

	var total uint32
	err := Finish(func() error {
		atomic.AddUint32(&total, 2)
		return nil
	}, func() error {
		atomic.AddUint32(&total, 3)
		return errDummy
	}, func() error {
		atomic.AddUint32(&total, 5)
		return nil
	})

	assert.Equal(t, errDummy, err)
}

func TestFinishVoid(t *testing.T) {
	defer goleak.VerifyNone(t)

	var total uint32
	FinishVoid(func() {
		atomic.AddUint32(&total, 2)
	}, func() {
		atomic.AddUint32(&total, 3)
	}, func() {
		atomic.AddUint32(&total, 5)
	})

	assert.Equal(t, uint32(10), atomic.LoadUint32(&total))
}

func TestForEach(t *testing.T) {
	const tasks = 1000

	t.Run("all", func(t *testing.T) {
		defer goleak.VerifyNone(t)

		var count uint32
		ForEach(func(source chan<- interface{}) {
			for i := 0; i < tasks; i++ {
				source <- i
			}
		}, func(item interface{}) {
			atomic.AddUint32(&count, 1)
		}, WithWorkers(-1))

		assert.Equal(t, tasks, int(count))
	})

	t.Run("odd", func(t *testing.T) {
		defer goleak.VerifyNone(t)

		var count uint32
		ForEach(func(source chan<- interface{}) {
			for i := 0; i < tasks; i++ {
				source <- i
			}
		}, func(item interface{}) {
			if item.(int)%2 == 0 {
				atomic.AddUint32(&count, 1)
			}
		})

		assert.Equal(t, tasks/2, int(count))
	})

	t.Run("all", func(t *testing.T) {
		defer goleak.VerifyNone(t)

		assert.PanicsWithValue(t, "foo", func() {
			ForEach(func(source chan<- interface{}) {
				for i := 0; i < tasks; i++ {
					source <- i
				}
			}, func(item interface{}) {
				panic("foo")
			})
		})
	})
}

func TestGeneratePanic(t *testing.T) {
	defer goleak.VerifyNone(t)

	t.Run("all", func(t *testing.T) {
		assert.PanicsWithValue(t, "foo", func() {
			ForEach(func(source chan<- interface{}) {
				panic("foo")
			}, func(item interface{}) {
			})
		})
	})
}

func TestMapperPanic(t *testing.T) {
	defer goleak.VerifyNone(t)

	const tasks = 1000
	var run int32
	t.Run("all", func(t *testing.T) {
		assert.PanicsWithValue(t, "foo", func() {
			_, _ = MapReduce(func(source chan<- interface{}) {
				for i := 0; i < tasks; i++ {
					source <- i
				}
			}, func(item interface{}, writer Writer, cancel func(error)) {
				atomic.AddInt32(&run, 1)
				panic("foo")
			}, func(pipe <-chan interface{}, writer Writer, cancel func(error)) {
			})
		})
		assert.True(t, atomic.LoadInt32(&run) < tasks/2)
	})
}

func TestMapReduce(t *testing.T) {
	defer goleak.VerifyNone(t)

	tests := []struct {
		name        string
		mapper      MapperFunc
		reducer     ReducerFunc
		expectErr   error
		expectValue interface{}
	}{
		{
			name:        "simple",
			expectErr:   nil,
			expectValue: 30,
		},
		{
			name: "cancel with error",
			mapper: func(item interface{}, writer Writer, cancel func(error)) {
				v := item.(int)
				if v%3 == 0 {
					cancel(errDummy)
				}
				writer.Write(v * v)
			},
			expectErr: errDummy,
		},
		{
			name: "cancel with nil",
			mapper: func(item interface{}, writer Writer, cancel func(error)) {
				v := item.(int)
				if v%3 == 0 {
					cancel(nil)
				}
				writer.Write(v * v)
			},
			expectErr:   ErrCancelWithNil,
			expectValue: nil,
		},
		{
			name: "cancel with more",
			reducer: func(pipe <-chan interface{}, writer Writer, cancel func(error)) {
				var result int
				for item := range pipe {
					result += item.(int)
					if result > 10 {
						cancel(errDummy)
					}
				}
				writer.Write(result)
			},
			expectErr: errDummy,
		},
	}

	t.Run("MapReduce", func(t *testing.T) {
		for _, test := range tests {
			t.Run(test.name, func(t *testing.T) {
				if test.mapper == nil {
					test.mapper = func(item interface{}, writer Writer, cancel func(error)) {
						v := item.(int)
						writer.Write(v * v)
					}
				}
				if test.reducer == nil {
					test.reducer = func(pipe <-chan interface{}, writer Writer, cancel func(error)) {
						var result int
						for item := range pipe {
							result += item.(int)
						}
						writer.Write(result)
					}
				}
				value, err := MapReduce(func(source chan<- interface{}) {
					for i := 1; i < 5; i++ {
						source <- i
					}
				}, test.mapper, test.reducer, WithWorkers(runtime.NumCPU()))

				assert.Equal(t, test.expectErr, err)
				assert.Equal(t, test.expectValue, value)
			})
		}
	})

	t.Run("MapReduce", func(t *testing.T) {
		for _, test := range tests {
			t.Run(test.name, func(t *testing.T) {
				if test.mapper == nil {
					test.mapper = func(item interface{}, writer Writer, cancel func(error)) {
						v := item.(int)
						writer.Write(v * v)
					}
				}
				if test.reducer == nil {
					test.reducer = func(pipe <-chan interface{}, writer Writer, cancel func(error)) {
						var result int
						for item := range pipe {
							result += item.(int)
						}
						writer.Write(result)
					}
				}

				source := make(chan interface{})
				go func() {
					for i := 1; i < 5; i++ {
						source <- i
					}
					close(source)
				}()

				value, err := MapReduceChan(source, test.mapper, test.reducer, WithWorkers(-1))
				assert.Equal(t, test.expectErr, err)
				assert.Equal(t, test.expectValue, value)
			})
		}
	})
}

func TestMapReduceWithReduerWriteMoreThanOnce(t *testing.T) {
	defer goleak.VerifyNone(t)

	assert.Panics(t, func() {
		MapReduce(func(source chan<- interface{}) {
			for i := 0; i < 10; i++ {
				source <- i
			}
		}, func(item interface{}, writer Writer, cancel func(error)) {
			writer.Write(item)
		}, func(pipe <-chan interface{}, writer Writer, cancel func(error)) {
			drain(pipe)
			writer.Write("one")
			writer.Write("two")
		})
	})
}

func TestMapReduceVoid(t *testing.T) {
	defer goleak.VerifyNone(t)

	var value uint32
	tests := []struct {
		name        string
		mapper      MapperFunc
		reducer     VoidReducerFunc
		expectValue uint32
		expectErr   error
	}{
		{
			name:        "simple",
			expectValue: 30,
			expectErr:   nil,
		},
		{
			name: "cancel with error",
			mapper: func(item interface{}, writer Writer, cancel func(error)) {
				v := item.(int)
				if v%3 == 0 {
					cancel(errDummy)
				}
				writer.Write(v * v)
			},
			expectErr: errDummy,
		},
		{
			name: "cancel with nil",
			mapper: func(item interface{}, writer Writer, cancel func(error)) {
				v := item.(int)
				if v%3 == 0 {
					cancel(nil)
				}
				writer.Write(v * v)
			},
			expectErr: ErrCancelWithNil,
		},
		{
			name: "cancel with more",
			reducer: func(pipe <-chan interface{}, cancel func(error)) {
				for item := range pipe {
					result := atomic.AddUint32(&value, uint32(item.(int)))
					if result > 10 {
						cancel(errDummy)
					}
				}
			},
			expectErr: errDummy,
		},
	}

	for _, test := range tests {
		t.Run(test.name, func(t *testing.T) {
			atomic.StoreUint32(&value, 0)

			if test.mapper == nil {
				test.mapper = func(item interface{}, writer Writer, cancel func(error)) {
					v := item.(int)
					writer.Write(v * v)
				}
			}
			if test.reducer == nil {
				test.reducer = func(pipe <-chan interface{}, cancel func(error)) {
					for item := range pipe {
						atomic.AddUint32(&value, uint32(item.(int)))
					}
				}
			}
			err := MapReduceVoid(func(source chan<- interface{}) {
				for i := 1; i < 5; i++ {
					source <- i
				}
			}, test.mapper, test.reducer)

			assert.Equal(t, test.expectErr, err)
			if err == nil {
				assert.Equal(t, test.expectValue, atomic.LoadUint32(&value))
			}
		})
	}
}

func TestMapReduceVoidWithDelay(t *testing.T) {
	defer goleak.VerifyNone(t)

	var result []int
	err := MapReduceVoid(func(source chan<- interface{}) {
		source <- 0
		source <- 1
	}, func(item interface{}, writer Writer, cancel func(error)) {
		i := item.(int)
		if i == 0 {
			time.Sleep(time.Millisecond * 50)
		}
		writer.Write(i)
	}, func(pipe <-chan interface{}, cancel func(error)) {
		for item := range pipe {
			i := item.(int)
			result = append(result, i)
		}
	})
	assert.Nil(t, err)
	assert.Equal(t, 2, len(result))
	assert.Equal(t, 1, result[0])
	assert.Equal(t, 0, result[1])
}

func TestMapReducePanic(t *testing.T) {
	defer goleak.VerifyNone(t)

	assert.Panics(t, func() {
		_, _ = MapReduce(func(source chan<- interface{}) {
			source <- 0
			source <- 1
		}, func(item interface{}, writer Writer, cancel func(error)) {
			i := item.(int)
			writer.Write(i)
		}, func(pipe <-chan interface{}, writer Writer, cancel func(error)) {
			for range pipe {
				panic("panic")
			}
		})
	})
}

func TestMapReducePanicOnce(t *testing.T) {
	defer goleak.VerifyNone(t)

	assert.Panics(t, func() {
		_, _ = MapReduce(func(source chan<- interface{}) {
			for i := 0; i < 100; i++ {
				source <- i
			}
		}, func(item interface{}, writer Writer, cancel func(error)) {
			i := item.(int)
			if i == 0 {
				panic("foo")
			}
			writer.Write(i)
		}, func(pipe <-chan interface{}, writer Writer, cancel func(error)) {
			for range pipe {
				panic("bar")
			}
		})
	})
}

func TestMapReducePanicBothMapperAndReducer(t *testing.T) {
	defer goleak.VerifyNone(t)

	assert.Panics(t, func() {
		_, _ = MapReduce(func(source chan<- interface{}) {
			source <- 0
			source <- 1
		}, func(item interface{}, writer Writer, cancel func(error)) {
			panic("foo")
		}, func(pipe <-chan interface{}, writer Writer, cancel func(error)) {
			panic("bar")
		})
	})
}

func TestMapReduceVoidCancel(t *testing.T) {
	defer goleak.VerifyNone(t)

	var result []int
	err := MapReduceVoid(func(source chan<- interface{}) {
		source <- 0
		source <- 1
	}, func(item interface{}, writer Writer, cancel func(error)) {
		i := item.(int)
		if i == 1 {
			cancel(errors.New("anything"))
		}
		writer.Write(i)
	}, func(pipe <-chan interface{}, cancel func(error)) {
		for item := range pipe {
			i := item.(int)
			result = append(result, i)
		}
	})
	assert.NotNil(t, err)
	assert.Equal(t, "anything", err.Error())
}

func TestMapReduceVoidCancelWithRemains(t *testing.T) {
	defer goleak.VerifyNone(t)

	var done int32
	var result []int
	err := MapReduceVoid(func(source chan<- interface{}) {
		for i := 0; i < defaultWorkers*2; i++ {
			source <- i
		}
		atomic.AddInt32(&done, 1)
	}, func(item interface{}, writer Writer, cancel func(error)) {
		i := item.(int)
		if i == defaultWorkers/2 {
			cancel(errors.New("anything"))
		}
		writer.Write(i)
	}, func(pipe <-chan interface{}, cancel func(error)) {
		for item := range pipe {
			i := item.(int)
			result = append(result, i)
		}
	})
	assert.NotNil(t, err)
	assert.Equal(t, "anything", err.Error())
	assert.Equal(t, int32(1), done)
}

func TestMapReduceWithoutReducerWrite(t *testing.T) {
	defer goleak.VerifyNone(t)

	uids := []int{1, 2, 3}
	res, err := MapReduce(func(source chan<- interface{}) {
		for _, uid := range uids {
			source <- uid
		}
	}, func(item interface{}, writer Writer, cancel func(error)) {
		writer.Write(item)
	}, func(pipe <-chan interface{}, writer Writer, cancel func(error)) {
		drain(pipe)
		// not calling writer.Write(...), should not panic
	})
	assert.Equal(t, ErrReduceNoOutput, err)
	assert.Nil(t, res)
}

func TestMapReduceVoidPanicInReducer(t *testing.T) {
	defer goleak.VerifyNone(t)

	const message = "foo"
	assert.Panics(t, func() {
		var done int32
		_ = MapReduceVoid(func(source chan<- interface{}) {
			for i := 0; i < defaultWorkers*2; i++ {
				source <- i
			}
			atomic.AddInt32(&done, 1)
		}, func(item interface{}, writer Writer, cancel func(error)) {
			i := item.(int)
			writer.Write(i)
		}, func(pipe <-chan interface{}, cancel func(error)) {
			panic(message)
		}, WithWorkers(1))
	})
}

func TestForEachWithContext(t *testing.T) {
	defer goleak.VerifyNone(t)

	var done int32
	ctx, cancel := context.WithCancel(context.Background())
	ForEach(func(source chan<- interface{}) {
		for i := 0; i < defaultWorkers*2; i++ {
			source <- i
		}
		atomic.AddInt32(&done, 1)
	}, func(item interface{}) {
		i := item.(int)
		if i == defaultWorkers/2 {
			cancel()
		}
	}, WithContext(ctx))
}

func TestMapReduceWithContext(t *testing.T) {
	defer goleak.VerifyNone(t)

	var done int32
	var result []int
	ctx, cancel := context.WithCancel(context.Background())
	err := MapReduceVoid(func(source chan<- interface{}) {
		for i := 0; i < defaultWorkers*2; i++ {
			source <- i
		}
		atomic.AddInt32(&done, 1)
	}, func(item interface{}, writer Writer, c func(error)) {
		i := item.(int)
		if i == defaultWorkers/2 {
			cancel()
		}
		writer.Write(i)
	}, func(pipe <-chan interface{}, cancel func(error)) {
		for item := range pipe {
			i := item.(int)
			result = append(result, i)
		}
	}, WithContext(ctx))
	assert.NotNil(t, err)
	assert.Equal(t, context.DeadlineExceeded, err)
}

func BenchmarkMapReduce(b *testing.B) {
	b.ReportAllocs()

	mapper := func(v interface{}, writer Writer, cancel func(error)) {
		writer.Write(v.(int64) * v.(int64))
	}
	reducer := func(input <-chan interface{}, writer Writer, cancel func(error)) {
		var result int64
		for v := range input {
			result += v.(int64)
		}
		writer.Write(result)
	}

	for i := 0; i < b.N; i++ {
		MapReduce(func(input chan<- interface{}) {
			for j := 0; j < 2; j++ {
				input <- int64(j)
			}
		}, mapper, reducer)
	}
}

```

File path: /Users/mac/Desktop/woker_code/monitor/common/errorx/callchain_test.go
```golang
package errorx

import (
	"errors"
	"testing"

	"github.com/stretchr/testify/assert"
)

func TestChain(t *testing.T) {
	errDummy := errors.New("dummy")
	assert.Nil(t, Chain(func() error {
		return nil
	}, func() error {
		return nil
	}))
	assert.Equal(t, errDummy, Chain(func() error {
		return errDummy
	}, func() error {
		return nil
	}))
	assert.Equal(t, errDummy, Chain(func() error {
		return nil
	}, func() error {
		return errDummy
	}))
}

```

File path: /Users/mac/Desktop/woker_code/monitor/common/errorx/atomicerror_test.go
```golang
package errorx

import (
	"errors"
	"sync"
	"sync/atomic"
	"testing"

	"github.com/stretchr/testify/assert"
)

var errDummy = errors.New("hello")

func TestAtomicError(t *testing.T) {
	var err AtomicError
	err.Set(errDummy)
	assert.Equal(t, errDummy, err.Load())
}

func TestAtomicErrorSetNil(t *testing.T) {
	var (
		errNil error
		err    AtomicError
	)
	err.Set(errNil)
	assert.Equal(t, errNil, err.Load())
}

func TestAtomicErrorNil(t *testing.T) {
	var err AtomicError
	assert.Nil(t, err.Load())
}

func BenchmarkAtomicError(b *testing.B) {
	var aerr AtomicError
	wg := sync.WaitGroup{}

	b.Run("Load", func(b *testing.B) {
		var done uint32
		go func() {
			for {
				if atomic.LoadUint32(&done) != 0 {
					break
				}
				wg.Add(1)
				go func() {
					aerr.Set(errDummy)
					wg.Done()
				}()
			}
		}()
		b.ResetTimer()
		for i := 0; i < b.N; i++ {
			_ = aerr.Load()
		}
		b.StopTimer()
		atomic.StoreUint32(&done, 1)
		wg.Wait()
	})
	b.Run("Set", func(b *testing.B) {
		var done uint32
		go func() {
			for {
				if atomic.LoadUint32(&done) != 0 {
					break
				}
				wg.Add(1)
				go func() {
					_ = aerr.Load()
					wg.Done()
				}()
			}
		}()
		b.ResetTimer()
		for i := 0; i < b.N; i++ {
			aerr.Set(errDummy)
		}
		b.StopTimer()
		atomic.StoreUint32(&done, 1)
		wg.Wait()
	})
}

```

File path: /Users/mac/Desktop/woker_code/monitor/common/errorx/atomicerror.go
```golang
package errorx

import "sync/atomic"

// AtomicError defines an atomic error.
type AtomicError struct {
	err atomic.Value // error
}

// Set sets the error.
func (ae *AtomicError) Set(err error) {
	if err != nil {
		ae.err.Store(err)
	}
}

// Load returns the error.
func (ae *AtomicError) Load() error {
	if v := ae.err.Load(); v != nil {
		return v.(error)
	}
	return nil
}

```

File path: /Users/mac/Desktop/woker_code/monitor/common/errorx/callchain.go
```golang
package errorx

// Chain runs funs one by one until an error occurred.
func Chain(fns ...func() error) error {
	for _, fn := range fns {
		if err := fn(); err != nil {
			return err
		}
	}

	return nil
}

```

File path: /Users/mac/Desktop/woker_code/monitor/common/errorx/batcherror.go
```golang
package errorx

import "bytes"

type (
	// A BatchError is an error that can hold multiple errors.
	BatchError struct {
		errs errorArray
	}

	errorArray []error
)

// Add adds errs to be, nil errors are ignored.
func (be *BatchError) Add(errs ...error) {
	for _, err := range errs {
		if err != nil {
			be.errs = append(be.errs, err)
		}
	}
}

// Err returns an error that represents all errors.
func (be *BatchError) Err() error {
	switch len(be.errs) {
	case 0:
		return nil
	case 1:
		return be.errs[0]
	default:
		return be.errs
	}
}

// NotNil checks if any error inside.
func (be *BatchError) NotNil() bool {
	return len(be.errs) > 0
}

// Error returns a string that represents inside errors.
func (ea errorArray) Error() string {
	var buf bytes.Buffer

	for i := range ea {
		if i > 0 {
			buf.WriteByte('\n')
		}
		buf.WriteString(ea[i].Error())
	}

	return buf.String()
}

```

File path: /Users/mac/Desktop/woker_code/monitor/common/errorx/wrap_test.go
```golang
package errorx

import (
	"errors"
	"testing"

	"github.com/stretchr/testify/assert"
)

func TestWrap(t *testing.T) {
	assert.Nil(t, Wrap(nil, "test"))
	assert.Equal(t, "foo: bar", Wrap(errors.New("bar"), "foo").Error())

	err := errors.New("foo")
	assert.True(t, errors.Is(Wrap(err, "bar"), err))
}

func TestWrapf(t *testing.T) {
	assert.Nil(t, Wrapf(nil, "%s", "test"))
	assert.Equal(t, "foo bar: quz", Wrapf(errors.New("quz"), "foo %s", "bar").Error())

	err := errors.New("foo")
	assert.True(t, errors.Is(Wrapf(err, "foo %s", "bar"), err))
}

```

File path: /Users/mac/Desktop/woker_code/monitor/common/errorx/wrap.go
```golang
package errorx

import "fmt"

// Wrap returns an error that wraps err with given message.
func Wrap(err error, message string) error {
	if err == nil {
		return nil
	}

	return fmt.Errorf("%s: %w", message, err)
}

// Wrapf returns an error that wraps err with given format and args.
func Wrapf(err error, format string, args ...interface{}) error {
	if err == nil {
		return nil
	}

	return fmt.Errorf("%s: %w", fmt.Sprintf(format, args...), err)
}

```

File path: /Users/mac/Desktop/woker_code/monitor/common/errorx/batcherror_test.go
```golang
package errorx

import (
	"errors"
	"fmt"
	"testing"

	"github.com/stretchr/testify/assert"
)

const (
	err1 = "first error"
	err2 = "second error"
)

func TestBatchErrorNil(t *testing.T) {
	var batch BatchError
	assert.Nil(t, batch.Err())
	assert.False(t, batch.NotNil())
	batch.Add(nil)
	assert.Nil(t, batch.Err())
	assert.False(t, batch.NotNil())
}

func TestBatchErrorNilFromFunc(t *testing.T) {
	err := func() error {
		var be BatchError
		return be.Err()
	}()
	assert.True(t, err == nil)
}

func TestBatchErrorOneError(t *testing.T) {
	var batch BatchError
	batch.Add(errors.New(err1))
	assert.NotNil(t, batch)
	assert.Equal(t, err1, batch.Err().Error())
	assert.True(t, batch.NotNil())
}

func TestBatchErrorWithErrors(t *testing.T) {
	var batch BatchError
	batch.Add(errors.New(err1))
	batch.Add(errors.New(err2))
	assert.NotNil(t, batch)
	assert.Equal(t, fmt.Sprintf("%s\n%s", err1, err2), batch.Err().Error())
	assert.True(t, batch.NotNil())
}

```

File path: /Users/mac/Desktop/woker_code/monitor/common/promql_template/matcher.go
```golang
// Copyright 2017 The Prometheus Authors
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package template

import (
	"fmt"
	"strings"

	"github.com/prometheus/common/model"
)

// MatchType is an enum for label matching types.
type MatchType int

// Possible MatchTypes.
const (
	MatchEqual MatchType = iota
	MatchNotEqual
	MatchRegexp
	MatchNotRegexp
)

var matchTypeToStr = [...]string{
	MatchEqual:     "=",
	MatchNotEqual:  "!=",
	MatchRegexp:    "=~",
	MatchNotRegexp: "!~",
}

func (m MatchType) String() string {
	if m < MatchEqual || m > MatchNotRegexp {
		m = MatchEqual
	}
	return matchTypeToStr[m]
}

// Matcher models the matching of a label.
type Matcher struct {
	Type  MatchType
	Name  model.LabelName
	Value model.LabelValue

	re *FastRegexMatcher
}

// NewMatcher returns a matcher object.
func NewMatcher(mt MatchType, n, v string) (*Matcher, error) {
	m := &Matcher{
		Type:  mt,
		Name:  model.LabelName(n),
		Value: model.LabelValue(v),
	}
	if mt == MatchRegexp || mt == MatchNotRegexp {
		re, err := NewFastRegexMatcher(v)
		if err != nil {
			return nil, err
		}
		m.re = re
	}
	return m, nil
}

func (m *Matcher) String() string {
	return fmt.Sprintf("%s%s%q", m.Name, m.Type, m.Value)
}

// Matches returns whether the matcher matches the given string value.
func (m *Matcher) Matches(s string) bool {
	switch m.Type {
	case MatchEqual:
		return model.LabelValue(s) == m.Value
	case MatchNotEqual:
		return model.LabelValue(s) != m.Value
	case MatchRegexp:
		return m.re.MatchString(s)
	case MatchNotRegexp:
		return !m.re.MatchString(s)
	default:
		return false
	}
}

// GetRegexString returns the regex string.
func (m *Matcher) GetRegexString() string {
	if m.re == nil {
		return ""
	}
	return m.re.GetRegexString()
}

// MatcherPairs is a sortable slice of Matcher pointers. It implements
// sort.Interface.
type MatcherPairs []*Matcher

func (mps MatcherPairs) Len() int {
	return len(mps)
}

func (mps MatcherPairs) Less(i, j int) bool {
	switch {
	case mps[i].Name > mps[j].Name:
		return false
	case mps[i].Name < mps[j].Name:
		return true
	case mps[i].Value > mps[j].Value:
		return false
	case mps[i].Value < mps[j].Value:
		return true
	default:
		return false
	}
}

func (mps MatcherPairs) Swap(i, j int) {
	mps[i], mps[j] = mps[j], mps[i]
}

func (mps MatcherPairs) String() string {
	matcherStrings := make([]string, 0, mps.Len())
	for _, m := range mps {
		matcherStrings = append(matcherStrings, m.String())
	}
	return strings.Join(matcherStrings, ",")
}

func (mps *MatcherPairs) AddMatcher(mt MatchType, n, v string) error {
	m, err := NewMatcher(mt, n, v)
	if err != nil {
		return err
	}
	*mps = append(*mps, m)
	return nil
}

```

File path: /Users/mac/Desktop/woker_code/monitor/common/promql_template/types.go
```golang
package template

import (
	"bytes"
	alarmv1alpha "ezone.ksyun.com/ezone/luban/luban_api/alarmapis/alarm/v1alpha/gen"
	"fmt"
	"github.com/prometheus/common/model"
	"text/template"
)

type PromQLReq func(labels []*alarmv1alpha.Label) *alarmv1alpha.ListPromQLsRequest

type QuerySql struct {
	Name        string
	Unit        string
	SqlTemplate string
	Labels      MatcherPairs
	TopK        int
	Duration    int64
	By          model.LabelNames
}

func (qs *QuerySql) Render() (string, error) {

	fmt.Printf("QuerySql: %+v\n", qs)

	sqlTemplate, err := template.New(qs.Name).Parse(qs.SqlTemplate)
	if err != nil {
		return "", err
	}
	buf := new(bytes.Buffer)
	if err = sqlTemplate.Execute(buf, qs); err != nil {
		return "", err
	}
	return buf.String(), nil
}

```

File path: /Users/mac/Desktop/woker_code/monitor/common/promql_template/regexp.go
```golang
// Copyright 2020 The Prometheus Authors
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package template

import (
	"strings"

	"github.com/grafana/regexp"
	"github.com/grafana/regexp/syntax"
)

type FastRegexMatcher struct {
	re       *regexp.Regexp
	prefix   string
	suffix   string
	contains string
}

func NewFastRegexMatcher(v string) (*FastRegexMatcher, error) {
	re, err := regexp.Compile("^(?:" + v + ")$")
	if err != nil {
		return nil, err
	}

	parsed, err := syntax.Parse(v, syntax.Perl)
	if err != nil {
		return nil, err
	}

	m := &FastRegexMatcher{
		re: re,
	}

	if parsed.Op == syntax.OpConcat {
		m.prefix, m.suffix, m.contains = optimizeConcatRegex(parsed)
	}

	return m, nil
}

func (m *FastRegexMatcher) MatchString(s string) bool {
	if m.prefix != "" && !strings.HasPrefix(s, m.prefix) {
		return false
	}
	if m.suffix != "" && !strings.HasSuffix(s, m.suffix) {
		return false
	}
	if m.contains != "" && !strings.Contains(s, m.contains) {
		return false
	}
	return m.re.MatchString(s)
}

func (m *FastRegexMatcher) GetRegexString() string {
	return m.re.String()
}

// optimizeConcatRegex returns literal prefix/suffix text that can be safely
// checked against the label value before running the regexp matcher.
func optimizeConcatRegex(r *syntax.Regexp) (prefix, suffix, contains string) {
	sub := r.Sub

	// We can safely remove begin and end text matchers respectively
	// at the beginning and end of the regexp.
	if len(sub) > 0 && sub[0].Op == syntax.OpBeginText {
		sub = sub[1:]
	}
	if len(sub) > 0 && sub[len(sub)-1].Op == syntax.OpEndText {
		sub = sub[:len(sub)-1]
	}

	if len(sub) == 0 {
		return
	}

	// Given Prometheus regex matchers are always anchored to the begin/end
	// of the text, if the first/last operations are literals, we can safely
	// treat them as prefix/suffix.
	if sub[0].Op == syntax.OpLiteral && (sub[0].Flags&syntax.FoldCase) == 0 {
		prefix = string(sub[0].Rune)
	}
	if last := len(sub) - 1; sub[last].Op == syntax.OpLiteral && (sub[last].Flags&syntax.FoldCase) == 0 {
		suffix = string(sub[last].Rune)
	}

	// If contains any literal which is not a prefix/suffix, we keep the
	// 1st one. We do not keep the whole list of literals to simplify the
	// fast path.
	for i := 1; i < len(sub)-1; i++ {
		if sub[i].Op == syntax.OpLiteral && (sub[i].Flags&syntax.FoldCase) == 0 {
			contains = string(sub[i].Rune)
			break
		}
	}

	return
}

```

File path: /Users/mac/Desktop/woker_code/monitor/common/promql_template/objectstorage/template.go
```golang
package objectstorage

import alarmv1alpha "ezone.ksyun.com/ezone/luban/luban_api/alarmapis/alarm/v1alpha/gen"

type objectStorageReqFunc func(region, bucketID, resourcePool, resourcePoolType, name string) *alarmv1alpha.ListPromQLsRequest

var MetricMap = map[string]string{
	ObjectPoolTotal:                   "总量",
	ObjectPoolUsageRate:               "使用率",
	ObjectPoolUsage:                   "使用量",
	ObjectPoolCapacityInventory:       "存储容量库存",
	ObjectPoolStandardStorage:         "标准存储",
	ObjectPoolInfrequentAccessStorage: "低频存储",
	ObjectPoolArchiveStorage:          "归档存储",

	ObjectPoolStatusCodesReturnNumber2XX:       "2XX",
	ObjectPoolStatusCodesReturnNumber4XX:       "4XX",
	ObjectPoolStatusCodesReturnNumber5XX:       "5XX",
	ObjectPoolStatusCodesReturnNumber3XX:       "3XX",
	ObjectPoolApiRequestNumber:                 "资源池API请求数",
	ObjectPoolPutRequestNumber:                 "资源池PUT请求数",
	ObjectPoolGetRequestNumber:                 "资源池GET请求数",
	ObjectPoolPostRequestNumber:                "资源池POST请求数",
	ObjectPoolHeadRequestNumber:                "资源池HEAD请求数",
	ObjectPoolDeleteRequestNumber:              "资源池DELETE请求数",
	ObjectPoolOptionsRequestNumber:             "资源池OPTIONS请求数",
	ObjectPoolExternalNetworkUploadBandwidth:   "资源池内外网上传带宽",
	ObjectPoolExternalNetworkDownloadBandwidth: "资源池内外网下载带宽",
	ObjectPoolCRRUploadBandwidth:               "资源池CRR上传带宽",
	ObjectPoolCRRDownloadBandwidth:             "资源池CRR下载带宽",
	ObjectPoolExternalNetworkUploadFlow:        "资源池内外网上传流量",
	ObjectPoolExternalNetworkDownloadFlow:      "资源池内外网下载流量",
	ObjectPoolCRRUploadFlow:                    "资源池CRR上传流量",
	ObjectPoolCRRDownloadFlow:                  "资源池CRR下载流量",

	ObjectPoolTotalCapacity:          "总量",
	ObjectPoolCapacityIncrement:      "增量",
	ObjectPoolCapacityDeleteQuantity: "删除量",

	ObjectStorageVolumeTotalRequestPUT: "PUT请求数", //--
	ObjectStorageVolumeTotalRequestGET: "GET请求数", //--
	//ObjectStorageVolumeSpaceCapacity:         "空间容量",
	ObjectStorageVolumeAbnormalReturnRanking: "存储空间异常返回排名", //--
	ObjectStorageVolumeWriteSuccessRateCount: "写入成功率",
	ObjectStorageVolumeReadSuccessRateCount:  "读取成功率",

	ObjectStorageVolumeStorageCurrentTotal:     "存储当前总量",
	ObjectStorageVolumeDownloads30day:          "30天下载量",
	ObjectStorageVolumeFileSum:                 "Object总量",
	ObjectStorageVolumeApiRequest30day:         "30天API请求数",
	ObjectVolumeCapacityTotal:                  "存储空间容量",
	ObjectVolumeCapacityIncrement:              "存储容量增量",
	ObjectVolumeCapacityDeleteQuantity:         "存储容量删除数量",
	ObjectVolumePublicNetworkUploadFlow:        "内外网流入",     // --
	ObjectVolumePublicNetworkDownloadFlow:      "内外网流出",     // --
	ObjectVolumeCRRUploadFlow:                  "CRR流入",        // --
	ObjectVolumeCRRDownloadFlow:                "CRR流出",        // --
	ObjectVolumePublicNetworkUploadBandwidth:   "内外网上传带宽", // --
	ObjectVolumePublicNetworkDownloadBandwidth: "内外网下载带宽", // --
	ObjectVolumeCRRUploadBandwidth:             "CRR上传带宽",    // --
	ObjectVolumeCRRDownloadBandwidth:           "CRR下载带宽",    // --
	ObjectVolumeGetRequestSum:                  "GET请求数",      // --
	ObjectVolumePutRequestSum:                  "PUT请求数",      // --
	ObjectVolumePostRequestSum:                 "POST请求数",     // --
	ObjectVolumeHeadRequestSum:                 "HEAD请求数",     // --
	ObjectVolumeDeleteRequestSum:               "DELETE请求数",   // --
	ObjectVolumeOptionsRequestSum:              "OPTIONS请求数",  // --
	ObjectVolume2xxRequestSum:                  "状态码:2xx",     // --
	ObjectVolume3xxRequestSum:                  "状态码:3xx",     // --
	ObjectVolume4xxRequestSum:                  "状态码:4xx",     // --
	ObjectVolume5xxRequestSum:                  "状态码:5xx",     // --
	ObjectVolumeWriteSuccessRate:               "写成功率",       // --
	ObjectVolumeReadSuccessRate:                "读成功率",       // --

	ObjectVolumePutDelay: "PUT延时",
	ObjectVolumeGetDelay: "GET延时",

	ObjectStorageVolumeTotalInflowPublicNetwork:               "总流入流量",
	ObjectStorageVolumeTotalOutflowPublicNetwork:              "总流出流量",
	ObjectStorageVolumeBucketCount:                            "存储空间(Bucket)数量",
	ObjectStorageResourcePoolCrrDownloadFlowCount:             "CRR总下载流量",
	ObjectStorageResourcePoolCrrUploadFlowCount:               "CRR总上传流量",
	ObjectStorageResourcePoolExternalNetworkDownloadFlowCount: "内外网下载流量",
	ObjectStorageResourcePoolExternalNetworkUploadFlowCount:   "内外网上传流量",
	ObjectStorageVolumeTotalRequestPutCount:                   "PUT请求",
	ObjectStorageVolumeTotalRequestGetCount:                   "GET请求",
	ObjectStorageResourcePoolApiRequestNumberCount:            "总体API请求",

	ObjectStorageResourcePoolPutRequestNumberCount:     "PUT请求",
	ObjectStorageResourcePoolGetRequestNumberCount:     "GET请求",
	ObjectStorageResourcePoolPostRequestNumberCount:    "POST请求",
	ObjectStorageResourcePoolHeadRequestNumberCount:    "HEAD请求",
	ObjectStorageResourcePoolDeleteRequestNumberCount:  "DELETE请求",
	ObjectStorageResourcePoolOptionsRequestNumberCount: "OPTIONS请求",

	ObjectStorageResourcePoolExternalNetworkUploadBandwidthCount:   "object_storage_resource_pool_external_network_upload_bandwidth_count",   // 内外网上传带宽（sum()）// --
	ObjectStorageResourcePoolExternalNetworkDownloadBandwidthCount: "object_storage_resource_pool_external_network_download_bandwidth_count", // 内外网下载带宽（sum()）// --
	ObjectStorageResourcePoolCrrUploadBandwidthCount:               "object_storage_resource_pool_crr_upload_bandwidth_count",                // CRR上传带宽（sum()）// --
	ObjectStorageResourcePoolCrrDownloadBandwidthCount:             "object_storage_resource_pool_crr_download_bandwidth_count",              // CRR下载带宽（sum()）// --

}

var MetricTopMap = map[string]string{}

const (
	// 资源池对象存储-概览
	ObjectPoolTotal                   = "object_storage_resource_pool_total"                     // 对象存储资源池总量--总数
	ObjectPoolUsageRate               = "object_storage_resource_pool_usage_rate"                // 对象存储资源池使用率--总数
	ObjectPoolUsage                   = "object_storage_resource_pool_usage"                     // 对象存储资源池使用量--计算
	ObjectPoolCapacityInventory       = "object_storage_resource_pool_capacity_inventory"        // 对象存储资源池容量库存--总数
	ObjectPoolStandardStorage         = "object_storage_resource_pool_standard_storage"          // 对象存储资源池标准存储--总数
	ObjectPoolInfrequentAccessStorage = "object_storage_resource_pool_infrequent_access_storage" // 对象存储资源池低频存储--总数
	ObjectPoolArchiveStorage          = "object_storage_resource_pool_archive_storage"           // 对象存储资源池归档存储--总数

	ObjectPoolStatusCodesReturnNumber2XX       = "object_storage_resource_pool_status_codes_return_number_2xx_count" // 对象存储资源池状态码返回数2XX--总数（sum ObjectVolume2xxRequestSum）
	ObjectPoolStatusCodesReturnNumber4XX       = "object_storage_resource_pool_status_codes_return_number_4xx_count" // 对象存储资源池状态码返回数4XX-总数（sum ObjectVolume4xxRequestSum）
	ObjectPoolStatusCodesReturnNumber5XX       = "object_storage_resource_pool_status_codes_return_number_5xx_count" // 对象存储资源池状态码返回数5XX-总数（sum ObjectVolume5xxRequestSum）
	ObjectPoolStatusCodesReturnNumber3XX       = "object_storage_resource_pool_status_codes_return_number_3xx_count" // 对象存储资源池状态码返回数3XX-总数（sum ObjectVolume3xxRequestSum）
	ObjectPoolApiRequestNumber                 = "object_storage_resource_pool_api_request_number"                   // 对象存储资源池API请求数--总数（sum ObjectVolumeApiRequest30day）
	ObjectPoolPutRequestNumber                 = "object_storage_resource_pool_put_request_number"                   // 对象存储资源池PUT请求数（sum ...）
	ObjectPoolGetRequestNumber                 = "object_storage_resource_pool_get_request_number"                   // 对象存储资源池GET请求数（sum ...）
	ObjectPoolPostRequestNumber                = "object_storage_resource_pool_post_request_number"                  // 对象存储资源池POST请求数（sum ...）
	ObjectPoolHeadRequestNumber                = "object_storage_resource_pool_head_request_number"                  // 对象存储资源池HEAD请求数（sum ...）
	ObjectPoolDeleteRequestNumber              = "object_storage_resource_pool_delete_request_number"                // 对象存储资源池DELETE请求数（sum ...）
	ObjectPoolOptionsRequestNumber             = "object_storage_resource_pool_options_request_number"               // 对象存储资源池OPTIONS请求数（sum ...）
	ObjectPoolExternalNetworkUploadBandwidth   = "object_storage_resource_pool_external_network_upload_bandwidth"    // 对象存储资源池内外网上传带宽（sum ...）
	ObjectPoolExternalNetworkDownloadBandwidth = "object_storage_resource_pool_external_network_download_bandwidth"  // 对象存储资源池内外网下载带宽（sum ...）
	ObjectPoolCRRUploadBandwidth               = "object_storage_resource_pool_crr_upload_bandwidth"                 // 对象存储资源池CRR上传带宽（sum ...）
	ObjectPoolCRRDownloadBandwidth             = "object_storage_resource_pool_crr_download_bandwidth"               // 对象存储资源池CRR下载带宽（sum ...）
	ObjectPoolExternalNetworkUploadFlow        = "object_storage_resource_pool_external_network_upload_flow"         // 对象存储资源池内外网上传流量（sum ...）
	ObjectPoolExternalNetworkDownloadFlow      = "object_storage_resource_pool_external_network_download_flow"       // 对象存储资源池内外网下载流量（sum ...）
	ObjectPoolCRRUploadFlow                    = "object_storage_resource_pool_crr_upload_flow"                      // 对象存储资源池CRR上传流量（sum ...）
	ObjectPoolCRRDownloadFlow                  = "object_storage_resource_pool_crr_download_flow"                    // 对象存储资源池CRR下载流量（sum ...）

	// 资源池对象存储-详情
	ObjectPoolTotalCapacity          = "object_storage_resource_pool_total_capacity"           // 对象存储资源池总容量 - 未采集（sum ObjectVolumeCapacityTotal）// --
	ObjectPoolCapacityIncrement      = "object_storage_resource_pool_capacity_increment"       // 对象存储资源池容量增量 - 未采集（sum ObjectVolumeCapacityIncrement）// --
	ObjectPoolCapacityDeleteQuantity = "object_storage_resource_pool_capacity_delete_quantity" // 对象存储资源池容量删除数量 - 未采集（sum ObjectVolumeCapacityDeleteQuantity）// --

	// 云产品对象存储-概览
	ObjectStorageVolumeTotalInflowPublicNetwork  = "object_storage_volume_total_inflow_public_network_count"  // 对象存储云产品公网总流入-内外网--未采集（sum ObjectVolumePublicNetworkUploadFlow）//--
	ObjectStorageVolumeTotalOutflowPublicNetwork = "object_storage_volume_total_outflow_public_network_count" // 对象存储云产品公网总流出-内外网--未采集（sum ObjectVolumePublicNetworkDownloadFlow）//--

	ObjectStorageVolumeBucketCount = "object_storage_volume_bucket_count" // 对象存储云产品bucket数量--总数 //--

	ObjectStorageVolumeTotalRequestPUT = "object_storage_volume_total_request_put" // 对象存储云产品总PUT请求数--单个 //--
	ObjectStorageVolumeTotalRequestGET = "object_storage_volume_total_request_get" // 对象存储云产品总GET请求数--单个 //--

	//ObjectStorageVolumeSpaceCapacity         = "object_storage_volume_space_capacity"          // 对象存储云产品空间总容量--单个（sum ObjectVolumeCapacityTotal）
	ObjectStorageVolumeAbnormalReturnRanking = "object_storage_volume_abnormal_return_ranking" // 对象存储云产品异常返回排名--单个（sum ObjectStorageVolumeAbnormalReturnRanking）// --

	ObjectStorageVolumeWriteSuccessRateCount = "object_storage_volume_write_success_rate_count" // 对象存储云产品写入成功率--单个（sum ObjectVolumeWriteSuccessRate）
	ObjectStorageVolumeReadSuccessRateCount  = "object_storage_volume_read_success_rate_count"  // 对象存储云产品读取成功率--单个（sum ObjectVolumeReadSuccessRate）

	// 云产品对象存储-详情
	ObjectStorageVolumeStorageCurrentTotal     = "object_storage_volume_storage_current_total"             // 对象存储云产品存储当前总量
	ObjectStorageVolumeDownloads30day          = "object_storage_volume_downloads_30day"                   // 对象存储云产品30天下载量 // --
	ObjectStorageVolumeApiRequest30day         = "object_storage_volume_api_request_30day"                 // 对象存储云产品30天API请求数 // --
	ObjectVolumeCapacityTotal                  = "object_storage_volume_capacity_total"                    // 对象卷单个容量总量 // --
	ObjectVolumeCapacityIncrement              = "object_storage_volume_capacity_increment"                // 对象卷单个容量增量 // --
	ObjectVolumeCapacityDeleteQuantity         = "object_storage_volume_capacity_delete_quantity"          // 对象卷单个容量删除数量 // --
	ObjectVolumePublicNetworkUploadFlow        = "object_storage_volume_public_network_upload_flow"        // 对象卷外网上传流量-内外网 //--
	ObjectVolumePublicNetworkDownloadFlow      = "object_storage_volume_public_network_download_flow"      // 对象卷外网下载流量-内外网 //--
	ObjectVolumeCRRUploadFlow                  = "object_storage_volume_crr_upload_flow"                   // 对象卷CRR上传流量 //--
	ObjectVolumeCRRDownloadFlow                = "object_storage_volume_crr_download_flow"                 // 对象卷CRR下载流量 //--
	ObjectVolumePublicNetworkUploadBandwidth   = "object_storage_volume_public_network_upload_bandwidth"   // 对象卷外网上传带宽-内外网 //--
	ObjectVolumePublicNetworkDownloadBandwidth = "object_storage_volume_public_network_download_bandwidth" // 对象卷外网下载带宽-内外网 //--
	ObjectVolumeCRRUploadBandwidth             = "object_storage_volume_crr_upload_bandwidth"              // 对象卷CRR上传带宽 //--
	ObjectVolumeCRRDownloadBandwidth           = "object_storage_volume_crr_download_bandwidth"            // 对象卷CRR下载带宽 //--
	ObjectVolumeGetRequestSum                  = "object_storage_volume_get_request_sum"                   // 对象卷GET请求数 // --
	ObjectVolumePutRequestSum                  = "object_storage_volume_put_request_sum"                   // 对象卷PUT请求数 // --
	ObjectVolumePostRequestSum                 = "object_storage_volume_post_request_sum"                  // 对象卷POST请求数 // --
	ObjectVolumeHeadRequestSum                 = "object_storage_volume_head_request_sum"                  // 对象卷HEAD请求数 // --
	ObjectVolumeDeleteRequestSum               = "object_storage_volume_delete_request_sum"                // 对象卷DELETE请求数 // --
	ObjectVolumeOptionsRequestSum              = "object_storage_volume_options_request_sum"               // 对象卷OPTIONS请求数 // --
	ObjectVolume2xxRequestSum                  = "object_storage_volume_2xx_request_sum"                   // 对象卷2xx请求数 // --
	ObjectVolume3xxRequestSum                  = "object_storage_volume_3xx_request_sum"                   // 对象卷3xx请求数 // --
	ObjectVolume4xxRequestSum                  = "object_storage_volume_4xx_request_sum"                   // 对象卷4xx请求数 // --
	ObjectVolume5xxRequestSum                  = "object_storage_volume_5xx_request_sum"                   // 对象卷5xx请求数 // --
	ObjectVolumeWriteSuccessRate               = "object_storage_volume_write_success_rate"                // 对象卷写入成功率 //--
	ObjectVolumeReadSuccessRate                = "object_storage_volume_read_success_rate"                 // 对象卷读取成功率 //--

	ObjectVolumePutDelay = "object_volume_put_delay" // 对象卷PUT延时 - 未定义
	ObjectVolumeGetDelay = "object_volume_get_delay" // 对象卷GET延时 - 未定义

	ObjectStorageResourcePoolCrrDownloadFlowCount             = "object_storage_resource_pool_crr_download_flow_count"              // 对象存储CRR总下载流量 // --
	ObjectStorageResourcePoolCrrUploadFlowCount               = "object_storage_resource_pool_crr_upload_flow_count"                // 对象存储CRR总上传流量 // --
	ObjectStorageResourcePoolExternalNetworkDownloadFlowCount = "object_storage_resource_pool_external_network_download_flow_count" // 对象存储外网总下载流量 // --
	ObjectStorageResourcePoolExternalNetworkUploadFlowCount   = "object_storage_resource_pool_external_network_upload_flow_count"   // 对象存储外网总上传流量 // --
	ObjectStorageVolumeTotalRequestPutCount                   = "object_storage_volume_total_request_put_count"                     // 对象存储云产品总PUT请求数--总数（sum ObjectStorageVolumeTotalRequestPUT）// --
	ObjectStorageVolumeTotalRequestGetCount                   = "object_storage_volume_total_request_get_count"                     // 对象存储云产品总GET请求数--总数（sum ObjectStorageVolumeTotalRequestGET）// --
	ObjectStorageResourcePoolApiRequestNumberCount            = "object_storage_resource_pool_api_request_number_count"             // 对象存储API请求数（sum()）// --

	ObjectStorageResourcePoolPutRequestNumberCount     = "object_storage_resource_pool_put_request_number_count"     // 对象存储PUT总请求数（sum()）// --
	ObjectStorageResourcePoolGetRequestNumberCount     = "object_storage_resource_pool_get_request_number_count"     // 对象存储GET总请求数（sum()）// --
	ObjectStorageResourcePoolPostRequestNumberCount    = "object_storage_resource_pool_post_request_number_count"    // 对象存储POST总请求数（sum()）// --
	ObjectStorageResourcePoolHeadRequestNumberCount    = "object_storage_resource_pool_head_request_number_count"    // 对象存储HEAD总请求数（sum()）// --
	ObjectStorageResourcePoolDeleteRequestNumberCount  = "object_storage_resource_pool_delete_request_number_count"  // 对象存储DELETE总请求数（sum()）// --
	ObjectStorageResourcePoolOptionsRequestNumberCount = "object_storage_resource_pool_options_request_number_count" // 对象存储OPTIONS总请求数（sum()）// --

	ObjectStorageResourcePoolExternalNetworkUploadBandwidthCount   = "object_storage_resource_pool_external_network_upload_bandwidth_count"   // 对象存储外网总上传带宽（sum()）// --
	ObjectStorageResourcePoolExternalNetworkDownloadBandwidthCount = "object_storage_resource_pool_external_network_download_bandwidth_count" // 对象存储外网总下载带宽（sum()）// --
	ObjectStorageResourcePoolCrrUploadBandwidthCount               = "object_storage_resource_pool_crr_upload_bandwidth_count"                // 对象存储CRR总上传带宽（sum()）// --
	ObjectStorageResourcePoolCrrDownloadBandwidthCount             = "object_storage_resource_pool_crr_download_bandwidth_count"              // 对象存储CRR总下载带宽（sum()）// --

	ObjectStorageVolumeFileSum = "object_storage_volume_file_sum" // Object总量（文件数）// --

)

var TemplateMap = map[string]objectStorageReqFunc{
	// 资源池概览
	ObjectPoolTotal: func(region, bucketID, resourcePool, resourcePoolType, name string) *alarmv1alpha.ListPromQLsRequest {
		return &alarmv1alpha.ListPromQLsRequest{
			Name:            "object_storage_resource_pool_total",
			ResourceSubType: "ks3",
			Labels: []*alarmv1alpha.Label{
				{
					Key:       "resource_pool_type",
					Value:     resourcePoolType,
					Operation: "=",
				},
			},
		}
	},
	ObjectPoolUsageRate: func(region, bucketID, resourcePool, resourcePoolType, name string) *alarmv1alpha.ListPromQLsRequest {
		return &alarmv1alpha.ListPromQLsRequest{
			Name:            "object_storage_resource_pool_usage_rate",
			ResourceSubType: "ks3",
			Labels: []*alarmv1alpha.Label{
				{
					Key:       "resource_pool_type",
					Value:     resourcePoolType,
					Operation: "=",
				},
			},
		}
	},
	ObjectPoolCapacityInventory: func(region, bucketID, resourcePool, resourcePoolType, name string) *alarmv1alpha.ListPromQLsRequest {
		return &alarmv1alpha.ListPromQLsRequest{
			Name:            "object_storage_resource_pool_capacity_inventory",
			ResourceSubType: "ks3",
			Labels: []*alarmv1alpha.Label{
				{
					Key:       "resource_pool_type",
					Value:     resourcePoolType,
					Operation: "=",
				},
			},
		}
	},
	ObjectPoolStandardStorage: func(region, bucketID, resourcePool, resourcePoolType, name string) *alarmv1alpha.ListPromQLsRequest {
		return &alarmv1alpha.ListPromQLsRequest{
			Name:            "object_storage_resource_pool_standard_storage",
			ResourceSubType: "ks3",
			Labels: []*alarmv1alpha.Label{
				{
					Key:       "resource_pool_type",
					Value:     resourcePoolType,
					Operation: "=",
				},
			},
		}
	},
	ObjectPoolInfrequentAccessStorage: func(region, bucketID, resourcePool, resourcePoolType, name string) *alarmv1alpha.ListPromQLsRequest {
		return &alarmv1alpha.ListPromQLsRequest{
			Name:            "object_storage_resource_pool_infrequent_access_storage",
			ResourceSubType: "ks3",
			Labels: []*alarmv1alpha.Label{
				{
					Key:       "resource_pool_type",
					Value:     resourcePoolType,
					Operation: "=",
				},
			},
		}
	},
	ObjectPoolArchiveStorage: func(region, bucketID, resourcePool, resourcePoolType, name string) *alarmv1alpha.ListPromQLsRequest {
		return &alarmv1alpha.ListPromQLsRequest{
			Name:            "object_storage_resource_pool_archive_storage",
			ResourceSubType: "ks3",
			Labels: []*alarmv1alpha.Label{
				{
					Key:       "resource_pool_type",
					Value:     resourcePoolType,
					Operation: "=",
				},
			},
		}
	},
	ObjectStorageResourcePoolPutRequestNumberCount: func(region, bucketID, resourcePool, resourcePoolType, name string) *alarmv1alpha.ListPromQLsRequest {
		return &alarmv1alpha.ListPromQLsRequest{
			Name:            "object_storage_resource_pool_put_request_number_count",
			ResourceSubType: "ks3",
			Labels: []*alarmv1alpha.Label{
				{
					Key:       "resource_pool_type",
					Value:     resourcePoolType,
					Operation: "=",
				},
			},
		}
	},
	ObjectStorageResourcePoolGetRequestNumberCount: func(region, bucketID, resourcePool, resourcePoolType, name string) *alarmv1alpha.ListPromQLsRequest {
		return &alarmv1alpha.ListPromQLsRequest{
			Name:            "object_storage_resource_pool_get_request_number_count",
			ResourceSubType: "ks3",
			Labels: []*alarmv1alpha.Label{
				{
					Key:       "resource_pool_type",
					Value:     resourcePoolType,
					Operation: "=",
				},
			},
		}
	},
	ObjectStorageResourcePoolPostRequestNumberCount: func(region, bucketID, resourcePool, resourcePoolType, name string) *alarmv1alpha.ListPromQLsRequest {
		return &alarmv1alpha.ListPromQLsRequest{
			Name:            "object_storage_resource_pool_post_request_number_count",
			ResourceSubType: "ks3",
			Labels: []*alarmv1alpha.Label{
				{
					Key:       "resource_pool_type",
					Value:     resourcePoolType,
					Operation: "=",
				},
			},
		}
	},
	ObjectStorageResourcePoolHeadRequestNumberCount: func(region, bucketID, resourcePool, resourcePoolType, name string) *alarmv1alpha.ListPromQLsRequest {
		return &alarmv1alpha.ListPromQLsRequest{
			Name:            "object_storage_resource_pool_head_request_number_count",
			ResourceSubType: "ks3",
			Labels: []*alarmv1alpha.Label{
				{
					Key:       "resource_pool_type",
					Value:     resourcePoolType,
					Operation: "=",
				},
			},
		}
	},
	ObjectStorageResourcePoolDeleteRequestNumberCount: func(region, bucketID, resourcePool, resourcePoolType, name string) *alarmv1alpha.ListPromQLsRequest {
		return &alarmv1alpha.ListPromQLsRequest{
			Name:            "object_storage_resource_pool_delete_request_number_count",
			ResourceSubType: "ks3",
			Labels: []*alarmv1alpha.Label{
				{
					Key:       "resource_pool_type",
					Value:     resourcePoolType,
					Operation: "=",
				},
			},
		}
	},
	ObjectStorageResourcePoolOptionsRequestNumberCount: func(region, bucketID, resourcePool, resourcePoolType, name string) *alarmv1alpha.ListPromQLsRequest {
		return &alarmv1alpha.ListPromQLsRequest{
			Name:            "object_storage_resource_pool_options_request_number_count",
			ResourceSubType: "ks3",
			Labels: []*alarmv1alpha.Label{
				{
					Key:       "resource_pool_type",
					Value:     resourcePoolType,
					Operation: "=",
				},
			},
		}
	},
	ObjectStorageResourcePoolExternalNetworkUploadBandwidthCount: func(region, bucketID, resourcePool, resourcePoolType, name string) *alarmv1alpha.ListPromQLsRequest {
		return &alarmv1alpha.ListPromQLsRequest{
			Name:            "object_storage_resource_pool_external_network_upload_bandwidth_count",
			ResourceSubType: "ks3",
			Labels: []*alarmv1alpha.Label{
				{
					Key:       "resource_pool_type",
					Value:     resourcePoolType,
					Operation: "=",
				},
			},
		}
	},
	ObjectStorageResourcePoolExternalNetworkDownloadBandwidthCount: func(region, bucketID, resourcePool, resourcePoolType, name string) *alarmv1alpha.ListPromQLsRequest {
		return &alarmv1alpha.ListPromQLsRequest{
			Name:            "object_storage_resource_pool_external_network_download_bandwidth_count",
			ResourceSubType: "ks3",
			Labels: []*alarmv1alpha.Label{
				{
					Key:       "resource_pool_type",
					Value:     resourcePoolType,
					Operation: "=",
				},
			},
		}
	},
	ObjectStorageResourcePoolCrrUploadBandwidthCount: func(region, bucketID, resourcePool, resourcePoolType, name string) *alarmv1alpha.ListPromQLsRequest {
		return &alarmv1alpha.ListPromQLsRequest{
			Name:            "object_storage_resource_pool_crr_upload_bandwidth_count",
			ResourceSubType: "ks3",
			Labels: []*alarmv1alpha.Label{
				{
					Key:       "resource_pool_type",
					Value:     resourcePoolType,
					Operation: "=",
				},
			},
		}
	},
	ObjectStorageResourcePoolCrrDownloadBandwidthCount: func(region, bucketID, resourcePool, resourcePoolType, name string) *alarmv1alpha.ListPromQLsRequest {
		return &alarmv1alpha.ListPromQLsRequest{
			Name:            "object_storage_resource_pool_crr_download_bandwidth_count",
			ResourceSubType: "ks3",
			Labels: []*alarmv1alpha.Label{
				{
					Key:       "resource_pool_type",
					Value:     resourcePoolType,
					Operation: "=",
				},
			},
		}
	},

	ObjectPoolTotalCapacity: func(region, bucketID, resourcePool, resourcePoolType, name string) *alarmv1alpha.ListPromQLsRequest {
		return &alarmv1alpha.ListPromQLsRequest{
			Name:            "object_storage_resource_pool_total_capacity",
			ResourceSubType: "ks3",
			Labels: []*alarmv1alpha.Label{
				{
					Key:       "resource_pool_type",
					Value:     resourcePoolType,
					Operation: "=",
				},
			},
		}
	},
	ObjectPoolCapacityIncrement: func(region, bucketID, resourcePool, resourcePoolType, name string) *alarmv1alpha.ListPromQLsRequest {
		return &alarmv1alpha.ListPromQLsRequest{
			Name:            "object_storage_resource_pool_capacity_increment",
			ResourceSubType: "ks3",
			Labels: []*alarmv1alpha.Label{
				{
					Key:       "resource_pool_type",
					Value:     resourcePoolType,
					Operation: "=",
				},
			},
		}
	},
	ObjectPoolCapacityDeleteQuantity: func(region, bucketID, resourcePool, resourcePoolType, name string) *alarmv1alpha.ListPromQLsRequest {
		return &alarmv1alpha.ListPromQLsRequest{
			Name:            "object_storage_resource_pool_capacity_delete_quantity",
			ResourceSubType: "ks3",
			Labels: []*alarmv1alpha.Label{
				{
					Key:       "resource_pool_type",
					Value:     resourcePoolType,
					Operation: "=",
				},
			},
		}
	},
	ObjectStorageVolumeFileSum: func(region, bucketID, resourcePool, resourcePoolType, name string) *alarmv1alpha.ListPromQLsRequest {
		return &alarmv1alpha.ListPromQLsRequest{
			Name:            "object_storage_volume_file_sum",
			ResourceSubType: "ks3",
			Labels: []*alarmv1alpha.Label{
				{
					Key:       "resource_pool_type",
					Value:     resourcePoolType,
					Operation: "=",
				},
			},
		}
	},
	ObjectStorageVolumeApiRequest30day: func(region, bucketID, resourcePool, resourcePoolType, name string) *alarmv1alpha.ListPromQLsRequest {
		return &alarmv1alpha.ListPromQLsRequest{
			Name:            "object_storage_volume_api_request_30day",
			ResourceSubType: "ks3",
			Labels: []*alarmv1alpha.Label{
				{
					Key:       "resource_pool_type",
					Value:     resourcePoolType,
					Operation: "=",
				},
			},
		}
	},
	ObjectStorageVolumeStorageCurrentTotal: func(region, bucketID, resourcePool, resourcePoolType, name string) *alarmv1alpha.ListPromQLsRequest {
		return &alarmv1alpha.ListPromQLsRequest{
			Name:            "object_storage_volume_storage_current_total",
			ResourceSubType: "ks3",
			Labels: []*alarmv1alpha.Label{
				{
					Key:       "resource_pool_type",
					Value:     resourcePoolType,
					Operation: "=",
				},
			},
		}
	},


	// 云产品
	// 监控项
	ObjectStorageVolumeTotalInflowPublicNetwork: func(region, bucketID, resourcePool, resourcePoolType, name string) *alarmv1alpha.ListPromQLsRequest {
		return &alarmv1alpha.ListPromQLsRequest{
			Name:            "object_storage_volume_total_inflow_public_network_count",
			ResourceSubType: "ks3",
			Labels: []*alarmv1alpha.Label{
				{
					Key:       "resource_pool_type",
					Value:     resourcePoolType,
					Operation: "=",
				},
			},
		}
	},
	ObjectStorageVolumeTotalOutflowPublicNetwork: func(region, bucketID, resourcePool, resourcePoolType, name string) *alarmv1alpha.ListPromQLsRequest {
		return &alarmv1alpha.ListPromQLsRequest{
			Name:            "object_storage_volume_total_outflow_public_network_count",
			ResourceSubType: "ks3",
			Labels: []*alarmv1alpha.Label{
				{
					Key:       "resource_pool_type",
					Value:     resourcePoolType,
					Operation: "=",
				},
			},
		}
	},
	ObjectStorageVolumeTotalRequestGetCount: func(region, bucketID, resourcePool, resourcePoolType, name string) *alarmv1alpha.ListPromQLsRequest {
		return &alarmv1alpha.ListPromQLsRequest{
			Name:            "object_storage_volume_total_request_get_count",
			ResourceSubType: "ks3",
			Labels: []*alarmv1alpha.Label{
				{
					Key:       "resource_pool_type",
					Value:     resourcePoolType,
					Operation: "=",
				},
			},
		}
	},
	ObjectStorageVolumeTotalRequestPutCount: func(region, bucketID, resourcePool, resourcePoolType, name string) *alarmv1alpha.ListPromQLsRequest {
		return &alarmv1alpha.ListPromQLsRequest{
			Name:            "object_storage_volume_total_request_put_count",
			ResourceSubType: "ks3",
			Labels: []*alarmv1alpha.Label{
				{
					Key:       "resource_pool_type",
					Value:     resourcePoolType,
					Operation: "=",
				},
			},
		}
	},
	ObjectStorageResourcePoolApiRequestNumberCount: func(region, bucketID, resourcePool, resourcePoolType, name string) *alarmv1alpha.ListPromQLsRequest {
		return &alarmv1alpha.ListPromQLsRequest{
			Name:            "object_storage_resource_pool_api_request_number_count",
			ResourceSubType: "ks3",
			Labels: []*alarmv1alpha.Label{
				{
					Key:       "resource_pool_type",
					Value:     resourcePoolType,
					Operation: "=",
				},
			},
		}
	},

	ObjectStorageResourcePoolExternalNetworkUploadFlowCount: func(region, bucketID, resourcePool, resourcePoolType, name string) *alarmv1alpha.ListPromQLsRequest {
		return &alarmv1alpha.ListPromQLsRequest{
			Name:            "object_storage_resource_pool_external_network_upload_flow_count",
			ResourceSubType: "ks3",
			Labels: []*alarmv1alpha.Label{
				{
					Key:       "resource_pool_type",
					Value:     resourcePoolType,
					Operation: "=",
				},
			},
		}
	},
	ObjectStorageResourcePoolExternalNetworkDownloadFlowCount: func(region, bucketID, resourcePool, resourcePoolType, name string) *alarmv1alpha.ListPromQLsRequest {
		return &alarmv1alpha.ListPromQLsRequest{
			Name:            "object_storage_resource_pool_external_network_download_flow_count",
			ResourceSubType: "ks3",
			Labels: []*alarmv1alpha.Label{
				{
					Key:       "resource_pool_type",
					Value:     resourcePoolType,
					Operation: "=",
				},
			},
		}
	},
	ObjectStorageResourcePoolCrrUploadFlowCount: func(region, bucketID, resourcePool, resourcePoolType, name string) *alarmv1alpha.ListPromQLsRequest {
		return &alarmv1alpha.ListPromQLsRequest{
			Name:            "object_storage_resource_pool_crr_upload_flow_count",
			ResourceSubType: "ks3",
			Labels: []*alarmv1alpha.Label{
				{
					Key:       "resource_pool_type",
					Value:     resourcePoolType,
					Operation: "=",
				},
			},
		}
	},
	ObjectStorageResourcePoolCrrDownloadFlowCount: func(region, bucketID, resourcePool, resourcePoolType, name string) *alarmv1alpha.ListPromQLsRequest {
		return &alarmv1alpha.ListPromQLsRequest{
			Name:            "object_storage_resource_pool_crr_download_flow_count",
			ResourceSubType: "ks3",
			Labels: []*alarmv1alpha.Label{
				{
					Key:       "resource_pool_type",
					Value:     resourcePoolType,
					Operation: "=",
				},
			},
		}
	},
	ObjectStorageVolumeBucketCount: func(region, bucketID, resourcePool, resourcePoolType, name string) *alarmv1alpha.ListPromQLsRequest {
		return &alarmv1alpha.ListPromQLsRequest{
			Name:            "object_storage_volume_bucket_count",
			ResourceSubType: "ks3",
			Labels: []*alarmv1alpha.Label{
				{
					Key:       "resource_pool_type",
					Value:     resourcePoolType,
					Operation: "=",
				},
			},
		}
	},

	// TOP
	ObjectStorageVolumeTotalRequestPUT: func(region, bucketID, resourcePool, resourcePoolType, name string) *alarmv1alpha.ListPromQLsRequest {
		return &alarmv1alpha.ListPromQLsRequest{
			Name:            "object_storage_volume_total_request_put",
			ResourceSubType: "ks3",
			Labels: []*alarmv1alpha.Label{
				{
					Key:       "resource_pool_type",
					Value:     resourcePoolType,
					Operation: "=",
				},
			},
		}
	},
	ObjectStorageVolumeTotalRequestGET: func(region, bucketID, resourcePool, resourcePoolType, name string) *alarmv1alpha.ListPromQLsRequest {
		return &alarmv1alpha.ListPromQLsRequest{
			Name:            "object_storage_volume_total_request_get",
			ResourceSubType: "ks3",
			Labels: []*alarmv1alpha.Label{
				{
					Key:       "resource_pool_type",
					Value:     resourcePoolType,
					Operation: "=",
				},
			},
		}
	},
	ObjectVolumePublicNetworkUploadBandwidth: func(region, bucketID, resourcePool, resourcePoolType, name string) *alarmv1alpha.ListPromQLsRequest {
		if bucketID == "" {
			return &alarmv1alpha.ListPromQLsRequest{
				Name:            "object_storage_volume_public_network_upload_bandwidth",
				ResourceSubType: "ks3",
				Labels: []*alarmv1alpha.Label{
					{
						Key:       "resource_pool_type",
						Value:     resourcePoolType,
						Operation: "=",
					},
				},
			}
		} else {
			return &alarmv1alpha.ListPromQLsRequest{
				Name:            "object_storage_volume_public_network_upload_bandwidth",
				ResourceSubType: "ks3",
				Labels: []*alarmv1alpha.Label{
					{
						Key:       "resource_pool_type",
						Value:     resourcePoolType,
						Operation: "=",
					},
					{
						Key:       "bucket_id",
						Value:     bucketID,
						Operation: "=",
					},
				},
			}
		}
	},
	ObjectVolumePublicNetworkDownloadBandwidth: func(region, bucketID, resourcePool, resourcePoolType, name string) *alarmv1alpha.ListPromQLsRequest {
		if bucketID == "" {
			return &alarmv1alpha.ListPromQLsRequest{
				Name:            "object_storage_volume_public_network_download_bandwidth",
				ResourceSubType: "ks3",
				Labels: []*alarmv1alpha.Label{
					{
						Key:       "resource_pool_type",
						Value:     resourcePoolType,
						Operation: "=",
					},
				},
			}
		} else {
			return &alarmv1alpha.ListPromQLsRequest{
				Name:            "object_storage_volume_public_network_download_bandwidth",
				ResourceSubType: "ks3",
				Labels: []*alarmv1alpha.Label{
					{
						Key:       "resource_pool_type",
						Value:     resourcePoolType,
						Operation: "=",
					},
					{
						Key:       "bucket_id",
						Value:     bucketID,
						Operation: "=",
					},
				},
			}
		}
	},
	ObjectVolumeCRRUploadBandwidth: func(region, bucketID, resourcePool, resourcePoolType, name string) *alarmv1alpha.ListPromQLsRequest {
		if bucketID == "" {
			return &alarmv1alpha.ListPromQLsRequest{
				Name:            "object_storage_volume_crr_upload_bandwidth",
				ResourceSubType: "ks3",
				Labels: []*alarmv1alpha.Label{
					{
						Key:       "resource_pool_type",
						Value:     resourcePoolType,
						Operation: "=",
					},
				},
			}
		} else {
			return &alarmv1alpha.ListPromQLsRequest{
				Name:            "object_storage_volume_crr_upload_bandwidth",
				ResourceSubType: "ks3",
				Labels: []*alarmv1alpha.Label{
					{
						Key:       "resource_pool_type",
						Value:     resourcePoolType,
						Operation: "=",
					},
					{
						Key:       "bucket_id",
						Value:     bucketID,
						Operation: "=",
					},
				},
			}
		}
	},
	ObjectVolumeCRRDownloadBandwidth: func(region, bucketID, resourcePool, resourcePoolType, name string) *alarmv1alpha.ListPromQLsRequest {
		if bucketID == "" {
			return &alarmv1alpha.ListPromQLsRequest{
				Name:            "object_storage_volume_crr_download_bandwidth",
				ResourceSubType: "ks3",
				Labels: []*alarmv1alpha.Label{
					{
						Key:       "resource_pool_type",
						Value:     resourcePoolType,
						Operation: "=",
					},
				},
			}
		} else {
			return &alarmv1alpha.ListPromQLsRequest{
				Name:            "object_storage_volume_crr_download_bandwidth",
				ResourceSubType: "ks3",
				Labels: []*alarmv1alpha.Label{
					{
						Key:       "resource_pool_type",
						Value:     resourcePoolType,
						Operation: "=",
					},
					{
						Key:       "bucket_id",
						Value:     bucketID,
						Operation: "=",
					},
				},
			}
		}
	},
	ObjectVolumePublicNetworkUploadFlow: func(region, bucketID, resourcePool, resourcePoolType, name string) *alarmv1alpha.ListPromQLsRequest {
		if bucketID == "" {
			return &alarmv1alpha.ListPromQLsRequest{
				Name:            "object_storage_volume_public_network_upload_flow",
				ResourceSubType: "ks3",
				Labels: []*alarmv1alpha.Label{
					{
						Key:       "resource_pool_type",
						Value:     resourcePoolType,
						Operation: "=",
					},
				},
			}
		} else {
			return &alarmv1alpha.ListPromQLsRequest{
				Name:            "object_storage_volume_public_network_upload_flow",
				ResourceSubType: "ks3",
				Labels: []*alarmv1alpha.Label{
					{
						Key:       "resource_pool_type",
						Value:     resourcePoolType,
						Operation: "=",
					},
					{
						Key:       "bucket_id",
						Value:     bucketID,
						Operation: "=",
					},
				},
			}
		}
	},
	ObjectVolumePublicNetworkDownloadFlow: func(region, bucketID, resourcePool, resourcePoolType, name string) *alarmv1alpha.ListPromQLsRequest {
		if bucketID == "" {
			return &alarmv1alpha.ListPromQLsRequest{
				Name:            "object_storage_volume_public_network_download_flow",
				ResourceSubType: "ks3",
				Labels: []*alarmv1alpha.Label{
					{
						Key:       "resource_pool_type",
						Value:     resourcePoolType,
						Operation: "=",
					},
				},
			}
		} else {
			return &alarmv1alpha.ListPromQLsRequest{
				Name:            "object_storage_volume_public_network_download_flow",
				ResourceSubType: "ks3",
				Labels: []*alarmv1alpha.Label{
					{
						Key:       "resource_pool_type",
						Value:     resourcePoolType,
						Operation: "=",
					},
					{
						Key:       "bucket_id",
						Value:     bucketID,
						Operation: "=",
					},
				},
			}
		}
	},
	ObjectVolumeCRRUploadFlow: func(region, bucketID, resourcePool, resourcePoolType, name string) *alarmv1alpha.ListPromQLsRequest {
		if bucketID == "" {
			return &alarmv1alpha.ListPromQLsRequest{
				Name:            "object_storage_volume_crr_upload_flow",
				ResourceSubType: "ks3",
				Labels: []*alarmv1alpha.Label{
					{
						Key:       "resource_pool_type",
						Value:     resourcePoolType,
						Operation: "=",
					},
				},
			}
		} else {
			return &alarmv1alpha.ListPromQLsRequest{
				Name:            "object_storage_volume_crr_upload_flow",
				ResourceSubType: "ks3",
				Labels: []*alarmv1alpha.Label{
					{
						Key:       "resource_pool_type",
						Value:     resourcePoolType,
						Operation: "=",
					},
					{
						Key:       "bucket_id",
						Value:     bucketID,
						Operation: "=",
					},
				},
			}
		}
	},
	ObjectVolumeCRRDownloadFlow: func(region, bucketID, resourcePool, resourcePoolType, name string) *alarmv1alpha.ListPromQLsRequest {
		if bucketID == "" {
			return &alarmv1alpha.ListPromQLsRequest{
				Name:            "object_storage_volume_crr_download_flow",
				ResourceSubType: "ks3",
				Labels: []*alarmv1alpha.Label{
					{
						Key:       "resource_pool_type",
						Value:     resourcePoolType,
						Operation: "=",
					},
				},
			}
		} else {
			return &alarmv1alpha.ListPromQLsRequest{
				Name:            "object_storage_volume_crr_download_flow",
				ResourceSubType: "ks3",
				Labels: []*alarmv1alpha.Label{
					{
						Key:       "resource_pool_type",
						Value:     resourcePoolType,
						Operation: "=",
					},
					{
						Key:       "bucket_id",
						Value:     bucketID,
						Operation: "=",
					},
				},
			}
		}
	},
	ObjectVolumeCapacityTotal: func(region, bucketID, resourcePool, resourcePoolType, name string) *alarmv1alpha.ListPromQLsRequest {
		if bucketID == "" {
			return &alarmv1alpha.ListPromQLsRequest{
				Name:            "object_storage_volume_capacity_total",
				ResourceSubType: "ks3",
				Labels: []*alarmv1alpha.Label{
					{
						Key:       "resource_pool_type",
						Value:     resourcePoolType,
						Operation: "=",
					},
				},
			}
		} else {
			return &alarmv1alpha.ListPromQLsRequest{
				Name:            "object_storage_volume_capacity_total",
				ResourceSubType: "ks3",
				Labels: []*alarmv1alpha.Label{
					{
						Key:       "resource_pool_type",
						Value:     resourcePoolType,
						Operation: "=",
					},
					{
						Key:       "bucket_id",
						Value:     bucketID,
						Operation: "=",
					},
				},
			}
		}
	},
	ObjectStorageVolumeAbnormalReturnRanking: func(region, bucketID, resourcePool, resourcePoolType, name string) *alarmv1alpha.ListPromQLsRequest {
		return &alarmv1alpha.ListPromQLsRequest{
			Name:            "object_storage_volume_abnormal_return_ranking",
			ResourceSubType: "ks3",
			Labels: []*alarmv1alpha.Label{
				{
					Key:       "resource_pool_type",
					Value:     resourcePoolType,
					Operation: "=",
				},
			},
		}
	},
	ObjectVolumeWriteSuccessRate: func(region, bucketID, resourcePool, resourcePoolType, name string) *alarmv1alpha.ListPromQLsRequest {
		if bucketID == "" {
			return &alarmv1alpha.ListPromQLsRequest{
				Name:            "object_storage_volume_write_success_rate",
				ResourceSubType: "ks3",
				Labels: []*alarmv1alpha.Label{
					{
						Key:       "resource_pool_type",
						Value:     resourcePoolType,
						Operation: "=",
					},
				},
			}
		} else {
			return &alarmv1alpha.ListPromQLsRequest{
				Name:            "object_storage_volume_write_success_rate",
				ResourceSubType: "ks3",
				Labels: []*alarmv1alpha.Label{
					{
						Key:       "resource_pool_type",
						Value:     resourcePoolType,
						Operation: "=",
					},
					{
						Key:       "bucket_id",
						Value:     bucketID,
						Operation: "=",
					},
				},
			}
		}
	},
	ObjectVolumeReadSuccessRate: func(region, bucketID, resourcePool, resourcePoolType, name string) *alarmv1alpha.ListPromQLsRequest {
		if bucketID == "" {
			return &alarmv1alpha.ListPromQLsRequest{
				Name:            "object_storage_volume_read_success_rate",
				ResourceSubType: "ks3",
				Labels: []*alarmv1alpha.Label{
					{
						Key:       "resource_pool_type",
						Value:     resourcePoolType,
						Operation: "=",
					},
				},
			}
		} else {
			return &alarmv1alpha.ListPromQLsRequest{
				Name:            "object_storage_volume_read_success_rate",
				ResourceSubType: "ks3",
				Labels: []*alarmv1alpha.Label{
					{
						Key:       "resource_pool_type",
						Value:     resourcePoolType,
						Operation: "=",
					},
					{
						Key:       "bucket_id",
						Value:     bucketID,
						Operation: "=",
					},
				},
			}
		}
	},
	ObjectStorageVolumeDownloads30day: func(region, bucketID, resourcePool, resourcePoolType, name string) *alarmv1alpha.ListPromQLsRequest {
		return &alarmv1alpha.ListPromQLsRequest{
			Name:            "object_storage_volume_downloads_30day",
			ResourceSubType: "ks3",
			Labels: []*alarmv1alpha.Label{
				{
					Key:       "resource_pool_type",
					Value:     resourcePoolType,
					Operation: "=",
				},
			},
		}
	},

	// 详情
	ObjectVolumeCapacityIncrement: func(region, bucketID, resourcePool, resourcePoolType, name string) *alarmv1alpha.ListPromQLsRequest {
		if bucketID == "" {
			return &alarmv1alpha.ListPromQLsRequest{
				Name:            "object_storage_volume_capacity_increment",
				ResourceSubType: "ks3",
				Labels: []*alarmv1alpha.Label{
					{
						Key:       "resource_pool_type",
						Value:     resourcePoolType,
						Operation: "=",
					},
				},
			}
		} else {
			return &alarmv1alpha.ListPromQLsRequest{
				Name:            "object_storage_volume_capacity_increment",
				ResourceSubType: "ks3",
				Labels: []*alarmv1alpha.Label{
					{
						Key:       "resource_pool_type",
						Value:     resourcePoolType,
						Operation: "=",
					},
					{
						Key:       "bucket_id",
						Value:     bucketID,
						Operation: "=",
					},
				},
			}
		}

	},
	ObjectVolumeCapacityDeleteQuantity: func(region, bucketID, resourcePool, resourcePoolType, name string) *alarmv1alpha.ListPromQLsRequest {
		if bucketID == "" {
			return &alarmv1alpha.ListPromQLsRequest{
				Name:            "object_storage_volume_capacity_delete_quantity",
				ResourceSubType: "ks3",
				Labels: []*alarmv1alpha.Label{
					{
						Key:       "resource_pool_type",
						Value:     resourcePoolType,
						Operation: "=",
					},
				},
			}
		} else {
			return &alarmv1alpha.ListPromQLsRequest{
				Name:            "object_storage_volume_capacity_delete_quantity",
				ResourceSubType: "ks3",
				Labels: []*alarmv1alpha.Label{
					{
						Key:       "resource_pool_type",
						Value:     resourcePoolType,
						Operation: "=",
					},
					{
						Key:       "bucket_id",
						Value:     bucketID,
						Operation: "=",
					},
				},
			}
		}
	},
	ObjectVolumeGetRequestSum: func(region, bucketID, resourcePool, resourcePoolType, name string) *alarmv1alpha.ListPromQLsRequest {
		return &alarmv1alpha.ListPromQLsRequest{
			Name:            "object_storage_volume_get_request_sum",
			ResourceSubType: "ks3",
			Labels: []*alarmv1alpha.Label{
				{
					Key:       "resource_pool_type",
					Value:     resourcePoolType,
					Operation: "=",
				},
				{
					Key:       "bucket_id",
					Value:     bucketID,
					Operation: "=",
				},
			},
		}
	},
	ObjectVolumePutRequestSum: func(region, bucketID, resourcePool, resourcePoolType, name string) *alarmv1alpha.ListPromQLsRequest {
		return &alarmv1alpha.ListPromQLsRequest{
			Name:            "object_storage_volume_put_request_sum",
			ResourceSubType: "ks3",
			Labels: []*alarmv1alpha.Label{
				{
					Key:       "resource_pool_type",
					Value:     resourcePoolType,
					Operation: "=",
				},
				{
					Key:       "bucket_id",
					Value:     bucketID,
					Operation: "=",
				},
			},
		}
	},
	ObjectVolumePostRequestSum: func(region, bucketID, resourcePool, resourcePoolType, name string) *alarmv1alpha.ListPromQLsRequest {
		return &alarmv1alpha.ListPromQLsRequest{
			Name:            "object_storage_volume_post_request_sum",
			ResourceSubType: "ks3",
			Labels: []*alarmv1alpha.Label{
				{
					Key:       "resource_pool_type",
					Value:     resourcePoolType,
					Operation: "=",
				},
				{
					Key:       "bucket_id",
					Value:     bucketID,
					Operation: "=",
				},
			},
		}
	},
	ObjectVolumeHeadRequestSum: func(region, bucketID, resourcePool, resourcePoolType, name string) *alarmv1alpha.ListPromQLsRequest {
		return &alarmv1alpha.ListPromQLsRequest{
			Name:            "object_storage_volume_head_request_sum",
			ResourceSubType: "ks3",
			Labels: []*alarmv1alpha.Label{
				{
					Key:       "resource_pool_type",
					Value:     resourcePoolType,
					Operation: "=",
				},
				{
					Key:       "bucket_id",
					Value:     bucketID,
					Operation: "=",
				},
			},
		}
	},
	ObjectVolumeDeleteRequestSum: func(region, bucketID, resourcePool, resourcePoolType, name string) *alarmv1alpha.ListPromQLsRequest {
		return &alarmv1alpha.ListPromQLsRequest{
			Name:            "object_storage_volume_delete_request_sum",
			ResourceSubType: "ks3",
			Labels: []*alarmv1alpha.Label{
				{
					Key:       "resource_pool_type",
					Value:     resourcePoolType,
					Operation: "=",
				},
				{
					Key:       "bucket_id",
					Value:     bucketID,
					Operation: "=",
				},
			},
		}
	},
	ObjectVolumeOptionsRequestSum: func(region, bucketID, resourcePool, resourcePoolType, name string) *alarmv1alpha.ListPromQLsRequest {
		return &alarmv1alpha.ListPromQLsRequest{
			Name:            "object_storage_volume_options_request_sum",
			ResourceSubType: "ks3",
			Labels: []*alarmv1alpha.Label{
				{
					Key:       "resource_pool_type",
					Value:     resourcePoolType,
					Operation: "=",
				},
				{
					Key:       "bucket_id",
					Value:     bucketID,
					Operation: "=",
				},
			},
		}
	},
	ObjectVolume2xxRequestSum: func(region, bucketID, resourcePool, resourcePoolType, name string) *alarmv1alpha.ListPromQLsRequest {
		return &alarmv1alpha.ListPromQLsRequest{
			Name:            "object_storage_volume_2xx_request_sum",
			ResourceSubType: "ks3",
			Labels: []*alarmv1alpha.Label{
				{
					Key:       "resource_pool_type",
					Value:     resourcePoolType,
					Operation: "=",
				},
				{
					Key:       "bucket_id",
					Value:     bucketID,
					Operation: "=",
				},
			},
		}
	},
	ObjectVolume3xxRequestSum: func(region, bucketID, resourcePool, resourcePoolType, name string) *alarmv1alpha.ListPromQLsRequest {
		return &alarmv1alpha.ListPromQLsRequest{
			Name:            "object_storage_volume_3xx_request_sum",
			ResourceSubType: "ks3",
			Labels: []*alarmv1alpha.Label{
				{
					Key:       "resource_pool_type",
					Value:     resourcePoolType,
					Operation: "=",
				},
				{
					Key:       "bucket_id",
					Value:     bucketID,
					Operation: "=",
				},
			},
		}
	},
	ObjectVolume4xxRequestSum: func(region, bucketID, resourcePool, resourcePoolType, name string) *alarmv1alpha.ListPromQLsRequest {
		return &alarmv1alpha.ListPromQLsRequest{
			Name:            "object_storage_volume_4xx_request_sum",
			ResourceSubType: "ks3",
			Labels: []*alarmv1alpha.Label{
				{
					Key:       "resource_pool_type",
					Value:     resourcePoolType,
					Operation: "=",
				},
				{
					Key:       "bucket_id",
					Value:     bucketID,
					Operation: "=",
				},
			},
		}
	},
	ObjectVolume5xxRequestSum: func(region, bucketID, resourcePool, resourcePoolType, name string) *alarmv1alpha.ListPromQLsRequest {
		return &alarmv1alpha.ListPromQLsRequest{
			Name:            "object_storage_volume_5xx_request_sum",
			ResourceSubType: "ks3",
			Labels: []*alarmv1alpha.Label{
				{
					Key:       "resource_pool_type",
					Value:     resourcePoolType,
					Operation: "=",
				},
				{
					Key:       "bucket_id",
					Value:     bucketID,
					Operation: "=",
				},
			},
		}
	},
	ObjectPoolStatusCodesReturnNumber2XX: func(region, bucketID, resourcePool, resourcePoolType, name string) *alarmv1alpha.ListPromQLsRequest {
		return &alarmv1alpha.ListPromQLsRequest{
			Name:            "object_storage_resource_pool_status_codes_return_number_2xx_count",
			ResourceSubType: "ks3",
			Labels: []*alarmv1alpha.Label{
				{
					Key:       "resource_pool_type",
					Value:     resourcePoolType,
					Operation: "=",
				},
			},
		}
	},
	ObjectPoolStatusCodesReturnNumber3XX: func(region, bucketID, resourcePool, resourcePoolType, name string) *alarmv1alpha.ListPromQLsRequest {
		return &alarmv1alpha.ListPromQLsRequest{
			Name:            "object_storage_resource_pool_status_codes_return_number_3xx_count",
			ResourceSubType: "ks3",
			Labels: []*alarmv1alpha.Label{
				{
					Key:       "resource_pool_type",
					Value:     resourcePoolType,
					Operation: "=",
				},
			},
		}
	},
	ObjectPoolStatusCodesReturnNumber4XX: func(region, bucketID, resourcePool, resourcePoolType, name string) *alarmv1alpha.ListPromQLsRequest {
		return &alarmv1alpha.ListPromQLsRequest{
			Name:            "object_storage_resource_pool_status_codes_return_number_4xx_count",
			ResourceSubType: "ks3",
			Labels: []*alarmv1alpha.Label{
				{
					Key:       "resource_pool_type",
					Value:     resourcePoolType,
					Operation: "=",
				},
			},
		}
	},
	ObjectPoolStatusCodesReturnNumber5XX: func(region, bucketID, resourcePool, resourcePoolType, name string) *alarmv1alpha.ListPromQLsRequest {
		return &alarmv1alpha.ListPromQLsRequest{
			Name:            "object_storage_resource_pool_status_codes_return_number_5xx_count",
			ResourceSubType: "ks3",
			Labels: []*alarmv1alpha.Label{
				{
					Key:       "resource_pool_type",
					Value:     resourcePoolType,
					Operation: "=",
				},
			},
		}
	},
}

```

File path: /Users/mac/Desktop/woker_code/monitor/common/promql_template/objectstorage/object_template.go
```golang
package objectstorage

func GetPredictObjectCapacity(resourcePoolType, t, tt string) string {
	psql := `avg without (pod, instance) (predict_linear(object_storage_resource_pool_capacity_inventory{resource_pool = "` + resourcePoolType + `"}[` + t + `],` + tt + `))`
	return psql
}

```

File path: /Users/mac/Desktop/woker_code/monitor/common/promql_template/blockstorage/template.go
```golang
package blockstorage

import alarmv1alpha "ezone.ksyun.com/ezone/luban/luban_api/alarmapis/alarm/v1alpha/gen"

type blockStorageReqFunc func(region, az, poolName, poolType string) *alarmv1alpha.ListPromQLsRequest

const (
	EbsCapacity             = "storage_resource_pool_capacity"
	EbsCapTotal             = "storage_resource_pool_total"
	EbsCapUsed              = "storage_resource_pool_usage"
	EbsCapRate              = "storage_resource_pool_use_rate"
	CloudDiskCount          = "cloud_disk_count"
	CloudDiskUnMountPercent = "cloud_disk_unmount_percent"
	EbsIOReadQps            = "storage_resource_pool_io_read_qps"
	EbsIOWriteQps           = "storage_resource_pool_io_write_qps"
	EbsIOReadDelay          = "storage_resource_pool_io_read_delay"
	EbsIOWriteDelay         = "storage_resource_pool_io_write_delay"
	EbsIOReadBand           = "storage_resource_pool_io_read_band"
	EbsIOWriteBand          = "storage_resource_pool_io_write_band"
)

var MetricMap = map[string]string{
	EbsCapacity:             "存储容量库存",
	CloudDiskCount:          "块存储总数",
	EbsCapTotal:             "总量",
	EbsCapRate:              "用量趋势",
	CloudDiskUnMountPercent: "待挂载块存储占比",
	EbsIOReadQps:            "读",
	EbsIOWriteQps:           "写",
	EbsIOReadDelay:          "读延时",
	EbsIOWriteDelay:         "写延时",
	EbsIOReadBand:           "读带宽",
	EbsIOWriteBand:          "写带宽",
}

var TemplateMap = map[string]blockStorageReqFunc{
	EbsCapacity: func(region, az, poolName, poolType string) *alarmv1alpha.ListPromQLsRequest {
		return &alarmv1alpha.ListPromQLsRequest{
			Name:            "storage_resource_pool_capacity",
			ResourceSubType: "ebs",
			Labels: []*alarmv1alpha.Label{
				{
					Key:       "resource_pool_type",
					Value:     poolType,
					Operation: "=",
				},
			},
		}
	},
	EbsCapTotal: func(region, az, poolName, poolType string) *alarmv1alpha.ListPromQLsRequest {
		return &alarmv1alpha.ListPromQLsRequest{
			Name:            "storage_resource_pool_total",
			ResourceSubType: "ebs",
			Labels: []*alarmv1alpha.Label{
				{
					Key:       "resource_pool",
					Value:     poolName,
					Operation: "=",
				},
			},
		}
	},
	EbsCapUsed: func(region, az, poolName, poolType string) *alarmv1alpha.ListPromQLsRequest {
		return &alarmv1alpha.ListPromQLsRequest{
			Name:            "storage_resource_pool_usage",
			ResourceSubType: "ebs",
			Labels: []*alarmv1alpha.Label{
				{
					Key:       "resource_pool",
					Value:     poolName,
					Operation: "=",
				},
			},
		}
	},
	EbsCapRate: func(region, az, poolName, poolType string) *alarmv1alpha.ListPromQLsRequest {
		return &alarmv1alpha.ListPromQLsRequest{
			Name:            "storage_resource_pool_use_rate",
			ResourceSubType: "ebs",
			Labels: []*alarmv1alpha.Label{
				{
					Key:       "resource_pool",
					Value:     poolName,
					Operation: "=",
				},
			},
		}
	},
	CloudDiskCount: func(region, az, poolName, poolType string) *alarmv1alpha.ListPromQLsRequest {
		return &alarmv1alpha.ListPromQLsRequest{
			Name:            "cloud_disk_count",
			ResourceSubType: "ebs",
			Labels: []*alarmv1alpha.Label{
				{
					Key:       "region",
					Value:     region,
					Operation: "=",
				},
				{
					Key:       "az",
					Value:     az,
					Operation: "=",
				},
				{
					Key:       "resource_pool",
					Value:     poolName,
					Operation: "=",
				},
				{
					Key:       "resource_pool_type",
					Value:     poolType,
					Operation: "=",
				},
			},
		}
	},
	CloudDiskUnMountPercent: func(region, az, poolName, poolType string) *alarmv1alpha.ListPromQLsRequest {
		return &alarmv1alpha.ListPromQLsRequest{
			Name:            "cloud_disk_unmount_percent",
			ResourceSubType: "ebs",
			Labels: []*alarmv1alpha.Label{
				{
					Key:       "region",
					Value:     region,
					Operation: "=",
				},
				{
					Key:       "az",
					Value:     az,
					Operation: "=",
				},
				{
					Key:       "resource_pool",
					Value:     poolName,
					Operation: "=",
				},
				{
					Key:       "resource_pool_type",
					Value:     poolType,
					Operation: "=",
				},
			},
		}
	},
	EbsIOReadQps: func(region, az, poolName, poolType string) *alarmv1alpha.ListPromQLsRequest {
		return &alarmv1alpha.ListPromQLsRequest{
			Name:            "storage_resource_pool_io_read_qps",
			ResourceSubType: "ebs",
			Labels: []*alarmv1alpha.Label{
				{
					Key:       "region",
					Value:     region,
					Operation: "=",
				},
				{
					Key:       "az",
					Value:     az,
					Operation: "=",
				},
				{
					Key:       "lubanResourceName",
					Value:     poolName,
					Operation: "=",
				},
				{
					Key:       "resourcePool",
					Value:     poolType,
					Operation: "=",
				},
			},
		}
	},
	EbsIOWriteQps: func(region, az, poolName, poolType string) *alarmv1alpha.ListPromQLsRequest {
		return &alarmv1alpha.ListPromQLsRequest{
			Name:            "storage_resource_pool_io_write_qps",
			ResourceSubType: "ebs",
			Labels: []*alarmv1alpha.Label{
				{
					Key:       "region",
					Value:     region,
					Operation: "=",
				},
				{
					Key:       "az",
					Value:     az,
					Operation: "=",
				},
				{
					Key:       "resourcePoolName",
					Value:     poolName,
					Operation: "=",
				},
				{
					Key:       "resourcePool",
					Value:     poolType,
					Operation: "=",
				},
			},
		}
	},
	EbsIOReadDelay: func(region, az, poolName, poolType string) *alarmv1alpha.ListPromQLsRequest {
		return &alarmv1alpha.ListPromQLsRequest{
			Name:            "storage_resource_pool_io_read_delay",
			ResourceSubType: "ebs",
			Labels: []*alarmv1alpha.Label{
				{
					Key:       "region",
					Value:     region,
					Operation: "=",
				},
				{
					Key:       "az",
					Value:     az,
					Operation: "=",
				},
				{
					Key:       "lubanResourceName",
					Value:     poolName,
					Operation: "=",
				},
				{
					Key:       "resourcePool",
					Value:     poolType,
					Operation: "=",
				},
			},
		}
	},
	EbsIOWriteDelay: func(region, az, poolName, poolType string) *alarmv1alpha.ListPromQLsRequest {
		return &alarmv1alpha.ListPromQLsRequest{
			Name:            "storage_resource_pool_io_write_delay",
			ResourceSubType: "ebs",
			Labels: []*alarmv1alpha.Label{
				{
					Key:       "region",
					Value:     region,
					Operation: "=",
				},
				{
					Key:       "az",
					Value:     az,
					Operation: "=",
				},
				{
					Key:       "lubanResourceName",
					Value:     poolName,
					Operation: "=",
				},
				{
					Key:       "resourcePool",
					Value:     poolType,
					Operation: "=",
				},
			},
		}
	},
	EbsIOReadBand: func(region, az, poolName, poolType string) *alarmv1alpha.ListPromQLsRequest {
		return &alarmv1alpha.ListPromQLsRequest{
			Name:            "storage_resource_pool_io_read_band",
			ResourceSubType: "ebs",
			Labels: []*alarmv1alpha.Label{
				{
					Key:       "region",
					Value:     region,
					Operation: "=",
				},
				{
					Key:       "az",
					Value:     az,
					Operation: "=",
				},
				{
					Key:       "lubanResourceName",
					Value:     poolName,
					Operation: "=",
				},
				{
					Key:       "resourcePool",
					Value:     poolType,
					Operation: "=",
				},
			},
		}
	},
	EbsIOWriteBand: func(region, az, poolName, poolType string) *alarmv1alpha.ListPromQLsRequest {
		return &alarmv1alpha.ListPromQLsRequest{
			Name:            "storage_resource_pool_io_write_band",
			ResourceSubType: "ebs",
			Labels: []*alarmv1alpha.Label{
				{
					Key:       "region",
					Value:     region,
					Operation: "=",
				},
				{
					Key:       "az",
					Value:     az,
					Operation: "=",
				},
				{
					Key:       "lubanResourceName",
					Value:     poolName,
					Operation: "=",
				},
				{
					Key:       "resourcePool",
					Value:     poolType,
					Operation: "=",
				},
			},
		}
	},
}

```

File path: /Users/mac/Desktop/woker_code/monitor/common/promql_template/blockstorage/native_template.go
```golang
package blockstorage

func GetPredictEbsCapacity(resourcePoolType, t, tt string) string {
	psql := `avg without (pod, instance) (predict_linear(storage_resource_pool_capacity{resource_pool = "` + resourcePoolType + `"}[` + t + `],` + tt + `))`
	return psql
}

```

File path: /Users/mac/Desktop/woker_code/monitor/common/promql_template/network/native_template.go
```golang
package network

import (
	template "ezone.ksyun.com/ezone/luban/monitor/common/promql_template"
	"strings"
)

const (
	SlbConns                   = "slbConns"
	SlbTrafficIn               = "slbTrafficIn"
	SlbTrafficOut              = "slbTrafficOut"
	TengineSlbConns            = "tengineSlbConns"
	TengineSlbTrafficIn        = "tengineSlbTrafficIn"
	TengineSlbTrafficOut       = "tengineSlbTrafficOut"
	EipTrafficIn               = "eipTrafficIn"
	EipTrafficOut              = "eipTrafficOut"
	NatTrafficIn               = "natTrafficIn"
	NatTrafficOut              = "natTrafficOut"
	TgwLpeerBytesIn            = "tgwLpeerBytesIn"
	TgwLpeerBytesOut           = "tgwLpeerBytesOut"
	TgwDcytesIn                = "tgwDcytesIn"
	TgwDcBytesOut              = "tgwDcBytesOut"
	TgwVpnBytesIn              = "tgwVpnBytesIn"
	TgwVpnBytesOut             = "tgwVpnBytesOut"
	SgwPublicDropPacketRateIn  = "sgwPublicDropPacketRateIn"
	SgwPublicDropPacketRateOut = "sgwPublicDropPacketRateOut"
	SgwPublicEipTrafficIn      = "sgwPublicEipTrafficIn"
	SgwPublicEipTrafficOut     = "sgwPublicEipTrafficOut"
)

var NativeTemplateMap = map[string]template.QuerySql{
	SlbConns: {
		SqlTemplate: `topK({{.TopK}},avg_over_time(xgw_lb_curr_local_conns{ {{.Labels}} }[10m]))`,
		Name:        "SLB连接数",
		Unit:        "个",
	},
	SlbTrafficIn: {
		SqlTemplate: `topK({{.TopK}},avg_over_time(xgw_lb_in_traffic{ {{.Labels}} }[10m]))`,
		Name:        "SLB入口流量",
		Unit:        "B",
	},
	SlbTrafficOut: {
		SqlTemplate: `topK({{.TopK}},avg_over_time(xgw_lb_out_traffic{ {{.Labels}} }[10m]))`,
		Name:        "SLB出口流量",
		Unit:        "B",
	},
	TengineSlbConns: {
		SqlTemplate: `topK({{.TopK}},avg_over_time(tengine_conn_total{ {{.Labels}} }[10m]))`,
		Name:        "Tengine连接数",
		Unit:        "个",
	},
	TengineSlbTrafficIn: {
		SqlTemplate: `topK({{.TopK}},avg_over_time(tengine_traffic_in{ {{.Labels}} }[10m]))`,
		Name:        "Tengine入口流量",
		Unit:        "B",
	},
	TengineSlbTrafficOut: {
		SqlTemplate: `topK({{.TopK}},avg_over_time(tengine_traffic_out{ {{.Labels}} }[10m]))`,
		Name:        "Tengine出口流量",
		Unit:        "B",
	},
	EipTrafficIn: {
		SqlTemplate: `topK({{.TopK}},avg_over_time(xgw_eip_in_traffic{ {{.Labels}} }[10m]))`,
		Name:        "EIP入口流量",
		Unit:        "B",
	},
	EipTrafficOut: {
		SqlTemplate: `topK({{.TopK}},avg_over_time(xgw_eip_out_traffic{ {{.Labels}} }[10m]))`,
		Name:        "EIP出口流量",
		Unit:        "B",
	},
	NatTrafficIn: {
		SqlTemplate: `topK({{.TopK}},avg_over_time(nat_traffic_in{ {{.Labels}} }[{{.Duration}}s]))`,
		Name:        "NAT入口流量",
		Unit:        "B",
	},
	NatTrafficOut: {
		SqlTemplate: `topK({{.TopK}},avg_over_time(nat_traffic_out{ {{.Labels}} }[{{.Duration}}s]))`,
		Name:        "NAT出口流量",
		Unit:        "B",
	},
	TgwLpeerBytesIn: {
		SqlTemplate: `topK({{.TopK}},sum(avg_over_time(tgw_bytes_in{ {{.Labels}} ,tgwtype = "lpeer"}[10m]))by(vni, domain,dip, tgwtype))`,
		Name:        "TGW Lpeer入口流量",
		Unit:        "B",
	},
	TgwLpeerBytesOut: {
		SqlTemplate: `topK({{.TopK}},sum(avg_over_time(tgw_bytes_out{ {{.Labels}} ,tgwtype = "lpeer"}[10m]))by(vni, domain,dip, tgwtype))`,
		Name:        "TGW Lpeer出口流量",
		Unit:        "B",
	},
	TgwDcytesIn: {
		SqlTemplate: `topK({{.TopK}},sum(avg_over_time(tgw_bytes_in{ {{.Labels}} ,tgwtype = "DC"}[10m]))by(vni, domain,dip, tgwtype))`,
		Name:        "TGW DC入口流量",
		Unit:        "B",
	},
	TgwDcBytesOut: {
		SqlTemplate: `topK({{.TopK}},sum(avg_over_time(tgw_bytes_out{ {{.Labels}} ,tgwtype = "DC"}[10m]))by(vni, domain,dip, tgwtype))`,
		Name:        "TGW DC出口流量",
		Unit:        "B",
	},
	TgwVpnBytesIn: {
		SqlTemplate: `topK({{.TopK}},sum(avg_over_time(tgw_bytes_in{ {{.Labels}} ,tgwtype = "vpn"}[10m]))by(vni, domain,dip, tgwtype))`,
		Name:        "TGW VPN入口流量",
		Unit:        "B",
	},
	TgwVpnBytesOut: {
		SqlTemplate: `topK({{.TopK}},sum(avg_over_time(tgw_bytes_out{ {{.Labels}} ,tgwtype = "vpn"}[10m]))by(vni, domain,dip, tgwtype))`,
		Name:        "TGW VPN出口流量",
		Unit:        "B",
	},
	SgwPublicDropPacketRateIn: {
		SqlTemplate: `topK({{.TopK}},rate(sgw_eip_in_drop_packet{ {{.Labels}} }[10m]))`,
		Name:        "SGW公网入口丢包率",
		Unit:        "%",
	},
	SgwPublicDropPacketRateOut: {
		SqlTemplate: `topK({{.TopK}},rate(sgw_eip_out_drop_packet{ {{.Labels}} }[10m]))`,
		Name:        "SGW公网出口丢包率",
		Unit:        "%",
	},
	SgwPublicEipTrafficIn: {
		SqlTemplate: `topK({{.TopK}},avg_over_time(sgw_eip_in_traffic{ {{.Labels}} }[10m]))`,
		Name:        "SGW公网EIP入口流量",
		Unit:        "B",
	},
	SgwPublicEipTrafficOut: {
		SqlTemplate: `topK({{.TopK}},avg_over_time(sgw_eip_out_traffic{ {{.Labels}} }[10m]))`,
		Name:        "SGW公网EIP出口流量",
		Unit:        "B",
	},
}

// XGW-LB 总活动连接数预测
func GetPredictNodeNetstatTcpCurrEstabSum(ipList []string, t, tt string) string {
	str := strings.Join(ipList, "|")
	psql := `predict_linear(sum(node_netstat_Tcp_CurrEstab{instance =~ "` + str + `"})[` + t + `:],` + tt + `)`
	return psql
}

// XGW-LB 节点活动连接数预测
func GetPredictNodeNetstatTcpCurrEstab(ip string, t, tt string) string {
	psql := `predict_linear(node_netstat_Tcp_CurrEstab{instance = "` + ip + `"}[` + t + `],` + tt + `)`
	return psql
}

```

File path: /Users/mac/Desktop/woker_code/monitor/common/promql_template/server/multiple_keys_template.go
```golang
package server

import (
	alarmv1alpha "ezone.ksyun.com/ezone/luban/luban_api/alarmapis/alarm/v1alpha/gen"
	template "ezone.ksyun.com/ezone/luban/monitor/common/promql_template"
)

const (
	IpmiSensorState            = "ipmi_sensor_state"
	NetworkReceiveBytes        = "network_receive_bytes"
	NetworkTransmitBytes       = "network_transmit_bytes"
	NetworkReceiveErrs         = "network_receive_errs_"
	NetworkTransmitErrs        = "network_transmit_errs"
	NetworkReceiveDrop         = "network_receive_drop"
	NetworkTransmitDrop        = "network_transmit_drop"
	SwitchInterfaceOutDropRate = "switch_interface_out_drop_rate"
	SwitchInterfaceInDropRate  = "switch_interface_in_drop_rate"
	SwitchInFlow               = "switch_in_flow"
	SwitchOutFlow              = "switch_out_flow"
	SwitchInPacketRate         = "switch_in_packet_rate"
	SwitchOutPacketRate        = "switch_out_packet_rate"
)

var MultipleKeysTemplateMap = map[string]template.PromQLReq{
	IpmiSensorState: func(labels []*alarmv1alpha.Label) *alarmv1alpha.ListPromQLsRequest {
		return &alarmv1alpha.ListPromQLsRequest{
			Name:            "ipmi_sensor_state",
			ResourceSubType: "physicalServer",
			Labels:          labels,
		}
	},
	NetworkReceiveBytes: func(Labels []*alarmv1alpha.Label) *alarmv1alpha.ListPromQLsRequest {
		return &alarmv1alpha.ListPromQLsRequest{
			Name:            "network_receive_bytes",
			ResourceSubType: "physicalServer",
			Labels:          Labels,
		}
	},
	NetworkTransmitBytes: func(labels []*alarmv1alpha.Label) *alarmv1alpha.ListPromQLsRequest {
		return &alarmv1alpha.ListPromQLsRequest{
			Name:            "network_transmit_bytes",
			ResourceSubType: "physicalServer",
			Labels:          labels,
		}
	},
	NetworkReceiveErrs: func(labels []*alarmv1alpha.Label) *alarmv1alpha.ListPromQLsRequest {
		return &alarmv1alpha.ListPromQLsRequest{
			Name:            "network_receive_errs",
			ResourceSubType: "physicalServer",
			Labels:          labels,
		}
	},
	NetworkTransmitErrs: func(labels []*alarmv1alpha.Label) *alarmv1alpha.ListPromQLsRequest {
		return &alarmv1alpha.ListPromQLsRequest{
			Name:            "network_transmit_errs",
			ResourceSubType: "physicalServer",
			Labels:          labels,
		}
	},
	NetworkReceiveDrop: func(labels []*alarmv1alpha.Label) *alarmv1alpha.ListPromQLsRequest {
		return &alarmv1alpha.ListPromQLsRequest{
			Name:            "network_receive_drop",
			ResourceSubType: "physicalServer",
			Labels:          labels,
		}
	},
	NetworkTransmitDrop: func(labels []*alarmv1alpha.Label) *alarmv1alpha.ListPromQLsRequest {
		return &alarmv1alpha.ListPromQLsRequest{
			Name:            "network_transmit_drop",
			ResourceSubType: "physicalServer",
			Labels:          labels,
		}
	},
	SwitchInterfaceOutDropRate: func(labels []*alarmv1alpha.Label) *alarmv1alpha.ListPromQLsRequest {
		return &alarmv1alpha.ListPromQLsRequest{
			Name:            "switch_interface_out_drop_rate",
			ResourceSubType: "physicalSwitch",
			Labels:          labels,
		}
	},
	SwitchInterfaceInDropRate: func(labels []*alarmv1alpha.Label) *alarmv1alpha.ListPromQLsRequest {
		return &alarmv1alpha.ListPromQLsRequest{
			Name:            "switch_interface_in_drop_rate",
			ResourceSubType: "physicalSwitch",
			Labels:          labels,
		}
	},
	SwitchInFlow: func(labels []*alarmv1alpha.Label) *alarmv1alpha.ListPromQLsRequest {
		return &alarmv1alpha.ListPromQLsRequest{
			Name:            "switch_in_flow",
			ResourceSubType: "physicalSwitch",
			Labels:          labels,
		}
	},
	SwitchOutFlow: func(labels []*alarmv1alpha.Label) *alarmv1alpha.ListPromQLsRequest {
		return &alarmv1alpha.ListPromQLsRequest{
			Name:            "switch_out_flow",
			ResourceSubType: "physicalSwitch",
			Labels:          labels,
		}
	},
	SwitchInPacketRate: func(labels []*alarmv1alpha.Label) *alarmv1alpha.ListPromQLsRequest {
		return &alarmv1alpha.ListPromQLsRequest{
			Name:            "switch_in_packet_rate",
			ResourceSubType: "physicalSwitch",
			Labels:          labels,
		}
	},
	SwitchOutPacketRate: func(labels []*alarmv1alpha.Label) *alarmv1alpha.ListPromQLsRequest {
		return &alarmv1alpha.ListPromQLsRequest{
			Name:            "switch_out_packet_rate",
			ResourceSubType: "physicalSwitch",
			Labels:          labels,
		}
	},
}

```

File path: /Users/mac/Desktop/woker_code/monitor/common/promql_template/server/template.go
```golang
package server

import (
	"strings"

	alarmv1alpha "ezone.ksyun.com/ezone/luban/luban_api/alarmapis/alarm/v1alpha/gen"
)

const (
	// 与前端定义，传入的值
	Status                     = "server_status"
	CpuTotal                   = "cpu_total"
	CpuUsageRate               = "cpu_usage_rate"
	CpuUsageSumRate            = "cpu_usage_sum_rate" //多个节点的汇总使用率
	MemTotal                   = "memory_total"
	MemUsageRate               = "memory_usage_rate"
	MemUsage                   = "memory_usage"
	MemUsageSumRate            = "memory_usage_sum_rate" //多个节点的汇总使用率
	DiskUsageRate              = "disk_usage_rate"
	DiskUsage                  = "disk_usage"
	DiskUsageSumRate           = "disk_usage_sum_rate"             //多个节点的汇总使用率
	NodeNetstatTcpCurrEstab    = "node_netstat_tcp_curr_estab"     //节点tcp连接数
	NodeNetstatTcpCurrEstabSum = "node_netstat_tcp_curr_estab_sum" //节点tcp连接数汇总
	NodeNetworkPps             = "node_network_pps"
	NodeNetworkBps             = "node_network_bps"
	NetworkReceive24h          = "server_network_receive_24h"
	NetworkTransmit24h         = "server_network_transmit_24h"
	DiskAvailEvery             = "server_disk_avail_every"
	CpuMode                    = "server_cpu_mode"
	CpuNodeLoad1               = "node_load1"
	CpuNodeLoad5               = "node_load5"
	CpuNodeLoad15              = "node_load15"
	NodeMemoryFree             = "node_memory_free"
	NodeMemoryTotal            = "node_memory_total"
	NodeMemoryAvailable        = "node_memory_available"
	DiskReadBytes              = "disk_read_bytes"
	DiskWrittenBytes           = "disk_written_bytes"
	DiskWriteIo                = "disk_write_io"
	DiskReadIo                 = "disk_read_io"
	DiskIoReadCount            = "disk_io_reads_count"
	DiskIoWriteCount           = "disk_io_writes_count"
	DiskIoReadDelay            = "disk_io_read_delay"
	DiskIoWriteDelay           = "disk_io_write_delay"
	NetworkCardList            = "network_card_list"
	IpmiUp                     = "ipmi_up"
	InTemp                     = "in_temp"
	OutTemp                    = "out_temp"
	IpmiSensorStateCpu         = "ipmi_sensor_state_cpu"
	IpmiSensorStateMem         = "ipmi_sensor_state_mem"
	IpmiSensorStatePower       = "ipmi_sensor_state_power"
	IpmiSensorStateFan         = "ipmi_sensor_state_fan"
	IpmiFanSpeedRpm            = "ipmi_fan_speed_rpm"
	SwitchStatus               = "switch_status"
	SwitchCpuUsageRate         = "switch_cpu_usage_rate"
	SwitchMemUsageRate         = "switch_mem_usage_rate"
)

//如果label的类型不固定，使用这个func
//type promQLReq func(labels []*alarmv1alpha.Label) *alarmv1alpha.ListPromQLsRequest

type serverReqFunc func(ipList []string) *alarmv1alpha.ListPromQLsRequest

var TemplateMap = map[string]serverReqFunc{
	Status: func(ipList []string) *alarmv1alpha.ListPromQLsRequest {
		return &alarmv1alpha.ListPromQLsRequest{
			Name:            "server_status",
			ResourceSubType: "physicalServer",
			Labels: []*alarmv1alpha.Label{
				{
					Key:       "instance",
					Value:     strings.Join(ipList, "|"), //127.0.0.1:9100|127.0.0.2:9100
					Operation: "=~",
				},
			},
		}
	},
	CpuTotal: func(ipList []string) *alarmv1alpha.ListPromQLsRequest {
		return &alarmv1alpha.ListPromQLsRequest{
			Name:            "cpu_total",
			ResourceSubType: "physicalServer",
			Labels: []*alarmv1alpha.Label{
				{
					Key:       "instance",
					Value:     strings.Join(ipList, "|"),
					Operation: "=~",
				},
			},
		}
	},
	CpuUsageRate: func(ipList []string) *alarmv1alpha.ListPromQLsRequest {
		return &alarmv1alpha.ListPromQLsRequest{
			Name:            "cpu_usage_rate",
			ResourceSubType: "physicalServer",
			Labels: []*alarmv1alpha.Label{
				{
					Key:       "instance",
					Value:     strings.Join(ipList, "|"),
					Operation: "=~",
				},
			},
		}
	},
	CpuUsageSumRate: func(ipList []string) *alarmv1alpha.ListPromQLsRequest {
		return &alarmv1alpha.ListPromQLsRequest{
			Name:            "cpu_usage_sum_rate",
			ResourceSubType: "physicalServer",
			Labels: []*alarmv1alpha.Label{
				{
					Key:       "instance",
					Value:     strings.Join(ipList, "|"),
					Operation: "=~",
				},
			},
		}
	},
	MemTotal: func(ipList []string) *alarmv1alpha.ListPromQLsRequest {
		return &alarmv1alpha.ListPromQLsRequest{
			Name:            "memory_total",
			ResourceSubType: "physicalServer",
			Labels: []*alarmv1alpha.Label{
				{
					Key:       "instance",
					Value:     strings.Join(ipList, "|"),
					Operation: "=~",
				},
			},
		}
	},
	MemUsageRate: func(ipList []string) *alarmv1alpha.ListPromQLsRequest {
		return &alarmv1alpha.ListPromQLsRequest{
			Name:            "memory_usage_rate",
			ResourceSubType: "physicalServer",
			Labels: []*alarmv1alpha.Label{
				{
					Key:       "instance",
					Value:     strings.Join(ipList, "|"),
					Operation: "=~",
				},
			},
		}
	},
	MemUsage: func(ipList []string) *alarmv1alpha.ListPromQLsRequest {
		return &alarmv1alpha.ListPromQLsRequest{
			Name:            "memory_usage",
			ResourceSubType: "physicalServer",
			Labels: []*alarmv1alpha.Label{
				{
					Key:       "instance",
					Value:     strings.Join(ipList, "|"),
					Operation: "=~",
				},
			},
		}
	},
	MemUsageSumRate: func(ipList []string) *alarmv1alpha.ListPromQLsRequest {
		return &alarmv1alpha.ListPromQLsRequest{
			Name:            "memory_usage_sum_rate",
			ResourceSubType: "physicalServer",
			Labels: []*alarmv1alpha.Label{
				{
					Key:       "instance",
					Value:     strings.Join(ipList, "|"),
					Operation: "=~",
				},
			},
		}
	},
	DiskUsageRate: func(ipList []string) *alarmv1alpha.ListPromQLsRequest {
		return &alarmv1alpha.ListPromQLsRequest{
			Name:            "disk_usage_rate",
			ResourceSubType: "physicalServer",
			Labels: []*alarmv1alpha.Label{
				{
					Key:       "instance",
					Value:     strings.Join(ipList, "|"),
					Operation: "=~",
				},
			},
		}
	},
	DiskUsage: func(ipList []string) *alarmv1alpha.ListPromQLsRequest {
		return &alarmv1alpha.ListPromQLsRequest{
			Name:            "disk_usage",
			ResourceSubType: "physicalServer",
			Labels: []*alarmv1alpha.Label{
				{
					Key:       "instance",
					Value:     strings.Join(ipList, "|"),
					Operation: "=~",
				},
			},
		}
	},
	DiskUsageSumRate: func(ipList []string) *alarmv1alpha.ListPromQLsRequest {
		return &alarmv1alpha.ListPromQLsRequest{
			Name:            "disk_usage_sum_rate",
			ResourceSubType: "physicalServer",
			Labels: []*alarmv1alpha.Label{
				{
					Key:       "instance",
					Value:     strings.Join(ipList, "|"),
					Operation: "=~",
				},
			},
		}
	},
	NodeNetstatTcpCurrEstab: func(ipList []string) *alarmv1alpha.ListPromQLsRequest {
		return &alarmv1alpha.ListPromQLsRequest{
			Name:            "node_netstat_tcp_curr_estab",
			ResourceSubType: "physicalServer",
			Labels: []*alarmv1alpha.Label{
				{
					Key:       "instance",
					Value:     strings.Join(ipList, "|"),
					Operation: "=~",
				},
			},
		}
	},
	NodeNetstatTcpCurrEstabSum: func(ipList []string) *alarmv1alpha.ListPromQLsRequest {
		return &alarmv1alpha.ListPromQLsRequest{
			Name:            "node_netstat_tcp_curr_estab_sum",
			ResourceSubType: "physicalServer",
			Labels: []*alarmv1alpha.Label{
				{
					Key:       "instance",
					Value:     strings.Join(ipList, "|"),
					Operation: "=~",
				},
			},
		}
	},
	NodeNetworkPps: func(ipList []string) *alarmv1alpha.ListPromQLsRequest {
		return &alarmv1alpha.ListPromQLsRequest{
			Name:            "node_network_pps",
			ResourceSubType: "physicalServer",
			Labels: []*alarmv1alpha.Label{
				{
					Key:       "instance",
					Value:     strings.Join(ipList, "|"),
					Operation: "=~",
				},
			},
		}
	},
	NodeNetworkBps: func(ipList []string) *alarmv1alpha.ListPromQLsRequest {
		return &alarmv1alpha.ListPromQLsRequest{
			Name:            "node_network_bps",
			ResourceSubType: "physicalServer",
			Labels: []*alarmv1alpha.Label{
				{
					Key:       "instance",
					Value:     strings.Join(ipList, "|"),
					Operation: "=~",
				},
			},
		}
	},
	NetworkReceive24h: func(ipList []string) *alarmv1alpha.ListPromQLsRequest {
		return &alarmv1alpha.ListPromQLsRequest{
			Name:            "server_network_receive_24h",
			ResourceSubType: "physicalServer",
			Labels: []*alarmv1alpha.Label{
				{
					Key:       "instance",
					Value:     strings.Join(ipList, "|"),
					Operation: "=~",
				},
			},
		}
	},
	NetworkTransmit24h: func(ipList []string) *alarmv1alpha.ListPromQLsRequest {
		return &alarmv1alpha.ListPromQLsRequest{
			Name:            "Server_network_transmit_24h",
			ResourceSubType: "physicalServer",
			Labels: []*alarmv1alpha.Label{
				{
					Key:       "instance",
					Value:     strings.Join(ipList, "|"),
					Operation: "=~",
				},
			},
		}
	},
	DiskAvailEvery: func(ipList []string) *alarmv1alpha.ListPromQLsRequest {
		return &alarmv1alpha.ListPromQLsRequest{
			Name:            "server_disk_avail_every",
			ResourceSubType: "physicalServer",
			Labels: []*alarmv1alpha.Label{
				{
					Key:       "instance",
					Value:     strings.Join(ipList, "|"),
					Operation: "=~",
				},
			},
		}
	},
	CpuMode: func(ipList []string) *alarmv1alpha.ListPromQLsRequest {
		return &alarmv1alpha.ListPromQLsRequest{
			Name:            "server_cpu_mode",
			ResourceSubType: "physicalServer",
			Labels: []*alarmv1alpha.Label{
				{
					Key:       "instance",
					Value:     strings.Join(ipList, "|"),
					Operation: "=~",
				},
			},
		}
	},
	CpuNodeLoad1: func(ipList []string) *alarmv1alpha.ListPromQLsRequest {
		return &alarmv1alpha.ListPromQLsRequest{
			Name:            "cpu_node_load1",
			ResourceSubType: "physicalServer",
			Labels: []*alarmv1alpha.Label{
				{
					Key:       "instance",
					Value:     strings.Join(ipList, "|"),
					Operation: "=~",
				},
			},
		}
	},
	CpuNodeLoad5: func(ipList []string) *alarmv1alpha.ListPromQLsRequest {
		return &alarmv1alpha.ListPromQLsRequest{
			Name:            "cpu_node_load5",
			ResourceSubType: "physicalServer",
			Labels: []*alarmv1alpha.Label{
				{
					Key:       "instance",
					Value:     strings.Join(ipList, "|"),
					Operation: "=~",
				},
			},
		}
	},
	CpuNodeLoad15: func(ipList []string) *alarmv1alpha.ListPromQLsRequest {
		return &alarmv1alpha.ListPromQLsRequest{
			Name:            "cpu_node_load15",
			ResourceSubType: "physicalServer",
			Labels: []*alarmv1alpha.Label{
				{
					Key:       "instance",
					Value:     strings.Join(ipList, "|"),
					Operation: "=~",
				},
			},
		}
	},
	NodeMemoryFree: func(ipList []string) *alarmv1alpha.ListPromQLsRequest {
		return &alarmv1alpha.ListPromQLsRequest{
			Name:            "node_memory_free",
			ResourceSubType: "physicalServer",
			Labels: []*alarmv1alpha.Label{
				{
					Key:       "instance",
					Value:     strings.Join(ipList, "|"),
					Operation: "=~",
				},
			},
		}
	},
	NodeMemoryTotal: func(ipList []string) *alarmv1alpha.ListPromQLsRequest {
		return &alarmv1alpha.ListPromQLsRequest{
			Name:            "node_memory_total",
			ResourceSubType: "physicalServer",
			Labels: []*alarmv1alpha.Label{
				{
					Key:       "instance",
					Value:     strings.Join(ipList, "|"),
					Operation: "=~",
				},
			},
		}
	},
	NodeMemoryAvailable: func(ipList []string) *alarmv1alpha.ListPromQLsRequest {
		return &alarmv1alpha.ListPromQLsRequest{
			Name:            "node_memory_available",
			ResourceSubType: "physicalServer",
			Labels: []*alarmv1alpha.Label{
				{
					Key:       "instance",
					Value:     strings.Join(ipList, "|"),
					Operation: "=~",
				},
			},
		}
	},
	DiskReadBytes: func(ipList []string) *alarmv1alpha.ListPromQLsRequest {
		return &alarmv1alpha.ListPromQLsRequest{
			Name:            "disk_read_bytes",
			ResourceSubType: "physicalServer",
			Labels: []*alarmv1alpha.Label{
				{
					Key:       "instance",
					Value:     strings.Join(ipList, "|"),
					Operation: "=~",
				},
			},
		}
	},
	DiskWrittenBytes: func(ipList []string) *alarmv1alpha.ListPromQLsRequest {
		return &alarmv1alpha.ListPromQLsRequest{
			Name:            "disk_written_bytes",
			ResourceSubType: "physicalServer",
			Labels: []*alarmv1alpha.Label{
				{
					Key:       "instance",
					Value:     strings.Join(ipList, "|"),
					Operation: "=~",
				},
			},
		}
	},
	DiskReadIo: func(ipList []string) *alarmv1alpha.ListPromQLsRequest {
		return &alarmv1alpha.ListPromQLsRequest{
			Name:            "disk_read_io",
			ResourceSubType: "physicalServer",
			Labels: []*alarmv1alpha.Label{
				{
					Key:       "instance",
					Value:     strings.Join(ipList, "|"),
					Operation: "=~",
				},
			},
		}
	},
	DiskWriteIo: func(ipList []string) *alarmv1alpha.ListPromQLsRequest {
		return &alarmv1alpha.ListPromQLsRequest{
			Name:            "disk_write_io",
			ResourceSubType: "physicalServer",
			Labels: []*alarmv1alpha.Label{
				{
					Key:       "instance",
					Value:     strings.Join(ipList, "|"),
					Operation: "=~",
				},
			},
		}
	},
	NetworkCardList: func(ipList []string) *alarmv1alpha.ListPromQLsRequest {
		return &alarmv1alpha.ListPromQLsRequest{
			Name:            "network_card_list",
			ResourceSubType: "physicalServer",
			Labels: []*alarmv1alpha.Label{
				{
					Key:       "instance",
					Value:     strings.Join(ipList, "|"),
					Operation: "=~",
				},
			},
		}
	},
	IpmiUp: func(ipList []string) *alarmv1alpha.ListPromQLsRequest {
		return &alarmv1alpha.ListPromQLsRequest{
			Name:            "ipmi_up",
			ResourceSubType: "physicalServer",
			Labels: []*alarmv1alpha.Label{
				{
					Key:       "instance",
					Value:     strings.Join(ipList, "|"),
					Operation: "=",
				},
			},
		}
	},
	InTemp: func(ipList []string) *alarmv1alpha.ListPromQLsRequest {
		return &alarmv1alpha.ListPromQLsRequest{
			Name:            "in_temp",
			ResourceSubType: "physicalServer",
			Labels: []*alarmv1alpha.Label{
				{
					Key:       "instance",
					Value:     strings.Join(ipList, "|"),
					Operation: "=",
				},
			},
		}
	},
	OutTemp: func(ipList []string) *alarmv1alpha.ListPromQLsRequest {
		return &alarmv1alpha.ListPromQLsRequest{
			Name:            "out_temp",
			ResourceSubType: "physicalServer",
			Labels: []*alarmv1alpha.Label{
				{
					Key:       "instance",
					Value:     strings.Join(ipList, "|"),
					Operation: "=",
				},
			},
		}
	},
	IpmiSensorStateCpu: func(ipList []string) *alarmv1alpha.ListPromQLsRequest {
		return &alarmv1alpha.ListPromQLsRequest{
			Name:            "ipmi_sensor_state_cpu",
			ResourceSubType: "physicalServer",
			Labels: []*alarmv1alpha.Label{
				{
					Key:       "instance",
					Value:     strings.Join(ipList, "|"),
					Operation: "=",
				},
			},
		}
	},
	IpmiSensorStateMem: func(ipList []string) *alarmv1alpha.ListPromQLsRequest {
		return &alarmv1alpha.ListPromQLsRequest{
			Name:            "ipmi_sensor_state_mem",
			ResourceSubType: "physicalServer",
			Labels: []*alarmv1alpha.Label{
				{
					Key:       "instance",
					Value:     strings.Join(ipList, "|"),
					Operation: "=",
				},
			},
		}
	},
	IpmiSensorStatePower: func(ipList []string) *alarmv1alpha.ListPromQLsRequest {
		return &alarmv1alpha.ListPromQLsRequest{
			Name:            "ipmi_sensor_state_power",
			ResourceSubType: "physicalServer",
			Labels: []*alarmv1alpha.Label{
				{
					Key:       "instance",
					Value:     strings.Join(ipList, "|"),
					Operation: "=",
				},
			},
		}
	},
	IpmiSensorStateFan: func(ipList []string) *alarmv1alpha.ListPromQLsRequest {
		return &alarmv1alpha.ListPromQLsRequest{
			Name:            "ipmi_sensor_state_fan",
			ResourceSubType: "physicalServer",
			Labels: []*alarmv1alpha.Label{
				{
					Key:       "instance",
					Value:     strings.Join(ipList, "|"),
					Operation: "=",
				},
			},
		}
	},
	IpmiFanSpeedRpm: func(ipList []string) *alarmv1alpha.ListPromQLsRequest {
		return &alarmv1alpha.ListPromQLsRequest{
			Name:            "ipmi_fan_speed_rpm",
			ResourceSubType: "physicalServer",
			Labels: []*alarmv1alpha.Label{
				{
					Key:       "instance",
					Value:     strings.Join(ipList, "|"),
					Operation: "=",
				},
			},
		}
	},
	SwitchStatus: func(ipList []string) *alarmv1alpha.ListPromQLsRequest {
		return &alarmv1alpha.ListPromQLsRequest{
			Name:            "switch_status",
			ResourceSubType: "physicalSwitch",
			Labels: []*alarmv1alpha.Label{
				{
					Key:       "instance",
					Value:     strings.Join(ipList, "|"), //127.0.0.1:9100|127.0.0.2:9100
					Operation: "=~",
				},
			},
		}
	},
	SwitchCpuUsageRate: func(ipList []string) *alarmv1alpha.ListPromQLsRequest {
		return &alarmv1alpha.ListPromQLsRequest{
			Name:            "switch_cpu_usage_rate",
			ResourceSubType: "physicalSwitch",
			Labels: []*alarmv1alpha.Label{
				{
					Key:       "instance",
					Value:     strings.Join(ipList, "|"),
					Operation: "=",
				},
			},
		}
	},
	SwitchMemUsageRate: func(ipList []string) *alarmv1alpha.ListPromQLsRequest {
		return &alarmv1alpha.ListPromQLsRequest{
			Name:            "switch_mem_usage_rate",
			ResourceSubType: "physicalSwitch",
			Labels: []*alarmv1alpha.Label{
				{
					Key:       "instance",
					Value:     strings.Join(ipList, "|"),
					Operation: "=",
				},
			},
		}
	},
	DiskIoReadCount: func(ipList []string) *alarmv1alpha.ListPromQLsRequest {
		return &alarmv1alpha.ListPromQLsRequest{
			Name:            "disk_io_reads_count",
			ResourceSubType: "physicalServer",
			Labels: []*alarmv1alpha.Label{
				{
					Key:       "instance",
					Value:     strings.Join(ipList, "|"),
					Operation: "=~",
				},
			},
		}
	},
	DiskIoWriteCount: func(ipList []string) *alarmv1alpha.ListPromQLsRequest {
		return &alarmv1alpha.ListPromQLsRequest{
			Name:            "disk_io_writes_count",
			ResourceSubType: "physicalServer",
			Labels: []*alarmv1alpha.Label{
				{
					Key:       "instance",
					Value:     strings.Join(ipList, "|"),
					Operation: "=~",
				},
			},
		}
	},
	DiskIoReadDelay: func(ipList []string) *alarmv1alpha.ListPromQLsRequest {
		return &alarmv1alpha.ListPromQLsRequest{
			Name:            "disk_io_read_delay",
			ResourceSubType: "physicalServer",
			Labels: []*alarmv1alpha.Label{
				{
					Key:       "instance",
					Value:     strings.Join(ipList, "|"),
					Operation: "=~",
				},
			},
		}
	},
	DiskIoWriteDelay: func(ipList []string) *alarmv1alpha.ListPromQLsRequest {
		return &alarmv1alpha.ListPromQLsRequest{
			Name:            "disk_io_write_delay",
			ResourceSubType: "physicalServer",
			Labels: []*alarmv1alpha.Label{
				{
					Key:       "instance",
					Value:     strings.Join(ipList, "|"),
					Operation: "=~",
				},
			},
		}
	},
}

```

File path: /Users/mac/Desktop/woker_code/monitor/common/promql_template/server/native_template.go
```golang
package server

// GetCpuRateTop 获取CPU使用率Top
func GetCpuRateTop(topK, ips, t string) string {
	psql := `topk(` + topK + `,1-sum(avg_over_time(node_cpu_seconds_total{instance=~"(` + ips + `)",mode="idle"}[` + t + `]))by(instance,hostname)/sum(avg_over_time(node_cpu_seconds_total{instance=~"(` + ips + `)"}[` + t + `]))by(instance,hostname))`
	return psql
}

func GetCpuRateTopByHostName(topK, hostNames, t string) string {
	psql := `topk(` + topK + `, avg_over_time(instance:node_cpu_usage:rate10m{hostname=~"(` + hostNames + `)"}[` + t + `]))`
	return psql
}

func GetMemoryRateTopK(topK, ips, t string) string {
	param := `topk(` + topK + `,1-(avg_over_time(node_memory_MemAvailable_bytes{instance=~"(` + ips + `)"}[` + t + `]))/(avg_over_time(node_memory_MemTotal_bytes{instance=~"(` + ips + `)"}[` + t + `])))`
	return param
}

func GetDiskRateTopK(topK, ips, t string) string {
	param := `topk(` + topK + `,1 - sum(avg_over_time(node_filesystem_free_bytes{instance=~"(` + ips + `)",mountpoint=~"/vm_data|/|/boot",fstype!="rootfs"}[` + t + `]))by(instance,hostname) / sum(avg_over_time(node_filesystem_size_bytes{instance=~"(` + ips + `)",mountpoint=~"/vm_data|/|/boot",fstype!="rootfs"}[` + t + `]))by(instance,hostname))`
	return param
}

func GetNetworkReceiveRateTopK(topK, ips, t string) string {
	param := `topk(` + topK + `,sum(avg_over_time(node_network_receive_bytes_total{instance=~"(` + ips + `)",device=~"(?i)^(en|eth).+$"}[` + t + `]))by(instance,hostname))`
	return param
}

func GetNetworkTransmitRateTopK(topK, ips, t string) string {
	param := `topk(` + topK + `,sum(avg_over_time(node_network_transmit_bytes_total{instance=~"(` + ips + `)",device=~"(?i)^(en|eth).+$"}[` + t + `]))by(instance,hostname))`
	return param
}

func GetSwitchCpuRateTop(topK, ips, t string) string {
	psql := `topk(` + topK + `, avg_over_time(cpuUsageRate{instance=~"` + ips + `"}[` + t + `]))`
	return psql
}

func GetSwitchMemRateTop(topK, ips, t string) string {
	psql := `topk(` + topK + `, avg_over_time(memoryUsageRate{instance=~"` + ips + `"}[` + t + `]))`
	return psql
}

func SwitchInterfaceOutDropRates(ips, ifIndex, t string) string {
	param := `rate(ifOutDiscards{instance=~"` + ips + `",ifIndex=~"` + ifIndex + `"}[` + t + `]) / rate(ifHCOutUcastPkts{instance=~"` + ips + `",ifIndex=~"` + ifIndex + `"}[` + t + `])`
	return param
}

func SwitchInterfaceInDropRates(ips, ifIndex, t string) string {
	param := `rate(ifInDiscards{instance=~"` + ips + `",ifIndex=~"` + ifIndex + `"}[` + t + `]) / rate(ifHCInUcastPkts{instance=~"` + ips + `",ifIndex=~"` + ifIndex + `"}[` + t + `])`
	return param
}

func SwitchInterfaceOutErrRates(ips, ifIndex, t string) string {
	param := `rate(ifOutErrors{instance=~"` + ips + `",ifIndex=~"` + ifIndex + `"}[` + t + `]) / rate(ifHCOutUcastPkts{instance=~"` + ips + `",ifIndex=~"` + ifIndex + `"}[` + t + `])`
	return param
}

// rate(ifHCOutOctets{instance="10.177.60.15"}[30m])/((ifHighSpeed{instance="10.177.60.15"}) * 1024 * 1024 / 8 )
func SwitchInterfaceInErrRates(ips, ifIndex, t string) string {
	param := `rate(ifInErrors{instance=~"` + ips + `",ifIndex=~"` + ifIndex + `"}[` + t + `]) / rate(ifHCInUcastPkts{instance=~"` + ips + `",ifIndex=~"` + ifIndex + `"}[` + t + `])`
	return param
}

// ifHCOutOctets 单位字节(Bytes)
// ifHighSpeed 单位字节(Mbit/s)
func SwitchInterfaceBandOutRates(ips, ifIndex, t string) string {
	param := `rate(ifHCOutOctets{instance=~"` + ips + `",ifIndex=~"` + ifIndex + `"}[` + t + `])/(ifHighSpeed{instance=~"` + ips + `",ifIndex=~"` + ifIndex + `"}/8*1024*1024)`
	return param
}

func SwitchInterfaceBandInRates(ips, ifIndex, t string) string {
	param := `rate(ifHCInOctets{instance=~"` + ips + `",ifIndex=~"` + ifIndex + `"}[` + t + `])/(ifHighSpeed{instance=~"` + ips + `",ifIndex=~"` + ifIndex + `"}/8*1024*1024)`
	return param
}

func SwitchInterfaceInErrNum(ips, ifIndex, t string) string {
	param := `rate(ifInErrors{instance=~"` + ips + `",ifIndex=~"` + ifIndex + `"}[` + t + `])`
	return param
}

func SwitchInterfaceOutErrNum(ips, ifIndex, t string) string {
	param := `rate(ifOutErrors{instance=~"` + ips + `",ifIndex=~"` + ifIndex + `"}[` + t + `])`
	return param
}

func SwitchInterfaceInDropNum(ips, ifIndex, t string) string {
	param := `rate(ifInDiscards{instance=~"` + ips + `",ifIndex=~"` + ifIndex + `"}[` + t + `])`
	return param
}

func SwitchInterfaceOutDropNum(ips, ifIndex, t string) string {
	param := `rate(ifOutDiscards{instance=~"` + ips + `",ifIndex=~"` + ifIndex + `"}[` + t + `])`
	return param
}

func SwitchInterfaceInFlow(ips, ifIndex, t string) string {
	param := `rate(ifHCInOctets{instance=~"` + ips + `",ifIndex=~"` + ifIndex + `"}[` + t + `])`
	return param
}

func SwitchInterfaceOutFlow(ips, ifIndex, t string) string {
	param := `rate(ifHCOutOctets{instance=~"` + ips + `",ifIndex=~"` + ifIndex + `"}[` + t + `])`
	return param
}

```

File path: /Users/mac/Desktop/woker_code/monitor/common/promql_template/compute/template.go
```golang
package compute

import (
	alarmv1alpha "ezone.ksyun.com/ezone/luban/luban_api/alarmapis/alarm/v1alpha/gen"
)

const (
	VCpuStock   = "vcpu_stock"
	MemoryStock = "memory_stock"
	CpuRate     = "cpu_usage_rate"
	MemoryRate  = "memory_usage_rate"
	DiskRate    = "disk_usage_rate"
)

type computeReqFunc func(region string, az string, poolName string) *alarmv1alpha.ListPromQLsRequest

var TemplateMap = map[string]computeReqFunc{
	VCpuStock: func(region string, az string, poolName string) *alarmv1alpha.ListPromQLsRequest {
		return &alarmv1alpha.ListPromQLsRequest{
			Name:            "vcpu_stock",
			ResourceSubType: "kec",
			Labels: []*alarmv1alpha.Label{
				{
					Key:       "region",
					Value:     region,
					Operation: "=",
				},
				{
					Key:       "az",
					Value:     az,
					Operation: "=",
				},
				{
					Key:       "resource_pool",
					Value:     poolName,
					Operation: "=",
				},
			},
		}
	},
	MemoryStock: func(region string, az string, poolName string) *alarmv1alpha.ListPromQLsRequest {
		return &alarmv1alpha.ListPromQLsRequest{
			Name:            "memory_stock",
			ResourceSubType: "kec",
			Labels: []*alarmv1alpha.Label{
				{
					Key:       "region",
					Value:     region,
					Operation: "=",
				},
				{
					Key:       "az",
					Value:     az,
					Operation: "=",
				},
				{
					Key:       "resource_pool",
					Value:     poolName,
					Operation: "=",
				},
			},
		}
	},
	CpuRate: func(region string, az string, poolName string) *alarmv1alpha.ListPromQLsRequest {
		return &alarmv1alpha.ListPromQLsRequest{
			Name:            "cpu_usage_rate",
			ResourceSubType: "kec",
			Labels: []*alarmv1alpha.Label{
				{
					Key:       "resource_pool",
					Value:     poolName,
					Operation: "=",
				},
			},
		}
	},
	MemoryRate: func(region string, az string, poolName string) *alarmv1alpha.ListPromQLsRequest {
		return &alarmv1alpha.ListPromQLsRequest{
			Name:            "memory_usage_rate",
			ResourceSubType: "kec",
			Labels: []*alarmv1alpha.Label{
				{
					Key:       "resource_pool",
					Value:     poolName,
					Operation: "=",
				},
			},
		}
	},
	DiskRate: func(region string, az string, poolName string) *alarmv1alpha.ListPromQLsRequest {
		return &alarmv1alpha.ListPromQLsRequest{
			Name:            "disk_usage_rate",
			ResourceSubType: "kec",
			Labels: []*alarmv1alpha.Label{
				{
					Key:       "resource_pool",
					Value:     poolName,
					Operation: "=",
				},
			},
		}
	},
}

```

File path: /Users/mac/Desktop/woker_code/monitor/common/promql_template/compute/native_template.go
```golang
package compute

// 预测库存
func GetPredictVCpuStock(resourcePool, resourcePoolType, t, tt string) string {
	psql := `avg without (pod, instance) (predict_linear(aggregate_vcpu_remain_count{resource_pool = "` + resourcePool + `",resource_pool_type="` + resourcePoolType + `"}[` + t + `],` + tt + `))`
	return psql
}

func GetPredictMemoryStock(resourcePool, resourcePoolType, t, tt string) string {
	psql := `avg without (pod, instance) (predict_linear(aggregate_memory_remain_count{resource_pool = "` + resourcePool + `",resource_pool_type="` + resourcePoolType + `"}[` + t + `],` + tt + `))`
	return psql
}

```

File path: /Users/mac/Desktop/woker_code/monitor/common/promql_template/db/template.go
```golang
package db

import (
	alarmv1alpha "ezone.ksyun.com/ezone/luban/luban_api/alarmapis/alarm/v1alpha/gen"
)

const (
	CpuUsage            = "cpu_usage"
	MemoryUsage         = "memory_usage"
	DiskUsage           = "disk_usage"
	DbVcpuRemainCount   = "db_vcpu_remain_count"
	DbMemoryRemainCount = "db_memory_remain_count"
	DbDiskRemainCount   = "db_disk_remain_count"
)

type dbReqFunc func(region, az, resourcePool, resourcePoolType string) *alarmv1alpha.ListPromQLsRequest

var TemplateMap = map[string]dbReqFunc{
	DbVcpuRemainCount: func(region, az, resourcePool, resourcePoolType string) *alarmv1alpha.ListPromQLsRequest {
		return &alarmv1alpha.ListPromQLsRequest{
			Name:            "db_vcpu_remain_count",
			ResourceSubType: "rds",
			Labels: []*alarmv1alpha.Label{
				{
					Key:       "region",
					Value:     region,
					Operation: "=",
				},
				{
					Key:       "az",
					Value:     az,
					Operation: "=",
				},
				{
					Key:       "resource_pool",
					Value:     resourcePool,
					Operation: "=",
				},
				{
					Key:       "resource_pool_type",
					Value:     resourcePoolType,
					Operation: "=",
				},
			},
		}
	},
	DbMemoryRemainCount: func(region, az, resourcePool, resourcePoolType string) *alarmv1alpha.ListPromQLsRequest {
		return &alarmv1alpha.ListPromQLsRequest{
			Name:            "db_memory_remain_count",
			ResourceSubType: "rds",
			Labels: []*alarmv1alpha.Label{
				{
					Key:       "region",
					Value:     region,
					Operation: "=",
				},
				{
					Key:       "az",
					Value:     az,
					Operation: "=",
				},
				{
					Key:       "resource_pool",
					Value:     resourcePool,
					Operation: "=",
				},
				{
					Key:       "resource_pool_type",
					Value:     resourcePoolType,
					Operation: "=",
				},
			},
		}
	},
	DbDiskRemainCount: func(region, az, resourcePool, resourcePoolType string) *alarmv1alpha.ListPromQLsRequest {
		return &alarmv1alpha.ListPromQLsRequest{
			Name:            "db_disk_remain_count",
			ResourceSubType: "rds",
			Labels: []*alarmv1alpha.Label{
				{
					Key:       "region",
					Value:     region,
					Operation: "=",
				},
				{
					Key:       "az",
					Value:     az,
					Operation: "=",
				},
				{
					Key:       "resource_pool",
					Value:     resourcePool,
					Operation: "=",
				},
				{
					Key:       "resource_pool_type",
					Value:     resourcePoolType,
					Operation: "=",
				},
			},
		}
	},
	CpuUsage: func(region, az, resourcePool, resourcePoolType string) *alarmv1alpha.ListPromQLsRequest {
		return &alarmv1alpha.ListPromQLsRequest{
			Name:            "cpu_usage",
			ResourceSubType: "rds",
			Labels: []*alarmv1alpha.Label{
				{
					Key:       "region",
					Value:     region,
					Operation: "=",
				},
				//{
				//	Key:       "az",
				//	Value:     az,
				//	Operation: "=",
				//},
			},
			AssistedLabels: []*alarmv1alpha.Label{
				{
					Key:       "resource_pool",
					Value:     resourcePool,
					Operation: "=",
				},
				{
					Key:       "resource_pool_type",
					Value:     resourcePoolType,
					Operation: "=",
				},
			},
		}
	},
	MemoryUsage: func(region, az, resourcePool, resourcePoolType string) *alarmv1alpha.ListPromQLsRequest {
		return &alarmv1alpha.ListPromQLsRequest{
			Name:            "memory_usage",
			ResourceSubType: "rds",
			Labels: []*alarmv1alpha.Label{
				{
					Key:       "region",
					Value:     region,
					Operation: "=",
				},
				//{
				//	Key:       "az",
				//	Value:     az,
				//	Operation: "=",
				//},
			},
			AssistedLabels: []*alarmv1alpha.Label{
				{
					Key:       "resource_pool",
					Value:     resourcePool,
					Operation: "=",
				},
				{
					Key:       "resource_pool_type",
					Value:     resourcePoolType,
					Operation: "=",
				},
			},
		}
	},
	DiskUsage: func(region, az, resourcePool, resourcePoolType string) *alarmv1alpha.ListPromQLsRequest {
		return &alarmv1alpha.ListPromQLsRequest{
			Name:            "disk_usage",
			ResourceSubType: "rds",
			Labels: []*alarmv1alpha.Label{
				{
					Key:       "region",
					Value:     region,
					Operation: "=",
				},
				//{
				//	Key:       "az",
				//	Value:     az,
				//	Operation: "=",
				//},
			},
			AssistedLabels: []*alarmv1alpha.Label{
				{
					Key:       "resource_pool",
					Value:     resourcePool,
					Operation: "=",
				},
				{
					Key:       "resource_pool_type",
					Value:     resourcePoolType,
					Operation: "=",
				},
			},
		}
	},
}

```

File path: /Users/mac/Desktop/woker_code/monitor/common/promql_template/db/native_template.go
```golang
package db

// GetPredictVCpuRemain 获取vcpu库存
func GetPredictVCpuRemain(resourcePool, resourcePoolType, t, tt string) string {
	psql := `predict_linear(db_vcpu_remain_count{resource_pool = "` + resourcePool + `",resource_pool_type="` + resourcePoolType + `"}[` + t + `],` + tt + `)`
	return psql
}

func GetPredictMemRemain(resourcePool, resourcePoolType, t, tt string) string {
	psql := `predict_linear(db_memory_remain_count{resource_pool = "` + resourcePool + `",resource_pool_type="` + resourcePoolType + `"}[` + t + `],` + tt + `)`
	return psql
}

func GetPredictDiskRemain(resourcePool, resourcePoolType, t, tt string) string {
	psql := `predict_linear(db_disk_remain_count{resource_pool = "` + resourcePool + `",resource_pool_type="` + resourcePoolType + `"}[` + t + `],` + tt + `)`
	return psql
}

```

File path: /Users/mac/Desktop/woker_code/monitor/common/utils/alert_count.go
```golang
package utils

import alarmv1alpha "ezone.ksyun.com/ezone/luban/luban_api/alarmapis/alarm/v1alpha/gen"

func CountAlertsNum(alerts []*alarmv1alpha.AlertInfo, poolTye, level string) int {
	var num int
	for _, alert := range alerts {
		if alert.ResourceSubType == poolTye && alert.Level == level {
			num++
		}
	}
	return num
}

func CountAlertsListNum(alerts []*alarmv1alpha.AlertInfo, resource_sub_type string) map[string]int {
	if alerts == nil || len(alerts) == 0 {
		return nil
	}
	res := make(map[string]int)
	for _, alt := range alerts {
		level := alt.Labels["level"]
		//只保留 p0  p1 p2 p3 级别告警
		if level != "p0" && level != "p1" && level != "p2" && level != "p3" {
			continue
		}
		//只保留gms告警策略创建出来的告警
		if alt.Labels["policy_id"] == "" {
			continue
		}
		var hostName string
		if resource_sub_type == "physicalServer" || resource_sub_type == "physicalSwitch" { //服务器 交换机
			hostName = alt.Labels["hostname"]
		}
		if ins, ok := res[hostName]; ok {
			res[hostName] = ins + 1
		} else {
			res[hostName] = 1
		}

	}
	return res
}

```

File path: /Users/mac/Desktop/woker_code/monitor/common/utils/page.go
```golang
package utils

func Paginate(data []interface{}, pageSize int, PageNo int) []interface{} {
	//-1不分页，返回全部
	if pageSize == -1 {
		return data
	}

	startIndex := (PageNo - 1) * pageSize
	endIndex := PageNo * pageSize
	if endIndex > len(data) {
		endIndex = len(data)
	}
	return data[startIndex:endIndex]
}

// 定义一个通用的结构体
type Bucket struct {
	Slice []interface{}               //承载以任意结构体为元素构成的Slice
	By    func(a, b interface{}) bool //排序规则函数,当需要对新的结构体slice进行排序时，只需定义这个函数即可
}

/*
定义三个必须方法的准则：接收者不能为指针
*/
func (this Bucket) Len() int { return len(this.Slice) }

func (this Bucket) Swap(i, j int) { this.Slice[i], this.Slice[j] = this.Slice[j], this.Slice[i] }

func (this Bucket) Less(i, j int) bool { return this.By(this.Slice[i], this.Slice[j]) }

```

File path: /Users/mac/Desktop/woker_code/monitor/common/utils/gosafe.go
```golang
package utils

import (
	"bytes"
	"fmt"
	"k8s.io/klog/v2"
	"runtime"
	"runtime/debug"
	"strconv"
)

// GoSafe runs the given fn using another goroutine, recovers if fn panics.
func GoSafe(fn func()) {
	go RunSafe(fn)
}

// RoutineId is only for debug, never use it in production.
func RoutineId() uint64 {
	b := make([]byte, 64)
	b = b[:runtime.Stack(b, false)]
	b = bytes.TrimPrefix(b, []byte("goroutine "))
	b = b[:bytes.IndexByte(b, ' ')]
	// if error, just return 0
	n, _ := strconv.ParseUint(string(b), 10, 64)

	return n
}

// RunSafe runs the given fn, recovers if fn panics.
func RunSafe(fn func()) {
	defer Recover()

	fn()
}

// Recover is used with defer to do cleanup on panics.
// Use it like:
//
//	defer Recover(func() {})
func Recover(cleanups ...func()) {
	for _, cleanup := range cleanups {
		cleanup()
	}

	if p := recover(); p != nil {
		klog.Error(fmt.Sprintf("%s\n%s", p, string(debug.Stack())))
	}
}

```

File path: /Users/mac/Desktop/woker_code/monitor/common/utils/page_test.go
```golang
package utils

import (
	"reflect"
	"testing"
)

func TestPaginate(t *testing.T) {
	data := []interface{}{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}

	// Positive test case
	pageSize := 3
	pageNo := 2
	expected := []interface{}{4, 5, 6}
	result := Paginate(data, pageSize, pageNo)
	if !reflect.DeepEqual(result, expected) {
		t.Errorf("Expected %v, but got %v", expected, result)
	}

	// Boundary test case
	pageSize = 5
	pageNo = 1
	expected = []interface{}{1, 2, 3, 4, 5}
	result = Paginate(data, pageSize, pageNo)
	if !reflect.DeepEqual(result, expected) {
		t.Errorf("Expected %v, but got %v", expected, result)
	}

	// Edge test case
	pageSize = 2
	pageNo = 6
	expected = []interface{}{}
	result = Paginate(data, pageSize, pageNo)
	if !reflect.DeepEqual(result, expected) {
		t.Errorf("Expected %v, but got %v", expected, result)
	}

	// Test case for pageSize = -1
	pageSize = -1
	pageNo = 1
	expected = []interface{}{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}
	result = Paginate(data, pageSize, pageNo)
	if !reflect.DeepEqual(result, expected) {
		t.Errorf("Expected %v, but got %v", expected, result)
	}
}

```

File path: /Users/mac/Desktop/woker_code/monitor/common/lang/lang.go
```golang
package lang

// Placeholder is a placeholder object that can be used globally.
var Placeholder PlaceholderType

type (
	// AnyType can be used to hold any type.
	AnyType = interface{}
	// PlaceholderType represents a placeholder type.
	PlaceholderType = struct{}
)

```

File path: /Users/mac/Desktop/woker_code/monitor/common/gormSerializer/jsonserializer.go
```golang
package gormSerializer

import (
	"context"
	"encoding/json"
	"fmt"
	"gorm.io/gorm/schema"
	"reflect"
)

// JSONSerializer json序列化器
type JSONSerializer struct {
}

// 实现 Scan 方法
func (JSONSerializer) Scan(ctx context.Context, field *schema.Field, dst reflect.Value, dbValue interface{}) (err error) {
	fieldValue := reflect.New(field.FieldType)

	if dbValue != nil {
		var bytes []byte
		switch v := dbValue.(type) {
		case []byte:
			bytes = v
		case string:
			bytes = []byte(v)
		default:
			return fmt.Errorf("failed to unmarshal JSONB value: %#v", dbValue)
		}

		err = json.Unmarshal(bytes, fieldValue.Interface())
	}

	field.ReflectValueOf(ctx, dst).Set(fieldValue.Elem())
	return
}

// 实现 Value 方法
func (JSONSerializer) Value(ctx context.Context, field *schema.Field, dst reflect.Value, fieldValue interface{}) (interface{}, error) {
	return json.Marshal(fieldValue)
}

```

File path: /Users/mac/Desktop/woker_code/monitor/common/paging/paging.go
```golang
package paging

import (
	"github.com/jinzhu/gorm"
)

// Pagination 存储分页结果
type Pagination struct {
	Total       int         // 总记录数
	PerPage     int         // 每页记录数
	CurrentPage int         // 当前页码
	LastPage    int         // 最后一页页码
	Data        interface{} // 数据
}

// Paginate 分页查询方法
func Paginate(db *gorm.DB, model interface{}, page int, perPage int) (*Pagination, error) {
	var count int
	err := db.Model(model).Count(&count).Error
	if err != nil {
		return nil, err
	}

	offset := (page - 1) * perPage
	err = db.Model(model).Offset(offset).Limit(perPage).Find(model).Error
	if err != nil {
		return nil, err
	}

	lastPage := int(count/perPage) + 1
	pagination := &Pagination{
		Total:       count,
		PerPage:     perPage,
		CurrentPage: page,
		LastPage:    lastPage,
		Data:        model,
	}

	return pagination, nil
}

```

File path: /Users/mac/Desktop/woker_code/monitor/common/version/version.go
```golang
package version

import "fmt"

var (
	Version   = "v0.1.0"
	GitHash   = "unknown"
	BuildTime = "unknown"
	GoVersion = "unknown"
)

func Info() string {
	return fmt.Sprintf("Version: %s\nGitHash: %s\nBuildTime: %s\nGoVersion: %s\n", Version, GitHash, BuildTime, GoVersion)
}

```

File path: /Users/mac/Desktop/woker_code/monitor/common/job/switch/fan_job.go
```golang
package _switch

```

File path: /Users/mac/Desktop/woker_code/monitor/common/tsdbql_template/types.go
```golang
package tsdbql_template

import "strings"

type TsdbQuery struct {
	Metric  string `json:"metric"`
	HostTag string `json:"host_tag"`
}

func ParseTsdbQuery(productLine, metricPrefix, id string) TsdbQuery {
	//ksceip--024561cc-b2e8-48d9-bee4-fec9486471b8
	hostTag := productLine + "--" + id
	if productLine == "ksckcs2" {
		hostTag = productLine + "-" + id
	}
	if productLine == "ksclb" {
		hostTag = productLine + "---" + id
	}
	if productLine == "kec" || productLine == "ebs" {
		hostTag = id
	}
	//eip.bps.in.ksceip--024561cc-b2e8-48d9-bee4-fec9486471b8
	fullMetric := metricPrefix + "." + hostTag
	//fmt.Printf("OpenTSDB Meric DEBUG: fullMetric: %s\n", fullMetric)
	return TsdbQuery{
		Metric:  fullMetric,
		HostTag: hostTag,
	}
}

func GetInstanceIdFromHostTag(hostTag string) string {
	//ksceip--024561cc-b2e8-48d9-bee4-fec9486471b8
	if strings.Index(hostTag, "---") != -1 {
		return strings.Split(hostTag, "ksclb---")[1]
	}
	if strings.Index(hostTag, "--") != -1 {
		return strings.Split(hostTag, "--")[1]
	}
	if strings.Index(hostTag, "ksckcs2-") != -1 {
		return strings.Split(hostTag, "ksckcs2-")[1]
	}
	return hostTag
}

```

File path: /Users/mac/Desktop/woker_code/monitor/common/tsdbql_template/redis/redis.go
```golang
package redis

const (
	Redis_cpu_load           = "redis_cpu_load"
	Redis_memory_load        = "redis_memory_load"
	Redis_intranet_in_ratio  = "redis_intranet_in_ratio"
	Redis_intranet_out_ratio = "redis_intranet_out_ratio"
	Redis_connection_usage   = "redis_connection_usage"
	Redis_hit_rate           = "redis_hit_rate"
	Redis_slowlog_len        = "redis_slowlog_len"
)

```

File path: /Users/mac/Desktop/woker_code/monitor/common/tsdbql_template/object_volume/object_volume.go
```golang
package object_volume

const (
	ObjectVolumeBandReadKs3     = "ebs_volume_band_read_ks3"
	ObjectVolumeBandWriteKs3    = "ebs_volume_band_write_ks3"
	ObjectVolumeIOReadKs3       = "ebs_volume_io_read_ks3"
	ObjectVolumeIOWriteKs3      = "ebs_volume_io_write_ks3"
	ObjectVolumeIOReadDelayKs3  = "ebs_volume_io_read_delay_ks3"
	ObjectVolumeIOWriteDelayKs3 = "ebs_volume_io_write_delay_ks3"

	ObjectVolumeBandReadObs     = "ebs_volume_band_read_obs"
	ObjectVolumeBandWriteObs    = "ebs_volume_band_write_obs"
	ObjectVolumeIOReadObs       = "ebs_volume_io_read_obs"
	ObjectVolumeIOWriteObs      = "ebs_volume_io_write_obs"
	ObjectVolumeIOReadDelayObs  = "ebs_volume_io_read_delay_obs"
	ObjectVolumeIOWriteDelayObs = "ebs_volume_io_write_delay_obs"
)

var ObjectVolumeTopKs3Metrics = []string{
	ObjectVolumeBandReadKs3,
	ObjectVolumeBandWriteKs3,
	ObjectVolumeIOReadKs3,
	ObjectVolumeIOWriteKs3,
}

var ObjectVolumeTopObsMetrics = []string{
	ObjectVolumeBandReadObs,
	ObjectVolumeBandWriteObs,
	ObjectVolumeIOReadObs,
	ObjectVolumeIOWriteObs,
}

type TsdbQuery struct {
	Metric string            `json:"metric"`
	Tags   map[string]string `json:"Tag"`
}

func ParseTsdbQuery(code, metricPrefix, id string) TsdbQuery {
	fullMetric := metricPrefix + "." + id
	tags := make(map[string]string)
	switch code {
	case ObjectVolumeBandReadKs3, ObjectVolumeBandWriteKs3, ObjectVolumeBandReadObs, ObjectVolumeBandWriteObs:
		tags = map[string]string{
			"host": id,
			"p1":   "vda", // 以挂盘区分
		}
	case ObjectVolumeIOReadKs3, ObjectVolumeIOWriteKs3, ObjectVolumeIOReadObs, ObjectVolumeIOWriteObs:
		tags = map[string]string{
			"host": id,
			"p1":   "vda",
		}
	case ObjectVolumeIOReadDelayKs3, ObjectVolumeIOWriteDelayKs3, ObjectVolumeIOReadDelayObs, ObjectVolumeIOWriteDelayObs:
		tags = map[string]string{
			"host": id,
			"p1":   "vda",
		}
	}
	return TsdbQuery{
		Metric: fullMetric,
		Tags:   tags,
	}
}

```

File path: /Users/mac/Desktop/woker_code/monitor/common/tsdbql_template/nat/nat.go
```golang
package nat

const (
	Nat_bps_in                 = "nat_bps_in"
	Nat_bps_out                = "nat_bps_out"
	Nat_public_bps_in          = "nat_public_bps_in"
	Nat_public_bps_out         = "nat_public_bps_out"
	Nat_pps_in                 = "nat_pps_in"
	Nat_pps_out                = "nat_pps_out"
	Nat_public_pps_in          = "nat_public_pps_in"
	Nat_public_pps_out         = "nat_public_pps_out"
	Nat_public_utilization_in  = "nat_public_utilization_in"
	Nat_public_utilization_out = "nat_public_utilization_out"
	Nat_ipconflict             = "nat_ipconflict"
)

```

File path: /Users/mac/Desktop/woker_code/monitor/common/tsdbql_template/lb/lb.go
```golang
package lb

const (
	Lb_flow_in        = "lb_flow_in"
	Lb_flow_out       = "lb_flow_out"
	Lb_pps_in         = "lb_pps_in"
	Lb_pps_out        = "lb_pps_out"
	Lb_cps            = "lb_cps"
	Lb_activeconn     = "lb_activeconn"
	Lb_concurrentconn = "lb_concurrentconn"
	Lb_inactiveconn   = "lb_inactiveconn"
)

```

File path: /Users/mac/Desktop/woker_code/monitor/common/tsdbql_template/ebs_volume/ebs_volume.go
```golang
package ebs_volume

const (
	EbsVolumeBandReadEhdd     = "ebs_volume_band_read_ehdd"
	EbsVolumeBandWriteEhdd    = "ebs_volume_band_write_ehdd"
	EbsVolumeIOReadEhdd       = "ebs_volume_io_read_ehdd"
	EbsVolumeIOWriteEhdd      = "ebs_volume_io_write_ehdd"
	EbsVolumeIOReadDelayEhdd  = "ebs_volume_io_read_delay_ehdd"
	EbsVolumeIOWriteDelayEhdd = "ebs_volume_io_write_delay_ehdd"

	EbsVolumeBandReadSSD     = "ebs_volume_band_read_ssd3.0"
	EbsVolumeBandWriteSSD    = "ebs_volume_band_write_ssd3.0"
	EbsVolumeIOReadSSD       = "ebs_volume_io_read_ssd3.0"
	EbsVolumeIOWriteSSD      = "ebs_volume_io_write_ssd3.0"
	EbsVolumeIOReadDelaySSD  = "ebs_volume_io_read_delay_ssd3.0"
	EbsVolumeIOWriteDelaySSD = "ebs_volume_io_write_delay_ssd3.0"
)

var EbsVolumeTopEhddMetrics = []string{
	EbsVolumeBandReadEhdd,
	EbsVolumeBandWriteEhdd,
	EbsVolumeIOReadEhdd,
	EbsVolumeIOWriteEhdd,
	EbsVolumeIOReadDelayEhdd,
	EbsVolumeIOWriteDelayEhdd,
}

var EbsVolumeTopSSDMetrics = []string{
	EbsVolumeBandReadSSD,
	EbsVolumeBandWriteSSD,
	EbsVolumeIOReadSSD,
	EbsVolumeIOWriteSSD,
	EbsVolumeIOReadDelaySSD,
	EbsVolumeIOWriteDelaySSD,
}

type TsdbQuery struct {
	Metric string            `json:"metric"`
	Tags   map[string]string `json:"Tag"`
}

func ParseTsdbQuery(code, metricPrefix, id string) TsdbQuery {
	fullMetric := metricPrefix + "." + id
	tags := make(map[string]string)
	switch code {
	case EbsVolumeBandReadEhdd, EbsVolumeBandWriteEhdd, EbsVolumeBandReadSSD, EbsVolumeBandWriteSSD:
		tags = map[string]string{
			"host": id,
			"p1":   "vda", // 以挂盘区分
		}
	case EbsVolumeIOReadEhdd, EbsVolumeIOWriteEhdd, EbsVolumeIOReadSSD, EbsVolumeIOWriteSSD:
		tags = map[string]string{
			"host": id,
			"p1":   "vda",
		}
	case EbsVolumeIOReadDelayEhdd, EbsVolumeIOWriteDelayEhdd, EbsVolumeIOReadDelaySSD, EbsVolumeIOWriteDelaySSD:
		tags = map[string]string{
			"host": id,
			"p1":   "vda",
		}
	}
	return TsdbQuery{
		Metric: fullMetric,
		Tags:   tags,
	}
}

```

File path: /Users/mac/Desktop/woker_code/monitor/common/tsdbql_template/vm/vm.go
```golang
package vm

const (
	CpuLoad         = "vm_cpu_load"
	MemoryLoad      = "vm_memory_load"
	DiskLoad        = "vm_disk_load"
	DiskFree        = "vm_disk_free"
	NetIn           = "vm_net_in"
	NetOut          = "vm_net_out"
	CpuModeSystem   = "vm_cpu_mode_system"
	CpuModeUser     = "vm_cpu_mode_user"
	CpuModeSoftIrq  = "vm_cpu_mode_soft_irq"
	CpuModeIrq      = "vm_cpu_mode_irq"
	CpuModeIOWait   = "vm_cpu_mode_io_wait"
	CpuModeIdle     = "vm_cpu_mode_idle"
	CpuModeNice     = "vm_cpu_mode_nice"
	CpuModeSteal    = "vm_cpu_mode_steal"
	MemorySizeTotal = "vm_memory_size_total"
	MemorySizeFree  = "vm_memory_size_free"
	NetReceive      = "vm_net_receive"
	NetTransmit     = "vm_net_transmit"
	NetPacketIn     = "vm_net_packet_in"
	NetPacketOut    = "vm_net_packet_out"
	DiskUsedRate    = "vm_disk_used_rate"
	DiskReadBps     = "vm_disk_read_bps"
	DiskWriteBps    = "vm_disk_write_bps"
	DiskReadOps     = "vm_disk_read_ops"
	DiskWriteOps    = "vm_disk_write_ops"
)

var VmTopMetrics = []string{
	CpuLoad,
	MemoryLoad,
	DiskLoad,
	NetIn,
	NetOut,
}

type TsdbQuery struct {
	Metric string            `json:"metric"`
	Tags   map[string]string `json:"Tag"`
}

func ParseTsdbQuery(code, metricPrefix, id string) TsdbQuery {
	fullMetric := metricPrefix + "." + id
	tags := make(map[string]string)
	switch code {
	case CpuLoad, MemoryLoad: // CPU 内存
		tags = map[string]string{
			"host": id,
		}
	case DiskLoad: // 磁盘
		tags = map[string]string{
			"host": id,
			"p1":   "/",
			"p2":   "pused",
		}
	case DiskFree:
		tags = map[string]string{
			"host": id,
			"p1":   "/",
			"p2":   "free",
		}
	case NetIn, NetOut, NetReceive, NetTransmit: // 网卡
		tags = map[string]string{
			"host": id,
			"p1":   "eth0", // 暂时写eth0 后面优化
		}
	case CpuModeSystem:
		tags = map[string]string{
			"host": id,
			"p1":   "all",
			"p2":   "system",
			"p3":   "avg1",
		}
	case CpuModeUser:
		tags = map[string]string{
			"host": id,
			"p1":   "all",
			"p2":   "user",
			"p3":   "avg1",
		}
	case CpuModeSoftIrq:
		tags = map[string]string{
			"host": id,
			"p1":   "all",
			"p2":   "softirq",
			"p3":   "avg1",
		}
	case CpuModeIrq:
		tags = map[string]string{
			"host": id,
			"p1":   "all",
			"p2":   "irq",
			"p3":   "avg1",
		}
	case CpuModeIOWait:
		tags = map[string]string{
			"host": id,
			"p1":   "all",
			"p2":   "iowait",
			"p3":   "avg1",
		}
	case CpuModeIdle:
		tags = map[string]string{
			"host": id,
			"p1":   "all",
			"p2":   "idle",
			"p3":   "avg1",
		}
	case CpuModeNice:
		tags = map[string]string{
			"host": id,
			"p1":   "all",
			"p2":   "nice",
			"p3":   "avg1",
		}
	case CpuModeSteal:
		tags = map[string]string{
			"host": id,
			"p1":   "all",
			"p2":   "steal",
			"p3":   "avg1",
		}
	case MemorySizeTotal:
		tags = map[string]string{
			"host": id,
			"p1":   "total",
		}
	case MemorySizeFree:
		tags = map[string]string{
			"host": id,
			"p1":   "free",
		}
	case NetPacketIn, NetPacketOut:
		tags = map[string]string{
			"host": id,
			"p1":   "eth0",
			"p2":   "packets",
		}
	case DiskReadBps, DiskWriteBps:
		tags = map[string]string{
			"host": id,
			"p1":   "vda", // 以挂盘区分
		}
	case DiskReadOps, DiskWriteOps:
		tags = map[string]string{
			"host": id,
			"p1":   "vda",
		}
	}

	return TsdbQuery{
		Metric: fullMetric,
		Tags:   tags,
	}
}

```

File path: /Users/mac/Desktop/woker_code/monitor/common/tsdbql_template/mysql/mysql.go
```golang
package mysql

const (
	Mysql_cpu_used_percent    = "mysql_cpu_used_percent"
	Mysql_memory_used_percent = "mysql_memory_used_percent"
	Mysql_riops               = "mysql_riops"
	Mysql_wiops               = "mysql_wiops"
	Mysql_threads_connected   = "mysql_threads_connected"
	Mysql_threads_running     = "mysql_threads_running"
	Mysql_bytes_received      = "mysql_bytes_received"
	Mysql_bytes_sent          = "mysql_bytes_sent"
	Mysql_qps                 = "mysql_qps"
	Mysql_tps                 = "mysql_tps"
)

```

File path: /Users/mac/Desktop/woker_code/monitor/common/tsdbql_template/eip/eip.go
```golang
package eip

const (
	Eip_band_rate_out = "eip_band_rate_out"
	Eip_band_rate_in  = "eip_band_rate_in"
	Eip_pps_out       = "eip_pps_out"
	Eip_pps_in        = "eip_pps_in"
	Eip_flow_out      = "eip_flow_out"
	Eip_flow_in       = "eip_flow_in"
)

var (
	Eip_top_metirc = []string{Eip_band_rate_out, Eip_band_rate_in, Eip_pps_out, Eip_pps_in, Eip_flow_out, Eip_flow_in}
)

```

File path: /Users/mac/Desktop/woker_code/monitor/common/init_conf/init.go
```golang
package init_conf

import (
	"log"
	"os"

	"ezone.ksyun.com/ezone/luban/communal/lib"
)

func init() {
	path, _ := os.Getwd()
	if err := lib.InitModuleYaml(path+"/conf/", []string{"base", "mysql", "redis"}); err != nil {
		log.Fatal(err)
	}
	//defer lib.Destroy() //销毁公共变量
}

```

File path: /Users/mac/Desktop/woker_code/monitor/common/structure/structure.go
```golang
package structure

import (
	"database/sql"
	"fmt"
	"strings"

	_ "github.com/go-sql-driver/mysql"
)

type TableColumn struct {
	Name     string
	DataType string
}

// ConvertTableToStruct 将MySQL表结构转换为结构体
func ConvertTableToStruct(db *sql.DB, tableName string) (string, error) {
	// 获取表结构信息
	columns, err := getTableColumns(db, tableName)
	if err != nil {
		return "", err
	}

	// 生成结构体定义
	structDefinition := generateStructDefinition(tableName, columns)
	return structDefinition, nil
}

// getTableColumns 获取表的列信息
func getTableColumns(db *sql.DB, tableName string) ([]TableColumn, error) {
	query := fmt.Sprintf("DESCRIBE %s", tableName)
	rows, err := db.Query(query)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var columns []TableColumn
	for rows.Next() {
		var column TableColumn
		err := rows.Scan(&column.Name, &column.DataType)
		if err != nil {
			return nil, err
		}
		columns = append(columns, column)
	}
	return columns, nil
}

// generateStructDefinition 生成结构体定义
func generateStructDefinition(tableName string, columns []TableColumn) string {
	structDefinition := fmt.Sprintf("type %s struct {\n", tableName)
	for _, column := range columns {
		structDefinition += fmt.Sprintf("\t%s %s\n", convertToCamelCase(column.Name), convertDataType(column.DataType))
	}
	structDefinition += "}"
	return structDefinition
}

// convertToCamelCase 转换列名为驼峰命名法
func convertToCamelCase(columnName string) string {
	parts := strings.Split(columnName, "_")
	for i := range parts {
		if i > 0 {
			parts[i] = strings.Title(parts[i])
		}
	}
	return strings.Join(parts, "")
}

// convertDataType 转换MySQL数据类型为Go语言数据类型
func convertDataType(dataType string) string {
	switch dataType {
	case "int":
		return "int"
	case "bigint":
		return "int64"
	case "float":
		return "float32"
	case "double":
		return "float64"
	case "varchar", "text":
		return "string"
	case "datetime", "timestamp":
		return "time.Time"
	default:
		return "interface{}"
	}
}

```

File path: /Users/mac/Desktop/woker_code/monitor/common/client/prom/trace.go
```golang
package prom

import (
	"context"
	"ezone.ksyun.com/ezone/luban/monitor/common/trace"
	"go.opentelemetry.io/otel/attribute"
	"go.opentelemetry.io/otel/codes"
	oteltrace "go.opentelemetry.io/otel/trace"
)

var promQlAttributeKey = attribute.Key("prom.ql")

func startSpan(ctx context.Context, ql string) (context.Context, oteltrace.Span) {
	tracer := trace.TracerFromContext(ctx)
	ctx, span := tracer.Start(ctx, "prometheus", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	span.SetAttributes(promQlAttributeKey.String(ql))

	return ctx, span
}

func endSpan(span oteltrace.Span, err error) {
	defer span.End()

	if err == nil {
		span.SetStatus(codes.Ok, "")
		return
	}

	span.SetStatus(codes.Error, err.Error())
	span.RecordError(err)
}

```

File path: /Users/mac/Desktop/woker_code/monitor/common/client/prom/redicted.go
```golang
package prom

import (
	"fmt"
	"github.com/pkg/errors"
	"github.com/prometheus/common/model"
	"math"
	"strconv"
)

func LinearPredictionWithPromValue(Values []model.SamplePair, interceptTime int64) (intercept float64, err error) {
	if len(Values) < 2 {
		return 0, errors.New("values length less than 2")
	}

	samples := []FPoint{}
	for _, v := range Values {
		samples = append(samples, FPoint{
			T: v.Timestamp.Unix(),
			F: float64(v.Value),
		})
	}
	_, intercept = linearRegression(samples, interceptTime)
	return intercept, nil

}

// from prometheus  https://github.com/prometheus/prometheus/blob/cef8aca8e8989ced6c1a493a3f3dd5e485206f92/promql/functions.go  965行
// FPoint represents a single float data point for a given timestamp.
type FPoint struct {
	T int64
	F float64
}

func (p FPoint) String() string {
	s := strconv.FormatFloat(p.F, 'f', -1, 64)
	return fmt.Sprintf("%s @[%v]", s, p.T)
}

func kahanSumInc(inc, sum, c float64) (newSum, newC float64) {
	t := sum + inc
	// Using Neumaier improvement, swap if next term larger than sum.
	if math.Abs(sum) >= math.Abs(inc) {
		c += (sum - t) + inc
	} else {
		c += (inc - t) + sum
	}
	return t, c
}

// linearRegression performs a least-square linear regression analysis on the
// provided SamplePairs. It returns the slope, and the intercept value at the
// provided time.
func linearRegression(samples []FPoint, interceptTime int64) (slope, intercept float64) {
	var (
		n          float64
		sumX, cX   float64
		sumY, cY   float64
		sumXY, cXY float64
		sumX2, cX2 float64
		initY      float64
		constY     bool
	)
	initY = samples[0].F
	constY = true
	for i, sample := range samples {
		// Set constY to false if any new y values are encountered.
		if constY && i > 0 && sample.F != initY {
			constY = false
		}
		n += 1.0
		x := float64(sample.T-interceptTime) / 1e3
		sumX, cX = kahanSumInc(x, sumX, cX)
		sumY, cY = kahanSumInc(sample.F, sumY, cY)
		sumXY, cXY = kahanSumInc(x*sample.F, sumXY, cXY)
		sumX2, cX2 = kahanSumInc(x*x, sumX2, cX2)
	}
	if constY {
		if math.IsInf(initY, 0) {
			return math.NaN(), math.NaN()
		}
		return 0, initY
	}
	sumX += cX
	sumY += cY
	sumXY += cXY
	sumX2 += cX2

	covXY := sumXY - sumX*sumY/n
	varX := sumX2 - sumX*sumX/n

	slope = covXY / varX
	intercept = sumY/n - slope*sumX/n
	return slope, intercept
}

```

File path: /Users/mac/Desktop/woker_code/monitor/common/client/prom/common.go
```golang
package prom

import (
	"github.com/prometheus/common/model"
	"math"
	"strings"
	"time"
)

// 一小时的毫秒数
const oneHourMsec = 3600 * 1000

// 一些公共处理逻辑的封装方法

// 根据查询时间段长度，确定采样率,避免返回数据点过多
// 用于线图类查询
func TimeToStep(duration int64) (step time.Duration) {
	if duration < 0 {
		return 0
	}
	if duration <= oneHourMsec { //0.5h/1h
		return 1 * time.Minute
	} else if duration <= (oneHourMsec * 3) { // 3h
		return 1 * time.Minute
	} else if duration <= (oneHourMsec * 24 * 7) { // 12h 24h 7d
		return 1 * time.Hour
	} else { // 30d
		return 24 * time.Hour
	}
}

// ip:up
type MonitorUpStatus map[string]string

// ParseServerMonitoringStatus 服务器监控状态解析
func ParseServerMonitoringStatus(up model.Vector) MonitorUpStatus {

	ipUpMap := make(MonitorUpStatus)
	flag := "down"
	if len(up) > 0 {
		for _, v := range up {
			if math.IsNaN(float64(v.Value)) {
				v.Value = 0
			}
			if float64(v.Value) == 1 {
				flag = "up"
			} else {
				flag = "down"
			}
			instance := v.Metric["instance"]
			ip := strings.Split(string(instance), ":")[0]
			ipUpMap[ip] = flag
		}
	}
	//fmt.Println(ipUpMap)
	return ipUpMap
}

// 解析1个metric的vector值
func ParseOneVectorValue(v model.Vector) float64 {
	if len(v) != 1 {
		return 0
	}
	if math.IsNaN(float64(v[0].Value)) {
		return 0
	}
	return float64(v[0].Value)
}

```

File path: /Users/mac/Desktop/woker_code/monitor/common/client/prom/default_client_test.go
```golang
package prom

import (
	"context"
	"fmt"
	v1 "github.com/prometheus/client_golang/api/prometheus/v1"
	"gonum.org/v1/gonum/stat"
	"testing"
	"time"
)

func TestQuery(t *testing.T) {
	result, err := VectorQuery(context.Background(), `avg by (instance)(up{instance=~"10.177.15.6:9100",namespace="monitoring"})`)
	if err != nil {
		fmt.Printf("Error querying Prometheus: %v\n", err)
	}
	fmt.Printf("type %s", result.Type())
	fmt.Printf("Result:\n%+v\n", result)
}

func TestQueryRange(t *testing.T) {
	r := v1.Range{
		Start: time.Now().Add(-time.Hour),
		End:   time.Now(),
		Step:  time.Minute,
	}
	result, err := MatrixQuery(context.Background(), `rate(prometheus_tsdb_head_samples_appended_total[5m])`, r)
	if err != nil {
		fmt.Printf("Error querying Prometheus: %v\n", err)
	}
	fmt.Printf("type %s", result.Type())
	fmt.Printf("Result:\n%+v\n", result)
}

func TestPredictLinear(t *testing.T) {
	r := v1.Range{
		Start: time.Now().Add(-time.Hour),
		End:   time.Now(),
		Step:  time.Minute,
	}
	//最近5m数据,预测1h之后的数据
	result, err := MatrixQuery(context.Background(), `predict_linear(prometheus_tsdb_head_samples_appended_total[5m], 3600)`, r)
	if err != nil {
		fmt.Printf("Error querying Prometheus: %v\n", err)
	}
	fmt.Printf("type %s", result.Type())
	fmt.Printf("Result:\n%+v\n", result[0].Values[0])
}

func TestPredictLinearMy(t *testing.T) {
	r := v1.Range{
		Start: time.Now().Add(-time.Hour),
		End:   time.Now(),
		Step:  time.Minute,
	}
	//最近5m数据,预测1h之后的数据
	result, err := MatrixQuery(context.Background(), `predict_linear(prometheus_tsdb_head_samples_appended_total[1h], 3600)`, r)
	if err != nil {
		fmt.Printf("Error querying Prometheus: %v\n", err)
	}
	fmt.Printf("type %s", result.Type())
	fmt.Printf("Result:\n%+v\n", result[0])

	fmt.Printf("predict_linear:\n%+v\n", result[0].Values[0])

	result, err = MatrixQuery(context.Background(), `prometheus_tsdb_head_samples_appended_total`, r)
	if err != nil {
		fmt.Printf("Error querying Prometheus: %v\n", err)
	}

	interceptTime := time.Now().Add(time.Hour).Unix()
	intercept, err := LinearPredictionWithPromValue(result[0].Values, interceptTime)
	if err != nil {
		fmt.Printf("Error LinearPredictionWithPromValue: %v\n", err)
	}

	fmt.Printf("interceptTime:\n%+v\n", interceptTime)
	fmt.Printf("intercept:\n%+v\n", intercept)
}

// 线性回归函数方法测试
func TestLinearRegression(t *testing.T) {
	// Positive test case
	samples := []FPoint{
		{1, 2},
		{2, 4},
		{3, 6},
	}
	interceptTime := int64(4)
	expectedIntercept := float64(8)

	_, intercept := linearRegression(samples, interceptTime)
	if intercept != expectedIntercept {
		t.Errorf("Expected intercept: %f, got: %f", expectedIntercept, intercept)
	}

	// Negative test case
	// Empty samples
	emptySamples := []FPoint{}
	emptyExpectedSlope := float64(0)
	emptyExpectedIntercept := float64(0)

	emptySlope, emptyIntercept := linearRegression(emptySamples, interceptTime)

	if emptySlope != emptyExpectedSlope {
		t.Errorf("Expected slope: %f, got: %f", emptyExpectedSlope, emptySlope)
	}

	if emptyIntercept != emptyExpectedIntercept {
		t.Errorf("Expected intercept: %f, got: %f", emptyExpectedIntercept, emptyIntercept)
	}
}

func TestMyLinearRegression(t *testing.T) {
	// 自变量 x 和因变量 y 的观测值
	x := []float64{1, 2, 3, 4, 5}
	y := []float64{2, 4, 6, 8, 10}

	// 计算 x 和 y 的均值
	meanX, meanY := stat.Mean(x, nil), stat.Mean(y, nil)

	// 计算斜率 beta1
	var ssXX, ssXY float64
	for i := range x {
		ssXX += (x[i] - meanX) * (x[i] - meanX)
		ssXY += (x[i] - meanX) * (y[i] - meanY)
	}

	// 斜率
	beta1 := ssXY / ssXX

	// 计算截距 beta0
	beta0 := meanY - beta1*meanX

	fmt.Printf("线性回归模型为: y = %.2f + %.2fx\n", beta0, beta1)

	// 使用模型预测新的 x 值
	newX := 6.0
	predictedY := beta0 + beta1*newX
	fmt.Printf("当 x = %.2f 时，预测的 y 值为: %.2f\n", newX, predictedY)
}

```

File path: /Users/mac/Desktop/woker_code/monitor/common/client/prom/default_client.go
```golang
package prom

import (
	"context"
	"fmt"
	"log"
	"time"

	_ "ezone.ksyun.com/ezone/luban/monitor/common/init_conf"

	"ezone.ksyun.com/ezone/luban/communal/lib"

	"github.com/prometheus/client_golang/api"
	v1 "github.com/prometheus/client_golang/api/prometheus/v1"
	"github.com/prometheus/common/model"
)

const timeOut = 5 * time.Second

var defaultClient = DefaultPromQueryApi()

func DefaultPromQueryApi() v1.API {
	promConfig := api.Config{}
	endpoint := lib.GetStringConf("base.prometheus.endpoint")
	//endpoint := "http://prometheus.luban.galaxy.cloud"
	promConfig.Address = endpoint
	client, err := api.NewClient(promConfig)
	if err != nil {
		log.Fatalf("init prometheus client addr %s,  error %v : ", endpoint, err)
	}
	return v1.NewAPI(client)
}

// 向量结果查询，一个时间点
func VectorQuery(ctx context.Context, query string) (v model.Vector, err error) {
	ctx, span := startSpan(ctx, query)
	defer endSpan(span, err)

	//fmt.Printf("DEBUG - prometheus query sql: %s\n", query)

	//提前1s,避免当前时间查不到数据
	t := time.Now().Add(time.Second * -1)
	//time.Now()
	value, warnings, err := defaultClient.Query(ctx, query, t, v1.WithTimeout(timeOut))
	if err != nil {
		fmt.Printf("prometheus query sql: %s, error: %v", query, err)
		return
	}
	if len(warnings) > 0 {
		fmt.Printf("prometheus query sql: %s, warnings: %v", query, warnings)
	}
	v, _ = value.(model.Vector)
	return
}

// 矩阵数据查询,多个时间点
func MatrixQuery(ctx context.Context, query string, r v1.Range) (v model.Matrix, err error) {
	ctx, span := startSpan(ctx, query)
	defer endSpan(span, err)
	//fmt.Printf("DEBUG - prometheus query time : %+v,  sql: %s\n", r, query)

	value, warnings, err := defaultClient.QueryRange(ctx, query, r, v1.WithTimeout(timeOut))
	if err != nil {
		fmt.Printf("prometheus query sql: %s, error: %v", query, err)
		return
	}
	if len(warnings) > 0 {
		fmt.Printf("prometheus query sql: %s, warnings: %v", query, warnings)
	}
	v, _ = value.(model.Matrix)
	return
}

```

File path: /Users/mac/Desktop/woker_code/monitor/common/client/ks3/ks3-client.go
```golang
package client

import (
	"ezone.ksyun.com/ezone/luban/communal/lib"
	_ "ezone.ksyun.com/ezone/luban/monitor/common/init_conf"
	"fmt"
	"github.com/ks3sdklib/aws-sdk-go/aws"
	"github.com/ks3sdklib/aws-sdk-go/aws/credentials"
	"github.com/ks3sdklib/aws-sdk-go/service/s3"
	"k8s.io/klog/v2"
	"time"
)

var ks3Client = Ks3Api()

func Ks3Api() *s3.S3 {

	region := lib.GetStringConf("base.ks3.region")
	endpoint := lib.GetStringConf("base.ks3.endpoint")
	ak := lib.GetStringConf("base.ks3.ak")
	sk := lib.GetStringConf("base.ks3.sk")

	klog.Info("Ks3ApiRegion", region)
	klog.Info("Ks3ApiEndpoint", endpoint)
	klog.Info("Ks3ApiAk", region)
	klog.Info("Ks3ApiSk", endpoint)

	cre := credentials.NewStaticCredentials(ak, sk, "")
	client1 := s3.New(&aws.Config{
		//Region 可参考 https://docs.ksyun.com/documents/6761
		Region:      region,
		Credentials: cre,
		//Endpoint 可参考 https://docs.ksyun.com/documents/6761
		Endpoint:         endpoint,
		DisableSSL:       true,  //是否禁用https
		LogLevel:         0,     //是否开启日志,0为关闭日志，1为开启日志
		LogHTTPBody:      false, //是否把HTTP请求body打入日志
		S3ForcePathStyle: false,
		Logger:           nil, //打日志的位置
		//DomainMode:       false, //是否开启自定义bucket绑定域名，当开启时 S3ForcePathStyle 参数不生效。
		//可选值有 ： V2 OR V4 OR V4_UNSIGNED_PAYLOAD_SIGNER
		//SignerVersion: "V4",
		MaxRetries: 1,
	})

	return client1
}

func GetObjectInputs(key, fileName string) string {

	bucket := lib.GetStringConf("base.Ks3.bucket")

	filesName := fmt.Sprintf("attachment; filename=%s", fileName)
	params := &s3.GetObjectInput{
		Bucket:                     aws.String(bucket), // bucket名称
		Key:                        aws.String(key),    // object key
		ResponseContentDisposition: aws.String(filesName),
	}
	timeUnixNano := time.Duration(time.Now().UnixNano() + int64(24*time.Hour))

	resp, err := ks3Client.GetObjectPresignedUrl(params, timeUnixNano)

	//第二个参数为外链过期时间，为纳秒级的时间戳
	if err != nil {
		klog.Errorf("get log download fdil ", err)
	}
	return resp.String()
}

```

File path: /Users/mac/Desktop/woker_code/monitor/common/client/alert/alert_client.go
```golang
package alert

import (
	"context"
	"time"

	_ "ezone.ksyun.com/ezone/luban/monitor/common/init_conf"

	"ezone.ksyun.com/ezone/luban/communal/lib"

	"github.com/prometheus/alertmanager/api/v2/client"
	"github.com/prometheus/alertmanager/api/v2/client/alert"
	"github.com/prometheus/alertmanager/api/v2/models"
)

const (
	TimeOut = 1 * time.Second
)

type AlertClient struct {
	apiClient *client.AlertmanagerAPI
}

var defaultAlertClient = NewAlertClient()

func NewAlertClient() *AlertClient {
	return &AlertClient{
		apiClient: defaultAlertManager(),
	}
}

func GetAlerts(params *alert.GetAlertsParams) (models.GettableAlerts, error) {
	ctx, cancel := context.WithTimeout(context.TODO(), TimeOut)
	defer cancel()
	params.Context = ctx
	return defaultAlertClient.GetAlerts(params)
}

func defaultAlertManager() *client.AlertmanagerAPI {
	config := client.TransportConfig{}
	endpoint := lib.GetStringConf("base.alert_manager.endpoint")
	//endpoint := "alert.luban.galaxy.cloud"
	config.Host = endpoint
	config.BasePath = "/api/v2"
	clientAlert := client.NewHTTPClientWithConfig(nil, &config)

	return clientAlert
}
func (ac *AlertClient) GetAlerts(params *alert.GetAlertsParams) (models.GettableAlerts, error) {
	res, err := ac.apiClient.Alert.GetAlerts(params)
	if err != nil {
		return nil, err
	}
	if res == nil {
		return nil, err
	}
	return res.Payload, err
}

```

File path: /Users/mac/Desktop/woker_code/monitor/common/client/alert/common.go
```golang
package alert

import (
	"github.com/prometheus/alertmanager/api/v2/client/alert"
	"github.com/prometheus/alertmanager/api/v2/models"
	"k8s.io/klog/v2"
)

// 一些公共处理逻辑的封装方法

func CountAlertsNumOld(alerts models.GettableAlerts, poolTye, severity string) int {
	if alerts == nil || len(alerts) == 0 {
		return 0
	}
	cntAlerts := make(models.GettableAlerts, 0)

	for _, alt := range alerts {
		level := (*alt).Labels["severity"]
		if level != "p0" && level != "p1" && level != "p2" && level != "p3" {
			continue
		}
		if (*alt).Labels["lubanAlarmView"] == "" && (*alt).Labels["lubanPolicyName"] == "" && (*alt).Annotations["lubanExpressionWithChinese"] == "" {
			continue
		}
		if poolTye != "" && (*alt).Labels["lubanResourceSubType"] != poolTye {
			continue
		}
		if severity != "" && level != severity {
			continue
		}
		cntAlerts = append(cntAlerts, alt)
	}
	return len(cntAlerts)
}

func CountAlertsNum(alerts models.GettableAlerts, poolTye, severity string) int {
	if alerts == nil || len(alerts) == 0 {
		return 0
	}
	cntAlerts := make(models.GettableAlerts, 0)
	for _, alt := range alerts {
		level := (*alt).Labels["level"]
		if level != "p0" && level != "p1" && level != "p2" && level != "p3" {
			continue
		}
		//只保留gms告警策略创建出来的告警
		if (*alt).Labels["policy_id"] == "" {
			continue
		}

		//if (*alt).Labels["lubanAlarmView"] == "" && (*alt).Labels["lubanPolicyName"] == "" && (*alt).Annotations["lubanExpressionWithChinese"] == "" {
		//	continue
		//}
		if poolTye != "" && (*alt).Labels["resource_sub_type"] != poolTye {
			continue
		}
		if severity != "" && level != severity {
			continue
		}
		cntAlerts = append(cntAlerts, alt)
	}
	return len(cntAlerts)
}

// CountAlertsListNum 获取服务器交换机对应告警数
func CountAlertsListNum(alerts models.GettableAlerts, resource_sub_type string) map[string]int {
	if alerts == nil || len(alerts) == 0 {
		return nil
	}
	res := make(map[string]int)
	for _, alt := range alerts {
		level := (*alt).Labels["level"]
		//只保留 p0  p1 p2 p3 级别告警
		if level != "p0" && level != "p1" && level != "p2" && level != "p3" {
			continue
		}
		//只保留gms告警策略创建出来的告警
		if (*alt).Labels["policy_id"] == "" {
			continue
		}
		var hostName string
		if resource_sub_type == "physicalServer" || resource_sub_type == "physicalSwitch" { //服务器 交换机
			hostName = (*alt).Labels["hostname"]
		}
		if ins, ok := res[hostName]; ok {
			res[hostName] = ins + 1
		} else {
			res[hostName] = 1
		}

	}
	return res
}

func GetAlertsByFilter(filter []string) (models.GettableAlerts, error) {
	var silenced bool = false
	var inhibited bool = false
	var active bool = true

	params := &alert.GetAlertsParams{
		Silenced:  &silenced,
		Active:    &active,
		Inhibited: &inhibited,
		Filter:    filter,
	}
	res, err := GetAlerts(params)
	if err != nil {
		klog.Error(err)
		return make(models.GettableAlerts, 0), err
	}
	return res, nil
}

```

File path: /Users/mac/Desktop/woker_code/monitor/common/client/alert/alert_client_test.go
```golang
package alert

import (
	"context"
	"github.com/prometheus/alertmanager/api/v2/client/alert"
	"k8s.io/klog/v2"
	"testing"
)

func TestAlertClient_GetAlerts(t *testing.T) {
	var silenced bool = false
	var inhibited bool = false
	var active bool = true
	ctx, cancel := context.WithTimeout(context.TODO(), TimeOut)
	defer cancel()
	params := &alert.GetAlertsParams{
		Silenced:  &silenced,
		Active:    &active,
		Inhibited: &inhibited,
		Context:   ctx,
		Filter:    []string{"lubanAlarmView=端口状态"},
	}
	res, err := defaultAlertClient.GetAlerts(params)
	if err != nil {
		klog.Error(err)
	}
	klog.Infof("res:%#v", res)
	// for _, v := range labels {
	// 	fmt.Println("key=", v.Metric["groupname"], "value=", v.Value)
	// }
	// tests := []struct {
	// 	name    string
	// 	ac      *AlertClient
	// 	want    *alert.GetAlertsOK
	// 	wantErr bool
	// }{
	// 	// TODO: Add test cases.
	// }
	// for _, tt := range tests {
	// 	t.Run(tt.name, func(t *testing.T) {
	// 		got, err := tt.ac.GetAlerts()
	// 		if (err != nil) != tt.wantErr {
	// 			t.Errorf("AlertClient.GetAlerts() error = %v, wantErr %v", err, tt.wantErr)
	// 			return
	// 		}
	// 		if !reflect.DeepEqual(got, tt.want) {
	// 			t.Errorf("AlertClient.GetAlerts() = %v, want %v", got, tt.want)
	// 		}
	// 	})
	// }
}

```

File path: /Users/mac/Desktop/woker_code/monitor/common/client/k8s/inner-client.go
```golang
package client

import (
	"fmt"
	"k8s.io/client-go/kubernetes"
	"k8s.io/client-go/rest"
)

var (
	InnerClient *kubernetes.Clientset
	RestConfig  *rest.Config
)

func GetClient() *kubernetes.Clientset {
	if InnerClient != nil {
		return InnerClient
	} else {
		return initClient()
	}
}
func GetToken() string {
	if RestConfig == nil {
		RestConfig, _ = rest.InClusterConfig()
	}
	return RestConfig.BearerToken
}

func initClient() *kubernetes.Clientset {

	config, err := rest.InClusterConfig()

	if err != nil {
		fmt.Printf("init k8s inner client error: %v\n", err.Error())
		return nil
	}
	// creates the clientset
	clientset, err := kubernetes.NewForConfig(config)
	if err != nil {
		fmt.Printf("get k8s inner client set error: %v\n", err.Error())
		return nil
	}
	return clientset
}

```

File path: /Users/mac/Desktop/woker_code/monitor/common/client/grpcx/conn.go
```golang
package grpcx

import (
	"ezone.ksyun.com/ezone/luban/communal/lib"
	"ezone.ksyun.com/ezone/luban/monitor/common/client/grpcx/clientinterceptors"
	"github.com/grpc-ecosystem/go-grpc-middleware/v2/interceptors/timeout"
	"google.golang.org/grpc"
	"google.golang.org/grpc/credentials/insecure"
	"google.golang.org/grpc/keepalive"
	"time"
)

const timeOut = 30 * time.Second

func NewGrpcClientConn(addr string) (*grpc.ClientConn, error) {

	clientKeepaliveParams := keepalive.ClientParameters{
		Time:                10 * time.Second, // send pings every 10 seconds if there is no activity
		Timeout:             timeOut,          // wait 5 second for ping ack before considering the connection dead
		PermitWithoutStream: false,
	}

	chainUnaryInterceptor := grpc.WithChainUnaryInterceptor(
		clientinterceptors.UnaryTracingInterceptor, //otl trace
		timeout.UnaryClientInterceptor(timeOut),    //timeout
	)

	kb := 1024
	mb := 1024 * kb

	conn, err := grpc.Dial(addr,
		grpc.WithTransportCredentials(insecure.NewCredentials()),
		grpc.WithKeepaliveParams(clientKeepaliveParams),
		chainUnaryInterceptor,
		grpc.WithDefaultCallOptions(
			grpc.MaxCallRecvMsgSize(1000*mb),
			grpc.MaxCallSendMsgSize(1000*mb),
		),
	)
	if err != nil {
		lib.Log.TagError(lib.NewTrace(), lib.DLTagTCPFailed, map[string]interface{}{"connect grpc server  error": err.Error(), "addr": addr})
		return nil, err
	}
	return conn, err
}

```

File path: /Users/mac/Desktop/woker_code/monitor/common/client/grpcx/clientinterceptors/client_trace.go
```golang
package clientinterceptors

import (
	"context"
	ztrace "ezone.ksyun.com/ezone/luban/monitor/common/trace"
	"go.opentelemetry.io/otel"
	"go.opentelemetry.io/otel/codes"
	"go.opentelemetry.io/otel/trace"
	"google.golang.org/grpc"
	gcodes "google.golang.org/grpc/codes"
	"google.golang.org/grpc/metadata"
	"google.golang.org/grpc/status"
)

// UnaryTracingInterceptor returns a grpc.UnaryClientInterceptor for opentelemetry.
func UnaryTracingInterceptor(ctx context.Context, method string, req, reply any,
	cc *grpc.ClientConn, invoker grpc.UnaryInvoker, opts ...grpc.CallOption) error {
	ctx, span := startSpan(ctx, method, cc.Target())
	defer span.End()

	ztrace.MessageSent.Event(ctx, 1, req)
	err := invoker(ctx, method, req, reply, cc, opts...)
	ztrace.MessageReceived.Event(ctx, 1, reply)
	if err != nil {
		s, ok := status.FromError(err)
		if ok {
			span.SetStatus(codes.Error, s.Message())
			span.SetAttributes(ztrace.StatusCodeAttr(s.Code()))
		} else {
			span.SetStatus(codes.Error, err.Error())
		}
		return err
	}

	span.SetAttributes(ztrace.StatusCodeAttr(gcodes.OK))
	return nil
}

func startSpan(ctx context.Context, method, target string) (context.Context, trace.Span) {
	md, ok := metadata.FromOutgoingContext(ctx)
	if !ok {
		md = metadata.MD{}
	}
	tr := otel.Tracer(ztrace.TraceName)
	name, attr := ztrace.SpanInfo(method, target)
	ctx, span := tr.Start(ctx, name, trace.WithSpanKind(trace.SpanKindClient),
		trace.WithAttributes(attr...))
	ztrace.Inject(ctx, otel.GetTextMapPropagator(), &md)
	ctx = metadata.NewOutgoingContext(ctx, md)

	return ctx, span
}

```

File path: /Users/mac/Desktop/woker_code/monitor/common/client/grpcx/serverinterceptors/server_trace.go
```golang
package serverinterceptors

import (
	"context"
	"fmt"

	ztrace "ezone.ksyun.com/ezone/luban/monitor/common/trace"
	"go.opentelemetry.io/otel"
	"go.opentelemetry.io/otel/baggage"
	"go.opentelemetry.io/otel/codes"
	"go.opentelemetry.io/otel/trace"
	"google.golang.org/grpc"
	gcodes "google.golang.org/grpc/codes"
	"google.golang.org/grpc/metadata"
	"google.golang.org/grpc/status"
)

// UnaryTracingInterceptor is a grpc.UnaryServerInterceptor for opentelemetry.
func UnaryTracingInterceptor(ctx context.Context, req any, info *grpc.UnaryServerInfo,
	handler grpc.UnaryHandler) (any, error) {
	ctx, span := startSpan(ctx, info.FullMethod)
	defer span.End()

	ztrace.MessageReceived.Event(ctx, 1, req)
	resp, err := handler(ctx, req)
	if err != nil {
		s, ok := status.FromError(err)
		if ok {
			span.SetStatus(codes.Error, s.Message())
			span.SetAttributes(ztrace.StatusCodeAttr(s.Code()))
			ztrace.MessageSent.Event(ctx, 1, s.Proto())
		} else {
			span.SetStatus(codes.Error, err.Error())
		}
		return nil, err
	}

	span.SetAttributes(ztrace.StatusCodeAttr(gcodes.OK))
	ztrace.MessageSent.Event(ctx, 1, resp)

	return resp, nil
}

func startSpan(ctx context.Context, method string) (context.Context, trace.Span) {
	md, ok := metadata.FromIncomingContext(ctx)
	if !ok {
		md = metadata.MD{}
	}

	fmt.Printf("DEBUG - %+v\n", md)

	bags, spanCtx := ztrace.Extract(ctx, otel.GetTextMapPropagator(), &md)
	ctx = baggage.ContextWithBaggage(ctx, bags)
	tr := otel.Tracer(ztrace.TraceName)
	name, attr := ztrace.SpanInfo(method, ztrace.PeerFromCtx(ctx))

	return tr.Start(trace.ContextWithRemoteSpanContext(ctx, spanCtx), name,
		trace.WithSpanKind(trace.SpanKindServer), trace.WithAttributes(attr...))
}

```

File path: /Users/mac/Desktop/woker_code/monitor/common/client/opentsdb/trace.go
```golang
package opentsdb

import (
	"context"
	"ezone.ksyun.com/ezone/luban/monitor/common/trace"
	"go.opentelemetry.io/otel/attribute"
	"go.opentelemetry.io/otel/codes"
	oteltrace "go.opentelemetry.io/otel/trace"
)

var tsdbQlAttributeKey = attribute.Key("tsdb.query")

func startSpan(ctx context.Context, query string) (context.Context, oteltrace.Span) {
	tracer := trace.TracerFromContext(ctx)
	ctx, span := tracer.Start(ctx, "tsdb", oteltrace.WithSpanKind(oteltrace.SpanKindClient))
	span.SetAttributes(tsdbQlAttributeKey.String(query))

	return ctx, span
}

func endSpan(span oteltrace.Span, err error) {
	defer span.End()

	if err == nil {
		span.SetStatus(codes.Ok, "")
		return
	}

	span.SetStatus(codes.Error, err.Error())
	span.RecordError(err)
}

```

File path: /Users/mac/Desktop/woker_code/monitor/common/client/opentsdb/common.go
```golang
package opentsdb

import (
	"fmt"
	"time"
)

// 一小时的毫秒数
const oneHourMsec = 3600 * 1000

// 一些公共处理逻辑的封装方法

// 根据查询时间段长度，确定采样率,避免返回数据点过多
// 用于线图类查询
func TimeToDownsample(duration int64) (downsample string) {
	if duration >= 0 {
		if duration <= oneHourMsec/2 { //0.5h
			return "1m-avg-zero"
		} else if duration <= (oneHourMsec * 1) { //1h
			return "5m-avg-zero"
		} else if duration <= (oneHourMsec * 3) { // 3h
			return "10m-avg-zero"
		} else if duration <= (oneHourMsec * 24 * 7) { // 12h 24h 7d
			return "1h-avg-zero"
		} else { // 30d
			return "1d-avg-zero"
		}
	}
	return ""
}

// 1.计算时间间隔
func ParseTimeInterval(start, end int64) string {
	var intervalStr string
	var interval int64
	interval = end - start
	fmt.Printf("DEBUG: interval:%d\n", interval)
	switch interval {
	case oneHourMsec / 2:
		intervalStr = "0.5h"
	case oneHourMsec * 1:
		intervalStr = "1h"
	case oneHourMsec * 3:
		intervalStr = "3h"
	case oneHourMsec * 12:
		intervalStr = "12h"
	case oneHourMsec * 24:
		intervalStr = "1d"
	case oneHourMsec * 24 * 7:
		intervalStr = "7d"
	case oneHourMsec * 24 * 30:
		intervalStr = "30d"
	}
	return intervalStr
}

// 根据间隔时间,计算从现在到之前的时间区间
func ParseTimeFromIntervalStr(interval string) (start, end int64) {
	end = time.Now().UnixMilli()
	switch interval {
	case "0.5h":
		start = end - oneHourMsec/2
	case "1h":
		start = end - oneHourMsec*1
	case "3h":
		start = end - oneHourMsec*3
	case "12h":
		start = end - oneHourMsec*12
	case "1d":
		start = end - oneHourMsec*24
	case "7d":
		start = end - oneHourMsec*24*7
	case "30d":
		start = end - oneHourMsec*24*30
	}
	return start, end
}

// 根据时间间隔,计算Top计算时的采样率
// 用于top类数据计算
func ParseTopDownsampleFromIntervalStr(interval string) string {
	switch interval {
	case "0.5h":
		return "30m-avg-zero"
	case "1h":
		return "1h-avg-zero"
	case "3h":
		return "3h-avg-zero"
	case "12h":
		return "12h-avg-zero"
	case "1d":
		return "1d-avg-zero"
	case "7d":
		return "7d-avg-zero"
	case "30d":
		return "30d-avg-zero"
	}
	return ""
}

```

File path: /Users/mac/Desktop/woker_code/monitor/common/client/opentsdb/default_client_test.go
```golang
package opentsdb

import (
	"context"
	"ezone.ksyun.com/ezone/luban/monitor/common/client/opentsdb/pkg"
	"fmt"
	"testing"
	"time"
)

func TestOpenTSDB(t *testing.T) {

	ctx := context.Background()
	//
	err := Ping(ctx, "cn-shanghai-2")
	if err != nil {
		t.Error(err)
	}

	name := []string{"cpu"}
	tags := make(map[string]string)
	st1 := time.Now().Unix()
	time.Sleep(1 * time.Second)

	// st2 = st1 after 1 second
	st2 := time.Now().Unix()
	queryParam := pkg.QueryParam{
		Start: st1,
		End:   st2,
	}
	subqueries := make([]pkg.SubQuery, 0)
	for _, metric := range name {
		subQuery := pkg.SubQuery{
			Aggregator: "sum",
			Metric:     metric,
			Tags:       tags,
		}
		subqueries = append(subqueries, subQuery)
	}
	queryParam.Queries = subqueries
	if queryResp, err := Query(ctx, "cn-shanghai-2", queryParam); err != nil {
		fmt.Printf("Error occurs when querying: %v", err)
	} else {
		fmt.Printf("%s", queryResp.String())
	}
	fmt.Println("Finish testing POST /api/query.")
}

```

File path: /Users/mac/Desktop/woker_code/monitor/common/client/opentsdb/default_client.go
```golang
package opentsdb

import (
	"context"
	"log"
	"time"

	"ezone.ksyun.com/ezone/luban/communal/lib"
	"ezone.ksyun.com/ezone/luban/monitor/common/client/opentsdb/pkg"
	_ "ezone.ksyun.com/ezone/luban/monitor/common/init_conf"
	"github.com/pkg/errors"
	"golang.org/x/time/rate"
)

const (
	//每秒请求数，令牌桶token每秒进入数量
	countPerSecond = 200

	//最大请求数, 令牌桶容量
	maxCount = 200

	//排队最大等待时间
	waitTimeOut = 10 * time.Second
)

var (
	regionClientPool = NewMultiRegionClients()
	noClientErr      = errors.New("no client are available")
)

type (
	LimitClient struct {
		limiter *rate.Limiter
		pkg.Client
	}
)

func NewMultiRegionClients() map[string]*LimitClient {
	pool := make(map[string]*LimitClient)
	regionToEndpoint := lib.GetStringMapStringConf("base.opentsdb")
	for region, endpoint := range regionToEndpoint {
		if c := NewClient(endpoint); c != nil {
			pool[region] = c
		}
	}
	return pool
}

func NewClient(host string) *LimitClient {

	opentsdbCfg := pkg.OpenTSDBConfig{
		OpentsdbHost: host,
	}
	//默认请求超时5s
	client, err := pkg.NewClient(opentsdbCfg)
	if err != nil {
		log.Fatalf("new opentsdb client error: %v\n", err)
		return nil
	}

	//设置client limiter
	limiter := rate.NewLimiter(countPerSecond, maxCount)

	return &LimitClient{
		limiter: limiter,
		Client:  client,
	}
}

func Ping(ctx context.Context, region string) (err error) {
	ctx, span := startSpan(ctx, "ping")
	defer endSpan(span, err)

	client, err := getClientByRegion(region)
	if err != nil {
		return err
	}
	return client.Ping()
}

// 实时类接口无限流,避免因排队等待导致页面加载超时

func Query(ctx context.Context, region string, param pkg.QueryParam) (*pkg.QueryResponse, error) {
	var err error
	ctx, span := startSpan(ctx, "Query")
	defer endSpan(span, err)

	client, err := getClientByRegion(region)
	if err != nil {
		return nil, err
	}
	return client.Query(param)
}

func QueryLast(ctx context.Context, region string, param pkg.QueryLastParam) (*pkg.QueryLastResponse, error) {
	var err error
	ctx, span := startSpan(ctx, "QueryLast")
	defer endSpan(span, err)

	client, err := getClientByRegion(region)
	if err != nil {
		return nil, err
	}
	return client.QueryLast(param)
}

// top类任务使用限流查询,避免并发请求过多

func QueryWithLimiter(ctx context.Context, region string, param pkg.QueryParam) (*pkg.QueryResponse, error) {
	var err error
	ctx, span := startSpan(ctx, "QueryWithLimiter")
	defer endSpan(span, err)

	client, err := getClientByRegion(region)
	if err != nil {
		return nil, err
	}

	// 等待直到有一个可用的令牌
	if err = client.limiter.Wait(context.Background()); err != nil {
		log.Printf("limiter wait error: %v\n", err)
		return nil, err
	}
	return client.Query(param)
}

func QueryLastWithLimiter(ctx context.Context, region string, param pkg.QueryLastParam) (*pkg.QueryLastResponse, error) {
	var err error
	ctx, span := startSpan(ctx, "QueryLastWithLimiter")
	defer endSpan(span, err)

	client, err := getClientByRegion(region)
	if err != nil {
		return nil, err
	}

	// 等待直到有一个可用的令牌
	if err = client.limiter.Wait(context.Background()); err != nil {
		log.Printf("limiter wait error: %v\n", err)
		return nil, err
	}
	return client.QueryLast(param)
}

func getClientByRegion(region string) (*LimitClient, error) {
	client, ok := regionClientPool[region]
	if !ok {
		return nil, noClientErr
	}
	return client, nil
}

```

File path: /Users/mac/Desktop/woker_code/monitor/common/client/opentsdb/pkg/query.go
```golang
// Copyright 2015 opentsdb-goclient authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//	http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Package client defines the client and the corresponding
// rest api implementaion of OpenTSDB.
//
// query.go contains the structs and methods for the implementation of /api/query.
package pkg

import (
	"bytes"
	"encoding/json"
	"errors"
	"fmt"
	"sort"
	"strconv"
	"strings"
)

// QueryParam is the structure used to hold
// the querying parameters when calling /api/query.
// Each attributes in QueryParam matches the definition in
// (http://opentsdb.net/docs/build/html/api_http/query/index.html).
type QueryParam struct {
	// The start time for the query. This can be a relative or absolute timestamp.
	// The data type can only be string, int, or int64.
	// The value is required with non-zero value of the target type.
	Start interface{} `json:"start"`

	// An end time for the query. If not supplied, the TSD will assume the local
	// system time on the server. This may be a relative or absolute timestamp.
	// The data type can only be string, or int64.
	// The value is optional.
	End interface{} `json:"end,omitempty"`

	// One or more sub queries used to select the time series to return.
	// These may be metric m or TSUID tsuids queries
	// The value is required with at least one element
	Queries []SubQuery `json:"queries"`

	// An optional value is used to show whether or not to return annotations with a query.
	// The default is to return annotations for the requested timespan but this flag can disable the return.
	// This affects both local and global notes and overrides globalAnnotations
	NoAnnotations bool `json:"noAnnotations,omitempty"`

	// An optional value is used to show whether or not the query should retrieve global
	// annotations for the requested timespan.
	GlobalAnnotations bool `json:"globalAnnotations,omitempty"`

	// An optional value is used to show whether or not to output data point timestamps in milliseconds or seconds.
	// If this flag is not provided and there are multiple data points within a second,
	// those data points will be down sampled using the query's aggregation function.
	MsResolution bool `json:"msResolution,omitempty"`

	// An optional value is used to show whether or not to output the TSUIDs associated with timeseries in the results.
	// If multiple time series were aggregated into one set, multiple TSUIDs will be returned in a sorted manner.
	ShowTSUIDs bool `json:"showTSUIDs,omitempty"`

	// An optional value is used to show whether or not can be paased to the JSON with a POST to delete any data point
	// that match the given query.
	Delete bool `json:"delete,omitempty"`
}

func (query *QueryParam) String() string {
	content, _ := json.Marshal(query)
	return string(content)
}

// SubQuery is the structure used to hold
// the subquery parameters when calling /api/query.
// Each attributes in SubQuery matches the definition in
// (http://opentsdb.net/docs/build/html/api_http/query/index.html).
type SubQuery struct {
	// The name of an aggregation function to use.
	// The value is required with non-empty one in the range of
	// the response of calling /api/aggregators.
	//
	// By default, the potential values and corresponding descriptions are as followings:
	//   "sum": Adds all of the data points for a timestamp.
	//   "min": Picks the smallest data point for each timestamp.
	//   "max": Picks the largest data point for each timestamp.
	//   "avg": Averages the values for the data points at each timestamp.
	Aggregator string `json:"aggregator"`

	// The name of a metric stored in the system.
	// The value is reqiured with non-empty value.
	Metric string `json:"metric"`

	// An optional value is used to show whether or not the data should be
	// converted into deltas before returning. This is useful if the metric is a
	// continously incrementing counter and you want to view the rate of change between data points.
	Rate bool `json:"rate,omitempty"`

	// rateOptions represents monotonically increasing counter handling options.
	// The value is optional.
	// Currently there is only three kind of value can be set to this map:
	// Only three keys can be set into the rateOption parameter of the QueryParam is
	// QueryRateOptionCounter (value type is bool),  QueryRateOptionCounterMax (value type is int,int64)
	// QueryRateOptionResetValue (value type is int,int64)
	RateParams map[string]interface{} `json:"rateOptions,omitempty"`

	// An optional value downsampling function to reduce the amount of data returned.
	Downsample string `json:"downsample,omitempty"`

	// An optional value to drill down to specific timeseries or group results by tag,
	// supply one or more map values in the same format as the query string. Tags are converted to filters in 2.2.
	// Note that if no tags are specified, all metrics in the system will be aggregated into the results.
	// It will be deprecated in OpenTSDB 2.2.
	Tags map[string]string `json:"tags,omitempty"`

	// An optional value used to filter the time series emitted in the results.
	// Note that if no filters are specified, all time series for the given
	// metric will be aggregated into the results.
	Fiters []Filter `json:"filters,omitempty"`
}

// Filter is the structure used to hold the filter parameters when calling /api/query.
// Each attributes in Filter matches the definition in
// (http://opentsdb.net/docs/build/html/api_http/query/index.html).
type Filter struct {
	// The name of the filter to invoke. The value is required with a non-empty
	// value in the range of calling /api/config/filters.
	Type string `json:"type"`

	// The tag key to invoke the filter on, required with a non-empty value
	Tagk string `json:"tagk"`

	// The filter expression to evaluate and depends on the filter being used, required with a non-empty value
	FilterExp string `json:"filter"`

	// An optional value to show whether or not to group the results by each value matched by the filter.
	// By default all values matching the filter will be aggregated into a single series.
	GroupBy bool `json:"groupBy"`
}

// DataPoint is the structure used to hold
// the values of a metric item. Each attributes
// in DataPoint matches the definition in
// (http://opentsdb.net/docs/build/html/api_http/put.html).
type DataPoint struct {
	// The name of the metric which is about to be stored, and is required with non-empty value.
	Metric string `json:"metric"`

	// A Unix epoch style timestamp in seconds or milliseconds.
	// The timestamp must not contain non-numeric characters.
	// One can use time.Now().Unix() to set this attribute.
	// This attribute is also required with non-zero value.
	Timestamp int64 `json:"timestamp"`

	// The real type of Value only could be int, int64, float64, or string, and is required.
	Value interface{} `json:"value"`

	// A map of tag name/tag value pairs. At least one pair must be supplied.
	// Don't use too many tags, keep it to a fairly small number, usually up to 4 or 5 tags
	// (By default, OpenTSDB supports a maximum of 8 tags, which can be modified by add
	// configuration item 'tsd.storage.max_tags' in opentsdb.conf).
	Tags map[string]string `json:"tags"`
}

func (data *DataPoint) String() string {
	content, _ := json.Marshal(data)
	return string(content)
}

// QueryResponse acts as the implementation of Response in the /api/query scene.
// It holds the status code and the response values defined in the
// (http://opentsdb.net/docs/build/html/api_http/query/index.html).
type QueryResponse struct {
	StatusCode    int
	QueryRespCnts []QueryRespItem        `json:"queryRespCnts"`
	ErrorMsg      map[string]interface{} `json:"error"`
}

func (queryResp *QueryResponse) String() string {
	buffer := bytes.NewBuffer(nil)
	content, _ := json.Marshal(queryResp)
	buffer.WriteString(fmt.Sprintf("%s\n", string(content)))
	return buffer.String()
}

func (queryResp *QueryResponse) SetStatus(code int) {
	queryResp.StatusCode = code
}

func (queryResp *QueryResponse) GetCustomParser() func(respCnt []byte) error {
	return func(respCnt []byte) error {
		originRespStr := string(respCnt)
		var respStr string
		if queryResp.StatusCode == 200 && strings.Contains(originRespStr, "[") && strings.Contains(originRespStr, "]") {
			respStr = fmt.Sprintf("{%s:%s}", `"queryRespCnts"`, originRespStr)
		} else {
			respStr = originRespStr
		}
		return json.Unmarshal([]byte(respStr), &queryResp)
	}
}

// QueryRespItem acts as the implementation of Response in the /api/query scene.
// It holds the response item defined in the
// (http://opentsdb.net/docs/build/html/api_http/query/index.html).
type QueryRespItem struct {
	// Name of the metric retreived for the time series
	Metric string `json:"metric"`

	// A list of tags only returned when the results are for a single time series.
	// If results are aggregated, this value may be null or an empty map
	Tags map[string]string `json:"tags"`

	// If more than one timeseries were included in the result set, i.e. they were aggregated,
	// this will display a list of tag names that were found in common across all time series.
	// Note that: Api Doc uses 'aggreatedTags', but actual response uses 'aggregateTags'
	AggregatedTags []string `json:"aggregateTags"`

	// Retrieved datapoints after being processed by the aggregators. Each data point consists
	// of a timestamp and a value, the format determined by the serializer.
	// For the JSON serializer, the timestamp will always be a Unix epoch style integer followed
	// by the value as an integer or a floating point.
	// For example, the default output is "dps"{"<timestamp>":<value>}.
	// By default the timestamps will be in seconds. If the msResolution flag is set, then the
	// timestamps will be in milliseconds.
	//
	// Because the elements of map is out of order, using common way to iterate Dps will not get
	// datapoints with timestamps out of order.
	// So be aware that one should use '(qri *QueryRespItem) GetDataPoints() []*DataPoint' to
	// acquire the real ascending datapoints.
	Dps map[string]interface{} `json:"dps"`

	// If the query retrieved annotations for timeseries over the requested timespan, they will
	// be returned in this group. Annotations for every timeseries will be merged into one set
	// and sorted by start_time. Aggregator functions do not affect annotations, all annotations
	// will be returned for the span.
	// The value is optional.
	Annotations []Annotation `json:"annotations,omitempty"`

	// If requested by the user, the query will scan for global annotations during
	// the timespan and the results returned in this group.
	// The value is optional.
	GlobalAnnotations []Annotation `json:"globalAnnotations,omitempty"`
}

// GetDataPoints returns the real ascending datapoints from the information of the related QueryRespItem.
func (qri *QueryRespItem) GetDataPoints() []*DataPoint {
	datapoints := make([]*DataPoint, 0)
	timestampStrs := qri.getSortedTimestampStrs()
	for _, timestampStr := range timestampStrs {
		timestamp, _ := strconv.ParseInt(timestampStr, 10, 64)
		datapoint := &DataPoint{
			Metric:    qri.Metric,
			Value:     qri.Dps[timestampStr],
			Tags:      qri.Tags,
			Timestamp: timestamp,
		}
		datapoints = append(datapoints, datapoint)
	}
	return datapoints
}

// getSortedTimestampStrs returns a slice of the ascending timestamp with
// string format for the Dps of the related QueryRespItem instance.
func (qri *QueryRespItem) getSortedTimestampStrs() []string {
	timestampStrs := make([]string, 0)
	for timestampStr := range qri.Dps {
		timestampStrs = append(timestampStrs, timestampStr)
	}
	sort.Strings(timestampStrs)
	return timestampStrs
}

// GetLatestDataPoint returns latest datapoint for the related QueryRespItem instance.
func (qri *QueryRespItem) GetLatestDataPoint() *DataPoint {
	timestampStrs := qri.getSortedTimestampStrs()
	size := len(timestampStrs)
	if size == 0 {
		return nil
	}
	timestamp, _ := strconv.ParseInt(timestampStrs[size-1], 10, 64)
	datapoint := &DataPoint{
		Metric:    qri.Metric,
		Value:     qri.Dps[timestampStrs[size-1]],
		Tags:      qri.Tags,
		Timestamp: timestamp,
	}
	return datapoint
}

func (c *clientImpl) Query(param QueryParam) (*QueryResponse, error) {
	if !isValidQueryParam(&param) {
		return nil, errors.New("The given query param is invalid.\n")
	}
	queryEndpoint := fmt.Sprintf("%s%s", c.tsdbEndpoint, QueryPath)
	reqBodyCnt, err := getQueryBodyContents(&param)
	if err != nil {
		return nil, err
	}
	queryResp := QueryResponse{}
	if err = c.sendRequest(PostMethod, queryEndpoint, reqBodyCnt, &queryResp); err != nil {
		return nil, err
	}
	return &queryResp, nil
}

func getQueryBodyContents(param interface{}) (string, error) {
	result, err := json.Marshal(param)
	if err != nil {
		return "", errors.New(fmt.Sprintf("Failed to marshal query param: %v\n", err))
	}
	return string(result), nil
}

func isValidQueryParam(param *QueryParam) bool {
	if param.Queries == nil || len(param.Queries) == 0 {
		return false
	}
	if !isValidTimePoint(param.Start) {
		return false
	}
	for _, query := range param.Queries {
		if len(query.Aggregator) == 0 || len(query.Metric) == 0 {
			return false
		}
		for k, _ := range query.RateParams {
			if k != QueryRateOptionCounter && k != QueryRateOptionCounterMax && k != QueryRateOptionResetValue {
				return false
			}
		}
	}
	return true
}

func isValidTimePoint(timePoint interface{}) bool {
	if timePoint == nil {
		return false
	}
	switch v := timePoint.(type) {
	case int:
		if v <= 0 {
			return false
		}
	case int64:
		if v <= 0 {
			return false
		}
	case string:
		if v == "" {
			return false
		}

	default:
		return false
	}
	return true
}

```

File path: /Users/mac/Desktop/woker_code/monitor/common/client/opentsdb/pkg/config.go
```golang
package pkg

// Copyright 2015 opentsdb-goclient authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
//
// Package config defines basic structure to hold the configure items used
// to initialize the opentsdb client.
//

import (
	"net/http"
)

type OpenTSDBConfig struct {

	// The host of the target opentsdb, is a required non-empty string which is
	// in the format of ip:port without http:// prefix or a domain.
	OpentsdbHost string

	// A pointer of http.Tranport is used by the opentsdb client.
	// This value is optional, and if it is not set, client.DefaultTransport, which
	// enables tcp keepalive mode, will be used in the opentsdb client.
	Transport *http.Transport

	// The maximal number of datapoints which will be inserted into the opentsdb
	// via one calling of /api/put method.
	// This value is optional, and if it is not set, client.DefaultMaxPutPointsNum
	// will be used in the opentsdb client.
	MaxPutPointsNum int

	// The detect delta number of datapoints which will be used in client.Put()
	// to split a large group of datapoints into small batches.
	// This value is optional, and if it is not set, client.DefaultDetectDeltaNum
	// will be used in the opentsdb client.
	DetectDeltaNum int

	// The maximal body content length per /api/put method to insert datapoints
	// into opentsdb.
	// This value is optional, and if it is not set, client.DefaultMaxPutPointsNum
	// will be used in the opentsdb client.
	MaxContentLength int
}

```

File path: /Users/mac/Desktop/woker_code/monitor/common/client/opentsdb/pkg/annotation.go
```golang
// Copyright 2015 opentsdb-goclient authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//	http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Package client defines the client and the corresponding
// rest api implementaion of OpenTSDB.
//
// annotation.go contains the structs and methods for the implementation of
// /api/annotation and /api/annotation/bulk.
package pkg

import (
	"bytes"
	"encoding/json"
	"errors"
	"fmt"
	"strings"
)

// Annotation is the structure used to hold
// the querying parameters when calling /api/annotation.
// Each attributes in Annotation matches the definition in
// (http://opentsdb.net/docs/build/html/api_http/annotation/index.html).
//
// Annotations are very basic objects used to record a note of an arbitrary
// event at some point, optionally associated with a timeseries. Annotations
// are not meant to be used as a tracking or event based system, rather they
// are useful for providing links to such systems by displaying a notice on
// graphs or via API query calls.
type Annotation struct {
	// A Unix epoch timestamp, in seconds, marking the time when the annotation event should be recorded.
	// The value is required with non-zero value.
	StartTime int64 `json:"startTime,omitempty"`

	// An optional end time for the event if it has completed or been resolved.
	EndTime int64 `json:"endTime,omitempty"`

	// A TSUID if the annotation is associated with a timeseries.
	// This may be optional if the note was for a global event
	Tsuid string `json:"tsuid,omitempty"`

	// An optional brief description of the event. As this may appear on GnuPlot graphs,
	// the description should be very short, ideally less than 25 characters.
	Description string `json:"description,omitempty"`

	// An optional detailed notes about the event
	Notes string `json:"notes,omitempty"`

	// An optional key/value map to store custom fields and values
	Custom map[string]string `json:"custom,omitempty"`
}

// AnnotationResponse acts as the implementation of Response in the /api/annotation scene.
// It holds the status code and the response values defined in the
// (http://opentsdb.net/docs/build/html/api_http/aggregators.html).
type AnnotationResponse struct {
	StatusCode int
	Annotation
	ErrorInfo map[string]interface{} `json:"error,omitempty"`
}

func (annotResp *AnnotationResponse) SetStatus(code int) {
	annotResp.StatusCode = code
}

func (annotResp *AnnotationResponse) GetCustomParser() func(respCnt []byte) error {
	return func(respCnt []byte) error {
		originContents := string(respCnt)
		var resultBytes []byte
		if strings.Contains(originContents, "startTime") ||
			strings.Contains(originContents, "error") {
			resultBytes = respCnt
		} else if annotResp.StatusCode == 204 {
			// The OpenTSDB deletes an annotation successfully and with no body content.
			return nil
		}
		return json.Unmarshal(resultBytes, &annotResp)
	}
}

func (annotResp *AnnotationResponse) String() string {
	buffer := bytes.NewBuffer(nil)
	content, _ := json.Marshal(annotResp)
	buffer.WriteString(fmt.Sprintf("%s\n", string(content)))
	return buffer.String()
}

func (c *clientImpl) QueryAnnotation(queryAnnoParam map[string]interface{}) (*AnnotationResponse, error) {
	if queryAnnoParam == nil || len(queryAnnoParam) == 0 {
		return nil, errors.New("The given query annotation param is nil")
	}
	buffer := bytes.NewBuffer(nil)
	size := len(queryAnnoParam)
	i := 0
	for k, v := range queryAnnoParam {
		buffer.WriteString(fmt.Sprintf("%s=%v", k, v))
		if i < size-1 {
			buffer.WriteString("&")
		} else {
			break
		}
		i++
	}
	annoEndpoint := fmt.Sprintf("%s%s?%s", c.tsdbEndpoint, AnnotationPath, buffer.String())
	annResp := AnnotationResponse{}
	if err := c.sendRequest(GetMethod, annoEndpoint, "", &annResp); err != nil {
		return nil, err
	}
	return &annResp, nil
}

func (c *clientImpl) UpdateAnnotation(annotation Annotation) (*AnnotationResponse, error) {
	return c.operateAnnotation(PostMethod, &annotation)
}

func (c *clientImpl) DeleteAnnotation(annotation Annotation) (*AnnotationResponse, error) {
	return c.operateAnnotation(DeleteMethod, &annotation)
}

func (c *clientImpl) operateAnnotation(method string, annotation *Annotation) (*AnnotationResponse, error) {
	if !c.isValidOperateMethod(method) {
		return nil, errors.New("The given method for operating an annotation is invalid.")
	}
	annoEndpoint := fmt.Sprintf("%s%s", c.tsdbEndpoint, AnnotationPath)
	resultBytes, err := json.Marshal(annotation)
	if err != nil {
		return nil, errors.New(fmt.Sprintf("Failed to marshal annotation: %v", err))
	}
	annResp := AnnotationResponse{}
	if err = c.sendRequest(method, annoEndpoint, string(resultBytes), &annResp); err != nil {
		return nil, err
	}
	return &annResp, nil
}

// BulkAnnotatResponse acts as the implementation of Response in the /api/annotation/bulk scene.
// It holds the status code and the response values defined in the
// (http://opentsdb.net/docs/build/html/api_http/annotation/bulk.html)
// for both bulk update and delete scenes.
type BulkAnnotatResponse struct {
	StatusCode        int
	UpdateAnnotations []Annotation           `json:"InvolvedAnnotations,omitempty"`
	ErrorInfo         map[string]interface{} `json:"error,omitempty"`
	BulkDeleteResp
}

type BulkAnnoDeleteInfo struct {
	// A list of TSUIDs with annotations that should be deleted. This may be empty
	// or null (for JSON) in which case the global flag should be set.
	Tsuids []string `json:"tsuids,omitempty"`

	// A timestamp for the start of the request.
	StartTime int64 `json:"startTime,omitempty"`

	// An optional end time for the event if it has completed or been resolved.
	EndTime int64 `json:"endTime,omitempty"`

	// An optional flag indicating whether or not global annotations should be deleted for the range
	Global bool `json:"global,omitempty"`
}

type BulkDeleteResp struct {
	BulkAnnoDeleteInfo

	// Total number of annotations to be deleted successfully for current bulk
	// delete operation. The value is only used in the reponse of bulk deleting,
	// not in the bulk deleting parameters.
	TotalDeleted int64 `json:"totalDeleted,omitempty"`
}

func (bulkAnnotResp *BulkAnnotatResponse) SetStatus(code int) {
	bulkAnnotResp.StatusCode = code
}

func (bulkAnnotResp *BulkAnnotatResponse) GetCustomParser() func(respCnt []byte) error {
	return func(respCnt []byte) error {
		originContents := string(respCnt)
		var resultBytes []byte
		if strings.Contains(originContents, "startTime") {
			resultBytes = []byte(fmt.Sprintf("{%s:%s}", `"InvolvedAnnotations"`, originContents))
		} else if strings.Contains(originContents, "error") || strings.Contains(originContents, "totalDeleted") {
			resultBytes = respCnt
		} else {
			return errors.New(fmt.Sprintf("Unrecognized bulk annotation response info: %s", originContents))
		}
		return json.Unmarshal(resultBytes, &bulkAnnotResp)
	}
}

func (bulkAnnotResp *BulkAnnotatResponse) String() string {
	buffer := bytes.NewBuffer(nil)
	content, _ := json.Marshal(bulkAnnotResp)
	buffer.WriteString(fmt.Sprintf("%s\n", string(content)))
	return buffer.String()
}

func (c *clientImpl) BulkUpdateAnnotations(annotations []Annotation) (*BulkAnnotatResponse, error) {
	if annotations == nil || len(annotations) == 0 {
		return nil, errors.New("The given annotations are empty.")
	}
	bulkAnnoEndpoint := fmt.Sprintf("%s%s", c.tsdbEndpoint, BulkAnnotationPath)
	reqBodyCnt, err := marshalAnnotations(annotations)
	if err != nil {
		return nil, errors.New(fmt.Sprintf("Failed to marshal annotations: %v", err))
	}
	bulkAnnoResp := BulkAnnotatResponse{}
	if err = c.sendRequest(PostMethod, bulkAnnoEndpoint, reqBodyCnt, &bulkAnnoResp); err != nil {
		return nil, err
	}
	return &bulkAnnoResp, nil
}

func (c *clientImpl) BulkDeleteAnnotations(bulkDelParam BulkAnnoDeleteInfo) (*BulkAnnotatResponse, error) {
	bulkAnnoEndpoint := fmt.Sprintf("%s%s", c.tsdbEndpoint, BulkAnnotationPath)
	resultBytes, err := json.Marshal(bulkDelParam)
	if err != nil {
		return nil, errors.New(fmt.Sprintf("Failed to marshal bulk delete param: %v", err))
	}
	bulkAnnoResp := BulkAnnotatResponse{}
	if err = c.sendRequest(DeleteMethod, bulkAnnoEndpoint, string(resultBytes), &bulkAnnoResp); err != nil {
		return nil, err
	}
	return &bulkAnnoResp, nil
}

func marshalAnnotations(annotations []Annotation) (string, error) {
	buffer := bytes.NewBuffer(nil)
	size := len(annotations)
	buffer.WriteString("[")
	for index, item := range annotations {
		result, err := json.Marshal(item)
		if err != nil {
			return "", err
		}
		buffer.Write(result)
		if index < size-1 {
			buffer.WriteString(",")
		}
	}
	buffer.WriteString("]")
	return buffer.String(), nil
}

```

File path: /Users/mac/Desktop/woker_code/monitor/common/client/opentsdb/pkg/client.go
```golang
// Copyright 2015 opentsdb-goclient authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//	http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Package client defines the client and the corresponding
// rest api implementaion of OpenTSDB.
//
// client.go contains the global interface and implementation struct
// definition of the OpenTSDB Client, as well as the common private
// and public methods used by all the rest-api implementation files,
// whose names are just like put.go, query.go, and so on.
package pkg

import (
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"io/ioutil"
	"net"
	"net/http"
	"strings"
	"time"
)

const (
	DefaultDialTimeout = 5 * time.Second
	KeepAliveTimeout   = 30 * time.Second
	GetMethod          = "GET"
	PostMethod         = "POST"
	PutMethod          = "PUT"
	DeleteMethod       = "DELETE"

	PutPath            = "/api/put"
	PutRespWithSummary = "summary"
	PutRespWithDetails = "details"

	QueryPath     = "/api/query"
	QueryLastPath = "/api/query/last"
	// The three keys in the rateOption parameter of the QueryParam
	QueryRateOptionCounter    = "counter"    // The corresponding value type is bool
	QueryRateOptionCounterMax = "counterMax" // The corresponding value type is int,int64
	QueryRateOptionResetValue = "resetValue" // The corresponding value type is int,int64

	AggregatorPath  = "/api/aggregators"
	ConfigPath      = "/api/config"
	SerializersPath = "/api/serializers"
	StatsPath       = "/api/stats"
	SuggestPath     = "/api/suggest"
	// Only the one of the three query type can be used in SuggestParam, UIDMetaData:
	TypeMetrics = "metrics"
	TypeTagk    = "tagk"
	TypeTagv    = "tagv"

	VersionPath        = "/api/version"
	DropcachesPath     = "/api/dropcaches"
	AnnotationPath     = "/api/annotation"
	AnQueryStartTime   = "start_time"
	AnQueryTSUid       = "tsuid"
	BulkAnnotationPath = "/api/annotation/bulk"
	UIDMetaDataPath    = "/api/uid/uidmeta"
	UIDAssignPath      = "/api/uid/assign"
	TSMetaDataPath     = "/api/uid/tsmeta"

	// The above three constants are used in /put
	DefaultMaxPutPointsNum = 75
	DefaultDetectDeltaNum  = 3
	// Unit is bytes, and assumes that config items of 'tsd.http.request.enable_chunked = true'
	// and 'tsd.http.request.max_chunk = 40960' are all in the opentsdb.conf:
	DefaultMaxContentLength = 40960
)

var (
	DefaultTransport = &http.Transport{
		MaxIdleConnsPerHost: 10,
		Dial: (&net.Dialer{
			Timeout:   DefaultDialTimeout,
			KeepAlive: KeepAliveTimeout,
		}).Dial,
	}
)

// Client defines the sdk methods, by which other go applications can
// commnicate with the OpenTSDB via the pre-defined rest-apis.
// Each method defined in the interface of Client is in the correspondance
// a rest-api definition in (http://opentsdb.net/docs/build/html/api_http/index.html#api-endpoints).
type Client interface {

	// Ping detects whether the target OpenTSDB is reachable or not.
	// If error occurs during the detection, an error instance will be returned, or nil otherwise.
	Ping() error

	// Query is the implementation of 'GET /api/query' endpoint.
	// It is probably the most useful endpoint in the API, /api/query enables extracting data from the storage
	// system in various formats determined by the serializer selected.
	//
	// param is a instance of QueryParam holding current query parameters.
	//
	// When query operation is successful, a pointer of QueryResponse will be returned with the corresponding
	// status code and response info. Otherwise, an error instance will be returned, when the given parameter
	// is invalid, it failed to parese the response, or OpenTSDB is un-connectable right now.
	Query(param QueryParam) (*QueryResponse, error)

	// QueryLast is the implementation of 'GET /api/query/last' endpoint.
	// It is introduced firstly in v2.1, and fully supported in v2.2. So it should be aware that this api works
	// well since v2.2 of opentsdb.
	//
	// param is a instance of QueryLastParam holding current query parameters.
	//
	// When query operation is successful, a pointer of QueryLastResponse will be returned with the corresponding
	// status code and response info. Otherwise, an error instance will be returned, when the given parameter
	// is invalid, it failed to parese the response, or OpenTSDB is un-connectable right now.
	QueryLast(param QueryLastParam) (*QueryLastResponse, error)
}

// NewClient creates an instance of http client which implements the
// pre-defined rest apis of OpenTSDB.
// A non-nil error instance returned means currently the target OpenTSDB
// designated with the given endpoint is not connectable.
func NewClient(opentsdbCfg OpenTSDBConfig) (Client, error) {
	opentsdbCfg.OpentsdbHost = strings.TrimSpace(opentsdbCfg.OpentsdbHost)
	if len(opentsdbCfg.OpentsdbHost) <= 0 {
		return nil, errors.New("The OpentsdbEndpoint of the given config should not be empty.")
	}
	transport := opentsdbCfg.Transport
	if transport == nil {
		transport = DefaultTransport
	}
	client := &http.Client{
		Transport: transport,
	}
	if opentsdbCfg.MaxPutPointsNum <= 0 {
		opentsdbCfg.MaxPutPointsNum = DefaultMaxPutPointsNum
	}
	if opentsdbCfg.DetectDeltaNum <= 0 {
		opentsdbCfg.DetectDeltaNum = DefaultDetectDeltaNum
	}
	if opentsdbCfg.MaxContentLength <= 0 {
		opentsdbCfg.MaxContentLength = DefaultMaxContentLength
	}
	tsdbEndpoint := fmt.Sprintf("http://%s", opentsdbCfg.OpentsdbHost)
	clientImpl := clientImpl{
		tsdbEndpoint: tsdbEndpoint,
		client:       client,
		opentsdbCfg:  opentsdbCfg,
	}
	return &clientImpl, nil
}

// ClientContext implements the Client interface and additionally provides a
// way to return a client that is associated with the given context.
type ClientContext interface {
	// WithContext returns a Client that is associated with the given context.
	// Use this to pass a context to underlying transport (e.g. to specify a
	// deadline).
	WithContext(ctx context.Context) Client
	Client
}

func NewClientContext(opentsdbCfg OpenTSDBConfig) (Client, error) {
	client, err := NewClient(opentsdbCfg)
	if err != nil {
		return nil, err
	}
	// We know this is actually clientImpl and implements this interface.
	return client.(ClientContext), nil
}

// The private implementation of Client interface.
type clientImpl struct {
	tsdbEndpoint string
	client       *http.Client
	ctx          context.Context
	opentsdbCfg  OpenTSDBConfig
}

// Response defines the common behaviours all the specific response for
// different rest-apis shound obey.
// Currently it is an abstraction used in (*clientImpl).sendRequest()
// to stored the different kinds of response contents for all the rest-apis.
type Response interface {

	// SetStatus can be used to set the actual http status code of
	// the related http response for the specific Response instance
	SetStatus(code int)

	// GetCustomParser can be used to retrive a custom-defined parser.
	// Returning nil means current specific Response instance doesn't
	// need a custom-defined parse process, and just uses the default
	// json unmarshal method to parse the contents of the http response.
	GetCustomParser() func(respCnt []byte) error

	// Return the contents of the specific Response instance with
	// the string format
	String() string
}

func (c *clientImpl) WithContext(ctx context.Context) Client {
	return &clientImpl{
		tsdbEndpoint: c.tsdbEndpoint,
		client:       c.client,
		ctx:          ctx,
		opentsdbCfg:  c.opentsdbCfg,
	}
}

// sendRequest dispatches the http request with the given method name, url and body contents.
// reqBodyCnt is "" means there is no contents in the request body.
// If the tsdb server responses properly, the error is nil and parsedResp is the parsed
// response with the specific type. Otherwise, the returned error is not nil.
func (c *clientImpl) sendRequest(method, url, reqBodyCnt string, parsedResp Response) error {
	req, err := http.NewRequest(method, url, strings.NewReader(reqBodyCnt))
	if c.ctx != nil {
		req = req.WithContext(c.ctx)
	}
	if err != nil {
		return errors.New(fmt.Sprintf("Failed to create request for %s %s: %v", method, url, err))
	}
	req.Header.Set("Content-Type", "application/json; charset=UTF-8")
	//fmt.Printf("TSDB DEBUG REQ: real request: %s, %s\n", url, reqBodyCnt)
	resp, err := c.client.Do(req)
	if err != nil {
		return errors.New(fmt.Sprintf("Failed to send request for %s %s: %v", method, url, err))
	}
	//fmt.Printf("TSDB DEBUG RSP: real response: %s, %+v\n", url, resp)

	defer resp.Body.Close()
	var jsonBytes []byte
	if jsonBytes, err = ioutil.ReadAll(resp.Body); err != nil {
		return errors.New(fmt.Sprintf("Failed to read response for %s %s: %v", method, url, err))
	}

	parsedResp.SetStatus(resp.StatusCode)
	parser := parsedResp.GetCustomParser()
	if parser == nil {
		if err = json.Unmarshal(jsonBytes, parsedResp); err != nil {
			return errors.New(fmt.Sprintf("Failed to parse response for %s %s: %v", method, url, err))
		}
	} else {
		if err = parser(jsonBytes); err != nil {
			return err
		}
	}

	return nil
}

func (c *clientImpl) isValidOperateMethod(method string) bool {
	method = strings.TrimSpace(strings.ToUpper(method))
	if len(method) == 0 {
		return false
	}
	methods := []string{PostMethod, PutMethod, DeleteMethod}
	exists := false
	for _, item := range methods {
		if method == item {
			exists = true
			break
		}
	}
	return exists
}

func (c *clientImpl) Ping() error {
	conn, err := net.DialTimeout("tcp", c.opentsdbCfg.OpentsdbHost, DefaultDialTimeout)
	if err != nil {
		return errors.New(fmt.Sprintf("The target OpenTSDB is unreachable: %v", err))
	}
	if conn != nil {
		defer conn.Close()
	}
	return nil
}

```

File path: /Users/mac/Desktop/woker_code/monitor/common/client/opentsdb/pkg/query_last.go
```golang
// Copyright 2015 opentsdb-goclient authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//	http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Package client defines the client and the corresponding
// rest api implementaion of OpenTSDB.
//
// query_last.go contains the structs and methods for the implementation of /api/query/last,
// which is fully supported since v2.2 of opentsdb.
package pkg

import (
	"bytes"
	"encoding/json"
	"errors"
	"fmt"
	"strings"
)

// QueryLastParam is the structure used to hold
// the querying parameters when calling /api/query/last.
// Each attributes in QueryLastParam matches the definition in
// (http://opentsdb.net/docs/build/html/api_http/query/last.html).
type QueryLastParam struct {
	// One or more sub queries used to select the time series to return.
	// These may be metric m or TSUID tsuids queries
	// The value is required with at least one element
	Queries []SubQueryLast `json:"queries"`

	// An optional flag is used to determine whether or not to resolve the TSUIDs of results to
	// their metric and tag names. The default value is false.
	ResolveNames bool `json:"resolveNames"`

	// An optional number of hours is used to search in the past for data. If set to 0 then the
	// timestamp of the meta data counter for the time series is used.
	BackScan int `json:"backScan"`
}

func (query *QueryLastParam) String() string {
	content, _ := json.Marshal(query)
	return string(content)
}

// SubQueryLast is the structure used to hold
// the subquery parameters when calling /api/query/last.
// Each attributes in SubQueryLast matches the definition in
// (http://opentsdb.net/docs/build/html/api_http/query/last.html).
type SubQueryLast struct {
	// The name of a metric stored in the system.
	// The value is reqiured with non-empty value.
	Metric string `json:"metric"`

	// An optional value to drill down to specific timeseries or group results by tag,
	// supply one or more map values in the same format as the query string. Tags are converted to filters in 2.2.
	// Note that if no tags are specified, all metrics in the system will be aggregated into the results.
	// It will be deprecated in OpenTSDB 2.2.
	Tags map[string]string `json:"tags,omitempty"`
}

// QueryLastResponse acts as the implementation of Response in the /api/query/last scene.
// It holds the status code and the response values defined in the
// (http://opentsdb.net/docs/build/html/api_http/query/last.html).
type QueryLastResponse struct {
	StatusCode    int
	QueryRespCnts []QueryRespLastItem    `json:"queryRespCnts,omitempty"`
	ErrorMsg      map[string]interface{} `json:"error"`
}

func (queryLastResp *QueryLastResponse) String() string {
	buffer := bytes.NewBuffer(nil)
	content, _ := json.Marshal(queryLastResp)
	buffer.WriteString(fmt.Sprintf("%s\n", string(content)))
	return buffer.String()
}

func (queryLastResp *QueryLastResponse) SetStatus(code int) {
	queryLastResp.StatusCode = code
}

func (queryLastResp *QueryLastResponse) GetCustomParser() func(respCnt []byte) error {
	return func(respCnt []byte) error {
		originRespStr := string(respCnt)
		var respStr string
		if queryLastResp.StatusCode == 200 && strings.Contains(originRespStr, "[") && strings.Contains(originRespStr, "]") {
			respStr = fmt.Sprintf("{%s:%s}", `"queryRespCnts"`, originRespStr)
		} else {
			respStr = originRespStr
		}
		return json.Unmarshal([]byte(respStr), &queryLastResp)
	}
}

// QueryRespLastItem acts as the implementation of Response in the /api/query/last scene.
// It holds the response item defined in the
// (http://opentsdb.net/docs/build/html/api_http/query/last.html).
type QueryRespLastItem struct {
	// Name of the metric retreived for the time series.
	// Only returned if resolve was set to true.
	Metric string `json:"metric"`

	// A list of tags only returned when the results are for a single time series.
	// If results are aggregated, this value may be null or an empty map.
	// Only returned if resolve was set to true.
	Tags map[string]string `json:"tags"`

	// A Unix epoch timestamp, in milliseconds, when the data point was written.
	Timestamp int64 `json:"timestamp"`

	// The value of the data point enclosed in quotation marks as a string
	Value string `json:"value"`

	// The hexadecimal TSUID for the time series
	Tsuid string `json:"tsuid"`
}

func (c *clientImpl) QueryLast(param QueryLastParam) (*QueryLastResponse, error) {
	if !isValidQueryLastParam(&param) {
		return nil, errors.New("The given query param is invalid.\n")
	}
	queryEndpoint := fmt.Sprintf("%s%s", c.tsdbEndpoint, QueryLastPath)
	reqBodyCnt, err := getQueryBodyContents(&param)
	if err != nil {
		return nil, err
	}
	queryResp := QueryLastResponse{}
	if err = c.sendRequest(PostMethod, queryEndpoint, reqBodyCnt, &queryResp); err != nil {
		return nil, err
	}
	return &queryResp, nil
}

func isValidQueryLastParam(param *QueryLastParam) bool {
	if param.Queries == nil || len(param.Queries) == 0 {
		return false
	}
	for _, query := range param.Queries {
		if len(query.Metric) == 0 {
			return false
		}
	}
	return true
}

```

File path: /Users/mac/Desktop/woker_code/monitor/common/client/opentsdb/pkg/client_test.go
```golang
package pkg

import (
	"fmt"
	"testing"
	"time"
)

func Test(t *testing.T) {

	opentsdbCfg := OpenTSDBConfig{
		OpentsdbHost: "127.0.0.1:4242",
	}
	tsdbClient, err := NewClient(opentsdbCfg)
	if err != nil {
		fmt.Printf("%v\n", err)
		return
	}

	//0. Ping
	if err = tsdbClient.Ping(); err != nil {
		fmt.Println(err.Error())
		return
	}

	name := []string{"cpu", "disk", "net", "mem", "bytes"}
	tags := make(map[string]string)
	tags["host"] = "bluebreezecf-host"
	tags["try-name"] = "bluebreezecf-sample"
	tags["demo-name"] = "opentsdb-test"

	//2.1 POST /api/query to query
	fmt.Println("Begin to test POST /api/query.")
	st1 := time.Now().Unix()
	time.Sleep(2 * time.Second)
	st2 := time.Now().Unix()
	queryParam := QueryParam{
		Start: st1,
		End:   st2,
	}
	subqueries := make([]SubQuery, 0)
	for _, metric := range name {
		subQuery := SubQuery{
			Aggregator: "sum",
			Metric:     metric,
			Tags:       tags,
		}
		subqueries = append(subqueries, subQuery)
	}
	queryParam.Queries = subqueries
	if queryResp, err := tsdbClient.Query(queryParam); err != nil {
		fmt.Printf("Error occurs when querying: %v", err)
	} else {
		fmt.Printf("%s", queryResp.String())
	}
	fmt.Println("Finish testing POST /api/query.")

	//2.2 POST /api/query/last
	fmt.Println("Begin to test POST /api/query/last.")
	time.Sleep(1 * time.Second)
	subqueriesLast := make([]SubQueryLast, 0)
	for _, metric := range name {
		subQueryLast := SubQueryLast{
			Metric: metric,
			Tags:   tags,
		}
		subqueriesLast = append(subqueriesLast, subQueryLast)
	}
	queryLastParam := QueryLastParam{
		Queries:      subqueriesLast,
		ResolveNames: true,
		BackScan:     24,
	}
	if queryLastResp, err := tsdbClient.QueryLast(queryLastParam); err != nil {
		fmt.Printf("Error occurs when querying last: %v", err)
	} else {
		fmt.Printf("%s", queryLastResp.String())
	}
	fmt.Println("Finish testing POST /api/query/last.")

}

```

File path: /Users/mac/Desktop/woker_code/monitor/common/consts/consts.go
```golang
package consts

const (
	// Success 业务响应状态码 11-monitor, xxxx-具体业务错误码
	Success                     = 200    //成功（获取成功、操作成功、创建成功、更新新成功、调用成功、响应成功）
	ServiceInternalError        = -1     //服务内部错误
	GainFail                    = 111001 //获取信息失败
	SubmitFail                  = 111002 //提交失败
	CreationFail                = 111003 //创建失败
	UpdateFail                  = 111004 //更新失败
	CallFail                    = 111005 //调用失败
	ResponseFail                = 111006 //响应失败
	RequestFail                 = 111007 //请求失败
	ParameterError              = 111008 //参数异常
	OverTime                    = 111009 //请求超时
	UnknownErr                  = 111010 //未知错误
	UnknownAction               = 111011 //未知Action
	InvalidRequest              = 111012 //无效的请求体
	ContentSelectorInvalidField = 111013 //ContentSelector字段无效
	ParameterVerificationFai    = 111014 //参数校验失败
	MethodNotSupported          = 111015 //不支持的请求方法
	ParModeNotSupported         = 111016 //不支持的参数模式

	// ErrorsConfigInitFail 配置文件
	ErrorsConfigInitFail      string = "初始化配置文件发生错误"
	ErrorsConfigYamlNotExists string = "配置文件不存在"

	//CurdStatusOkCode CURD常用状态码
	CurdStatusOkCode   int    = 0
	CurdStatusOkMsg    string = "Success"
	CurdSelectFailCode int    = 9999 //查询
	CurdSelectFailMsg  string = "查询失败"
	CurdUpdateFailCode int    = 9998 //更新
	CurdUpdateFailMsg  string = "更新失败"
	CurdWriteFailCode  int    = 9997 // 写入
	CurdWriteFailMsg   string = "写入失败"

	// ValidatorPrefix 表单验证
	ValidatorPrefix              string = "Form_Validator_" //表单验证前缀
	ValidatorParamsCheckFailCode int    = -1
	ValidatorParamsCheckFailMsg  string = "参数校验失败"
	ValidatorParamsToJSONFail    string = "验证器参数 json 反序列化失败"

	// DefaultMysqlPool 数据库连接池配置
	DefaultMysqlPool = "default"
	ProMysqlPool     = "pro"
	DevMysqlPool     = "dev"
)

```

File path: /Users/mac/Desktop/woker_code/monitor/common/consts/product_source.go
```golang
package consts

const (
	Platform = "platform"
	Business = "business"
)

func SourceName(key string) string {
	switch key {
	case Platform:
		return "平台"
	case Business:
		return "业务"
	default:
		return ""
	}
}

```

File path: /Users/mac/Desktop/woker_code/monitor/modules/database/dto/response.go
```golang
package dto

import "ezone.ksyun.com/ezone/luban/monitor/common/types"

var RedisDeployType = map[string]string{"SINGLE": "主从高可用", "CLUSTER": "集群高可用"}

type RedisLogRsp struct {
	TotalCount int64         `json:"TotalCount"`
	PageNo     int           `json:"PageNo"`
	PageSize   int           `json:"PageSize"`
	Logs       []interface{} `json:"Logs"`
}

type DbListRsp struct {
	TotalCount int64 `json:"TotalCount"`
	PageNo     int   `json:"PageNo"`
	PageSize   int   `json:"PageSize"`
	List       []Db  `json:"List"`
}

type Db struct {
	Id             string `json:"Id"`
	Name           string `json:"Name"`
	Status         string `json:"Status"`
	TenantId       string `json:"TenantId"`
	TenantName     string `json:"TenantName"`
	ProjectId      string `json:"ProjectId"`
	ProjectName    string `json:"ProjectName"`
	Ip             string `json:"Ip"`
	Region         string `json:"Region"`
	Az             string `json:"Az"`
	ResourcePool   string `json:"ResourcePool"`
	ResourcePoolId string `json:"ResourcePoolId"`
	DeployType     string `json:"DeployType"`
	DeployTypeDesc string `json:"DeployTypeDesc"`
	CreateTime     int64  `json:"CreateTime"`
}

type ProductDatabaseOverviewTopRsp struct {
	Tops []types.BasicOverviewSlot
}

type ProductSubListRsp struct {
}

type ProductDbLineRsp struct {
	Lines []types.BasicOverviewSlot
}

type DbPoolOverviewAlertRsp struct {
	Alerts []types.BasicOverviewSlot `json:"Alerts"`
}

type DbPoolOverviewMonitorRsp struct {
	AbnormalService  []types.BasicOverviewSlot `json:"AbnormalService"`
	AbnormalInstance []types.BasicOverviewSlot `json:"AbnormalInstance"`
}

type DbPoolOverviewLineRsp struct {
	Lines []types.BasicOverviewSlot `json:"Lines"`
}

type DbPoolListRsp struct {
	TotalCount int64
	PageNo     int
	PageSize   int
	List       []DbPoolList `json:"List"`
}

type DbPoolList struct {
	Id                  string  `json:"Id"`
	Name                string  `json:"Name"`
	DbType              string  `json:"DbType"`
	ResourcePoolType    string  `json:"ResourcePoolType"`
	Region              string  `json:"Region"`
	Az                  string  `json:"Az"`
	CpuLoad             float64 `json:"CpuLoad"`
	MemLoad             float64 `json:"MemLoad"`
	DiskLoad            float64 `json:"DiskLoad"`
	ServerCount         int     `json:"ServerCount"`
	AbnormalServerCount int     `json:"AbnormalServerCount"`
	InstanceTotal       int     `json:"InstanceTotal"`     //最大可创建实例数量
	InstanceUsed        int     `json:"InstanceUsed"`      //已创建的实例数量
	AbnormalInstance    int     `json:"AbnormalInstance"`  //异常实例数量
	InstanceAvailable   int     `json:"InstanceAvailable"` //当前可创建实例数量
	CreateTime          string  `json:"CreateTime"`
	AlertNumber         int     `json:"AlertNumber"`
}

type DbPoolDetailsLineRsp struct {
	Lines []types.BasicOverviewSlot `json:"Lines"`
}

type MysqlLogRsp struct {
	TotalCount int64      `json:"TotalCount"`
	PageNo     int        `json:"PageNo"`
	PageSize   int        `json:"PageSize"`
	List       []MysqlLog `json:"Logs"`
}

type MysqlLog struct {
	Id        string `json:"Id"`
	Name      string `json:"Name"`
	Size      string `json:"Size"`
	StartTime string `json:"StartTime"`
	EndTime   string `json:"EndTime"`
	Download  string `json:"Download"`
}

```

File path: /Users/mac/Desktop/woker_code/monitor/modules/database/dto/request.go
```golang
package dto

type DbListReq struct {
	Az             []string `json:"Az"`
	OrderCode      string   `json:"OrderCode" form:"OrderCode"`
	OrderType      string   `json:"OrderType" form:"OrderType" binding:"omitempty,oneof=ASC DESC"`
	PageNo         int      `json:"PageNo"`
	PageSize       int      `json:"PageSize"`
	PoolName       []string `json:"PoolName"`
	Region         string   `json:"Region"`
	Status         []string `json:"Status"`
	TenantIdList   []string `json:"TenantIdList"`
	TenantNameList []string `json:"TenantNameList"`
	ProjectIdList  []string `json:"ProjectIdList"`
	Query          Query    `json:"Query"`
	DatabaseType   string   `json:"DatabaseType"`
}

type Query map[string]string

type ProductDatabaseOverviewTopReq struct {
	Region     string   `json:"Region"`
	Az         string   `json:"Az"`
	MetricName []string `json:"MetricName"`
	TopK       int      `json:"TopK"` //5,10
	Start      int64    `json:"Start"`
	End        int64    `json:"End"`
}

type ProductDbSubListReq struct {
	ServerType string `json:"ServerType" binding:"omitempty,oneof=CLUSTER SINGLE" `
	InstanceId string `json:"InstanceId" binding:"required"` //主实例ID
}

type ProductDbLineReq struct {
	MetricName []string `json:"MetricName"`
	Start      int64    `json:"Start"`
	End        int64    `json:"End"`
	ID         string   `json:"ID"`
	DbType     string   `json:"DbType"`
}

type RedisLogReq struct {
	Id       string `json:"Id"`
	Start    int64  `json:"Start,omitempty"`
	End      int64  `json:"End,omitempty"`
	PageNo   int    `json:"PageNo,omitempty"`
	PageSize int    `json:"PageSize,omitempty"`
	LogType  string `json:"LogType,omitempty"`
	Context  string `json:"Context,omitempty"`
}

type MysqlLogReq struct {
	Id        string  `json:"Id" binding:"required"`
	Name      string  `json:"Name" binding:"required"`
	DbLogType string  `json:"DbLogType" binding:"oneof= errlog slowquery binlog" `
	PageNo    int     `json:"PageNo"`
	PageSize  int     `json:"PageSize"`
	Start     float64 `json:"Start"`
	End       float64 `json:"End"`
}

type DbPoolOverviewReq struct {
	Region string   `json:"Region"`
	Az     []string `json:"Az"`
	LabId  int      `json:"LabId"`
}

type DbPoolOverviewLineReq struct {
	Region        string   `json:"region"`
	Az            []string `json:"az"`
	MetricName    []string `json:"MetricName" binding:"required"`
	Start         int64    `json:"Start" binding:"required"`
	End           int64    `json:"End" binding:"required"`
	HasPrediction bool     `json:"HasPrediction"`
}

type DbPoolListReq struct {
	PageNo    int      `json:"PageNo"`
	PageSize  int      `json:"PageSize"`
	Region    string   `json:"Region"`
	Az        []string `json:"Az"`
	DbType    []string `json:"DbType"` //数据类型
	Query     Query    `json:"Query"`
	OrderCode string   `json:"OrderCode" form:"OrderCode"`
	OrderType string   `json:"OrderType" form:"OrderType" binding:"omitempty,oneof=ASC DESC"`
}

type DbPoolDetailsLineReq struct {
	Id         string   `json:"id" binding:"required"`
	MetricName []string `json:"MetricName" binding:"required"`
	Start      int64    `json:"Start" binding:"required"`
	End        int64    `json:"End" binding:"required"`
}

```

File path: /Users/mac/Desktop/woker_code/monitor/modules/database/dto/model.go
```golang
package dto

type SlowLog struct {
	RunLog
	Redis struct {
		SlowLog struct {
			Cmd      string `json:"Cmd"`
			Key      string `json:"Key"`
			Duration struct {
				Us int64 `json:"Us"`
			} `json:"Duration"`
		} `json:"SlowLog"`
	} `json:"Redis"`
}

type RunLog struct {
	Host struct {
		Name string `json:"Name"`
	} `json:"Host"`
	Message string `json:"Message"`
	Event   struct {
		Created string `json:"Created"`
		Dataset string `json:"Dataset"`
	} `json:"Event"`
}

```

File path: /Users/mac/Desktop/woker_code/monitor/modules/database/dao/monitor_tsdb_metrics.go
```golang
package dao

import (
	"context"
	"ezone.ksyun.com/ezone/luban/communal/lib"
	"ezone.ksyun.com/ezone/luban/monitor/modules/database/model"
	"github.com/pkg/errors"
	"gorm.io/gorm"
)

type MetricDao struct {
	db *gorm.DB
}

func NewMetricDao() *MetricDao {
	return &MetricDao{
		db: lib.GORMMapPool["business"],
	}
}

func (m *MetricDao) GetOneByCode(ctx context.Context, code string) (*model.MonitorTsdbMetrics, error) {
	content := model.MonitorTsdbMetrics{}
	err := m.db.WithContext(ctx).Where("code = ?", code).First(&content).Error
	if err != nil {
		if errors.Is(err, gorm.ErrRecordNotFound) {
			return nil, nil
		}
		lib.Log.TagError(lib.NewTrace(), lib.DLTagMySqlFailed, map[string]interface{}{"error": err.Error()})
		return nil, err
	}
	return &content, nil
}

```

File path: /Users/mac/Desktop/woker_code/monitor/modules/database/dao/db_instance_rds_log.go
```golang
package dao

import (
	"ezone.ksyun.com/ezone/luban/communal/lib"
	"ezone.ksyun.com/ezone/luban/monitor/modules/database/dto"
	"ezone.ksyun.com/ezone/luban/monitor/modules/database/model"
	"github.com/gin-gonic/gin"
	"gorm.io/gorm"
)

type DbInstanceRdsLogDao struct {
	db *gorm.DB
}

func NewDbInstanceRdsLogDao() *DbInstanceRdsLogDao {
	return &DbInstanceRdsLogDao{
		db: lib.GORMMapPool["business"],
	}
}

func (i *DbInstanceRdsLogDao) GetDbRdsLogList(ctx *gin.Context, par dto.MysqlLogReq) (int64, *[]model.DbInstanceRdsLog, error) {
	var content []model.DbInstanceRdsLog

	db := i.db.Model(&model.DbInstanceRdsLog{})

	if par.Id != "" {
		db = db.Where("instance_id = ?", par.Id)
	}

	if par.DbLogType != "" {
		db = db.Where("logtype = ?", par.DbLogType)
	}

	if par.Start != 0 && par.End == 0 {
		db = db.Where("start_time >= ?", par.Start)
	}

	if par.End != 0 && par.Start == 0 {
		db = db.Where("end_time <= ?", par.End)
	}

	if par.Start != 0 && par.End != 0 {
		db = db.Where("start_time >= ? and end_time < ?", par.Start, par.End)
	}

	// 设置排序
	db = db.Order("start_time desc")

	// 设置分页
	if par.PageSize != -1 {
		if par.PageNo > 0 && par.PageSize > 0 {
			db = db.Offset((par.PageNo - 1) * par.PageSize).Limit(par.PageSize)
		} else {
			db = db.Limit(10)
		}
	}

	var total int64
	db.Count(&total)

	err := db.Scan(&content).Error
	if err != nil {
		lib.Log.TagError(lib.NewTrace(), lib.DLTagMySqlFailed, map[string]interface{}{"error": err.Error()})
		return 0, nil, err
	}
	return total, &content, nil
}

```

File path: /Users/mac/Desktop/woker_code/monitor/modules/database/dao/monitor_top.go
```golang
package dao

import (
	"ezone.ksyun.com/ezone/luban/communal/lib"
	"ezone.ksyun.com/ezone/luban/monitor/common/gormSerializer"
	"ezone.ksyun.com/ezone/luban/monitor/modules/network/model"
	"github.com/pkg/errors"
	"gorm.io/gorm"
	"gorm.io/gorm/schema"
)

type MetricTopDao struct {
	db *gorm.DB
}

type QueryParams struct {
	Region string
	Az     string
	Code   string
}

func NewMetricTopDao() *MetricTopDao {
	schema.RegisterSerializer("json_str", gormSerializer.JSONSerializer{})
	return &MetricTopDao{
		db: lib.GORMMapPool["business"],
	}
}

//func (m *MetricTopDao) Insert(data model.MonitorTop) error {
//	if err := m.db.Create(&data).Error; err != nil {
//		return err
//	}
//	return nil
//}

func (m *MetricTopDao) CreateOrUpdate(data model.MonitorTop) error {
	// Save update value in database, if the value doesn't have primary key, will insert it
	if err := m.db.Save(&data).Error; err != nil {
		return err
	}
	return nil
}

func (m *MetricTopDao) GetOneByCode(q QueryParams) (*model.MonitorTop, error) {
	var data model.MonitorTop
	if err := m.db.Where("region = ? AND az = ? AND code = ?", q.Region, q.Az, q.Code).First(&data).Error; err != nil {
		if errors.Is(err, gorm.ErrRecordNotFound) {
			return nil, nil
		}
		return nil, err
	}
	return &data, nil
}

```

File path: /Users/mac/Desktop/woker_code/monitor/modules/database/dao/overview.go
```golang
package dao

import (
	"ezone.ksyun.com/ezone/luban/communal/lib"
	alarmv1alpha "ezone.ksyun.com/ezone/luban/luban_api/alarmapis/alarm/v1alpha/gen"
	databasepb "ezone.ksyun.com/ezone/luban/luban_api/resourceapis/resource_database/v1alpha/gen"
	"ezone.ksyun.com/ezone/luban/monitor/common/client/grpcx"
)

type DatabaseStore struct {
	//rpc
	DatabaseRpcClient databasepb.DatabaseServiceClient
	AlarmRpcClient    alarmv1alpha.AlarmServiceClient

	MetricTopDao        *MetricTopDao
	MetricDao           *MetricDao
	DbRedisInstanceDao  *DbRedisInstanceDao
	DbInstanceRdsLogDao *DbInstanceRdsLogDao
}

func NewDatabaseStore() *DatabaseStore {
	//resource
	resourceAddr := lib.GetStringConf("base.grpc.luban_resource")
	resourceConn, err := grpcx.NewGrpcClientConn(resourceAddr)
	if err != nil {
		lib.Log.TagError(lib.NewTrace(), lib.DLTagUndefind, map[string]interface{}{"connect luban_resource grpc server error, %s": err.Error()})
	}

	//alarm
	alarmAddr := lib.GetStringConf("base.grpc.alarm")
	alarmConn, err := grpcx.NewGrpcClientConn(alarmAddr)
	if err != nil {
		lib.Log.TagError(lib.NewTrace(), lib.DLTagUndefind, map[string]interface{}{"connect alarm grpc server error, %s": err.Error()})
	}

	return &DatabaseStore{
		DatabaseRpcClient:   databasepb.NewDatabaseServiceClient(resourceConn),
		AlarmRpcClient:      alarmv1alpha.NewAlarmServiceClient(alarmConn),
		MetricTopDao:        NewMetricTopDao(),
		MetricDao:           NewMetricDao(),
		DbRedisInstanceDao:  NewDbRedisInstanceDao(),
		DbInstanceRdsLogDao: NewDbInstanceRdsLogDao(),
	}
}

```

File path: /Users/mac/Desktop/woker_code/monitor/modules/database/dao/db_redis_instance.go
```golang
package dao

import (
	"ezone.ksyun.com/ezone/luban/communal/lib"
	"ezone.ksyun.com/ezone/luban/monitor/modules/database/model"
	"github.com/gin-gonic/gin"
	"github.com/pkg/errors"
	"gorm.io/gorm"
)

type DbRedisInstanceDao struct {
	db *gorm.DB
}

func NewDbRedisInstanceDao() *DbRedisInstanceDao {
	return &DbRedisInstanceDao{
		db: lib.GORMMapPool["business"],
	}
}

func (m *DbRedisInstanceDao) GetDbRedisInstance(ctx *gin.Context, instanceId string) (*[]model.DbRedisInstance, error) {
	var content []model.DbRedisInstance
	err := m.db.Where("instance_id = ?", instanceId).Find(&content).Error
	if err != nil {
		lib.Log.TagError(lib.NewTrace(), lib.DLTagMySqlFailed, map[string]interface{}{"error": err.Error()})
		return nil, err
	}
	return &content, nil
}

func (m *DbRedisInstanceDao) GetDbRedisSubInstance(subInstanceId string) (*model.DbRedisInstance, error) {
	var content model.DbRedisInstance
	err := m.db.Where("sub_instance_id = ?", subInstanceId).First(&content).Error
	if err != nil {
		if errors.Is(err, gorm.ErrRecordNotFound) {
			return nil, nil
		}
		lib.Log.TagError(lib.NewTrace(), lib.DLTagMySqlFailed, map[string]interface{}{"error": err.Error()})
		return nil, err
	}
	return &content, nil
}

```

File path: /Users/mac/Desktop/woker_code/monitor/modules/database/controller/db_product.go
```golang
package controller

import (
	"bytes"
	"encoding/json"
	"ezone.ksyun.com/ezone/luban/communal/lib"
	"ezone.ksyun.com/ezone/luban/monitor/common/consts"
	"ezone.ksyun.com/ezone/luban/monitor/modules/database/dto"
	"ezone.ksyun.com/ezone/luban/monitor/modules/database/service"
	"ezone.ksyun.com/ezone/luban/monitor/response"
	"github.com/gin-gonic/gin"
	"github.com/pkg/errors"
	"net/http"
)

type DatabaseController struct {
	svc *service.DatabaseService
}

func NewDatabaseController() *DatabaseController {
	return &DatabaseController{
		svc: service.NewDatabaseService(),
	}
}

func (d *DatabaseController) RedisLog(c *gin.Context) {
	// 绑定参数
	var params dto.RedisLogReq
	if err := c.ShouldBind(&params); err != nil {
		lib.Log.TagError(lib.GetTraceContext(c), lib.DLTagRequestOut, map[string]interface{}{"error": err.Error(), "params": params})
		response.Failed(c, http.StatusBadRequest, consts.ParameterError, "参数绑定失败")
		return
	}
	lib.Log.TagInfo(lib.GetTraceContext(c), lib.DLTagResponseFailed, map[string]interface{}{"params": params})
	if params.LogType != "redis.slowlog" && params.LogType != "redis.log" {
		params.LogType = "redis.slowlog"
	}
	logData, err := d.svc.GetLogMsg(c, &params)

	if err != nil {
		lib.Log.TagError(lib.GetTraceContext(c), lib.DLTagResponseFailed, map[string]interface{}{"error": errors.Cause(err).Error()})
		response.Failed(c, http.StatusInternalServerError, consts.GainFail, "获取redis日志失败")
		return
	}
	response.Success(c, logData)
}

func (d *DatabaseController) RedisSubInstanceList(c *gin.Context) {
	// 绑定参数
	var params dto.ProductDbSubListReq
	if err := c.ShouldBind(&params); err != nil {
		lib.Log.TagError(lib.GetTraceContext(c), lib.DLTagRequestOut, map[string]interface{}{"error": err.Error(), "params": params})
		response.Failed(c, http.StatusBadRequest, consts.ParameterError, "参数绑定失败")
		return
	}
	lib.Log.TagInfo(lib.GetTraceContext(c), lib.DLTagResponseFailed, map[string]interface{}{"params": params})

	// 业务处理
	res, err := d.svc.RedisSubInstanceList(c, &params)
	if err != nil {
		lib.Log.TagError(lib.GetTraceContext(c), lib.DLTagResponseFailed, map[string]interface{}{"error": errors.Cause(err).Error()})
		response.Failed(c, http.StatusInternalServerError, consts.GainFail, "获取redis子实例列表失败")
		return
	}
	if res == nil {
		lib.Log.TagError(lib.GetTraceContext(c), lib.DLTagResponseFailed, map[string]interface{}{"data": res})
		response.Failed(c, http.StatusInternalServerError, consts.GainFail, "获取折线图信息失败")
		return
	}
	response.Success(c, res)
}

func (d *DatabaseController) Line(c *gin.Context) {
	// 绑定参数
	var params dto.ProductDbLineReq
	if err := c.ShouldBind(&params); err != nil {
		lib.Log.TagError(lib.GetTraceContext(c), lib.DLTagRequestOut, map[string]interface{}{"error": err.Error(), "params": params})
		response.Failed(c, http.StatusBadRequest, consts.ParameterError, "参数绑定失败")
		return
	}
	lib.Log.TagInfo(lib.GetTraceContext(c), lib.DLTagResponseFailed, map[string]interface{}{"params": params})

	// 业务处理
	res, err := d.svc.DbLine(c, &params)
	if err != nil {
		lib.Log.TagError(lib.GetTraceContext(c), lib.DLTagResponseFailed, map[string]interface{}{"error": errors.Cause(err).Error()})
		response.Failed(c, http.StatusInternalServerError, consts.GainFail, "获取折线图信息失败")
		return
	}
	if res == nil {
		lib.Log.TagError(lib.GetTraceContext(c), lib.DLTagResponseFailed, map[string]interface{}{"data": res})
		response.Failed(c, http.StatusInternalServerError, consts.GainFail, "获取折线图信息失败")
		return
	}
	response.Success(c, res)
}

func (d *DatabaseController) Top(c *gin.Context) {
	// 绑定参数
	var params dto.ProductDatabaseOverviewTopReq
	if err := c.ShouldBind(&params); err != nil {
		lib.Log.TagError(lib.GetTraceContext(c), lib.DLTagRequestOut, map[string]interface{}{"error": err.Error(), "params": params})
		response.Failed(c, http.StatusBadRequest, consts.ParameterError, "参数绑定失败")
		return
	}
	lib.Log.TagInfo(lib.GetTraceContext(c), lib.DLTagResponseFailed, map[string]interface{}{"params": params})

	// 业务处理
	res, err := d.svc.OverviewTop(c, &params)
	if err != nil {
		lib.Log.TagError(lib.GetTraceContext(c), lib.DLTagResponseFailed, map[string]interface{}{"error": err.Error()})
		response.Failed(c, http.StatusInternalServerError, consts.GainFail, "获取概览失败")
		return
	}
	if res == nil {
		lib.Log.TagError(lib.GetTraceContext(c), lib.DLTagResponseFailed, map[string]interface{}{"data": res})
		response.Failed(c, http.StatusInternalServerError, consts.GainFail, "获取概览失败")
		return
	}
	response.Success(c, res)
}

func (d *DatabaseController) List(c *gin.Context) {
	// 参数绑定
	var params dto.DbListReq
	if err := c.ShouldBind(&params); err != nil {
		lib.Log.TagError(lib.GetTraceContext(c), lib.DLTagRequestOut, map[string]interface{}{"error": err.Error(), "params": params})
		response.Failed(c, http.StatusBadRequest, consts.ParameterError, "参数绑定失败")
		return
	}
	lib.Log.TagInfo(lib.GetTraceContext(c), lib.DLTagResponseFailed, map[string]interface{}{"params": params})

	// 业务处理
	res, err := d.svc.DbList(c, params)
	if err != nil {
		lib.Log.TagError(lib.GetTraceContext(c), lib.DLTagResponseFailed, map[string]interface{}{"error": err.Error()})
		response.Failed(c, http.StatusInternalServerError, consts.GainFail, "获取db list失败")
		return
	}

	lib.Log.TagInfo(lib.GetTraceContext(c), lib.DLTagResponseSuccess, map[string]interface{}{"res": res})
	response.Success(c, res)
}

func (d *DatabaseController) MysqlLog(c *gin.Context) {
	// 绑定参数
	var params dto.MysqlLogReq
	if err := c.ShouldBind(&params); err != nil {
		lib.Log.TagError(lib.GetTraceContext(c), lib.DLTagRequestOut, map[string]interface{}{"error": err.Error(), "params": params})
		response.Failed(c, http.StatusBadRequest, consts.ParameterError, "参数绑定失败")
		return
	}
	lib.Log.TagInfo(lib.GetTraceContext(c), lib.DLTagResponseFailed, map[string]interface{}{"params": params})

	logData, err := d.svc.MysqlLogList(c, params)

	if err != nil {
		lib.Log.TagError(lib.GetTraceContext(c), lib.DLTagResponseFailed, map[string]interface{}{"error": errors.Cause(err).Error()})
		response.Failed(c, http.StatusInternalServerError, consts.GainFail, "获取redis日志失败")
		return
	}

	responses := gin.H{
		"Code":      http.StatusOK,
		"Message":   "success",
		"Data":      logData,
		"RequestID": lib.GetTraceContext(c).TraceId}

	var buf bytes.Buffer
	encoder := json.NewEncoder(&buf)
	encoder.SetEscapeHTML(false) // 禁用 HTML 转义

	if err := encoder.Encode(responses); err != nil {
		lib.Log.TagError(lib.GetTraceContext(c), lib.DLTagResponseFailed, map[string]interface{}{"error": errors.Cause(err).Error()})
		response.Failed(c, http.StatusInternalServerError, consts.GainFail, "获取redis日志失败")
		return
	}

	c.Data(http.StatusOK, "application/json", buf.Bytes())
}

```

File path: /Users/mac/Desktop/woker_code/monitor/modules/database/controller/db_pool.go
```golang
package controller

import (
	"ezone.ksyun.com/ezone/luban/communal/lib"
	"ezone.ksyun.com/ezone/luban/monitor/common/consts"
	"ezone.ksyun.com/ezone/luban/monitor/modules/database/dto"
	"ezone.ksyun.com/ezone/luban/monitor/modules/database/service"
	"ezone.ksyun.com/ezone/luban/monitor/response"
	"github.com/gin-gonic/gin"
	"net/http"
)

type DbPoolController struct {
	svc *service.DbPoolService
}

func NewDbkPoolController() *DbPoolController {
	return &DbPoolController{
		svc: service.NewDbPoolService(),
	}
}

func (s *DbPoolController) DbPoolOverviewAlert(c *gin.Context) {
	// 参数绑定
	var params dto.DbPoolOverviewReq
	if err := c.ShouldBind(&params); err != nil {
		lib.Log.TagError(lib.GetTraceContext(c), lib.DLTagRequestOut, map[string]interface{}{"error": err.Error(), "params": params})
		response.Failed(c, http.StatusBadRequest, consts.ParameterError, "参数绑定失败")
		return
	}
	lib.Log.TagInfo(lib.GetTraceContext(c), lib.DLTagResponseFailed, map[string]interface{}{"params": params})

	// 业务处理
	res, err := s.svc.DbPoolOverviewAlert(c, params)
	if err != nil {
		lib.Log.TagError(lib.GetTraceContext(c), lib.DLTagResponseFailed, map[string]interface{}{"error": err.Error()})
		response.Failed(c, http.StatusInternalServerError, consts.GainFail, "获取数据库资源池概览监控告警失败")
		return
	}

	lib.Log.TagInfo(lib.GetTraceContext(c), lib.DLTagResponseSuccess, map[string]interface{}{"res": res})
	response.Success(c, res)
}

func (s *DbPoolController) DbPoolOverviewMonitor(c *gin.Context) {
	// 参数绑定
	var params dto.DbPoolOverviewReq
	if err := c.ShouldBind(&params); err != nil {
		lib.Log.TagError(lib.GetTraceContext(c), lib.DLTagRequestOut, map[string]interface{}{"error": err.Error(), "params": params})
		response.Failed(c, http.StatusBadRequest, consts.ParameterError, "参数绑定失败")
		return
	}
	lib.Log.TagInfo(lib.GetTraceContext(c), lib.DLTagResponseFailed, map[string]interface{}{"params": params})

	// 业务处理
	res, err := s.svc.DbPoolOverviewMonitor(c, params)
	if err != nil {
		lib.Log.TagError(lib.GetTraceContext(c), lib.DLTagResponseFailed, map[string]interface{}{"error": err.Error()})
		response.Failed(c, http.StatusInternalServerError, consts.GainFail, "获取数据库资源池概览监控告警失败")
		return
	}

	lib.Log.TagInfo(lib.GetTraceContext(c), lib.DLTagResponseSuccess, map[string]interface{}{"res": res})
	response.Success(c, res)
}

func (s *DbPoolController) DbPoolOverviewLine(c *gin.Context) {
	// 参数绑定
	var params dto.DbPoolOverviewLineReq
	if err := c.ShouldBind(&params); err != nil {
		lib.Log.TagError(lib.GetTraceContext(c), lib.DLTagRequestOut, map[string]interface{}{"error": err.Error(), "params": params})
		response.Failed(c, http.StatusBadRequest, consts.ParameterError, "参数绑定失败")
		return
	}
	lib.Log.TagInfo(lib.GetTraceContext(c), lib.DLTagResponseFailed, map[string]interface{}{"params": params})

	// 业务处理
	res, err := s.svc.DbPoolOverviewLine(c, params)
	if err != nil {
		lib.Log.TagError(lib.GetTraceContext(c), lib.DLTagResponseFailed, map[string]interface{}{"error": err.Error()})
		response.Failed(c, http.StatusInternalServerError, consts.GainFail, "获取数据库资源池概览监控告警失败")
		return
	}

	lib.Log.TagInfo(lib.GetTraceContext(c), lib.DLTagResponseSuccess, map[string]interface{}{"res": res})
	response.Success(c, res)
}

func (s *DbPoolController) DbPoolList(c *gin.Context) {
	// 参数绑定
	var params dto.DbPoolListReq
	if err := c.ShouldBind(&params); err != nil {
		lib.Log.TagError(lib.GetTraceContext(c), lib.DLTagRequestOut, map[string]interface{}{"error": err.Error(), "params": params})
		response.Failed(c, http.StatusBadRequest, consts.ParameterError, "参数绑定失败")
		return
	}
	lib.Log.TagInfo(lib.GetTraceContext(c), lib.DLTagResponseFailed, map[string]interface{}{"params": params})

	// 业务处理
	res, err := s.svc.DbPoolList(c, params)
	if err != nil {
		lib.Log.TagError(lib.GetTraceContext(c), lib.DLTagResponseFailed, map[string]interface{}{"error": err.Error()})
		response.Failed(c, http.StatusInternalServerError, consts.GainFail, "获取数据库资源池列表失败")
		return
	}

	lib.Log.TagInfo(lib.GetTraceContext(c), lib.DLTagResponseSuccess, map[string]interface{}{"res": res})
	response.Success(c, res)
}

func (s *DbPoolController) DbPoolDetailsLine(c *gin.Context) {
	// 参数绑定
	var params dto.DbPoolDetailsLineReq
	if err := c.ShouldBind(&params); err != nil {
		lib.Log.TagError(lib.GetTraceContext(c), lib.DLTagRequestOut, map[string]interface{}{"error": err.Error(), "params": params})
		response.Failed(c, http.StatusBadRequest, consts.ParameterError, "参数绑定失败")
		return
	}
	lib.Log.TagInfo(lib.GetTraceContext(c), lib.DLTagResponseFailed, map[string]interface{}{"params": params})

	// 业务处理
	res, err := s.svc.DbPoolDetailsLine(c, params)
	if err != nil {
		lib.Log.TagError(lib.GetTraceContext(c), lib.DLTagResponseFailed, map[string]interface{}{"error": err.Error()})
		response.Failed(c, http.StatusInternalServerError, consts.GainFail, "获取数据库资源池列表失败")
		return
	}

	lib.Log.TagInfo(lib.GetTraceContext(c), lib.DLTagResponseSuccess, map[string]interface{}{"res": res})
	response.Success(c, res)
}

```

File path: /Users/mac/Desktop/woker_code/monitor/modules/database/model/monitor_tsdb_metrics.go
```golang
package model

import (
	"time"
)

type MonitorTsdbMetrics struct {
	ID           int       `gorm:"column:id;primary_key;AUTO_INCREMENT"`
	ProductLine  string    `gorm:"column:product_line;NOT NULL"` // 产品线
	Code         string    `gorm:"column:code;NOT NULL"`         // 唯一标识
	Name         string    `gorm:"column:name;NOT NULL"`         // 中文名
	DisplayName  string    `gorm:"column:display_name;NOT NULL"`
	MetricPrefix string    `gorm:"column:metric_prefix;NOT NULL"` // metric前缀
	Unit         string    `gorm:"column:unit;NOT NULL;default:''"`
	CreatedAt    time.Time `gorm:"column:created_at;default:CURRENT_TIMESTAMP"`
	UpdatedAt    time.Time `gorm:"column:updated_at;default:CURRENT_TIMESTAMP"`
	DeletedAt    time.Time `gorm:"column:deleted_at"`
}

func (m *MonitorTsdbMetrics) TableName() string {
	return "monitor_tsdb_metrics"
}

```

File path: /Users/mac/Desktop/woker_code/monitor/modules/database/model/db_instance_rds_log.go
```golang
package model

import (
	"time"
)

type DbInstanceRdsLog struct {
	Id           int       `gorm:"column:id;type:int(11);primary_key;AUTO_INCREMENT" json:"id"`
	InstanceId   string    `gorm:"column:instance_id;type:varchar(36);comment:实例id" json:"instance_id"`
	GroupId      string    `gorm:"column:group_id;type:varchar(36);comment:分组id" json:"group_id"`
	Logtype      string    `gorm:"column:logtype;type:varchar(255);comment:日志类型" json:"logtype"`
	Size         int64     `gorm:"column:size;type:bigint(20)" json:"size"`
	StartTime    time.Time `gorm:"column:start_time;type:timestamp" json:"start_time"`
	EndTime      time.Time `gorm:"column:end_time;type:timestamp" json:"end_time"`
	Name         string    `gorm:"column:name;type:varchar(255)" json:"name"`
	LastUpdateAt time.Time `gorm:"column:last_update_at;type:timestamp;default:CURRENT_TIMESTAMP" json:"last_update_at"`
	Region       string    `gorm:"column:region;type:varchar(128)" json:"region"`
	Galaxy       string    `gorm:"column:galaxy;type:varchar(128)" json:"galaxy"`
	Deleted      int       `gorm:"column:deleted;type:tinyint(1);default:0" json:"deleted"`
}

```

File path: /Users/mac/Desktop/woker_code/monitor/modules/database/model/db_redis_instance.go
```golang
package model

import (
	"time"
)

type DbRedisInstance struct {
	Id            uint      `gorm:"column:id;type:int(10) unsigned;primary_key;AUTO_INCREMENT" json:"id"`
	InstanceId    string    `gorm:"column:instance_id;type:varchar(36);comment:redis主实例id;NOT NULL" json:"instance_id"`
	Role          string    `gorm:"column:role;type:varchar(20);comment:节点类型;NOT NULL" json:"role"`
	SubInstanceId string    `gorm:"column:sub_instance_id;type:varchar(36);comment:子实例id;NOT NULL" json:"sub_instance_id"`
	Region        string    `gorm:"column:region;type:varchar(128);NOT NULL" json:"region"`
	Galaxy        string    `gorm:"column:galaxy;type:varchar(128);NOT NULL" json:"galaxy"`
	Deleted       int       `gorm:"column:deleted;type:tinyint(1);default:0;NOT NULL" json:"deleted"`
	LastUpdateTim time.Time `gorm:"column:last_update_tim;type:timestamp;default:CURRENT_TIMESTAMP" json:"last_update_tim"`
}

```

File path: /Users/mac/Desktop/woker_code/monitor/modules/database/service/db_product.go
```golang
package service

import (
	"context"
	"ezone.ksyun.com/ezone/luban/communal/lib"
	resource_databasev1alpha "ezone.ksyun.com/ezone/luban/luban_api/resourceapis/resource_database/v1alpha/gen"
	ks3client "ezone.ksyun.com/ezone/luban/monitor/common/client/ks3"
	"ezone.ksyun.com/ezone/luban/monitor/common/client/opentsdb"
	"ezone.ksyun.com/ezone/luban/monitor/common/client/opentsdb/pkg"
	"ezone.ksyun.com/ezone/luban/monitor/common/tools"
	"ezone.ksyun.com/ezone/luban/monitor/common/tsdbql_template"
	"ezone.ksyun.com/ezone/luban/monitor/common/tsdbql_template/mysql"
	"ezone.ksyun.com/ezone/luban/monitor/common/types"
	"ezone.ksyun.com/ezone/luban/monitor/modules/database/dao"
	"ezone.ksyun.com/ezone/luban/monitor/modules/database/dto"
	"fmt"
	"github.com/gin-gonic/gin"
	"github.com/olivere/elastic"
	"github.com/pkg/errors"
	"k8s.io/klog/v2"
	"net/http"
	"reflect"
	"time"
)

type DatabaseService struct {
	Store    dao.DatabaseStore
	esClient *elastic.Client
}

func NewDatabaseService() *DatabaseService {
	client, err := elastic.NewClient(
		elastic.SetURL(lib.GetStringSliceConf("base.elasticsearch.KCSRedisLogingElasticsearchAddress")...),
		elastic.SetSniff(false),
	)
	if err != nil {
		klog.Errorf("KCS redis log elasticsearch connect error: %s", err)
	}
	return &DatabaseService{
		Store:    *dao.NewDatabaseStore(),
		esClient: client,
	}
}

func (d *DatabaseService) OverviewTop(ctx context.Context, par *dto.ProductDatabaseOverviewTopReq) (*dto.ProductDatabaseOverviewTopRsp, error) {
	tops := []types.BasicOverviewSlot{}

	for _, name := range par.MetricName {
		tsdbMetric, err := d.Store.MetricDao.GetOneByCode(ctx, name)
		if err != nil {
			return nil, errors.WithMessagef(err, "get tsdb metric %s err", name)
		}
		if tsdbMetric == nil {
			return nil, errors.WithMessagef(fmt.Errorf("record not found"), "get tsdb metric %s err", name)
		}
		topData, err := d.Store.MetricTopDao.GetOneByCode(dao.QueryParams{
			Region: par.Region,
			Az:     par.Az,
			Code:   name,
		})
		if err != nil {
			return nil, err
		}

		if topData == nil {
			klog.Warning("overviewTop data not found ", fmt.Sprintf("%s|%s|%s", name, par.Az, par.Region))
			continue
		}

		intervalData := topData.ParseIntervalData(par.Start, par.End)
		//topK
		if par.TopK > 10 {
			return nil, fmt.Errorf("topK is too large")
		}
		if par.TopK < len(intervalData) {
			intervalData = intervalData[:par.TopK]
		}

		values := []types.BasicOverviewSlotValue{}
		for k, v := range intervalData {
			value := types.BasicOverviewSlotValue{
				Name:     v.Name,
				Code:     v.Id,
				Value:    v.Value,
				Unit:     tsdbMetric.Unit,
				UnitType: types.ParseUnitTypeByUnit(tsdbMetric.Unit),
				Kind:     types.KindInfo,
			}
			if tools.In([]string{mysql.Mysql_riops, mysql.Mysql_wiops, mysql.Mysql_threads_connected, mysql.Mysql_threads_running}, name) {
				value.SubName = value.Name
				value.Name = fmt.Sprintf("Top%d", k+1)
			}
			values = append(values, value)
		}

		slot := types.BasicOverviewSlot{
			Info: types.BasicOverviewSlotInfo{
				Index:       0,
				Name:        tsdbMetric.DisplayName,
				Value:       0,
				UnitType:    types.ParseUnitTypeByUnit(tsdbMetric.Unit),
				Unit:        tsdbMetric.Unit,
				Kind:        types.KindInfo,
				Prognosis:   0,
				Description: "",
			},
			Values: values,
		}
		tops = append(tops, slot)
	}

	return &dto.ProductDatabaseOverviewTopRsp{
		Tops: tops,
	}, nil
}

func (d *DatabaseService) DbList(ctx *gin.Context, par dto.DbListReq) (*dto.DbListRsp, error) {
	//获取
	rpcResult, err := d.Store.DatabaseRpcClient.ListDatabase(ctx, &resource_databasev1alpha.ProductDbListRequest{
		PageNo:       1,
		PageSize:     -1,
		Az:           par.Az,
		OrderCode:    par.OrderCode,
		OrderType:    par.OrderType,
		ResourcePool: par.PoolName,
		Region:       par.Region,
		Status:       par.Status,
		TenantId:     par.TenantIdList,
		TenantName:   par.TenantNameList,
		ProjectId:    par.ProjectIdList,
		DataBaseType: par.DatabaseType,
		Query:        par.Query,
	})
	if err != nil {
		return nil, err
	}
	var dbList []dto.Db

	for _, v := range rpcResult.Data {
		val := dto.Db{
			Id:             v.Id,
			Name:           v.Name,
			Status:         v.Status,
			TenantId:       v.TenantId,
			TenantName:     v.TenantName,
			ProjectId:      v.ProjectId,
			ProjectName:    v.ProjectName,
			Ip:             v.Ip,
			Region:         v.Region,
			Az:             v.Az,
			ResourcePool:   v.ResourcePool,
			ResourcePoolId: v.ResourcePoolId,
			CreateTime:     v.CreateTime,
		}
		if par.DatabaseType == "redis" {
			val.DeployType = v.DeployType
			val.DeployTypeDesc = dto.RedisDeployType[v.DeployType]
		}
		dbList = append(dbList, val)
	}
	//分页
	low := (par.PageNo - 1) * par.PageSize
	if low > len(rpcResult.Data) {
		klog.Info("PageSize is too large")
	}

	high := low + par.PageSize
	if high > len(rpcResult.Data) {
		high = len(rpcResult.Data)
	}

	var results dto.DbListRsp
	results.PageSize = par.PageSize
	results.PageNo = par.PageNo
	results.TotalCount = int64(len(rpcResult.Data))
	results.List = dbList[low:high]

	return &results, err
}

func (d *DatabaseService) RedisSubInstanceList(ctx *gin.Context, par *dto.ProductDbSubListReq) (map[string][]string, error) {

	list, err := d.Store.DbRedisInstanceDao.GetDbRedisInstance(ctx, par.InstanceId)
	if err != nil {
		return nil, err
	}
	resMap := make(map[string][]string, 0)
	if par.ServerType == "CLUSTER" { // 集群
		for _, v := range *list {
			if v.Role == "SLAVE" {
				continue
			}
			if ins, ok := resMap[v.Role]; ok {
				resMap[v.Role] = append(ins, v.SubInstanceId)
			} else {
				resMap[v.Role] = []string{v.SubInstanceId}
			}
		}
	} else if par.ServerType == "SINGLE" { //主从
		resMap["MASTER"] = []string{par.InstanceId}
		resMap["SLAVE"] = []string{}
		for _, v := range *list {
			resMap["SLAVE"] = append(resMap["SLAVE"], v.SubInstanceId)
		}
	}

	return resMap, nil
}

func (d *DatabaseService) DbLine(ctx context.Context, par *dto.ProductDbLineReq) (*dto.ProductDbLineRsp, error) {
	queryParam := pkg.QueryParam{
		Start: par.Start,
		End:   par.End,
	}
	var region string
	if par.DbType == "mysql" {
		mysqlInfo, err := d.Store.DatabaseRpcClient.MysqlDetails(ctx, &resource_databasev1alpha.DbDetailsRequest{
			InstanceId: par.ID,
		})
		if mysqlInfo == nil {
			return nil, errors.New(fmt.Sprintf("mysql instance %s not found", par.ID))
		}
		if err != nil {
			return nil, errors.WithMessage(err, "rpc call DetailMysql err")
		}
		region = mysqlInfo.BaseInfo.Region
	} else {
		redisInfo, err := d.Store.DatabaseRpcClient.RedisDetails(ctx, &resource_databasev1alpha.DbDetailsRequest{
			InstanceId: par.ID,
		})
		if err != nil {
			return nil, errors.WithMessage(err, "rpc call DetailRedis err")
		}
		if redisInfo == nil || redisInfo.BaseInfo == nil {
			redisSubInstanceInfo, err := d.Store.DbRedisInstanceDao.GetDbRedisSubInstance(par.ID)
			if err != nil {
				return nil, errors.WithMessage(err, "GetDbRedisSubInstance err")
			}
			if redisSubInstanceInfo == nil {
				return nil, errors.New(fmt.Sprintf("redis instance %s not found", par.ID))
			}
			region = redisSubInstanceInfo.Region
		} else {
			region = redisInfo.BaseInfo.Region
		}
	}

	lines := make([]types.BasicOverviewSlot, 0)
	for _, name := range par.MetricName {
		subqueries := make([]pkg.SubQuery, 0)
		tsdbMetric, err := d.Store.MetricDao.GetOneByCode(ctx, name)
		if err != nil {
			return nil, errors.WithMessagef(err, "get tsdb metric %s err", name)
		}
		if tsdbMetric == nil {
			return nil, errors.WithMessagef(fmt.Errorf("record not found"), "get tsdb metric %s err", name)
		}
		eipQuery := tsdbql_template.ParseTsdbQuery(tsdbMetric.ProductLine, tsdbMetric.MetricPrefix, par.ID)
		subqueries = append(subqueries, pkg.SubQuery{
			Aggregator: "sum",
			Metric:     eipQuery.Metric,
			Tags:       map[string]string{"host": eipQuery.HostTag},
			Downsample: opentsdb.TimeToDownsample(par.End - par.Start),
		})

		queryParam.Queries = subqueries
		queryResp, err := opentsdb.Query(ctx, region, queryParam)
		if err != nil {
			return nil, errors.WithMessagef(err, "tsdb query err, param : %v", queryParam)
		}
		//查询404返回空数据
		if queryResp.StatusCode != http.StatusOK {
			if queryResp.StatusCode == http.StatusNotFound {
				return &dto.ProductDbLineRsp{Lines: lines}, nil
			}
			return nil, errors.New("tsdb query response failed")
		}
		//查询200,但是数据为空，返回空数据
		if len(queryResp.QueryRespCnts) <= 0 {
			return &dto.ProductDbLineRsp{Lines: lines}, nil
		}

		line := types.BasicOverviewSlot{
			Info: types.BasicOverviewSlotInfo{
				Index:       0,
				Name:        tsdbMetric.DisplayName,
				Value:       nil,
				UnitType:    types.ParseUnitTypeByUnit(tsdbMetric.Unit),
				Unit:        tsdbMetric.Unit,
				Kind:        types.KindInfo,
				Prognosis:   0,
				Description: "",
			},
		}

		dataPoints := queryResp.QueryRespCnts[0].GetDataPoints()
		for _, v := range dataPoints {
			if tsdbMetric.Unit == "%" {
				v.Value = tools.FormPercent(v.Value.(float64) / 1e2)
			}
			line.Values = append(line.Values, types.BasicOverviewSlotValue{
				Name:        fmt.Sprintf("%d", tools.UnixToUnixMilli(v.Timestamp)),
				Code:        "",
				Value:       v.Value,
				Unit:        tsdbMetric.Unit,
				UnitType:    types.ParseUnitTypeByUnit(tsdbMetric.Unit),
				Kind:        types.KindInfo,
				Description: v.Metric,
			})
		}
		lines = append(lines, line)
	}

	return &dto.ProductDbLineRsp{
		Lines: lines,
	}, nil
}

// 从 ES 搜索日志并返回 SearchResult
func (d *DatabaseService) getLogFromES(param *dto.RedisLogReq, logType string, include []string) (*elastic.SearchResult, error) {
	if param.PageSize == 0 {
		param.PageSize = 10
	}
	if param.PageNo == 0 {
		param.PageNo = 1
	}
	from := (param.PageNo - 1) * param.PageSize

	// cluster_id 对应控制台实例ID，搜索实例及对应的日志类型
	boolQuery := elastic.NewBoolQuery().Must(elastic.NewMatchQuery("cluster_id", param.Id), elastic.NewMatchQuery("event.dataset", logType))

	// 匹配日志内容
	if len(param.Context) > 0 {
		boolQuery.Must(elastic.NewMatchQuery("message", param.Context))
	}
	// 设置日志生成时间
	if param.Start != 0 && param.End != 0 {
		boolQuery.Filter(elastic.NewRangeQuery("event.created").From(param.Start).To(param.End))
	}
	// 设置 ES 返回字段, 构建请求 DSL
	includeContext := elastic.NewFetchSourceContext(true).Include(include...)
	searchSource := elastic.NewSearchSource().Query(boolQuery).Sort("event.created", false).
		From(from).Size(param.PageSize).FetchSourceContext(includeContext)
	// 打印 ES 请求DSL
	queryDSL, _ := searchSource.Source()
	klog.V(1).Infof("KCS redis instacne log query DSL: %+v", queryDSL)

	builder := elastic.NewSearchService(d.esClient).Index(lib.GetStringConf("base.elasticsearch.KCSRedisLogingElasticsearchIndex"))
	builder.SearchSource(searchSource)
	return builder.Do(context.Background())
}

func (d *DatabaseService) GetLogMsg(ctx context.Context, par *dto.RedisLogReq) (data dto.RedisLogRsp, err error) {
	if d.esClient == nil {
		if lib.GetStringSliceConf("base.elasticsearch.KCSRedisLogingElasticsearchAddress") == nil {
			return
		}
		err = errors.New("esClient is invalid")
		return
	}
	logFields := []string{"host.name", "message", "event"}
	if par.LogType == "redis.slowlog" {
		logFields = append(logFields, "redis.slowlog")
	}

	resp, err := d.getLogFromES(par, par.LogType, logFields)
	if err != nil {
		klog.Errorf("get redis instance %s log error: %s", par.Id, err)
		return
	}

	switch par.LogType {
	case "redis.slowlog":
		var slowLog dto.SlowLog
		data.Logs = resp.Each(reflect.TypeOf(slowLog))
	case "redis.log":
		var runLog dto.RunLog
		data.Logs = resp.Each(reflect.TypeOf(runLog))
	}
	data.TotalCount = resp.TotalHits()
	data.PageNo = par.PageNo
	data.PageSize = par.PageSize
	return
}

func (d *DatabaseService) MysqlLogList(ctx *gin.Context, par dto.MysqlLogReq) (*dto.MysqlLogRsp, error) {

	//获取日志数据
	totalCount, list, err := d.Store.DbInstanceRdsLogDao.GetDbRdsLogList(ctx, par)
	if err != nil {
		return nil, err
	}

	var logList []dto.MysqlLog

	for _, v := range *list {
		size := fmt.Sprintf("%.2fKB", float64(v.Size)/1024.0)

		TimeStr := time.Now().Format("20060102")

		fileName := par.Name + "_" + v.Logtype + "_" + TimeStr + ".log.gz"
		download := ks3client.GetObjectInputs(v.Name, fileName)
		info := dto.MysqlLog{
			Id:        v.InstanceId,
			Name:      v.Name,
			Size:      size,
			StartTime: v.StartTime.Format("2006-01-02 15:04:05"),
			EndTime:   v.EndTime.Format("2006-01-02 15:04:05"),
			Download:  download,
		}
		logList = append(logList, info)
	}

	return &dto.MysqlLogRsp{
		TotalCount: totalCount,
		PageNo:     par.PageNo,
		PageSize:   par.PageSize,
		List:       logList,
	}, nil
}

```

File path: /Users/mac/Desktop/woker_code/monitor/modules/database/service/db_pool.go
```golang
package service

import (
	"fmt"
	"math"
	"sort"
	"strconv"
	"time"

	alarmv1alpha "ezone.ksyun.com/ezone/luban/luban_api/alarmapis/alarm/v1alpha/gen"
	db_rpc "ezone.ksyun.com/ezone/luban/luban_api/resourceapis/resource_database/v1alpha/gen"
	prom_client "ezone.ksyun.com/ezone/luban/monitor/common/client/prom"
	"ezone.ksyun.com/ezone/luban/monitor/common/promql_template/db"
	"ezone.ksyun.com/ezone/luban/monitor/common/promql_template/server"
	"ezone.ksyun.com/ezone/luban/monitor/common/tools"
	"ezone.ksyun.com/ezone/luban/monitor/common/types"
	"ezone.ksyun.com/ezone/luban/monitor/common/utils"
	"ezone.ksyun.com/ezone/luban/monitor/modules/database/dao"
	"ezone.ksyun.com/ezone/luban/monitor/modules/database/dto"
	"github.com/gin-gonic/gin"
	"github.com/pkg/errors"
	v1 "github.com/prometheus/client_golang/api/prometheus/v1"
	"k8s.io/klog/v2"
)

type DbPoolService struct {
	Store dao.DatabaseStore
}

func NewDbPoolService() *DbPoolService {
	return &DbPoolService{
		Store: *dao.NewDatabaseStore(),
	}
}

func (s *DbPoolService) DbPoolOverviewAlert(ctx *gin.Context, par dto.DbPoolOverviewReq) (*dto.DbPoolOverviewAlertRsp, error) {

	alertLevels := []types.OverviewAlert{
		{Name: "紧急告警", Level: "p0", Kind: "error", Number: 0, Unit: "个"},
		{Name: "重要告警", Level: "p1", Kind: "warn", Number: 0, Unit: "个"},
		{Name: "次要告警", Level: "p2", Kind: "minor", Number: 0, Unit: "个"},
		{Name: "提醒告警", Level: "p3", Kind: "info", Number: 0, Unit: "个"},
	}

	alerts, err := s.Store.AlarmRpcClient.ListAlerts(ctx, &alarmv1alpha.ListAlertsRequest{
		PageNo:   -1,
		PageSize: -1,
		Region:   par.Region,
		Az:       par.Az,
		Status:   "firing",
	})
	if err != nil {
		return nil, errors.WithMessage(err, "rpc call AlarmRpcClient.ListAlerts err")
	}

	//概览数据拼装
	var alertSlots []types.BasicOverviewSlot

	for _, alert := range alertLevels {
		var alertSlotInfo types.BasicOverviewSlot

		kscNum := utils.CountAlertsNum(alerts.Items, "ksc", alert.Level)
		rdsNum := utils.CountAlertsNum(alerts.Items, "rds", alert.Level)

		alertSlotInfo.Info = types.BasicOverviewSlotInfo{
			Index:       0,
			Name:        alert.Level,
			Value:       kscNum + rdsNum,
			UnitType:    types.TypeNumber,
			Unit:        "个",
			Kind:        alert.Kind,
			Prognosis:   0,
			Description: "",
		}
		alertSlots = append(alertSlots, alertSlotInfo)
	}

	return &dto.DbPoolOverviewAlertRsp{
		Alerts: alertSlots,
	}, nil

}

func (s *DbPoolService) DbPoolOverviewMonitor(ctx *gin.Context, par dto.DbPoolOverviewReq) (*dto.DbPoolOverviewMonitorRsp, error) {

	rpcResult, err := s.Store.DatabaseRpcClient.DbResourcePoolList(ctx, &db_rpc.DbAggregateListRequest{
		DataBaseType: []string{"mysql", "redis"},
		PageNo:       1,
		PageSize:     -1,
		Az:           []string{},
	})

	if err != nil {
		return nil, err
	}

	var (
		serverTotal        int
		serverDownValues   []types.BasicOverviewSlotValue
		service            []types.BasicOverviewSlot
		instanceTotal      int
		instanceDownValues []types.BasicOverviewSlotValue
		instance           []types.BasicOverviewSlot
	)

	for _, v := range rpcResult.Data {

		serverTotal += int(v.ServerCount)
		instanceTotal += int(v.InstanceUsed)

		var ipList []string
		for _, server := range v.Servers {

			if server.Ip != "" {
				ipList = append(ipList, server.Ip+":9100")
			}
		}
		//获取资源池下服务器状态
		statusPromQL, err := s.Store.AlarmRpcClient.ListPromQLs(ctx, server.TemplateMap[server.Status](ipList))
		if err != nil {
			return nil, err
		}
		//查Prometheus
		status, err := prom_client.VectorQuery(ctx, statusPromQL.Items[0].RealPromql)
		if err != nil {
			return nil, err
		}
		serverMonitorUpStatusMap := prom_client.ParseServerMonitoringStatus(status)
		serverdown := 0
		for _, v := range serverMonitorUpStatusMap {
			if v != "up" {
				serverdown++
			}
		}
		serverDownValues = append(serverDownValues, types.BasicOverviewSlotValue{
			Name:        v.Name,
			Value:       serverdown,
			Unit:        "",
			UnitType:    types.TypeNumber,
			Kind:        types.KindError,
			Description: "",
		})

		instanceDownValues = append(instanceDownValues, types.BasicOverviewSlotValue{
			Name:        v.Name,
			Value:       v.AbnormalInstance,
			Unit:        "",
			UnitType:    types.TypeNumber,
			Kind:        types.KindError,
			Description: "",
		})

	}

	serviceDown := types.BasicOverviewSlot{
		Info: types.BasicOverviewSlotInfo{
			Index:       0,
			Name:        "服务器异常统计",
			Value:       serverTotal,
			UnitType:    types.TypeNumber,
			Unit:        "",
			Kind:        types.KindError,
			Prognosis:   0,
			Description: "",
		},
		Values: serverDownValues,
	}
	service = append(service, serviceDown)

	instanceDown := types.BasicOverviewSlot{
		Info: types.BasicOverviewSlotInfo{
			Index:       0,
			Name:        "实例异常统计",
			Value:       instanceTotal,
			UnitType:    types.TypeNumber,
			Unit:        "",
			Kind:        types.KindError,
			Prognosis:   0,
			Description: "",
		},
		Values: instanceDownValues,
	}

	instance = append(instance, instanceDown)

	return &dto.DbPoolOverviewMonitorRsp{
		AbnormalService:  service,
		AbnormalInstance: instance,
	}, nil
}

func (s *DbPoolService) DbPoolOverviewLine(ctx *gin.Context, par dto.DbPoolOverviewLineReq) (*dto.DbPoolOverviewLineRsp, error) {

	rpcResult, err := s.Store.DatabaseRpcClient.DbResourcePoolList(ctx, &db_rpc.DbAggregateListRequest{
		DataBaseType: []string{"mysql", "redis"},
		PageNo:       1,
		PageSize:     -1,
		Az:           []string{},
	})

	if err != nil {
		return nil, err
	}

	start := par.Start / 1e3
	end := par.End / 1e3
	step := tools.TimeToStepForInt(end - start)

	predictStart := end
	predictEnd := end + (end - start)

	var lines []types.BasicOverviewSlot
	predictionMetrics := []string{"VcpuRemain", "MemRemain", "DiskRemain"}

	for _, v := range rpcResult.Data {
		var (
			psql       string
			predictSql string
			unit       string
			unitType   string
		)
		switch par.MetricName[0] {
		case "CpuRate":
			//todo psql 改造
			//cpuMode, err := s.Store.AlarmRpcClient.ListPromQLs(ctx, server.TemplateMap[server.CpuUsageRate](ipList))
			cpuMode, err := s.Store.AlarmRpcClient.ListPromQLs(ctx, db.TemplateMap[db.CpuUsage](v.Region, v.Az, v.Name, v.ResourcePoolType))
			if err != nil {
				return nil, err
			}

			psql = cpuMode.Items[0].RealPromql
			unit = "%"
			unitType = types.TypePercent
		case "MemRate":
			//memMode, err := s.Store.AlarmRpcClient.ListPromQLs(ctx, server.TemplateMap[server.MemUsageSumRate](ipList))
			memMode, err := s.Store.AlarmRpcClient.ListPromQLs(ctx, db.TemplateMap[db.MemoryUsage](v.Region, v.Az, v.Name, v.ResourcePoolType))
			if err != nil {
				return nil, err
			}
			psql = memMode.Items[0].RealPromql
			unit = "%"
			unitType = types.TypePercent
		case "DiskRate":
			//diskMode, err := s.Store.AlarmRpcClient.ListPromQLs(ctx, server.TemplateMap[server.DiskUsageRate](ipList))
			diskMode, err := s.Store.AlarmRpcClient.ListPromQLs(ctx, db.TemplateMap[db.DiskUsage](v.Region, v.Az, v.Name, v.ResourcePoolType))
			if err != nil {
				return nil, err
			}
			psql = diskMode.Items[0].RealPromql
			unit = "%"
			unitType = types.TypePercent
		case "VcpuRemain": //cpu库存
			cpuRemainMode, err := s.Store.AlarmRpcClient.ListPromQLs(ctx, db.TemplateMap[db.DbVcpuRemainCount](v.Region, v.Az, v.Name, v.ResourcePoolType))
			if err != nil {
				return nil, err
			}
			psql = cpuRemainMode.Items[0].RealPromql
			unit = "核"
			unitType = types.TypeNumber
		case "MemRemain": // 内存库存
			memRemainMode, err := s.Store.AlarmRpcClient.ListPromQLs(ctx, db.TemplateMap[db.DbMemoryRemainCount](v.Region, v.Az, v.Name, v.ResourcePoolType))
			if err != nil {
				return nil, err
			}
			psql = memRemainMode.Items[0].RealPromql
			unit = "B"
			unitType = types.TypeStorage
		case "DiskRemain": // 磁盘库存
			diskRemainMode, err := s.Store.AlarmRpcClient.ListPromQLs(ctx, db.TemplateMap[db.DbDiskRemainCount](v.Region, v.Az, v.Name, v.ResourcePoolType))
			if err != nil {
				return nil, err
			}
			psql = diskRemainMode.Items[0].RealPromql
			unit = "B"
			unitType = types.TypeStorage
		}

		klog.Info("DbPoolOverviewLinePsql  ", psql)
		matrix, err := prom_client.MatrixQuery(ctx, psql, v1.Range{
			Start: time.Unix(start, 0),
			End:   time.Unix(end, 0),
			Step:  time.Duration(step) * time.Second,
		})

		if err != nil {
			fmt.Printf("Error querying Prometheus: %v\n", err)
		}
		line := types.BasicOverviewSlot{}
		line.Info = types.BasicOverviewSlotInfo{
			Index:    0,
			Name:     v.Name,
			Value:    0,
			UnitType: unitType,
			Unit:     unit,
		}
		for _, m := range matrix {
			for _, p := range m.Values {
				timeStamp := p.Timestamp
				value := p.Value
				line.Values = append(line.Values, types.BasicOverviewSlotValue{
					Name:        timeStamp.String(),
					Value:       value,
					Unit:        unit,
					UnitType:    unitType,
					Kind:        "",
					Description: "",
				})
			}
		}

		//添加预测值
		if par.HasPrediction && tools.Contains(predictionMetrics, par.MetricName[0]) != -1 {
			//添加预测值
			line.Info.Prognosis = len(line.Values)
			rangeDuration := strconv.FormatInt(3*(end-start), 10)
			predictDuration := strconv.FormatInt(end-start, 10)
			switch par.MetricName[0] {
			case "VcpuRemain":
				predictSql = db.GetPredictVCpuRemain(v.Name, v.ResourcePoolType, rangeDuration+"s", predictDuration)
			case "MemRemain":
				predictSql = db.GetPredictMemRemain(v.Name, v.ResourcePoolType, rangeDuration+"s", predictDuration)
			case "DiskRemain":
				predictSql = db.GetPredictDiskRemain(v.Name, v.ResourcePoolType, rangeDuration+"s", predictDuration)
			}
			predictMatrix, err := prom_client.MatrixQuery(ctx, predictSql, v1.Range{
				Start: time.Unix(predictStart, 0),
				End:   time.Unix(predictEnd, 0),
				Step:  time.Duration(step) * time.Second,
			})

			if err != nil {
				fmt.Printf("Error querying Prometheus predictMatrix: %v\n", err)
			}
			for _, m := range predictMatrix {
				for _, p := range m.Values {
					timeStamp := p.Timestamp
					value := p.Value
					line.Values = append(line.Values, types.BasicOverviewSlotValue{
						Name:        timeStamp.String(),
						Value:       value,
						Unit:        unit,
						UnitType:    unitType,
						Kind:        "",
						Description: "预测数据",
					})
				}
			}
		}

		lines = append(lines, line)
	}

	return &dto.DbPoolOverviewLineRsp{
		Lines: lines,
	}, nil

}

func formatDuration(duration time.Duration) string {
	days := duration / (24 * time.Hour)
	if days == 1 {
		return "1d"
	} else if days == 7 {
		return "7d"
	} else if days == 30 {
		return "30d"
	} else {
		return fmt.Sprintf("%dd", days)
	}
}

func (s *DbPoolService) DbPoolList(ctx *gin.Context, par dto.DbPoolListReq) (*dto.DbPoolListRsp, error) {

	rpcResult, err := s.Store.DatabaseRpcClient.DbResourcePoolList(ctx, &db_rpc.DbAggregateListRequest{
		Region:       par.Region,
		Az:           par.Az,
		DataBaseType: par.DbType,
		Query:        par.Query,
		PageNo:       1,
		PageSize:     -1,
	})

	if err != nil {
		return nil, err
	}

	var dbPollList []dto.DbPoolList
	for _, v := range rpcResult.Data {
		info := dto.DbPoolList{
			Id:                v.Id,
			Name:              v.Name,
			DbType:            v.DataBaseType,
			Region:            v.Region,
			Az:                v.Az,
			ServerCount:       int(v.ServerCount),
			InstanceTotal:     int(v.InstanceTotal),
			InstanceUsed:      int(v.InstanceUsed),
			AbnormalInstance:  int(v.AbnormalInstance),
			InstanceAvailable: int(v.InstanceAvailable),
			CreateTime:        "",
			AlertNumber:       0,
		}

		if v.DataBaseType == "mysql" {
			info.ResourcePoolType = "rds"
		} else if v.DataBaseType == "redis" {
			info.ResourcePoolType = "kcs"
		}

		var ipList []string
		for _, dbServer := range v.Servers {
			if dbServer.Ip != "" {
				ipList = append(ipList, dbServer.Ip+":9100")
			}
		}
		//获取资源池下服务器状态
		statusPromQL, err := s.Store.AlarmRpcClient.ListPromQLs(ctx, server.TemplateMap[server.Status](ipList))
		if err != nil {
			return nil, err
		}
		//查Prometheus
		status, err := prom_client.VectorQuery(ctx, statusPromQL.Items[0].RealPromql)
		if err != nil {
			return nil, err
		}
		serverMonitorUpStatusMap := prom_client.ParseServerMonitoringStatus(status)
		serverdown := 0
		for _, v := range serverMonitorUpStatusMap {
			if v != "up" {
				serverdown++
			}
		}
		info.AbnormalServerCount = serverdown

		//获取cpu使用率
		cpuMode, err := s.Store.AlarmRpcClient.ListPromQLs(ctx, db.TemplateMap[db.CpuUsage](v.Region, v.Az, v.Name, v.ResourcePoolType))
		if err != nil {
			return nil, err
		}
		cpu, err := prom_client.VectorQuery(ctx, cpuMode.Items[0].RealPromql)
		if err != nil {
			klog.Info(err)
		}
		for _, v := range cpu {
			if math.IsNaN(float64(v.Value)) {
				v.Value = 0
			}
			info.CpuLoad = tools.FormPercent(float64(v.Value))
		}

		//获取内存使用率
		memMode, err := s.Store.AlarmRpcClient.ListPromQLs(ctx, db.TemplateMap[db.MemoryUsage](v.Region, v.Az, v.Name, v.ResourcePoolType))
		if err != nil {
			return nil, err
		}
		mem, err := prom_client.VectorQuery(ctx, memMode.Items[0].RealPromql)
		if err != nil {
			klog.Info(err)
		}
		for _, v := range mem {
			if math.IsNaN(float64(v.Value)) {
				v.Value = 0
			}
			info.MemLoad = tools.FormPercent(float64(v.Value))
		}
		//获取磁盘使用率
		diskMode, err := s.Store.AlarmRpcClient.ListPromQLs(ctx, db.TemplateMap[db.DiskUsage](v.Region, v.Az, v.Name, v.ResourcePoolType))
		if err != nil {
			return nil, err
		}
		disk, err := prom_client.VectorQuery(ctx, diskMode.Items[0].RealPromql)
		if err != nil {
			klog.Info(err)
		}
		for _, v := range disk {
			if math.IsNaN(float64(v.Value)) {
				v.Value = 0
			}
			info.DiskLoad = tools.FormPercent(float64(v.Value))
		}

		alertRpcRes, err := s.Store.AlarmRpcClient.ListAlerts(ctx, &alarmv1alpha.ListAlertsRequest{
			Region:          v.Region,
			Az:              []string{v.Az},
			ResourceType:    []string{"resourcePool"},
			ResourceSubType: []string{v.ResourcePoolType},
			SearchKey:       "resource",
			SearchValue:     v.Name,
			Status:          "firing",
		})
		info.AlertNumber = int(alertRpcRes.Total)

		dbPollList = append(dbPollList, info)
	}

	//order
	if par.OrderCode != "" && par.OrderType != "" {
		results := utils.Bucket{}
		for i := 0; i < len(dbPollList); i++ {
			results.Slice = append(results.Slice, dbPollList[i])
		}
		time_by := func(a, b interface{}) bool {
			return true
		}
		switch par.OrderCode {
		case "CpuLoad":
			switch par.OrderType {
			case "ASC":
				time_by = func(a, b interface{}) bool {
					return a.(dto.DbPoolList).CpuLoad < b.(dto.DbPoolList).CpuLoad
				}
			case "DESC":
				time_by = func(a, b interface{}) bool {
					return a.(dto.DbPoolList).CpuLoad > b.(dto.DbPoolList).CpuLoad
				}
			}
		case "MemLoad":
			switch par.OrderType {
			case "ASC":
				time_by = func(a, b interface{}) bool {
					return a.(dto.DbPoolList).MemLoad < b.(dto.DbPoolList).MemLoad
				}
			case "DESC":
				time_by = func(a, b interface{}) bool {
					return a.(dto.DbPoolList).MemLoad > b.(dto.DbPoolList).MemLoad
				}
			}
		case "DiskLoad":
			switch par.OrderType {
			case "ASC":
				time_by = func(a, b interface{}) bool {
					return a.(dto.DbPoolList).DiskLoad < b.(dto.DbPoolList).DiskLoad
				}
			case "DESC":
				time_by = func(a, b interface{}) bool {
					return a.(dto.DbPoolList).DiskLoad > b.(dto.DbPoolList).DiskLoad
				}
			}
		}
		results.By = time_by
		sort.Sort(results)
		for i := 0; i < len(results.Slice); i++ {
			dbPollList[i] = results.Slice[i].(dto.DbPoolList)
		}
	}

	//分页
	low := (par.PageNo - 1) * par.PageSize
	if low > len(dbPollList) {
		klog.Info("PageSize is too large")
	}

	hight := low + par.PageSize
	if hight > len(dbPollList) {
		hight = len(dbPollList)
	}

	var results dto.DbPoolListRsp
	results.PageSize = par.PageSize
	results.PageNo = par.PageNo
	results.TotalCount = int64(len(dbPollList))
	results.List = dbPollList[low:hight]

	return &results, nil
}

func (s *DbPoolService) DbPoolDetailsLine(ctx *gin.Context, par dto.DbPoolDetailsLineReq) (*dto.DbPoolDetailsLineRsp, error) {

	rpcResult, err := s.Store.DatabaseRpcClient.DbResourcePoolList(ctx, &db_rpc.DbAggregateListRequest{
		Id:       par.Id,
		PageNo:   1,
		PageSize: -1,
		Az:       []string{},
	})

	if err != nil {
		return nil, err
	}

	var lines []types.BasicOverviewSlot

	start := par.Start / 1e3
	end := par.End / 1e3
	step := tools.TimeToStepForInt(end - start)

	for _, host := range rpcResult.Data[0].Servers {
		if host.Ip != "" {
			var psql string
			ip := host.Ip + ":9100"
			var unitType string
			var unit string
			unitType = types.TypePercent
			unit = "%"
			switch par.MetricName[0] {
			case "CpuRate":
				cpuMode, err := s.Store.AlarmRpcClient.ListPromQLs(ctx, server.TemplateMap[server.CpuUsageSumRate]([]string{ip}))
				if err != nil {
					return nil, err
				}
				psql = cpuMode.Items[0].RealPromql
			case "MemRate":
				cpuMode, err := s.Store.AlarmRpcClient.ListPromQLs(ctx, server.TemplateMap[server.MemUsageRate]([]string{ip}))
				if err != nil {
					return nil, err
				}
				psql = cpuMode.Items[0].RealPromql
			case "MemUsage":
				cpuMode, err := s.Store.AlarmRpcClient.ListPromQLs(ctx, server.TemplateMap[server.MemUsage]([]string{ip}))
				if err != nil {
					return nil, err
				}
				psql = cpuMode.Items[0].RealPromql
				unitType = types.TypeStorage
				unit = "B"
			case "DiskRate":
				cpuMode, err := s.Store.AlarmRpcClient.ListPromQLs(ctx, server.TemplateMap[server.DiskUsageRate]([]string{ip}))
				if err != nil {
					return nil, err
				}
				psql = cpuMode.Items[0].RealPromql
			case "DiskUsage":
				cpuMode, err := s.Store.AlarmRpcClient.ListPromQLs(ctx, server.TemplateMap[server.DiskUsage]([]string{ip}))
				if err != nil {
					return nil, err
				}
				psql = cpuMode.Items[0].RealPromql
				unitType = types.TypeStorage
				unit = "B"
			}

			matrix, err := prom_client.MatrixQuery(ctx, psql, v1.Range{
				Start: time.Unix(start, 0),
				End:   time.Unix(end, 0),
				Step:  time.Duration(step) * time.Second,
			})

			if err != nil {
				fmt.Printf("Error querying Prometheus: %v\n", err)
			}

			line := types.BasicOverviewSlot{}
			for _, m := range matrix {
				for _, p := range m.Values {
					timeStamp := p.Timestamp
					value := p.Value
					line.Values = append(line.Values, types.BasicOverviewSlotValue{
						Name:        timeStamp.String(),
						Value:       value,
						Unit:        unit,
						UnitType:    unitType,
						Kind:        "",
						Description: "",
					})
				}
			}

			line.Info = types.BasicOverviewSlotInfo{
				Index:    0,
				Name:     host.HostName,
				Value:    0,
				UnitType: unitType,
				Unit:     unit,
			}
			lines = append(lines, line)
		}
	}

	return &dto.DbPoolDetailsLineRsp{
		Lines: lines,
	}, nil
}

```

File path: /Users/mac/Desktop/woker_code/monitor/modules/blockstorage/dto/ebs_volume_response.go
```golang
package dto

import "ezone.ksyun.com/ezone/luban/monitor/common/types"

type EbsVolumeOverviewTopRsp struct {
	Tops []types.BasicOverviewSlot `json:"Tops"`
}

type EbsVolumeOverviewRsp struct {
	EbsStorageUse           []types.BasicOverviewSlot `json:"EbsStorageUse"`
	EbsVolumePlatformCounts []types.BasicOverviewSlot `json:"EbsVolumePlatformCounts"`
	EbsVolumeBusinessCounts []types.BasicOverviewSlot `json:"EbsVolumeBusinessCounts"`
}

type EbsVolumeDetailMetricRsp struct {
	ResourceOverview []EbsVolumeDetailMetric `json:"ResourceOverview"`
}

type EbsVolumeDetailMetric struct {
	PoolId   string      `json:"PoolId"`
	Name     string      `json:"Name"`
	Unit     string      `json:"Unit"`
	UnitType string      `json:"UnitType"`
	Value    interface{} `json:"Value"`
	Kind     string      `json:"Kind"`
}

type EbsVolumeDetailMetricLineRsp struct {
	Lines []types.BasicOverviewSlot `json:"Lines"`
}

```

File path: /Users/mac/Desktop/woker_code/monitor/modules/blockstorage/dto/ebs_volume_request.go
```golang
package dto

type EbsVolumeOverviewTopReq struct {
	Region     string   `json:"Region"`
	Az         string   `json:"Az"`
	MetricName []string `json:"MetricName"`
	TopK       int      `jons:"TopK"`
	Start      int64    `json:"Start"`
	End        int64    `json:"End"`
	DiskType   string   `json:"DiskType"`
}

type EbsVolumeOverviewReq struct {
	Region   string `json:"Region"`
	Az       string `json:"Az"`
	DiskType string `json:"DiskType"`
}

type EbsVolumeDetailMetricReq struct {
	Id string `json:"Id"`
}

type EbsVolumeDetailMetricLineReq struct {
	Id         string   `json:"Id"`
	Start      int64    `json:"Start"`
	End        int64    `json:"End"`
	MetricName []string `json:"MetricName"`
}

```

File path: /Users/mac/Desktop/woker_code/monitor/modules/blockstorage/dto/ebs_pool_request.go
```golang
package dto

// EbsPoolOverviewAlertReq 块存储资源池概览告警请求
type EbsPoolOverviewAlertReq struct {
	Region   string `json:"Region"`
	Az       string `json:"Az"`
	PoolType string `json:"PoolType"`
}

// EbsPoolOverviewReq 块存储资源池总览概览
type EbsPoolOverviewReq struct {
	Region   string `json:"Region"`
	Az       string `json:"Az"`
	PoolType string `json:"PoolType"`
}

type EbsPoolOverviewLineReq struct {
	PoolType      string   `json:"PoolType"`
	Region        string   `json:"Region"`
	Az            string   `json:"Az"`
	MetricName    []string `json:"MetricName"`
	Start         int64    `json:"Start"`
	End           int64    `json:"End"`
	HasPrediction bool     `json:"HasPrediction"`
}

type EbsPoolListReq struct {
	PageNo    int               `json:"PageNo"`
	PageSize  int               `json:"PageSize"`
	Region    string            `json:"Region"`
	Az        []string          `json:"Az"`
	OrderCode string            `json:"OrderCode"`
	OrderType string            `json:"OrderType"`
	PoolType  []string          `json:"PoolType"`
	Query     map[string]string `json:"Query"`
}

type EbsPoolDetailMetricReq struct {
	PoolId string `json:"PoolId"`
}

type EbsPoolDetailMetricLineReq struct {
	PoolType   string   `json:"PoolType"`
	Region     string   `json:"Region"`
	Az         string   `json:"Az"`
	MetricName []string `json:"MetricName"`
	Start      int64    `json:"Start"`
	End        int64    `json:"End"`
}

```

File path: /Users/mac/Desktop/woker_code/monitor/modules/blockstorage/dto/ebs_pool_response.go
```golang
package dto

import "ezone.ksyun.com/ezone/luban/monitor/common/types"

// EbsPoolOverviewAlertRsp 块存储资源池概览告警响应
type EbsPoolOverviewAlertRsp struct {
	Alerts []types.BasicOverviewSlot `json:"Alerts"`
}

type EbsPoolOverviewRsp struct {
	EbsPools                []types.BasicOverviewSlot `json:"EbsPools"`
	EbsVolumePlatformCounts []types.BasicOverviewSlot `json:"EbsVolumePlatformCounts"`
	EbsVolumeBusinessCounts []types.BasicOverviewSlot `json:"EbsVolumeBusinessCounts"`
}

type EbsPoolOverviewLineRsp struct {
	Lines []types.BasicOverviewSlot `json:"Lines"`
}

type EbsPoolListRsp struct {
	TotalCount int               `json:"TotalCount"`
	PageNo     int               `json:"PageNo"`
	PageSize   int               `json:"PageSize"`
	DataList   []*EbsPoolMonitor `json:"DataList"`
}

type EbsPoolMonitor struct {
	Id                string      `json:"Id"`
	Name              string      `json:"Name"`
	Region            string      `json:"Region"`
	Az                string      `json:"Az"`
	PoolType          string      `json:"PoolType"`
	ServerCount       int         `json:"ServerCount"`
	CloudDiskCount    int         `json:"CloudDiskCount"`
	CapacityTotal     float64     `json:"CapacityTotal"`
	CapacityAvailable float64     `json:"CapacityAvailable"`
	CapacityUsedRate  float64     `json:"CapacityUsedRate"`
	ErrorRate         float64     `json:"ErrorRate"`
	IOInput           interface{} `json:"IOInput"`
	IODelay           interface{} `json:"IODelay"`
	Bandwidth         interface{} `json:"Bandwidth"`
	CreateTime        int64       `json:"CreateTime"`
	AlertCount        int         `json:"AlertCount"`
}

type EbsPoolDetailMetricRsp struct {
	ResourceOverview []EbsPoolDetailMetric `json:"ResourceOverview"`
}

type EbsPoolDetailMetric struct {
	PoolId   string      `json:"PoolId"`
	Name     string      `json:"Name"`
	Unit     string      `json:"Unit"`
	UnitType string      `json:"UnitType"`
	Value    interface{} `json:"Value"`
	Kind     string      `json:"Kind"`
}

type EbsPoolDetailMetricLineRsp struct {
	Lines []types.BasicOverviewSlot `json:"Lines"`
}

// OptionalEbsPoolResult 可选项列表
type OptionalEbsPoolResult map[string]any

```

File path: /Users/mac/Desktop/woker_code/monitor/modules/blockstorage/dao/metric_top.go
```golang
package dao

import (
	"ezone.ksyun.com/ezone/luban/communal/lib"
	"ezone.ksyun.com/ezone/luban/monitor/common/gormSerializer"
	"ezone.ksyun.com/ezone/luban/monitor/modules/blockstorage/model"
	"gorm.io/gorm"
	"gorm.io/gorm/schema"
)

type MetricTopDao struct {
	db *gorm.DB
}

type QueryParams struct {
	Region string
	Az     string
	Code   string
}

func NewMetricTopDao() *MetricTopDao {
	schema.RegisterSerializer("json_str", gormSerializer.JSONSerializer{})
	return &MetricTopDao{
		db: lib.GORMMapPool["business"],
	}
}

func (m *MetricTopDao) GetOneByCode(q QueryParams) (model.MonitorTop, error) {
	var data model.MonitorTop
	if err := m.db.Where("region = ? AND az = ? AND code = ?", q.Region, q.Az, q.Code).First(&data).Error; err != nil {
		return data, err
	}
	return data, nil
}

```

File path: /Users/mac/Desktop/woker_code/monitor/modules/blockstorage/dao/store.go
```golang
package dao

import (
	"ezone.ksyun.com/ezone/luban/communal/lib"
	alarmv1alpha "ezone.ksyun.com/ezone/luban/luban_api/alarmapis/alarm/v1alpha/gen"
	resource_blockstoragev1alpha "ezone.ksyun.com/ezone/luban/luban_api/resourceapis/resource_blockstorage/v1alpha/gen"
	resource_serverv1alpha "ezone.ksyun.com/ezone/luban/luban_api/resourceapis/resource_server/v1alpha/gen"
	"ezone.ksyun.com/ezone/luban/monitor/common/client/grpcx"
)

type Store interface {
	// DAO 服务
	Metric() *MetricDao
	MetricTop() *MetricTopDao

	AlarmRpcClient() alarmv1alpha.AlarmServiceClient
	EbsPoolRpcClient() resource_blockstoragev1alpha.EbsPoolServiceClient
	EbsVolumeRpcClient() resource_blockstoragev1alpha.EbsVolumeServiceClient
	ServerRpcClient() resource_serverv1alpha.ResourceServiceClient
}

type blockStorageStore struct{}

func NewBlockStorageStore() *blockStorageStore {
	return &blockStorageStore{}
}

func (n *blockStorageStore) Metric() *MetricDao {
	return NewMetricDao()
}

func (n *blockStorageStore) MetricTop() *MetricTopDao {
	return NewMetricTopDao()
}

func (n *blockStorageStore) AlarmRpcClient() alarmv1alpha.AlarmServiceClient {
	alarmAddr := lib.GetStringConf("base.grpc.alarm")
	alarmConn, err := grpcx.NewGrpcClientConn(alarmAddr)
	if err != nil {
		lib.Log.TagError(lib.NewTrace(), lib.DLTagUndefind, map[string]interface{}{"connect alarm grpc server error, %s": err.Error()})
	}
	return alarmv1alpha.NewAlarmServiceClient(alarmConn)
}

func (n *blockStorageStore) EbsPoolRpcClient() resource_blockstoragev1alpha.EbsPoolServiceClient {
	resourceAddr := lib.GetStringConf("base.grpc.luban_resource")
	resourceConn, err := grpcx.NewGrpcClientConn(resourceAddr)
	if err != nil {
		lib.Log.TagError(lib.NewTrace(), lib.DLTagUndefind, map[string]interface{}{"connect luban_resource grpc server error, %s": err.Error()})
	}
	return resource_blockstoragev1alpha.NewEbsPoolServiceClient(resourceConn)
}

func (n *blockStorageStore) EbsVolumeRpcClient() resource_blockstoragev1alpha.EbsVolumeServiceClient {
	resourceAddr := lib.GetStringConf("base.grpc.luban_resource")
	resourceConn, err := grpcx.NewGrpcClientConn(resourceAddr)
	if err != nil {
		lib.Log.TagError(lib.NewTrace(), lib.DLTagUndefind, map[string]interface{}{"connect luban_resource grpc server error, %s": err.Error()})
	}
	return resource_blockstoragev1alpha.NewEbsVolumeServiceClient(resourceConn)
}

func (n *blockStorageStore) ServerRpcClient() resource_serverv1alpha.ResourceServiceClient {
	resourceAddr := lib.GetStringConf("base.grpc.luban_resource")
	resourceConn, err := grpcx.NewGrpcClientConn(resourceAddr)
	if err != nil {
		lib.Log.TagError(lib.NewTrace(), lib.DLTagUndefind, map[string]interface{}{"connect luban_resource grpc server error, %s": err.Error()})
	}
	return resource_serverv1alpha.NewResourceServiceClient(resourceConn)
}

```

File path: /Users/mac/Desktop/woker_code/monitor/modules/blockstorage/dao/metric.go
```golang
package dao

import (
	"ezone.ksyun.com/ezone/luban/communal/lib"
	"ezone.ksyun.com/ezone/luban/monitor/modules/blockstorage/model"
	"gorm.io/gorm"
)

type MetricDao struct {
	db *gorm.DB
}

func NewMetricDao() *MetricDao {
	return &MetricDao{
		db: lib.GORMMapPool["business"],
	}
}

func (m *MetricDao) GetOneByCode(code string) (*model.MonitorTsdbMetrics, error) {
	content := model.MonitorTsdbMetrics{}
	err := m.db.Where("code = ?", code).Find(&content).Error
	if err != nil {
		lib.Log.TagError(lib.NewTrace(), lib.DLTagMySqlFailed, map[string]interface{}{"error": err.Error()})
		return nil, err
	}
	return &content, nil
}

// get list by codes
func (m *MetricDao) GetListByCodes(codes []string) ([]model.MonitorTsdbMetrics, error) {
	var content []model.MonitorTsdbMetrics
	err := m.db.Where("code in (?)", codes).Find(&content).Error
	if err != nil {
		lib.Log.TagError(lib.NewTrace(), lib.DLTagMySqlFailed, map[string]interface{}{"error": err.Error()})
		return nil, err
	}
	return content, nil
}

```

File path: /Users/mac/Desktop/woker_code/monitor/modules/blockstorage/utils/tools.go
```golang
package utils

func TimeToStepForInt(fileSize int64) (size int) {
	//处理的单位是秒
	if fileSize >= 0 {
		if fileSize <= (3600.0 * 3.0) {
			return 60 //1m
		} else if fileSize <= (3600.0 * 24.0 * 7) {
			return 3600 //1h
		} else {
			return 86400 //1d
		}
	}
	return 0
}

```

File path: /Users/mac/Desktop/woker_code/monitor/modules/blockstorage/utils/collection/set.go
```golang
package collection

import (
	"fmt"
)

const (
	unmanaged = iota
	untyped
	intType
	int64Type
	uintType
	uint64Type
	stringType
)

// PlaceholderType represents a placeholder type.
type PlaceholderType = struct{}

// Set is not thread-safe, for concurrent use, make sure to use it with synchronization.
type Set struct {
	data map[interface{}]PlaceholderType
	tp   int
}

// NewSet returns a managed Set, can only put the values with the same type.
func NewSet() *Set {
	return &Set{
		data: make(map[interface{}]PlaceholderType),
		tp:   untyped,
	}
}

// NewUnmanagedSet returns a unmanaged Set, which can put values with different types.
func NewUnmanagedSet() *Set {
	return &Set{
		data: make(map[interface{}]PlaceholderType),
		tp:   unmanaged,
	}
}

// Add adds i into s.
func (s *Set) Add(i ...interface{}) {
	for _, each := range i {
		s.add(each)
	}
}

// AddInt adds int values ii into s.
func (s *Set) AddInt(ii ...int) {
	for _, each := range ii {
		s.add(each)
	}
}

// AddInt64 adds int64 values ii into s.
func (s *Set) AddInt64(ii ...int64) {
	for _, each := range ii {
		s.add(each)
	}
}

// AddUint adds uint values ii into s.
func (s *Set) AddUint(ii ...uint) {
	for _, each := range ii {
		s.add(each)
	}
}

// AddUint64 adds uint64 values ii into s.
func (s *Set) AddUint64(ii ...uint64) {
	for _, each := range ii {
		s.add(each)
	}
}

// AddStr adds string values ss into s.
func (s *Set) AddStr(ss ...string) {
	for _, each := range ss {
		s.add(each)
	}
}

// Contains checks if i is in s.
func (s *Set) Contains(i interface{}) bool {
	if len(s.data) == 0 {
		return false
	}

	s.validate(i)
	_, ok := s.data[i]
	return ok
}

// Keys returns the keys in s.
func (s *Set) Keys() []interface{} {
	var keys []interface{}

	for key := range s.data {
		keys = append(keys, key)
	}

	return keys
}

// KeysInt returns the int keys in s.
func (s *Set) KeysInt() []int {
	var keys []int

	for key := range s.data {
		if intKey, ok := key.(int); ok {
			keys = append(keys, intKey)
		}
	}

	return keys
}

// KeysInt64 returns int64 keys in s.
func (s *Set) KeysInt64() []int64 {
	var keys []int64

	for key := range s.data {
		if intKey, ok := key.(int64); ok {
			keys = append(keys, intKey)
		}
	}

	return keys
}

// KeysUint returns uint keys in s.
func (s *Set) KeysUint() []uint {
	var keys []uint

	for key := range s.data {
		if intKey, ok := key.(uint); ok {
			keys = append(keys, intKey)
		}
	}

	return keys
}

// KeysUint64 returns uint64 keys in s.
func (s *Set) KeysUint64() []uint64 {
	var keys []uint64

	for key := range s.data {
		if intKey, ok := key.(uint64); ok {
			keys = append(keys, intKey)
		}
	}

	return keys
}

// KeysStr returns string keys in s.
func (s *Set) KeysStr() []string {
	var keys []string

	for key := range s.data {
		if strKey, ok := key.(string); ok {
			keys = append(keys, strKey)
		}
	}

	return keys
}

// Remove removes i from s.
func (s *Set) Remove(i interface{}) {
	s.validate(i)
	delete(s.data, i)
}

// Count returns the number of items in s.
func (s *Set) Count() int {
	return len(s.data)
}

func (s *Set) add(i interface{}) {
	switch s.tp {
	case unmanaged:
		// do nothing
	case untyped:
		s.setType(i)
	default:
		s.validate(i)
	}
	s.data[i] = PlaceholderType{}
}

func (s *Set) setType(i interface{}) {
	// s.tp can only be untyped here
	switch i.(type) {
	case int:
		s.tp = intType
	case int64:
		s.tp = int64Type
	case uint:
		s.tp = uintType
	case uint64:
		s.tp = uint64Type
	case string:
		s.tp = stringType
	}
}

func (s *Set) validate(i interface{}) {
	if s.tp == unmanaged {
		return
	}

	switch i.(type) {
	case int:
		if s.tp != intType {
			fmt.Errorf("Error: element is int, but set contains elements with type %d", s.tp)
		}
	case int64:
		if s.tp != int64Type {
			fmt.Errorf("Error: element is int64, but set contains elements with type %d", s.tp)
		}
	case uint:
		if s.tp != uintType {
			fmt.Errorf("Error: element is uint, but set contains elements with type %d", s.tp)
		}
	case uint64:
		if s.tp != uint64Type {
			fmt.Errorf("Error: element is uint64, but set contains elements with type %d", s.tp)
		}
	case string:
		if s.tp != stringType {
			fmt.Errorf("Error: element is string, but set contains elements with type %d", s.tp)
		}
	}
}

```

File path: /Users/mac/Desktop/woker_code/monitor/modules/blockstorage/utils/serializer/register.go
```golang
package serializer

import (
	"gorm.io/gorm/schema"
)

func RegisterSerializer() {
	schema.RegisterSerializer("json_str", JSONSerializer{})
}

```

File path: /Users/mac/Desktop/woker_code/monitor/modules/blockstorage/utils/serializer/json.go
```golang
package serializer

import (
	"context"
	"encoding/json"
	"fmt"
	"reflect"

	"gorm.io/gorm/schema"
)

// JSONSerializer json序列化器
type JSONSerializer struct {
}

// 实现 Scan 方法
func (JSONSerializer) Scan(ctx context.Context, field *schema.Field, dst reflect.Value, dbValue interface{}) (err error) {
	fieldValue := reflect.New(field.FieldType)

	if dbValue != nil {
		var bytes []byte
		switch v := dbValue.(type) {
		case []byte:
			bytes = v
		case string:
			bytes = []byte(v)
		default:
			return fmt.Errorf("failed to unmarshal JSONB value: %#v", dbValue)
		}

		err = json.Unmarshal(bytes, fieldValue.Interface())
	}

	field.ReflectValueOf(ctx, dst).Set(fieldValue.Elem())
	return
}

// 实现 Value 方法
func (JSONSerializer) Value(ctx context.Context, field *schema.Field, dst reflect.Value, fieldValue interface{}) (interface{}, error) {
	return json.Marshal(fieldValue)
}

```

File path: /Users/mac/Desktop/woker_code/monitor/modules/blockstorage/controller/ebs_pool.go
```golang
package controller

import (
	"net/http"

	"ezone.ksyun.com/ezone/luban/communal/lib"
	"ezone.ksyun.com/ezone/luban/monitor/common/consts"
	"ezone.ksyun.com/ezone/luban/monitor/modules/blockstorage/dto"
	"ezone.ksyun.com/ezone/luban/monitor/modules/blockstorage/service"
	"ezone.ksyun.com/ezone/luban/monitor/response"
	"github.com/gin-gonic/gin"
)

type EbsPoolController struct {
	svc service.EbsPoolService
}

func NewEbsPoolController() *EbsPoolController {
	return &EbsPoolController{
		svc: service.NewEbsPoolService(),
	}
}

// OverviewAlert godoc
// @Summary      EbsPool Alert Overview
// @Description  Get EbsPool Alert Overview
// @Tags         EbsPool
// @Accept       json
// @Produce      json
// @Param        body body dto.EbsPoolOverviewAlertReq true "ebsPool Overview Alert Request"
// @Success      200  {object}  dto.EbsPoolOverviewAlertRsp
// @Router       /block_storage/ebs_pool/overview_alert [POST]
func (n *EbsPoolController) OverviewAlert(c *gin.Context) {
	var params dto.EbsPoolOverviewAlertReq
	if err := c.ShouldBind(&params); err != nil {
		lib.Log.TagError(lib.GetTraceContext(c), lib.DLTagRequestOut, map[string]interface{}{"error": err.Error(), "params": params})
		response.Failed(c, http.StatusBadRequest, consts.ParameterError, "参数绑定失败")
		return
	}
	lib.Log.TagInfo(lib.GetTraceContext(c), lib.DLTagResponseSuccess, map[string]interface{}{"params": params})

	// 业务处理
	res, err := n.svc.OverviewAlert(c, params)
	if err != nil {
		lib.Log.TagError(lib.GetTraceContext(c), lib.DLTagResponseFailed, map[string]interface{}{"error": err.Error()})
		response.Failed(c, http.StatusInternalServerError, consts.GainFail, "获取块存储概览告警信息失败")
		return
	}

	lib.Log.TagInfo(lib.GetTraceContext(c), lib.DLTagResponseSuccess, map[string]interface{}{"res": res})
	response.Success(c, res)
}

// Overview godoc
// @Summary      EbsPool  Overview
// @Description  Get EbsPool  Overview
// @Tags         EbsPool
// @Accept       json
// @Produce      json
// @Param        body body dto.EbsPoolOverviewReq true "ebsPool Overview Request"
// @Success      200  {object}  dto.EbsPoolOverviewRsp
// @Router       /block_storage/ebs_pool/overview [POST]
func (n *EbsPoolController) Overview(c *gin.Context) {
	var params dto.EbsPoolOverviewReq
	if err := c.ShouldBind(&params); err != nil {
		lib.Log.TagError(lib.GetTraceContext(c), lib.DLTagRequestOut, map[string]interface{}{"error": err.Error(), "params": params})
		response.Failed(c, http.StatusBadRequest, consts.ParameterError, "参数绑定失败")
		return
	}
	lib.Log.TagInfo(lib.GetTraceContext(c), lib.DLTagResponseSuccess, map[string]interface{}{"params": params})

	// 业务处理
	res, err := n.svc.Overview(c, params)
	if err != nil {
		lib.Log.TagError(lib.GetTraceContext(c), lib.DLTagResponseFailed, map[string]interface{}{"error": err.Error()})
		response.Failed(c, http.StatusInternalServerError, consts.GainFail, "获取块存储概览信息失败")
		return
	}

	lib.Log.TagInfo(lib.GetTraceContext(c), lib.DLTagResponseSuccess, map[string]interface{}{"res": res})
	response.Success(c, res)
}

// OverviewLine godoc
// @Summary      EbsPool OverviewLine
// @Description  Get EbsPool Overview
// @Tags         EbsPool
// @Accept       json
// @Produce      json
// @Param        body body dto.EbsPoolOverviewLineReq true "ebsPool OverviewLine Request"
// @Success      200  {object}  dto.EbsPoolOverviewLineRsp
// @Router       /block_storage/ebs_pool/overview_line [POST]
func (n *EbsPoolController) OverviewLine(c *gin.Context) {
	var params dto.EbsPoolOverviewLineReq
	if err := c.ShouldBind(&params); err != nil {
		lib.Log.TagError(lib.GetTraceContext(c), lib.DLTagRequestOut, map[string]interface{}{"error": err.Error(), "params": params})
		response.Failed(c, http.StatusBadRequest, consts.ParameterError, "参数绑定失败")
		return
	}
	lib.Log.TagInfo(lib.GetTraceContext(c), lib.DLTagResponseSuccess, map[string]interface{}{"params": params})

	// 业务处理
	res, err := n.svc.OverviewLine(c, params)
	if err != nil {
		lib.Log.TagError(lib.GetTraceContext(c), lib.DLTagResponseFailed, map[string]interface{}{"error": err.Error()})
		response.Failed(c, http.StatusInternalServerError, consts.GainFail, "获取块存储概览线信息失败")
		return
	}

	lib.Log.TagInfo(lib.GetTraceContext(c), lib.DLTagResponseSuccess, map[string]interface{}{"res": res})
	response.Success(c, res)
}

// List godoc
// @Summary      EbsPool List
// @Description  Get EbsPool List
// @Tags         EbsPool
// @Accept       json
// @Produce      json
// @Param        body body dto.EbsPoolListReq true "ebsPool List Request"
// @Success      200  {object}  dto.EbsPoolListReq
// @Router       /block_storage/ebs_pool/list [POST]
func (n *EbsPoolController) List(c *gin.Context) {
	var params dto.EbsPoolListReq
	if err := c.ShouldBind(&params); err != nil {
		lib.Log.TagError(lib.GetTraceContext(c), lib.DLTagRequestOut, map[string]interface{}{"error": err.Error(), "params": params})
		response.Failed(c, http.StatusBadRequest, consts.ParameterError, "参数绑定失败")
		return
	}
	lib.Log.TagInfo(lib.GetTraceContext(c), lib.DLTagResponseSuccess, map[string]interface{}{"params": params})

	// 业务处理
	res, err := n.svc.List(c, params)
	if err != nil {
		lib.Log.TagError(lib.GetTraceContext(c), lib.DLTagResponseFailed, map[string]interface{}{"error": err.Error()})
		response.Failed(c, http.StatusInternalServerError, consts.GainFail, "获取块存储列表信息失败")
		return
	}

	lib.Log.TagInfo(lib.GetTraceContext(c), lib.DLTagResponseSuccess, map[string]interface{}{"res": res})
	response.Success(c, res)
}

// DetailMetricOverview godoc
// @Summary      EbsPool DetailMetricOverview
// @Description  Get EbsPool DetailMetricOverview
// @Tags         EbsPool
// @Accept       json
// @Produce      json
// @Param        body body dto.EbsPoolDetailMetricReq true "ebsPool DetailMetricOverview Request"
// @Success      200  {object}  dto.EbsPoolDetailMetricRsp
// @Router       /block_storage/ebs_pool/detail_metric_overview [POST]
func (n *EbsPoolController) DetailMetricOverview(c *gin.Context) {
	var params dto.EbsPoolDetailMetricReq
	if err := c.ShouldBind(&params); err != nil {
		lib.Log.TagError(lib.GetTraceContext(c), lib.DLTagRequestOut, map[string]interface{}{"error": err.Error(), "params": params})
		response.Failed(c, http.StatusBadRequest, consts.ParameterError, "参数绑定失败")
		return
	}
	lib.Log.TagInfo(lib.GetTraceContext(c), lib.DLTagResponseSuccess, map[string]interface{}{"params": params})

	// 业务处理
	res, err := n.svc.DetailMetricOverview(c, params)
	if err != nil {
		lib.Log.TagError(lib.GetTraceContext(c), lib.DLTagResponseFailed, map[string]interface{}{"error": err.Error()})
		response.Failed(c, http.StatusInternalServerError, consts.GainFail, "获取块存储详情-监控指标-详情概览信息失败")
		return
	}

	lib.Log.TagInfo(lib.GetTraceContext(c), lib.DLTagResponseSuccess, map[string]interface{}{"res": res})
	response.Success(c, res)
}

// DetailMetricLines godoc
// @Summary      EbsPool DetailMetricLine
// @Description  Get EbsPool DetailMetricLine
// @Tags         EbsPool
// @Accept       json
// @Produce      json
// @Param        body body dto.EbsPoolDetailMetricLineReq true "ebsPool DetailMetricLine Request"
// @Success      200  {object}  dto.EbsPoolDetailMetricLineRsp
// @Router       /block_storage/ebs_pool/detail_metric_lines [POST]
func (n *EbsPoolController) DetailMetricLines(c *gin.Context) {
	var params dto.EbsPoolDetailMetricLineReq
	if err := c.ShouldBind(&params); err != nil {
		lib.Log.TagError(lib.GetTraceContext(c), lib.DLTagRequestOut, map[string]interface{}{"error": err.Error(), "params": params})
		response.Failed(c, http.StatusBadRequest, consts.ParameterError, "参数绑定失败")
		return
	}
	lib.Log.TagInfo(lib.GetTraceContext(c), lib.DLTagResponseSuccess, map[string]interface{}{"params": params})

	// 业务处理
	res, err := n.svc.DetailMetricLine(c, params)
	if err != nil {
		lib.Log.TagError(lib.GetTraceContext(c), lib.DLTagResponseFailed, map[string]interface{}{"error": err.Error()})
		response.Failed(c, http.StatusInternalServerError, consts.GainFail, "获取块存储详情-监控指标-监控线信息失败")
		return
	}

	lib.Log.TagInfo(lib.GetTraceContext(c), lib.DLTagResponseSuccess, map[string]interface{}{"res": res})
	response.Success(c, res)
}

// ListOptionalCondition godoc
// @Summary      EbsPool ListOptionalCondition
// @Description  Get EbsPool ListOptionalCondition
// @Tags         EbsPool
// @Accept       json
// @Produce      json
// @Success      200  {object}  dto.OptionalEbsPoolResult
// @Router       /block_storage/ebs_pool/list_optional_condition [GET]
func (n *EbsPoolController) ListOptionalCondition(c *gin.Context) {
	// 业务处理
	res, err := n.svc.GetListOptionalCondition(c)
	if err != nil {
		lib.Log.TagError(lib.GetTraceContext(c), lib.DLTagResponseFailed, map[string]interface{}{"error": err.Error()})
		response.Failed(c, http.StatusInternalServerError, consts.GainFail, "获取可选列表信息失败")
		return
	}

	lib.Log.TagInfo(lib.GetTraceContext(c), lib.DLTagResponseSuccess, map[string]interface{}{"res": res})
	response.Success(c, res)
}

```

File path: /Users/mac/Desktop/woker_code/monitor/modules/blockstorage/controller/ebs_volume.go
```golang
package controller

import (
	"net/http"

	"ezone.ksyun.com/ezone/luban/communal/lib"
	"ezone.ksyun.com/ezone/luban/monitor/common/consts"
	"ezone.ksyun.com/ezone/luban/monitor/modules/blockstorage/dto"
	"ezone.ksyun.com/ezone/luban/monitor/modules/blockstorage/service"
	"ezone.ksyun.com/ezone/luban/monitor/response"
	"github.com/gin-gonic/gin"
)

type EbsVolumeController struct {
	svc service.EbsVolumeService
}

func NewEbsVolumeController() *EbsVolumeController {
	return &EbsVolumeController{
		svc: service.NewEbsVolumeService(),
	}
}

// OverviewTop godoc
// @Summary      EbsVolume OverviewTop
// @Description  Get EbsVolume OverviewTop
// @Tags         EbsVolume
// @Accept       json
// @Produce      json
// @Param        body body dto.EbsVolumeOverviewTopReq true "ebsVolume Overview Top Request"
// @Success      200  {object}  dto.EbsVolumeOverviewTopRsp
// @Router       /block_storage/ebs_volume/overview_top [POST]
func (n *EbsVolumeController) OverviewTop(c *gin.Context) {
	var params dto.EbsVolumeOverviewTopReq
	if err := c.ShouldBind(&params); err != nil {
		lib.Log.TagError(lib.GetTraceContext(c), lib.DLTagRequestOut, map[string]interface{}{"error": err.Error(), "params": params})
		response.Failed(c, http.StatusBadRequest, consts.ParameterError, "参数绑定失败")
		return
	}
	lib.Log.TagInfo(lib.GetTraceContext(c), lib.DLTagResponseSuccess, map[string]interface{}{"params": params})

	// 业务处理
	res, err := n.svc.OverviewTop(c, params)
	if err != nil {
		lib.Log.TagError(lib.GetTraceContext(c), lib.DLTagResponseFailed, map[string]interface{}{"error": err.Error()})
		response.Failed(c, http.StatusInternalServerError, consts.GainFail, "获取云产品-块存储概览TopK信息失败")
		return
	}

	lib.Log.TagInfo(lib.GetTraceContext(c), lib.DLTagResponseSuccess, map[string]interface{}{"res": res})
	response.Success(c, res)
}

// Overview godoc
// @Summary      EbsVolume Overview
// @Description  Get EbsVolume Overview
// @Tags         EbsVolume
// @Accept       json
// @Produce      json
// @Param        body body dto.EbsVolumeOverviewReq true "ebsVolume Overview Request"
// @Success      200  {object}  dto.EbsVolumeOverviewRsp
// @Router       /block_storage/ebs_volume/overview [POST]
func (n *EbsVolumeController) Overview(c *gin.Context) {
	var params dto.EbsVolumeOverviewReq
	if err := c.ShouldBind(&params); err != nil {
		lib.Log.TagError(lib.GetTraceContext(c), lib.DLTagRequestOut, map[string]interface{}{"error": err.Error(), "params": params})
		response.Failed(c, http.StatusBadRequest, consts.ParameterError, "参数绑定失败")
		return
	}
	lib.Log.TagInfo(lib.GetTraceContext(c), lib.DLTagResponseSuccess, map[string]interface{}{"params": params})

	// 业务处理
	res, err := n.svc.Overview(c, params)
	if err != nil {
		lib.Log.TagError(lib.GetTraceContext(c), lib.DLTagResponseFailed, map[string]interface{}{"error": err.Error()})
		response.Failed(c, http.StatusInternalServerError, consts.GainFail, "获取云产品-块存储概览信息失败")
		return
	}

	lib.Log.TagInfo(lib.GetTraceContext(c), lib.DLTagResponseSuccess, map[string]interface{}{"res": res})
	response.Success(c, res)
}

// DetailMetric godoc
// @Summary      EbsVolume DetailMetric
// @Description  Get EbsVolume DetailMetric
// @Tags         EbsVolume
// @Accept       json
// @Produce      json
// @Param        body body dto.EbsVolumeDetailMetricReq true "ebsVolume detail metric Request"
// @Success      200  {object}  dto.EbsVolumeDetailMetricRsp
// @Router       /block_storage/ebs_volume/detail_metric [POST]
func (n *EbsVolumeController) DetailMetric(c *gin.Context) {
	var params dto.EbsVolumeDetailMetricReq
	if err := c.ShouldBind(&params); err != nil {
		lib.Log.TagError(lib.GetTraceContext(c), lib.DLTagRequestOut, map[string]interface{}{"error": err.Error(), "params": params})
		response.Failed(c, http.StatusBadRequest, consts.ParameterError, "参数绑定失败")
		return
	}
	lib.Log.TagInfo(lib.GetTraceContext(c), lib.DLTagResponseSuccess, map[string]interface{}{"params": params})

	// 业务处理
	res, err := n.svc.DetailMetric(c, params)
	if err != nil {
		lib.Log.TagError(lib.GetTraceContext(c), lib.DLTagResponseFailed, map[string]interface{}{"error": err.Error()})
		response.Failed(c, http.StatusInternalServerError, consts.GainFail, "获取云产品-块存储详情指标信息失败")
		return
	}

	lib.Log.TagInfo(lib.GetTraceContext(c), lib.DLTagResponseSuccess, map[string]interface{}{"res": res})
	response.Success(c, res)
}

// DetailMetricLines godoc
// @Summary      EbsVolume DetailMetricLine
// @Description  Get EbsVolume DetailMetricLine
// @Tags         EbsVolume
// @Accept       json
// @Produce      json
// @Param        body body dto.EbsVolumeDetailMetricLineReq true "ebsVolume detail metric Request"
// @Success      200  {object}  dto.EbsVolumeDetailMetricLineRsp
// @Router       /block_storage/ebs_volume/detail_metric_lines [POST]
func (n *EbsVolumeController) DetailMetricLines(c *gin.Context) {
	var params dto.EbsVolumeDetailMetricLineReq
	if err := c.ShouldBind(&params); err != nil {
		lib.Log.TagError(lib.GetTraceContext(c), lib.DLTagRequestOut, map[string]interface{}{"error": err.Error(), "params": params})
		response.Failed(c, http.StatusBadRequest, consts.ParameterError, "参数绑定失败")
		return
	}
	lib.Log.TagInfo(lib.GetTraceContext(c), lib.DLTagResponseSuccess, map[string]interface{}{"params": params})

	// 业务处理
	res, err := n.svc.DetailMetricLine(c, params)
	if err != nil {
		lib.Log.TagError(lib.GetTraceContext(c), lib.DLTagResponseFailed, map[string]interface{}{"error": err.Error()})
		response.Failed(c, http.StatusInternalServerError, consts.GainFail, "获取云产品-块存储详情指标线信息失败")
		return
	}

	lib.Log.TagInfo(lib.GetTraceContext(c), lib.DLTagResponseSuccess, map[string]interface{}{"res": res})
	response.Success(c, res)
}

```

File path: /Users/mac/Desktop/woker_code/monitor/modules/blockstorage/constant/constant.go
```golang
package constant

var EbsVolumeStatusMap = map[string]string{
	"creating":        "创建中",
	"available":       "待挂载",
	"attaching":       "挂载中",
	"in-use":          "使用中",
	"detaching":       "卸载中",
	"extending":       "扩容中",
	"deleting":        "删除中",
	"error":           "错误",
	"error_attaching": "挂载失败",
	"error_detaching": "卸载失败",
	"error_deleting":  "删除失败",
	"error_extending": "扩容失败",
	"deleted":         "已删除",
	"recycling":       "回收中",
	"rollbacking":     "回滚中",
}

var EbsVolumeUseStatusMap = map[string]string{
	"creating":    "创建中",
	"available":   "待挂载",
	"attaching":   "挂载中",
	"in-use":      "使用中",
	"detaching":   "卸载中",
	"extending":   "扩容中",
	"recycling":   "回收中",
	"rollbacking": "回滚中",
}

var PlatformTenantName = []string{"init_test", "init_user"}

var EbsVolumeTopMap = map[string]string{
	"ebs_volume_band_read":      "读带宽",
	"ebs_volume_band_write":     "写带宽",
	"ebs_volume_io_read":        "读",
	"ebs_volume_io_write":       "写",
	"ebs_volume_io_read_delay":  "读延时",
	"ebs_volume_io_write_delay": "写延时",
}

```

File path: /Users/mac/Desktop/woker_code/monitor/modules/blockstorage/model/monitor_tsdb_metrics.go
```golang
package model

import "time"

type MonitorTsdbMetrics struct {
	ID           int       `gorm:"column:id;primary_key;AUTO_INCREMENT"`
	ProductLine  string    `gorm:"column:product_line;NOT NULL"`  // 产品线
	Code         string    `gorm:"column:code;NOT NULL"`          // 唯一标识
	Name         string    `gorm:"column:name;NOT NULL"`          // 中文名
	MetricPrefix string    `gorm:"column:metric_prefix;NOT NULL"` // metric前缀
	Unit         string    `gorm:"column:unit;NOT NULL;default:''"`
	CreatedAt    time.Time `gorm:"column:created_at;default:CURRENT_TIMESTAMP"`
	UpdatedAt    time.Time `gorm:"column:updated_at;default:CURRENT_TIMESTAMP"`
	DeletedAt    time.Time `gorm:"column:deleted_at"`
}

func (m *MonitorTsdbMetrics) TableName() string {
	return "monitor_tsdb_metrics"
}

```

File path: /Users/mac/Desktop/woker_code/monitor/modules/blockstorage/model/monitor_top.go
```golang
package model

import (
	"time"

	"ezone.ksyun.com/ezone/luban/monitor/common/client/opentsdb"
)

// region + az + code 唯一
type MonitorTop struct {
	ID                  int        `gorm:"column:id;primary_key;AUTO_INCREMENT"`        // 主键
	ProductLine         string     `gorm:"column:product_line;NOT NULL"`                // 产品线
	Region              string     `gorm:"column:region;NOT NULL"`                      // 区域
	Az                  string     `gorm:"column:az;NOT NULL"`                          // 可用区
	Code                string     `gorm:"column:code;NOT NULL"`                        // top项的唯一标识
	Name                string     `gorm:"column:name;NOT NULL"`                        // 中文名
	HalfHour            []TopValue `gorm:"column:half_hour;serializer:json_str"`        // 0.5h top10数据
	HalfHourUpdateAt    time.Time  `gorm:"column:half_hour_update_at"`                  // 0.5h更新时间
	OneHour             []TopValue `gorm:"column:one_hour;serializer:json_str"`         // 1h top10数据
	OneHourUpdateAt     time.Time  `gorm:"column:one_hour_update_at"`                   // 1h更新时间
	ThreeHours          []TopValue `gorm:"column:three_hours;serializer:json_str"`      // 3h top10数据
	ThreeHoursUpdateAt  time.Time  `gorm:"column:three_hours_update_at"`                // 3h更新时间
	TwelveHours         []TopValue `gorm:"column:twelve_hours;serializer:json_str"`     // 12h top10数据
	TwelveHoursUpdateAt time.Time  `gorm:"column:twelve_hours_update_at"`               // 12h更新时间
	OneDay              []TopValue `gorm:"column:one_day;serializer:json_str"`          // 1d top10数据
	OneDayUpdateAt      time.Time  `gorm:"column:one_day_update_at"`                    // 1d更新时间
	SevenDays           []TopValue `gorm:"column:seven_days;serializer:json_str"`       // 7d top10数据
	SevenDaysUpdateAt   time.Time  `gorm:"column:seven_days_update_at"`                 // 7d更新时间
	ThirtyDays          []TopValue `gorm:"column:thirty_days;serializer:json_str"`      // 30d top10数据
	ThirtyDaysUpdateAt  time.Time  `gorm:"column:thirty_days_update_at"`                // 30d更新时间
	CreatedAt           time.Time  `gorm:"column:created_at;default:CURRENT_TIMESTAMP"` // 创建时间
	UpdatedAt           time.Time  `gorm:"column:updated_at;default:CURRENT_TIMESTAMP"` // 更新时间
	DeletedAt           time.Time  `gorm:"column:deleted_at"`                           // 删除时间
}
type TopValue struct {
	Id    string  //实例唯一id
	Name  string  //名称
	Value float64 //值
}

func (m *MonitorTop) TableName() string {
	return "monitor_top"
}

func (m *MonitorTop) ParseIntervalData(start, end int64) []TopValue {
	var intervalData []TopValue
	intervalStr := opentsdb.ParseTimeInterval(start, end)
	switch intervalStr {
	case "0.5h":
		intervalData = m.HalfHour
	case "1h":
		intervalData = m.OneHour
	case "3h":
		intervalData = m.ThreeHours
	case "12h":
		intervalData = m.TwelveHours
	case "1d":
		intervalData = m.OneDay
	case "7d":
		intervalData = m.SevenDays
	case "30d":
		intervalData = m.ThirtyDays
	}
	return intervalData
}

```

File path: /Users/mac/Desktop/woker_code/monitor/modules/blockstorage/service/ebs_pool.go
```golang
package service

import (
	"context"
	"fmt"
	"math"
	"sort"
	"strconv"
	"strings"
	"time"

	"ezone.ksyun.com/ezone/luban/monitor/common/tools"
	"ezone.ksyun.com/ezone/luban/monitor/common/utils"

	"ezone.ksyun.com/ezone/luban/communal/lib"
	alarmv1alpha "ezone.ksyun.com/ezone/luban/luban_api/alarmapis/alarm/v1alpha/gen"
	resource_blockstoragev1alpha "ezone.ksyun.com/ezone/luban/luban_api/resourceapis/resource_blockstorage/v1alpha/gen"
	resource_serverv1alpha "ezone.ksyun.com/ezone/luban/luban_api/resourceapis/resource_server/v1alpha/gen"
	prom_client "ezone.ksyun.com/ezone/luban/monitor/common/client/prom"
	"ezone.ksyun.com/ezone/luban/monitor/common/promql_template/blockstorage"
	"ezone.ksyun.com/ezone/luban/monitor/common/promql_template/server"
	"ezone.ksyun.com/ezone/luban/monitor/common/types"
	"ezone.ksyun.com/ezone/luban/monitor/modules/blockstorage/constant"
	"ezone.ksyun.com/ezone/luban/monitor/modules/blockstorage/dao"
	"ezone.ksyun.com/ezone/luban/monitor/modules/blockstorage/dto"
	blockstorage_utils "ezone.ksyun.com/ezone/luban/monitor/modules/blockstorage/utils"
	"ezone.ksyun.com/ezone/luban/monitor/modules/blockstorage/utils/collection"
	"github.com/gin-gonic/gin"
	"github.com/pkg/errors"
	v1 "github.com/prometheus/client_golang/api/prometheus/v1"
)

var (
	alertLevels     = []string{"p0", "p1", "p2", "p3"}
	alertLevelsName = map[string]string{
		"p0": "紧急告警",
		"p1": "重要告警",
		"p2": "次要告警",
		"p3": "提醒告警",
	}
	alertKinds = map[string]string{
		"p0": types.KindError,
		"p1": types.KindWarn,
		"p2": types.KindMinor,
		"p3": types.KindInfo,
	}
)

type EbsPoolService interface {
	OverviewAlert(ctx context.Context, par dto.EbsPoolOverviewAlertReq) (*dto.EbsPoolOverviewAlertRsp, error)
	Overview(ctx context.Context, par dto.EbsPoolOverviewReq) (*dto.EbsPoolOverviewRsp, error)
	OverviewLine(ctx context.Context, par dto.EbsPoolOverviewLineReq) (*dto.EbsPoolOverviewLineRsp, error)
	List(ctx context.Context, par dto.EbsPoolListReq) (res *dto.EbsPoolListRsp, err error)
	DetailMetricOverview(ctx context.Context, par dto.EbsPoolDetailMetricReq) (*dto.EbsPoolDetailMetricRsp, error)
	DetailMetricLine(ctx context.Context, par dto.EbsPoolDetailMetricLineReq) (*dto.EbsPoolDetailMetricLineRsp, error)
	GetListOptionalCondition(ctx *gin.Context) (*dto.OptionalEbsPoolResult, error)
}

type ebsPoolService struct {
	Store dao.Store
}

func NewEbsPoolService() EbsPoolService {
	return &ebsPoolService{
		Store: dao.NewBlockStorageStore(),
	}
}

func (n *ebsPoolService) OverviewAlert(ctx context.Context, par dto.EbsPoolOverviewAlertReq) (*dto.EbsPoolOverviewAlertRsp, error) {
	//var filters []string
	//
	//if par.Region != "" {
	//	filters = append(filters, fmt.Sprintf("region=%s", par.Region))
	//}
	//if par.Az != "" {
	//	filters = append(filters, fmt.Sprintf("az=%s", par.Az))
	//}
	//// 资源池
	//filters = append(filters, fmt.Sprintf("lubanResourceType=%s", "resourcePool"))
	//// 获取告警
	//alerts, err := alert_client.GetAlertsByFilter(filters)
	//if err != nil {
	//	return nil, err
	//}
	var az []string
	if par.Az != "" {
		az = []string{par.Az}
	}
	alerts, err := n.Store.AlarmRpcClient().ListAlerts(ctx, &alarmv1alpha.ListAlertsRequest{
		PageNo:   -1,
		PageSize: -1,
		Region:   par.Region,
		Status:   "firing",
		Az:       az,
	})
	if err != nil {
		return nil, errors.WithMessage(err, "rpc call AlarmRpcClient.ListAlerts err")
	}

	// 概览数据
	alertSlots := []types.BasicOverviewSlot{}
	for _, level := range alertLevels {
		alertSlot := types.BasicOverviewSlot{
			Info: types.BasicOverviewSlotInfo{
				Code:     par.PoolType,
				Name:     alertLevelsName[level],
				UnitType: types.TypeNumber,
				Unit:     "个",
				Value:    utils.CountAlertsNum(alerts.Items, strings.ToLower(par.PoolType), level),
				Kind:     alertKinds[level],
			},
		}
		alertSlots = append(alertSlots, alertSlot)
	}
	return &dto.EbsPoolOverviewAlertRsp{
		Alerts: alertSlots,
	}, nil
}

func (n *ebsPoolService) Overview(ctx context.Context, par dto.EbsPoolOverviewReq) (*dto.EbsPoolOverviewRsp, error) {
	// 资源池容量
	var (
		usedDiskSize, freeDiskSize int64
		platformStatusCount        = map[string]int64{}
		businessStatusCount        = map[string]int64{}
		ebsPools                   = make([]types.BasicOverviewSlot, 0)
		ebsVolumePlatformCounts    = make([]types.BasicOverviewSlot, 0)
		ebsVolumeBusinessCounts    = make([]types.BasicOverviewSlot, 0)
	)
	ebsPoolStockList, err := n.Store.EbsPoolRpcClient().ListEbsPoolStock(ctx, &resource_blockstoragev1alpha.ListEbsPoolStockReq{
		PoolType: []string{par.PoolType},
	})
	if err != nil {
		lib.Log.TagError(lib.GetTraceContext(ctx), lib.DLTagUndefind, map[string]interface{}{"rpc error": err})
		return nil, err
	}
	if len(ebsPoolStockList.List) == 0 {
		return nil, nil
	}
	ebsPoolStock := ebsPoolStockList.List[0]
	usedDiskSize = ebsPoolStock.TotalDiskCapacity - ebsPoolStock.CapacityAvailabel
	freeDiskSize = ebsPoolStock.CapacityAvailabel
	// 组装业务数据
	storageUse := types.BasicOverviewSlot{
		Info: types.BasicOverviewSlotInfo{
			Index:    0,
			Name:     "存储使用概览",
			Value:    ebsPoolStock.TotalDiskCapacity,
			Unit:     "GB",
			UnitType: "storage",
		},
		Values: make([]types.BasicOverviewSlotValue, 0),
	}
	storageUse.Values = append(storageUse.Values,
		types.BasicOverviewSlotValue{
			Name:     "已使用",
			Value:    usedDiskSize,
			Unit:     "GB",
			UnitType: "storage",
		},
		types.BasicOverviewSlotValue{
			Name:     "可使用",
			Value:    freeDiskSize,
			Unit:     "GB",
			UnitType: "storage",
		},
	)

	// 平台块存储数量
	var platformTotalCount, businessTotalCount int
	for code, status := range constant.EbsVolumeStatusMap {
		var azList []string
		if par.Az != "" {
			azList = append(azList, par.Az)
		}
		ebsVolumePlatformResult, err := n.Store.EbsVolumeRpcClient().ListEbsVolume(ctx, &resource_blockstoragev1alpha.ListVolumeReq{
			PageSize:   -1,
			Region:     par.Region,
			Az:         azList,
			UseStatus:  []string{code},
			VolumeType: []string{par.PoolType},
			TenantName: constant.PlatformTenantName,
		})
		if err != nil {
			lib.Log.TagError(lib.GetTraceContext(ctx), lib.DLTagUndefind, map[string]interface{}{"rpc error": err})
			return nil, err
		}
		// 存在数据进行录入
		if ebsVolumePlatformResult.TotalCount != 0 {
			platformStatusCount[status] = ebsVolumePlatformResult.TotalCount
			platformTotalCount += int(ebsVolumePlatformResult.TotalCount)
		}

		ebsVolumeResult, err := n.Store.EbsVolumeRpcClient().ListEbsVolume(ctx, &resource_blockstoragev1alpha.ListVolumeReq{
			PageSize:   -1,
			Region:     par.Region,
			Az:         azList,
			UseStatus:  []string{code},
			VolumeType: []string{par.PoolType},
		})
		if err != nil {
			lib.Log.TagError(lib.GetTraceContext(ctx), lib.DLTagUndefind, map[string]interface{}{"rpc error": err})
			return nil, err
		}
		if ebsVolumeResult.TotalCount != 0 {
			businessStatusCount[status] = ebsVolumeResult.TotalCount - ebsVolumePlatformResult.TotalCount
			businessTotalCount += int(ebsVolumeResult.TotalCount - ebsVolumePlatformResult.TotalCount)
		}
	}
	ebsVolumePlatformCount := types.BasicOverviewSlot{
		Info: types.BasicOverviewSlotInfo{
			Index:    1,
			Name:     "平台块存储",
			Value:    platformTotalCount,
			Unit:     "个",
			UnitType: "number",
		},
		Values: make([]types.BasicOverviewSlotValue, 0),
	}
	for status, count := range platformStatusCount {
		ebsVolumePlatformCount.Values = append(ebsVolumePlatformCount.Values, types.BasicOverviewSlotValue{
			Name:     status,
			Value:    count,
			Unit:     "个",
			UnitType: "number",
		})
	}
	// 业务块存储
	ebsVolumeBusinessCount := types.BasicOverviewSlot{
		Info: types.BasicOverviewSlotInfo{
			Index:    2,
			Name:     "业务块存储",
			Value:    businessTotalCount,
			Unit:     "个",
			UnitType: "number",
		},
		Values: make([]types.BasicOverviewSlotValue, 0),
	}
	for status, count := range businessStatusCount {
		ebsVolumeBusinessCount.Values = append(ebsVolumeBusinessCount.Values, types.BasicOverviewSlotValue{
			Name:     status,
			Value:    count,
			Unit:     "个",
			UnitType: "number",
		})
	}
	ebsPools = append(ebsPools, storageUse)
	ebsVolumePlatformCounts = append(ebsVolumePlatformCounts, ebsVolumePlatformCount)
	ebsVolumeBusinessCounts = append(ebsVolumeBusinessCounts, ebsVolumeBusinessCount)
	return &dto.EbsPoolOverviewRsp{
		EbsPools:                ebsPools,
		EbsVolumePlatformCounts: ebsVolumePlatformCounts,
		EbsVolumeBusinessCounts: ebsVolumeBusinessCounts,
	}, nil
}

func (n *ebsPoolService) OverviewLine(ctx context.Context, par dto.EbsPoolOverviewLineReq) (*dto.EbsPoolOverviewLineRsp, error) {
	var azList []string
	if par.Az != "" {
		azList = append(azList, par.Az)
	}
	ebsPoolRpcRes, err := n.Store.EbsPoolRpcClient().ListEbsPool(ctx, &resource_blockstoragev1alpha.ListEbsPoolReq{
		Region:   par.Region,
		Az:       azList,
		PoolType: []string{par.PoolType},
	})
	if err != nil {
		lib.Log.TagError(lib.GetTraceContext(ctx), lib.DLTagHTTPFailed, map[string]interface{}{"error": err.Error()})
		return nil, err
	}
	if len(ebsPoolRpcRes.List) == 0 {
		return nil, nil
	}
	ebsPool := ebsPoolRpcRes.List[0]
	lines := make([]types.BasicOverviewSlot, 0)
	predictionMetrics := []string{blockstorage.EbsCapacity}
	for _, metric := range par.MetricName {
		rsp, err := n.Store.AlarmRpcClient().ListPromQLs(ctx, blockstorage.TemplateMap[metric](ebsPool.Region, ebsPool.Az, ebsPool.Name, ebsPool.PoolType))
		if err != nil {
			lib.Log.TagError(lib.GetTraceContext(ctx), lib.DLTagResponseFailed, map[string]interface{}{"error": err.Error()})
			return nil, err
		}
		promQL := rsp.Items[0].RealPromql
		unit := rsp.Items[0].Unit

		matrix, err := prom_client.MatrixQuery(ctx, promQL, v1.Range{
			Start: time.UnixMilli(par.Start),
			End:   time.UnixMilli(par.End),
			Step:  prom_client.TimeToStep(par.End - par.Start),
		})
		if err != nil {
			lib.Log.TagError(lib.GetTraceContext(ctx), lib.DLTagResponseFailed, map[string]interface{}{"error": err.Error()})
			return nil, err
		}
		// 封装结果
		line := types.BasicOverviewSlot{
			Info: types.BasicOverviewSlotInfo{
				Name:     blockstorage.MetricMap[metric],
				UnitType: types.ParseUnitTypeByUnit(unit),
				Unit:     unit,
				Kind:     types.KindInfo,
			},
		}
		for _, m := range matrix {
			for _, p := range m.Values {
				timeStamp := p.Timestamp
				value := p.Value
				line.Values = append(line.Values, types.BasicOverviewSlotValue{
					Name:     timeStamp.String(),
					Code:     metric,
					Value:    value,
					Unit:     unit,
					UnitType: types.ParseUnitTypeByUnit(unit),
					Kind:     types.KindInfo,
				})
			}
		}
		var predictSql string
		start, end := par.Start/1e3, par.End/1e3
		step := blockstorage_utils.TimeToStepForInt(end - start)
		predictStart, predictEnd := end, end+(end-start)
		// 添加预测分析
		if par.HasPrediction && tools.Contains(predictionMetrics, metric) != -1 {
			line.Info.Prognosis = len(line.Values)
			rangeDuration := strconv.FormatInt(3*(end-start), 10)
			predictDuration := strconv.FormatInt(end-start, 10)
			switch metric {
			case blockstorage.EbsCapacity:
				predictSql = blockstorage.GetPredictEbsCapacity(ebsPool.PoolType, rangeDuration+"s", predictDuration)
			}
			predictMatrix, err := prom_client.MatrixQuery(ctx, predictSql, v1.Range{
				Start: time.Unix(predictStart, 0),
				End:   time.Unix(predictEnd, 0),
				Step:  time.Duration(step) * time.Second,
			})
			if err != nil {
				fmt.Printf("Error querying Prometheus predictMatrix: %v\n", err)
			}
			for _, m := range predictMatrix {
				for _, p := range m.Values {
					timeStamp := p.Timestamp
					value := p.Value
					line.Values = append(line.Values, types.BasicOverviewSlotValue{
						Name:        timeStamp.String(),
						Value:       value,
						Unit:        unit,
						UnitType:    types.ParseUnitTypeByUnit(unit),
						Kind:        "",
						Description: "预测数据",
					})
				}
				break
			}
		}
		lines = append(lines, line)
	}

	return &dto.EbsPoolOverviewLineRsp{
		Lines: lines,
	}, nil

}

func (n *ebsPoolService) List(ctx context.Context, par dto.EbsPoolListReq) (res *dto.EbsPoolListRsp, err error) {
	ebsPoolList, err := n.Store.EbsPoolRpcClient().ListEbsPool(ctx, &resource_blockstoragev1alpha.ListEbsPoolReq{
		PageNo:    int32(par.PageNo),
		PageSize:  int32(par.PageSize),
		Region:    par.Region,
		Az:        par.Az,
		OrderCode: par.OrderCode,
		OrderType: par.OrderType,
		PoolType:  par.PoolType,
		Query:     par.Query,
	})
	if err != nil {
		lib.Log.TagError(lib.GetTraceContext(ctx), lib.DLTagUndefind, map[string]interface{}{"rpc error": err})
		return nil, err
	}
	res = &dto.EbsPoolListRsp{
		TotalCount: len(ebsPoolList.List),
		PageNo:     par.PageNo,
		PageSize:   par.PageSize,
		DataList:   make([]*dto.EbsPoolMonitor, 0),
	}
	for _, ebsPool := range ebsPoolList.List {
		// 后续补prometheus sql
		capacityTotal, err := n.EbsPoolVector(ctx, ebsPool.Region, ebsPool.Az, ebsPool.Name, ebsPool.PoolType, blockstorage.EbsCapTotal)
		if err != nil {
			lib.Log.TagError(lib.GetTraceContext(ctx), lib.DLTagUndefind, map[string]interface{}{"prom vector error": err})
		}
		capacityUsed, err := n.EbsPoolVector(ctx, ebsPool.Region, ebsPool.Az, ebsPool.Name, ebsPool.PoolType, blockstorage.EbsCapUsed)
		if err != nil {
			lib.Log.TagError(lib.GetTraceContext(ctx), lib.DLTagUndefind, map[string]interface{}{"prom vector error": err})
		}
		capUseRate, err := n.EbsPoolVector(ctx, ebsPool.Region, ebsPool.Az, ebsPool.Name, ebsPool.PoolType, blockstorage.EbsCapRate)
		if err != nil {
			lib.Log.TagError(lib.GetTraceContext(ctx), lib.DLTagUndefind, map[string]interface{}{"prom vector error": err})
		}
		IOReadQps, err := n.EbsPoolVector(ctx, ebsPool.Region, ebsPool.Az, ebsPool.Name, ebsPool.PoolType, blockstorage.EbsIOReadQps)
		if err != nil {
			lib.Log.TagError(lib.GetTraceContext(ctx), lib.DLTagUndefind, map[string]interface{}{"prom vector error": err})
		}
		IOWriteQps, err := n.EbsPoolVector(ctx, ebsPool.Region, ebsPool.Az, ebsPool.Name, ebsPool.PoolType, blockstorage.EbsIOWriteQps)
		if err != nil {
			lib.Log.TagError(lib.GetTraceContext(ctx), lib.DLTagUndefind, map[string]interface{}{"prom vector error": err})
		}
		IOReadDelay, err := n.EbsPoolVector(ctx, ebsPool.Region, ebsPool.Az, ebsPool.Name, ebsPool.PoolType, blockstorage.EbsIOReadDelay)
		if err != nil {
			lib.Log.TagError(lib.GetTraceContext(ctx), lib.DLTagUndefind, map[string]interface{}{"prom vector error": err})
		}
		IOWriteDelay, err := n.EbsPoolVector(ctx, ebsPool.Region, ebsPool.Az, ebsPool.Name, ebsPool.PoolType, blockstorage.EbsIOWriteDelay)
		if err != nil {
			lib.Log.TagError(lib.GetTraceContext(ctx), lib.DLTagUndefind, map[string]interface{}{"prom vector error": err})
		}
		IOReadBand, err := n.EbsPoolVector(ctx, ebsPool.Region, ebsPool.Az, ebsPool.Name, ebsPool.PoolType, blockstorage.EbsIOReadBand)
		if err != nil {
			lib.Log.TagError(lib.GetTraceContext(ctx), lib.DLTagUndefind, map[string]interface{}{"prom vector error": err})
		}
		IOWriteBand, err := n.EbsPoolVector(ctx, ebsPool.Region, ebsPool.Az, ebsPool.Name, ebsPool.PoolType, blockstorage.EbsIOWriteBand)
		if err != nil {
			lib.Log.TagError(lib.GetTraceContext(ctx), lib.DLTagUndefind, map[string]interface{}{"prom vector error": err})
		}
		// 告警数量
		rpcAlertRes, err := n.Store.AlarmRpcClient().ListAlerts(ctx, &alarmv1alpha.ListAlertsRequest{
			PageSize:        -1,
			Region:          ebsPool.Region,
			Az:              []string{ebsPool.Az},
			Level:           alertLevels,
			ResourceType:    []string{"resourcePool"},
			ResourceSubType: []string{ebsPool.PoolType},
			Status:          "firing",
		})
		if err != nil {
			lib.Log.TagError(lib.GetTraceContext(ctx), lib.DLTagUndefind, map[string]interface{}{"rpc alert error": err})
		}
		result := &dto.EbsPoolMonitor{
			Id:                ebsPool.PoolId,
			Name:              ebsPool.Name,
			Region:            ebsPool.Region,
			Az:                ebsPool.Az,
			PoolType:          ebsPool.PoolType,
			ServerCount:       int(ebsPool.ServerCount),
			CloudDiskCount:    int(ebsPool.CloudDiskCount),
			CapacityTotal:     capacityTotal,
			CapacityAvailable: capacityTotal - capacityUsed,
			CapacityUsedRate:  math.Round(capUseRate*100*100) / 100,
			ErrorRate:         0,                                                                                                  // 异常率 待办
			IOInput:           strconv.FormatFloat(IOReadQps, 'f', 2, 64) + "/" + strconv.FormatFloat(IOWriteQps, 'f', 2, 64),     // IO吞吐
			IODelay:           strconv.FormatFloat(IOReadDelay, 'f', 2, 64) + "/" + strconv.FormatFloat(IOWriteDelay, 'f', 2, 64), // IO延时
			Bandwidth:         strconv.FormatFloat(IOReadBand, 'f', 2, 64) + "/" + strconv.FormatFloat(IOWriteBand, 'f', 2, 64),   // IO带宽
			CreateTime:        ebsPool.CreateTime,
			AlertCount:        int(rpcAlertRes.Total),
		}
		res.DataList = append(res.DataList, result)
	}

	// 排序操作
	switch par.OrderCode {
	case "CapacityUsedRate":
		sort.Slice(res.DataList, func(i, j int) bool {
			if par.OrderType == "ASC" {
				return res.DataList[i].CapacityUsedRate < res.DataList[j].CapacityUsedRate
			} else {
				return res.DataList[i].CapacityUsedRate > res.DataList[j].CapacityUsedRate
			}
		})
	}

	return res, nil
}

func (n *ebsPoolService) EbsPoolVector(ctx context.Context, region, az, poolName, poolType, metricName string) (float64, error) {
	promQlReq := blockstorage.TemplateMap[metricName](region, az, poolName, poolType)
	rsp, err := n.Store.AlarmRpcClient().ListPromQLs(ctx, promQlReq)
	if err != nil {
		return 0, errors.WithMessagef(err, "rpc call ListPromQLs err, req: %+v", promQlReq)
	}
	if rsp == nil || len(rsp.Items) < 1 {
		return 0, err
	}
	promQL := rsp.Items[0].RealPromql
	fmt.Println("real promQL: ", promQL)

	//查Prometheus
	matrix, err := prom_client.VectorQuery(ctx, promQL)
	if err != nil {
		return 0, errors.WithMessage(err, "prom_client VectorQuery err")
	}
	return prom_client.ParseOneVectorValue(matrix), nil
}

func (n *ebsPoolService) EbsPoolServerVector(ctx context.Context, serverList *resource_serverv1alpha.ListPhysicalHostResponse, metricName string) (float64, error) {
	promIpList := []string{}
	for _, s := range serverList.PhysicalServerHostList {
		promIpList = append(promIpList, s.ManageIp+":9100")
	}

	//查alarm获取promql
	promQlReq := server.TemplateMap[metricName](promIpList)
	rsp, err := n.Store.AlarmRpcClient().ListPromQLs(ctx, promQlReq)
	if err != nil {
		return 0, errors.WithMessagef(err, "rpc call ListPromQLs err, req: %+v", promQlReq)
	}
	if rsp == nil || len(rsp.Items) < 1 {
		return 0, err
	}
	promQL := rsp.Items[0].RealPromql
	fmt.Println("real promQL: ", promQL)

	//查Prometheus
	matrix, err := prom_client.VectorQuery(ctx, promQL)
	if err != nil {
		return 0, errors.WithMessage(err, "prom_client VectorQuery err")
	}
	return prom_client.ParseOneVectorValue(matrix), nil
}

func (n *ebsPoolService) DetailMetricOverview(ctx context.Context, par dto.EbsPoolDetailMetricReq) (*dto.EbsPoolDetailMetricRsp, error) {
	var statusMap = map[string]int{}
	ebsPool, err := n.Store.EbsPoolRpcClient().EbsPoolStock(ctx, &resource_blockstoragev1alpha.EbsPoolStockReq{
		PoolId: par.PoolId,
	})
	if err != nil {
		lib.Log.TagError(lib.GetTraceContext(ctx), lib.DLTagUndefind, map[string]interface{}{"rpc error": err})
		return nil, err
	}

	ebsVolumes, err := n.Store.EbsVolumeRpcClient().ListEbsVolume(ctx, &resource_blockstoragev1alpha.ListVolumeReq{
		PageSize: -1,
		Region:   ebsPool.Region,
		PoolId:   ebsPool.PoolId,
		Az:       []string{ebsPool.Az},
		PoolName: []string{ebsPool.Name},
	})
	if err != nil {
		lib.Log.TagError(lib.GetTraceContext(ctx), lib.DLTagUndefind, map[string]interface{}{"rpc error": err})
		return nil, err
	}
	for _, ebsVolume := range ebsVolumes.List {
		statusMap[ebsVolume.Status] += 1
	}

	return &dto.EbsPoolDetailMetricRsp{
		ResourceOverview: []dto.EbsPoolDetailMetric{
			{
				PoolId:   ebsPool.PoolId,
				Name:     "块存储总容量",
				Unit:     "GB",
				UnitType: types.TypeStorage,
				Value:    ebsPool.TotalDiskCapacity,
				Kind:     types.KindInfo,
			},
			{
				PoolId:   ebsPool.PoolId,
				Name:     "块存储可用容量",
				Unit:     "GB",
				UnitType: types.TypeStorage,
				Value:    ebsPool.CapacityAvailabel,
				Kind:     types.KindInfo,
			},
			{
				PoolId:   ebsPool.PoolId,
				Name:     "块存储总数",
				Unit:     "个",
				UnitType: types.TypeNumber,
				Value:    ebsPool.CapacityAvailabel,
				Kind:     types.KindInfo,
			},
			{
				PoolId:   ebsPool.PoolId,
				Name:     "使用中块存储总数",
				Unit:     "个",
				UnitType: types.TypeNumber,
				Value:    statusMap["in-use"],
				Kind:     types.KindInfo,
			},
			{
				PoolId:   ebsPool.PoolId,
				Name:     "待挂载块存储总数",
				Unit:     "个",
				UnitType: types.TypeNumber,
				Value:    statusMap["available"],
				Kind:     types.KindInfo,
			},
		},
	}, nil
}

func (n *ebsPoolService) DetailMetricLine(ctx context.Context, par dto.EbsPoolDetailMetricLineReq) (*dto.EbsPoolDetailMetricLineRsp, error) {
	ebsPoolRpcRes, err := n.Store.EbsPoolRpcClient().ListEbsPool(ctx, &resource_blockstoragev1alpha.ListEbsPoolReq{
		Region:   par.Region,
		Az:       []string{par.Az},
		PoolType: []string{par.PoolType},
	})
	ebsPool := ebsPoolRpcRes.List[0]
	if err != nil {
		lib.Log.TagError(lib.GetTraceContext(ctx), lib.DLTagHTTPFailed, map[string]interface{}{"error": err.Error()})
		return nil, err
	}
	lines := make([]types.BasicOverviewSlot, 0)
	for _, metric := range par.MetricName {
		rsp, err := n.Store.AlarmRpcClient().ListPromQLs(ctx, blockstorage.TemplateMap[metric](ebsPool.Region, ebsPool.Az, ebsPool.Name, ebsPool.PoolType))
		if err != nil {
			lib.Log.TagError(lib.GetTraceContext(ctx), lib.DLTagResponseFailed, map[string]interface{}{"error": err.Error()})
		}
		promQL := rsp.Items[0].RealPromql
		unit := rsp.Items[0].Unit

		matrix, err := prom_client.MatrixQuery(ctx, promQL, v1.Range{
			Start: time.UnixMilli(par.Start),
			End:   time.UnixMilli(par.End),
			Step:  prom_client.TimeToStep(par.End - par.Start),
		})

		if err != nil {
			lib.Log.TagError(lib.GetTraceContext(ctx), lib.DLTagResponseFailed, map[string]interface{}{"error": err.Error()})
		}
		// 封装结果
		line := types.BasicOverviewSlot{
			Info: types.BasicOverviewSlotInfo{
				Index:       0,
				Name:        blockstorage.MetricMap[metric],
				Value:       0,
				UnitType:    types.ParseUnitTypeByUnit(unit),
				Unit:        unit,
				Kind:        types.KindInfo,
				Prognosis:   0, //预测值，values的下标，0则无预测值
				Description: "",
			},
		}
		for _, m := range matrix {
			for _, p := range m.Values {
				timeStamp := p.Timestamp
				value := p.Value
				line.Values = append(line.Values, types.BasicOverviewSlotValue{
					Name:        timeStamp.String(),
					Code:        metric,
					Value:       value,
					Unit:        unit,
					UnitType:    types.ParseUnitTypeByUnit(unit),
					Kind:        types.KindInfo,
					Description: "",
				})
			}
		}
		lines = append(lines, line)
	}
	return &dto.EbsPoolDetailMetricLineRsp{
		Lines: lines,
	}, nil
}

func (n *ebsPoolService) GetListOptionalCondition(ctx *gin.Context) (*dto.OptionalEbsPoolResult, error) {
	var (
		poolTypeSet = collection.NewSet()
		azSet       = collection.NewSet()
	)
	ebsPoolList, err := n.Store.EbsPoolRpcClient().ListEbsPool(ctx, &resource_blockstoragev1alpha.ListEbsPoolReq{PageNo: 1, PageSize: 1000})
	if err != nil {
		lib.Log.TagError(lib.GetTraceContext(ctx), lib.DLTagUndefind, map[string]interface{}{"rpc error": err})
		return nil, err
	}
	for _, ebsPool := range ebsPoolList.List {
		if ebsPool.PoolType != "" {
			poolTypeSet.Add(ebsPool.PoolType)
		}
		if ebsPool.Az != "" {
			azSet.Add(ebsPool.Az)
		}
	}
	result := dto.OptionalEbsPoolResult{
		"PoolTypeSet": poolTypeSet,
		"AzSet":       azSet,
	}
	return &result, nil
}

```

File path: /Users/mac/Desktop/woker_code/monitor/modules/blockstorage/service/ebs_volume.go
```golang
package service

import (
	"context"
	"fmt"

	"ezone.ksyun.com/ezone/luban/communal/lib"
	resource_blockstoragev1alpha "ezone.ksyun.com/ezone/luban/luban_api/resourceapis/resource_blockstorage/v1alpha/gen"
	"ezone.ksyun.com/ezone/luban/monitor/common/client/opentsdb"
	"ezone.ksyun.com/ezone/luban/monitor/common/client/opentsdb/pkg"
	"ezone.ksyun.com/ezone/luban/monitor/common/tools"
	"ezone.ksyun.com/ezone/luban/monitor/common/tsdbql_template/ebs_volume"
	"ezone.ksyun.com/ezone/luban/monitor/common/types"
	"ezone.ksyun.com/ezone/luban/monitor/modules/blockstorage/constant"
	"ezone.ksyun.com/ezone/luban/monitor/modules/blockstorage/dao"
	"ezone.ksyun.com/ezone/luban/monitor/modules/blockstorage/dto"
)

type EbsVolumeService interface {
	OverviewTop(ctx context.Context, par dto.EbsVolumeOverviewTopReq) (*dto.EbsVolumeOverviewTopRsp, error)
	Overview(ctx context.Context, par dto.EbsVolumeOverviewReq) (*dto.EbsVolumeOverviewRsp, error)
	DetailMetric(ctx context.Context, par dto.EbsVolumeDetailMetricReq) (*dto.EbsVolumeDetailMetricRsp, error)
	DetailMetricLine(ctx context.Context, par dto.EbsVolumeDetailMetricLineReq) (*dto.EbsVolumeDetailMetricLineRsp, error)
}

type ebsVolumeService struct {
	Store dao.Store
}

func NewEbsVolumeService() EbsVolumeService {
	return &ebsVolumeService{
		Store: dao.NewBlockStorageStore(),
	}
}

func (n *ebsVolumeService) OverviewTop(ctx context.Context, par dto.EbsVolumeOverviewTopReq) (*dto.EbsVolumeOverviewTopRsp, error) {
	var tops []types.BasicOverviewSlot
	for _, name := range par.MetricName {
		name += "_" + par.DiskType
		tsdbMetric, err := n.Store.Metric().GetOneByCode(name)
		if err != nil {
			return nil, nil
		}
		topData, err := n.Store.MetricTop().GetOneByCode(dao.QueryParams{
			Region: par.Region,
			Az:     par.Az,
			Code:   name,
		})
		if err != nil {
			return nil, nil
		}
		intervalData := topData.ParseIntervalData(par.Start, par.End)
		//topK
		if par.TopK > 10 {
			return nil, fmt.Errorf("topK is too large")
		}
		if len(intervalData) < par.TopK {
			length := len(intervalData)
			intervalData = intervalData[:length]
		} else {
			intervalData = intervalData[:par.TopK]
		}

		values := []types.BasicOverviewSlotValue{}
		for _, v := range intervalData {
			values = append(values, types.BasicOverviewSlotValue{
				Name:     v.Name,
				Code:     v.Id,
				Value:    v.Value,
				Unit:     tsdbMetric.Unit,
				UnitType: types.ParseUnitTypeByUnit(tsdbMetric.Unit),
				Kind:     types.KindInfo,
			})
		}

		slot := types.BasicOverviewSlot{
			Info: types.BasicOverviewSlotInfo{
				Index:       0,
				Name:        constant.EbsVolumeTopMap[name],
				Value:       0,
				UnitType:    types.ParseUnitTypeByUnit(tsdbMetric.Unit),
				Unit:        tsdbMetric.Unit,
				Kind:        types.KindInfo,
				Prognosis:   0,
				Description: "",
			},
			Values: values,
		}
		tops = append(tops, slot)
	}

	return &dto.EbsVolumeOverviewTopRsp{
		Tops: tops,
	}, nil
}

func (n *ebsVolumeService) Overview(ctx context.Context, par dto.EbsVolumeOverviewReq) (*dto.EbsVolumeOverviewRsp, error) {
	var (
		platformStatusCount     = map[string]int64{}
		businessStatusCount     = map[string]int64{}
		ebsStorageUse           = make([]types.BasicOverviewSlot, 0)
		ebsVolumePlatformCounts = make([]types.BasicOverviewSlot, 0)
		ebsVolumeBusinessCounts = make([]types.BasicOverviewSlot, 0)
	)
	var platformUseCount, businessUseCount int
	platformUseCount, businessUseCount = calculateEbsVolumeUseCount(ctx, n.Store, par)
	storageUse := types.BasicOverviewSlot{
		Info: types.BasicOverviewSlotInfo{
			Index:    0,
			Name:     "云硬盘规格统计",
			Value:    platformUseCount + businessUseCount,
			Unit:     "个",
			UnitType: "number",
		},
		Values: make([]types.BasicOverviewSlotValue, 0),
	}
	storageUse.Values = append(storageUse.Values,
		types.BasicOverviewSlotValue{
			Name:     "平台开盘量",
			Value:    platformUseCount,
			Unit:     "个",
			UnitType: "number",
		},
		types.BasicOverviewSlotValue{
			Name:     "业务开盘量",
			Value:    businessUseCount,
			Unit:     "个",
			UnitType: "number",
		},
	)
	ebsStorageUse = append(ebsStorageUse, storageUse)

	// 平台块存储数量
	var platformTotalCount, businessTotalCount int
	for code, status := range constant.EbsVolumeUseStatusMap {
		var azList []string
		if par.Az != "" {
			azList = append(azList, par.Az)
		}
		ebsVolumePlatformResult, err := n.Store.EbsVolumeRpcClient().ListEbsVolume(ctx, &resource_blockstoragev1alpha.ListVolumeReq{
			PageSize:   -1,
			Region:     par.Region,
			Az:         azList,
			UseStatus:  []string{code},
			VolumeType: []string{par.DiskType},
			TenantName: constant.PlatformTenantName,
		})
		if err != nil {
			lib.Log.TagError(lib.GetTraceContext(ctx), lib.DLTagUndefind, map[string]interface{}{"rpc error": err})
			return nil, err
		}
		// 存在数据进行录入
		if ebsVolumePlatformResult.TotalCount != 0 {
			platformStatusCount[status] = ebsVolumePlatformResult.TotalCount
			platformTotalCount += int(ebsVolumePlatformResult.TotalCount)
		}

		ebsVolumeResult, err := n.Store.EbsVolumeRpcClient().ListEbsVolume(ctx, &resource_blockstoragev1alpha.ListVolumeReq{
			PageSize:   -1,
			Region:     par.Region,
			Az:         azList,
			UseStatus:  []string{code},
			VolumeType: []string{par.DiskType},
		})
		if err != nil {
			lib.Log.TagError(lib.GetTraceContext(ctx), lib.DLTagUndefind, map[string]interface{}{"rpc error": err})
			return nil, err
		}
		if ebsVolumeResult.TotalCount != 0 {
			businessStatusCount[status] = ebsVolumeResult.TotalCount - ebsVolumePlatformResult.TotalCount
			businessTotalCount += int(ebsVolumeResult.TotalCount - ebsVolumePlatformResult.TotalCount)
		}
	}
	ebsVolumePlatformCount := types.BasicOverviewSlot{
		Info: types.BasicOverviewSlotInfo{
			Index:    1,
			Name:     "平台块存储",
			Value:    platformTotalCount,
			Unit:     "个",
			UnitType: "number",
		},
		Values: make([]types.BasicOverviewSlotValue, 0),
	}
	for status, count := range platformStatusCount {
		ebsVolumePlatformCount.Values = append(ebsVolumePlatformCount.Values, types.BasicOverviewSlotValue{
			Name:     status,
			Value:    count,
			Unit:     "个",
			UnitType: "number",
		})
	}
	// 业务块存储
	ebsVolumeBusinessCount := types.BasicOverviewSlot{
		Info: types.BasicOverviewSlotInfo{
			Index:    2,
			Name:     "业务块存储",
			Value:    businessTotalCount,
			Unit:     "个",
			UnitType: "number",
		},
		Values: make([]types.BasicOverviewSlotValue, 0),
	}
	for status, count := range businessStatusCount {
		ebsVolumeBusinessCount.Values = append(ebsVolumeBusinessCount.Values, types.BasicOverviewSlotValue{
			Name:     status,
			Value:    count,
			Unit:     "个",
			UnitType: "number",
		})
	}
	ebsVolumePlatformCounts = append(ebsVolumePlatformCounts, ebsVolumePlatformCount)
	ebsVolumeBusinessCounts = append(ebsVolumeBusinessCounts, ebsVolumeBusinessCount)
	return &dto.EbsVolumeOverviewRsp{
		EbsStorageUse:           ebsStorageUse,
		EbsVolumePlatformCounts: ebsVolumePlatformCounts,
		EbsVolumeBusinessCounts: ebsVolumeBusinessCounts,
	}, nil
}

func calculateEbsVolumeUseCount(ctx context.Context, store dao.Store, par dto.EbsVolumeOverviewReq) (int, int) {
	var platformUseCount, businessUseCount int
	for code := range constant.EbsVolumeUseStatusMap {
		var azList []string
		if par.Az != "" {
			azList = append(azList, par.Az)
		}
		ebsVolumePlatformResult, err := store.EbsVolumeRpcClient().ListEbsVolume(ctx, &resource_blockstoragev1alpha.ListVolumeReq{
			PageSize:   -1,
			Region:     par.Region,
			Az:         azList,
			UseStatus:  []string{code},
			VolumeType: []string{par.DiskType},
			TenantName: constant.PlatformTenantName,
		})
		if err != nil {
			lib.Log.TagError(lib.GetTraceContext(ctx), lib.DLTagUndefind, map[string]interface{}{"rpc error": err})
			return 0, 0
		}
		// 存在数据进行录入
		if ebsVolumePlatformResult.TotalCount != 0 {
			platformUseCount += int(ebsVolumePlatformResult.TotalCount)
		}

		ebsVolumeResult, err := store.EbsVolumeRpcClient().ListEbsVolume(ctx, &resource_blockstoragev1alpha.ListVolumeReq{
			PageSize:   -1,
			Region:     par.Region,
			Az:         azList,
			UseStatus:  []string{code},
			VolumeType: []string{par.DiskType},
		})
		if err != nil {
			lib.Log.TagError(lib.GetTraceContext(ctx), lib.DLTagUndefind, map[string]interface{}{"rpc error": err})
			return 0, 0
		}
		if ebsVolumeResult.TotalCount != 0 {
			businessUseCount += int(ebsVolumeResult.TotalCount - ebsVolumePlatformResult.TotalCount)
		}
	}
	return platformUseCount, businessUseCount
}

func (n *ebsVolumeService) DetailMetric(ctx context.Context, par dto.EbsVolumeDetailMetricReq) (*dto.EbsVolumeDetailMetricRsp, error) {
	rpcRes, err := n.Store.EbsVolumeRpcClient().ListEbsVolume(ctx, &resource_blockstoragev1alpha.ListVolumeReq{
		PageSize: -1,
		Query: map[string]string{
			"VolumeId": par.Id,
		},
	})
	if err != nil {
		lib.Log.TagError(lib.GetTraceContext(ctx), lib.DLTagUndefind, map[string]interface{}{"rpc error": err})
		return nil, err
	}
	ebsVolume := rpcRes.List[0]

	result := []dto.EbsVolumeDetailMetric{
		{
			Name:     "块存储总容量",
			Unit:     "GB",
			UnitType: types.TypeStorage,
			Value:    ebsVolume.Size,
		},
		{
			Name:     "磁盘使用状态",
			Value:    constant.EbsVolumeStatusMap[ebsVolume.Status],
			UnitType: types.TypePercent,
			Unit:     "status",
		},
		{
			Name:  "磁盘健康状态",
			Value: nil, // 磁盘健康状态 后续讨论完进行定义
		},
	}
	return &dto.EbsVolumeDetailMetricRsp{
		ResourceOverview: result,
	}, nil
}

func (n *ebsVolumeService) DetailMetricLine(ctx context.Context, par dto.EbsVolumeDetailMetricLineReq) (*dto.EbsVolumeDetailMetricLineRsp, error) {
	rpcRes, err := n.Store.EbsVolumeRpcClient().ListEbsVolume(ctx, &resource_blockstoragev1alpha.ListVolumeReq{
		Query: map[string]string{
			"VolumeId": par.Id,
		},
	})
	if err != nil {
		lib.Log.TagError(lib.GetTraceContext(ctx), lib.DLTagUndefind, map[string]interface{}{"rpc error": err})
		return nil, err
	}
	ebsVolume := rpcRes.List[0]
	region := ebsVolume.Region
	queryParam := pkg.QueryParam{
		Start: par.Start,
		End:   par.End,
	}
	lines := make([]types.BasicOverviewSlot, 0)
	for _, metric := range par.MetricName {
		subQueries := make([]pkg.SubQuery, 0)
		tsdbMetric, err := n.Store.Metric().GetOneByCode(metric + "_" + ebsVolume.VolumeType)
		if err != nil {
			lib.Log.TagError(lib.GetTraceContext(ctx), lib.DLTagResponseFailed, map[string]interface{}{"error": err.Error()})
			continue
		}
		ebsVolumeQuery := ebs_volume.ParseTsdbQuery(tsdbMetric.Code, tsdbMetric.MetricPrefix, ebsVolume.VmId)
		subQueries = append(subQueries, pkg.SubQuery{
			Aggregator: "sum",
			Metric:     ebsVolumeQuery.Metric,
			Tags:       ebsVolumeQuery.Tags,
			Downsample: opentsdb.TimeToDownsample(par.End - par.Start),
		})

		queryParam.Queries = subQueries
		queryResp, err := opentsdb.Query(ctx, region, queryParam)
		if err != nil {
			lib.Log.TagError(lib.GetTraceContext(ctx), lib.DLTagResponseFailed, map[string]interface{}{"error": err.Error()})
			continue
		}

		line := types.BasicOverviewSlot{
			Info: types.BasicOverviewSlotInfo{
				Index:       0,
				Name:        metric,
				Value:       nil,
				Unit:        tsdbMetric.Unit,
				UnitType:    types.ParseUnitTypeByUnit(tsdbMetric.Unit),
				Kind:        types.KindInfo,
				Prognosis:   0,
				Description: "",
			},
		}
		if len(queryResp.QueryRespCnts) > 0 {
			dataPoints := queryResp.QueryRespCnts[0].GetDataPoints()
			for _, v := range dataPoints {
				line.Values = append(line.Values, types.BasicOverviewSlotValue{
					Name:        fmt.Sprintf("%d", tools.UnixToUnixMilli(v.Timestamp)),
					Code:        "",
					Value:       v.Value,
					Unit:        tsdbMetric.Unit,
					UnitType:    types.ParseUnitTypeByUnit(tsdbMetric.Unit),
					Kind:        types.KindInfo,
					Description: v.Metric,
				})
			}
		}
		lines = append(lines, line)
	}

	return &dto.EbsVolumeDetailMetricLineRsp{
		Lines: lines,
	}, nil
}

```

File path: /Users/mac/Desktop/woker_code/monitor/modules/blockstorage/rpc/ebs_pool.go
```golang
package rpc

import (
	"context"

	"ezone.ksyun.com/ezone/luban/communal/lib"
	pb "ezone.ksyun.com/ezone/luban/luban_api/monitorapis/blockstorage/v1alpha/gen"
	"ezone.ksyun.com/ezone/luban/monitor/modules/blockstorage/dto"
	"github.com/jinzhu/copier"
	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/status"
)

func (n *blockStorageRpcServer) EbsPoolList(ctx context.Context, req *pb.EbsPoolListReq) (*pb.EbsPoolListRsp, error) {
	lib.Log.TagInfo(lib.GetTraceContext(ctx), lib.DLTagRequestIn, map[string]interface{}{"params": req})
	var par dto.EbsPoolListReq
	if err := copier.Copy(&par, req); err != nil {
		lib.Log.TagError(lib.GetTraceContext(ctx), lib.DLTagUndefind, map[string]interface{}{"copy err": err})
		return nil, status.Error(codes.Internal, err.Error())
	}
	res, err := n.ebsPoolSvc.List(ctx, par)
	if err != nil {
		lib.Log.TagError(lib.GetTraceContext(ctx), lib.DLTagUndefind, map[string]interface{}{"call service err": err})
		return nil, status.Error(codes.Internal, err.Error())
	}
	resp := &pb.EbsPoolListRsp{}
	copier.Copy(&resp, res)
	return resp, nil
}

```

File path: /Users/mac/Desktop/woker_code/monitor/modules/blockstorage/rpc/rpcserver.go
```golang
package rpc

import (
	pb "ezone.ksyun.com/ezone/luban/luban_api/monitorapis/blockstorage/v1alpha/gen"
	"ezone.ksyun.com/ezone/luban/monitor/modules/blockstorage/service"
)

type blockStorageRpcServer struct {
	ebsPoolSvc   service.EbsPoolService
	ebsVolumeSvc service.EbsVolumeService
	pb.UnimplementedEbsPoolServiceServer
}

func NewBlockStorageRpcServer() *blockStorageRpcServer {
	return &blockStorageRpcServer{
		ebsPoolSvc:   service.NewEbsPoolService(),
		ebsVolumeSvc: service.NewEbsVolumeService(),
	}
}

```

File path: /Users/mac/Desktop/woker_code/monitor/modules/network/dto/response.go
```golang
package dto

import "ezone.ksyun.com/ezone/luban/monitor/common/types"

type NetworkPoolDetailTopRsp struct {
	Lines []types.BasicOverviewSlot
}

type NetworkPoolDetailLineRsp struct {
	Lines []types.BasicOverviewSlot
}

type NetworkPoolOverviewLineRsp struct {
	Lines []types.BasicOverviewSlot
}

type NetworkPoolOverviewRsp struct {
}

type NetworkPoolOverviewAlertRsp struct {
	Alerts []types.BasicOverviewSlot
}

type NetworkPoolOverviewMonitorRsp struct {
	Up   []types.BasicOverviewSlot
	Down []types.BasicOverviewSlot
}

type ListNetworkPoolEIPRsp struct {
	TotalCount int64
	PageNo     int
	PageSize   int
	Set        []*ListNetworkPoolEIP
}

type ListNetworkPoolEIP struct {
	Hosts       []string `json:"Hosts"`
	PoolName    string   `json:"PoolName"`
	PoolType    string   `json:"PoolType"`
	Region      string   `json:"Region"`
	LBCount     int      `json:"LBCount"`
	ServerCount int      `json:"ServerCount"`
	EipCount    int      `json:"EipCount"`
	CreateTime  int64    `json:"CreateTime"`

	//使用率
	CpuUsedRatio  float64 `json:"CpuUsedRatio"`
	MemUsedRatio  float64 `json:"MemUsedRatio"`
	DiskUsedRatio float64 `json:"DiskUsedRatio"`
}

type ListNetworkPoolLBRsp struct {
	TotalCount int64
	PageNo     int
	PageSize   int
	Set        []*ListNetworkPoolLB
}

type ListNetworkPoolLB struct {
	Hosts       []string `json:"Hosts"`
	PoolName    string   `json:"PoolName"`
	PoolType    string   `json:"PoolType"`
	Region      string   `json:"Region"`
	ServerCount int      `json:"ServerCount"`
	LBCount     int      `json:"LBCount"`
	EipCount    int      `json:"EipCount"`
	CreateTime  int64    `json:"CreateTime"`

	//使用率
	CpuUsedRatio  float64 `json:"CpuUsedRatio"`
	MemUsedRatio  float64 `json:"MemUsedRatio"`
	DiskUsedRatio float64 `json:"DiskUsedRatio"`
}

type ListNetworkPoolNATRsp struct {
	TotalCount int64
	PageNo     int
	PageSize   int
	Set        []*ListNetworkPoolNAT
}

type ListNetworkPoolNAT struct {
	Hosts       []string `json:"Hosts"`
	PoolName    string   `json:"PoolName"`
	PoolType    string   `json:"PoolType"`
	Region      string   `json:"Region"`
	ServerCount int      `json:"ServerCount"`
	NatCount    int      `json:"NatCount"`
	CreateTime  int64    `json:"CreateTime"`

	//使用率
	CpuUsedRatio  float64 `json:"CpuUsedRatio"`
	MemUsedRatio  float64 `json:"MemUsedRatio"`
	DiskUsedRatio float64 `json:"DiskUsedRatio"`
}

type ListNetworkPoolBMRsp struct {
	TotalCount int64
	PageNo     int
	PageSize   int
	Set        []*ListNetworkPoolBM
}

type ListNetworkPoolBM struct {
	Hosts       []string `json:"Hosts"`
	PoolName    string   `json:"PoolName"`
	PoolType    string   `json:"PoolType"`
	Region      string   `json:"Region"`
	ServerCount int      `json:"ServerCount"`
	BMCount     int      `json:"BMCount"`
	CreateTime  int64    `json:"CreateTime"`

	//使用率
	CpuUsedRatio  float64 `json:"CpuUsedRatio"`
	MemUsedRatio  float64 `json:"MemUsedRatio"`
	DiskUsedRatio float64 `json:"DiskUsedRatio"`
}

type ListNetworkPoolSLRsp struct {
	TotalCount int64
	PageNo     int
	PageSize   int
	Set        []*ListNetworkPoolSL
}

type ListNetworkPoolSL struct {
	Hosts       []string `json:"Hosts"`
	PoolName    string   `json:"PoolName"`
	PoolType    string   `json:"PoolType"`
	Region      string   `json:"Region"`
	ServerCount int      `json:"ServerCount"`
	SLCount     int      `json:"SLCount"`
	P2PCount    int      `json:"P2PCount"`
	VPNCount    int      `json:"VPNCount"`
	CreateTime  int64    `json:"CreateTime"`

	//使用率
	CpuUsedRatio  float64 `json:"CpuUsedRatio"`
	MemUsedRatio  float64 `json:"MemUsedRatio"`
	DiskUsedRatio float64 `json:"DiskUsedRatio"`
}

type ProductEipOverviewAlertRsp struct {
}

type ProductEipOverviewTopRsp struct {
	Tops []types.BasicOverviewSlot
}

type ProductEipInfoRsp struct {
	Region       string `json:"Region"`
	CreateTime   int64  `json:"CreateTime"`
	InstanceID   string `json:"InstanceID"`
	InstanceName string `json:"InstanceName"`
	TenantID     string `json:"TenantID"`
	TenantName   string `json:"TenantName"`
	ProjectID    string `json:"ProjectID"`
	ProjectName  string `json:"ProjectName"`

	IpAddr      string `json:"IpAddr"`
	Cidr        string `json:"Cidr"`
	WayType     string `json:"WayType"`
	BandWidth   string `json:"BandWidth"`
	IpVersion   string `json:"IpVersion"`
	Label       string `json:"Label"`
	Description string `json:"Description"`

	//绑定实例信息
	BoundId    string `json:"BoundId"`
	BoundType  string `json:"BoundType"`
	Name       string `json:"Name"`       //绑定实例名称
	Flavor     string `json:"Flavor"`     //规格
	Status     string `json:"Status"`     //绑定实例状态
	Aggregate  string `json:"Aggregate"`  //所属资源池
	Hypervisor string `json:"Hypervisor"` //所属服务器
}

type ProductEipLineRsp struct {
	Lines []types.BasicOverviewSlot
}

type TaskRsp struct {
	//资源类型
	ResourceType string `json:"resource_type"`

	//时间间隔
	Interval string `json:"interval"`
}

type ProductLbListRsp struct {
	TotalCount int64 `json:"TotalCount"`
	PageNo     int   `json:"PageNo"`
	PageSize   int   `json:"PageSize"`
	List       []Lb  `json:"List"`
}

type Lb struct {
	LoadBalancerId    string `json:"LoadBalancerId"`
	LoadBalancerName  string `json:"LoadBalancerName"`
	LoadBalancerState string `json:"LoadBalancerState"`
	LoadBalancerType  string `json:"LoadBalancerType"`
	VpcId             string `json:"VpcId"`
	VpcName           string `json:"VpcName"`
	PublicIp          string `json:"PublicIp"`
	ListenersCount    int    `json:"ListenersCount"`
	Region            string `json:"Region"`
	TenantId          string `json:"TenantId"`
	TenantName        string `json:"TenantName"`
	ProjectId         string `json:"ProjectId"`
	ProjectName       string `json:"ProjectName"`
	IpVersion         string `json:"IpVersion"`
	Type              string `json:"Type"`
	LineType          string `json:"LineType"`
	CreateTime        int64  `json:"CreateTime"`
	PoolName          string `json:"PoolName"`
	PoolId            string `json:"PoolId"`
}

type ProductLbOverviewTopRsp struct {
	Tops []types.BasicOverviewSlot
}

type ProductLbLineRsp struct {
	Lines []types.BasicOverviewSlot
}

type ProductNatOverviewTopRsp struct {
	Tops []types.BasicOverviewSlot
}

type ProductNatLineRsp struct {
	Lines []types.BasicOverviewSlot
}

```

File path: /Users/mac/Desktop/woker_code/monitor/modules/network/dto/request.go
```golang
package dto

type NetworkPoolDetailTopReq struct {
	Start      int64  `json:"Start"`
	End        int64  `json:"End"`
	MetricName string `json:"MetricName"`
	Region     string `json:"Region"`
	PoolType   string `json:"PoolType"`
	Hostname   string `json:"HostName"`
	TopK       int    `json:"TopK"`
}

type NetworkPoolDetailLineReq struct {
	Start         int64    `json:"Start"`
	End           int64    `json:"End"`
	MetricName    []string `json:"MetricName"`
	Region        string   `json:"Region"`
	PoolType      string   `json:"PoolType"`
	HasPrediction bool     `json:"HasPrediction"`
}

type NetworkPoolOverviewLineReq struct {
	Start      int64    `json:"Start"`
	End        int64    `json:"End"`
	MetricName []string `json:"MetricName"`
	Region     string   `json:"Region"`
	PoolType   string   `json:"PoolType"`
}

type NetworkPoolOverviewAlertReq struct {
	Region string `json:"Region"`
	Az     string `json:"Az"`
}

type NetworkPoolOverviewMonitorReq struct {
	Region string `json:"Region"`
}

type CommonListReq struct {
	PageNo    int    `json:"PageNo"`
	PageSize  int    `json:"PageSize" binding:"lte=1000"`
	Region    string `json:"Region"`
	OrderCode string `json:"OrderCode"`
	OrderType string `json:"OrderType" binding:"omitempty,oneof=ASC DESC"`
	Query     Query  `json:"Query"`
}
type Query map[string]string

type ListNetworkPoolEipReq struct {
	CommonListReq
	PoolType []string `json:"PoolType"`
}

type ListNetworkPoolLBReq struct {
	CommonListReq
	PoolType []string `json:"PoolType"`
}

type ListNetworkPoolNATReq struct {
	CommonListReq
	PoolType []string `json:"PoolType"`
}

type ListNetworkPoolBMReq struct {
	CommonListReq
	PoolType []string `json:"PoolType"`
}

type ListNetworkPoolSLReq struct {
	CommonListReq
	PoolType []string `json:"PoolType"`
}

type ListNetworkPoolStockReq struct {
	CommonListReq
	PoolType []string `json:"PoolType"`
}

type ProductEipOverviewAlertReq struct {
	Region string `json:"Region"`
}

type ProductEipOverviewTopReq struct {
	Region     string   `json:"Region"`
	MetricName []string `json:"MetricName"`
	TopK       int      `json:"TopK"` //5,10
	Start      int64    `json:"Start"`
	End        int64    `json:"End"`
}

type ProductEipInfoReq struct {
	InstanceID string `form:"InstanceID"`
	IP         string `form:"IP"`
}

type ProductEipLineReq struct {
	MetricName []string `json:"MetricName"`
	Start      int64    `json:"Start"`
	End        int64    `json:"End"`
	EIP        string   `json:"EIP"`
	ID         string   `json:"ID"`
}

type ProductLbListReq struct {
	CommonListReq
	Az                []string `json:"Az"`
	TenantId          []string `json:"TenantId"`
	TenantName        []string `json:"TenantName"`
	ProjectId         []string `json:"ProjectId"`
	ProjectName       []string `json:"ProjectName"`
	VpcName           []string `json:"VpcName"`
	VpcId             []string `json:"VpcId"`
	LoadBalancerState string   `json:"LoadBalancerState"`
	LoadBalancerType  string   `json:"LoadBalancerType"`
	Type              string   `json:"Type"`
	PoolName          []string `json:"PoolName"`
	LineType          string   `json:"LineType"`
	HostName          string   `json:"HostName"`
}

type ProductLbOverviewTopReq struct {
	Region     string   `json:"Region"`
	Az         string   `json:"Az"`
	MetricName []string `json:"MetricName"`
	TopK       int      `json:"TopK"` //5,10
	Start      int64    `json:"Start"`
	End        int64    `json:"End"`
}

type ProductLbLineReq struct {
	MetricName []string `json:"MetricName"`
	Start      int64    `json:"Start"`
	End        int64    `json:"End"`
	ID         string   `json:"ID"`
}

type ProductLbOverviewReq struct {
	Region string `json:"Region"`
	Az     string `json:"Az"`
}

type ProductNatOverviewReq struct {
	Region string `json:"Region"`
	Az     string `json:"Az"`
}

type ProductNatOverviewTopReq struct {
	Region     string   `json:"Region"`
	Az         string   `json:"Az"`
	MetricName []string `json:"MetricName"`
	TopK       int      `json:"TopK"` //5,10
	Start      int64    `json:"Start"`
	End        int64    `json:"End"`
}

type ProductNatLineReq struct {
	MetricName []string `json:"MetricName"`
	Start      int64    `json:"Start"`
	End        int64    `json:"End"`
	ID         string   `json:"ID"`
}

```

File path: /Users/mac/Desktop/woker_code/monitor/modules/network/dao/monitor_tsdb_metrics.go
```golang
package dao

import (
	"context"
	"ezone.ksyun.com/ezone/luban/communal/lib"
	"ezone.ksyun.com/ezone/luban/monitor/modules/network/model"
	"github.com/pkg/errors"
	"gorm.io/gorm"
	"gorm.io/plugin/opentelemetry/tracing"
)

type MetricDao struct {
	db *gorm.DB
}

func NewMetricDao() *MetricDao {
	db := lib.GORMMapPool["business"].Debug()
	db.Use(tracing.NewPlugin(tracing.WithoutMetrics()))

	return &MetricDao{
		db: db,
	}
}

func (m *MetricDao) GetOneByCode(ctx context.Context, code string) (*model.MonitorTsdbMetrics, error) {
	content := model.MonitorTsdbMetrics{}
	err := m.db.WithContext(ctx).Where("code = ?", code).First(&content).Error
	if err != nil {
		if errors.Is(err, gorm.ErrRecordNotFound) {
			return nil, nil
		}
		lib.Log.TagError(lib.NewTrace(), lib.DLTagMySqlFailed, map[string]interface{}{"error": err.Error()})
		return nil, err
	}
	return &content, nil
}

// get list by codes
func (m *MetricDao) GetListByCodes(ctx context.Context, codes []string) ([]model.MonitorTsdbMetrics, error) {
	var content []model.MonitorTsdbMetrics
	err := m.db.WithContext(ctx).Where("code in (?)", codes).Find(&content).Error
	if err != nil {
		lib.Log.TagError(lib.NewTrace(), lib.DLTagMySqlFailed, map[string]interface{}{"error": err.Error()})
		return nil, err
	}
	return content, nil
}

```

File path: /Users/mac/Desktop/woker_code/monitor/modules/network/dao/monitor_top.go
```golang
package dao

import (
	"context"
	"ezone.ksyun.com/ezone/luban/communal/lib"
	"ezone.ksyun.com/ezone/luban/monitor/common/gormSerializer"
	"ezone.ksyun.com/ezone/luban/monitor/modules/network/model"
	"gorm.io/gorm"
	"gorm.io/gorm/schema"
	"gorm.io/plugin/opentelemetry/tracing"
)

type MetricTopDao struct {
	db *gorm.DB
}

type QueryParams struct {
	Region string
	Az     string
	Code   string
}

func NewMetricTopDao() *MetricTopDao {
	schema.RegisterSerializer("json_str", gormSerializer.JSONSerializer{})
	db := lib.GORMMapPool["business"].Debug()
	db.Use(tracing.NewPlugin(tracing.WithoutMetrics()))

	return &MetricTopDao{
		db: db,
	}
}

//func (m *MetricTopDao) Insert(data model.MonitorTop) error {
//	if err := m.db.Create(&data).Error; err != nil {
//		return err
//	}
//	return nil
//}

func (m *MetricTopDao) CreateOrUpdate(ctx context.Context, data model.MonitorTop) error {
	// Save update value in database, if the value doesn't have primary key, will insert it
	if err := m.db.WithContext(ctx).Save(&data).Error; err != nil {
		return err
	}
	return nil
}

func (m *MetricTopDao) GetOneByCode(ctx context.Context, q QueryParams) (model.MonitorTop, error) {
	var data model.MonitorTop
	if err := m.db.WithContext(ctx).Where("region = ? AND az = ? AND code = ?", q.Region, q.Az, q.Code).First(&data).Error; err != nil {
		return data, err
	}
	return data, nil
}

```

File path: /Users/mac/Desktop/woker_code/monitor/modules/network/dao/overview.go
```golang
package dao

import (
	"ezone.ksyun.com/ezone/luban/communal/lib"
	alarmv1alpha "ezone.ksyun.com/ezone/luban/luban_api/alarmapis/alarm/v1alpha/gen"
	resource_networkv1alpha "ezone.ksyun.com/ezone/luban/luban_api/resourceapis/resource_network/v1alpha/gen"
	resource_serverv1alpha "ezone.ksyun.com/ezone/luban/luban_api/resourceapis/resource_server/v1alpha/gen"

	"ezone.ksyun.com/ezone/luban/monitor/common/client/grpcx"
)

type NetworkStore struct {
	//rpc
	NetworkRpcClient resource_networkv1alpha.ResourceNetworkClient
	ServerRpcClient  resource_serverv1alpha.ResourceServiceClient
	AlarmRpcClient   alarmv1alpha.AlarmServiceClient

	//dao
	MetricDao    *MetricDao
	MetricTopDao *MetricTopDao
}

func NewNetworkStore() *NetworkStore {
	//resource
	resourceAddr := lib.GetStringConf("base.grpc.luban_resource")
	resourceConn, err := grpcx.NewGrpcClientConn(resourceAddr)
	if err != nil {
		lib.Log.TagError(lib.NewTrace(), lib.DLTagUndefind, map[string]interface{}{"connect luban_resource grpc server error, %s": err.Error()})
	}

	//alarm
	alarmAddr := lib.GetStringConf("base.grpc.alarm")
	alarmConn, err := grpcx.NewGrpcClientConn(alarmAddr)
	if err != nil {
		lib.Log.TagError(lib.NewTrace(), lib.DLTagUndefind, map[string]interface{}{"connect alarm grpc server error, %s": err.Error()})
	}

	return &NetworkStore{
		NetworkRpcClient: resource_networkv1alpha.NewResourceNetworkClient(resourceConn),
		ServerRpcClient:  resource_serverv1alpha.NewResourceServiceClient(resourceConn),
		AlarmRpcClient:   alarmv1alpha.NewAlarmServiceClient(alarmConn),
		MetricDao:        NewMetricDao(),
		MetricTopDao:     NewMetricTopDao(),
	}
}

```

File path: /Users/mac/Desktop/woker_code/monitor/modules/network/controller/product_nat.go
```golang
package controller

import (
	"ezone.ksyun.com/ezone/luban/communal/lib"
	"ezone.ksyun.com/ezone/luban/monitor/common/consts"
	"ezone.ksyun.com/ezone/luban/monitor/modules/network/dto"
	"ezone.ksyun.com/ezone/luban/monitor/modules/network/service"
	"ezone.ksyun.com/ezone/luban/monitor/response"
	"fmt"
	"github.com/gin-gonic/gin"
	"net/http"
)

type ProductNatController struct {
	svc *service.ProductNatService
}

func NewProductNatController() *ProductNatController {
	return &ProductNatController{
		svc: service.NewProductNatService(),
	}
}

func (p *ProductNatController) Overview(c *gin.Context) {
	// 绑定参数
	var params dto.ProductNatOverviewReq
	if err := c.ShouldBind(&params); err != nil {
		lib.Log.TagError(lib.GetTraceContext(c), lib.DLTagRequestOut, map[string]interface{}{"error": err.Error(), "params": params})
		response.Failed(c, http.StatusBadRequest, consts.ParameterError, "参数绑定失败")
		return
	}
	lib.Log.TagInfo(lib.GetTraceContext(c), lib.DLTagResponseFailed, map[string]interface{}{"params": params})

	// 业务处理
	res, err := p.svc.Overview(c.Request.Context(), &params)
	if err != nil {
		lib.Log.TagError(lib.GetTraceContext(c), lib.DLTagResponseFailed, map[string]interface{}{"error": fmt.Sprintf("%+v", err)})
		response.Failed(c, http.StatusInternalServerError, consts.GainFail, "获取概览信息失败")
		return
	}
	if res == nil {
		lib.Log.TagError(lib.GetTraceContext(c), lib.DLTagResponseFailed, map[string]interface{}{"data": res})
		response.Failed(c, http.StatusInternalServerError, consts.GainFail, "获取概览信息失败")
		return
	}
	response.Success(c, res)
}

func (p *ProductNatController) Top(c *gin.Context) {
	// 绑定参数
	var params dto.ProductNatOverviewTopReq
	if err := c.ShouldBind(&params); err != nil {
		lib.Log.TagError(lib.GetTraceContext(c), lib.DLTagRequestOut, map[string]interface{}{"error": err.Error(), "params": params})
		response.Failed(c, http.StatusBadRequest, consts.ParameterError, "参数绑定失败")
		return
	}
	lib.Log.TagInfo(lib.GetTraceContext(c), lib.DLTagResponseFailed, map[string]interface{}{"params": params})

	// 业务处理
	res, err := p.svc.OverviewTop(c.Request.Context(), &params)
	if err != nil {
		lib.Log.TagError(lib.GetTraceContext(c), lib.DLTagResponseFailed, map[string]interface{}{"error": fmt.Sprintf("%+v", err)})
		response.Failed(c, http.StatusInternalServerError, consts.GainFail, "获取概览信息失败")
		return
	}
	if res == nil {
		lib.Log.TagError(lib.GetTraceContext(c), lib.DLTagResponseFailed, map[string]interface{}{"data": res})
		response.Failed(c, http.StatusInternalServerError, consts.GainFail, "获取概览信息失败")
		return
	}
	response.Success(c, res)
}

func (p *ProductNatController) Line(c *gin.Context) {
	// 绑定参数
	var params dto.ProductNatLineReq
	if err := c.ShouldBind(&params); err != nil {
		lib.Log.TagError(lib.GetTraceContext(c), lib.DLTagRequestOut, map[string]interface{}{"error": err.Error(), "params": params})
		response.Failed(c, http.StatusBadRequest, consts.ParameterError, "参数绑定失败")
		return
	}
	lib.Log.TagInfo(lib.GetTraceContext(c), lib.DLTagResponseFailed, map[string]interface{}{"params": params})

	// 业务处理
	res, err := p.svc.NatLine(c.Request.Context(), &params)
	if err != nil {
		lib.Log.TagError(lib.GetTraceContext(c), lib.DLTagResponseFailed, map[string]interface{}{"error": fmt.Sprintf("%+v", err)})
		response.Failed(c, http.StatusInternalServerError, consts.GainFail, "获取折线图信息失败")
		return
	}
	if res == nil {
		lib.Log.TagError(lib.GetTraceContext(c), lib.DLTagResponseFailed, map[string]interface{}{"data": res})
		response.Failed(c, http.StatusInternalServerError, consts.GainFail, "获取折线图信息失败")
		return
	}
	response.Success(c, res)
}

```

File path: /Users/mac/Desktop/woker_code/monitor/modules/network/controller/product_lb.go
```golang
package controller

import (
	"ezone.ksyun.com/ezone/luban/communal/lib"
	"ezone.ksyun.com/ezone/luban/monitor/common/consts"
	"ezone.ksyun.com/ezone/luban/monitor/modules/network/dto"
	"ezone.ksyun.com/ezone/luban/monitor/modules/network/service"
	"ezone.ksyun.com/ezone/luban/monitor/response"
	"fmt"
	"github.com/gin-gonic/gin"
	"net/http"
	"strings"
)

type ProductLbController struct {
	svc    *service.ProductLbService
	eipSvc *service.ProductEipService
}

func NewProductLbController() *ProductLbController {
	return &ProductLbController{
		svc:    service.NewProductLbService(),
		eipSvc: service.NewProductEipService(),
	}
}

func (p *ProductLbController) List(c *gin.Context) {
	// 参数绑定
	var params dto.ProductLbListReq
	if err := c.ShouldBind(&params); err != nil {
		lib.Log.TagError(lib.GetTraceContext(c), lib.DLTagRequestOut, map[string]interface{}{"error": err.Error(), "params": params})
		response.Failed(c, http.StatusBadRequest, consts.ParameterError, "参数绑定失败")
		return
	}
	lib.Log.TagInfo(lib.GetTraceContext(c), lib.DLTagResponseFailed, map[string]interface{}{"params": params})

	// 业务处理
	res, err := p.svc.LbList(c, params)
	if err != nil {
		lib.Log.TagError(lib.GetTraceContext(c), lib.DLTagResponseFailed, map[string]interface{}{"error": err.Error()})
		response.Failed(c, http.StatusInternalServerError, consts.GainFail, "获取db list失败")
		return
	}

	lib.Log.TagInfo(lib.GetTraceContext(c), lib.DLTagResponseSuccess, map[string]interface{}{"res": res})
	response.Success(c, res)
}

func (p *ProductLbController) Overview(c *gin.Context) {
	// 绑定参数
	var params dto.ProductLbOverviewReq
	if err := c.ShouldBind(&params); err != nil {
		lib.Log.TagError(lib.GetTraceContext(c), lib.DLTagRequestOut, map[string]interface{}{"error": err.Error(), "params": params})
		response.Failed(c, http.StatusBadRequest, consts.ParameterError, "参数绑定失败")
		return
	}
	lib.Log.TagInfo(lib.GetTraceContext(c), lib.DLTagResponseFailed, map[string]interface{}{"params": params})

	// 业务处理
	res, err := p.svc.Overview(c.Request.Context(), &params)
	if err != nil {
		lib.Log.TagError(lib.GetTraceContext(c), lib.DLTagResponseFailed, map[string]interface{}{"error": fmt.Sprintf("%+v", err)})
		response.Failed(c, http.StatusInternalServerError, consts.GainFail, "获取概览信息失败")
		return
	}
	if res == nil {
		lib.Log.TagError(lib.GetTraceContext(c), lib.DLTagResponseFailed, map[string]interface{}{"data": res})
		response.Failed(c, http.StatusInternalServerError, consts.GainFail, "获取概览信息失败")
		return
	}
	response.Success(c, res)
}

func (p *ProductLbController) Top(c *gin.Context) {
	// 绑定参数
	var params dto.ProductLbOverviewTopReq
	if err := c.ShouldBind(&params); err != nil {
		lib.Log.TagError(lib.GetTraceContext(c), lib.DLTagRequestOut, map[string]interface{}{"error": err.Error(), "params": params})
		response.Failed(c, http.StatusBadRequest, consts.ParameterError, "参数绑定失败")
		return
	}
	lib.Log.TagInfo(lib.GetTraceContext(c), lib.DLTagResponseFailed, map[string]interface{}{"params": params})

	// 业务处理
	var eipTop bool
	for _, v := range params.MetricName {
		if strings.HasPrefix(v, "eip_") {
			eipTop = true
			break
		}
	}
	var res interface{}
	var err error
	if eipTop {
		res, err = p.eipSvc.OverviewTop(c.Request.Context(), &dto.ProductEipOverviewTopReq{
			Region:     params.Region,
			MetricName: params.MetricName,
			TopK:       params.TopK,
			Start:      params.Start,
			End:        params.End,
		})
	} else {
		res, err = p.svc.OverviewTop(c.Request.Context(), &params)
	}
	if err != nil {
		lib.Log.TagError(lib.GetTraceContext(c), lib.DLTagResponseFailed, map[string]interface{}{"error": fmt.Sprintf("%+v", err)})
		response.Failed(c, http.StatusInternalServerError, consts.GainFail, "获取概览信息失败")
		return
	}
	if res == nil {
		lib.Log.TagError(lib.GetTraceContext(c), lib.DLTagResponseFailed, map[string]interface{}{"data": res})
		response.Failed(c, http.StatusInternalServerError, consts.GainFail, "获取概览信息失败")
		return
	}
	response.Success(c, res)
}

func (p *ProductLbController) Line(c *gin.Context) {
	// 绑定参数
	var params dto.ProductLbLineReq
	if err := c.ShouldBind(&params); err != nil {
		lib.Log.TagError(lib.GetTraceContext(c), lib.DLTagRequestOut, map[string]interface{}{"error": err.Error(), "params": params})
		response.Failed(c, http.StatusBadRequest, consts.ParameterError, "参数绑定失败")
		return
	}
	lib.Log.TagInfo(lib.GetTraceContext(c), lib.DLTagResponseFailed, map[string]interface{}{"params": params})

	// 业务处理
	res, err := p.svc.LbLine(c.Request.Context(), &params)
	if err != nil {
		lib.Log.TagError(lib.GetTraceContext(c), lib.DLTagResponseFailed, map[string]interface{}{"error": fmt.Sprintf("%+v", err)})
		response.Failed(c, http.StatusInternalServerError, consts.GainFail, "获取折线图信息失败")
		return
	}
	if res == nil {
		lib.Log.TagError(lib.GetTraceContext(c), lib.DLTagResponseFailed, map[string]interface{}{"data": res})
		response.Failed(c, http.StatusInternalServerError, consts.GainFail, "获取折线图信息失败")
		return
	}
	response.Success(c, res)
}

```

File path: /Users/mac/Desktop/woker_code/monitor/modules/network/controller/network_pool.go
```golang
package controller

import (
	"ezone.ksyun.com/ezone/luban/communal/lib"
	"ezone.ksyun.com/ezone/luban/monitor/common/consts"
	"ezone.ksyun.com/ezone/luban/monitor/common/trace"
	"ezone.ksyun.com/ezone/luban/monitor/modules/network/dto"
	"ezone.ksyun.com/ezone/luban/monitor/modules/network/service"
	"ezone.ksyun.com/ezone/luban/monitor/response"
	"fmt"
	"github.com/gin-gonic/gin"
	"net/http"
)

type NetworkPoolController struct {
	svc *service.NetworkPoolService
}

func NewNetworkPoolController() *NetworkPoolController {
	return &NetworkPoolController{
		svc: service.NewNetworkPoolService(),
	}
}

func (n *NetworkPoolController) OverviewAlert(c *gin.Context) {
	// 绑定参数
	var params dto.NetworkPoolOverviewAlertReq
	if err := c.ShouldBind(&params); err != nil {
		lib.Log.TagError(lib.GetTraceContext(c), lib.DLTagRequestOut, map[string]interface{}{"error": err.Error(), "params": params})
		response.Failed(c, http.StatusBadRequest, consts.ParameterError, "参数绑定失败")
		return
	}
	lib.Log.TagInfo(lib.GetTraceContext(c), lib.DLTagResponseFailed, map[string]interface{}{"params": params})

	// 业务处理
	res, err := n.svc.OverviewAlert(c.Request.Context(), &params)
	if err != nil {
		lib.Log.TagError(lib.GetTraceContext(c), lib.DLTagResponseFailed, map[string]interface{}{"error": fmt.Sprintf("%+v", err)})
		response.Failed(c, http.StatusInternalServerError, consts.GainFail, "获取列表信息失败")
		return
	}
	if res == nil {
		lib.Log.TagError(lib.GetTraceContext(c), lib.DLTagResponseFailed, map[string]interface{}{"data": res})
		response.Failed(c, http.StatusInternalServerError, consts.GainFail, "获取列表信息失败")
		return
	}
	response.Success(c, res)

}

func (n *NetworkPoolController) OverviewMonitor(c *gin.Context) {
	// 绑定参数
	var params dto.NetworkPoolOverviewMonitorReq
	if err := c.ShouldBind(&params); err != nil {
		lib.Log.TagError(lib.GetTraceContext(c), lib.DLTagRequestOut, map[string]interface{}{"error": err.Error(), "params": params})
		response.Failed(c, http.StatusBadRequest, consts.ParameterError, "参数绑定失败")
		return
	}
	lib.Log.TagInfo(lib.GetTraceContext(c), lib.DLTagResponseFailed, map[string]interface{}{"params": params})

	// 业务处理
	res, err := n.svc.OverviewMonitor(c.Request.Context(), &params)
	if err != nil {
		lib.Log.TagError(lib.GetTraceContext(c), lib.DLTagResponseFailed, map[string]interface{}{"error": fmt.Sprintf("%+v", err)})
		response.Failed(c, http.StatusInternalServerError, consts.GainFail, "获取列表信息失败")
		return
	}
	if res == nil {
		lib.Log.TagError(lib.GetTraceContext(c), lib.DLTagResponseFailed, map[string]interface{}{"data": res})
		response.Failed(c, http.StatusInternalServerError, consts.GainFail, "获取列表信息失败")
		return
	}
	response.Success(c, res)

}

func (n *NetworkPoolController) OverviewLine(c *gin.Context) {
	// 绑定参数
	var params dto.NetworkPoolOverviewLineReq
	if err := c.ShouldBind(&params); err != nil {
		lib.Log.TagError(lib.GetTraceContext(c), lib.DLTagRequestOut, map[string]interface{}{"error": err.Error(), "params": params})
		response.Failed(c, http.StatusBadRequest, consts.ParameterError, "参数绑定失败")
		return
	}
	lib.Log.TagInfo(lib.GetTraceContext(c), lib.DLTagResponseFailed, map[string]interface{}{"params": params})

	// 业务处理
	res, err := n.svc.OverviewLine(c.Request.Context(), &params)
	if err != nil {
		lib.Log.TagError(lib.GetTraceContext(c), lib.DLTagResponseFailed, map[string]interface{}{"error": fmt.Sprintf("%+v", err)})
		response.Failed(c, http.StatusInternalServerError, consts.GainFail, "获取列表信息失败")
		return
	}
	if res == nil {
		lib.Log.TagError(lib.GetTraceContext(c), lib.DLTagResponseFailed, map[string]interface{}{"data": res})
		response.Failed(c, http.StatusInternalServerError, consts.GainFail, "获取列表信息失败")
		return
	}
	response.Success(c, res)
}

func (n *NetworkPoolController) ListLBPool(c *gin.Context) {
	// 绑定参数
	var params dto.ListNetworkPoolLBReq
	if err := c.ShouldBind(&params); err != nil {
		lib.Log.TagError(lib.GetTraceContext(c), lib.DLTagRequestOut, map[string]interface{}{"error": err.Error(), "params": params})
		response.Failed(c, http.StatusBadRequest, consts.ParameterError, "参数绑定失败")
		return
	}
	lib.Log.TagInfo(lib.GetTraceContext(c), lib.DLTagResponseFailed, map[string]interface{}{"params": params})

	// 业务处理
	res, err := n.svc.ListLBPool(c.Request.Context(), &params)
	if err != nil {
		lib.Log.TagError(lib.GetTraceContext(c), lib.DLTagResponseFailed, map[string]interface{}{"error": fmt.Sprintf("%+v", err)})
		response.Failed(c, http.StatusInternalServerError, consts.GainFail, "获取列表信息失败")
		return
	}
	if res == nil {
		lib.Log.TagError(lib.GetTraceContext(c), lib.DLTagResponseFailed, map[string]interface{}{"data": res})
		response.Failed(c, http.StatusInternalServerError, consts.GainFail, "获取列表信息失败")
		return
	}
	response.Success(c, res)
}

func (n *NetworkPoolController) ListEIPPool(c *gin.Context) {
	fmt.Printf("DEBUG - traceID: %s\n", trace.TraceIDFromContext(c.Request.Context()))

	// 绑定参数
	var params dto.ListNetworkPoolEipReq
	if err := c.ShouldBind(&params); err != nil {
		lib.Log.TagError(lib.GetTraceContext(c), lib.DLTagRequestOut, map[string]interface{}{"error": err.Error(), "params": params})
		response.Failed(c, http.StatusBadRequest, consts.ParameterError, "参数绑定失败")
		return
	}
	lib.Log.TagInfo(lib.GetTraceContext(c), lib.DLTagResponseFailed, map[string]interface{}{"params": params})

	// 业务处理
	res, err := n.svc.ListEIPPool(c.Request.Context(), &params)
	if err != nil {
		lib.Log.TagError(lib.GetTraceContext(c), lib.DLTagResponseFailed, map[string]interface{}{"error": fmt.Sprintf("%+v", err)})
		response.Failed(c, http.StatusInternalServerError, consts.GainFail, "获取列表信息失败")
		return
	}
	if res == nil {
		lib.Log.TagError(lib.GetTraceContext(c), lib.DLTagResponseFailed, map[string]interface{}{"data": res})
		response.Failed(c, http.StatusInternalServerError, consts.GainFail, "获取列表信息失败")
		return
	}
	response.Success(c, res)
}

func (n *NetworkPoolController) ListNatPool(c *gin.Context) {
	// 绑定参数
	var params dto.ListNetworkPoolNATReq
	if err := c.ShouldBind(&params); err != nil {
		lib.Log.TagError(lib.GetTraceContext(c), lib.DLTagRequestOut, map[string]interface{}{"error": err.Error(), "params": params})
		response.Failed(c, http.StatusBadRequest, consts.ParameterError, "参数绑定失败")
		return
	}
	lib.Log.TagInfo(lib.GetTraceContext(c), lib.DLTagResponseFailed, map[string]interface{}{"params": params})

	// 业务处理
	res, err := n.svc.ListNATPool(c.Request.Context(), &params)
	if err != nil {
		lib.Log.TagError(lib.GetTraceContext(c), lib.DLTagResponseFailed, map[string]interface{}{"error": fmt.Sprintf("%+v", err)})
		response.Failed(c, http.StatusInternalServerError, consts.GainFail, "获取列表信息失败")
		return
	}
	if res == nil {
		lib.Log.TagError(lib.GetTraceContext(c), lib.DLTagResponseFailed, map[string]interface{}{"data": res})
		response.Failed(c, http.StatusInternalServerError, consts.GainFail, "获取列表信息失败")
		return
	}
	response.Success(c, res)
}

func (n *NetworkPoolController) ListBMPool(c *gin.Context) {
	// 绑定参数
	var params dto.ListNetworkPoolBMReq
	if err := c.ShouldBind(&params); err != nil {
		lib.Log.TagError(lib.GetTraceContext(c), lib.DLTagRequestOut, map[string]interface{}{"error": err.Error(), "params": params})
		response.Failed(c, http.StatusBadRequest, consts.ParameterError, "参数绑定失败")
		return
	}
	lib.Log.TagInfo(lib.GetTraceContext(c), lib.DLTagResponseFailed, map[string]interface{}{"params": params})

	// 业务处理
	res, err := n.svc.ListBMPool(c.Request.Context(), &params)
	if err != nil {
		lib.Log.TagError(lib.GetTraceContext(c), lib.DLTagResponseFailed, map[string]interface{}{"error": fmt.Sprintf("%+v", err)})
		response.Failed(c, http.StatusInternalServerError, consts.GainFail, "获取列表信息失败")
		return
	}
	if res == nil {
		lib.Log.TagError(lib.GetTraceContext(c), lib.DLTagResponseFailed, map[string]interface{}{"data": res})
		response.Failed(c, http.StatusInternalServerError, consts.GainFail, "获取列表信息失败")
		return
	}
	response.Success(c, res)
}

func (n *NetworkPoolController) ListSLPool(c *gin.Context) {
	// 绑定参数
	var params dto.ListNetworkPoolSLReq
	if err := c.ShouldBind(&params); err != nil {
		lib.Log.TagError(lib.GetTraceContext(c), lib.DLTagRequestOut, map[string]interface{}{"error": err.Error(), "params": params})
		response.Failed(c, http.StatusBadRequest, consts.ParameterError, "参数绑定失败")
		return
	}
	lib.Log.TagInfo(lib.GetTraceContext(c), lib.DLTagResponseFailed, map[string]interface{}{"params": params})

	// 业务处理
	res, err := n.svc.ListSLPool(c.Request.Context(), &params)
	if err != nil {
		lib.Log.TagError(lib.GetTraceContext(c), lib.DLTagResponseFailed, map[string]interface{}{"error": fmt.Sprintf("%+v", err)})
		response.Failed(c, http.StatusInternalServerError, consts.GainFail, "获取列表信息失败")
		return
	}
	if res == nil {
		lib.Log.TagError(lib.GetTraceContext(c), lib.DLTagResponseFailed, map[string]interface{}{"data": res})
		response.Failed(c, http.StatusInternalServerError, consts.GainFail, "获取列表信息失败")
		return
	}
	response.Success(c, res)
}

func (n *NetworkPoolController) DetailLine(c *gin.Context) {
	// 绑定参数
	var params dto.NetworkPoolDetailLineReq
	if err := c.ShouldBind(&params); err != nil {
		lib.Log.TagError(lib.GetTraceContext(c), lib.DLTagRequestOut, map[string]interface{}{"error": err.Error(), "params": params})
		response.Failed(c, http.StatusBadRequest, consts.ParameterError, "参数绑定失败")
		return
	}
	lib.Log.TagInfo(lib.GetTraceContext(c), lib.DLTagResponseFailed, map[string]interface{}{"params": params})

	// 业务处理
	res, err := n.svc.DetailLine(c.Request.Context(), &params)
	if err != nil {
		lib.Log.TagError(lib.GetTraceContext(c), lib.DLTagResponseFailed, map[string]interface{}{"error": fmt.Sprintf("%+v", err)})
		response.Failed(c, http.StatusInternalServerError, consts.GainFail, "获取列表信息失败")
		return
	}
	if res == nil {
		lib.Log.TagError(lib.GetTraceContext(c), lib.DLTagResponseFailed, map[string]interface{}{"data": res})
		response.Failed(c, http.StatusInternalServerError, consts.GainFail, "获取列表信息失败")
		return
	}
	response.Success(c, res)
}

func (n *NetworkPoolController) DetailTop(c *gin.Context) {
	// 绑定参数
	var params dto.NetworkPoolDetailTopReq
	if err := c.ShouldBind(&params); err != nil {
		lib.Log.TagError(lib.GetTraceContext(c), lib.DLTagRequestOut, map[string]interface{}{"error": err.Error(), "params": params})
		response.Failed(c, http.StatusBadRequest, consts.ParameterError, "参数绑定失败")
		return
	}
	lib.Log.TagInfo(lib.GetTraceContext(c), lib.DLTagResponseFailed, map[string]interface{}{"params": params})

	// 业务处理
	res, err := n.svc.DetailTop(c.Request.Context(), &params)
	if err != nil {
		lib.Log.TagError(lib.GetTraceContext(c), lib.DLTagResponseFailed, map[string]interface{}{"error": fmt.Sprintf("%+v", err)})
		response.Failed(c, http.StatusInternalServerError, consts.GainFail, "获取列表信息失败")
		return
	}
	if res == nil {
		lib.Log.TagError(lib.GetTraceContext(c), lib.DLTagResponseFailed, map[string]interface{}{"data": res})
		response.Failed(c, http.StatusInternalServerError, consts.GainFail, "获取列表信息失败")
		return
	}
	response.Success(c, res)
}

```

File path: /Users/mac/Desktop/woker_code/monitor/modules/network/controller/product_eip.go
```golang
package controller

import (
	"ezone.ksyun.com/ezone/luban/communal/lib"
	"ezone.ksyun.com/ezone/luban/monitor/common/consts"
	"ezone.ksyun.com/ezone/luban/monitor/modules/network/dto"
	"ezone.ksyun.com/ezone/luban/monitor/modules/network/service"
	"ezone.ksyun.com/ezone/luban/monitor/response"
	"fmt"
	"github.com/gin-gonic/gin"
	"net/http"
)

type ProductEipController struct {
	svc *service.ProductEipService
}

func NewProductEipController() *ProductEipController {
	return &ProductEipController{
		svc: service.NewProductEipService(),
	}
}

func (n *ProductEipController) OverviewAlert(c *gin.Context) {
	// 绑定参数
	var params dto.ProductEipOverviewAlertReq
	if err := c.ShouldBind(&params); err != nil {
		lib.Log.TagError(lib.GetTraceContext(c), lib.DLTagRequestOut, map[string]interface{}{"error": err.Error(), "params": params})
		response.Failed(c, http.StatusBadRequest, consts.ParameterError, "参数绑定失败")
		return
	}
	lib.Log.TagInfo(lib.GetTraceContext(c), lib.DLTagResponseFailed, map[string]interface{}{"params": params})

	// 业务处理
	res, err := n.svc.OverviewAlert(c.Request.Context(), &params)
	if err != nil {
		lib.Log.TagError(lib.GetTraceContext(c), lib.DLTagResponseFailed, map[string]interface{}{"error": fmt.Sprintf("%+v", err)})
		response.Failed(c, http.StatusInternalServerError, consts.GainFail, "获取列表信息失败")
		return
	}
	if res == nil {
		lib.Log.TagError(lib.GetTraceContext(c), lib.DLTagResponseFailed, map[string]interface{}{"data": res})
		response.Failed(c, http.StatusInternalServerError, consts.GainFail, "获取列表信息失败")
		return
	}
	response.Success(c, res)
}

func (n *ProductEipController) OverviewTop(c *gin.Context) {
	// 绑定参数
	var params dto.ProductEipOverviewTopReq
	if err := c.ShouldBind(&params); err != nil {
		lib.Log.TagError(lib.GetTraceContext(c), lib.DLTagRequestOut, map[string]interface{}{"error": err.Error(), "params": params})
		response.Failed(c, http.StatusBadRequest, consts.ParameterError, "参数绑定失败")
		return
	}
	lib.Log.TagInfo(lib.GetTraceContext(c), lib.DLTagResponseFailed, map[string]interface{}{"params": params})

	// 业务处理
	res, err := n.svc.OverviewTop(c.Request.Context(), &params)
	if err != nil {
		lib.Log.TagError(lib.GetTraceContext(c), lib.DLTagResponseFailed, map[string]interface{}{"error": fmt.Sprintf("%+v", err)})
		response.Failed(c, http.StatusInternalServerError, consts.GainFail, "获取列表信息失败")
		return
	}
	if res == nil {
		lib.Log.TagError(lib.GetTraceContext(c), lib.DLTagResponseFailed, map[string]interface{}{"data": res})
		response.Failed(c, http.StatusInternalServerError, consts.GainFail, "获取列表信息失败")
		return
	}
	response.Success(c, res)
}

func (n *ProductEipController) EipInfo(c *gin.Context) {
	// 绑定参数
	var params dto.ProductEipInfoReq
	if err := c.ShouldBind(&params); err != nil {
		lib.Log.TagError(lib.GetTraceContext(c), lib.DLTagRequestOut, map[string]interface{}{"error": err.Error(), "params": params})
		response.Failed(c, http.StatusBadRequest, consts.ParameterError, "参数绑定失败")
		return
	}
	lib.Log.TagInfo(lib.GetTraceContext(c), lib.DLTagResponseFailed, map[string]interface{}{"params": params})

	// 业务处理
	res, err := n.svc.EipInfo(c.Request.Context(), &params)
	if err != nil {
		lib.Log.TagError(lib.GetTraceContext(c), lib.DLTagResponseFailed, map[string]interface{}{"error": fmt.Sprintf("%+v", err)})
		response.Failed(c, http.StatusInternalServerError, consts.GainFail, "获取列表信息失败")
		return
	}
	if res == nil {
		lib.Log.TagError(lib.GetTraceContext(c), lib.DLTagResponseFailed, map[string]interface{}{"data": res})
		response.Failed(c, http.StatusInternalServerError, consts.GainFail, "获取列表信息失败")
		return
	}
	response.Success(c, res)
}

func (n *ProductEipController) EipLine(c *gin.Context) {
	// 绑定参数
	var params dto.ProductEipLineReq
	if err := c.ShouldBind(&params); err != nil {
		lib.Log.TagError(lib.GetTraceContext(c), lib.DLTagRequestOut, map[string]interface{}{"error": err.Error(), "params": params})
		response.Failed(c, http.StatusBadRequest, consts.ParameterError, "参数绑定失败")
		return
	}
	lib.Log.TagInfo(lib.GetTraceContext(c), lib.DLTagResponseFailed, map[string]interface{}{"params": params})

	// 业务处理
	res, err := n.svc.EipLine(c.Request.Context(), &params)
	if err != nil {
		lib.Log.TagError(lib.GetTraceContext(c), lib.DLTagResponseFailed, map[string]interface{}{"error": fmt.Sprintf("%+v", err)})
		response.Failed(c, http.StatusInternalServerError, consts.GainFail, "获取列表信息失败")
		return
	}
	if res == nil {
		lib.Log.TagError(lib.GetTraceContext(c), lib.DLTagResponseFailed, map[string]interface{}{"data": res})
		response.Failed(c, http.StatusInternalServerError, consts.GainFail, "获取列表信息失败")
		return
	}
	response.Success(c, res)
}

```

File path: /Users/mac/Desktop/woker_code/monitor/modules/network/constant/constant.go
```golang
package constant

const (
	Xgw     = "XGW"
	Tengine = "Tengine"
	Kgw     = "KGW"
	Sgw     = "SGW"
	Nat     = "NAT"
	Pgw     = "PGW"
	Tgw     = "TGW"

	Lb  = "LB"  //负载均衡
	Eip = "EIP" //弹性IP
	Bm  = "BM"  //裸金属
	Sl  = "SL"  //专线
	P2p = "P2P" // peer to peer 对等连接
	Vpn = "VPN" //VPN

	XgwLb     = "XGW-LB"
	XgwEip    = "XGW-EIP"
	TengineLb = "Tengine-LB"
	KgwLb     = "KGW-LB"
	SgwEip    = "SGW-EIP"
	NatNat    = "NAT"
	PgwBm     = "PGW-BM"
	TgwSl     = "TGW-SL"
	TgwP2p    = "TGW-P2P"
	TgwVpn    = "TGW-VPN"
)

```

File path: /Users/mac/Desktop/woker_code/monitor/modules/network/model/monitor_tsdb_metrics.go
```golang
package model

import (
	"time"
)

type MonitorTsdbMetrics struct {
	ID           int       `gorm:"column:id;primary_key;AUTO_INCREMENT"`
	ProductLine  string    `gorm:"column:product_line;NOT NULL"` // 产品线
	Code         string    `gorm:"column:code;NOT NULL"`         // 唯一标识
	Name         string    `gorm:"column:name;NOT NULL"`         // 中文名
	DisplayName  string    `gorm:"column:display_name;NOT NULL"`
	MetricPrefix string    `gorm:"column:metric_prefix;NOT NULL"` // metric前缀
	Unit         string    `gorm:"column:unit;NOT NULL;default:''"`
	CreatedAt    time.Time `gorm:"column:created_at;default:CURRENT_TIMESTAMP"`
	UpdatedAt    time.Time `gorm:"column:updated_at;default:CURRENT_TIMESTAMP"`
	DeletedAt    time.Time `gorm:"column:deleted_at"`
}

func (m *MonitorTsdbMetrics) TableName() string {
	return "monitor_tsdb_metrics"
}

```

File path: /Users/mac/Desktop/woker_code/monitor/modules/network/model/monitor_top.go
```golang
package model

import (
	"ezone.ksyun.com/ezone/luban/monitor/common/client/opentsdb"
	"fmt"
	"time"
)

// region + az + code 唯一
type MonitorTop struct {
	ID                  int        `gorm:"column:id;primary_key;AUTO_INCREMENT"`        // 主键
	ProductLine         string     `gorm:"column:product_line;NOT NULL"`                // 产品线
	Region              string     `gorm:"column:region;NOT NULL"`                      // 区域
	Az                  string     `gorm:"column:az;NOT NULL"`                          // 可用区
	Code                string     `gorm:"column:code;NOT NULL"`                        // top项的唯一标识
	Name                string     `gorm:"column:name;NOT NULL"`                        // 中文名
	HalfHour            []TopValue `gorm:"column:half_hour;serializer:json_str"`        // 0.5h top10数据
	HalfHourUpdateAt    time.Time  `gorm:"column:half_hour_update_at"`                  // 0.5h更新时间
	OneHour             []TopValue `gorm:"column:one_hour;serializer:json_str"`         // 1h top10数据
	OneHourUpdateAt     time.Time  `gorm:"column:one_hour_update_at"`                   // 1h更新时间
	ThreeHours          []TopValue `gorm:"column:three_hours;serializer:json_str"`      // 3h top10数据
	ThreeHoursUpdateAt  time.Time  `gorm:"column:three_hours_update_at"`                // 3h更新时间
	TwelveHours         []TopValue `gorm:"column:twelve_hours;serializer:json_str"`     // 12h top10数据
	TwelveHoursUpdateAt time.Time  `gorm:"column:twelve_hours_update_at"`               // 12h更新时间
	OneDay              []TopValue `gorm:"column:one_day;serializer:json_str"`          // 1d top10数据
	OneDayUpdateAt      time.Time  `gorm:"column:one_day_update_at"`                    // 1d更新时间
	SevenDays           []TopValue `gorm:"column:seven_days;serializer:json_str"`       // 7d top10数据
	SevenDaysUpdateAt   time.Time  `gorm:"column:seven_days_update_at"`                 // 7d更新时间
	ThirtyDays          []TopValue `gorm:"column:thirty_days;serializer:json_str"`      // 30d top10数据
	ThirtyDaysUpdateAt  time.Time  `gorm:"column:thirty_days_update_at"`                // 30d更新时间
	CreatedAt           time.Time  `gorm:"column:created_at;default:CURRENT_TIMESTAMP"` // 创建时间
	UpdatedAt           time.Time  `gorm:"column:updated_at;default:CURRENT_TIMESTAMP"` // 更新时间
	DeletedAt           time.Time  `gorm:"column:deleted_at"`                           // 删除时间
}

type TopValue struct {
	Id    string  //实例唯一id
	Name  string  //名称
	Value float64 //值
}

func (m *MonitorTop) TableName() string {
	return "monitor_top"
}

func (m *MonitorTop) ParseIntervalData(start, end int64) []TopValue {
	var intervalData []TopValue
	intervalStr := opentsdb.ParseTimeInterval(start, end)
	fmt.Printf("DEBUG: intervalStr:%s\n", intervalStr)
	switch intervalStr {
	case "0.5h":
		intervalData = m.HalfHour
	case "1h":
		intervalData = m.OneHour
	case "3h":
		intervalData = m.ThreeHours
	case "12h":
		intervalData = m.TwelveHours
	case "1d":
		intervalData = m.OneDay
	case "7d":
		intervalData = m.SevenDays
	case "30d":
		intervalData = m.ThirtyDays
	}
	return intervalData
}

```

File path: /Users/mac/Desktop/woker_code/monitor/modules/network/model/network_pool.go
```golang
package model

import "time"

// NetworkPool 网络资源池信息
type NetworkPool struct {
	Galaxy         string    `gorm:"column:galaxy"`          // 环境
	Region         string    `gorm:"column:region"`          // 区域
	Az             string    `gorm:"column:az"`              // 可用区
	Deleted        int       `gorm:"column:deleted"`         // 是否删除
	LastUpdateAt   time.Time `gorm:"column:last_update_at"`  // 最后更新时间
	PoolID         string    `gorm:"column:pool_id"`         // 资源池ID
	PoolName       string    `gorm:"column:pool_name"`       // 资源池名称
	ID             uint64    `gorm:"column:id"`              // 自增ID
	CreatedAt      time.Time `gorm:"column:created_at"`      // 创建时间
	UpdatedAt      time.Time `gorm:"column:updated_at"`      // 更新时间
	DeletedAt      time.Time `gorm:"column:deleted_at"`      // 删除时间
	PoolType       string    `gorm:"column:pool_type"`       // 资源池类型
	ServerCount    int       `gorm:"column:server_count"`    // 服务器数量
	Hosts          string    `gorm:"column:hosts"`           // 主机列表
	ExtensionCount string    `gorm:"column:extension_count"` // 扩展数量
}

type NetworkPoolInventory struct {
	Id        int       `gorm:"column:id"`
	CreatedAt time.Time `gorm:"column:created_at"`
	UpdatedAt time.Time `gorm:"column:updated_at"`
	DeletedAt time.Time `gorm:"column:deleted_at"`

	Galaxy       string    `gorm:"column:galaxy"`
	Region       string    `gorm:"column:region"`
	Az           string    `gorm:"column:az"`
	Deleted      int       `gorm:"column:deleted"`
	LastUpdateAt time.Time `gorm:"column:last_update_at"`

	PoolType         string  `gorm:"column:pool_type"`
	WayType          string  `gorm:"column:way_type"`
	Cidr             string  `gorm:"column:cidr"`
	IpCount          int     `gorm:"column:ip_count"`
	IpUsedCount      int     `gorm:"column:ip_used_count"`
	IpValidCount     int     `gorm:"column:ip_valid_count"`
	IpRemindCount    int     `gorm:"column:ip_remind_count"`
	IpUsedRatio      float64 `gorm:"column:ip_used_ratio"`
	IpAvailableRatio float64 `gorm:"column:ip_available_ratio"`
	CpuTotal         int     `gorm:"column:cpu_total"`
	MemTotal         int     `gorm:"column:mem_total"`
}

type NetworkPoolClusters struct {
	Galaxy          string    `gorm:"column:galaxy"`
	Region          string    `gorm:"column:region"`
	Az              string    `gorm:"column:az"`
	Deleted         int       `gorm:"column:deleted"`
	LastUpdateAt    time.Time `gorm:"column:last_update_at"`
	Id              uint64    `gorm:"column:id"`
	CreatedAt       time.Time `gorm:"column:created_at"`
	UpdatedAt       time.Time `gorm:"column:updated_at"`
	DeletedAt       time.Time `gorm:"column:deleted_at"`
	Name            string    `gorm:"column:name"`
	Count           int       `gorm:"column:count"`
	InstancesCounts string    `gorm:"column:instances_counts"`
}

type NetworkProductEip struct {
	Id     int    `gorm:"column:id"`
	Galaxy string `gorm:"column:galaxy"`
	Region string `gorm:"column:region"`
	Az     string `gorm:"column:az"`
	//Deleted      int       `gorm:"column:deleted"`
	//LastUpdateAt int64     `gorm:"column:last_update_at"`
	PoolId       string    `gorm:"column:pool_id"`
	PoolName     string    `gorm:"column:pool_name"`
	TenantId     string    `gorm:"column:tenant_id"`
	TenantName   string    `gorm:"column:tenant_name"`
	ProjectId    string    `gorm:"column:project_id"`
	ProjectName  string    `gorm:"column:project_name"`
	InstanceId   string    `gorm:"column:instance_id"`
	InstanceName string    `gorm:"column:instance_name"`
	CreatedAt    time.Time `gorm:"column:created_at"`
	UpdatedAt    time.Time `gorm:"column:updated_at"`
	DeletedAt    time.Time `gorm:"column:deleted_at"`

	XgwCluster string    `gorm:"column:xgw_cluster"`
	IpAddr     string    `gorm:"column:ip_addr"`
	BoundState int       `gorm:"column:bound_state"`
	NetSegName string    `gorm:"column:net_seg_name"`
	Cidr       string    `gorm:"column:cidr"`
	IpVersion  string    `gorm:"column:ip_version"`
	WayType    string    `gorm:"column:way_type"`
	BoundType  string    `gorm:"column:bound_type"`
	BoundName  string    `gorm:"column:bound_name"`
	BoundId    string    `gorm:"column:bound_id"`
	NetCard    string    `gorm:"column:net_card"`
	CardType   string    `gorm:"column:card_type"`
	Bandwidth  string    `gorm:"column:bandwidth"`
	RowNum     int       `gorm:"column:row_num"`
	CreateTime time.Time `gorm:"column:create_time"`
}

type VmDetail struct {
	Id                     string `gorm:"column:id"`
	TenantId               string `gorm:"column:tenant_id"`
	TenantName             string `gorm:"column:tenant_name"`
	Status                 string `gorm:"column:status"`
	Name                   string `gorm:"column:name"`
	Aggregate              string `gorm:"column:aggregate"`
	AggregateId            int    `gorm:"column:aggregate_id"`
	Region                 string `gorm:"column:region"`
	RegionName             string `gorm:"column:region_name"`
	Az                     string `gorm:"column:az"`
	AzName                 string `gorm:"column:az_name"`
	Host                   string `gorm:"column:host"`
	VmName                 string `gorm:"column:vm_name"`
	Business               string `gorm:"column:business"`
	OpsLabel               string `gorm:"column:ops_label"`
	Label                  string `gorm:"column:label"`
	ImageId                string `gorm:"column:image_id"`
	DataGuardSet           string `gorm:"column:data_guard_set"`
	AdminPass              string `gorm:"column:admin_pass"`
	CreateTime             int    `gorm:"column:create_time"`
	EndTime                int    `gorm:"column:end_time"`
	DeleteTime             int    `gorm:"column:delete_time"`
	InstanceType           string `gorm:"column:instance_type"`
	Size                   string `gorm:"column:size"`
	Os                     string `gorm:"column:os"`
	SysDisk                string `gorm:"column:sys_disk"`
	DataDisk               string `gorm:"column:data_disk"`
	IncId                  string `gorm:"column:inc_id"`
	Eip                    string `gorm:"column:eip"`
	Dns1                   string `gorm:"column:dns1"`
	Dns2                   string `gorm:"column:dns2"`
	InternetIpv4           string `gorm:"column:internet_ipv4"`
	SecurityGroup          string `gorm:"column:security_group"`
	Vpc                    string `gorm:"column:vpc"`
	SubNetwork             string `gorm:"column:sub_network"`
	InnerIp                string `gorm:"column:inner_ip"`
	NetworkData            string `gorm:"column:network_data"`
	KeySet                 string `gorm:"column:key_set"`
	KeyList                string `gorm:"column:key_list"`
	DataGuardList          string `gorm:"column:data_guard_list"`
	SecurityList           string `gorm:"column:security_list"`
	LocalVolumeSetDataList string `gorm:"column:local_volume_set_data_list"`
	EbsVolumes             string `gorm:"column:ebs_volumes"`
	Hostname               string `gorm:"column:hostname"`
	MetricDir              string `gorm:"column:metric_dir"`
}

```

File path: /Users/mac/Desktop/woker_code/monitor/modules/network/service/product_nat.go
```golang
package service

import (
	"context"
	resource_networkv1alpha "ezone.ksyun.com/ezone/luban/luban_api/resourceapis/resource_network/v1alpha/gen"
	"ezone.ksyun.com/ezone/luban/monitor/common/client/opentsdb"
	"ezone.ksyun.com/ezone/luban/monitor/common/client/opentsdb/pkg"
	"ezone.ksyun.com/ezone/luban/monitor/common/tools"
	"ezone.ksyun.com/ezone/luban/monitor/common/tsdbql_template"
	"ezone.ksyun.com/ezone/luban/monitor/common/types"
	"ezone.ksyun.com/ezone/luban/monitor/modules/network/dao"
	"ezone.ksyun.com/ezone/luban/monitor/modules/network/dto"
	"fmt"
	"github.com/pkg/errors"
	"net/http"
)

type ProductNatService struct {
	Store dao.NetworkStore
}

func NewProductNatService() *ProductNatService {
	return &ProductNatService{
		Store: *dao.NewNetworkStore(),
	}
}

func (p *ProductNatService) Overview(ctx context.Context, par *dto.ProductNatOverviewReq) (*dto.ProductNatOverviewTopRsp, error) {
	natListRsp, err := p.Store.NetworkRpcClient.ListNat(ctx, &resource_networkv1alpha.ListNatReq{
		PageSize: -1,
		Region:   par.Region,
		Az:       []string{par.Az},
	})
	if err != nil {
		fmt.Printf("error query rpc ListNat: %v", err)
		return nil, err
	}

	var (
		public  = 0 //公网
		private = 0 // 内网
		i       = int64(0)
	)
	for ; i < natListRsp.TotalCount; i++ {
		switch natListRsp.NatSet[i].NatType {
		case "public":
			public++
		default:
			private++
		}
	}
	values := []types.BasicOverviewSlotValue{
		{
			Name:  "公网",
			Value: public,
		},
		{
			Name:  "金山云内网",
			Value: private,
		},
	}
	slot := types.BasicOverviewSlot{
		Info: types.BasicOverviewSlotInfo{
			Name:  "NAT统计",
			Value: natListRsp.TotalCount,
		},
		Values: values,
	}
	tops := []types.BasicOverviewSlot{slot}
	return &dto.ProductNatOverviewTopRsp{
		Tops: tops,
	}, nil
}

func (p *ProductNatService) OverviewTop(ctx context.Context, par *dto.ProductNatOverviewTopReq) (*dto.ProductNatOverviewTopRsp, error) {
	tops := []types.BasicOverviewSlot{}

	for _, name := range par.MetricName {
		tsdbMetric, err := p.Store.MetricDao.GetOneByCode(ctx, name)
		if err != nil {
			return nil, errors.WithMessagef(err, "get tsdb metric %s err", name)
		}
		if tsdbMetric == nil {
			return nil, errors.WithMessagef(fmt.Errorf("record not found"), "get tsdb metric %s err", name)
		}
		topData, err := p.Store.MetricTopDao.GetOneByCode(ctx, dao.QueryParams{
			Region: par.Region,
			Az:     par.Az,
			Code:   name,
		})
		if err != nil {
			return nil, err
		}

		intervalData := topData.ParseIntervalData(par.Start, par.End)
		//topK
		if par.TopK > 10 {
			return nil, fmt.Errorf("topK is too large")
		}
		if par.TopK < len(intervalData) {
			intervalData = intervalData[:par.TopK]
		}

		values := []types.BasicOverviewSlotValue{}
		for k, v := range intervalData {
			value := types.BasicOverviewSlotValue{
				Name:     fmt.Sprintf("Top%d", k+1),
				SubName:  v.Name,
				Code:     v.Id,
				Value:    v.Value,
				Unit:     tsdbMetric.Unit,
				UnitType: types.ParseUnitTypeByUnit(tsdbMetric.Unit),
				Kind:     types.KindInfo,
			}
			values = append(values, value)
		}

		slot := types.BasicOverviewSlot{
			Info: types.BasicOverviewSlotInfo{
				Index:       0,
				Name:        tsdbMetric.DisplayName,
				Value:       0,
				UnitType:    types.ParseUnitTypeByUnit(tsdbMetric.Unit),
				Unit:        tsdbMetric.Unit,
				Kind:        types.KindInfo,
				Prognosis:   0,
				Description: "",
			},
			Values: values,
		}
		tops = append(tops, slot)
	}

	return &dto.ProductNatOverviewTopRsp{
		Tops: tops,
	}, nil
}

func (p *ProductNatService) NatLine(ctx context.Context, par *dto.ProductNatLineReq) (*dto.ProductNatLineRsp, error) {
	natInfo, err := p.Store.NetworkRpcClient.DetailNat(ctx, &resource_networkv1alpha.DetailNatReq{NatId: par.ID})
	if err != nil {
		return nil, errors.WithMessage(err, "rpc call DetailNat err")
	}
	if natInfo == nil || natInfo.NatId == "" {
		return nil, errors.New(fmt.Sprintf("nat instance %s not found", par.ID))
	}
	region := natInfo.Region
	queryParam := pkg.QueryParam{
		Start: par.Start,
		End:   par.End,
	}
	lines := make([]types.BasicOverviewSlot, 0)
	for _, name := range par.MetricName {
		subqueries := make([]pkg.SubQuery, 0)
		tsdbMetric, err := p.Store.MetricDao.GetOneByCode(ctx, name)
		if err != nil {
			return nil, errors.WithMessagef(err, "get tsdb metric %s err", name)
		}
		if tsdbMetric == nil {
			return nil, errors.WithMessagef(fmt.Errorf("record not found"), "get tsdb metric %s err", name)
		}
		eipQuery := tsdbql_template.ParseTsdbQuery(tsdbMetric.ProductLine, tsdbMetric.MetricPrefix, par.ID)
		subqueries = append(subqueries, pkg.SubQuery{
			Aggregator: "sum",
			Metric:     eipQuery.Metric,
			Tags:       map[string]string{"host": eipQuery.HostTag},
			Downsample: opentsdb.TimeToDownsample(par.End - par.Start),
		})

		queryParam.Queries = subqueries
		queryResp, err := opentsdb.Query(ctx, region, queryParam)
		if err != nil {
			return nil, errors.WithMessagef(err, "tsdb query err, param : %v", queryParam)
		}
		//查询404返回空数据
		if queryResp.StatusCode != http.StatusOK {
			if queryResp.StatusCode == http.StatusNotFound {
				return &dto.ProductNatLineRsp{Lines: lines}, nil
			}
			return nil, errors.New("tsdb query response failed")
		}
		//查询200,但是数据为空，返回空数据
		if len(queryResp.QueryRespCnts) <= 0 {
			return &dto.ProductNatLineRsp{Lines: lines}, nil
		}

		line := types.BasicOverviewSlot{
			Info: types.BasicOverviewSlotInfo{
				Index:       0,
				Name:        tsdbMetric.DisplayName,
				Value:       nil,
				UnitType:    types.ParseUnitTypeByUnit(tsdbMetric.Unit),
				Unit:        tsdbMetric.Unit,
				Kind:        types.KindInfo,
				Prognosis:   0,
				Description: "",
			},
		}

		dataPoints := queryResp.QueryRespCnts[0].GetDataPoints()
		for _, v := range dataPoints {
			if tsdbMetric.Unit == "%" {
				v.Value = tools.FormPercent(v.Value.(float64) / 1e2)
			}
			line.Values = append(line.Values, types.BasicOverviewSlotValue{
				Name:        fmt.Sprintf("%d", tools.UnixToUnixMilli(v.Timestamp)),
				Code:        "",
				Value:       v.Value,
				Unit:        tsdbMetric.Unit,
				UnitType:    types.ParseUnitTypeByUnit(tsdbMetric.Unit),
				Kind:        types.KindInfo,
				Description: v.Metric,
			})
		}
		lines = append(lines, line)
	}

	return &dto.ProductNatLineRsp{
		Lines: lines,
	}, nil
}

```

File path: /Users/mac/Desktop/woker_code/monitor/modules/network/service/product_lb.go
```golang
package service

import (
	"context"
	resource_networkv1alpha "ezone.ksyun.com/ezone/luban/luban_api/resourceapis/resource_network/v1alpha/gen"
	"ezone.ksyun.com/ezone/luban/monitor/common/client/opentsdb"
	"ezone.ksyun.com/ezone/luban/monitor/common/client/opentsdb/pkg"
	"ezone.ksyun.com/ezone/luban/monitor/common/tools"
	"ezone.ksyun.com/ezone/luban/monitor/common/tsdbql_template"
	"ezone.ksyun.com/ezone/luban/monitor/common/tsdbql_template/lb"
	"ezone.ksyun.com/ezone/luban/monitor/common/types"
	"ezone.ksyun.com/ezone/luban/monitor/modules/network/dao"
	"ezone.ksyun.com/ezone/luban/monitor/modules/network/dto"
	"fmt"
	"github.com/gin-gonic/gin"
	"github.com/pkg/errors"
	"k8s.io/klog/v2"
	"net/http"
)

type ProductLbService struct {
	Store dao.NetworkStore
}

func NewProductLbService() *ProductLbService {
	return &ProductLbService{
		Store: *dao.NewNetworkStore(),
	}
}

func (p *ProductLbService) LbList(ctx *gin.Context, par dto.ProductLbListReq) (*dto.ProductLbListRsp, error) {
	//获取
	rpcResult, err := p.Store.NetworkRpcClient.ListLb(ctx, &resource_networkv1alpha.ListLbReq{
		PageNo:            1,
		PageSize:          -1,
		LoadBalancerType:  par.LoadBalancerType,
		LoadBalancerState: par.LoadBalancerState,
		LineType:          par.LineType,
		Type:              par.Type,
		Region:            par.Region,
		Az:                par.Az,
		PoolName:          par.PoolName,
		TenantId:          par.TenantId,
		TenantName:        par.TenantName,
		ProjectName:       par.ProjectName,
		OrderCode:         par.OrderCode,
		OrderType:         par.OrderType,
		Query:             par.Query,
	})
	if err != nil {
		return nil, err
	}
	var lbList []dto.Lb

	for _, v := range rpcResult.LoadBalancerSet {
		lbList = append(lbList, dto.Lb{
			LoadBalancerName:  v.LoadBalancerName,
			LoadBalancerId:    v.LoadBalancerId,
			LoadBalancerType:  v.LoadBalancerType,
			LoadBalancerState: v.LoadBalancerState,
			LineType:          v.LineType,
			VpcName:           v.VpcName,
			PublicIp:          v.PublicIp,
			Region:            v.Region,
			PoolName:          v.PoolName,
			TenantId:          v.TenantId,
			TenantName:        v.TenantName,
			ProjectName:       v.ProjectName,
			CreateTime:        v.CreateTime,
		})
	}
	//分页
	low := (par.PageNo - 1) * par.PageSize
	if low > len(rpcResult.LoadBalancerSet) {
		klog.Info("PageSize is too large")
	}

	high := low + par.PageSize
	if high > len(rpcResult.LoadBalancerSet) {
		high = len(rpcResult.LoadBalancerSet)
	}

	var results dto.ProductLbListRsp
	results.PageSize = par.PageSize
	results.PageNo = par.PageNo
	results.TotalCount = int64(len(rpcResult.LoadBalancerSet))
	results.List = lbList[low:high]

	return &results, err
}

func (p *ProductLbService) Overview(ctx context.Context, par *dto.ProductLbOverviewReq) (*dto.ProductLbOverviewTopRsp, error) {
	lbListRsp, err := p.Store.NetworkRpcClient.ListLb(ctx, &resource_networkv1alpha.ListLbReq{
		PageSize: -1,
		Region:   par.Region,
		Az:       []string{par.Az},
	})
	if err != nil {
		fmt.Printf("error query rpc ListLb: %v", err)
		return nil, err
	}

	var (
		active   = 0 //运行中
		shutdown = 0 //已停止
		i        = int64(0)
	)
	for ; i < lbListRsp.TotalCount; i++ {
		switch lbListRsp.LoadBalancerSet[i].LoadBalancerState {
		case "start":
			active++
		default:
			shutdown++
		}
	}
	values := []types.BasicOverviewSlotValue{
		{
			Name:  "运行中",
			Value: active,
		},
		{
			Name:  "已停止",
			Value: shutdown,
		},
	}
	slot := types.BasicOverviewSlot{
		Info: types.BasicOverviewSlotInfo{
			Name:  "实例状态",
			Value: lbListRsp.TotalCount,
		},
		Values: values,
	}
	tops := []types.BasicOverviewSlot{slot}
	return &dto.ProductLbOverviewTopRsp{
		Tops: tops,
	}, nil
}

func (p *ProductLbService) OverviewTop(ctx context.Context, par *dto.ProductLbOverviewTopReq) (*dto.ProductLbOverviewTopRsp, error) {
	tops := []types.BasicOverviewSlot{}

	for _, name := range par.MetricName {
		tsdbMetric, err := p.Store.MetricDao.GetOneByCode(ctx, name)
		if err != nil {
			return nil, errors.WithMessagef(err, "get tsdb metric %s err", name)
		}
		if tsdbMetric == nil {
			return nil, errors.WithMessagef(fmt.Errorf("record not found"), "get tsdb metric %s err", name)
		}
		topData, err := p.Store.MetricTopDao.GetOneByCode(ctx, dao.QueryParams{
			Region: par.Region,
			Az:     par.Az,
			Code:   name,
		})
		if err != nil {
			return nil, err
		}

		intervalData := topData.ParseIntervalData(par.Start, par.End)
		//topK
		if par.TopK > 10 {
			return nil, fmt.Errorf("topK is too large")
		}
		if par.TopK < len(intervalData) {
			intervalData = intervalData[:par.TopK]
		}

		values := []types.BasicOverviewSlotValue{}
		for k, v := range intervalData {
			value := types.BasicOverviewSlotValue{
				Name:     v.Name,
				Code:     v.Id,
				Value:    v.Value,
				Unit:     tsdbMetric.Unit,
				UnitType: types.ParseUnitTypeByUnit(tsdbMetric.Unit),
				Kind:     types.KindInfo,
			}
			if name != lb.Lb_cps {
				value.SubName = value.Name
				value.Name = fmt.Sprintf("Top%d", k+1)
			}
			values = append(values, value)
		}

		slot := types.BasicOverviewSlot{
			Info: types.BasicOverviewSlotInfo{
				Index:       0,
				Name:        tsdbMetric.DisplayName,
				Value:       0,
				UnitType:    types.ParseUnitTypeByUnit(tsdbMetric.Unit),
				Unit:        tsdbMetric.Unit,
				Kind:        types.KindInfo,
				Prognosis:   0,
				Description: "",
			},
			Values: values,
		}
		tops = append(tops, slot)
	}

	return &dto.ProductLbOverviewTopRsp{
		Tops: tops,
	}, nil
}

func (p *ProductLbService) LbLine(ctx context.Context, par *dto.ProductLbLineReq) (*dto.ProductLbLineRsp, error) {
	lbInfo, err := p.Store.NetworkRpcClient.DetailLb(ctx, &resource_networkv1alpha.DetailLbReq{LoadBalancerId: par.ID})
	if err != nil {
		return nil, errors.WithMessage(err, "rpc call DetailLb err")
	}
	if lbInfo == nil || lbInfo.LoadBalancerId == "" {
		return nil, errors.New(fmt.Sprintf("lb instance %s not found", par.ID))
	}
	region := lbInfo.Region
	queryParam := pkg.QueryParam{
		Start: par.Start,
		End:   par.End,
	}
	lines := make([]types.BasicOverviewSlot, 0)
	for _, name := range par.MetricName {
		subqueries := make([]pkg.SubQuery, 0)
		tsdbMetric, err := p.Store.MetricDao.GetOneByCode(ctx, name)
		if err != nil {
			return nil, errors.WithMessagef(err, "get tsdb metric %s err", name)
		}
		if tsdbMetric == nil {
			return nil, errors.WithMessagef(fmt.Errorf("record not found"), "get tsdb metric %s err", name)
		}
		eipQuery := tsdbql_template.ParseTsdbQuery(tsdbMetric.ProductLine, tsdbMetric.MetricPrefix, par.ID)
		subqueries = append(subqueries, pkg.SubQuery{
			Aggregator: "sum",
			Metric:     eipQuery.Metric,
			Tags:       map[string]string{"host": eipQuery.HostTag},
			Downsample: opentsdb.TimeToDownsample(par.End - par.Start),
		})

		queryParam.Queries = subqueries
		queryResp, err := opentsdb.Query(ctx, region, queryParam)
		if err != nil {
			return nil, errors.WithMessagef(err, "tsdb query err, param : %v", queryParam)
		}
		//查询404返回空数据
		if queryResp.StatusCode != http.StatusOK {
			if queryResp.StatusCode == http.StatusNotFound {
				return &dto.ProductLbLineRsp{Lines: lines}, nil
			}
			return nil, errors.New("tsdb query response failed")
		}
		//查询200,但是数据为空，返回空数据
		if len(queryResp.QueryRespCnts) <= 0 {
			return &dto.ProductLbLineRsp{Lines: lines}, nil
		}

		line := types.BasicOverviewSlot{
			Info: types.BasicOverviewSlotInfo{
				Index:       0,
				Name:        tsdbMetric.DisplayName,
				Value:       nil,
				UnitType:    types.ParseUnitTypeByUnit(tsdbMetric.Unit),
				Unit:        tsdbMetric.Unit,
				Kind:        types.KindInfo,
				Prognosis:   0,
				Description: "",
			},
		}

		dataPoints := queryResp.QueryRespCnts[0].GetDataPoints()
		for _, v := range dataPoints {
			if tsdbMetric.Unit == "%" {
				v.Value = tools.FormPercent(v.Value.(float64) / 1e2)
			}
			line.Values = append(line.Values, types.BasicOverviewSlotValue{
				Name:        fmt.Sprintf("%d", tools.UnixToUnixMilli(v.Timestamp)),
				Code:        "",
				Value:       v.Value,
				Unit:        tsdbMetric.Unit,
				UnitType:    types.ParseUnitTypeByUnit(tsdbMetric.Unit),
				Kind:        types.KindInfo,
				Description: v.Metric,
			})
		}
		lines = append(lines, line)
	}

	return &dto.ProductLbLineRsp{
		Lines: lines,
	}, nil
}

```

File path: /Users/mac/Desktop/woker_code/monitor/modules/network/service/network_pool.go
```golang
package service

import (
	"context"
	"fmt"
	"strconv"
	"strings"
	"time"

	template "ezone.ksyun.com/ezone/luban/monitor/common/promql_template"
	"ezone.ksyun.com/ezone/luban/monitor/common/promql_template/network"
	"ezone.ksyun.com/ezone/luban/monitor/common/promql_template/server"
	"ezone.ksyun.com/ezone/luban/monitor/common/tools"
	"ezone.ksyun.com/ezone/luban/monitor/common/trace"
	"ezone.ksyun.com/ezone/luban/monitor/common/utils"
	"github.com/pkg/errors"
	v1 "github.com/prometheus/client_golang/api/prometheus/v1"
	prom_model "github.com/prometheus/common/model"

	alarmv1alpha "ezone.ksyun.com/ezone/luban/luban_api/alarmapis/alarm/v1alpha/gen"
	resource_networkv1alpha "ezone.ksyun.com/ezone/luban/luban_api/resourceapis/resource_network/v1alpha/gen"
	resource_serverv1alpha "ezone.ksyun.com/ezone/luban/luban_api/resourceapis/resource_server/v1alpha/gen"
	prom_client "ezone.ksyun.com/ezone/luban/monitor/common/client/prom"
	"ezone.ksyun.com/ezone/luban/monitor/common/types"
	"ezone.ksyun.com/ezone/luban/monitor/modules/network/dao"
	"ezone.ksyun.com/ezone/luban/monitor/modules/network/dto"
	"github.com/jinzhu/copier"
)

var (
	alertLevels      = []string{"p0", "p1", "p2", "p3"}
	_alertLevelsName = map[string]string{
		"p0": "紧急告警",
		"p1": "重要告警",
		"p2": "次要告警",
		"p3": "提醒告警",
	}
	poolTypes      = []string{"XGW", "Tengine", "SGW", "NAT", "KGW"}
	_poolTypesName = map[string]string{
		"XGW":     "XGW集群",
		"Tengine": "Tengine集群",
		"SGW":     "SGW集群",
		"NAT":     "NAT集群",
		"KGW":     "KGW集群",
		"PGW":     "PGW集群",
		"TGW":     "TGW集群",
	}
)

type NetworkPoolService struct {
	Store dao.NetworkStore
}

func NewNetworkPoolService() *NetworkPoolService {
	return &NetworkPoolService{
		Store: *dao.NewNetworkStore(),
	}
}

func (n *NetworkPoolService) OverviewAlert(ctx context.Context, par *dto.NetworkPoolOverviewAlertReq) (*dto.NetworkPoolOverviewAlertRsp, error) {

	alerts, err := n.Store.AlarmRpcClient.ListAlerts(ctx, &alarmv1alpha.ListAlertsRequest{
		PageNo:   -1,
		PageSize: -1,
		Region:   par.Region,
		Status:   "firing",
	})

	if err != nil {
		return nil, errors.WithMessage(err, "rpc call AlarmRpcClient.ListAlerts err")
	}

	//概览数据拼装
	alertSlots := []types.BasicOverviewSlot{}
	for _, level := range alertLevels {
		alertValues := []types.BasicOverviewSlotValue{}
		levelCount := 0
		for _, poolType := range poolTypes {
			levelPoolTypeCount := utils.CountAlertsNum(alerts.Items, strings.ToLower(poolType), level)
			levelCount += levelPoolTypeCount
			alertValues = append(alertValues, types.BasicOverviewSlotValue{
				Name:        poolType,
				Code:        poolType,
				Value:       levelPoolTypeCount,
				Unit:        "个",
				UnitType:    types.TypeNumber,
				Kind:        types.KindError,
				Description: "",
			})
		}
		alertSlot := types.BasicOverviewSlot{
			Info: types.BasicOverviewSlotInfo{
				Index:       0,
				Code:        level,
				Name:        level,
				Value:       levelCount,
				UnitType:    types.TypeNumber,
				Unit:        "个",
				Kind:        types.KindError,
				Prognosis:   0,
				Description: "",
			},
			Values: alertValues,
		}
		alertSlots = append(alertSlots, alertSlot)
	}

	return &dto.NetworkPoolOverviewAlertRsp{
		Alerts: alertSlots,
	}, nil
}

func (n *NetworkPoolService) OverviewMonitor(ctx context.Context, par *dto.NetworkPoolOverviewMonitorReq) (*dto.NetworkPoolOverviewMonitorRsp, error) {
	//服务器列表
	serverList, err := n.Store.ServerRpcClient.PhysicalServerList(ctx, &resource_serverv1alpha.PhysicalHostListRequest{
		PageSize: -1, //all
		Region:   par.Region,
		NodeType: []string{"network"},
	})
	if err != nil {
		return nil, errors.WithMessage(err, "rpc call ServerRpcClient.PhysicalServerList err")
	}

	ipList := []string{}
	promIpList := []string{}
	//group server  by resource pool
	//XGW: []string{"89.207.132.170", "38.0.101.76"}
	poolTypeToServesMap := map[string][]string{}
	for _, s := range serverList.PhysicalServerHostList {
		ipList = append(ipList, s.ManageIp)
		promIpList = append(promIpList, s.ManageIp+":9100")
		resourcePools := strings.Split(s.ResourcePoolType, ",")
		for _, rp := range resourcePools {
			poolTypeToServesMap[rp] = append(poolTypeToServesMap[rp], s.ManageIp)
		}
	}

	//查alarm获取promql
	rsp, err := n.Store.AlarmRpcClient.ListPromQLs(ctx, server.TemplateMap[server.Status](promIpList))
	if err != nil {
		return nil, errors.WithMessage(err, "rpc call AlarmRpcClient.ListPromQLs err")
	}
	promQL := rsp.Items[0].RealPromql

	//查Prometheus
	up, err := prom_client.VectorQuery(ctx, promQL)
	if err != nil {
		return nil, errors.WithMessage(err, "prom_client VectorQuery err")
	}
	serverMonitorUpStatusMap := prom_client.ParseServerMonitoringStatus(up)

	//UpCount by resource pool
	//XGW: 1
	poolTypeToUpCountMap := map[string]int{}
	poolTypeToDownCountMap := map[string]int{}
	upCount := 0
	downCount := 0
	for pt, ips := range poolTypeToServesMap {
		for _, ip := range ips {
			if serverMonitorUpStatusMap[ip] == "up" {
				upCount++
				poolTypeToUpCountMap[pt]++
			} else if serverMonitorUpStatusMap[ip] == "down" {
				downCount++
				poolTypeToDownCountMap[pt]++
			} else {
				//nothing
			}
		}
	}

	//服务器监控
	monitors := []types.BasicOverviewSlot{}
	monitorUpValues := []types.BasicOverviewSlotValue{}
	monitorDownValues := []types.BasicOverviewSlotValue{}
	for _, poolType := range poolTypes {
		monitorUpValues = append(monitorUpValues, types.BasicOverviewSlotValue{
			Name:        poolType,
			Code:        poolType,
			Value:       poolTypeToUpCountMap[poolType],
			Unit:        "个",
			UnitType:    types.TypeNumber,
			Kind:        types.KindInfo,
			Description: "",
		})

		monitorDownValues = append(monitorDownValues, types.BasicOverviewSlotValue{
			Name:        poolType,
			Code:        poolType,
			Value:       poolTypeToDownCountMap[poolType],
			Unit:        "个",
			UnitType:    types.TypeNumber,
			Kind:        types.KindError,
			Description: "",
		})
	}
	monitorUp := types.BasicOverviewSlot{
		Info: types.BasicOverviewSlotInfo{
			Index:       0,
			Code:        "up",
			Name:        "up",
			Value:       upCount,
			UnitType:    types.TypeNumber,
			Unit:        "个",
			Kind:        types.KindError,
			Prognosis:   0,
			Description: "",
		},
		Values: monitorUpValues,
	}

	monitorDown := types.BasicOverviewSlot{
		Info: types.BasicOverviewSlotInfo{
			Index:       0,
			Code:        "down",
			Name:        "down",
			Value:       downCount,
			UnitType:    types.TypeNumber,
			Unit:        "个",
			Kind:        types.KindError,
			Prognosis:   0,
			Description: "",
		},
		Values: monitorDownValues,
	}
	monitors = append(monitors, monitorUp, monitorDown)

	return &dto.NetworkPoolOverviewMonitorRsp{
		Up:   []types.BasicOverviewSlot{monitorUp},
		Down: []types.BasicOverviewSlot{monitorDown},
	}, nil
}

func (n *NetworkPoolService) OverviewLine(ctx context.Context, par *dto.NetworkPoolOverviewLineReq) (*dto.NetworkPoolOverviewLineRsp, error) {
	////TODO my test req
	//currentTime := time.Now()
	//par.End = currentTime.UnixMilli()
	//par.Start = currentTime.Add(-time.Hour).UnixMilli()
	//
	//poolType := par.PoolType
	//metrics := par.Name
	//服务器列表
	serverList, err := n.Store.ServerRpcClient.PhysicalServerList(ctx, &resource_serverv1alpha.PhysicalHostListRequest{
		PageSize: -1, //all
		Region:   par.Region,
		Query: map[string]string{
			"ResourcePoolType": par.PoolType,
		},
	})
	if err != nil {
		return nil, errors.WithMessage(err, "rpc call ServerRpcClient.PhysicalServerList err")
	}

	fmt.Printf("DEBUG: NetworkOverviewLine: serverList : %+v", serverList)

	promIpList := []string{}
	for _, s := range serverList.PhysicalServerHostList {
		promIpList = append(promIpList, s.ManageIp+":9100")
	}

	lines := []types.BasicOverviewSlot{}
	for _, name := range par.MetricName {
		//查模版
		tpl, ok := server.TemplateMap[name]
		if !ok {
			return nil, errors.New("not found metric name")
		}

		//查alarm获取promql
		rsp, err := n.Store.AlarmRpcClient.ListPromQLs(ctx, tpl(promIpList))
		if err != nil {
			return nil, errors.WithMessage(err, "rpc call AlarmRpcClient.ListPromQLs err")
		}
		if rsp == nil || len(rsp.Items) < 1 {
			return nil, errors.WithMessage(err, "rpc call AlarmRpcClient.ListPromQLs rsp err")
		}
		promQL := rsp.Items[0].RealPromql
		unit := rsp.Items[0].Unit

		step := prom_client.TimeToStep(par.End - par.Start)

		//查Prometheus
		matrix, err := prom_client.MatrixQuery(ctx, promQL, v1.Range{
			Start: time.UnixMilli(par.Start),
			End:   time.UnixMilli(par.End),
			Step:  step,
		})
		if err != nil {
			return nil, errors.WithMessage(err, "call prom_client.MatrixQuery err")
		}

		fmt.Printf("DEBUG: NetworkOverviewLine: real promQL : %s", promQL)
		fmt.Printf("DEBUG: NetworkOverviewLine: rsp %+v", matrix)
		fmt.Printf("DEBUG: NetworkOverviewLine: rsp err %+v", err)

		//封装结果数据
		for _, m := range matrix {
			lineName := string(m.Metric["hostname"])
			line := types.BasicOverviewSlot{
				Info: types.BasicOverviewSlotInfo{
					Index:       0,
					Name:        lineName,
					Value:       0,
					UnitType:    types.ParseUnitTypeByUnit(unit),
					Unit:        unit,
					Kind:        types.KindInfo,
					Prognosis:   0, //预测值，values的下标，0则无预测值
					Description: "",
				},
			}
			for _, p := range m.Values {
				timeStamp := p.Timestamp
				value := p.Value
				line.Values = append(line.Values, types.BasicOverviewSlotValue{
					Name:        timeStamp.String(),
					Code:        lineName,
					Value:       value,
					Unit:        unit,
					UnitType:    types.ParseUnitTypeByUnit(unit),
					Kind:        types.KindInfo,
					Description: "",
				})
			}
			lines = append(lines, line)
		}
	}
	return &dto.NetworkPoolOverviewLineRsp{
		Lines: lines,
	}, nil
}

func (n *NetworkPoolService) ListEIPPool(ctx context.Context, par *dto.ListNetworkPoolEipReq) (*dto.ListNetworkPoolEIPRsp, error) {
	//dtoReq to pb
	pbReq := resource_networkv1alpha.ListNetworkPoolTypeReq{}
	err := copier.Copy(&pbReq, &par)
	if err != nil {
		return nil, errors.WithMessage(err, "dto to pb err")
	}

	fmt.Printf("DEBUG 1 - traceID: %s\n", trace.TraceIDFromContext(ctx))

	//rpc call
	rsp, err := n.Store.NetworkRpcClient.ListEIPPool(ctx, &pbReq)
	if err != nil {
		return nil, errors.WithMessage(err, "rpc call NetworkRpcClient.ListEIPPool err")
	}

	//pb to dto
	dtoResult := dto.ListNetworkPoolEIPRsp{}
	err = copier.Copy(&dtoResult, rsp)
	if err != nil {
		return nil, errors.WithMessage(err, "pb to dto err")
	}

	//add monitor value
	for _, item := range dtoResult.Set {
		cpuUsedRatio, err := n.networkPoolVector(ctx, par.Region, item.PoolType, server.CpuUsageSumRate)
		if err != nil {
			return nil, errors.WithMessage(err, "rpc call networkPoolVector err")
		}
		memUsedRatio, err := n.networkPoolVector(ctx, par.Region, item.PoolType, server.MemUsageSumRate)
		if err != nil {
			return nil, errors.WithMessage(err, "rpc call networkPoolVector err")
		}
		diskUsedRatio, err := n.networkPoolVector(ctx, par.Region, item.PoolType, server.DiskUsageSumRate)
		if err != nil {
			return nil, errors.WithMessage(err, "rpc call networkPoolVector err")
		}
		item.CpuUsedRatio = tools.FormPercent(cpuUsedRatio)
		item.MemUsedRatio = tools.FormPercent(memUsedRatio)
		item.DiskUsedRatio = tools.FormPercent(diskUsedRatio)
	}

	return &dtoResult, nil
}

func (n *NetworkPoolService) ListLBPool(ctx context.Context, par *dto.ListNetworkPoolLBReq) (*dto.ListNetworkPoolLBRsp, error) {
	//dtoReq to pb
	pbReq := resource_networkv1alpha.ListNetworkPoolTypeReq{}
	if err := copier.Copy(&pbReq, par); err != nil {
		return nil, errors.WithMessage(err, "failed to copy dto to pb")
	}

	//rpc call
	rsp, err := n.Store.NetworkRpcClient.ListLBPool(ctx, &pbReq)
	if err != nil {
		return nil, errors.WithMessage(err, "failed to call ListLBPool rpc")
	}

	//pb to dto
	dtoResult := dto.ListNetworkPoolLBRsp{}
	if err := copier.Copy(&dtoResult, rsp); err != nil {
		return nil, errors.WithMessage(err, "failed to copy pb to dto")
	}

	//add monitor value
	for _, item := range dtoResult.Set {
		cpuUsedRatio, err := n.networkPoolVector(ctx, par.Region, item.PoolType, server.CpuUsageSumRate)
		if err != nil {
			return nil, errors.WithMessage(err, "rpc call networkPoolVector err")
		}
		memUsedRatio, err := n.networkPoolVector(ctx, par.Region, item.PoolType, server.MemUsageSumRate)
		if err != nil {
			return nil, errors.WithMessage(err, "rpc call networkPoolVector err")
		}
		diskUsedRatio, err := n.networkPoolVector(ctx, par.Region, item.PoolType, server.DiskUsageSumRate)
		if err != nil {
			return nil, errors.WithMessage(err, "rpc call networkPoolVector err")
		}
		item.CpuUsedRatio = tools.FormPercent(cpuUsedRatio)
		item.MemUsedRatio = tools.FormPercent(memUsedRatio)
		item.DiskUsedRatio = tools.FormPercent(diskUsedRatio)
	}

	return &dtoResult, nil
}

func (n *NetworkPoolService) ListNATPool(ctx context.Context, par *dto.ListNetworkPoolNATReq) (*dto.ListNetworkPoolNATRsp, error) {
	//dtoReq to pb
	pbReq := resource_networkv1alpha.ListNetworkPoolTypeReq{}
	if err := copier.Copy(&pbReq, &par); err != nil {
		return nil, errors.WithMessage(err, "error copying dto to pb")
	}

	//rpc call
	rsp, err := n.Store.NetworkRpcClient.ListNATPool(ctx, &pbReq)
	if err != nil {
		return nil, errors.WithMessage(err, "error calling ListNATPool RPC")
	}

	//pb to dto
	dtoResult := dto.ListNetworkPoolNATRsp{}
	if err := copier.Copy(&dtoResult, rsp); err != nil {
		return nil, errors.WithMessage(err, "error copying pb to dto")
	}

	//add monitor value
	for _, item := range dtoResult.Set {
		cpuUsedRatio, err := n.networkPoolVector(ctx, par.Region, item.PoolType, server.CpuUsageSumRate)
		if err != nil {
			return nil, errors.WithMessage(err, "error getting CPU usage")
		}
		memUsedRatio, err := n.networkPoolVector(ctx, par.Region, item.PoolType, server.MemUsageSumRate)
		if err != nil {
			return nil, errors.WithMessage(err, "error getting memory usage")
		}
		diskUsedRatio, err := n.networkPoolVector(ctx, par.Region, item.PoolType, server.DiskUsageSumRate)
		if err != nil {
			return nil, errors.WithMessage(err, "error getting disk usage")
		}
		item.CpuUsedRatio = tools.FormPercent(cpuUsedRatio)
		item.MemUsedRatio = tools.FormPercent(memUsedRatio)
		item.DiskUsedRatio = tools.FormPercent(diskUsedRatio)
	}

	return &dtoResult, nil
}

func (n *NetworkPoolService) ListBMPool(ctx context.Context, par *dto.ListNetworkPoolBMReq) (*dto.ListNetworkPoolBMRsp, error) {
	//dtoReq to pb
	pbReq := resource_networkv1alpha.ListNetworkPoolTypeReq{}
	if err := copier.Copy(&pbReq, &par); err != nil {
		return nil, errors.WithMessage(err, "failed to copy dto to pb")
	}

	//rpc call
	rsp, err := n.Store.NetworkRpcClient.ListBMPool(ctx, &pbReq)
	if err != nil {
		return nil, errors.WithMessage(err, "failed to call ListBMPool rpc")
	}

	//pb to dto
	dtoResult := dto.ListNetworkPoolBMRsp{}
	if err := copier.Copy(&dtoResult, rsp); err != nil {
		return nil, errors.WithMessage(err, "failed to copy pb to dto")
	}

	//add monitor value
	for _, item := range dtoResult.Set {
		cpuUsedRatio, err := n.networkPoolVector(ctx, par.Region, item.PoolType, server.CpuUsageSumRate)
		if err != nil {
			return nil, errors.WithMessage(err, "failed to get CPU usage")
		}
		memUsedRatio, err := n.networkPoolVector(ctx, par.Region, item.PoolType, server.MemUsageSumRate)
		if err != nil {
			return nil, errors.WithMessage(err, "failed to get memory usage")
		}
		diskUsedRatio, err := n.networkPoolVector(ctx, par.Region, item.PoolType, server.DiskUsageSumRate)
		if err != nil {
			return nil, errors.WithMessage(err, "failed to get disk usage")
		}
		item.CpuUsedRatio = tools.FormPercent(cpuUsedRatio)
		item.MemUsedRatio = tools.FormPercent(memUsedRatio)
		item.DiskUsedRatio = tools.FormPercent(diskUsedRatio)
	}

	return &dtoResult, nil
}

func (n *NetworkPoolService) ListSLPool(ctx context.Context, par *dto.ListNetworkPoolSLReq) (*dto.ListNetworkPoolSLRsp, error) {
	//dtoReq to pb
	pbReq := resource_networkv1alpha.ListNetworkPoolTypeReq{}
	if err := copier.Copy(&pbReq, &par); err != nil {
		return nil, errors.WithMessage(err, "error copying pbReq from par")
	}

	//rpc call
	rsp, err := n.Store.NetworkRpcClient.ListSLPool(ctx, &pbReq)
	if err != nil {
		return nil, errors.WithMessage(err, "error calling ListSLPool")
	}

	//pb to dto
	dtoResult := dto.ListNetworkPoolSLRsp{}
	if err := copier.Copy(&dtoResult, rsp); err != nil {
		return nil, errors.WithMessage(err, "error copying dtoResult from rsp")
	}

	//add monitor value
	for _, item := range dtoResult.Set {
		cpuUsedRatio, err := n.networkPoolVector(ctx, par.Region, item.PoolType, server.CpuUsageSumRate)
		if err != nil {
			return nil, errors.WithMessage(err, "rpc call networkPoolVector err")
		}
		memUsedRatio, err := n.networkPoolVector(ctx, par.Region, item.PoolType, server.MemUsageSumRate)
		if err != nil {
			return nil, errors.WithMessage(err, "rpc call networkPoolVector err")
		}
		diskUsedRatio, err := n.networkPoolVector(ctx, par.Region, item.PoolType, server.DiskUsageSumRate)
		if err != nil {
			return nil, errors.WithMessage(err, "rpc call networkPoolVector err")
		}
		item.CpuUsedRatio = tools.FormPercent(cpuUsedRatio)
		item.MemUsedRatio = tools.FormPercent(memUsedRatio)
		item.DiskUsedRatio = tools.FormPercent(diskUsedRatio)
	}

	return &dtoResult, nil
}

func (n *NetworkPoolService) networkPoolVector(ctx context.Context, region, poolType, metricName string) (float64, error) {
	//服务器列表
	serverList, err := n.Store.ServerRpcClient.PhysicalServerList(ctx, &resource_serverv1alpha.PhysicalHostListRequest{
		PageSize: -1, //all
		Region:   region,
		Query: map[string]string{
			"ResourcePoolType": poolType,
		},
	})
	if err != nil {
		return 0, errors.WithMessage(err, "rpc call PhysicalServerList err")
	}
	promIpList := []string{}
	for _, s := range serverList.PhysicalServerHostList {
		promIpList = append(promIpList, s.ManageIp+":9100")
	}

	//查alarm获取promql
	promQlReq := server.TemplateMap[metricName](promIpList)
	rsp, err := n.Store.AlarmRpcClient.ListPromQLs(ctx, promQlReq)
	if err != nil {
		return 0, errors.WithMessagef(err, "rpc call ListPromQLs err, req: %+v", promQlReq)
	}
	if rsp == nil || len(rsp.Items) < 1 {
		return 0, err
	}
	promQL := rsp.Items[0].RealPromql
	fmt.Println("real promQL: ", promQL)

	//查Prometheus
	matrix, err := prom_client.VectorQuery(ctx, promQL)
	if err != nil {
		return 0, errors.WithMessage(err, "prom_client VectorQuery err")
	}
	return prom_client.ParseOneVectorValue(matrix), nil
}

func (n *NetworkPoolService) DetailLine(ctx context.Context, par *dto.NetworkPoolDetailLineReq) (*dto.NetworkPoolDetailLineRsp, error) {

	//TODO my test req
	//currentTime := time.Now()
	//par.End = currentTime.UnixMilli()
	//par.Start = currentTime.Add(-time.Hour).UnixMilli()
	//par.MetricName = []string{server.NodeNetworkPps}
	//poolType := "XGW"

	//节点汇总
	//节点实例连接数汇总 NodeNetstatTcpCurrEstabSum

	//按节点
	//节点实例连接数    NodeNetstatTcpCurrEstab
	//节点pps	NodeNetworkPps
	//节点bps	NodeNetworkBps
	//CPU使用率	CpuUsageRate
	//内存使用量  MemUsage
	//内存使用率	MemUsageRate
	//磁盘使用量	DiskUsage
	//磁盘使用率	DiskUsageRate

	//需要预测的metric
	predictionMetrics := []string{server.NodeNetstatTcpCurrEstabSum, server.NodeNetstatTcpCurrEstab}

	//需要特别处理line name
	specialLineNameMetrics := []string{server.NodeNetstatTcpCurrEstabSum}

	//服务器列表
	serverList, err := n.Store.ServerRpcClient.PhysicalServerList(ctx, &resource_serverv1alpha.PhysicalHostListRequest{
		PageSize: -1, //all
		Region:   par.Region,
		Query: map[string]string{
			"ResourcePoolType": par.PoolType,
		},
	})
	if err != nil {
		return nil, errors.WithMessage(err, "rpc call ServerRpcClient.PhysicalServerList err")
	}

	promIpList := []string{}
	for _, s := range serverList.PhysicalServerHostList {
		promIpList = append(promIpList, s.ManageIp+":9100")
	}

	lines := []types.BasicOverviewSlot{}
	for _, name := range par.MetricName {
		//查alarm获取promql
		promReq := server.TemplateMap[name](promIpList)
		rsp, err := n.Store.AlarmRpcClient.ListPromQLs(ctx, promReq)
		if err != nil {
			return nil, errors.WithMessage(err, "rpc call AlarmRpcClient.ListPromQLs err")
		}
		if rsp == nil || len(rsp.Items) < 1 {
			return nil, errors.New("rpc call AlarmRpcClient.ListPromQLs rsp err")
		}
		promQL := rsp.Items[0].RealPromql
		unit := rsp.Items[0].Unit

		//查Prometheus
		step := prom_client.TimeToStep(par.End - par.Start)
		matrix, err := prom_client.MatrixQuery(ctx, promQL, v1.Range{
			Start: time.UnixMilli(par.Start),
			End:   time.UnixMilli(par.End),
			Step:  step,
		})
		if err != nil {
			return nil, errors.WithMessage(err, "prom_client MatrixQuery err")
		}

		//封装结果数据
		for _, m := range matrix {
			lineName := string(m.Metric["hostname"])
			if tools.Contains(specialLineNameMetrics, name) != -1 {
				lineName = par.PoolType
			}

			line := types.BasicOverviewSlot{
				Info: types.BasicOverviewSlotInfo{
					Index:       0,
					Name:        lineName,
					Value:       0,
					UnitType:    types.ParseUnitTypeByUnit(unit),
					Unit:        unit,
					Kind:        types.KindInfo,
					Prognosis:   0, //预测值，values的下标，0则无预测值
					Description: "",
				},
			}
			for _, p := range m.Values {
				timeStamp := tools.UnixToUnixMilli(p.Timestamp.Unix())
				value := p.Value
				line.Values = append(line.Values, types.BasicOverviewSlotValue{
					Name:        strconv.Itoa(int(timeStamp)),
					Code:        lineName,
					Value:       value,
					UnitType:    types.ParseUnitTypeByUnit(unit),
					Unit:        unit,
					Kind:        types.KindInfo,
					Description: "",
				})
			}

			//添加预测值
			if par.HasPrediction && tools.Contains(predictionMetrics, name) != -1 {
				line.Info.Prognosis = len(line.Values)
				predictStart := par.End
				predictEnd := par.End + (par.End - par.Start)
				tInt := tools.UnixMilliToUnix(par.End) - tools.UnixMilliToUnix(par.Start)
				rangeDuration := strconv.FormatInt(3*tInt, 10)
				predictDuration := strconv.FormatInt(tInt, 10)
				predictSql := ""
				switch name {
				case server.NodeNetstatTcpCurrEstabSum:
					predictSql = network.GetPredictNodeNetstatTcpCurrEstabSum(promIpList, rangeDuration+"s", predictDuration)
				case server.NodeNetstatTcpCurrEstab:
					instance := string(m.Metric["instance"])
					predictSql = network.GetPredictNodeNetstatTcpCurrEstab(instance, rangeDuration+"s", predictDuration)
				}

				predictMatrix, err := prom_client.MatrixQuery(ctx, predictSql, v1.Range{
					Start: time.UnixMilli(predictStart),
					End:   time.UnixMilli(predictEnd),
					Step:  step,
				})
				if err != nil {
					return nil, errors.WithMessage(err, "prom_client predictMatrix err")
				}

				for _, pm := range predictMatrix {
					for _, p := range pm.Values {
						timeStamp := tools.UnixToUnixMilli(p.Timestamp.Unix())
						value := p.Value
						line.Values = append(line.Values, types.BasicOverviewSlotValue{
							Name:        strconv.Itoa(int(timeStamp)),
							Value:       value,
							Unit:        unit,
							UnitType:    types.ParseUnitTypeByUnit(unit),
							Kind:        types.KindInfo,
							Description: "预测数据",
						})
					}
				}
			}

			lines = append(lines, line)
		}
	}

	return &dto.NetworkPoolDetailLineRsp{
		Lines: lines,
	}, nil
}

func (n *NetworkPoolService) DetailTop(ctx context.Context, par *dto.NetworkPoolDetailTopReq) (*dto.NetworkPoolDetailTopRsp, error) {

	////TODO my test req
	//currentTime := time.Now()
	//par.End = currentTime.UnixMilli()
	//par.Start = currentTime.Add(-time.Hour).UnixMilli()
	//par.TopK = 5
	//par.Name = []string{"slbConns"}
	//par.Hostname = "xgw-2.poc.test.com"
	//par.PoolType = "XGW"

	metricName := par.MetricName
	querySql, ok := network.NativeTemplateMap[metricName]
	if !ok {
		return nil, errors.New("not find metric")
	}
	unit := querySql.Unit
	//displayName := querySql.Name
	querySql.TopK = par.TopK
	querySql.Duration = tools.UnixMilliToUnix(par.End) - tools.UnixMilliToUnix(par.Start)
	err := querySql.Labels.AddMatcher(template.MatchEqual, "hostname", par.Hostname)
	if err != nil {
		return nil, errors.WithMessage(err, "add hostname matcher err")
	}
	promSql, err := querySql.Render()
	if err != nil {
		return nil, errors.WithMessage(err, "render promql err")
	}

	matrix, err := prom_client.MatrixQuery(ctx, promSql, v1.Range{
		Start: time.UnixMilli(par.Start),
		End:   time.UnixMilli(par.End),
		Step:  prom_client.TimeToStep(par.End - par.Start),
	})
	if err != nil {
		return nil, errors.WithMessage(err, "prom_client MatrixQuery err")
	}

	lines := []types.BasicOverviewSlot{}
	for _, m := range matrix {
		name := parseMetricDisplayName(metricName, m.Metric)
		line := types.BasicOverviewSlot{
			Info: types.BasicOverviewSlotInfo{
				Index:       0,
				Name:        name,
				Value:       0,
				UnitType:    types.ParseUnitTypeByUnit(unit),
				Unit:        unit,
				Kind:        types.KindInfo,
				Prognosis:   0,
				Description: "",
			},
		}
		for _, p := range m.Values {
			timeStamp := tools.UnixToUnixMilli(p.Timestamp.Unix())
			value := p.Value
			line.Values = append(line.Values, types.BasicOverviewSlotValue{
				Name:        strconv.Itoa(int(timeStamp)),
				Code:        name,
				Value:       value,
				UnitType:    types.ParseUnitTypeByUnit(unit),
				Unit:        unit,
				Kind:        types.KindInfo,
				Description: "",
			})
		}

		lines = append(lines, line)
	}

	return &dto.NetworkPoolDetailTopRsp{
		Lines: lines,
	}, nil
}

func parseMetricDisplayName(name string, metric prom_model.Metric) string {
	displayNames := map[string]string{
		network.SlbConns:                   fmt.Sprintf("%s_%s", metric["ip"], metric["port"]),
		network.SlbTrafficIn:               fmt.Sprintf("%s_%s", metric["ip"], metric["port"]),
		network.SlbTrafficOut:              fmt.Sprintf("%s_%s", metric["ip"], metric["port"]),
		network.TengineSlbConns:            fmt.Sprintf("%s_%s", metric["ip"], metric["port"]),
		network.TengineSlbTrafficIn:        fmt.Sprintf("%s_%s", metric["ip"], metric["port"]),
		network.TengineSlbTrafficOut:       fmt.Sprintf("%s_%s", metric["ip"], metric["port"]),
		network.EipTrafficIn:               fmt.Sprintf("%s", metric["eip"]),
		network.EipTrafficOut:              fmt.Sprintf("%s", metric["eip"]),
		network.NatTrafficIn:               fmt.Sprintf("%s", metric["vni"]),
		network.NatTrafficOut:              fmt.Sprintf("%s", metric["vni"]),
		network.TgwLpeerBytesIn:            fmt.Sprintf("%s_%s", metric["domain"], metric["vni"]),
		network.TgwLpeerBytesOut:           fmt.Sprintf("%s_%s", metric["domain"], metric["vni"]),
		network.TgwDcytesIn:                fmt.Sprintf("%s_%s", metric["domain"], metric["vni"]),
		network.TgwDcBytesOut:              fmt.Sprintf("%s_%s", metric["domain"], metric["vni"]),
		network.TgwVpnBytesIn:              fmt.Sprintf("%s_%s", metric["domain"], metric["vni"]),
		network.TgwVpnBytesOut:             fmt.Sprintf("%s_%s", metric["domain"], metric["vni"]),
		network.SgwPublicDropPacketRateIn:  fmt.Sprintf("%s", metric["ip"]),
		network.SgwPublicDropPacketRateOut: fmt.Sprintf("%s", metric["ip"]),
		network.SgwPublicEipTrafficIn:      fmt.Sprintf("%s", metric["ip"]),
		network.SgwPublicEipTrafficOut:     fmt.Sprintf("%s", metric["ip"]),
	}

	return displayNames[name]
}

```

File path: /Users/mac/Desktop/woker_code/monitor/modules/network/service/product_eip.go
```golang
package service

import (
	"context"
	pb "ezone.ksyun.com/ezone/luban/luban_api/resourceapis/resource_network/v1alpha/gen"
	"ezone.ksyun.com/ezone/luban/monitor/common/client/opentsdb"
	"ezone.ksyun.com/ezone/luban/monitor/common/client/opentsdb/pkg"
	"ezone.ksyun.com/ezone/luban/monitor/common/tools"
	"ezone.ksyun.com/ezone/luban/monitor/common/tsdbql_template"
	"ezone.ksyun.com/ezone/luban/monitor/common/types"
	"ezone.ksyun.com/ezone/luban/monitor/modules/network/dao"
	"ezone.ksyun.com/ezone/luban/monitor/modules/network/dto"
	"fmt"
	"github.com/jinzhu/copier"
	"github.com/pkg/errors"
	"net/http"
)

type ProductEipService struct {
	Store dao.NetworkStore
}

func NewProductEipService() *ProductEipService {
	return &ProductEipService{
		Store: *dao.NewNetworkStore(),
	}
}

func (n *ProductEipService) OverviewAlert(ctx context.Context, par *dto.ProductEipOverviewAlertReq) (*dto.ProductEipOverviewAlertRsp, error) {
	return nil, nil
}

func (n *ProductEipService) OverviewTop(ctx context.Context, par *dto.ProductEipOverviewTopReq) (*dto.ProductEipOverviewTopRsp, error) {

	////TODO my test req
	//currentTime := time.Now()
	//par.End = currentTime.UnixMilli()
	//par.Start = currentTime.Add(-time.Hour).UnixMilli()
	//par.TopK = 10

	tops := []types.BasicOverviewSlot{}

	for _, name := range par.MetricName {
		tsdbMetric, err := n.Store.MetricDao.GetOneByCode(ctx, name)
		if err != nil {
			return nil, errors.WithMessagef(err, "get tsdb metric %s err", name)
		}
		if tsdbMetric == nil {
			return nil, errors.WithMessagef(fmt.Errorf("record not found"), "get tsdb metric %s err", name)
		}

		topData, err := n.Store.MetricTopDao.GetOneByCode(ctx, dao.QueryParams{
			Region: par.Region,
			Az:     "",
			Code:   name,
		})
		if err != nil {
			return nil, errors.WithMessage(err, "MetricTopDao.GetOneByCode err")
		}

		intervalData := topData.ParseIntervalData(par.Start, par.End)
		//topK
		if par.TopK > 10 {
			return nil, errors.New("topK is too large")
		}
		if par.TopK < len(intervalData) {
			intervalData = intervalData[:par.TopK]
		}

		values := []types.BasicOverviewSlotValue{}
		for _, v := range intervalData {
			values = append(values, types.BasicOverviewSlotValue{
				Name:     v.Name,
				Code:     v.Id,
				Value:    v.Value,
				Unit:     tsdbMetric.Unit,
				UnitType: types.ParseUnitTypeByUnit(tsdbMetric.Unit),
				Kind:     types.KindInfo,
			})
		}

		slot := types.BasicOverviewSlot{
			Info: types.BasicOverviewSlotInfo{
				Index:       0,
				Name:        name,
				Value:       0,
				UnitType:    types.ParseUnitTypeByUnit(tsdbMetric.Unit),
				Unit:        tsdbMetric.Unit,
				Kind:        types.KindInfo,
				Prognosis:   0,
				Description: "",
			},
			Values: values,
		}
		tops = append(tops, slot)
	}

	return &dto.ProductEipOverviewTopRsp{
		Tops: tops,
	}, nil
}

func (n *ProductEipService) EipInfo(ctx context.Context, par *dto.ProductEipInfoReq) (*dto.ProductEipInfoRsp, error) {

	eip, err := n.Store.NetworkRpcClient.DetailEip(ctx, &pb.DetailEipReq{
		InstanceID: par.InstanceID,
		IP:         par.IP,
	})
	if err != nil {
		return nil, errors.WithMessage(err, "rpc call DetailEip err")
	}

	//rsp pb to dto
	result := &dto.ProductEipInfoRsp{}
	err = copier.Copy(&result, &eip)
	if err != nil {
		return nil, errors.WithMessage(err, "failed to copy pb to dto")
	}

	// add monitor status
	return result, nil
}

func (n *ProductEipService) EipLine(ctx context.Context, par *dto.ProductEipLineReq) (*dto.ProductEipLineRsp, error) {

	eipInfo, err := n.Store.NetworkRpcClient.DetailEip(ctx, &pb.DetailEipReq{InstanceID: par.ID})
	if err != nil {
		return nil, errors.WithMessage(err, "rpc call DetailEip err")
	}
	region := eipInfo.Region

	queryParam := pkg.QueryParam{
		Start: par.Start,
		End:   par.End,
	}
	lines := make([]types.BasicOverviewSlot, 0)
	for _, name := range par.MetricName {

		subqueries := make([]pkg.SubQuery, 0)
		tsdbMetric, err := n.Store.MetricDao.GetOneByCode(ctx, name)
		if err != nil {
			return nil, errors.WithMessagef(err, "get tsdb metric %s err", name)
		}
		if tsdbMetric == nil {
			return nil, errors.WithMessagef(fmt.Errorf("record not found"), "get tsdb metric %s err", name)
		}
		line := types.BasicOverviewSlot{
			Info: types.BasicOverviewSlotInfo{
				Index:       0,
				Name:        name,
				Value:       nil,
				Unit:        tsdbMetric.Unit,
				UnitType:    types.ParseUnitTypeByUnit(tsdbMetric.Unit),
				Kind:        types.KindInfo,
				Prognosis:   0,
				Description: "",
			},
		}

		eipQuery := tsdbql_template.ParseTsdbQuery(tsdbMetric.ProductLine, tsdbMetric.MetricPrefix, par.ID)
		subqueries = append(subqueries, pkg.SubQuery{
			Aggregator: "sum",
			Metric:     eipQuery.Metric,
			Tags:       map[string]string{"host": eipQuery.HostTag},
			Downsample: opentsdb.TimeToDownsample(par.End - par.Start),
		})
		queryParam.Queries = subqueries
		queryResp, err := opentsdb.Query(ctx, region, queryParam)
		if err != nil {
			return nil, errors.WithMessagef(err, "tsdb query err, param : %v", queryParam)
		}

		//查询404返回空数据
		if queryResp.StatusCode != http.StatusOK {
			if queryResp.StatusCode == http.StatusNotFound {
				return &dto.ProductEipLineRsp{Lines: lines}, nil
			}
			return nil, errors.New("tsdb query response failed")
		}
		//查询200,但是数据为空，返回空数据
		if len(queryResp.QueryRespCnts) <= 0 {
			return &dto.ProductEipLineRsp{Lines: lines}, nil
		}

		dataPoints := queryResp.QueryRespCnts[0].GetDataPoints()
		fmt.Printf("DEBUG len of dataPoints is %d\n", len(dataPoints))
		for _, v := range dataPoints {
			line.Values = append(line.Values, types.BasicOverviewSlotValue{
				Name:        fmt.Sprintf("%d", tools.UnixToUnixMilli(v.Timestamp)),
				Code:        "",
				Value:       v.Value,
				Unit:        tsdbMetric.Unit,
				UnitType:    types.ParseUnitTypeByUnit(tsdbMetric.Unit),
				Kind:        types.KindInfo,
				Description: v.Metric, //完整metric，便于排查问题
			})
		}
		lines = append(lines, line)
	}

	return &dto.ProductEipLineRsp{
		Lines: lines,
	}, nil
}

```

File path: /Users/mac/Desktop/woker_code/monitor/modules/network/rpc/rpcserver.go
```golang
package rpc

import (
	"context"
	monitor_networkv1alpha "ezone.ksyun.com/ezone/luban/luban_api/monitorapis/network/v1alpha/gen"
	"ezone.ksyun.com/ezone/luban/monitor/modules/network/service"
)

type NetWorkRpcServer struct {
	svc service.ProductEipService
	monitor_networkv1alpha.UnimplementedNetworkServer
}

func NewNetWorkRpcServer() *NetWorkRpcServer {
	return &NetWorkRpcServer{
		svc: *service.NewProductEipService(),
	}
}

func (n *NetWorkRpcServer) Test(ctx context.Context, req *monitor_networkv1alpha.TestRequest) (*monitor_networkv1alpha.TestResponse, error) {
	return &monitor_networkv1alpha.TestResponse{HostName: "my test"}, nil
}

func (n *NetWorkRpcServer) EipInfo(ctx context.Context, req *monitor_networkv1alpha.EipInfoRequest) (*monitor_networkv1alpha.EipInfoResponse, error) {

	////req pb to dto
	//
	//
	////call service
	//dtoResult, err := n.svc.EipInfo(ctx, req)
	//if err != nil {
	//	return nil, status.Errorf(codes.Unknown, "call service error, %s", err.Error())
	//}
	//
	////rsp dto to pb

	return nil, nil
}

```

File path: /Users/mac/Desktop/woker_code/monitor/modules/basic/dto/response.go
```golang
package dto

import "ezone.ksyun.com/ezone/luban/monitor/common/types"

type DashboardCreateRsp struct {
	Name string            `json:"Name"`
	Data map[string]string `json:"Data"`
}

type DashboardUpdateRsp struct {
	Name string            `json:"Name"`
	Data map[string]string `json:"Data"`
}

type DashboardDeleteRsp struct {
	Name string            `json:"Name"`
	Data map[string]string `json:"Data"`
}

type DashboardInfo struct {
	Name string            `json:"Name"`
	Data map[string]string `json:"Data"`
}
type DashboardListRsp []DashboardInfo

type DashboardDetailRsp struct {
	Name string            `json:"Name"`
	Data map[string]string `json:"Data"`
}

type PhysicalOverviewTopRsp struct {
	PhysicalCount []types.BasicOverviewSlot `json:"PhysicalCount"`
	ServerState   []types.BasicOverviewSlot `json:"ServerState"`
	SwitchState   []types.BasicOverviewSlot `json:"SwitchState"`
	Tops          []types.BasicOverviewSlot `json:"Top"`
}

type ComputePoolLineRsp struct {
	CpuRate    []types.BasicOverviewSlot `json:"CpuRate"`
	MemoryRate []types.BasicOverviewSlot `json:"MemoryRate"`
	DiskRate   []types.BasicOverviewSlot `json:"DiskRate"`
}

type EbsPoolLineRsp struct {
	CapRate []types.BasicOverviewSlot `json:"CapRate"`
}

type ObjectPoolLineRsp struct {
	CapRate []types.BasicOverviewSlot `json:"CapRate"`
}

```

File path: /Users/mac/Desktop/woker_code/monitor/modules/basic/dto/request.go
```golang
package dto

type DashboardCreateReq struct {
	Name string            `json:"Name"`
	Data map[string]string `json:"Data"`
}

type DashboardUpdateReq struct {
	Name string            `json:"Name"`
	Data map[string]string `json:"Data"`
}

type DashboardDeleteReq struct {
	Name string `json:"Name"`
}

type DashboardListReq struct {
}

type DashboardDetailReq struct {
	Name string `json:"Name"`
}

type PhysicalDeviceReq struct {
	Region string `json:"Region"`
}

type ComputePoolLineReq struct {
	Region string `json:"Region"`
}

type EbsPoolLineReq struct {
	Region string `json:"Region"`
}

type ObjectPoolLineReq struct {
	Region string `json:"Region"`
}

```

File path: /Users/mac/Desktop/woker_code/monitor/modules/basic/dao/overview.go
```golang
package dao

import (
	"ezone.ksyun.com/ezone/luban/communal/lib"
	alarmv1alpha "ezone.ksyun.com/ezone/luban/luban_api/alarmapis/alarm/v1alpha/gen"
	blockstoragepb "ezone.ksyun.com/ezone/luban/luban_api/resourceapis/resource_blockstorage/v1alpha/gen"
	computepb "ezone.ksyun.com/ezone/luban/luban_api/resourceapis/resource_compute/v1alpha/gen"
	networkpb "ezone.ksyun.com/ezone/luban/luban_api/resourceapis/resource_network/v1alpha/gen"
	objectstoragepb "ezone.ksyun.com/ezone/luban/luban_api/resourceapis/resource_objectstorage/v1alpha/gen"
	serverpb "ezone.ksyun.com/ezone/luban/luban_api/resourceapis/resource_server/v1alpha/gen"
	switch_rpc "ezone.ksyun.com/ezone/luban/luban_api/resourceapis/resource_switch/v1alpha/gen"
	"ezone.ksyun.com/ezone/luban/monitor/common/client/grpcx"
)

type DashboardStore struct {
	//rpc
	NetworkRpcClient     networkpb.ResourceNetworkClient
	ServiceRpcClient     serverpb.ResourceServiceClient
	SwitchRpcClient      switch_rpc.ResourceSwitchClient
	AlarmRpcClient       alarmv1alpha.AlarmServiceClient
	ComputePoolRpcClient computepb.ComputePoolServiceClient
	EbsPoolRpcClient     blockstoragepb.EbsPoolServiceClient
	ObjectPoolRpcClient  objectstoragepb.ObjectPoolServiceClient
}

func NewJobsStore() *DashboardStore {
	//resource
	resourceAddr := lib.GetStringConf("base.grpc.luban_resource")
	resourceConn, err := grpcx.NewGrpcClientConn(resourceAddr)
	if err != nil {
		lib.Log.TagError(lib.NewTrace(), lib.DLTagUndefind, map[string]interface{}{"connect luban_resource grpc server error, %s": err.Error()})
	}

	//alarm
	alarmAddr := lib.GetStringConf("base.grpc.alarm")
	alarmConn, err := grpcx.NewGrpcClientConn(alarmAddr)

	return &DashboardStore{
		NetworkRpcClient:     networkpb.NewResourceNetworkClient(resourceConn),
		ServiceRpcClient:     serverpb.NewResourceServiceClient(resourceConn),
		SwitchRpcClient:      switch_rpc.NewResourceSwitchClient(resourceConn),
		AlarmRpcClient:       alarmv1alpha.NewAlarmServiceClient(alarmConn),
		ComputePoolRpcClient: computepb.NewComputePoolServiceClient(resourceConn),
		EbsPoolRpcClient:     blockstoragepb.NewEbsPoolServiceClient(resourceConn),
		ObjectPoolRpcClient:  objectstoragepb.NewObjectPoolServiceClient(resourceConn),
	}
}

```

File path: /Users/mac/Desktop/woker_code/monitor/modules/basic/controller/dashboard.go
```golang
package controller

import (
	"net/http"

	"ezone.ksyun.com/ezone/luban/communal/lib"
	"ezone.ksyun.com/ezone/luban/monitor/common/consts"
	"ezone.ksyun.com/ezone/luban/monitor/modules/basic/dto"
	"ezone.ksyun.com/ezone/luban/monitor/modules/basic/service"

	"ezone.ksyun.com/ezone/luban/monitor/response"
	"github.com/gin-gonic/gin"
)

type DashboardController struct {
	svc *service.DashboardService
}

func NewDashboardController() *DashboardController {
	return &DashboardController{
		svc: service.NewDashboardService(),
	}
}

func (s *DashboardController) Create(c *gin.Context) {
	// 绑定参数
	var params dto.DashboardCreateReq
	if err := c.ShouldBind(&params); err != nil {
		lib.Log.TagError(lib.GetTraceContext(c), lib.DLTagRequestOut, map[string]interface{}{"error": err.Error(), "params": params})
		response.Failed(c, http.StatusBadRequest, consts.ParameterError, "参数绑定失败")
		return
	}
	lib.Log.TagInfo(lib.GetTraceContext(c), lib.DLTagResponseFailed, map[string]interface{}{"params": params})

	// 业务处理
	res, err := s.svc.Create(c, &params)
	if err != nil {
		lib.Log.TagError(lib.GetTraceContext(c), lib.DLTagResponseFailed, map[string]interface{}{"error": err.Error()})
		response.Failed(c, http.StatusInternalServerError, consts.GainFail, "创建监控大屏失败")
		return
	}

	lib.Log.TagInfo(lib.GetTraceContext(c), lib.DLTagResponseSuccess, map[string]interface{}{"res": res})
	response.Success(c, res)
}

func (s *DashboardController) Update(c *gin.Context) {
	// 绑定参数
	var params dto.DashboardUpdateReq
	if err := c.ShouldBind(&params); err != nil {
		lib.Log.TagError(lib.GetTraceContext(c), lib.DLTagRequestOut, map[string]interface{}{"error": err.Error(), "params": params})
		response.Failed(c, http.StatusBadRequest, consts.ParameterError, "参数绑定失败")
		return
	}
	lib.Log.TagInfo(lib.GetTraceContext(c), lib.DLTagResponseFailed, map[string]interface{}{"params": params})

	// 业务处理
	res, err := s.svc.Update(c, &params)
	if err != nil {
		lib.Log.TagError(lib.GetTraceContext(c), lib.DLTagResponseFailed, map[string]interface{}{"error": err.Error()})
		response.Failed(c, http.StatusInternalServerError, consts.GainFail, "更新监控大屏失败")
		return
	}

	lib.Log.TagInfo(lib.GetTraceContext(c), lib.DLTagResponseSuccess, map[string]interface{}{"res": res})
	response.Success(c, res)
}

func (s *DashboardController) Delete(c *gin.Context) {
	// 绑定参数
	var params dto.DashboardDeleteReq
	if err := c.ShouldBind(&params); err != nil {
		lib.Log.TagError(lib.GetTraceContext(c), lib.DLTagRequestOut, map[string]interface{}{"error": err.Error(), "params": params})
		response.Failed(c, http.StatusBadRequest, consts.ParameterError, "参数绑定失败")
		return
	}
	lib.Log.TagInfo(lib.GetTraceContext(c), lib.DLTagResponseFailed, map[string]interface{}{"params": params})
	// 业务处理
	res, err := s.svc.Delete(c, &params)
	if err != nil {
		lib.Log.TagError(lib.GetTraceContext(c), lib.DLTagResponseFailed, map[string]interface{}{"error": err.Error()})
		response.Failed(c, http.StatusInternalServerError, consts.GainFail, "删除监控大屏失败")
		return
	}

	lib.Log.TagInfo(lib.GetTraceContext(c), lib.DLTagResponseSuccess, map[string]interface{}{"res": res})
	response.Success(c, res)
}

func (s *DashboardController) List(c *gin.Context) {
	// 绑定参数
	var params dto.DashboardListReq
	if err := c.ShouldBind(&params); err != nil {
		lib.Log.TagError(lib.GetTraceContext(c), lib.DLTagRequestOut, map[string]interface{}{"error": err.Error(), "params": params})
		response.Failed(c, http.StatusBadRequest, consts.ParameterError, "参数绑定失败")
		return
	}
	lib.Log.TagInfo(lib.GetTraceContext(c), lib.DLTagResponseFailed, map[string]interface{}{"params": params})
	// 业务处理
	res, err := s.svc.List(c, &params)
	if err != nil {
		lib.Log.TagError(lib.GetTraceContext(c), lib.DLTagResponseFailed, map[string]interface{}{"error": err.Error()})
		response.Failed(c, http.StatusInternalServerError, consts.GainFail, "获取监控大屏列表失败")
		return
	}

	lib.Log.TagInfo(lib.GetTraceContext(c), lib.DLTagResponseSuccess, map[string]interface{}{"res": res})
	response.Success(c, res)
}

func (s *DashboardController) Detail(c *gin.Context) {
	// 绑定参数
	var params dto.DashboardDetailReq
	if err := c.ShouldBind(&params); err != nil {
		lib.Log.TagError(lib.GetTraceContext(c), lib.DLTagRequestOut, map[string]interface{}{"error": err.Error(), "params": params})
		response.Failed(c, http.StatusBadRequest, consts.ParameterError, "参数绑定失败")
		return
	}
	lib.Log.TagInfo(lib.GetTraceContext(c), lib.DLTagResponseFailed, map[string]interface{}{"params": params})
	// 业务处理
	res, err := s.svc.Detail(c, &params)
	if err != nil {
		lib.Log.TagError(lib.GetTraceContext(c), lib.DLTagResponseFailed, map[string]interface{}{"error": err.Error()})
		response.Failed(c, http.StatusInternalServerError, consts.GainFail, "获取监控大屏列表失败")
		return
	}

	lib.Log.TagInfo(lib.GetTraceContext(c), lib.DLTagResponseSuccess, map[string]interface{}{"res": res})
	response.Success(c, res)
}

func (s *DashboardController) PhysicalDevice(c *gin.Context) {
	// 绑定参数
	var params dto.PhysicalDeviceReq
	if err := c.ShouldBind(&params); err != nil {
		lib.Log.TagError(lib.GetTraceContext(c), lib.DLTagRequestOut, map[string]interface{}{"error": err.Error(), "params": params})
		response.Failed(c, http.StatusBadRequest, consts.ParameterError, "参数绑定失败")
		return
	}
	lib.Log.TagInfo(lib.GetTraceContext(c), lib.DLTagResponseFailed, map[string]interface{}{"params": params})
	// 业务处理
	res, err := s.svc.PhysicalDevice(c, &params)
	if err != nil {
		lib.Log.TagError(lib.GetTraceContext(c), lib.DLTagResponseFailed, map[string]interface{}{"error": err.Error()})
		response.Failed(c, http.StatusInternalServerError, consts.GainFail, "获取监控大屏列表失败")
		return
	}

	lib.Log.TagInfo(lib.GetTraceContext(c), lib.DLTagResponseSuccess, map[string]interface{}{"res": res})
	response.Success(c, res)
}

// ComputePoolLine godoc
// @Summary      Dashboard ComputePoolLine
// @Description  Get Dashboard ComputePoolLine
// @Tags         dashBoard
// @Accept       json
// @Produce      json
// @Param        body body dto.ComputePoolLineReq true " Dashboard ComputePoolLine Request"
// @Success      200  {object}  dto.ComputePoolLineRsp
// @Router       /dashboard/compute_pool_line [POST]
func (s *DashboardController) ComputePoolLine(c *gin.Context) {
	var params dto.ComputePoolLineReq
	if err := c.ShouldBind(&params); err != nil {
		lib.Log.TagError(lib.GetTraceContext(c), lib.DLTagRequestOut, map[string]interface{}{"error": err.Error(), "params": params})
		response.Failed(c, http.StatusBadRequest, consts.ParameterError, "参数绑定失败")
		return
	}
	lib.Log.TagInfo(lib.GetTraceContext(c), lib.DLTagResponseFailed, map[string]interface{}{"params": params})
	// 业务处理
	res, err := s.svc.ComputePoolLine(c, &params)
	if err != nil {
		lib.Log.TagError(lib.GetTraceContext(c), lib.DLTagResponseFailed, map[string]interface{}{"error": err.Error()})
		response.Failed(c, http.StatusInternalServerError, consts.GainFail, "获取计算资源池使用率信息失败")
		return
	}

	lib.Log.TagInfo(lib.GetTraceContext(c), lib.DLTagResponseSuccess, map[string]interface{}{"res": res})
	response.Success(c, res)
}

// EbsPoolLine godoc
// @Summary      Dashboard EbsPoolLine
// @Description  Get Dashboard EbsPoolLine
// @Tags         dashBoard
// @Accept       json
// @Produce      json
// @Param        body body dto.EbsPoolLineReq true " Dashboard EbsPoolLine Request"
// @Success      200  {object}  dto.EbsPoolLineRsp
// @Router       /dashboard/ebs_pool_line [POST]
func (s *DashboardController) EbsPoolLine(c *gin.Context) {
	var params dto.EbsPoolLineReq
	if err := c.ShouldBind(&params); err != nil {
		lib.Log.TagError(lib.GetTraceContext(c), lib.DLTagRequestOut, map[string]interface{}{"error": err.Error(), "params": params})
		response.Failed(c, http.StatusBadRequest, consts.ParameterError, "参数绑定失败")
		return
	}
	lib.Log.TagInfo(lib.GetTraceContext(c), lib.DLTagResponseFailed, map[string]interface{}{"params": params})
	// 业务处理
	res, err := s.svc.EbsPoolLine(c, &params)
	if err != nil {
		lib.Log.TagError(lib.GetTraceContext(c), lib.DLTagResponseFailed, map[string]interface{}{"error": err.Error()})
		response.Failed(c, http.StatusInternalServerError, consts.GainFail, "获取块存储资源池使用率信息失败")
		return
	}

	lib.Log.TagInfo(lib.GetTraceContext(c), lib.DLTagResponseSuccess, map[string]interface{}{"res": res})
	response.Success(c, res)
}

// ObjectPoolLine godoc
// @Summary      Dashboard ObjectPoolLine
// @Description  Get Dashboard ObjectPoolLine
// @Tags         dashBoard
// @Accept       json
// @Produce      json
// @Param        body body dto.ObjectPoolLineReq true " Dashboard ObjectPoolLine Request"
// @Success      200  {object}  dto.ObjectPoolLineRsp
// @Router       /dashboard/object_pool_line [POST]
func (s *DashboardController) ObjectPoolLine(c *gin.Context) {
	var params dto.ObjectPoolLineReq
	if err := c.ShouldBind(&params); err != nil {
		lib.Log.TagError(lib.GetTraceContext(c), lib.DLTagRequestOut, map[string]interface{}{"error": err.Error(), "params": params})
		response.Failed(c, http.StatusBadRequest, consts.ParameterError, "参数绑定失败")
		return
	}
	lib.Log.TagInfo(lib.GetTraceContext(c), lib.DLTagResponseFailed, map[string]interface{}{"params": params})
	// 业务处理
	res, err := s.svc.ObjectPoolLine(c, &params)
	if err != nil {
		lib.Log.TagError(lib.GetTraceContext(c), lib.DLTagResponseFailed, map[string]interface{}{"error": err.Error()})
		response.Failed(c, http.StatusInternalServerError, consts.GainFail, "获取对象存储资源池使用率信息失败")
		return
	}

	lib.Log.TagInfo(lib.GetTraceContext(c), lib.DLTagResponseSuccess, map[string]interface{}{"res": res})
	response.Success(c, res)
}

```

File path: /Users/mac/Desktop/woker_code/monitor/modules/basic/constant/constant.go
```golang
package constant

const ()

```

File path: /Users/mac/Desktop/woker_code/monitor/modules/basic/service/dashboard.go
```golang
package service

import (
	"context"
	resource_objectstoragev1alpha "ezone.ksyun.com/ezone/luban/luban_api/resourceapis/resource_objectstorage/v1alpha/gen"
	"ezone.ksyun.com/ezone/luban/monitor/common/promql_template/objectstorage"
	"strconv"
	"strings"
	"time"

	"ezone.ksyun.com/ezone/luban/communal/lib"
	resource_blockstoragev1alpha "ezone.ksyun.com/ezone/luban/luban_api/resourceapis/resource_blockstorage/v1alpha/gen"
	resource_computev1alpha "ezone.ksyun.com/ezone/luban/luban_api/resourceapis/resource_compute/v1alpha/gen"
	resource_serverv1alpha "ezone.ksyun.com/ezone/luban/luban_api/resourceapis/resource_server/v1alpha/gen"
	switch_rpc "ezone.ksyun.com/ezone/luban/luban_api/resourceapis/resource_switch/v1alpha/gen"
	k8sclient "ezone.ksyun.com/ezone/luban/monitor/common/client/k8s"
	prom_client "ezone.ksyun.com/ezone/luban/monitor/common/client/prom"
	"ezone.ksyun.com/ezone/luban/monitor/common/promql_template/blockstorage"
	"ezone.ksyun.com/ezone/luban/monitor/common/promql_template/compute"
	"ezone.ksyun.com/ezone/luban/monitor/common/promql_template/server"
	"ezone.ksyun.com/ezone/luban/monitor/common/types"
	"ezone.ksyun.com/ezone/luban/monitor/modules/basic/dao"
	"ezone.ksyun.com/ezone/luban/monitor/modules/basic/dto"
	"github.com/gin-gonic/gin"
	"github.com/pkg/errors"
	v1 "github.com/prometheus/client_golang/api/prometheus/v1"
	core "k8s.io/api/core/v1"
	meta "k8s.io/apimachinery/pkg/apis/meta/v1"
)

const (
	DefaultLabelKey   = "luban"
	DefaultLabelValue = "dashboard"
	DefaultName       = "default"
	DefaultMapKey     = "title"
	DefaultMapValue   = "Dashboard"
)

var (
	namespace = "luban"
	clientSet = k8sclient.GetClient()
)

type DashboardService struct {
	Store dao.DashboardStore
}

func NewDashboardService() *DashboardService {
	return &DashboardService{
		Store: *dao.NewJobsStore(),
	}
}

func (n *DashboardService) Create(ctx context.Context, par *dto.DashboardCreateReq) (*dto.DashboardCreateRsp, error) {

	conMap := &core.ConfigMap{}
	conMap.Name = par.Name
	conMap.Labels = map[string]string{
		DefaultLabelKey: DefaultLabelValue,
	}
	if len(par.Data) != 0 {
		conMap.Data = par.Data
	}
	_, err := clientSet.CoreV1().ConfigMaps(namespace).Create(ctx, conMap, meta.CreateOptions{})
	if err != nil {
		return nil, errors.WithMessage(err, "create configmap failed")
	}
	return &dto.DashboardCreateRsp{}, nil
}

func (n *DashboardService) Update(ctx context.Context, par *dto.DashboardUpdateReq) (*dto.DashboardUpdateRsp, error) {

	name := par.Name
	data := par.Data
	if name == "" {
		return nil, errors.New("name is nil, Invalid value!")
	}

	cm, err := clientSet.CoreV1().ConfigMaps(namespace).Get(ctx, name, meta.GetOptions{})
	if err != nil {
		return nil, errors.WithMessage(err, "get configmap failed")
	}

	cm.Labels = map[string]string{
		DefaultLabelKey: DefaultLabelValue,
	}

	if len(cm.Data) != 0 {
		cm.Data = data
	}

	newCm, e := clientSet.CoreV1().ConfigMaps(namespace).Update(ctx, cm, meta.UpdateOptions{})
	if e != nil {
		return nil, errors.WithMessage(e, "update configmap failed")
	}
	return &dto.DashboardUpdateRsp{
		Name: newCm.Name,
		Data: newCm.Data,
	}, nil
}

func (n *DashboardService) Delete(ctx context.Context, par *dto.DashboardDeleteReq) (*dto.DashboardDeleteRsp, error) {
	name := par.Name
	if name == "" {
		return nil, errors.New("name is nil, Invalid value!")
	}

	err := clientSet.CoreV1().ConfigMaps(namespace).Delete(ctx, name, meta.DeleteOptions{})
	if err != nil {
		return nil, errors.WithMessage(err, "delete configmap failed")
	}
	return &dto.DashboardDeleteRsp{}, nil
}

func (n *DashboardService) List(ctx context.Context, par *dto.DashboardListReq) (*dto.DashboardListRsp, error) {

	cml, err := clientSet.CoreV1().ConfigMaps(namespace).List(ctx, meta.ListOptions{
		LabelSelector: DefaultLabelKey + "=" + DefaultLabelValue,
	})
	if err != nil {
		return nil, errors.WithMessage(err, "list configmap failed")
	}
	var rps dto.DashboardListRsp
	for _, cm := range cml.Items {
		rps = append(rps, dto.DashboardInfo{
			Name: cm.Name,
			Data: cm.Data,
		})
	}
	return &rps, nil
}

func (n *DashboardService) Detail(ctx context.Context, par *dto.DashboardDetailReq) (*dto.DashboardDetailRsp, error) {
	name := par.Name
	if name == "" {
		return nil, errors.New("name is nil, Invalid value!")
	}

	cm, err := clientSet.CoreV1().ConfigMaps(namespace).Get(ctx, name, meta.GetOptions{})
	if err == nil {
		rsp := dto.DashboardDetailRsp{
			Name: cm.Name,
			Data: cm.Data,
		}
		return &rsp, nil
	}

	//默认值未创建，则创建默认值
	if err != nil {
		if name == DefaultName {
			m := make(map[string]string, 0)
			m[DefaultMapKey] = DefaultMapValue
			conMap := &core.ConfigMap{}
			conMap.Name = DefaultName
			conMap.Labels = map[string]string{
				DefaultLabelKey: DefaultLabelValue,
			}
			conMap.Data = m
			_, err = clientSet.CoreV1().ConfigMaps(namespace).Create(ctx, conMap, meta.CreateOptions{})
			if err != nil {
				return nil, errors.WithMessage(err, "create configmap failed")
			}
			rsp := dto.DashboardDetailRsp{
				Name: DefaultName,
				Data: m,
			}
			return &rsp, nil
		}
	}
	return &dto.DashboardDetailRsp{}, nil
}

func (n *DashboardService) PhysicalDevice(ctx *gin.Context, par *dto.PhysicalDeviceReq) (*dto.PhysicalOverviewTopRsp, error) {

	//获取服务器数据
	rpcServer, err := n.Store.ServiceRpcClient.PhysicalServerList(ctx, &resource_serverv1alpha.PhysicalHostListRequest{
		PageNo:   1,
		PageSize: -1,
		Region:   par.Region,
	})
	if err != nil {
		return nil, err
	}

	var (
		serverUp     int
		serverDown   int
		switchUp     int
		switchDown   int
		physicalNum  []types.BasicOverviewSlot
		serverStatus []types.BasicOverviewSlot
		switchStatus []types.BasicOverviewSlot
	)

	var ipList []string

	for _, servers := range rpcServer.PhysicalServerHostList {
		ipList = append(ipList, servers.ManageIp+":9100")
		//ipNamMap[server.ManageIp+":9100"] = server.HostName
		if servers.MonitoringStatus == "up" {
			serverUp += 1
		} else {
			serverDown += 1
		}
	}
	statusList := []string{"Up", "Down"}
	for _, name := range statusList {
		var serverStatusInfo types.BasicOverviewSlot
		var value int
		if name == "Up" {
			value = serverUp
		} else {
			value = serverDown
		}
		serverStatusInfo.Info = types.BasicOverviewSlotInfo{
			Index:     0,
			Name:      name,
			Value:     value,
			UnitType:  types.TypeNumber,
			Unit:      "个",
			Prognosis: 0,
		}
		serverStatus = append(serverStatus, serverStatusInfo)
	}

	//获取交换机监控状态
	rpcSwitch, err := n.Store.SwitchRpcClient.SwitchList(ctx, &switch_rpc.SwitchListRequest{
		PageNo:     1,
		PageSize:   -1,
		RegionCode: par.Region,
	})
	if err != nil {
		return nil, err
	}

	for _, switchs := range rpcSwitch.DataList {
		if switchs.RunStatus == "up" {
			switchUp += 1
		} else {
			switchDown += 1
		}
	}

	for _, name := range statusList {
		var switchStatusInfo types.BasicOverviewSlot
		var value int
		if name == "Up" {
			value = switchUp
		} else {
			value = switchDown
		}
		switchStatusInfo.Info = types.BasicOverviewSlotInfo{
			Index:     0,
			Name:      name,
			Value:     value,
			UnitType:  types.TypeNumber,
			Unit:      "个",
			Prognosis: 0,
		}
		switchStatus = append(switchStatus, switchStatusInfo)
	}

	//物理设备数量
	physicalList := []string{"ServerNum", "SwitchNum"}
	for _, name := range physicalList {
		var num types.BasicOverviewSlot
		var value int
		if name == "ServerNum" {
			value = int(rpcServer.TotalCount)
		} else {
			value = int(rpcSwitch.TotalCount)
		}
		num.Info = types.BasicOverviewSlotInfo{
			Index:     0,
			Name:      name,
			Value:     value,
			UnitType:  types.TypeNumber,
			Unit:      "个",
			Prognosis: 0,
		}
		physicalNum = append(physicalNum, num)
	}

	//获取服务器cpu mem disk top
	var tops []types.BasicOverviewSlot
	ips := strings.Join(ipList, "|")
	cpuTop, _ := Top(ctx, []string{"CpuRate"}, "5", ips, "30m")
	memTop, _ := Top(ctx, []string{"MemoryRate"}, "5", ips, "30m")
	diskTop, _ := Top(ctx, []string{"DiskRate"}, "5", ips, "30m")
	tops = append(tops, cpuTop)
	tops = append(tops, memTop)
	tops = append(tops, diskTop)

	return &dto.PhysicalOverviewTopRsp{
		PhysicalCount: physicalNum,
		ServerState:   serverStatus,
		SwitchState:   switchStatus,
		Tops:          tops,
	}, nil
}

func Top(ctx *gin.Context, metricName []string, topK, ips, t string) (res types.BasicOverviewSlot, err error) {
	var (
		psql string
		name string
	)
	for i := 0; i < len(metricName); i++ {
		switch metricName[i] {
		case "CpuRate":
			psql = server.GetCpuRateTop(topK, ips, t)
			name = "cpuRate"

		case "MemoryRate":
			psql = server.GetMemoryRateTopK(topK, ips, t)
			name = "MemoryRate"

		case "DiskRate":
			psql = server.GetDiskRateTopK(topK, ips, t)
			name = "DiskRate"
		}

		result, err := prom_client.VectorQuery(ctx, psql)
		if err != nil {
			return res, err
		}
		info := types.BasicOverviewSlotInfo{
			Name:     name,
			UnitType: "",
			Unit:     "%",
		}
		var val []types.BasicOverviewSlotValue
		for _, v := range result {
			ip := string(v.Metric["instance"])
			hostName := string(v.Metric["hostname"])
			vv := types.BasicOverviewSlotValue{
				Name:     hostName,
				Code:     ip,
				Value:    strconv.FormatFloat(float64(v.Value), 'f', 2, 64),
				Unit:     "%",
				UnitType: types.TypePercent,
			}
			val = append(val, vv)
		}
		res = types.BasicOverviewSlot{
			Info:   info,
			Values: val,
		}
	}

	return
}

func (n *DashboardService) ComputePoolLine(ctx *gin.Context, par *dto.ComputePoolLineReq) (*dto.ComputePoolLineRsp, error) {
	computePoolRpcRes, err := n.Store.ComputePoolRpcClient.ListComputePool(ctx, &resource_computev1alpha.ListComputePoolReq{
		PageSize: -1,
		Region:   par.Region,
	})
	if err != nil {
		lib.Log.TagError(lib.GetTraceContext(ctx), lib.DLTagHTTPFailed, map[string]interface{}{"error": err.Error()})
		return nil, err
	}
	var res = &dto.ComputePoolLineRsp{
		CpuRate:    make([]types.BasicOverviewSlot, 0),
		MemoryRate: make([]types.BasicOverviewSlot, 0),
		DiskRate:   make([]types.BasicOverviewSlot, 0),
	}
	start, end := time.Now().Add(-8*24*time.Hour).UnixMilli(), time.Now().UnixMilli()
	for _, computePool := range computePoolRpcRes.DataList {
		cpuRate, err := n.ComputePoolMatrix(ctx, start, end, computePool.Region, computePool.Az, computePool.Name, compute.CpuRate)
		if err != nil {
			lib.Log.TagError(lib.GetTraceContext(ctx), lib.DLTagResponseFailed, map[string]interface{}{"error": err.Error()})
		} else {
			res.CpuRate = append(res.CpuRate, cpuRate)
		}
		memoryRate, err := n.ComputePoolMatrix(ctx, start, end, computePool.Region, computePool.Az, computePool.Name, compute.MemoryRate)
		if err != nil {
			lib.Log.TagError(lib.GetTraceContext(ctx), lib.DLTagResponseFailed, map[string]interface{}{"error": err.Error()})
		} else {
			res.MemoryRate = append(res.MemoryRate, memoryRate)
		}
		diskRate, err := n.ComputePoolMatrix(ctx, start, end, computePool.Region, computePool.Az, computePool.Name, compute.DiskRate)
		if err != nil {
			lib.Log.TagError(lib.GetTraceContext(ctx), lib.DLTagResponseFailed, map[string]interface{}{"error": err.Error()})
		} else {
			res.DiskRate = append(res.DiskRate, diskRate)
		}
	}
	return res, nil
}

func (n *DashboardService) ComputePoolMatrix(ctx context.Context, start, end int64, region, az, poolName, metricName string) (types.BasicOverviewSlot, error) {
	promQlReq := compute.TemplateMap[metricName](region, az, poolName)
	rsp, err := n.Store.AlarmRpcClient.ListPromQLs(ctx, promQlReq)
	if err != nil {
		lib.Log.TagError(lib.GetTraceContext(ctx), lib.DLTagResponseFailed, map[string]interface{}{"error": err.Error()})
	}
	promQL := rsp.Items[0].RealPromql
	unit := rsp.Items[0].Unit

	matrix, err := prom_client.MatrixQuery(ctx, promQL, v1.Range{
		Start: time.UnixMilli(start),
		End:   time.UnixMilli(end),
		Step:  prom_client.TimeToStep(end - start),
	})
	if err != nil {
		return types.BasicOverviewSlot{}, errors.WithMessage(err, "prom_client MatrixQuery err")
	}

	line := types.BasicOverviewSlot{
		Info: types.BasicOverviewSlotInfo{
			Index:       0,
			Name:        poolName,
			Value:       0,
			UnitType:    types.ParseUnitTypeByUnit(unit),
			Unit:        unit,
			Kind:        types.KindInfo,
			Prognosis:   0, //预测值，values的下标，0则无预测值
			Description: "",
		},
		Values: make([]types.BasicOverviewSlotValue, 0),
	}
	for _, m := range matrix {
		for _, p := range m.Values {
			timeStamp := p.Timestamp
			value := p.Value
			line.Values = append(line.Values, types.BasicOverviewSlotValue{
				Name:        timeStamp.String(),
				Code:        metricName,
				Value:       value,
				Unit:        unit,
				UnitType:    types.ParseUnitTypeByUnit(unit),
				Kind:        types.KindInfo,
				Description: "",
			})
		}
	}
	return line, nil
}

func (n *DashboardService) EbsPoolLine(ctx *gin.Context, par *dto.EbsPoolLineReq) (*dto.EbsPoolLineRsp, error) {
	ebsPoolList, err := n.Store.EbsPoolRpcClient.ListEbsPool(ctx, &resource_blockstoragev1alpha.ListEbsPoolReq{
		PageSize: -1,
		Region:   par.Region,
	})
	if err != nil {
		lib.Log.TagError(lib.GetTraceContext(ctx), lib.DLTagUndefind, map[string]interface{}{"rpc error": err})
		return nil, err
	}
	start, end := time.Now().Add(-8*24*time.Hour).UnixMilli(), time.Now().UnixMilli()
	var res = &dto.EbsPoolLineRsp{CapRate: make([]types.BasicOverviewSlot, 0)}
	for _, ebsPool := range ebsPoolList.List {
		capRate, err := n.EbsPoolMatrix(ctx, start, end, ebsPool.Region, ebsPool.Az, ebsPool.Name, ebsPool.PoolType, blockstorage.EbsCapRate)
		if err != nil {
			lib.Log.TagError(lib.GetTraceContext(ctx), lib.DLTagResponseFailed, map[string]interface{}{"error": err.Error()})
		} else {
			res.CapRate = append(res.CapRate, capRate)
		}
	}
	return res, nil
}

func (n *DashboardService) EbsPoolMatrix(ctx context.Context, start, end int64, region, az, poolName, poolType, metricName string) (types.BasicOverviewSlot, error) {
	promQlReq := blockstorage.TemplateMap[metricName](region, az, poolName, poolType)
	rsp, err := n.Store.AlarmRpcClient.ListPromQLs(ctx, promQlReq)
	if err != nil {
		lib.Log.TagError(lib.GetTraceContext(ctx), lib.DLTagResponseFailed, map[string]interface{}{"error": err.Error()})
	}
	promQL := rsp.Items[0].RealPromql
	unit := rsp.Items[0].Unit

	matrix, err := prom_client.MatrixQuery(ctx, promQL, v1.Range{
		Start: time.UnixMilli(start),
		End:   time.UnixMilli(end),
		Step:  prom_client.TimeToStep(end - start),
	})
	if err != nil {
		return types.BasicOverviewSlot{}, errors.WithMessage(err, "prom_client MatrixQuery err")
	}

	line := types.BasicOverviewSlot{
		Info: types.BasicOverviewSlotInfo{
			Index:       0,
			Name:        poolName,
			Value:       0,
			UnitType:    types.ParseUnitTypeByUnit(unit),
			Unit:        unit,
			Kind:        types.KindInfo,
			Prognosis:   0, //预测值，values的下标，0则无预测值
			Description: "",
		},
		Values: make([]types.BasicOverviewSlotValue, 0),
	}
	for _, m := range matrix {
		for _, p := range m.Values {
			timeStamp := p.Timestamp
			value := p.Value
			line.Values = append(line.Values, types.BasicOverviewSlotValue{
				Name:        timeStamp.String(),
				Code:        metricName,
				Value:       value,
				Unit:        unit,
				UnitType:    types.ParseUnitTypeByUnit(unit),
				Kind:        types.KindInfo,
				Description: "",
			})
		}
	}
	return line, nil
}

func (n *DashboardService) ObjectPoolLine(ctx *gin.Context, par *dto.ObjectPoolLineReq) (*dto.ObjectPoolLineRsp, error) {
	objectPoolList, err := n.Store.ObjectPoolRpcClient.ListObjectPool(ctx, &resource_objectstoragev1alpha.ObjectPoolReq{
		PageSize: -1,
		Region:   par.Region,
	})
	if err != nil {
		lib.Log.TagError(lib.GetTraceContext(ctx), lib.DLTagUndefind, map[string]interface{}{"rpc error": err})
		return nil, err
	}
	start, end := time.Now().Add(-8*24*time.Hour).UnixMilli(), time.Now().UnixMilli()
	var res = &dto.ObjectPoolLineRsp{CapRate: make([]types.BasicOverviewSlot, 0)}
	for _, objectPool := range objectPoolList.List {
		capRate, err := n.ObjectPoolMatrix(ctx, start, end, objectPool.Region, objectPool.Name, objectPool.PoolType, objectstorage.ObjectPoolUsageRate)
		if err != nil {
			lib.Log.TagError(lib.GetTraceContext(ctx), lib.DLTagResponseFailed, map[string]interface{}{"error": err.Error()})
		} else {
			res.CapRate = append(res.CapRate, capRate)
		}
	}
	return res, nil
}

func (n *DashboardService) ObjectPoolMatrix(ctx context.Context, start, end int64, region, poolName, poolType, metricName string) (types.BasicOverviewSlot, error) {
	promQlReq := objectstorage.TemplateMap[metricName](region, "", poolName, poolType, poolName)
	rsp, err := n.Store.AlarmRpcClient.ListPromQLs(ctx, promQlReq)
	if err != nil {
		lib.Log.TagError(lib.GetTraceContext(ctx), lib.DLTagResponseFailed, map[string]interface{}{"error": err.Error()})
	}
	promQL := rsp.Items[0].RealPromql
	unit := rsp.Items[0].Unit

	matrix, err := prom_client.MatrixQuery(ctx, promQL, v1.Range{
		Start: time.UnixMilli(start),
		End:   time.UnixMilli(end),
		Step:  prom_client.TimeToStep(end - start),
	})
	if err != nil {
		return types.BasicOverviewSlot{}, errors.WithMessage(err, "prom_client MatrixQuery err")
	}

	line := types.BasicOverviewSlot{
		Info: types.BasicOverviewSlotInfo{
			Index:       0,
			Name:        poolName,
			Value:       0,
			UnitType:    types.ParseUnitTypeByUnit(unit),
			Unit:        unit,
			Kind:        types.KindInfo,
			Prognosis:   0, //预测值，values的下标，0则无预测值
			Description: "",
		},
		Values: make([]types.BasicOverviewSlotValue, 0),
	}
	for _, m := range matrix {
		for _, p := range m.Values {
			timeStamp := p.Timestamp
			value := p.Value / 100
			line.Values = append(line.Values, types.BasicOverviewSlotValue{
				Name:        timeStamp.String(),
				Code:        metricName,
				Value:       value,
				Unit:        unit,
				UnitType:    types.ParseUnitTypeByUnit(unit),
				Kind:        types.KindInfo,
				Description: "",
			})
		}
	}
	return line, nil
}

```

File path: /Users/mac/Desktop/woker_code/monitor/modules/server/dto/response.go
```golang
package dto

import "ezone.ksyun.com/ezone/luban/monitor/common/types"

type PhysicalOverviewAlertRsp struct {
	Alerts []types.BasicOverviewSlot `json:"Alerts"`
}

type PhysicalOverviewMonitorRsp struct {
	MonitoringStatus   []types.BasicOverviewSlot `json:"MonitoringStatus"`
	HardwareMonitoring []types.BasicOverviewSlot `json:"HardwareMonitoring"`
}

type PhysicalOverviewTopRsp struct {
	Tops []types.BasicOverviewSlot
}

type PhysicalListRsp struct {
	TotalCount             int64
	PageNo                 int
	PageSize               int
	PhysicalServerHostList []PhysicalServer `json:"InstanceList"`
}

type PhysicalServer struct {
	HostId           int     `json:"HostId"`
	HostName         string  `json:"HostName"`
	MonitoringStatus string  `json:"MonitoringStatus"`
	Node             string  `json:"Node"`
	ResourcePoolName string  `json:"ResourcePoolName"`
	ResourcePoolType string  `json:"ResourcePoolType"`
	Region           string  `json:"Region"`
	Az               string  `json:"Az"`
	Lab              string  `json:"Lab"`
	Sn               string  `json:"Sn"`
	Ip               string  `json:"Ip"`
	OutBindIp        string  `json:"OutBindIp"`
	CpuErrNum        int     `json:"CpuErrNum"`
	CpuLoad          float64 `json:"CpuLoad"`
	MemErrNum        int     `json:"MemErrNum"`
	MemLoad          float64 `json:"MemLoad"`
	DiskErrNum       int     `json:"DiskErrNum"`
	DiskLoad         float64 `json:"DiskLoad"`
	AlertNumber      int     `json:"AlertNumber"`
	Tag              string  `json:"Tag"`
}

type PhysicalDetailsOverviewRsp struct {
	DetailsOverview []types.BasicOverviewSlot `json:"DetailsOverview"`
}

type PhysicalDetailsOverviewLineRsp struct {
	Lines []types.BasicOverviewSlot `json:"Lines"`
}

type PhysicalHardwareRsp struct {
	IpmiStatus    []types.BasicOverviewSlot `json:"IpmiStatus"`
	InTemp        []types.BasicOverviewSlot `json:"InTemp"`
	OutTemp       []types.BasicOverviewSlot `json:"OutTemp"`
	CpuState      []types.BasicOverviewSlot `json:"CpuState"`
	MemState      []types.BasicOverviewSlot `json:"MemState"`
	DiskState     []types.BasicOverviewSlot `json:"DiskState"`
	PowerState    []types.BasicOverviewSlot `json:"PowerState"`
	FanState      []types.BasicOverviewSlot `json:"FanState"`
	MainBoardList []MainBoard               `json:"mainBoardList" description:"主板"`
	CpuList       CpuDetail                 `json:"CpuList" description:"cpu"`
	MemList       MemDetail                 `json:"MemList" description:"内存"`
	DiskList      DiskDetail                `json:"DiskList" description:"硬盘"`
	PowerList     []Power                   `json:"PowerList" description:"电源"`
	FanList       []Fan                     `json:"FanList" description:"风扇"`
	WorkList      []Work                    `json:"WorkList",description:"网卡"`
}

type MainBoard struct {
	Name          string  `json:"Name" description:"名称"`
	State         float64 `json:"State" description:"健康状态"`
	Sn            string  `json:"Sn" description:"序列号"`
	ProductNum    string  `json:"ProductNum" description:"产品部件号"`
	ProductTime   int64   `json:"ProductTime" description:"产品生产日期"`
	ProducFactory string  `json:"ProductFactory" description:"生产厂家"`
}

type CpuDetail struct {
	Sum     int   `json:"Sum" description:"cpu总数"`
	Cores   int   `json:"Cores" description:"cpu核心数"`
	CpuList []Cpu `json:"CpuList" description:"cpu列表"`
}
type Cpu struct {
	Name        string  `json:"Name" description:"名称"`
	State       float64 `json:"State" description:"健康状态"`
	UsedRate    float64 `json:"UsedRate" description:"使用率"`
	Temperature string  `json:"Temperature" description:"温度"`
	Model       string  `json:"Model" description:"型号"`
	ClockSpeed  string  `json:"ClockSpeed" description:"主频"`
	MaxClock    string  `json:"MaxClock" description:"最大主频"`
	Cores       byte    `json:"Cores" description:"核心数"`
	Threads     byte    `json:"Threads" description:"线程数"`
	L1Cache     string  `json:"L1Cache" description:"L1缓存"`
	L2Cache     string  `json:"L2Cache" description:"L2缓存"`
	L3Cache     string  `json:"L3Cache" description:"L3缓存"`
}

type MemDetail struct {
	Sum      int      `json:"Sum" description:"总数"`
	Capacity string   `json:"Capacity" description:"总容量"`
	MemList  []Memory `json:"MemList" description:"内存列表"`
}

type Memory struct {
	Name          string  `json:"Name" description:"名称"`
	State         float64 `json:"State" description:"健康状态"`
	UsedRate      float64 `json:"UsedRate" description:"使用率"`
	In            string  `json:"In" description:"在位信息"`
	Position      string  `json:"Position" description:"位置"`
	Channl        string  `json:"Channl" description:"通道"`
	Slot          string  `json:"Slot" description:"插槽"`
	Model         string  `json:"Model" description:"型号"`
	Ranks         int     `json:"Ranks" description:"ranks"`
	Width         int     `json:"Width" description:"位宽"`
	MaxClock      int     `json:"MaxClock" description:"最大主频"`
	Capacity      string  `json:"Capacity" description:"容量"`
	Tech          string  `json:"Tech" description:"技术"`
	Sn            string  `json:"Sn" description:"序列号"`
	ProductNum    string  `json:"ProductNum" description:"产品部件号"`
	ProducFactory string  `json:"ProducFactory" description:"生产厂家"`
}

type DiskDetail struct {
	Sum      int    `json:"sum" description:"总数"`
	Capacity string `json:"capacity" description:"总容量"`
	DiskList []Disk `json:"DiskList" description:"硬盘列表"`
}

type Disk struct {
	Name          string  `json:"Name" description:"名称"`
	State         float64 `json:"State" description:"健康状态"`
	UpDown        string  `json:"UpDown" description:"启用状态"`
	UsedRate      string  `json:"UsedRate" description:"使用率"`
	In            string  `json:"In" description:"在位信息"`
	Capacity      string  `json:"Capacity" description:"容量"`
	Domain        string  `json:"Domain" description:"硬盘域"`
	Model         string  `json:"Model" description:"型号"`
	DiskType      string  `json:"DiskType" description:"类型"`
	Temperature   string  `json:"Temperature" description:"温度"`
	Speed         float64 `json:"Speed" description:"转速"`
	ProducFactory string  `json:"ProductFactory" description:"生产厂家"`
	Sn            string  `json:"Sn" description:"序列号"`
}

type Power struct {
	Id              string  `json:"Id" description:"序号"`
	State           float64 `json:"State" description:"健康状态"`
	In              string  `json:"In" description:"在位信息"`
	Temperature     string  `json:"Temperature" description:"温度"`
	RatedPower      string  `json:"RatePower" description:"额定功率"`
	InputPower      float64 `json:"InputPower" description:"输入功率"`
	PowerInputModel string  `json:"PowerInputModel" description:"电源输入模式"`
	Model           string  `json:"Model" description:"型号"`
	FireWare        string  `json:"FireWare" description:"固件"`
	Sn              string  `json:"Sn" description:"序列号"`
	ProductNum      string  `json:"ProductNum" description:"产品部件号"`
	ProducFactory   string  `json:"ProductFactory" description:"生产厂家"`
}

type Fan struct {
	Name       string  `json:"Name" description:"名称"`
	State      float64 `json:"State" description:"健康状态"`
	In         string  `json:"In" description:"在位信息"`
	Speed      float64 `json:"Speed" description:"转速"`
	SpeedRate  string  `json:"SpeedRate" description:"速率比"`
	Redundancy string  `json:"Redundancy" description:"冗余"`
}

type Work struct {
	Name         string `json:"Name"`
	HealthStatus string `json:"HealthStatus"` // 健康状态
	Product      string `json:"Product"`      // 厂商
	Vendor       string `json:"Vendor"`       // 型号
	Speed        string `json:"Speed"`        // 速率
	Units        string `json:"Units"`
	Size         int    `json:"Size"`
	Mac          string `json:"Mac"`
}

type GetMonitoringStatusRsp struct {
	Ip           string `json:"Ip" binding:"required"`
	ResourceType string `json:"ResourceType"`
	RunStatus    string `json:"RunStatus"`
}

```

File path: /Users/mac/Desktop/woker_code/monitor/modules/server/dto/request.go
```golang
package dto

type PhysicalOverviewMonitorReq struct {
	Region string   `json:"Region"`
	Az     []string `json:"Az"`
	LabId  []int32  `json:"LabId"`
}

type PhysicalOverviewTopReq struct {
	Region     string   `json:"Region"`
	Az         []string `json:"Az"`
	LabId      []int32  `json:"LabId"`
	MetricName []string `json:"MetricName"`
	TopK       string   `json:"TopK"`
	Start      int64    `json:"Start"`
	End        int64    `json:"End"`
}

type PhysicalListReq struct {
	PageNo           int      `json:"PageNo"`
	PageSize         int      `json:"PageSize"`
	Region           string   `json:"Region"`
	Az               []string `json:"Az"`
	LabId            []int32  `json:"LabId"`
	MonitoringStatus []string `json:"MonitoringStatus"` //监控状态
	NodeType         []string `json:"NodeType"`         //节点类型实际对应库里node字段
	ResourcePoolType []string `json:"ResourcePoolType"` //所属资源池类型
	ResourcePoolName string   `json:"ResourcePoolName"` //所属资源池
	CpuErrNum        string   `json:"CpuErrNum"`
	MemErrNum        string   `json:"MemErrNum"`
	DiskErrNum       string   `json:"DiskErrNum"`
	Query            Query    `json:"Query"`
	OrderCode        string   `json:"OrderCode" form:"OrderCode"`
	OrderType        string   `json:"OrderType" form:"OrderType" binding:"omitempty,oneof=ASC DESC"`
}

type Query map[string]string

type PhysicalDetailsOverviewReq struct {
	DeviceSn string
}

type PhysicalDetailsLineReq struct {
	Ip         string   `json:"Ip" binding:"required"`
	MetricName []string `json:"MetricName" binding:"required"`
	Start      int64    `json:"Start" binding:"required"`
	End        int64    `json:"End" binding:"required"`
	WorkName   string   `json:"WorkName"`
}

type PhysicalWorkListReq struct {
	Ip string `json:"Ip" binding:"required"`
}

type PhysicalHardwareReq struct {
	DeviceSn string
}

type GetMonitoringStatusReq struct {
	Ip           string `json:"Ip" binding:"required"`
	ResourceType string `json:"ResourceType" binding:"omitempty,oneof=Switch Server"`
}

```

File path: /Users/mac/Desktop/woker_code/monitor/modules/server/dao/overview.go
```golang
package dao

import (
	"ezone.ksyun.com/ezone/luban/communal/lib"
	alarmv1alpha "ezone.ksyun.com/ezone/luban/luban_api/alarmapis/alarm/v1alpha/gen"
	serverpb "ezone.ksyun.com/ezone/luban/luban_api/resourceapis/resource_server/v1alpha/gen"
	"ezone.ksyun.com/ezone/luban/monitor/common/client/grpcx"
)

type ServerStore struct {
	//rpc
	ServiceRpcClient serverpb.ResourceServiceClient
	AlarmRpcClient   alarmv1alpha.AlarmServiceClient

	//dao
	AssetPhysicalServerHardwareDao *AssetPhysicalServerHardwareDao
}

func NewServerStore() *ServerStore {
	//resource
	resourceAddr := lib.GetStringConf("base.grpc.luban_resource")
	resourceConn, err := grpcx.NewGrpcClientConn(resourceAddr)
	if err != nil {
		lib.Log.TagError(lib.NewTrace(), lib.DLTagUndefind, map[string]interface{}{"connect luban_resource grpc server error, %s": err.Error()})
	}

	//alarm
	alarmAddr := lib.GetStringConf("base.grpc.alarm")
	alarmConn, err := grpcx.NewGrpcClientConn(alarmAddr)
	if err != nil {
		lib.Log.TagError(lib.NewTrace(), lib.DLTagUndefind, map[string]interface{}{"connect alarm grpc server error, %s": err.Error()})
	}

	return &ServerStore{
		ServiceRpcClient:               serverpb.NewResourceServiceClient(resourceConn),
		AlarmRpcClient:                 alarmv1alpha.NewAlarmServiceClient(alarmConn),
		AssetPhysicalServerHardwareDao: NewAssetPhysicalServerHardwareDao(),
		//MetricTopDao:     NewMetricTopDao(),
	}
}

```

File path: /Users/mac/Desktop/woker_code/monitor/modules/server/dao/asset_physical_server_hardware.go
```golang
package dao

import (
	"context"

	"ezone.ksyun.com/ezone/luban/communal/lib"
	"ezone.ksyun.com/ezone/luban/monitor/modules/server/model"
	"gorm.io/gorm"
)

type AssetPhysicalServerHardwareDao struct {
	db *gorm.DB
}

func NewAssetPhysicalServerHardwareDao() *AssetPhysicalServerHardwareDao {
	return &AssetPhysicalServerHardwareDao{
		db: lib.GORMMapPool["business"].Debug(),
	}
}

func (m *AssetPhysicalServerHardwareDao) GetHardware(ctx context.Context, sn string) (*model.AssetPhysicalServerHardware, error) {
	content := model.AssetPhysicalServerHardware{}
	err := m.db.Where("sn = ?", sn).Find(&content).Error
	if err != nil {
		lib.Log.TagError(lib.NewTrace(), lib.DLTagMySqlFailed, map[string]interface{}{"error": err.Error()})
		return nil, err
	}
	return &content, nil
}

```

File path: /Users/mac/Desktop/woker_code/monitor/modules/server/controller/server.go
```golang
package controller

import (
	"ezone.ksyun.com/ezone/luban/communal/lib"
	"ezone.ksyun.com/ezone/luban/monitor/common/consts"
	"ezone.ksyun.com/ezone/luban/monitor/modules/server/dto"
	"ezone.ksyun.com/ezone/luban/monitor/modules/server/service"
	"ezone.ksyun.com/ezone/luban/monitor/response"
	"github.com/gin-gonic/gin"
	"net/http"
)

type ServerController struct {
	svc *service.PhysicalService
}

func NewServerController() *ServerController {
	return &ServerController{
		svc: service.NewPhysicalService(),
	}
}

func (s *ServerController) PhysicalOverviewAlert(c *gin.Context) {
	// 参数绑定
	var params dto.PhysicalOverviewMonitorReq
	if err := c.ShouldBind(&params); err != nil {
		lib.Log.TagError(lib.GetTraceContext(c), lib.DLTagRequestOut, map[string]interface{}{"error": err.Error(), "params": params})
		response.Failed(c, http.StatusBadRequest, consts.ParameterError, "参数绑定失败")
		return
	}
	lib.Log.TagInfo(lib.GetTraceContext(c), lib.DLTagResponseFailed, map[string]interface{}{"params": params})

	// 业务处理
	res, err := s.svc.PhysicalOverviewAlert(c, params)
	if err != nil {
		lib.Log.TagError(lib.GetTraceContext(c), lib.DLTagResponseFailed, map[string]interface{}{"error": err.Error()})
		response.Failed(c, http.StatusInternalServerError, consts.GainFail, "获取服务器概览监控告警失败")
		return
	}

	lib.Log.TagInfo(lib.GetTraceContext(c), lib.DLTagResponseSuccess, map[string]interface{}{"res": res})
	response.Success(c, res)
}

func (s *ServerController) PhysicalOverviewMonitor(c *gin.Context) {
	// 参数绑定
	var params dto.PhysicalOverviewMonitorReq
	if err := c.ShouldBind(&params); err != nil {
		lib.Log.TagError(lib.GetTraceContext(c), lib.DLTagRequestOut, map[string]interface{}{"error": err.Error(), "params": params})
		response.Failed(c, http.StatusBadRequest, consts.ParameterError, "参数绑定失败")
		return
	}
	lib.Log.TagInfo(lib.GetTraceContext(c), lib.DLTagResponseFailed, map[string]interface{}{"params": params})

	// 业务处理
	res, err := s.svc.PhysicalOverviewMonitor(c, params)
	if err != nil {
		lib.Log.TagError(lib.GetTraceContext(c), lib.DLTagResponseFailed, map[string]interface{}{"error": err.Error()})
		response.Failed(c, http.StatusInternalServerError, consts.GainFail, "获取服务器概览监控状态失败")
		return
	}

	lib.Log.TagInfo(lib.GetTraceContext(c), lib.DLTagResponseSuccess, map[string]interface{}{"res": res})
	response.Success(c, res)
}

func (s *ServerController) PhysicalOverviewTop(c *gin.Context) {
	// 参数绑定
	var params dto.PhysicalOverviewTopReq
	if err := c.ShouldBind(&params); err != nil {
		lib.Log.TagError(lib.GetTraceContext(c), lib.DLTagRequestOut, map[string]interface{}{"error": err.Error(), "params": params})
		response.Failed(c, http.StatusBadRequest, consts.ParameterError, "参数绑定失败")
		return
	}
	lib.Log.TagInfo(lib.GetTraceContext(c), lib.DLTagResponseFailed, map[string]interface{}{"params": params})

	// 业务处理
	res, err := s.svc.PhysicalOverviewTop(c, params)
	if err != nil {
		lib.Log.TagError(lib.GetTraceContext(c), lib.DLTagResponseFailed, map[string]interface{}{"error": err.Error()})
		response.Failed(c, http.StatusInternalServerError, consts.GainFail, "获取服务器概览Top失败")
		return
	}

	lib.Log.TagInfo(lib.GetTraceContext(c), lib.DLTagResponseSuccess, map[string]interface{}{"res": res})
	response.Success(c, res)
}

func (s *ServerController) PhysicalList(c *gin.Context) {
	// 参数绑定
	var params dto.PhysicalListReq
	if err := c.ShouldBind(&params); err != nil {
		lib.Log.TagError(lib.GetTraceContext(c), lib.DLTagRequestOut, map[string]interface{}{"error": err.Error(), "params": params})
		response.Failed(c, http.StatusBadRequest, consts.ParameterError, "参数绑定失败")
		return
	}
	lib.Log.TagInfo(lib.GetTraceContext(c), lib.DLTagResponseFailed, map[string]interface{}{"params": params})

	// 业务处理
	res, err := s.svc.PhysicalList(c, params)
	if err != nil {
		lib.Log.TagError(lib.GetTraceContext(c), lib.DLTagResponseFailed, map[string]interface{}{"error": err.Error()})
		response.Failed(c, http.StatusInternalServerError, consts.GainFail, "获取服务器概览Top失败")
		return
	}

	lib.Log.TagInfo(lib.GetTraceContext(c), lib.DLTagResponseSuccess, map[string]interface{}{"res": res})
	response.Success(c, res)
}

func (s *ServerController) PhysicalDetailsOverview(c *gin.Context) {
	// 参数绑定
	var params dto.PhysicalDetailsOverviewReq
	if err := c.ShouldBind(&params); err != nil {
		lib.Log.TagError(lib.GetTraceContext(c), lib.DLTagRequestOut, map[string]interface{}{"error": err.Error(), "params": params})
		response.Failed(c, http.StatusBadRequest, consts.ParameterError, "参数绑定失败")
		return
	}
	lib.Log.TagInfo(lib.GetTraceContext(c), lib.DLTagResponseFailed, map[string]interface{}{"params": params})

	// 业务处理
	res, err := s.svc.PhysicalDetailsOverview(c, params)
	if err != nil {
		lib.Log.TagError(lib.GetTraceContext(c), lib.DLTagResponseFailed, map[string]interface{}{"error": err.Error()})
		response.Failed(c, http.StatusInternalServerError, consts.GainFail, "获取服务器详情概览失败")
		return
	}

	lib.Log.TagInfo(lib.GetTraceContext(c), lib.DLTagResponseSuccess, map[string]interface{}{"res": res})
	response.Success(c, res)
}

func (s *ServerController) PhysicalDetailsLine(c *gin.Context) {
	// 参数绑定
	var params dto.PhysicalDetailsLineReq
	if err := c.ShouldBind(&params); err != nil {
		lib.Log.TagError(lib.GetTraceContext(c), lib.DLTagRequestOut, map[string]interface{}{"error": err.Error(), "params": params})
		response.Failed(c, http.StatusBadRequest, consts.ParameterError, "参数绑定失败")
		return
	}
	lib.Log.TagInfo(lib.GetTraceContext(c), lib.DLTagResponseFailed, map[string]interface{}{"params": params})

	// 业务处理
	res, err := s.svc.PhysicalDetailsLine(c, params)
	if err != nil {
		lib.Log.TagError(lib.GetTraceContext(c), lib.DLTagResponseFailed, map[string]interface{}{"error": err.Error()})
		response.Failed(c, http.StatusInternalServerError, consts.GainFail, "获取服务器详情折线图失败")
		return
	}

	lib.Log.TagInfo(lib.GetTraceContext(c), lib.DLTagResponseSuccess, map[string]interface{}{"res": res})
	response.Success(c, res)
}

func (s *ServerController) PhysicalWorkList(c *gin.Context) {
	// 参数绑定
	var params dto.PhysicalWorkListReq
	if err := c.ShouldBind(&params); err != nil {
		lib.Log.TagError(lib.GetTraceContext(c), lib.DLTagRequestOut, map[string]interface{}{"error": err.Error(), "params": params})
		response.Failed(c, http.StatusBadRequest, consts.ParameterError, "参数绑定失败")
		return
	}
	lib.Log.TagInfo(lib.GetTraceContext(c), lib.DLTagResponseFailed, map[string]interface{}{"params": params})

	// 业务处理
	res, err := s.svc.PhysicalWorkList(c, params)
	if err != nil {
		lib.Log.TagError(lib.GetTraceContext(c), lib.DLTagResponseFailed, map[string]interface{}{"error": err.Error()})
		response.Failed(c, http.StatusInternalServerError, consts.GainFail, "获取服务器详情折线图失败")
		return
	}

	lib.Log.TagInfo(lib.GetTraceContext(c), lib.DLTagResponseSuccess, map[string]interface{}{"res": res})
	response.Success(c, res)
}

func (s *ServerController) MonitoringStatus(c *gin.Context) {
	// 参数绑定
	var params dto.GetMonitoringStatusReq
	if err := c.ShouldBind(&params); err != nil {
		lib.Log.TagError(lib.GetTraceContext(c), lib.DLTagRequestOut, map[string]interface{}{"error": err.Error(), "params": params})
		response.Failed(c, http.StatusBadRequest, consts.ParameterError, "参数绑定失败")
		return
	}
	lib.Log.TagInfo(lib.GetTraceContext(c), lib.DLTagResponseFailed, map[string]interface{}{"params": params})

	// 业务处理
	res, err := s.svc.GetMonitoringStatus(c, params)
	if err != nil {
		lib.Log.TagError(lib.GetTraceContext(c), lib.DLTagResponseFailed, map[string]interface{}{"error": err.Error()})
		response.Failed(c, http.StatusInternalServerError, consts.GainFail, "获取监控状态失败")
		return
	}

	lib.Log.TagInfo(lib.GetTraceContext(c), lib.DLTagResponseSuccess, map[string]interface{}{"res": res})
	response.Success(c, res)
}

func (s *ServerController) PhysicalHardware(c *gin.Context) {
	// 参数绑定
	var params dto.PhysicalHardwareReq
	if err := c.ShouldBind(&params); err != nil {
		lib.Log.TagError(lib.GetTraceContext(c), lib.DLTagRequestOut, map[string]interface{}{"error": err.Error(), "params": params})
		response.Failed(c, http.StatusBadRequest, consts.ParameterError, "参数绑定失败")
		return
	}
	lib.Log.TagInfo(lib.GetTraceContext(c), lib.DLTagResponseFailed, map[string]interface{}{"params": params})

	// 业务处理
	res, err := s.svc.PhysicalHardware(c, params)
	if err != nil {
		lib.Log.TagError(lib.GetTraceContext(c), lib.DLTagResponseFailed, map[string]interface{}{"error": err.Error()})
		response.Failed(c, http.StatusInternalServerError, consts.GainFail, "获取服务器硬件失败")
		return
	}

	lib.Log.TagInfo(lib.GetTraceContext(c), lib.DLTagResponseSuccess, map[string]interface{}{"res": res})
	response.Success(c, res)
}

```

File path: /Users/mac/Desktop/woker_code/monitor/modules/server/constant/constant.go
```golang
package constant

const ()

```

File path: /Users/mac/Desktop/woker_code/monitor/modules/server/model/asset_physical_server.go
```golang
package model

import (
	"time"
)

// AssetPhysicalServer 物理服务器
// 物理服务器
type AssetPhysicalServer struct {
	Id                 int       `gorm:"column:id;type:int(11);primary_key;AUTO_INCREMENT;comment:服务器ID" json:"id"`
	Name               string    `gorm:"column:name;type:varchar(50);comment:服务器名称;NOT NULL" json:"name"`
	Ip                 string    `gorm:"column:ip;type:varchar(20);comment:ip;NOT NULL" json:"ip"`
	RunStatus          string    `gorm:"column:run_status;type:varchar(10);comment:运行状态(up:运行中;down:故障中);NOT NULL" json:"run_status"`
	AssignmentStatus   string    `gorm:"column:assignment_status;type:varchar(10);comment:分配状态(assigned:已分配;unassigned:未分配);NOT NULL" json:"assignment_status"`
	Service            string    `gorm:"column:service;type:varchar(500);comment:业务;NOT NULL" json:"service"`
	AzId               int       `gorm:"column:az_id;type:int(11);default:0;comment:az id;NOT NULL" json:"az_id"`
	AzCode             string    `gorm:"column:az_code;type:varchar(20);comment:可用区;NOT NULL" json:"az_code"`
	RegionId           int       `gorm:"column:region_id;type:int(11);default:0;comment:region id;NOT NULL" json:"region_id"`
	RegionCode         string    `gorm:"column:region_code;type:varchar(20);comment:区域;NOT NULL" json:"region_code"`
	LabId              int       `gorm:"column:lab_id;type:int(11);default:0;comment:机房id;NOT NULL" json:"lab_id"`
	RoomId             int       `gorm:"column:room_id;type:int(11);default:0;comment:房间id;NOT NULL" json:"room_id"`
	CabinetId          int       `gorm:"column:cabinet_id;type:int(11);default:0;comment:机柜id;NOT NULL" json:"cabinet_id"`
	RackId             int       `gorm:"column:rack_id;type:int(11);default:0;comment:机架位id;NOT NULL" json:"rack_id"`
	HostUnitNumber     int       `gorm:"column:host_unit_number;type:int(11);default:0;comment:所占U位;NOT NULL" json:"host_unit_number"`
	Sn                 string    `gorm:"column:sn;type:varchar(36);comment:SN号;NOT NULL" json:"sn"`
	ServerType         string    `gorm:"column:server_type;type:varchar(200);comment:服务器型号;NOT NULL" json:"server_type"`
	OutBandIp          string    `gorm:"column:out_band_ip;type:varchar(20);comment:带外IP;NOT NULL" json:"out_band_ip"`
	OutBandUser        string    `gorm:"column:out_band_user;type:varchar(255);comment:带外IP账号;NOT NULL" json:"out_band_user"`
	OutBandPassword    string    `gorm:"column:out_band_password;type:varchar(255);comment:带外IP账号密码;NOT NULL" json:"out_band_password"`
	Power              string    `gorm:"column:power;type:varchar(50);comment:电源/功率;NOT NULL" json:"power"`
	MainMaintainer     string    `gorm:"column:main_maintainer;type:varchar(10);comment:主要维护人;NOT NULL" json:"main_maintainer"`
	UplinkSwitch       string    `gorm:"column:uplink_switch;type:varchar(100);comment:上联交换机;NOT NULL" json:"uplink_switch"`
	MaintenanceDue     time.Time `gorm:"column:maintenance_due;type:timestamp;comment:维保到期时间" json:"maintenance_due"`
	MaintenanceStatus  string    `gorm:"column:maintenance_status;type:varchar(10);comment:维保到期状态(uninsured:未过保;insured3m:3个月过保;insured1m:1个月过保;insured:已过保);NOT NULL" json:"maintenance_status"`
	AssetsNumber       string    `gorm:"column:assets_number;type:varchar(20);comment:资产编号;NOT NULL" json:"assets_number"`
	InputTime          int       `gorm:"column:input_time;type:int(11);default:0;comment:录入时间;NOT NULL" json:"input_time"`
	InputMethod        string    `gorm:"column:input_method;type:varchar(10);comment:录入方式(auto:自动;manual:手动);NOT NULL" json:"input_method"`
	MacAddress         string    `gorm:"column:mac_address;type:varchar(100);comment:MAC地址;NOT NULL" json:"mac_address"`
	SystemSales        string    `gorm:"column:system_sales;type:varchar(100);comment:服务器厂商;NOT NULL" json:"system_sales"`
	Description        string    `gorm:"column:description;type:varchar(100);comment:描述;NOT NULL" json:"description"`
	Creator            string    `gorm:"column:creator;type:varchar(64);comment:创建人;NOT NULL" json:"creator"`
	CreateTime         int       `gorm:"column:create_time;type:int(11);default:0;comment:创建时间;NOT NULL" json:"create_time"`
	CpuAllocationRatio int       `gorm:"column:cpu_allocation_ratio;type:int(10) unsigned;default:0;comment:cpu超配额;NOT NULL" json:"cpu_allocation_ratio"`
	RamAllocationRatio float64   `gorm:"column:ram_allocation_ratio;type:float unsigned;default:0;comment:内存超配额;NOT NULL" json:"ram_allocation_ratio"`
	OperateSystem      string    `gorm:"column:operate_system;type:varchar(64);comment:操作系统;NOT NULL" json:"operate_system"`
	CpuTotal           int       `gorm:"column:cpu_total;type:int(10) unsigned;default:0;comment:cpu总和;NOT NULL" json:"cpu_total"`
	MemoryTotal        int       `gorm:"column:memory_total;type:int(10) unsigned;default:0;comment:内存总和;NOT NULL" json:"memory_total"`
	Deleted            int       `gorm:"column:deleted;type:int(11);default:0;comment:是否删除 1：删除，0：未删除" json:"deleted"`
	Label              string    `gorm:"column:label;type:varchar(100);comment:标签;NOT NULL" json:"label"`
	ResourcePoolType   string    `gorm:"column:resource_pool_type;type:varchar(50);comment:服务器所属资源池类型;NOT NULL" json:"resource_pool_type"`
	ResourcePool       string    `gorm:"column:resource_pool;type:varchar(50);comment:服务器所属资源池;NOT NULL" json:"resource_pool"`
	Node               string    `gorm:"column:node;type:varchar(255);comment:服务器节点" json:"node"`
	NodeType           string    `gorm:"column:node_type;type:varchar(100);comment:服务器节点类型;NOT NULL" json:"node_type"`
	NodeGroup          string    `gorm:"column:node_group;type:varchar(255);comment:服务器节点" json:"node_group"`
	IsVm               int       `gorm:"column:is_vm;type:int(11);default:0;comment:是否是虚机 0:物理机器,1虚机 ;NOT NULL" json:"is_vm"`
	Kind               string    `gorm:"column:kind;type:varchar(64);comment:服务器型后;NOT NULL" json:"kind"`
	LastUpdateAt       time.Time `gorm:"column:last_update_at;type:timestamp" json:"last_update_at"`
}

// AssetSwitch 物理交换机
type AssetSwitch struct {
	Id                int       `gorm:"column:id;type:int(11);primary_key;AUTO_INCREMENT;comment:交换机ID" json:"id"`
	Name              string    `gorm:"column:name;type:varchar(50);comment:交换机名称;NOT NULL" json:"name"`
	Ip                string    `gorm:"column:ip;type:varchar(20);comment:ip;NOT NULL" json:"ip"`
	RunStatus         string    `gorm:"column:run_status;type:varchar(10);comment:运行状态(up:运行中;down:故障中);NOT NULL" json:"run_status"`
	SnmpStatus        int       `gorm:"column:snmp_status;type:int(10);comment:snmp 状态 0 正常 1 异常" json:"snmp_status"`
	AzId              int       `gorm:"column:az_id;type:int(11);default:0;comment:az id;NOT NULL" json:"az_id"`
	RegionId          int       `gorm:"column:region_id;type:int(11);default:0;comment:region id;NOT NULL" json:"region_id"`
	LabId             int       `gorm:"column:lab_id;type:int(11);default:0;comment:机房id;NOT NULL" json:"lab_id"`
	RoomId            int       `gorm:"column:room_id;type:int(11);default:0;comment:房间id;NOT NULL" json:"room_id"`
	CabinetId         int       `gorm:"column:cabinet_id;type:int(11);default:0;comment:机柜id;NOT NULL" json:"cabinet_id"`
	RackId            int       `gorm:"column:rack_id;type:int(11);default:0;comment:机架位id;NOT NULL" json:"rack_id"`
	SwitchUnitNumber  int       `gorm:"column:switch_unit_number;type:int(11);default:0;comment:所占U位;NOT NULL" json:"switch_unit_number"`
	Sn                string    `gorm:"column:sn;type:varchar(50);comment:SN号;NOT NULL" json:"sn"`
	SwitchType        string    `gorm:"column:switch_type;type:varchar(50);comment:交换机型号;NOT NULL" json:"switch_type"`
	SwitchRole        string    `gorm:"column:switch_role;type:varchar(10);comment:交换机角色;NOT NULL" json:"switch_role"`
	OutBandIp         string    `gorm:"column:out_band_ip;type:varchar(20);comment:带外IP;NOT NULL" json:"out_band_ip"`
	Community         string    `gorm:"column:community;type:varchar(20);comment:团体字;NOT NULL" json:"community"`
	MainMaintainer    string    `gorm:"column:main_maintainer;type:varchar(50);comment:负责人;NOT NULL" json:"main_maintainer"`
	MaintenanceDue    time.Time `gorm:"column:maintenance_due;type:timestamp;comment:维保到期时间" json:"maintenance_due"`
	MaintenanceStatus string    `gorm:"column:maintenance_status;type:varchar(10);comment:维保到期状态(uninsured:未过保;insured3m:3个月过保;insured1m:1个月过保;insured:已过保);NOT NULL" json:"maintenance_status"`
	AssetsNumber      string    `gorm:"column:assets_number;type:varchar(10);comment:资产编号;NOT NULL" json:"assets_number"`
	InputTime         time.Time `gorm:"column:input_time;type:timestamp;comment:交换机录入时间" json:"input_time"`
	SystemSales       string    `gorm:"column:system_sales;type:varchar(10);comment:交换机厂商;NOT NULL" json:"system_sales"`
	HardwareVersion   string    `gorm:"column:hardware_version;type:varchar(20);comment:硬件版本;NOT NULL" json:"hardware_version"`
	OsVersion         string    `gorm:"column:os_version;type:varchar(20);comment:OS版本;NOT NULL" json:"os_version"`
	Label             string    `gorm:"column:label;type:varchar(20);comment:标签" json:"label"`
	Description       string    `gorm:"column:description;type:varchar(100);comment:描述;NOT NULL" json:"description"`
	Creator           string    `gorm:"column:creator;type:varchar(64);comment:创建人;NOT NULL" json:"creator"`
	CreateTime        time.Time `gorm:"column:create_time;type:timestamp;default:CURRENT_TIMESTAMP;comment:创建时间;NOT NULL" json:"create_time"`
	Updater           string    `gorm:"column:updater;type:varchar(64);comment:修改人;NOT NULL" json:"updater"`
	UpdateTime        time.Time `gorm:"column:update_time;type:timestamp;default:CURRENT_TIMESTAMP;comment:修改时间;NOT NULL" json:"update_time"`
	OperateSystem     string    `gorm:"column:operate_system;type:varchar(64);comment:操作系统;NOT NULL" json:"operate_system"`
	Deleted           int       `gorm:"column:deleted;type:int(11);default:0;comment:是否删除 1：删除，0：未删除" json:"deleted"`
	CpuModel          string    `gorm:"column:cpu_model;type:varchar(50);comment:cpu型号;NOT NULL" json:"cpu_model"`
	MemModel          string    `gorm:"column:mem_model;type:varchar(50);comment:内存型号;NOT NULL" json:"mem_model"`
	Mib               string    `gorm:"column:mib;type:varchar(255);comment:mib" json:"mib"`
	IntervalTime      string    `gorm:"column:interval_time;type:varchar(255);comment:时间间隔" json:"interval_time"`
	ScrapeTimeout     string    `gorm:"column:scrape_timeout;type:varchar(255);comment:过期时间" json:"scrape_timeout"`
}

```

File path: /Users/mac/Desktop/woker_code/monitor/modules/server/model/asset_physical_server_hardware.go
```golang
package model

import (
	"database/sql/driver"
	"encoding/json"
	"time"
)

type AssetPhysicalServerHardware struct {
	Id            int                `gorm:"column:id;type:int(11);primary_key;AUTO_INCREMENT;comment:ID" json:"id"`
	Sn            string             `gorm:"column:sn;type:varchar(64);comment:设备sn号;NOT NULL" json:"sn"`
	HostName      string             `gorm:"column:host_name;type:varchar(50);comment:名称;NOT NULL" json:"host_name"`
	SysInfo       SysInfoSlice       `gorm:"column:sys_info;type:text;comment:系统信息" json:"sys_info"`
	BaseboardInfo BaseboardInfoSlice `gorm:"column:baseboard_info;type:text;comment:主板信息" json:"baseboard_info"`
	CpuInfo       CpuInfoSlice       `gorm:"column:cpu_info;type:text;comment:cpu信息" json:"cpu_info"`
	DiskInfo      DiskInfoSlice      `gorm:"column:disk_info;type:text;comment:磁盘信息" json:"disk_info"`
	GpuInfo       GpuInfoSlice       `gorm:"column:gpu_info;type:text;comment:显卡信息" json:"gpu_info"`
	MemoryInfo    MemoryInfoSlice    `gorm:"column:memory_info;type:text;comment:内存信息" json:"memory_info"`
	NicInfo       NicInfoSlice       `gorm:"column:nic_info;type:text;comment:nic信息" json:"nic_info"`
	RaidInfo      RaidInfoSlice      `gorm:"column:raid_info;type:text;comment:磁盘阵列信息" json:"raid_info"`
	WorkInfo      WorkInfoSlice      `gorm:"column:work_info;type:text;comment:网卡信息" json:"work_info"`
	//FanInfo       string       `gorm:"column:fan_info;type:text;comment:风扇信息" json:"fan_info"`
	//PowerInfo     string       `gorm:"column:power_info;type:text;comment:电源信息" json:"power_info"`
	LastUpdateAt time.Time `gorm:"column:last_update_at;type:timestamp" json:"last_update_at"`
}

type (
	SysInfoSlice       []SysInfo
	WorkInfoSlice      []WorkInfo
	BaseboardInfoSlice []BaseboardInfo
	CpuInfoSlice       []CpuInfo
	DiskInfoSlice      []DiskInfo
	GpuInfoSlice       []GpuInfo
	MemoryInfoSlice    []MemoryDeviceInfo
	NicInfoSlice       []NicInfo
	RaidInfoSlice      []RaidInfo
)

type (
	SysInfo struct {
		Manufacturer      string `json:"Manufacturer" gorm:"column:manufacturer;type:varchar(100)"`
		ProductName       string `json:"ProductName" gorm:"column:manufacturer;type:varchar(100)"`
		Version           string `json:"Version" gorm:"column:manufacturer;type:varchar(100)"`
		SerialNumber      string `json:"SerialNumber" gorm:"column:serialNumber;type:varchar(100)"`
		UUID              string `json:"UUID" gorm:"column:manufacturer;type:varchar(100)"`
		SystemProductName string `json:"SystemProductName" gorm:"column:manufacturer;type:varchar(100)"`
	}
	WorkInfo struct {
		Name         string `json:"Name"`
		HealthStatus string `json:"HealthStatus"` // 健康状态
		Product      string `json:"Product"`      // 厂商
		Vendor       string `json:"Vendor"`       // 型号
		Speed        string `json:"Speed"`        // 速率
		Units        string `json:"Units"`
		Size         int    `json:"Size"`
		Mac          string `json:"Mac"`
	}
	BaseboardInfo struct {
		Model        string `json:"Model"`
		SerialNumber string `json:"SerialNumber"`
		Manufacturer string `json:"Manufacturer"`
	}
	CpuInfo struct {
		SocketDesignation string `json:"SocketDesignation"`
		Model             string `json:"Model"` // 型号名
		CoreCount         byte   `json:"CoreCount"`
		ThreadCount       byte   `json:"ThreadCount"`
		CurrentSpeed      string `json:"CurrentSpeed"` // MHZ
		MaxSpeed          string `json:"MaxSpeed"`     // MHZ
		L1dCache          string `json:"L1dCache"`
		L1iCache          string `json:"L1iCache"`
		L2Cache           string `json:"L2Cache"`
		L3Cache           string `json:"L3Cache"`
	}
	DiskInfo struct {
		flag         string `json:"Flag"`
		Model        string `json:"Model"`
		SerialNumber string `json:"SerialNumber"`
		Size         string `json:"Size"`
		DiskName     string `json:"DiskName"` //硬盘名称
		Vendor       string `json:"Vendor"`   // 厂商
		DiskType     string `json:"DiskType"` // 硬盘类型
		DiskRate     string `json:"DiskRate"` // 使用率
	}

	GpuInfo struct {
		Id    string `json:"Id"`
		Model string `json:"Model"`
		Size  string `json:"Size"`
	}
	MemoryDeviceInfo struct {
		PartNumber        string `json:"PartNumber"`
		Size              uint16 `json:"Size"`
		TotalWidth        uint16 `json:"TotalWidth"`
		DataWidth         uint16 `json:"DataWidth"`
		FormFactor        string `json:"FormFactor"`
		DeviceSet         byte   `json:"DeviceSet"`
		DeviceLocator     string `json:"DeviceLocator"`
		BankLocator       string `json:"BankLocator"`
		MemoryType        string `json:"MemoryType"`
		TypeDetail        string `json:"TypeDetail"`
		Speed             uint16 `json:"Speed"`
		Manufacturer      string `json:"Manufacturer"`
		SerialNumber      string `json:"serialNumber"`
		AssetTag          string `json:"AssetTag"`
		Attributes        byte   `json:"Attributes"`
		ConfiguredVoltage uint16 `json:"ConfiguredVoltage"`
	}
	NicInfo struct {
		Model string `json:"Model"`
		Count int    `json:"Count"`
	}
	RaidInfo struct {
		Model string `json:"Model"`
		Count int    `json:"Count"`
	}
)

func (c SysInfoSlice) Value() (driver.Value, error) {
	b, err := json.Marshal(c)
	return string(b), err
}

func (c *SysInfoSlice) Scan(input interface{}) error {
	return json.Unmarshal(input.([]byte), c)
}

func (c BaseboardInfoSlice) Value() (driver.Value, error) {
	b, err := json.Marshal(c)
	return string(b), err
}

func (c *BaseboardInfoSlice) Scan(input interface{}) error {
	return json.Unmarshal(input.([]byte), c)
}

func (c CpuInfoSlice) Value() (driver.Value, error) {
	b, err := json.Marshal(c)
	return string(b), err
}

func (c *CpuInfoSlice) Scan(input interface{}) error {
	return json.Unmarshal(input.([]byte), c)
}

func (c DiskInfoSlice) Value() (driver.Value, error) {
	b, err := json.Marshal(c)
	return string(b), err
}

func (c *DiskInfoSlice) Scan(input interface{}) error {
	return json.Unmarshal(input.([]byte), c)
}

func (c WorkInfoSlice) Value() (driver.Value, error) {
	b, err := json.Marshal(c)
	return string(b), err
}

func (c *WorkInfoSlice) Scan(input interface{}) error {
	return json.Unmarshal(input.([]byte), c)
}

func (c GpuInfoSlice) Value() (driver.Value, error) {
	b, err := json.Marshal(c)
	return string(b), err
}

func (c *GpuInfoSlice) Scan(input interface{}) error {
	return json.Unmarshal(input.([]byte), c)
}

func (c MemoryInfoSlice) Value() (driver.Value, error) {
	b, err := json.Marshal(c)
	return string(b), err
}

func (c *MemoryInfoSlice) Scan(input interface{}) error {
	return json.Unmarshal(input.([]byte), c)
}

func (c NicInfoSlice) Value() (driver.Value, error) {
	b, err := json.Marshal(c)
	return string(b), err
}

func (c *NicInfoSlice) Scan(input interface{}) error {
	return json.Unmarshal(input.([]byte), c)
}

func (c RaidInfoSlice) Value() (driver.Value, error) {
	b, err := json.Marshal(c)
	return string(b), err
}

func (c *RaidInfoSlice) Scan(input interface{}) error {
	return json.Unmarshal(input.([]byte), c)
}

```

File path: /Users/mac/Desktop/woker_code/monitor/modules/server/service/server.go
```golang
package service

import (
	"context"
	"fmt"
	"math"
	"sort"
	"strconv"
	"strings"
	"time"

	"github.com/pkg/errors"

	alarmv1alpha "ezone.ksyun.com/ezone/luban/luban_api/alarmapis/alarm/v1alpha/gen"
	resource_serverv1alpha "ezone.ksyun.com/ezone/luban/luban_api/resourceapis/resource_server/v1alpha/gen"
	prom_client "ezone.ksyun.com/ezone/luban/monitor/common/client/prom"
	"ezone.ksyun.com/ezone/luban/monitor/common/promql_template/server"
	"ezone.ksyun.com/ezone/luban/monitor/common/tools"
	"ezone.ksyun.com/ezone/luban/monitor/common/types"
	"ezone.ksyun.com/ezone/luban/monitor/common/utils"
	"ezone.ksyun.com/ezone/luban/monitor/modules/server/dao"
	"ezone.ksyun.com/ezone/luban/monitor/modules/server/dto"
	"ezone.ksyun.com/ezone/luban/monitor/modules/server/model"
	"github.com/gin-gonic/gin"
	v1 "github.com/prometheus/client_golang/api/prometheus/v1"
	"k8s.io/klog/v2"
)

type PhysicalService struct {
	Store dao.ServerStore
}

func NewPhysicalService() *PhysicalService {
	return &PhysicalService{
		Store: *dao.NewServerStore(),
	}
}

func (s *PhysicalService) PhysicalOverviewAlert(ctx context.Context, par dto.PhysicalOverviewMonitorReq) (*dto.PhysicalOverviewAlertRsp, error) {

	alertLevels := []types.OverviewAlert{
		{Name: "紧急告警", Level: "p0", Kind: "error", Number: 0, Unit: "个"},
		{Name: "重要告警", Level: "p1", Kind: "warn", Number: 0, Unit: "个"},
		{Name: "次要告警", Level: "p2", Kind: "minor", Number: 0, Unit: "个"},
		{Name: "提醒告警", Level: "p3", Kind: "info", Number: 0, Unit: "个"},
	}

	alerts, err := s.Store.AlarmRpcClient.ListAlerts(ctx, &alarmv1alpha.ListAlertsRequest{
		PageNo:   -1,
		PageSize: -1,
		Region:   par.Region,
		Az:       par.Az,
		Status:   "firing",
	})
	if err != nil {
		return nil, errors.WithMessage(err, "rpc call AlarmRpcClient.ListAlerts err")
	}
	//概览数据拼装
	var alertSlots []types.BasicOverviewSlot

	for _, alert := range alertLevels {
		var alertSlotInfo types.BasicOverviewSlot
		alertSlotInfo.Info = types.BasicOverviewSlotInfo{
			Index:       0,
			Name:        alert.Level,
			Value:       utils.CountAlertsNum(alerts.Items, "physicalServer", alert.Level),
			UnitType:    types.TypeNumber,
			Unit:        "个",
			Kind:        alert.Kind,
			Prognosis:   0,
			Description: "",
		}
		alertSlots = append(alertSlots, alertSlotInfo)
	}

	return &dto.PhysicalOverviewAlertRsp{
		Alerts: alertSlots,
	}, nil

}

func (s *PhysicalService) PhysicalOverviewMonitor(ctx context.Context, par dto.PhysicalOverviewMonitorReq) (*dto.PhysicalOverviewMonitorRsp, error) {

	list, err := s.Store.ServiceRpcClient.PhysicalServerList(ctx, &resource_serverv1alpha.PhysicalHostListRequest{
		Region:   par.Region,
		Az:       par.Az,
		LabId:    par.LabId,
		PageNo:   1,
		PageSize: -1,
	})
	if err != nil && list.TotalCount == 0 {
		return nil, err
	}

	var (
		serverUp           int
		serverDown         int
		ourIpList          []string
		monitoringStatus   []types.BasicOverviewSlot
		hardwareMonitoring []types.BasicOverviewSlot
	)
	for _, server := range list.PhysicalServerHostList {
		ourIpList = append(ourIpList, server.OutbandIp)
		if server.MonitoringStatus == "up" {
			serverUp += 1
		} else {
			serverDown += 1
		}
	}

	statusList := []string{"监控中", "监控异常"}
	for _, name := range statusList {
		var monitoringStatusInfo types.BasicOverviewSlot
		value := 0
		if name == "监控中" {
			value = serverUp
		} else {
			value = serverDown
		}
		monitoringStatusInfo.Info = types.BasicOverviewSlotInfo{
			Index:     0,
			Name:      name,
			Value:     value,
			UnitType:  "types.TypeNumber",
			Unit:      "个",
			Prognosis: 0,
		}
		monitoringStatus = append(monitoringStatus, monitoringStatusInfo)
	}

	cpuFaultNum, _ := GetCPUFaultNum(s.Store, ctx, ourIpList)
	memFaultNum, _ := GetMemFaultNum(s.Store, ctx, ourIpList)
	diskFaultNum, _ := GetDiskFaultNum(s.Store, ctx, ourIpList)

	faultList := []string{"CPU故障数量", "内存故障数量", "硬盘故障数量"}

	for _, name := range faultList {
		var hardwareMonitoringInfo types.BasicOverviewSlot
		value := 0
		switch name {
		case "CPU故障数量":
			value = cpuFaultNum
		case "内存故障数量":
			value = memFaultNum
		case "硬盘故障数量":
			value = diskFaultNum
		}
		hardwareMonitoringInfo.Info = types.BasicOverviewSlotInfo{
			Index:     0,
			Name:      name,
			Value:     value,
			UnitType:  "types.TypeNumber",
			Unit:      "个",
			Prognosis: 0,
		}
		hardwareMonitoring = append(hardwareMonitoring, hardwareMonitoringInfo)
	}

	return &dto.PhysicalOverviewMonitorRsp{
		MonitoringStatus:   monitoringStatus,
		HardwareMonitoring: hardwareMonitoring,
	}, nil

}

func GetCPUFaultNum(s dao.ServerStore, ctx context.Context, ourIpList []string) (num int, err error) {
	//获取cpu故障数
	promQL, err := s.AlarmRpcClient.ListPromQLs(ctx, server.MultipleKeysTemplateMap[server.IpmiSensorState]([]*alarmv1alpha.Label{
		{
			Key:       "instance",
			Value:     strings.Join(ourIpList, "|"),
			Operation: "=~",
		},
		{
			Key:       "name",
			Value:     "^CPU.*State|^CPU.*Status",
			Operation: "=~",
		},
		{
			Key:       "type",
			Value:     "Processor",
			Operation: "=",
		},
	}))
	if err != nil {
		return 0, err
	}
	promQLStr := promQL.Items[0].RealPromql

	klog.Info("cpuPromQLStr ", promQLStr)

	//查Prometheus
	cpu, err := prom_client.VectorQuery(ctx, promQLStr)
	if err != nil {
		return 0, err
	}
	for _, v := range cpu {
		if math.IsNaN(float64(v.Value)) {
			v.Value = 0
		}
		if float64(v.Value) == 1 {
			num += 1
		}
	}
	return num, nil
}

func GetFaultNumMap(s dao.ServerStore, ctx context.Context, ourIpList []string, errType string) (map[string]int, error) {
	//获取cpu故障数
	var promQLStr string

	switch errType {
	case "cpu":
		promQL, err := s.AlarmRpcClient.ListPromQLs(ctx, server.MultipleKeysTemplateMap[server.IpmiSensorState]([]*alarmv1alpha.Label{
			{
				Key:       "instance",
				Value:     strings.Join(ourIpList, "|"),
				Operation: "=~",
			},
			{
				Key:       "name",
				Value:     "^CPU.*State|^CPU.*Status",
				Operation: "=~",
			},
			{
				Key:       "type",
				Value:     "Processor",
				Operation: "=",
			},
		}))
		if err != nil {
			return nil, err
		}
		promQLStr = promQL.Items[0].RealPromql
	case "mem":
		promQL, err := s.AlarmRpcClient.ListPromQLs(ctx, server.MultipleKeysTemplateMap[server.IpmiSensorState]([]*alarmv1alpha.Label{
			{
				Key:       "instance",
				Value:     strings.Join(ourIpList, "|"),
				Operation: "=~",
			},
			{
				Key:       "name",
				Value:     "Memory Usage",
				Operation: "!=",
			},
			{
				Key:       "type",
				Value:     "Memory",
				Operation: "=",
			},
		}))
		if err != nil {
			return nil, err
		}
		promQLStr = promQL.Items[0].RealPromql
	case "disk":
		promQL, err := s.AlarmRpcClient.ListPromQLs(ctx, server.MultipleKeysTemplateMap[server.IpmiSensorState]([]*alarmv1alpha.Label{
			{
				Key:       "instance",
				Value:     strings.Join(ourIpList, "|"),
				Operation: "=~",
			},
			{
				Key:       "type",
				Value:     "Drive Slot",
				Operation: "=",
			},
		}))
		if err != nil {
			return nil, err
		}
		promQLStr = promQL.Items[0].RealPromql
	}

	//查Prometheus
	promRes, err := prom_client.VectorQuery(ctx, promQLStr)
	if err != nil {
		return nil, err
	}

	res := make(map[string]int)
	for _, v := range promRes {
		if math.IsNaN(float64(v.Value)) {
			v.Value = 0
		}
		instance := string(v.Metric["instance"])
		if ins, ok := res[instance]; ok {
			if v.Value == 1 {
				res[instance] = ins + 1
			} else {
				res[instance] = ins
			}
		} else {
			res[instance] = int(v.Value)
		}

	}
	return res, nil
}

func GetUsageRayeMap(s dao.ServerStore, ctx context.Context, ips []string, errType string) (map[string]float64, error) {

	var promQLStr string
	switch errType {
	case "cpu":
		promQL, err := s.AlarmRpcClient.ListPromQLs(ctx, server.TemplateMap[server.CpuUsageRate](ips))
		if err != nil {
			return nil, err
		}
		promQLStr = promQL.Items[0].RealPromql
	case "mem":
		promQL, err := s.AlarmRpcClient.ListPromQLs(ctx, server.TemplateMap[server.MemUsageRate](ips))
		if err != nil {
			return nil, err
		}
		promQLStr = promQL.Items[0].RealPromql
	case "disk":
		promQL, err := s.AlarmRpcClient.ListPromQLs(ctx, server.TemplateMap[server.DiskUsageRate](ips))
		if err != nil {
			return nil, err
		}
		promQLStr = promQL.Items[0].RealPromql

	}
	//查Prometheus
	promRes, err := prom_client.VectorQuery(ctx, promQLStr)
	if err != nil {
		return nil, err
	}
	//
	res := make(map[string]float64)

	for _, v := range promRes {
		if math.IsNaN(float64(v.Value)) {
			v.Value = 0
		}
		hostname := string(v.Metric["hostname"])
		_, ok := res[hostname]
		if !ok {
			res[hostname] = tools.FormPercent(float64(v.Value))
		}
	}
	return res, nil
}

func GetMemFaultNum(s dao.ServerStore, ctx context.Context, ourIpList []string) (num int, err error) {
	//获取mem故障数
	promQL, err := s.AlarmRpcClient.ListPromQLs(ctx, server.MultipleKeysTemplateMap[server.IpmiSensorState]([]*alarmv1alpha.Label{
		{
			Key:       "instance",
			Value:     strings.Join(ourIpList, "|"),
			Operation: "=~",
		},
		{
			Key:       "name",
			Value:     "Memory Usage",
			Operation: "!=",
		},
		{
			Key:       "type",
			Value:     "Memory",
			Operation: "=",
		},
	}))
	if err != nil {
		return 0, err
	}
	promQLStr := promQL.Items[0].RealPromql

	klog.Info("memPromQLStr ", promQLStr)

	//查Prometheus
	cpu, err := prom_client.VectorQuery(ctx, promQLStr)
	if err != nil {
		return 0, err
	}
	for _, v := range cpu {
		if math.IsNaN(float64(v.Value)) {
			v.Value = 0
		}
		if float64(v.Value) == 1 {
			num += 1
		}
	}
	return num, nil
}

func GetDiskFaultNum(s dao.ServerStore, ctx context.Context, ourIpList []string) (num int, err error) {
	//获取disk故障数
	promQL, err := s.AlarmRpcClient.ListPromQLs(ctx, server.MultipleKeysTemplateMap[server.IpmiSensorState]([]*alarmv1alpha.Label{
		{
			Key:       "instance",
			Value:     strings.Join(ourIpList, "|"),
			Operation: "=~",
		},
		{
			Key:       "type",
			Value:     "Drive Slot",
			Operation: "=",
		},
	}))
	if err != nil {
		return 0, err
	}
	promQLStr := promQL.Items[0].RealPromql

	klog.Info("diskPromQLStr ", promQLStr)

	//查Prometheus
	cpu, err := prom_client.VectorQuery(ctx, promQLStr)
	if err != nil {
		return 0, err
	}
	for _, v := range cpu {
		if math.IsNaN(float64(v.Value)) {
			v.Value = 0
		}
		if float64(v.Value) == 1 {
			num += 1
		}
	}
	return num, nil
}

func (s *PhysicalService) PhysicalList(ctx context.Context, par dto.PhysicalListReq) (*dto.PhysicalListRsp, error) {

	//获取
	rpcServer, err := s.Store.ServiceRpcClient.PhysicalServerList(ctx, &resource_serverv1alpha.PhysicalHostListRequest{
		PageNo:           1,
		PageSize:         -1,
		Region:           par.Region,
		Az:               par.Az,
		LabId:            par.LabId,
		Query:            par.Query,
		MonitoringStatus: par.MonitoringStatus,
		Node:             par.NodeType,
		ResourcePoolType: par.ResourcePoolType,
		ResourcePoolName: par.ResourcePoolName,
	})
	if err != nil {
		return nil, err
	}

	var (
		hosts      []dto.PhysicalServer
		serverList []dto.PhysicalServer
		hostname   []string
		ips        []string
		outBandIp  []string
	)
	for _, v := range rpcServer.PhysicalServerHostList {

		host := dto.PhysicalServer{
			HostId:           int(v.HostId),
			HostName:         v.HostName,
			MonitoringStatus: v.MonitoringStatus,
			Node:             v.NodeType,
			ResourcePoolName: v.ResourcePoolName,
			ResourcePoolType: v.ResourcePoolType,
			Region:           v.Region,
			Az:               v.Az,
			Lab:              v.LabName,
			Sn:               v.DeviceSn,
			Ip:               v.ManageIp,
			OutBindIp:        v.OutbandIp,
			Tag:              v.Tag,
		}
		hostname = append(hostname, v.HostName)
		ips = append(ips, v.ManageIp+":9100")
		outBandIp = append(outBandIp, v.OutbandIp)
		hosts = append(hosts, host)
	}

	//获取服务器故障数
	cpuErrNum, _ := GetFaultNumMap(s.Store, ctx, outBandIp, "cpu")
	memErrNum, _ := GetFaultNumMap(s.Store, ctx, outBandIp, "mem")
	diskErrNum, _ := GetFaultNumMap(s.Store, ctx, outBandIp, "disk")

	//获取服务器告警数
	alerts, err := s.Store.AlarmRpcClient.ListAlerts(ctx, &alarmv1alpha.ListAlertsRequest{
		PageNo:          -1,
		PageSize:        -1,
		Status:          "firing",
		Region:          par.Region,
		ResourceType:    []string{"physicalResource"},
		ResourceSubType: []string{"physicalServer"},
	})
	if err != nil {
		return nil, errors.WithMessage(err, "rpc call AlarmRpcClient.ListAlerts err")
	}
	alertNum := utils.CountAlertsListNum(alerts.Items, "physicalServer")

	//获取服务器cpu mem disk 使用率
	cpuLoad, _ := GetUsageRayeMap(s.Store, ctx, ips, "cpu")
	memLoad, _ := GetUsageRayeMap(s.Store, ctx, ips, "mem")
	diskLoad, _ := GetUsageRayeMap(s.Store, ctx, ips, "disk")

	for _, h := range hosts {
		cpuErr := cpuErrNum[h.OutBindIp]
		memErr := memErrNum[h.OutBindIp]
		diskErr := diskErrNum[h.OutBindIp]

		serverInfo := dto.PhysicalServer{
			HostId:           h.HostId,
			HostName:         h.HostName,
			MonitoringStatus: h.MonitoringStatus,
			Node:             h.Node,
			ResourcePoolName: h.ResourcePoolName,
			ResourcePoolType: h.ResourcePoolType,
			Region:           h.Region,
			Az:               h.Az,
			Lab:              h.Lab,
			Sn:               h.Sn,
			Ip:               h.Ip,
			OutBindIp:        h.OutBindIp,
			CpuErrNum:        cpuErr,
			CpuLoad:          cpuLoad[h.HostName],
			MemErrNum:        memErr,
			MemLoad:          memLoad[h.HostName],
			DiskErrNum:       diskErr,
			DiskLoad:         diskLoad[h.HostName],
			AlertNumber:      alertNum[h.HostName],
			Tag:              h.Tag,
		}
		if par.CpuErrNum == "zero" && cpuErr > 0 { //筛选cpu故障数等于0的
			continue
		}
		if par.MemErrNum == "zero" && memErr > 0 { //筛选mem故障数等于0的
			continue
		}
		if par.DiskErrNum == "zero" && diskErr > 0 { //筛选硬盘故障数等于0的
			continue
		}
		if par.CpuErrNum == "nozero" && cpuErr == 0 { //筛选mem故障数大于0的
			continue
		}
		if par.MemErrNum == "nozero" && memErr == 0 { //筛选cpu故障数大于0的
			continue
		}
		if par.DiskErrNum == "nozero" && diskErr == 0 { //筛选硬盘故障数大于0的
			continue
		}
		serverList = append(serverList, serverInfo)
	}

	//order 排序
	if par.OrderCode != "" && par.OrderType != "" {
		results := utils.Bucket{}
		for i := 0; i < len(serverList); i++ {
			results.Slice = append(results.Slice, serverList[i])
		}
		time_by := func(a, b interface{}) bool {
			return true
		}
		switch par.OrderCode {
		case "CpuLoad":
			if par.OrderType != "" {
				switch par.OrderType {
				case "ASC":
					time_by = func(a, b interface{}) bool {
						return a.(dto.PhysicalServer).CpuLoad < b.(dto.PhysicalServer).CpuLoad
					}
				case "DESC":
					time_by = func(a, b interface{}) bool {
						return a.(dto.PhysicalServer).CpuLoad > b.(dto.PhysicalServer).CpuLoad
					}
				}
			}
		case "MemLoad":
			if par.OrderType != "" {
				switch par.OrderType {
				case "ASC":
					time_by = func(a, b interface{}) bool {
						return a.(dto.PhysicalServer).MemLoad < b.(dto.PhysicalServer).MemLoad
					}
				case "DESC":
					time_by = func(a, b interface{}) bool {
						return a.(dto.PhysicalServer).MemLoad > b.(dto.PhysicalServer).MemLoad
					}
				}
			}
		case "DiskLoad":
			if par.OrderType != "" {
				switch par.OrderType {
				case "ASC":
					time_by = func(a, b interface{}) bool {
						return a.(dto.PhysicalServer).DiskLoad < b.(dto.PhysicalServer).DiskLoad
					}
				case "DESC":
					time_by = func(a, b interface{}) bool {
						return a.(dto.PhysicalServer).DiskLoad > b.(dto.PhysicalServer).DiskLoad
					}
				}
			}
		}
		results.By = time_by
		sort.Sort(results)
		for i := 0; i < len(results.Slice); i++ {
			serverList[i] = results.Slice[i].(dto.PhysicalServer)
		}
	}

	//分页
	low := (par.PageNo - 1) * par.PageSize
	if low > len(serverList) {
		klog.Info("PageSize is too large")
	}

	hight := low + par.PageSize
	if hight > len(serverList) {
		hight = len(serverList)
	}

	var results dto.PhysicalListRsp
	results.PageSize = par.PageSize
	results.PageNo = par.PageNo
	results.TotalCount = int64(len(serverList))
	results.PhysicalServerHostList = serverList[low:hight]

	return &results, err
}

func (s *PhysicalService) PhysicalOverviewTop(ctx context.Context, par dto.PhysicalOverviewTopReq) (*dto.PhysicalOverviewTopRsp, error) {
	res := dto.PhysicalOverviewTopRsp{}

	list, err := s.Store.ServiceRpcClient.PhysicalServerList(ctx, &resource_serverv1alpha.PhysicalHostListRequest{
		Region:   par.Region,
		Az:       par.Az,
		LabId:    par.LabId,
		PageNo:   1,
		PageSize: -1,
	})
	if err != nil {
		return &res, nil
	}

	var ipList []string
	var hostNameList []string
	ipSnMap := make(map[string]string, len(list.PhysicalServerHostList))
	hostIpMap := make(map[string][]string, len(list.PhysicalServerHostList))
	for _, v := range list.PhysicalServerHostList {
		ipList = append(ipList, v.ManageIp+":9100")
		hostNameList = append(hostNameList, v.HostName)
		ipSnMap[v.ManageIp+":9100"] = v.DeviceSn
		hostIpMap[v.HostName] = []string{v.ManageIp, v.DeviceSn}
	}

	ips := strings.Join(ipList, "|")
	hostNames := strings.Join(hostNameList, "|")
	t := tools.FormatTime(float64(par.End/1000 - par.Start/1000))

	var tops []types.BasicOverviewSlot

	for i := 0; i < len(par.MetricName); i++ {
		switch par.MetricName[i] {
		case "CpuRate":
			psql := server.GetCpuRateTopByHostName(par.TopK, hostNames, t)
			result, err := prom_client.VectorQuery(ctx, psql)
			if err != nil {
				return nil, err
			}
			info := types.BasicOverviewSlotInfo{
				Name:     "cpuRate",
				UnitType: types.TypePercent,
				Unit:     "%",
			}
			var val []types.BasicOverviewSlotValue
			for _, v := range result {
				hostName := string(v.Metric["hostname"])
				sn := ""
				ip := ""
				if ipSn, ok := hostIpMap[hostName]; ok {
					ip = ipSn[0] + ":9100"
					sn = ipSn[1]
				}
				vv := types.BasicOverviewSlotValue{
					Name:     hostName,
					SubName:  sn,
					Code:     ip,
					Value:    strconv.FormatFloat(float64(v.Value), 'f', 2, 64),
					Unit:     "%",
					UnitType: types.TypePercent,
				}
				val = append(val, vv)
			}
			value := types.BasicOverviewSlot{
				Info:   info,
				Values: val,
			}
			tops = append(tops, value)
		case "MemoryRate":
			psql := server.GetMemoryRateTopK(par.TopK, ips, t)
			result, err := prom_client.VectorQuery(ctx, psql)
			if err != nil {
				return nil, err
			}
			info := types.BasicOverviewSlotInfo{
				Name:     "MemoryRate",
				UnitType: types.TypePercent,
				Unit:     "%",
			}
			var val []types.BasicOverviewSlotValue
			for _, v := range result {
				ip := string(v.Metric["instance"])
				hostName := string(v.Metric["hostname"])
				sn := ""
				if deviceSn, ok := ipSnMap[ip]; ok {
					sn = deviceSn
				}
				vv := types.BasicOverviewSlotValue{
					Name:     hostName,
					SubName:  sn,
					Code:     ip,
					Value:    strconv.FormatFloat(float64(v.Value), 'f', 2, 64),
					Unit:     "%",
					UnitType: types.TypePercent,
				}
				val = append(val, vv)
			}
			value := types.BasicOverviewSlot{
				Info:   info,
				Values: val,
			}
			tops = append(tops, value)
		case "NetIn":
			psql := server.GetNetworkReceiveRateTopK(par.TopK, ips, t)
			result, err := prom_client.VectorQuery(ctx, psql)
			if err != nil {
				return nil, err
			}
			info := types.BasicOverviewSlotInfo{
				Name:     "NetIn",
				UnitType: types.TypeStorage,
				Unit:     "GB",
			}
			var val []types.BasicOverviewSlotValue
			for _, v := range result {
				ip := string(v.Metric["instance"])
				hostName := string(v.Metric["hostname"])
				sn := ""
				if deviceSn, ok := ipSnMap[ip]; ok {
					sn = deviceSn
				}
				vv := types.BasicOverviewSlotValue{
					Name:     hostName,
					SubName:  sn,
					Code:     ip,
					Value:    strconv.FormatFloat(float64(v.Value), 'f', 2, 64),
					UnitType: types.TypeStorage,
					Unit:     "B",
				}
				val = append(val, vv)
			}
			value := types.BasicOverviewSlot{
				Info:   info,
				Values: val,
			}
			tops = append(tops, value)
		case "NetOut":
			psql := server.GetNetworkTransmitRateTopK(par.TopK, ips, t)
			result, err := prom_client.VectorQuery(ctx, psql)
			if err != nil {
				return nil, err
			}
			info := types.BasicOverviewSlotInfo{
				Name:     "NetOut",
				UnitType: types.TypeStorage,
				Unit:     "B",
			}
			var val []types.BasicOverviewSlotValue
			for _, v := range result {
				ip := string(v.Metric["instance"])
				hostName := string(v.Metric["hostname"])
				sn := ""
				if deviceSn, ok := ipSnMap[ip]; ok {
					sn = deviceSn
				}
				vv := types.BasicOverviewSlotValue{
					Name:     hostName,
					SubName:  sn,
					Code:     ip,
					Value:    strconv.FormatFloat(float64(v.Value), 'f', 2, 64),
					UnitType: types.TypeStorage,
					Unit:     "B",
				}
				val = append(val, vv)
			}
			value := types.BasicOverviewSlot{
				Info:   info,
				Values: val,
			}
			tops = append(tops, value)
		}
	}

	return &dto.PhysicalOverviewTopRsp{
		Tops: tops,
	}, nil
}

func (s *PhysicalService) PhysicalDetailsOverview(ctx context.Context, par dto.PhysicalDetailsOverviewReq) (*dto.PhysicalDetailsOverviewRsp, error) {
	res := dto.PhysicalDetailsOverviewRsp{}
	//获取服务器详情
	details, err := s.Store.ServiceRpcClient.PhysicalServerDetails(ctx, &resource_serverv1alpha.DescribePhysicalHostRequest{
		DeviceSn: par.DeviceSn,
	})
	if err != nil {
		return &res, nil
	}

	var (
		detailsOverview []types.BasicOverviewSlot
		cpuLoad         float64
		memLoad         float64
		diskLoad        float64
		netIn           float64
		netOut          float64
	)

	//cpu使用率
	cpuSp, err := s.Store.AlarmRpcClient.ListPromQLs(ctx, server.TemplateMap[server.CpuUsageRate]([]string{details.ManageIP + ":9100"}))
	if err != nil {
		return nil, err
	}
	cpuPromQL := cpuSp.Items[0].RealPromql
	cpu, err := prom_client.VectorQuery(ctx, cpuPromQL)
	if err != nil {
		klog.Info(err)
	}
	for _, v := range cpu {
		if math.IsNaN(float64(v.Value)) {
			v.Value = 0
		}
		cpuLoad = tools.FormPercent(float64(v.Value))
	}
	cpuRes := types.BasicOverviewSlot{
		Info: types.BasicOverviewSlotInfo{
			Name:     "CpuUsage",
			Value:    cpuLoad,
			Unit:     "%",
			UnitType: types.TypePercent,
		},
	}

	//mem使用率
	memSp, err := s.Store.AlarmRpcClient.ListPromQLs(ctx, server.TemplateMap[server.MemUsageRate]([]string{details.ManageIP + ":9100"}))
	if err != nil {
		return nil, err
	}
	memPromQL := memSp.Items[0].RealPromql
	fmt.Println("memPromQL", memPromQL)
	mem, err := prom_client.VectorQuery(ctx, memPromQL)
	if err != nil {
		klog.Info(err)
	}
	for _, v := range mem {
		if math.IsNaN(float64(v.Value)) {
			v.Value = 0
		}
		memLoad = tools.FormPercent(float64(v.Value))
	}
	memRes := types.BasicOverviewSlot{
		Info: types.BasicOverviewSlotInfo{
			Name:     "MemoryUsage",
			Value:    memLoad,
			Unit:     "%",
			UnitType: types.TypePercent,
		},
	}

	//磁盘使用率
	diskSp, err := s.Store.AlarmRpcClient.ListPromQLs(ctx, server.TemplateMap[server.DiskUsageRate]([]string{details.ManageIP + ":9100"}))
	if err != nil {
		return nil, err
	}
	diskPromQL := diskSp.Items[0].RealPromql
	fmt.Println("diskPromQL", diskPromQL)
	disk, err := prom_client.VectorQuery(ctx, diskPromQL)
	if err != nil {
		klog.Info(err)
	}

	for _, v := range disk {
		if math.IsNaN(float64(v.Value)) {
			v.Value = 0
		}
		diskLoad = tools.FormPercent(float64(v.Value))
	}
	diskRes := types.BasicOverviewSlot{
		Info: types.BasicOverviewSlotInfo{
			Name:     "DiskUsage",
			Value:    diskLoad,
			Unit:     "%",
			UnitType: types.TypePercent,
		},
	}

	//网卡入口流量
	netInSp, err := s.Store.AlarmRpcClient.ListPromQLs(ctx, server.TemplateMap[server.NetworkReceive24h]([]string{details.ManageIP + ":9100"}))
	if err != nil {
		return nil, err
	}
	netIns, err := prom_client.VectorQuery(ctx, netInSp.Items[0].RealPromql)
	if err != nil {
		klog.Info(err)
	}
	for _, v := range netIns {
		if math.IsNaN(float64(v.Value)) {
			v.Value = 0
		}
		netIn = tools.FormPercent(float64(v.Value))
	}
	netInRes := types.BasicOverviewSlot{
		Info: types.BasicOverviewSlotInfo{
			Name:     "NetIn",
			Value:    netIn,
			Unit:     "B",
			UnitType: types.TypeStorage,
		},
	}

	//网卡出口流量
	netOutSp, err := s.Store.AlarmRpcClient.ListPromQLs(ctx, server.TemplateMap[server.NetworkReceive24h]([]string{details.ManageIP + ":9100"}))
	if err != nil {
		return nil, err
	}
	netOuts, err := prom_client.VectorQuery(ctx, netOutSp.Items[0].RealPromql)
	if err != nil {
		klog.Info(err)
	}

	for _, v := range netOuts {
		if math.IsNaN(float64(v.Value)) {
			v.Value = 0
		}
		netOut = tools.FormPercent(float64(v.Value))
	}
	netOutRes := types.BasicOverviewSlot{
		Info: types.BasicOverviewSlotInfo{
			Name:     "NetOut",
			Value:    netOut,
			Unit:     "B",
			UnitType: types.TypeStorage,
		},
	}
	//磁盘剩余容量
	diskAvailSp, err := s.Store.AlarmRpcClient.ListPromQLs(ctx, server.TemplateMap[server.DiskAvailEvery]([]string{details.ManageIP + ":9100"}))
	if err != nil {
		return nil, err
	}
	results, err := prom_client.VectorQuery(ctx, diskAvailSp.Items[0].RealPromql)
	if err != nil {
		klog.Info(err)
	}
	diskAvailRes := types.BasicOverviewSlot{
		Info: types.BasicOverviewSlotInfo{
			Name: "Disk",
		},
	}

	for _, v := range results {
		fstype, ok := v.Metric["fstype"]
		if !ok {
			continue
		}
		device, ok := v.Metric["device"]
		if !ok {
			continue
		}
		vv := types.BasicOverviewSlotValue{
			Name:  string(device),
			Code:  string(fstype),
			Value: tools.FormPercent(float64(v.Value)),
		}
		diskAvailRes.Values = append(diskAvailRes.Values, vv)
	}

	detailsOverview = append(detailsOverview, cpuRes, memRes, diskRes, netInRes, netOutRes, diskAvailRes)

	return &dto.PhysicalDetailsOverviewRsp{
		DetailsOverview: detailsOverview,
	}, nil

}

func (s *PhysicalService) PhysicalWorkList(ctx *gin.Context, par dto.PhysicalWorkListReq) ([]string, error) {

	//磁盘使用率
	workSp, err := s.Store.AlarmRpcClient.ListPromQLs(ctx, server.TemplateMap[server.NetworkCardList]([]string{par.Ip + ":9100"}))
	if err != nil {
		return nil, err
	}
	workPromQL := workSp.Items[0].RealPromql
	fmt.Println("workPromQL", workPromQL)
	res, err := prom_client.VectorQuery(ctx, workPromQL)
	if err != nil {
		klog.Info(err)
	}
	var names []string
	for _, v := range res {
		names = append(names, string(v.Metric["device"]))
	}

	return names, nil
}

var MetricWorkMap = map[string]struct{}{
	//network
	"Receive":     struct{}{},
	"Transmit":    struct{}{},
	"ErrDropIn":   struct{}{},
	"ErrDropOut":  struct{}{},
	"LoseDropIn":  struct{}{},
	"LoseDropOut": struct{}{},
}

func (s *PhysicalService) PhysicalDetailsLine(ctx context.Context, par dto.PhysicalDetailsLineReq) (*dto.PhysicalDetailsOverviewLineRsp, error) {

	start := par.Start / 1e3
	end := par.End / 1e3
	step := tools.TimeToStepForInt(end - start)
	ip := par.Ip + ":9100"

	var lines []types.BasicOverviewSlot

	for i := 0; i < len(par.MetricName); i++ {
		if _, ok := MetricWorkMap[par.MetricName[i]]; ok { // 网络监控验证参数
			if len(par.WorkName) <= 0 {
				return nil, fmt.Errorf("workName Parameter not passed")
			}
		}
		switch par.MetricName[i] {
		case "CpuMode": //cpu负载
			cpuMode, err := s.Store.AlarmRpcClient.ListPromQLs(ctx, server.TemplateMap[server.CpuMode]([]string{ip}))
			if err != nil {
				return nil, err
			}
			realPromql := cpuMode.Items[0].RealPromql
			fmt.Println("cpuModeSql", realPromql)
			matrix, err := prom_client.MatrixQuery(ctx, realPromql, v1.Range{
				Start: time.Unix(start, 0),
				End:   time.Unix(end, 0),
				Step:  time.Duration(step) * time.Second,
			})
			if err != nil {
				fmt.Printf("Error querying Prometheus: %v\n", err)
			}
			for _, m := range matrix {
				line := types.BasicOverviewSlot{}
				var avg []float64
				for _, p := range m.Values {
					timeStamp := p.Timestamp
					value := p.Value
					line.Values = append(line.Values, types.BasicOverviewSlotValue{
						Name:        timeStamp.String(),
						Value:       value,
						Unit:        "%",
						UnitType:    "",
						Kind:        "",
						Description: "",
					})
					avg = append(avg, float64(value))
				}
				current := m.Values[len(m.Values)-1].Value
				line.Info = types.BasicOverviewSlotInfo{
					Index:       0,
					Name:        string(m.Metric["mode"]),
					Value:       current,
					Avg:         tools.GetAvg(avg),
					UnitType:    "",
					Unit:        "%",
					Kind:        "",
					Prognosis:   0, //预测值，values的下标，0则无预测值
					Description: "",
				}
				lines = append(lines, line)
			}

		case "CpuAvgMode": //cpu平均负载
			cpuAvgMode1, err := s.Store.AlarmRpcClient.ListPromQLs(ctx, server.TemplateMap[server.CpuNodeLoad1]([]string{ip}))
			if err != nil {
				return nil, err
			}
			realPromql := cpuAvgMode1.Items[0].RealPromql
			line, _ := GetBasicOverviewSlot(ctx, realPromql, "node_load", start, end, step, true, false, false)
			lines = append(lines, line)

			cpuAvgMode5, err := s.Store.AlarmRpcClient.ListPromQLs(ctx, server.TemplateMap[server.CpuNodeLoad5]([]string{ip}))
			if err != nil {
				return nil, err
			}
			realPromql5 := cpuAvgMode5.Items[0].RealPromql
			line5, _ := GetBasicOverviewSlot(ctx, realPromql5, "node_load", start, end, step, true, false, false)
			lines = append(lines, line5)

			cpuAvgMode15, err := s.Store.AlarmRpcClient.ListPromQLs(ctx, server.TemplateMap[server.CpuNodeLoad15]([]string{ip}))
			if err != nil {
				return nil, err
			}
			realPromql15 := cpuAvgMode15.Items[0].RealPromql
			line15, _ := GetBasicOverviewSlot(ctx, realPromql15, "node_load", start, end, step, true, false, false)
			lines = append(lines, line15)

		case "MemoryCapacity": //
			//free
			free, err := s.Store.AlarmRpcClient.ListPromQLs(ctx, server.TemplateMap[server.NodeMemoryFree]([]string{ip}))
			if err != nil {
				return nil, err
			}
			freeRealPromql := free.Items[0].RealPromql
			freeLine, _ := GetBasicOverviewSlot(ctx, freeRealPromql, "Free", start, end, step, false, false, false)
			lines = append(lines, freeLine)

			//total
			total, err := s.Store.AlarmRpcClient.ListPromQLs(ctx, server.TemplateMap[server.NodeMemoryTotal]([]string{ip}))
			if err != nil {
				return nil, err
			}
			totalRealPromql := total.Items[0].RealPromql
			totalLine, _ := GetBasicOverviewSlot(ctx, totalRealPromql, "Total", start, end, step, false, false, false)
			lines = append(lines, totalLine)

			//available
			available, err := s.Store.AlarmRpcClient.ListPromQLs(ctx, server.TemplateMap[server.NodeMemoryAvailable]([]string{ip}))
			if err != nil {
				return nil, err
			}
			availableRealPromql := available.Items[0].RealPromql
			availableLine, _ := GetBasicOverviewSlot(ctx, availableRealPromql, "Available", start, end, step, false, false, false)
			lines = append(lines, availableLine)

		case "NetworkInOut": //网络流量(流入/流入)
			//网络流量流入
			receive, err := s.Store.AlarmRpcClient.ListPromQLs(ctx, server.MultipleKeysTemplateMap[server.NetworkReceiveBytes]([]*alarmv1alpha.Label{
				{
					Key:       "instance",
					Value:     ip,
					Operation: "=~",
				}, {
					Key:       "device",
					Value:     par.WorkName,
					Operation: "=",
				},
			}))
			if err != nil {
				return nil, err
			}
			receivePromql := receive.Items[0].RealPromql
			fmt.Println("receivePromql", receivePromql)
			receiveLine, _ := GetBasicOverviewSlot(ctx, receivePromql, "network_receive_bytes", start, end, step, false, true, true)
			lines = append(lines, receiveLine)
			//网络流量流出
			transmit, err := s.Store.AlarmRpcClient.ListPromQLs(ctx, server.MultipleKeysTemplateMap[server.NetworkTransmitBytes]([]*alarmv1alpha.Label{
				{
					Key:       "instance",
					Value:     ip,
					Operation: "=~",
				}, {
					Key:       "device",
					Value:     par.WorkName,
					Operation: "=",
				},
			}))
			if err != nil {
				return nil, err
			}
			transmitPromql := transmit.Items[0].RealPromql
			fmt.Println("transmitPromql", transmitPromql)
			transmitLine, _ := GetBasicOverviewSlot(ctx, transmitPromql, "network_transmit_bytes", start, end, step, false, true, true)
			lines = append(lines, transmitLine)

		case "ErrDropInOut": //网络误包(流入/流出)
			//网络丢包流入
			errIn, err := s.Store.AlarmRpcClient.ListPromQLs(ctx, server.MultipleKeysTemplateMap[server.NetworkReceiveErrs]([]*alarmv1alpha.Label{
				{
					Key:       "instance",
					Value:     ip,
					Operation: "=~",
				}, {
					Key:       "device",
					Value:     par.WorkName,
					Operation: "=",
				},
			}))
			if err != nil {
				return nil, err
			}
			errInPromql := errIn.Items[0].RealPromql
			fmt.Println("errInPromql", errInPromql)
			errInLine, _ := GetBasicOverviewSlot(ctx, errInPromql, "network_receive_errs", start, end, step, false, true, true)
			lines = append(lines, errInLine)

			//网络丢包流出
			errOut, err := s.Store.AlarmRpcClient.ListPromQLs(ctx, server.MultipleKeysTemplateMap[server.NetworkTransmitErrs]([]*alarmv1alpha.Label{
				{
					Key:       "instance",
					Value:     ip,
					Operation: "=~",
				}, {
					Key:       "device",
					Value:     par.WorkName,
					Operation: "=",
				},
			}))
			if err != nil {
				return nil, err
			}
			errOutPromql := errOut.Items[0].RealPromql
			fmt.Println("errOutPromql", errOutPromql)
			transmitLine, _ := GetBasicOverviewSlot(ctx, errOutPromql, "network_transmit_errs", start, end, step, false, true, true)
			lines = append(lines, transmitLine)

		case "LoseDropInOut":
			//网络丢包流入
			dropIn, err := s.Store.AlarmRpcClient.ListPromQLs(ctx, server.MultipleKeysTemplateMap[server.NetworkReceiveDrop]([]*alarmv1alpha.Label{
				{
					Key:       "instance",
					Value:     ip,
					Operation: "=~",
				}, {
					Key:       "device",
					Value:     par.WorkName,
					Operation: "=",
				},
			}))
			if err != nil {
				return nil, err
			}
			dropInPromql := dropIn.Items[0].RealPromql
			fmt.Println("dropInPromql", dropInPromql)
			dropInLine, _ := GetBasicOverviewSlot(ctx, dropInPromql, "network_receive_drop", start, end, step, false, true, true)
			lines = append(lines, dropInLine)

			//网络丢包流出
			dropOut, err := s.Store.AlarmRpcClient.ListPromQLs(ctx, server.MultipleKeysTemplateMap[server.NetworkTransmitDrop]([]*alarmv1alpha.Label{
				{
					Key:       "instance",
					Value:     ip,
					Operation: "=~",
				}, {
					Key:       "device",
					Value:     par.WorkName,
					Operation: "=",
				},
			}))
			if err != nil {
				return nil, err
			}
			dropOutPromql := dropOut.Items[0].RealPromql
			fmt.Println("dropOutPromql", dropOutPromql)
			transmitLine, _ := GetBasicOverviewSlot(ctx, dropOutPromql, "network_transmit_drop", start, end, step, false, true, true)
			lines = append(lines, transmitLine)

		case "DiskAvailBytes": //磁盘剩余容量
			diskAvailSp, err := s.Store.AlarmRpcClient.ListPromQLs(ctx, server.TemplateMap[server.DiskAvailEvery]([]string{ip}))
			if err != nil {
				return nil, err
			}
			diskAvailPromql := diskAvailSp.Items[0].RealPromql
			transmitLine, _ := GetBasicOverviewSlot(ctx, diskAvailPromql, "server_disk_avail_every", start, end, step, false, false, false)
			lines = append(lines, transmitLine)

		case "DiskReadWrite": //磁盘读写带宽
			var readOther []float64
			var writeOther []float64
			//磁盘读带宽
			read, err := s.Store.AlarmRpcClient.ListPromQLs(ctx, server.TemplateMap[server.DiskReadBytes]([]string{ip}))
			if err != nil {
				return nil, err
			}
			readPromql := read.Items[0].RealPromql
			fmt.Println("readPromql", readPromql)
			readMatrix, err := prom_client.MatrixQuery(ctx, readPromql, v1.Range{
				Start: time.Unix(start, 0),
				End:   time.Unix(end, 0),
				Step:  time.Duration(step) * time.Second,
			})
			if err != nil {
				fmt.Printf("Error querying Prometheus: %v\n", err)
			}
			for _, m := range readMatrix {
				readLine := types.BasicOverviewSlot{}
				for _, p := range m.Values {
					timeStamp := p.Timestamp
					value := p.Value
					readLine.Values = append(readLine.Values, types.BasicOverviewSlotValue{
						Name:        timeStamp.String(),
						Value:       value,
						Kind:        "",
						Description: "",
						Unit:        "b/s",
						UnitType:    types.TypeNumber,
					})
					readOther = append(readOther, float64(value))
				}
				current := m.Values[len(m.Values)-1].Value
				readLine.Info = types.BasicOverviewSlotInfo{
					Index:     0,
					Name:      "Read:" + string(m.Metric["device"]),
					Min:       tools.GetMin(writeOther),
					Max:       tools.GetMin(writeOther),
					Value:     current,
					Prognosis: 0, //预测值，values的下标，0则无预测值
					Unit:      "b/s",
					UnitType:  types.TypeNumber,
				}
				lines = append(lines, readLine)
			}
			//磁盘写带宽
			write, err := s.Store.AlarmRpcClient.ListPromQLs(ctx, server.TemplateMap[server.DiskReadBytes]([]string{ip}))
			if err != nil {
				return nil, err
			}
			writePromql := write.Items[0].RealPromql
			fmt.Println("writePromql", writePromql)
			writeMatrix, err := prom_client.MatrixQuery(ctx, writePromql, v1.Range{
				Start: time.Unix(start, 0),
				End:   time.Unix(end, 0),
				Step:  time.Duration(step) * time.Second,
			})
			if err != nil {
				fmt.Printf("Error querying Prometheus: %v\n", err)
			}
			for _, m := range writeMatrix {
				writeLine := types.BasicOverviewSlot{}
				for _, p := range m.Values {
					timeStamp := p.Timestamp
					value := p.Value
					writeLine.Values = append(writeLine.Values, types.BasicOverviewSlotValue{
						Name:        timeStamp.String(),
						Value:       value,
						Kind:        "",
						Description: "",
						Unit:        "b/s",
						UnitType:    types.TypeNumber,
					})
					writeOther = append(writeOther, float64(value))
				}
				current := m.Values[len(m.Values)-1].Value
				writeLine.Info = types.BasicOverviewSlotInfo{
					Index:     0,
					Name:      "Write:" + string(m.Metric["device"]),
					Min:       tools.GetMin(writeOther),
					Max:       tools.GetMin(writeOther),
					Value:     current,
					Prognosis: 0, //预测值，values的下标，0则无预测值
					Unit:      "b/s",
					UnitType:  types.TypeNumber,
				}
				lines = append(lines, writeLine)
			}

		case "DiskReadWriteIo": // 磁盘io
			var readOther []float64
			var writeOther []float64
			//磁盘读io
			read, err := s.Store.AlarmRpcClient.ListPromQLs(ctx, server.TemplateMap[server.DiskReadIo]([]string{ip}))
			if err != nil {
				return nil, err
			}
			readPromql := read.Items[0].RealPromql
			fmt.Println("readPromql", readPromql)
			readMatrix, err := prom_client.MatrixQuery(ctx, readPromql, v1.Range{
				Start: time.Unix(start, 0),
				End:   time.Unix(end, 0),
				Step:  time.Duration(step) * time.Second,
			})
			if err != nil {
				fmt.Printf("Error querying Prometheus: %v\n", err)
			}

			for _, m := range readMatrix {
				readLine := types.BasicOverviewSlot{}
				for _, p := range m.Values {
					timeStamp := p.Timestamp
					value := p.Value
					readLine.Values = append(readLine.Values, types.BasicOverviewSlotValue{
						Name:        timeStamp.String(),
						Value:       value,
						Kind:        "",
						Description: "",
						Unit:        "次秒s",
						UnitType:    types.TypeNumber,
					})
					readOther = append(readOther, float64(value))
				}
				current := m.Values[len(m.Values)-1].Value
				readLine.Info = types.BasicOverviewSlotInfo{
					Index:     0,
					Name:      "Read:" + string(m.Metric["device"]),
					Min:       tools.GetMin(readOther),
					Max:       tools.GetMax(readOther),
					Value:     current,
					Prognosis: 0, //预测值，values的下标，0则无预测值
					Unit:      "次秒s",
					UnitType:  types.TypeNumber,
				}
				lines = append(lines, readLine)
			}
			//磁盘写io
			write, err := s.Store.AlarmRpcClient.ListPromQLs(ctx, server.TemplateMap[server.DiskWriteIo]([]string{ip}))
			if err != nil {
				return nil, err
			}
			writePromql := write.Items[0].RealPromql
			fmt.Println("writePromql", writePromql)
			writeMatrix, err := prom_client.MatrixQuery(ctx, writePromql, v1.Range{
				Start: time.Unix(start, 0),
				End:   time.Unix(end, 0),
				Step:  time.Duration(step) * time.Second,
			})
			if err != nil {
				fmt.Printf("Error querying Prometheus: %v\n", err)
			}
			for _, m := range writeMatrix {
				writeLine := types.BasicOverviewSlot{}
				for _, p := range m.Values {
					timeStamp := p.Timestamp
					value := p.Value
					writeLine.Values = append(writeLine.Values, types.BasicOverviewSlotValue{
						Name:        timeStamp.String(),
						Value:       value,
						Kind:        "",
						Description: "",
						Unit:        "次秒s",
						UnitType:    types.TypeNumber,
					})
					writeOther = append(writeOther, float64(value))
				}
				current := m.Values[len(m.Values)-1].Value
				writeLine.Info = types.BasicOverviewSlotInfo{
					Index:     0,
					Name:      "Write:" + string(m.Metric["device"]),
					Min:       tools.GetMin(writeOther),
					Max:       tools.GetMin(writeOther),
					Value:     current,
					Prognosis: 0, //预测值，values的下标，0则无预测值
					Unit:      "次秒s",
					UnitType:  types.TypeNumber,
				}
				lines = append(lines, writeLine)
			}

		}

	}

	return &dto.PhysicalDetailsOverviewLineRsp{
		Lines: lines,
	}, nil

}

func GetBasicOverviewSlot(ctx context.Context, realPromql, infoName string, start, end int64, step int, isAvg, isMax, isMin bool) (res types.BasicOverviewSlot, err error) {

	matrix, err := prom_client.MatrixQuery(ctx, realPromql, v1.Range{
		Start: time.Unix(start, 0),
		End:   time.Unix(end, 0),
		Step:  time.Duration(step) * time.Second,
	})
	if err != nil {
		fmt.Printf("Error querying Prometheus: %v\n", err)
	}

	for _, m := range matrix {
		var (
			metricName string
			unit       string
			unitType   string
			other      []float64
		)

		switch infoName {
		case "node_load": //cup平均负载
			metricName = string(m.Metric["__name__"])
			unit = "%"
			unitType = ""
		case "Free": //
			metricName = "Free"
			unit = "B"
			unitType = types.ParseUnitTypeByUnit(unit)
		case "Total":
			metricName = "Total"
			unit = "B"
			unitType = types.ParseUnitTypeByUnit(unit)
		case "Available":
			metricName = "Available"
			unit = "B"
			unitType = types.ParseUnitTypeByUnit(unit)
		case "network_receive_bytes":
			metricName = "In:" + string(m.Metric["device"])
			unit = "bps"
			unitType = types.ParseUnitTypeByUnit(unit)
		case "network_transmit_bytes":
			metricName = "Out:" + string(m.Metric["device"])
			unit = "bps"
			unitType = types.ParseUnitTypeByUnit(unit)
		case "network_receive_errs":
			metricName = "Err/Drop In:" + string(m.Metric["device"])
			unit = "p/s"
			unitType = types.TypeNumber
		case "network_transmit_errs":
			metricName = "Err/Drop Out:" + string(m.Metric["device"])
			unit = "p/s"
			unitType = types.TypeNumber
		case "network_receive_drop":
			metricName = "Lose/Drop In:" + string(m.Metric["device"])
			unit = "p/s"
			unitType = types.TypeNumber
		case "network_transmit_drop":
			metricName = "Lose/Drop Out:" + string(m.Metric["device"])
			unit = "p/s"
			unitType = types.TypeNumber
		case "server_disk_avail_every":
			metricName = string(m.Metric["mountpoint"])
			unit = "B"
			unitType = types.ParseUnitTypeByUnit(unit)
		}

		for _, p := range m.Values {
			timeStamp := p.Timestamp
			value := p.Value
			res.Values = append(res.Values, types.BasicOverviewSlotValue{
				Name:     timeStamp.String(),
				Value:    value,
				Unit:     unit,
				UnitType: unitType,
			})
			other = append(other, float64(value))
		}

		current := m.Values[len(m.Values)-1].Value
		res.Info = types.BasicOverviewSlotInfo{
			Index:       0,
			Name:        metricName,
			Value:       current,
			Unit:        unit,
			UnitType:    unitType,
			Kind:        "",
			Prognosis:   0, //预测值，values的下标，0则无预测值
			Description: "",
		}
		if isAvg == true {
			res.Info.Avg = tools.GetAvg(other)
		}
		if isMax == true {
			res.Info.Max = tools.GetMax(other)
		}
		if isMin == true {
			res.Info.Min = tools.GetMin(other)
		}
	}
	return res, nil
}

func (s *PhysicalService) PhysicalHardware(ctx context.Context, par dto.PhysicalHardwareReq) (res *dto.PhysicalHardwareRsp, err error) {
	//获取服务器详情
	details, err := s.Store.ServiceRpcClient.PhysicalServerDetails(ctx, &resource_serverv1alpha.DescribePhysicalHostRequest{
		DeviceSn: par.DeviceSn,
	})
	if err != nil {
		return nil, err
	}
	fmt.Printf("details %+v", details)
	//获取硬件数据
	hardware, err := s.Store.AssetPhysicalServerHardwareDao.GetHardware(ctx, par.DeviceSn)
	if err != nil {
		return nil, err
	}
	outBandIp := []string{details.OutbandIP}
	var (
		ipmiRunStatus []types.BasicOverviewSlot
		inTemp        []types.BasicOverviewSlot
		outTemp       []types.BasicOverviewSlot
		cpuState      []types.BasicOverviewSlot
		memState      []types.BasicOverviewSlot
		diskState     []types.BasicOverviewSlot
		powerState    []types.BasicOverviewSlot
		fanState      []types.BasicOverviewSlot
		boardList     []dto.MainBoard
		cpulist       dto.CpuDetail
		memList       dto.MemDetail
		diskList      dto.DiskDetail
		powerList     []dto.Power
		fanList       []dto.Fan
		workList      []dto.Work
	)

	ipmiStatus, err := GetHardware(s.Store, ctx, outBandIp, server.IpmiUp, "带外连通状态")
	if err != nil {
		return nil, err
	}
	ipmiRunStatus = append(ipmiRunStatus, ipmiStatus)

	inTemps, err := GetHardware(s.Store, ctx, outBandIp, server.InTemp, "进风口温度")
	if err != nil {
		return nil, err
	}
	inTemp = append(inTemp, inTemps)

	outTemps, err := GetHardware(s.Store, ctx, outBandIp, server.OutTemp, "出风口温度")
	if err != nil {
		return nil, err
	}
	outTemp = append(outTemp, outTemps)

	ipmiCpuStatus, err := GetHardwareCpuHealthStatus(s.Store, ctx, outBandIp, len(hardware.CpuInfo))
	if err != nil {
		return nil, err
	}
	cpuState = append(cpuState, ipmiCpuStatus)

	ipmiMemStatus, err := GetHardwareMemHealthStatus(s.Store, ctx, outBandIp, hardware.MemoryInfo)
	if err != nil {
		return nil, err
	}
	memState = append(memState, ipmiMemStatus)

	ipmiDiskStatus, err := GetHardwareDiskHealthStatus(len(hardware.CpuInfo))
	if err != nil {
		return nil, err
	}
	diskState = append(diskState, ipmiDiskStatus)

	ipmiPowerStatus, err := GetHardwarePowerFanHealthStatus(s.Store, ctx, outBandIp, server.IpmiSensorStatePower, "电源健康状态")
	if err != nil {
		return nil, err
	}
	powerState = append(powerState, ipmiPowerStatus)

	ipmiFanStatus, err := GetHardwarePowerFanHealthStatus(s.Store, ctx, outBandIp, server.IpmiSensorStateFan, "风扇健康状态")
	if err != nil {
		return nil, err
	}
	fanState = append(fanState, ipmiFanStatus)

	// 主板
	for _, v := range hardware.BaseboardInfo {
		mainBoard := dto.MainBoard{Name: v.Model, State: 0, ProducFactory: v.Manufacturer, Sn: v.SerialNumber}
		boardList = append(boardList, mainBoard)
	}

	//cpu列表
	for _, v := range hardware.CpuInfo {
		cpulist.Cores += int(v.CoreCount)
		cpulist.Sum++
		cpulist.CpuList = append(cpulist.CpuList, dto.Cpu{
			Name:       v.SocketDesignation,
			State:      0,
			UsedRate:   0,
			Model:      v.Model,
			ClockSpeed: v.CurrentSpeed,
			MaxClock:   v.MaxSpeed,
			Cores:      v.CoreCount,
			Threads:    v.ThreadCount,
			L1Cache:    v.L1iCache + v.L1dCache,
			L2Cache:    v.L2Cache,
			L3Cache:    "v.L3Cache",
		})
	}

	//内存列表
	var memCapTotal int
	for _, v := range hardware.MemoryInfo {
		memCapTotal += int(v.Size)
		memList.Sum++
		memList.MemList = append(memList.MemList, dto.Memory{
			Position:      v.DeviceLocator,
			Model:         v.PartNumber,
			Width:         int(v.TotalWidth),
			MaxClock:      int(v.Speed),
			Capacity:      tools.FormatBytes(int(v.Size)),
			Tech:          v.FormFactor,
			Sn:            v.SerialNumber,
			ProducFactory: v.Manufacturer})
	}
	memList.Capacity = tools.FormatBytes(memCapTotal)

	//硬盘列表
	var diskCapTotal int64
	for _, v := range hardware.DiskInfo {
		vSize := tools.TypeToRealSize(v.Size)
		diskCapTotal += vSize
		diskList.Sum++
		var diskType string
		if v.DiskType == "0" {
			diskType = "sdd"
		} else if v.DiskType == "" {
			diskType = "hdd"
		}
		vv := dto.Disk{
			Name:          v.DiskName,
			ProducFactory: v.Vendor,
			DiskType:      diskType,
			UsedRate:      v.DiskRate,
			Model:         v.Model,
			Sn:            v.SerialNumber,
			Capacity:      tools.FormatBytes(int(vSize)),
		}
		diskList.DiskList = append(diskList.DiskList, vv)
	}
	diskList.Capacity = tools.FormatBytes(int(diskCapTotal))

	//work列表
	for _, v := range hardware.WorkInfo {
		speed := tools.FormCMDBStorageM(v.Size)
		workList = append(workList, dto.Work{
			Name:         v.Name,
			HealthStatus: v.HealthStatus,
			Product:      v.Product,
			Vendor:       v.Vendor,
			Speed:        speed})
	}

	//电源
	ipmiPower, _ := s.Store.AlarmRpcClient.ListPromQLs(ctx, server.TemplateMap[server.IpmiSensorStatePower](outBandIp))
	ipmiPowerPromRes, err := prom_client.VectorQuery(ctx, ipmiPower.Items[0].RealPromql)
	if err != nil {
		return nil, err
	}
	for _, v := range ipmiPowerPromRes {
		if math.IsNaN(float64(v.Value)) {
			v.Value = 0
		}
		powerList = append(powerList, dto.Power{Id: string(v.Metric["id"]), State: float64(v.Value)})
	}

	//风扇
	ipmiFan, _ := s.Store.AlarmRpcClient.ListPromQLs(ctx, server.TemplateMap[server.IpmiFanSpeedRpm](outBandIp))
	ipmiFanPromRes, err := prom_client.VectorQuery(ctx, ipmiFan.Items[0].RealPromql)
	if err != nil {
		return nil, err
	}

	for _, v := range ipmiFanPromRes {
		if math.IsNaN(float64(v.Value)) {
			v.Value = 0
		}
		fanList = append(fanList, dto.Fan{Name: string(v.Metric["name"]), Speed: float64(v.Value)})
	}

	return &dto.PhysicalHardwareRsp{
		IpmiStatus:    ipmiRunStatus,
		InTemp:        inTemp,
		OutTemp:       outTemp,
		CpuState:      cpuState,
		MemState:      memState,
		DiskState:     diskState,
		PowerState:    powerState,
		FanState:      fanState,
		MainBoardList: boardList,
		CpuList:       cpulist,
		MemList:       memList,
		DiskList:      diskList,
		WorkList:      workList,
		PowerList:     powerList,
		FanList:       fanList,
	}, nil
}

type HardwareState struct {
	State string `json:"state" description:"状态"`
	Name  string `json:"name" description:"名称"`
}

var StateSlice = []HardwareState{
	{
		State: "0",
		Name:  "正常",
	},
	{
		State: "1",
		Name:  "告警",
	},
	{
		State: "2",
		Name:  "故障",
	},
	{
		State: "3",
		Name:  "未知",
	},
}

func GetHardware(s dao.ServerStore, ctx context.Context, ourIpList []string, template, name string) (types.BasicOverviewSlot, error) {
	var res types.BasicOverviewSlot
	ipmiStatus, err := s.AlarmRpcClient.ListPromQLs(ctx, server.TemplateMap[template](ourIpList))
	if err != nil {
		return res, err
	}
	promQLStr := ipmiStatus.Items[0].RealPromql
	fmt.Println("promQLStr", promQLStr)
	promRes, err := prom_client.VectorQuery(ctx, promQLStr)
	if err != nil {
		return res, err
	}
	if len(promRes) != 0 {
		if !math.IsNaN(float64(promRes[0].Value)) {
			res.Info = types.BasicOverviewSlotInfo{
				Name:  name,
				Value: float64(promRes[0].Value),
			}
		}
	} else {
		res.Info = types.BasicOverviewSlotInfo{
			Name:  name,
			Value: 0,
		}
	}
	return res, nil
}

func GetHardwareCpuHealthStatus(s dao.ServerStore, ctx context.Context, ourIpList []string, cpuNum int) (types.BasicOverviewSlot, error) {

	var cpuStateList []float64
	slot := types.BasicOverviewSlot{}
	slot.Info = types.BasicOverviewSlotInfo{
		Name: "CPU健康状态",
	}
	ipmiStatus, err := s.AlarmRpcClient.ListPromQLs(ctx, server.TemplateMap[server.IpmiSensorStateCpu](ourIpList))
	if err != nil {
		return slot, err
	}
	promQLStr := ipmiStatus.Items[0].RealPromql
	fmt.Println("promQLStr", promQLStr)
	promRes, err := prom_client.VectorQuery(ctx, promQLStr)
	if err != nil {
		return slot, err
	}
	fmt.Println("promRes", promRes)
	for _, v := range promRes {
		if math.IsNaN(float64(v.Value)) {
			v.Value = 3 //未知
		}
		cpuStateList = append(cpuStateList, float64(v.Value))
	}
	var stateMapCpu = map[float64]int{}
	if len(cpuStateList) > 0 {
		for _, status := range cpuStateList {
			if v, ok := stateMapCpu[status]; ok {
				stateMapCpu[status] = v + 1
			} else {
				stateMapCpu[status] = 1
			}
		}
	}
	for _, v := range StateSlice {
		state, _ := strconv.ParseFloat(v.State, 64)
		value, ok := stateMapCpu[state]
		if ok {
			slot.Values = append(slot.Values, types.BasicOverviewSlotValue{
				Name:  v.Name,
				Value: value,
			})
		} else { // 未获取到数据
			fillValue := 0
			if v.Name == "正常" {
				fillValue = cpuNum
			}
			slot.Values = append(slot.Values, types.BasicOverviewSlotValue{
				Name:  v.Name,
				Code:  "false",
				Value: fillValue,
			})
		}
	}

	return slot, nil
}

func GetHardwareMemHealthStatus(s dao.ServerStore, ctx context.Context, ourIpList []string, memList []model.MemoryDeviceInfo) (types.BasicOverviewSlot, error) {

	var memStateList []float64
	slot := types.BasicOverviewSlot{}
	slot.Info = types.BasicOverviewSlotInfo{
		Name: "内存健康状态",
	}
	promQL, err := s.AlarmRpcClient.ListPromQLs(ctx, server.TemplateMap[server.IpmiSensorStateMem](ourIpList))
	if err != nil {
		return slot, err
	}
	promQLStr := promQL.Items[0].RealPromql
	promRes, _ := prom_client.VectorQuery(ctx, promQLStr)

	for _, mem := range memList {
		for _, prom := range promRes { // 匹配数据
			if math.IsNaN(float64(prom.Value)) {
				prom.Value = 3 //未知
			}
			name := string(prom.Metric["name"])
			if name == mem.DeviceLocator {
				memStateList = append(memStateList, float64(prom.Value))
			}
		}
	}

	var stateMapMem = map[float64]int{}
	if len(memStateList) > 0 {
		for _, status := range memStateList {
			if v, ok := stateMapMem[status]; ok {
				stateMapMem[status] = v + 1
			} else {
				stateMapMem[status] = 1
			}
		}
	}

	for _, v := range StateSlice {
		state, _ := strconv.ParseFloat(v.State, 64)
		value, ok := stateMapMem[state]
		if ok {
			slot.Values = append(slot.Values, types.BasicOverviewSlotValue{
				Name:  v.Name,
				Value: value,
			})
		} else { // 未获取到数据
			fillValue := 0
			if v.Name == "正常" {
				fillValue = len(memList)
			}
			slot.Values = append(slot.Values, types.BasicOverviewSlotValue{
				Name:  v.Name,
				Code:  "false",
				Value: fillValue,
			})
		}
	}
	return slot, nil
}

func GetHardwareDiskHealthStatus(diskNum int) (types.BasicOverviewSlot, error) {
	slot := types.BasicOverviewSlot{}
	slot.Info = types.BasicOverviewSlotInfo{
		Name: "硬盘健康状态",
	}

	for _, v := range StateSlice {
		fillValue := 0
		if v.Name == "正常" {
			fillValue = diskNum
		}
		slot.Values = append(slot.Values, types.BasicOverviewSlotValue{
			Name:  v.Name,
			Code:  "false",
			Value: fillValue,
		})
	}
	return slot, nil
}

func GetHardwarePowerFanHealthStatus(s dao.ServerStore, ctx context.Context, ourIpList []string, template, name string) (types.BasicOverviewSlot, error) {
	var stateList []float64
	slot := types.BasicOverviewSlot{}
	slot.Info = types.BasicOverviewSlotInfo{
		Name: name,
	}
	ipmiStatus, err := s.AlarmRpcClient.ListPromQLs(ctx, server.TemplateMap[template](ourIpList))
	if err != nil {
		return slot, err
	}
	promQLStr := ipmiStatus.Items[0].RealPromql
	fmt.Println("promQLStr", promQLStr)
	promRes, err := prom_client.VectorQuery(ctx, promQLStr)

	if err != nil {
		return slot, err
	}
	for _, v := range promRes {
		if math.IsNaN(float64(v.Value)) {
			v.Value = 3 //未知
		}
		stateList = append(stateList, float64(v.Value))
	}
	var stateMap = map[float64]int{}
	if len(stateList) > 0 {
		for _, status := range stateList {
			if v, ok := stateMap[status]; ok {
				stateMap[status] = v + 1
			} else {
				stateMap[status] = 1
			}
		}
	}
	for _, v := range StateSlice {
		state, _ := strconv.ParseFloat(v.State, 64)
		value, ok := stateMap[state]
		if ok {
			slot.Values = append(slot.Values, types.BasicOverviewSlotValue{
				Name:  v.Name,
				Value: value,
			})
		} else { // 未获取到数据
			slot.Values = append(slot.Values, types.BasicOverviewSlotValue{
				Name:  v.Name,
				Code:  "false",
				Value: 0,
			})
		}
	}
	return slot, nil
}

func (s *PhysicalService) GetMonitoringStatus(ctx context.Context, par dto.GetMonitoringStatusReq) (*dto.GetMonitoringStatusRsp, error) {
	// 监控状态
	var ips string
	if par.ResourceType == "Server" {
		ips = par.Ip + ":9100"
	} else {
		ips = par.Ip
	}
	upSp, err := s.Store.AlarmRpcClient.ListPromQLs(ctx, server.TemplateMap[server.Status]([]string{ips}))
	if err != nil {
		return nil, err
	}
	up, err := prom_client.VectorQuery(ctx, upSp.Items[0].RealPromql)
	var flag string
	for _, v := range up {
		if math.IsNaN(float64(v.Value)) {
			v.Value = 0
		}
		if float64(v.Value) == 1 {
			flag = "up"
		} else {
			flag = "down"
		}
	}
	res := dto.GetMonitoringStatusRsp{
		Ip:           par.Ip,
		ResourceType: par.ResourceType,
		RunStatus:    flag,
	}

	return &res, nil

}

```

File path: /Users/mac/Desktop/woker_code/monitor/modules/server/rpc/server.go
```golang
package rpc

import (
	"context"

	"ezone.ksyun.com/ezone/luban/communal/lib"
	pb "ezone.ksyun.com/ezone/luban/luban_api/monitorapis/server/v1alpha/gen"
	"ezone.ksyun.com/ezone/luban/monitor/modules/server/dto"
	"github.com/jinzhu/copier"
	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/status"
)

func (n *serverRpcServer) PhysicalList(ctx context.Context, req *pb.PhysicalListReq) (*pb.PhysicalListRsp, error) {
	lib.Log.TagInfo(lib.GetTraceContext(ctx), lib.DLTagRequestIn, map[string]interface{}{"params": req})
	var par dto.PhysicalListReq
	if err := copier.Copy(&par, req); err != nil {
		lib.Log.TagError(lib.GetTraceContext(ctx), lib.DLTagUndefind, map[string]interface{}{"copy err": err})
		return nil, status.Error(codes.Internal, err.Error())
	}
	res, err := n.physicalSvc.PhysicalList(ctx, par)
	if err != nil {
		lib.Log.TagError(lib.GetTraceContext(ctx), lib.DLTagUndefind, map[string]interface{}{"call service err": err})
		return nil, status.Error(codes.Internal, err.Error())
	}
	resp := &pb.PhysicalListRsp{}
	copier.Copy(&resp, res)
	return resp, nil
}

func (n *serverRpcServer) PhysicalHardware(ctx context.Context, req *pb.PhysicalHardwareReq) (*pb.PhysicalHardwareRsp, error) {
	lib.Log.TagInfo(lib.GetTraceContext(ctx), lib.DLTagRequestIn, map[string]interface{}{"params": req})
	var par dto.PhysicalHardwareReq
	if err := copier.Copy(&par, req); err != nil {
		lib.Log.TagError(lib.GetTraceContext(ctx), lib.DLTagUndefind, map[string]interface{}{"copy err": err})
		return nil, status.Error(codes.Internal, err.Error())
	}
	res, err := n.physicalSvc.PhysicalHardware(ctx, par)
	if err != nil {
		lib.Log.TagError(lib.GetTraceContext(ctx), lib.DLTagUndefind, map[string]interface{}{"call service err": err})
		return nil, status.Error(codes.Internal, err.Error())
	}
	resp := &pb.PhysicalHardwareRsp{}
	if err := copier.CopyWithOption(&resp, res, copier.Option{IgnoreEmpty: true}); err != nil { // 忽略nil
		lib.Log.TagError(lib.GetTraceContext(ctx), lib.DLTagUndefind, map[string]interface{}{"copy err": err})
		return nil, status.Error(codes.Internal, err.Error())
	}
	return resp, nil
}

```

File path: /Users/mac/Desktop/woker_code/monitor/modules/server/rpc/rpcserver.go
```golang
package rpc

import (
	pb "ezone.ksyun.com/ezone/luban/luban_api/monitorapis/server/v1alpha/gen"
	"ezone.ksyun.com/ezone/luban/monitor/modules/server/service"
)

type serverRpcServer struct {
	physicalSvc *service.PhysicalService
	pb.UnimplementedPhysicalServiceServer
}

func NewServerRpcServer() *serverRpcServer {
	return &serverRpcServer{
		physicalSvc: service.NewPhysicalService(),
	}
}

```

File path: /Users/mac/Desktop/woker_code/monitor/modules/server/rpc/server_test.go
```golang
package rpc

import (
	"context"
	"testing"

	monitor_server1alpha "ezone.ksyun.com/ezone/luban/luban_api/monitorapis/server/v1alpha/gen"
	"ezone.ksyun.com/ezone/luban/monitor/modules/server/service"
)

func Test_serverRpcServer_PhysicalList(t *testing.T) {
	type fields struct {
		physicalSvc                        *service.PhysicalService
		UnimplementedPhysicalServiceServer monitor_server1alpha.UnimplementedPhysicalServiceServer
	}
	type args struct {
		ctx context.Context
		req *monitor_server1alpha.PhysicalListReq
	}
	tests := []struct {
		name    string
		fields  fields
		args    args
		want    *monitor_server1alpha.PhysicalListRsp
		wantErr bool
	}{
		{
			name: "Test PhysicalList",
			fields: fields{
				physicalSvc: service.NewPhysicalService(),
			},
			args: args{
				ctx: context.Background(),
				req: &monitor_server1alpha.PhysicalListReq{
					PageNo:   1,
					PageSize: 1000,
					Query:    map[string]string{"ManageIP": "10.175.129.1"},
				},
			},
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			n := &serverRpcServer{
				physicalSvc:                        tt.fields.physicalSvc,
				UnimplementedPhysicalServiceServer: tt.fields.UnimplementedPhysicalServiceServer,
			}
			got, err := n.PhysicalList(tt.args.ctx, tt.args.req)
			if (err != nil) != tt.wantErr {
				t.Errorf("PhysicalList() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			t.Log(got)
		})
	}
}

func Test_serverRpcServer_PhysicalHardware(t *testing.T) {
	type fields struct {
		physicalSvc                        *service.PhysicalService
		UnimplementedPhysicalServiceServer monitor_server1alpha.UnimplementedPhysicalServiceServer
	}
	type args struct {
		ctx context.Context
		req *monitor_server1alpha.PhysicalHardwareReq
	}
	tests := []struct {
		name    string
		fields  fields
		args    args
		want    *monitor_server1alpha.PhysicalHardwareRsp
		wantErr bool
	}{
		{
			name: "Test PhysicalHardware",
			fields: fields{
				physicalSvc: service.NewPhysicalService(),
			},
			args: args{
				ctx: context.Background(),
				req: &monitor_server1alpha.PhysicalHardwareReq{
					DeviceSn: "9800165603762656",
				},
			},
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			n := &serverRpcServer{
				physicalSvc:                        tt.fields.physicalSvc,
				UnimplementedPhysicalServiceServer: tt.fields.UnimplementedPhysicalServiceServer,
			}
			got, err := n.PhysicalHardware(tt.args.ctx, tt.args.req)
			if err != nil {
				t.Errorf("PhysicalHardware() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			t.Log(got)
		})
	}
}

```

File path: /Users/mac/Desktop/woker_code/monitor/modules/compute/dto/response.go
```golang
package dto

import (
	"time"

	"ezone.ksyun.com/ezone/luban/monitor/common/types"
)

// ComputePoolOverviewAlertRsp 计算资源池概览告警响应
type ComputePoolOverviewAlertRsp struct {
	Alerts []types.BasicOverviewSlot `json:"Alerts"`
}

// ComputePoolOverviewMonitorRsp 计算资源池概览监控响应
type ComputePoolOverviewMonitorRsp struct {
	Monitors []types.BasicOverviewSlot `json:"Monitors"`
}

// ComputePoolOverviewLineRsp 计算资源池概览线图响应
type ComputePoolOverviewLineRsp struct {
	Lines []types.BasicOverviewSlot `json:"Lines"`
}

// ComputePoolListRsp 计算资源池列表响应
type ComputePoolListRsp struct {
	TotalCount int                   `json:"TotalCount"`
	PageNo     int                   `json:"PageNo"`
	PageSize   int                   `json:"PageSize"`
	DataList   []*ComputePoolMonitor `json:"DataList"`
}

type ComputePoolDetailLineRsp struct {
	Lines []types.BasicOverviewSlot `json:"Lines"`
}

type ComputePoolMonitor struct {
	Id              string    `json:"Id"`
	Name            string    `json:"Name"`
	Region          string    `json:"Region"`
	Az              string    `json:"Az"`
	CpuTotal        int       `json:"CpuTotal"`
	CpuRemain       int       `json:"CpuRemain"`
	CpuRate         float64   `json:"CpuRate"`
	CpuUsedTotal    int       `json:"CpuUsedTotal"`
	MemoryTotal     float64   `json:"MemoryTotal"`
	MemoryRemain    float64   `json:"MemoryRemain"`
	MemoryRate      float64   `json:"MemoryRate"`
	MemoryUsedTotal float64   `json:"MemoryUsedTotal"`
	DiskRate        float64   `json:"DiskRate"`
	HostCount       int       `json:"HostCount"`
	VmCount         int       `json:"VmCount"`
	AlertCount      int       `json:"AlertCount"`
	CreateTime      time.Time `json:"CreateTime"`
	PType           string    `json:"PType"`
}

// VmOverviewMonitorRsp 云主机概览监控响应
type VmOverviewMonitorRsp struct {
	TotalCount int64                     `json:"TotalCount"`
	Business   []types.BasicOverviewSlot `json:"Business"`
	Platform   []types.BasicOverviewSlot `json:"Platform"`
}

// VmOverviewTopRsp 云主机概览TopK响应
type VmOverviewTopRsp struct {
	Tops []types.BasicOverviewSlot `json:"Tops"`
}

// VmDetailMetricsRsp 云主机详情指标响应
type VmDetailMetricsRsp struct {
	Metrics []types.BasicOverviewSlot `json:"Metrics"`
}

// VmDetailMetricLinesRsp 云主机详情指标线响应
type VmDetailMetricLinesRsp struct {
	Lines []types.BasicOverviewSlot `json:"Lines"`
}

```

File path: /Users/mac/Desktop/woker_code/monitor/modules/compute/dto/request.go
```golang
package dto

// CommonListReq 列表基础请求
type CommonListReq struct {
	PageNo    int    `json:"PageNo"`
	PageSize  int    `json:"PageSize" binding:"lte=1000"`
	Region    string `json:"Region"`
	OrderCode string `json:"OrderCode"`
	OrderType string `json:"OrderType"`
	Query     Query  `json:"Query"`
}

type Query map[string]string

// ComputePoolOverviewAlertReq  计算资源池概览告警请求
type ComputePoolOverviewAlertReq struct {
	Region string `json:"Region"`
	Az     string `json:"Az"`
}

// ComputePoolOverviewMonitorReq 计算资源池概览监控请求
type ComputePoolOverviewMonitorReq struct {
	Region string `json:"Region"`
	Az     string `json:"Az"`
}

// ComputePoolOverviewLineReq 计算资源池概览线图请求
type ComputePoolOverviewLineReq struct {
	Region        string `json:"Region"`
	Az            string `json:"Az"`
	MetricName    string `json:"MetricName"`
	Start         int64  `json:"Start"`
	End           int64  `json:"End"`
	HasPrediction bool   `json:"HasPrediction"`
}

// ComputePoolListReq 计算资源池监控列表请求
type ComputePoolListReq struct {
	PageNo    int      `json:"PageNo"`
	PageSize  int      `json:"PageSize" binding:"lte=1000"`
	Region    string   `json:"Region"`
	OrderCode string   `json:"OrderCode"`
	OrderType string   `json:"OrderType"`
	Query     Query    `json:"Query"`
	Name      string   `json:"Name"`
	Az        []string `json:"Az"`
}

type ComputePoolDetailLineReq struct {
	Start      int64  `json:"Start"`
	End        int64  `json:"End"`
	Region     string `json:"Region"`
	Name       string `json:"Name"`
	MetricName string `json:"MetricName"`
}

// VmOverviewMonitorReq 云主机概览监控请求
type VmOverviewMonitorReq struct {
	Region string `json:"Region"`
	Az     string `json:"Az"`
}

// VmOverviewTopReq 云主机概览TopK请求
type VmOverviewTopReq struct {
	Region string   `json:"Region"`
	Az     string   `json:"Az"`
	Name   []string `json:"Name"`
	TopK   int      `json:"TopK"`
	Start  int64    `json:"Start"`
	End    int64    `json:"End"`
}

// VmDetailMetricsReq 云主机详情指标请求
type VmDetailMetricsReq struct {
	Id         string   `json:"Id"`
	MetricName []string `json:"MetricName"`
}

// VmDetailMetricLinesReq 云主机详情指标线请求
type VmDetailMetricLinesReq struct {
	Id         string   `json:"Id"`
	Start      int64    `json:"Start"`
	End        int64    `json:"End"`
	MetricName []string `json:"MetricName"`
}

```

File path: /Users/mac/Desktop/woker_code/monitor/modules/compute/dao/metric_top.go
```golang
package dao

import (
	"ezone.ksyun.com/ezone/luban/communal/lib"
	"ezone.ksyun.com/ezone/luban/monitor/common/gormSerializer"
	"ezone.ksyun.com/ezone/luban/monitor/modules/network/model"
	"gorm.io/gorm"
	"gorm.io/gorm/schema"
)

type MetricTopDao struct {
	db *gorm.DB
}

type QueryParams struct {
	Region string
	Az     string
	Code   string
}

func NewMetricTopDao() *MetricTopDao {
	schema.RegisterSerializer("json_str", gormSerializer.JSONSerializer{})
	return &MetricTopDao{
		db: lib.GORMMapPool["business"],
	}
}

func (m *MetricTopDao) GetOneByCode(q QueryParams) (model.MonitorTop, error) {
	var data model.MonitorTop
	if err := m.db.Where("region = ? AND az = ? AND code = ?", q.Region, q.Az, q.Code).First(&data).Error; err != nil {
		return data, err
	}
	return data, nil
}

```

File path: /Users/mac/Desktop/woker_code/monitor/modules/compute/dao/store.go
```golang
package dao

import (
	"ezone.ksyun.com/ezone/luban/communal/lib"
	alarmv1alpha "ezone.ksyun.com/ezone/luban/luban_api/alarmapis/alarm/v1alpha/gen"
	resource_computev1alpha "ezone.ksyun.com/ezone/luban/luban_api/resourceapis/resource_compute/v1alpha/gen"
	resource_serverv1alpha "ezone.ksyun.com/ezone/luban/luban_api/resourceapis/resource_server/v1alpha/gen"
	"ezone.ksyun.com/ezone/luban/monitor/common/client/grpcx"
)

type Store interface {
	// DAO 服务
	Metric() *MetricDao
	MetricTop() *MetricTopDao

	// RPC 服务
	AlarmRpcClient() alarmv1alpha.AlarmServiceClient
	ComputePoolRpcClient() resource_computev1alpha.ComputePoolServiceClient
	VmRpcClient() resource_computev1alpha.VmServiceClient
	ServerRpcClient() resource_serverv1alpha.ResourceServiceClient
}

type computeStore struct {
}

func NewComputeStore() *computeStore {
	return &computeStore{}
}

func (n *computeStore) Metric() *MetricDao {
	return NewMetricDao()
}

func (n *computeStore) MetricTop() *MetricTopDao {
	return NewMetricTopDao()
}

func (n *computeStore) AlarmRpcClient() alarmv1alpha.AlarmServiceClient {
	alarmAddr := lib.GetStringConf("base.grpc.alarm")
	alarmConn, err := grpcx.NewGrpcClientConn(alarmAddr)
	if err != nil {
		lib.Log.TagError(lib.NewTrace(), lib.DLTagUndefind, map[string]interface{}{"connect alarm grpc server error, %s": err.Error()})
	}
	return alarmv1alpha.NewAlarmServiceClient(alarmConn)
}

func (n *computeStore) ComputePoolRpcClient() resource_computev1alpha.ComputePoolServiceClient {
	resourceAddr := lib.GetStringConf("base.grpc.luban_resource")
	resourceConn, err := grpcx.NewGrpcClientConn(resourceAddr)
	if err != nil {
		lib.Log.TagError(lib.NewTrace(), lib.DLTagUndefind, map[string]interface{}{"connect luban_resource grpc server error, %s": err.Error()})
	}
	return resource_computev1alpha.NewComputePoolServiceClient(resourceConn)
}

func (n *computeStore) VmRpcClient() resource_computev1alpha.VmServiceClient {
	resourceAddr := lib.GetStringConf("base.grpc.luban_resource")
	resourceConn, err := grpcx.NewGrpcClientConn(resourceAddr)
	if err != nil {
		lib.Log.TagError(lib.NewTrace(), lib.DLTagUndefind, map[string]interface{}{"connect luban_resource grpc server error, %s": err.Error()})
	}
	return resource_computev1alpha.NewVmServiceClient(resourceConn)
}

func (n *computeStore) ServerRpcClient() resource_serverv1alpha.ResourceServiceClient {
	resourceAddr := lib.GetStringConf("base.grpc.luban_resource")
	resourceConn, err := grpcx.NewGrpcClientConn(resourceAddr)
	if err != nil {
		lib.Log.TagError(lib.NewTrace(), lib.DLTagUndefind, map[string]interface{}{"connect luban_resource grpc server error, %s": err.Error()})
	}
	return resource_serverv1alpha.NewResourceServiceClient(resourceConn)
}

```

File path: /Users/mac/Desktop/woker_code/monitor/modules/compute/dao/metric.go
```golang
package dao

import (
	"ezone.ksyun.com/ezone/luban/communal/lib"
	"ezone.ksyun.com/ezone/luban/monitor/modules/compute/model"
	"gorm.io/gorm"
)

type MetricDao struct {
	db *gorm.DB
}

func NewMetricDao() *MetricDao {
	return &MetricDao{
		db: lib.GORMMapPool["business"],
	}
}

func (m *MetricDao) GetOneByCode(code string) (*model.MonitorTsdbMetrics, error) {
	content := model.MonitorTsdbMetrics{}
	err := m.db.Where("code = ?", code).Find(&content).Error
	if err != nil {
		lib.Log.TagError(lib.NewTrace(), lib.DLTagMySqlFailed, map[string]interface{}{"error": err.Error()})
		return nil, err
	}
	return &content, nil
}

// get list by codes
func (m *MetricDao) GetListByCodes(codes []string) ([]model.MonitorTsdbMetrics, error) {
	var content []model.MonitorTsdbMetrics
	err := m.db.Where("code in (?)", codes).Find(&content).Error
	if err != nil {
		lib.Log.TagError(lib.NewTrace(), lib.DLTagMySqlFailed, map[string]interface{}{"error": err.Error()})
		return nil, err
	}
	return content, nil
}

```

File path: /Users/mac/Desktop/woker_code/monitor/modules/compute/dao/mock.go
```golang
package dao

import (
	"fmt"
	"log"
	"os"
	"path/filepath"

	resource_serverv1alpha "ezone.ksyun.com/ezone/luban/luban_api/resourceapis/resource_server/v1alpha/gen"

	computePoolv1alpha "ezone.ksyun.com/ezone/luban/luban_api/resourceapis/resource_compute/v1alpha/gen"

	"ezone.ksyun.com/ezone/luban/communal/lib"
	alarmv1alpha "ezone.ksyun.com/ezone/luban/luban_api/alarmapis/alarm/v1alpha/gen"
	"ezone.ksyun.com/ezone/luban/monitor/common/client/grpcx"
)

type MockComputeStore struct{}

func findProjectRoot(startDir string) (string, error) {
	_, err := os.Stat(filepath.Join(startDir, "go.mod"))
	if err == nil {
		return startDir, nil
	}
	// 获取上级目录
	parentDir := filepath.Dir(startDir)
	if startDir == parentDir {
		return "", fmt.Errorf("no go.mod found")
	}
	return findProjectRoot(parentDir)
}

func NewMockComputeStore() *MockComputeStore {
	dir, _ := os.Getwd()
	root, _ := findProjectRoot(dir)
	if err := lib.InitModuleYaml(root+"/conf/", []string{"base", "mysql", "redis"}); err != nil {
		log.Println(err)
	}
	return &MockComputeStore{}
}

func (n *MockComputeStore) Metric() *MetricDao {
	return NewMetricDao()
}

func (n *MockComputeStore) MetricTop() *MetricTopDao {
	return NewMetricTopDao()
}

func (n *MockComputeStore) AlarmRpcClient() alarmv1alpha.AlarmServiceClient {
	alarmAddr := lib.GetStringConf("base.grpc.alarm")
	alarmConn, err := grpcx.NewGrpcClientConn(alarmAddr)
	if err != nil {
		lib.Log.TagError(lib.NewTrace(), lib.DLTagUndefind, map[string]interface{}{"connect alarm grpc server error, %s": err.Error()})
	}
	return alarmv1alpha.NewAlarmServiceClient(alarmConn)
}

func (n *MockComputeStore) ComputePoolRpcClient() computePoolv1alpha.ComputePoolServiceClient {
	resourceAddr := lib.GetStringConf("base.grpc.luban_resource")
	resourceConn, err := grpcx.NewGrpcClientConn(resourceAddr)
	if err != nil {
		lib.Log.TagError(lib.NewTrace(), lib.DLTagUndefind, map[string]interface{}{"connect luban_resource grpc server error, %s": err.Error()})
	}
	return computePoolv1alpha.NewComputePoolServiceClient(resourceConn)
}

func (n *MockComputeStore) VmRpcClient() computePoolv1alpha.VmServiceClient {
	resourceAddr := lib.GetStringConf("base.grpc.luban_resource")
	resourceConn, err := grpcx.NewGrpcClientConn(resourceAddr)
	if err != nil {
		lib.Log.TagError(lib.NewTrace(), lib.DLTagUndefind, map[string]interface{}{"connect luban_resource grpc server error, %s": err.Error()})
	}
	return computePoolv1alpha.NewVmServiceClient(resourceConn)
}

func (n *MockComputeStore) ServerRpcClient() resource_serverv1alpha.ResourceServiceClient {
	resourceAddr := lib.GetStringConf("base.grpc.luban_resource")
	resourceConn, err := grpcx.NewGrpcClientConn(resourceAddr)
	if err != nil {
		lib.Log.TagError(lib.NewTrace(), lib.DLTagUndefind, map[string]interface{}{"connect luban_resource grpc server error, %s": err.Error()})
	}
	return resource_serverv1alpha.NewResourceServiceClient(resourceConn)
}

```

File path: /Users/mac/Desktop/woker_code/monitor/modules/compute/utils/tools.go
```golang
package utils

func TimeToStepForInt(fileSize int64) (size int) {
	//处理的单位是秒
	if fileSize >= 0 {
		if fileSize <= (3600.0 * 3.0) {
			return 60 //1m
		} else if fileSize <= (3600.0 * 24.0 * 7) {
			return 3600 //1h
		} else {
			return 86400 //1d
		}
	}
	return 0
}

```

File path: /Users/mac/Desktop/woker_code/monitor/modules/compute/utils/serializer/register.go
```golang
package serializer

import (
	"gorm.io/gorm/schema"
)

func RegisterSerializer() {
	schema.RegisterSerializer("json_str", JSONSerializer{})
}

```

File path: /Users/mac/Desktop/woker_code/monitor/modules/compute/utils/serializer/json.go
```golang
package serializer

import (
	"context"
	"encoding/json"
	"fmt"
	"reflect"

	"gorm.io/gorm/schema"
)

// JSONSerializer json序列化器
type JSONSerializer struct {
}

// 实现 Scan 方法
func (JSONSerializer) Scan(ctx context.Context, field *schema.Field, dst reflect.Value, dbValue interface{}) (err error) {
	fieldValue := reflect.New(field.FieldType)

	if dbValue != nil {
		var bytes []byte
		switch v := dbValue.(type) {
		case []byte:
			bytes = v
		case string:
			bytes = []byte(v)
		default:
			return fmt.Errorf("failed to unmarshal JSONB value: %#v", dbValue)
		}

		err = json.Unmarshal(bytes, fieldValue.Interface())
	}

	field.ReflectValueOf(ctx, dst).Set(fieldValue.Elem())
	return
}

// 实现 Value 方法
func (JSONSerializer) Value(ctx context.Context, field *schema.Field, dst reflect.Value, fieldValue interface{}) (interface{}, error) {
	return json.Marshal(fieldValue)
}

```

File path: /Users/mac/Desktop/woker_code/monitor/modules/compute/utils/convert/convert.go
```golang
package convert

import (
	"fmt"
	"strconv"
)

func Decimal(value float64) float64 {
	value, _ = strconv.ParseFloat(fmt.Sprintf("%.2f", value), 64)
	return value
}

```

File path: /Users/mac/Desktop/woker_code/monitor/modules/compute/controller/vm.go
```golang
package controller

import (
	"errors"
	"net/http"

	"ezone.ksyun.com/ezone/luban/communal/lib"
	"ezone.ksyun.com/ezone/luban/monitor/common/consts"
	"ezone.ksyun.com/ezone/luban/monitor/modules/compute/constant"
	"ezone.ksyun.com/ezone/luban/monitor/modules/compute/dto"
	"ezone.ksyun.com/ezone/luban/monitor/modules/compute/service"
	"ezone.ksyun.com/ezone/luban/monitor/response"
	"github.com/gin-gonic/gin"
)

type VmController struct {
	svc service.VmService
}

func NewVmController() *VmController {
	return &VmController{
		svc: service.NewVmService(),
	}
}

// OverviewMonitor godoc
// @Summary      Vm Monitor Overview
// @Description  Compute Product Vm Monitor Overview
// @Tags         vm
// @Accept       json
// @Produce      json
// @Param        body body dto.VmOverviewMonitorReq true "Vm Overview Monitor Request"
// @Success      200  {object}  dto.VmOverviewMonitorRsp
// @Router       /compute/product/vm/overview_monitor [POST]
func (n *VmController) OverviewMonitor(c *gin.Context) {
	// 绑定参数
	var params dto.VmOverviewMonitorReq
	if err := c.ShouldBind(&params); err != nil {
		lib.Log.TagError(lib.GetTraceContext(c), lib.DLTagRequestOut, map[string]interface{}{"error": err.Error(), "params": params})
		response.Failed(c, http.StatusBadRequest, consts.ParameterError, "参数绑定失败")
		return
	}
	lib.Log.TagInfo(lib.GetTraceContext(c), lib.DLTagResponseSuccess, map[string]interface{}{"params": params})

	// 业务处理
	res, err := n.svc.OverviewMonitor(c, params)
	if err != nil {
		lib.Log.TagError(lib.GetTraceContext(c), lib.DLTagResponseFailed, map[string]interface{}{"error": err.Error()})
		response.Failed(c, http.StatusInternalServerError, consts.GainFail, "获取云主机监控概览信息失败")
		return
	}

	lib.Log.TagInfo(lib.GetTraceContext(c), lib.DLTagResponseSuccess, map[string]interface{}{"res": res})
	response.Success(c, res)
}

// OverviewTop godoc
// @Summary      Vm TopK Overview
// @Description  Compute Product Vm topK Overview
// @Tags         vm
// @Accept       json
// @Produce      json
// @Param        body body dto.VmOverviewTopReq true "Vm Overview TopK Request"
// @Success      200  {object}  dto.VmOverviewTopRsp
// @Router       /compute/product/vm/overview_top [POST]
func (n *VmController) OverviewTop(c *gin.Context) {
	// 绑定参数
	var params dto.VmOverviewTopReq
	if err := c.ShouldBind(&params); err != nil {
		lib.Log.TagError(lib.GetTraceContext(c), lib.DLTagRequestOut, map[string]interface{}{"error": err.Error(), "params": params})
		response.Failed(c, http.StatusBadRequest, consts.ParameterError, "参数绑定失败")
		return
	}
	lib.Log.TagInfo(lib.GetTraceContext(c), lib.DLTagResponseSuccess, map[string]interface{}{"params": params})

	// 业务处理
	res, err := n.svc.OverviewTop(c, params)
	if err != nil {
		lib.Log.TagError(lib.GetTraceContext(c), lib.DLTagResponseFailed, map[string]interface{}{"error": err.Error()})
		if errors.Is(err, constant.GetTopDataErrorWithRegion) {
			response.Success(c, res)
		}
		response.Failed(c, http.StatusInternalServerError, consts.GainFail, "获取云主机Top概览信息失败")
		return
	}

	lib.Log.TagInfo(lib.GetTraceContext(c), lib.DLTagResponseSuccess, map[string]interface{}{"res": res})
	response.Success(c, res)
}

// DetailMetrics godoc
// @Summary      Vm Detail Metrics
// @Description  Compute Product Vm detail Metrics
// @Tags         vm
// @Accept       json
// @Produce      json
// @Param        body body dto.VmDetailMetricsReq true "Vm Detail Metrics Request"
// @Success      200  {object}  dto.VmDetailMetricsRsp
// @Router       /compute/product/vm/detail_metrics [POST]
func (n *VmController) DetailMetrics(c *gin.Context) {
	// 绑定参数
	var params dto.VmDetailMetricsReq
	if err := c.ShouldBind(&params); err != nil {
		lib.Log.TagError(lib.GetTraceContext(c), lib.DLTagRequestOut, map[string]interface{}{"error": err.Error(), "params": params})
		response.Failed(c, http.StatusBadRequest, consts.ParameterError, "参数绑定失败")
		return
	}
	lib.Log.TagInfo(lib.GetTraceContext(c), lib.DLTagResponseSuccess, map[string]interface{}{"params": params})

	// 业务处理
	res, err := n.svc.DetailMetrics(c, params)
	if err != nil {
		lib.Log.TagError(lib.GetTraceContext(c), lib.DLTagResponseFailed, map[string]interface{}{"error": err.Error()})
		response.Failed(c, http.StatusInternalServerError, consts.GainFail, "获取云主机详情指标信息失败")
		return
	}

	lib.Log.TagInfo(lib.GetTraceContext(c), lib.DLTagResponseSuccess, map[string]interface{}{"res": res})
	response.Success(c, res)
}

// DetailMetricLines godoc
// @Summary      Vm Detail MetricLines
// @Description  Compute Product Vm detail MetricLines
// @Tags         vm
// @Accept       json
// @Produce      json
// @Param        body body dto.VmDetailMetricLinesReq true "Vm Detail Metrics Request"
// @Success      200  {object}  dto.VmDetailMetricLinesRsp
// @Router       /compute/product/vm/detail_metric_lines [POST]
func (n *VmController) DetailMetricLines(c *gin.Context) {
	// 绑定参数
	var params dto.VmDetailMetricLinesReq
	if err := c.ShouldBind(&params); err != nil {
		lib.Log.TagError(lib.GetTraceContext(c), lib.DLTagRequestOut, map[string]interface{}{"error": err.Error(), "params": params})
		response.Failed(c, http.StatusBadRequest, consts.ParameterError, "参数绑定失败")
		return
	}
	lib.Log.TagInfo(lib.GetTraceContext(c), lib.DLTagResponseSuccess, map[string]interface{}{"params": params})

	// 业务处理
	res, err := n.svc.DetailMetricLines(c, params)
	if err != nil {
		lib.Log.TagError(lib.GetTraceContext(c), lib.DLTagResponseFailed, map[string]interface{}{"error": err.Error()})
		response.Failed(c, http.StatusInternalServerError, consts.GainFail, "获取云主机详情指标线信息失败")
		return
	}

	lib.Log.TagInfo(lib.GetTraceContext(c), lib.DLTagResponseSuccess, map[string]interface{}{"res": res})
	response.Success(c, res)
}

```

File path: /Users/mac/Desktop/woker_code/monitor/modules/compute/controller/compute_pool.go
```golang
package controller

import (
	"net/http"

	"ezone.ksyun.com/ezone/luban/communal/lib"
	"ezone.ksyun.com/ezone/luban/monitor/common/consts"
	"ezone.ksyun.com/ezone/luban/monitor/modules/compute/dto"
	"ezone.ksyun.com/ezone/luban/monitor/modules/compute/service"
	"ezone.ksyun.com/ezone/luban/monitor/response"
	"github.com/gin-gonic/gin"
)

type ComputePoolController struct {
	svc service.ComputePoolService
}

func NewComputePoolController() *ComputePoolController {
	return &ComputePoolController{
		svc: service.NewComputePoolService(),
	}
}

// OverviewAlert godoc
// @Summary      ComputePool Alert Overview
// @Description  Get ComputePool Alert Overview
// @Tags         computePool
// @Accept       json
// @Produce      json
// @Param        body body dto.ComputePoolOverviewAlertReq true "ComputePool Overview Alert Request"
// @Success      200  {object}  dto.ComputePoolOverviewAlertRsp
// @Router       /compute/compute_pool/overview_alert [POST]
func (n *ComputePoolController) OverviewAlert(c *gin.Context) {
	// 绑定参数
	var params dto.ComputePoolOverviewAlertReq
	if err := c.ShouldBind(&params); err != nil {
		lib.Log.TagError(lib.GetTraceContext(c), lib.DLTagRequestOut, map[string]interface{}{"error": err.Error(), "params": params})
		response.Failed(c, http.StatusBadRequest, consts.ParameterError, "参数绑定失败")
		return
	}
	lib.Log.TagInfo(lib.GetTraceContext(c), lib.DLTagResponseSuccess, map[string]interface{}{"params": params})

	// 业务处理
	res, err := n.svc.OverviewAlert(c, params)
	if err != nil {
		lib.Log.TagError(lib.GetTraceContext(c), lib.DLTagResponseFailed, map[string]interface{}{"error": err.Error()})
		response.Failed(c, http.StatusInternalServerError, consts.GainFail, "获取概览告警信息失败")
		return
	}

	lib.Log.TagInfo(lib.GetTraceContext(c), lib.DLTagResponseSuccess, map[string]interface{}{"res": res})
	response.Success(c, res)
}

// OverviewMonitor godoc
// @Summary      ComputePool Monitor Overview
// @Description  Get ComputePool Monitor Overview
// @Tags         computePool
// @Accept       json
// @Produce      json
// @Param        body body dto.ComputePoolOverviewMonitorReq true "ComputePool Overview Monitor Request"
// @Success      200  {object}  dto.ComputePoolOverviewMonitorRsp
// @Router       /compute/compute_pool/overview_monitor [POST]
func (n *ComputePoolController) OverviewMonitor(c *gin.Context) {
	// 绑定参数
	var params dto.ComputePoolOverviewMonitorReq
	if err := c.ShouldBind(&params); err != nil {
		lib.Log.TagError(lib.GetTraceContext(c), lib.DLTagRequestOut, map[string]interface{}{"error": err.Error(), "params": params})
		response.Failed(c, http.StatusBadRequest, consts.ParameterError, "参数绑定失败")
		return
	}
	lib.Log.TagInfo(lib.GetTraceContext(c), lib.DLTagResponseSuccess, map[string]interface{}{"params": params})

	// 业务处理
	res, err := n.svc.OverviewMonitor(c, params)
	if err != nil {
		lib.Log.TagError(lib.GetTraceContext(c), lib.DLTagResponseFailed, map[string]interface{}{"error": err.Error()})
		response.Failed(c, http.StatusInternalServerError, consts.GainFail, "获取概览监控信息失败")
		return
	}

	lib.Log.TagInfo(lib.GetTraceContext(c), lib.DLTagResponseSuccess, map[string]interface{}{"res": res})
	response.Success(c, res)
}

// OverviewLine godoc
// @Summary      ComputePool Monitor OverviewLine
// @Description  Get ComputePool Monitor OverviewLine
// @Tags         computePool
// @Accept       json
// @Produce      json
// @Param        body body dto.ComputePoolOverviewLineReq true "ComputePool Overview Line Request"
// @Success      200  {object}  dto.ComputePoolOverviewLineRsp
// @Router       /compute/compute_pool/overview_line [POST]
func (n *ComputePoolController) OverviewLine(c *gin.Context) {
	// 绑定参数
	var params dto.ComputePoolOverviewLineReq
	if err := c.ShouldBind(&params); err != nil {
		lib.Log.TagError(lib.GetTraceContext(c), lib.DLTagRequestOut, map[string]interface{}{"error": err.Error(), "params": params})
		response.Failed(c, http.StatusBadRequest, consts.ParameterError, "参数绑定失败")
		return
	}
	lib.Log.TagInfo(lib.GetTraceContext(c), lib.DLTagResponseSuccess, map[string]interface{}{"params": params})

	// 业务处理
	res, err := n.svc.OverviewLine(c, params)
	if err != nil {
		lib.Log.TagError(lib.GetTraceContext(c), lib.DLTagResponseFailed, map[string]interface{}{"error": err.Error()})
		response.Failed(c, http.StatusInternalServerError, consts.GainFail, "获取概览监控线信息失败")
		return
	}

	lib.Log.TagInfo(lib.GetTraceContext(c), lib.DLTagResponseSuccess, map[string]interface{}{"res": res})
	response.Success(c, res)
}

// List godoc
// @Summary      ComputePool Monitor List
// @Description  Get ComputePool Monitor List
// @Tags         computePool
// @Accept       json
// @Produce      json
// @Param        body body dto.ComputePoolListReq true "ComputePool List Request"
// @Success      200  {object}  dto.ComputePoolListRsp
// @Router       /compute/compute_pool/list [POST]
func (n *ComputePoolController) List(c *gin.Context) {
	// 绑定参数
	var params dto.ComputePoolListReq
	if err := c.ShouldBind(&params); err != nil {
		lib.Log.TagError(lib.GetTraceContext(c), lib.DLTagRequestOut, map[string]interface{}{"error": err.Error(), "params": params})
		response.Failed(c, http.StatusBadRequest, consts.ParameterError, "参数绑定失败")
		return
	}
	lib.Log.TagInfo(lib.GetTraceContext(c), lib.DLTagResponseSuccess, map[string]interface{}{"params": params})

	// 业务处理
	res, err := n.svc.List(c, params)
	if err != nil {
		lib.Log.TagError(lib.GetTraceContext(c), lib.DLTagResponseFailed, map[string]interface{}{"error": err.Error()})
		response.Failed(c, http.StatusInternalServerError, consts.GainFail, "获取计算资源池列表信息失败")
		return
	}

	lib.Log.TagInfo(lib.GetTraceContext(c), lib.DLTagResponseSuccess, map[string]interface{}{"res": res})
	response.Success(c, res)
}

// DetailLine godoc
// @Summary      ComputePool Monitor DetailLine
// @Description  Get ComputePool Monitor DetailLine
// @Tags         computePool
// @Accept       json
// @Produce      json
// @Param        body body dto.ComputePoolDetailLineReq true "ComputePool Detail Line Request"
// @Success      200  {object}  dto.ComputePoolDetailLineRsp
// @Router       /compute/compute_pool/detail_line [POST]
func (n *ComputePoolController) DetailLine(c *gin.Context) {
	var params dto.ComputePoolDetailLineReq
	if err := c.ShouldBind(&params); err != nil {
		lib.Log.TagError(lib.GetTraceContext(c), lib.DLTagRequestOut, map[string]interface{}{"error": err.Error(), "params": params})
		response.Failed(c, http.StatusBadRequest, consts.ParameterError, "参数绑定失败")
		return
	}
	lib.Log.TagInfo(lib.GetTraceContext(c), lib.DLTagResponseSuccess, map[string]interface{}{"params": params})

	// 业务处理
	res, err := n.svc.DetailLine(c, params)
	if err != nil {
		lib.Log.TagError(lib.GetTraceContext(c), lib.DLTagResponseFailed, map[string]interface{}{"error": err.Error()})
		response.Failed(c, http.StatusInternalServerError, consts.GainFail, "获取计算资源池列表信息失败")
		return
	}

	lib.Log.TagInfo(lib.GetTraceContext(c), lib.DLTagResponseSuccess, map[string]interface{}{"res": res})
	response.Success(c, res)
}

```

File path: /Users/mac/Desktop/woker_code/monitor/modules/compute/constant/constant.go
```golang
package constant

import (
	"ezone.ksyun.com/ezone/luban/monitor/common/tsdbql_template/vm"
	"github.com/pkg/errors"
)

var (
	VmStatusMap = map[string]string{
		"shutoff":     "关闭",
		"active":      "运行中",
		"error":       "失败",
		"build":       "创建中",
		"hard_reboot": "强制重启",
		"deleting":    "删除中",
		"suspended":   "挂起",
	}
)

var (
	VmMetricTopMap = map[string]string{
		vm.CpuLoad:    "cpu使用率",
		vm.MemoryLoad: "内存使用率",
		vm.DiskLoad:   "磁盘使用率",
		vm.NetIn:      "网卡流入流量",
		vm.NetOut:     "网卡流出流量",
	}
)

var (
	VmMetricMap = map[string]string{
		vm.CpuModeSystem:   "cpu.system",
		vm.CpuModeUser:     "cpu.user",
		vm.CpuModeSoftIrq:  "cpu.soft_irq",
		vm.CpuModeIrq:      "cpu.irq",
		vm.CpuModeIdle:     "cpu.idle",
		vm.CpuModeIOWait:   "cpu.io_wait",
		vm.CpuModeNice:     "cpu.nice",
		vm.CpuModeSteal:    "cpu.steal",
		vm.MemorySizeTotal: "mem.memTotal",
		vm.MemorySizeFree:  "mem.memFree",
		vm.NetReceive:      "net.receive",
		vm.NetTransmit:     "net.transmit",
		vm.NetPacketIn:     "net.packetIn",
		vm.NetPacketOut:    "net.packetOut",
		vm.DiskUsedRate:    "disk.used_rate",
		vm.DiskReadBps:     "disk.vda.read",
		vm.DiskWriteBps:    "disk.vda.write",
		vm.DiskReadOps:     "disk.vdb.read",
		vm.DiskWriteOps:    "disk.vdb.write",
	}
)

var (
	GetTopDataErrorWithRegion = errors.New("获取top数据失败，因为区域信息错误")
)

```

File path: /Users/mac/Desktop/woker_code/monitor/modules/compute/model/monitor_tsdb_metrics.go
```golang
package model

import (
	"time"
)

type MonitorTsdbMetrics struct {
	ID           int       `gorm:"column:id;primary_key;AUTO_INCREMENT"`
	ProductLine  string    `gorm:"column:product_line;NOT NULL"`  // 产品线
	Code         string    `gorm:"column:code;NOT NULL"`          // 唯一标识
	Name         string    `gorm:"column:name;NOT NULL"`          // 中文名
	MetricPrefix string    `gorm:"column:metric_prefix;NOT NULL"` // metric前缀
	Unit         string    `gorm:"column:unit;NOT NULL;default:''"`
	CreatedAt    time.Time `gorm:"column:created_at;default:CURRENT_TIMESTAMP"`
	UpdatedAt    time.Time `gorm:"column:updated_at;default:CURRENT_TIMESTAMP"`
	DeletedAt    time.Time `gorm:"column:deleted_at"`
}

func (m *MonitorTsdbMetrics) TableName() string {
	return "monitor_tsdb_metrics"
}

```

File path: /Users/mac/Desktop/woker_code/monitor/modules/compute/model/monitor_top.go
```golang
package model

import (
	"time"

	"ezone.ksyun.com/ezone/luban/monitor/common/client/opentsdb"
)

// region + az + code 唯一
type MonitorTop struct {
	ID                 int        `gorm:"column:id;primary_key;AUTO_INCREMENT"`        // 主键
	ProductLine        string     `gorm:"column:product_line;NOT NULL"`                // 产品线
	Region             string     `gorm:"column:region;NOT NULL"`                      // 区域
	Az                 string     `gorm:"column:az;NOT NULL"`                          // 可用区
	Code               string     `gorm:"column:code;NOT NULL"`                        // top项的唯一标识
	Name               string     `gorm:"column:name;NOT NULL"`                        // 中文名
	HalfHour           []TopValue `gorm:"column:half_hour;serializer:json_str"`        // 0.5h top10数据
	HalfHourUpdateAt   time.Time  `gorm:"column:half_hour_update_at"`                  // 0.5h更新时间
	OneHour            []TopValue `gorm:"column:one_hour;serializer:json_str"`         // 1h top10数据
	OneHourUpdateAt    time.Time  `gorm:"column:one_hour_update_at"`                   // 1h更新时间
	ThreeHours         []TopValue `gorm:"column:three_hours;serializer:json_str"`      // 3h top10数据
	ThreeHoursUpdateAt time.Time  `gorm:"column:three_hours_update_at"`                // 3h更新时间
	OneDay             []TopValue `gorm:"column:one_day;serializer:json_str"`          // 1d top10数据
	OneDayUpdateAt     time.Time  `gorm:"column:one_day_update_at"`                    // 1d更新时间
	SevenDays          []TopValue `gorm:"column:seven_days;serializer:json_str"`       // 7d top10数据
	SevenDaysUpdateAt  time.Time  `gorm:"column:seven_days_update_at"`                 // 7d更新时间
	ThirtyDays         []TopValue `gorm:"column:thirty_days;serializer:json_str"`      // 30d top10数据
	ThirtyDaysUpdateAt time.Time  `gorm:"column:thirty_days_update_at"`                // 30d更新时间
	CreatedAt          time.Time  `gorm:"column:created_at;default:CURRENT_TIMESTAMP"` // 创建时间
	UpdatedAt          time.Time  `gorm:"column:updated_at;default:CURRENT_TIMESTAMP"` // 更新时间
	DeletedAt          time.Time  `gorm:"column:deleted_at"`                           // 删除时间
}

type TopValue struct {
	Id    string  //实例唯一id
	Name  string  //名称
	Value float64 //值
}

func (m *MonitorTop) TableName() string {
	return "monitor_top"
}

func (m *MonitorTop) ParseIntervalData(start, end int64) []TopValue {
	var intervalData []TopValue
	intervalStr := opentsdb.ParseTimeInterval(start, end)
	switch intervalStr {
	case "0.5h":
		intervalData = m.HalfHour
	case "1h":
		intervalData = m.OneHour
	case "3h":
		intervalData = m.ThreeHours
	case "1d":
		intervalData = m.OneDay
	case "7d":
		intervalData = m.SevenDays
	case "30d":
		intervalData = m.ThirtyDays
	}
	return intervalData
}

```

File path: /Users/mac/Desktop/woker_code/monitor/modules/compute/model/compute_pool.go
```golang
package model

type AggragateMonitor struct {
	Id                  int     `json:"id"`
	Name                string  `json:"name"`
	Region              string  `json:"region"`
	Az                  string  `json:"az"`
	VcpuTotal           float64 `json:"vcpuTotal"`
	VcpuAvaiLable       float64 `json:"vcpuAvaiLable"`
	VcpuUtilizationRate float64 `json:"vcpuUtilizationRate"`
	VcpuUsedTotal       float64 `json:"vcpuUsedTotal"`
	MemTotal            float64 `json:"memTotal"`
	MemAvaiLable        float64 `json:"memAvaiLable"`
	MemUtilizationRate  float64 `json:"memUtilizationRate"`
	MemUsedTotal        float64 `json:"memUsedTotal"`
	DiskUtilizationRate float64 `json:"diskUtilizationRate"`
	HostCount           int     `json:"hostCount"`
	VmCount             int     `json:"vmCount"`
	AlertCount          int     `json:"alertCount"`
	CreateTime          int64   `json:"createTime"` //秒级时间戳
}

// 临时用 后面玉冰姐写好了服务器接口 直接删掉
type Host struct {
	Id               string `json:"id"`
	Name             string `json:"name"`
	Status           string `json:"status"`
	ResourcePoolType string `json:"resourcePoolType"`
	ResourcePool     string `json:"resourcePool"`
	Service          string `json:"service"`
	Region           string `json:"region"`
	Az               string `json:"az"`
	Room             string `json:"room"`
	Rack             string `json:"rack"`
	//RackPosition     string `json:"rackPosition"`
	SN string `json:"sn"`
	IP string `json:"ip"`
}

```

File path: /Users/mac/Desktop/woker_code/monitor/modules/compute/service/compute_pool_test.go
```golang
package service

import (
	"context"
	"encoding/json"
	"testing"
	"time"

	"ezone.ksyun.com/ezone/luban/monitor/modules/compute/dao"
	"ezone.ksyun.com/ezone/luban/monitor/modules/compute/dto"
	"go.uber.org/mock/gomock"
)

func Test_computePoolService_OverviewAlert(t *testing.T) {
	ctrl := gomock.NewController(t)
	defer ctrl.Finish()

	type args struct {
		ctx context.Context
		par dto.ComputePoolOverviewAlertReq
	}
	tests := []struct {
		name string
		args args
	}{
		{
			name: "全部区域",
			args: args{
				ctx: context.Background(),
				par: dto.ComputePoolOverviewAlertReq{
					Region: "",
				},
			},
		},
		{
			name: "单region az",
			args: args{
				ctx: context.Background(),
				par: dto.ComputePoolOverviewAlertReq{
					Region: "cn-shanghai-2",
					Az:     "cn-shanghai-2a",
				},
			},
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			n := &computePoolService{
				Store: dao.NewComputeStore(),
			}
			got, err := n.OverviewAlert(tt.args.ctx, tt.args.par)

			t.Logf("Test Case: %s, Got: %v, Error: %v", tt.name, got, err)
		})
	}
}

func Test_computePoolService_OverviewMonitor(t *testing.T) {
	ctrl := gomock.NewController(t)
	defer ctrl.Finish()

	type args struct {
		ctx context.Context
		par dto.ComputePoolOverviewMonitorReq
	}
	tests := []struct {
		name string
		args args
	}{
		{
			name: "全部区域",
			args: args{
				ctx: context.Background(),
				par: dto.ComputePoolOverviewMonitorReq{
					Region: "",
				},
			},
		},
		{
			name: "单region az",
			args: args{
				ctx: context.Background(),
				par: dto.ComputePoolOverviewMonitorReq{
					Region: "cn-shanghai-2",
					Az:     "cn-shanghai-2a",
				},
			},
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			n := &computePoolService{
				Store: dao.NewMockComputeStore(),
			}
			got, err := n.OverviewMonitor(tt.args.ctx, tt.args.par)
			t.Logf("Test Case: %s, Got: %v, Error: %v", tt.name, got, err)
		})
	}
}

// 待后续修改
func Test_computePoolService_OverviewLine(t *testing.T) {
	ctrl := gomock.NewController(t)
	defer ctrl.Finish()

	type args struct {
		ctx context.Context
		par dto.ComputePoolOverviewLineReq
	}
	tests := []struct {
		name string
		args args
	}{
		{
			name: "单region az",
			args: args{
				ctx: context.Background(),
				par: dto.ComputePoolOverviewLineReq{
					Region: "cn-shanghai-2",
					Az:     "cn-shanghai-2a",
					// "vcpu_stock", "memory_stock", "memory_rate", "disk_rate"
					// vcpu_stock, memory_stock, memory_rate, disk_rate
					MetricName: "cpu_usage_rate",
					Start:      time.Now().Unix(),
					End:        time.Now().Add(3 * time.Second).Unix(),
				},
			},
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			n := &computePoolService{
				Store: dao.NewMockComputeStore(),
			}
			got, err := n.OverviewLine(tt.args.ctx, tt.args.par)
			jsonResult, err := json.Marshal(got)
			if err != nil {
				t.Errorf("Failed to marshal result to JSON: %v", err)
				return
			}

			t.Logf("OverviewLine result = %v", string(jsonResult))
		})
	}
}

func Test_computePoolService_List(t *testing.T) {
	ctrl := gomock.NewController(t)
	defer ctrl.Finish()

	type args struct {
		ctx context.Context
		par dto.ComputePoolListReq
	}
	tests := []struct {
		name string
		args args
	}{
		{
			name: "单region az",
			args: args{
				ctx: context.Background(),
				par: dto.ComputePoolListReq{
					Region: "cn-shanghai-2",
					Az:     []string{"cn-shanghai-2a"},
				},
			},
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			n := &computePoolService{
				Store: dao.NewMockComputeStore(),
			}
			got, err := n.List(tt.args.ctx, tt.args.par)
			jsonResult, err := json.Marshal(got)
			if err != nil {
				t.Errorf("Failed to marshal result to JSON: %v", err)
				return
			}

			t.Logf("ListComputePool result = %v", string(jsonResult))
		})
	}
}

```

File path: /Users/mac/Desktop/woker_code/monitor/modules/compute/service/vm.go
```golang
package service

import (
	"context"
	"fmt"
	"time"

	"ezone.ksyun.com/ezone/luban/communal/lib"
	pb "ezone.ksyun.com/ezone/luban/luban_api/resourceapis/resource_compute/v1alpha/gen"
	"ezone.ksyun.com/ezone/luban/monitor/common/client/opentsdb"
	"ezone.ksyun.com/ezone/luban/monitor/common/client/opentsdb/pkg"
	"ezone.ksyun.com/ezone/luban/monitor/common/consts"
	"ezone.ksyun.com/ezone/luban/monitor/common/tools"
	"ezone.ksyun.com/ezone/luban/monitor/common/tsdbql_template/vm"
	"ezone.ksyun.com/ezone/luban/monitor/common/types"
	"ezone.ksyun.com/ezone/luban/monitor/modules/compute/constant"
	"ezone.ksyun.com/ezone/luban/monitor/modules/compute/dao"
	"ezone.ksyun.com/ezone/luban/monitor/modules/compute/dto"
	"github.com/pkg/errors"
)

type VmService interface {
	OverviewMonitor(ctx context.Context, par dto.VmOverviewMonitorReq) (*dto.VmOverviewMonitorRsp, error)
	OverviewTop(ctx context.Context, par dto.VmOverviewTopReq) (*dto.VmOverviewTopRsp, error)
	DetailMetrics(ctx context.Context, par dto.VmDetailMetricsReq) (*dto.VmDetailMetricsRsp, error)
	DetailMetricLines(ctx context.Context, par dto.VmDetailMetricLinesReq) (*dto.VmDetailMetricLinesRsp, error)
}

type vmService struct {
	Store dao.Store
}

func NewVmService() VmService {
	return &vmService{
		Store: dao.NewComputeStore(),
	}
}

func (n *vmService) OverviewMonitor(ctx context.Context, par dto.VmOverviewMonitorReq) (*dto.VmOverviewMonitorRsp, error) {
	// grpc vm list
	var (
		rpcRes *pb.ListVmResult
		err    error
	)
	if par.Az != "" {
		rpcRes, err = n.Store.VmRpcClient().ListVm(ctx, &pb.ListVmReq{Region: par.Region, Az: []string{par.Az}, PageSize: -1})
	} else {
		rpcRes, err = n.Store.VmRpcClient().ListVm(ctx, &pb.ListVmReq{Region: par.Region, PageSize: -1})
	}
	if err != nil {
		return nil, err
	}

	rsp := &dto.VmOverviewMonitorRsp{}
	productSources := []string{consts.Platform, consts.Business}
	for _, ps := range productSources {
		// 记录云主机状态
		vmStatusCount := map[string]int{}
		sourceCount := 0
		for _, vm := range rpcRes.DataList {
			if vm.Source == ps {
				sourceCount += 1
				if vm.Status != "" {
					vmStatusCount[vm.Status] += 1
				}
			}

		}
		// 结果记录
		monitor := types.BasicOverviewSlot{
			// 云主机总量
			Info: types.BasicOverviewSlotInfo{
				Name:     ps,
				Value:    sourceCount,
				UnitType: "number",
				Unit:     "个",
			},
		}
		// 云主机状态
		for status, count := range vmStatusCount {
			monitor.Values = append(monitor.Values, types.BasicOverviewSlotValue{
				Name:     constant.VmStatusMap[status],
				Code:     status,
				Value:    count,
				Unit:     "个",
				UnitType: "number",
			},
			)
		}

		// 返回值
		if ps == consts.Platform {
			rsp.Platform = []types.BasicOverviewSlot{monitor}
		} else {
			rsp.Business = []types.BasicOverviewSlot{monitor}
		}
	}
	rsp.TotalCount = rpcRes.TotalCount
	return rsp, nil
}

func (n *vmService) OverviewTop(ctx context.Context, par dto.VmOverviewTopReq) (*dto.VmOverviewTopRsp, error) {
	tops := []types.BasicOverviewSlot{}
	for _, name := range par.Name {
		tsdbMetric, err := n.Store.Metric().GetOneByCode(name)
		if err != nil {
			return nil, errors.WithMessagef(err, "get tsdb metric %s err", name)
		}
		topData, err := n.Store.MetricTop().GetOneByCode(dao.QueryParams{
			Region: par.Region,
			Az:     par.Az,
			Code:   name,
		})
		if err != nil {
			return nil, constant.GetTopDataErrorWithRegion
		}
		intervalData := topData.ParseIntervalData(par.Start, par.End)
		//topK
		if par.TopK > 10 || par.TopK > len(intervalData) {
			return nil, fmt.Errorf("topK is too large")
		}
		intervalData = intervalData[:par.TopK]

		values := []types.BasicOverviewSlotValue{}
		for _, v := range intervalData {
			values = append(values, types.BasicOverviewSlotValue{
				Name:     v.Name,
				Code:     v.Id,
				Value:    v.Value,
				Unit:     tsdbMetric.Unit,
				UnitType: types.ParseUnitTypeByUnit(tsdbMetric.Unit),
				Kind:     types.KindInfo,
			})
		}

		slot := types.BasicOverviewSlot{
			Info: types.BasicOverviewSlotInfo{
				Index:       0,
				Name:        constant.VmMetricTopMap[name],
				Value:       0,
				UnitType:    types.ParseUnitTypeByUnit(tsdbMetric.Unit),
				Unit:        tsdbMetric.Unit,
				Kind:        types.KindInfo,
				Prognosis:   0,
				Description: "",
			},
			Values: values,
		}
		tops = append(tops, slot)
	}

	return &dto.VmOverviewTopRsp{
		Tops: tops,
	}, nil
}

func (n *vmService) DetailMetrics(ctx context.Context, par dto.VmDetailMetricsReq) (*dto.VmDetailMetricsRsp, error) {
	vmDetail, err := n.Store.VmRpcClient().DescribeVm(ctx, &pb.DescribeVmReq{Id: par.Id})
	if err != nil {
		return nil, err
	}
	// 通过 opentsdb queryLast 查询单点数据
	metrics := make([]types.BasicOverviewSlot, 0)
	for _, metric := range par.MetricName {
		subQueries := make([]pkg.SubQuery, 0)
		tsdbMetric, err := n.Store.Metric().GetOneByCode(metric)
		metricValue := types.BasicOverviewSlot{
			Info: types.BasicOverviewSlotInfo{
				Name:     metric,
				Unit:     tsdbMetric.Unit,
				UnitType: types.ParseUnitTypeByUnit(tsdbMetric.Unit),
				Kind:     types.KindInfo,
			},
		}
		if err != nil {
			lib.Log.TagError(lib.GetTraceContext(ctx), lib.DLTagResponseFailed, map[string]interface{}{"error": err.Error()})
			metrics = append(metrics, metricValue)
			continue
		}
		vmQuery := vm.ParseTsdbQuery(tsdbMetric.Code, tsdbMetric.MetricPrefix, par.Id)
		queryParam := pkg.QueryParam{
			Start: time.Now().Add(-24 * time.Hour).Unix(),
			End:   time.Now().Unix(),
		}
		switch metric {
		// 24h 处理 其余正常queryLast查询 查单点
		case vm.NetIn, vm.NetOut:
			subQueries = append(subQueries, pkg.SubQuery{
				Aggregator: "sum",
				Metric:     vmQuery.Metric,
				Tags:       vmQuery.Tags,
				Downsample: opentsdb.TimeToDownsample(time.Now().Unix() - time.Now().Add(-24*time.Hour).Unix()),
			})
			queryParam.Queries = subQueries
			queryResp, err := opentsdb.Query(ctx, vmDetail.Region, queryParam)
			if err != nil {
				lib.Log.TagError(lib.GetTraceContext(ctx), lib.DLTagResponseFailed, map[string]interface{}{"error": err.Error()})
				continue
			}
			var values []float64
			if len(queryResp.QueryRespCnts) > 0 {
				dataPoints := queryResp.QueryRespCnts[0].GetDataPoints()
				for _, v := range dataPoints {
					values = append(values, v.Value.(float64))
				}
			}
			metricValue = types.BasicOverviewSlot{
				Info: types.BasicOverviewSlotInfo{
					Name:     metric,
					Value:    tools.GetAvg(values),
					Unit:     tsdbMetric.Unit,
					UnitType: types.ParseUnitTypeByUnit(tsdbMetric.Unit),
					Kind:     types.KindInfo,
				},
			}
		case vm.CpuLoad, vm.MemoryLoad, vm.DiskLoad:
			queryParam := pkg.QueryParam{
				Start: time.Now().Add(-1 * time.Hour).Unix(),
				End:   time.Now().Unix(),
			}
			subQueries = append(subQueries, pkg.SubQuery{
				Aggregator: "sum",
				Metric:     vmQuery.Metric,
				Tags:       vmQuery.Tags,
				Downsample: opentsdb.TimeToDownsample(time.Now().Unix() - time.Now().Add(-1*time.Hour).Unix()),
			})
			queryParam.Queries = subQueries
			queryResp, err := opentsdb.Query(ctx, vmDetail.Region, queryParam)
			if err != nil {
				lib.Log.TagError(lib.GetTraceContext(ctx), lib.DLTagResponseFailed, map[string]interface{}{"error": err.Error()})
				continue
			}
			var values []float64
			if len(queryResp.QueryRespCnts) > 0 {
				dataPoints := queryResp.QueryRespCnts[0].GetDataPoints()
				for _, v := range dataPoints {
					values = append(values, v.Value.(float64))
				}
			}
			metricValue = types.BasicOverviewSlot{
				Info: types.BasicOverviewSlotInfo{
					Name:     metric,
					Value:    tools.GetAvg(values),
					Unit:     tsdbMetric.Unit,
					UnitType: types.ParseUnitTypeByUnit(tsdbMetric.Unit),
					Kind:     types.KindInfo,
				},
			}
			if tsdbMetric.Unit == "%" {
				metricValue.Info.UnitType = ""
			}
		case vm.DiskFree:
			queryParam := pkg.QueryParam{
				Start: time.Now().Add(-1 * time.Hour).Unix(),
				End:   time.Now().Unix(),
			}
			subQueries = append(subQueries, pkg.SubQuery{
				Aggregator: "sum",
				Metric:     vmQuery.Metric,
				Tags:       vmQuery.Tags,
				Downsample: opentsdb.TimeToDownsample(time.Now().Unix() - time.Now().Add(-1*time.Hour).Unix()),
			})
			queryParam.Queries = subQueries
			queryResp, err := opentsdb.Query(ctx, vmDetail.Region, queryParam)
			if err != nil {
				lib.Log.TagError(lib.GetTraceContext(ctx), lib.DLTagResponseFailed, map[string]interface{}{"error": err.Error()})
				continue
			}
			var values []float64
			if len(queryResp.QueryRespCnts) > 0 {
				dataPoints := queryResp.QueryRespCnts[0].GetDataPoints()
				for _, v := range dataPoints {
					values = append(values, v.Value.(float64))
				}
			}
			metricValue.Values = make([]types.BasicOverviewSlotValue, 1)
			metricValue.Values = append(metricValue.Values, types.BasicOverviewSlotValue{
				Name: "/",
				Code: "ext4",
			})
			if len(queryResp.QueryRespCnts) > 0 {
				metricValue.Values[0].Value = tools.GetAvg(values)
			}
		}

		metrics = append(metrics, metricValue)
	}
	return &dto.VmDetailMetricsRsp{
		Metrics: metrics,
	}, nil
}

func (n *vmService) DetailMetricLines(ctx context.Context, par dto.VmDetailMetricLinesReq) (*dto.VmDetailMetricLinesRsp, error) {
	vmDetail, err := n.Store.VmRpcClient().DescribeVm(ctx, &pb.DescribeVmReq{Id: par.Id})
	if err != nil {
		return nil, err
	}
	region := vmDetail.Region
	queryParam := pkg.QueryParam{
		Start: par.Start,
		End:   par.End,
	}
	lines := make([]types.BasicOverviewSlot, 0)
	for _, metric := range par.MetricName {
		subQueries := make([]pkg.SubQuery, 0)
		tsdbMetric, err := n.Store.Metric().GetOneByCode(metric)
		if err != nil {
			lib.Log.TagError(lib.GetTraceContext(ctx), lib.DLTagResponseFailed, map[string]interface{}{"error": err.Error()})
			continue
		}
		// 组装 Tag
		switch metric {
		case vm.DiskUsedRate:
			metricDir := vmDetail.MetricDir
			if len(metricDir) == 0 {
				metricDir = append(metricDir, "/")
			}
			for _, dir := range metricDir {
				tags := map[string]string{
					"host": vmDetail.Id,
					"p1":   dir,
					"p2":   "pused",
				}
				subQueries = append(subQueries, pkg.SubQuery{
					Aggregator: "sum",
					Metric:     "vfs.fs.size" + "." + par.Id,
					Tags:       tags,
					Downsample: opentsdb.TimeToDownsample(par.End - par.Start),
				})
			}
		default:
			vmQuery := vm.ParseTsdbQuery(tsdbMetric.Code, tsdbMetric.MetricPrefix, par.Id)
			subQueries = append(subQueries, pkg.SubQuery{
				Aggregator: "sum",
				Metric:     vmQuery.Metric,
				Tags:       vmQuery.Tags,
				Downsample: opentsdb.TimeToDownsample(par.End - par.Start),
			})
		}

		// 处理查询结果
		queryParam.Queries = subQueries
		queryResp, err := opentsdb.Query(ctx, region, queryParam)
		if err != nil {
			lib.Log.TagError(lib.GetTraceContext(ctx), lib.DLTagResponseFailed, map[string]interface{}{"error": err.Error()})
			continue
		}

		line := types.BasicOverviewSlot{
			Info: types.BasicOverviewSlotInfo{
				Name:     constant.VmMetricMap[metric],
				Unit:     tsdbMetric.Unit,
				UnitType: types.ParseUnitTypeByUnit(tsdbMetric.Unit),
				Kind:     types.KindInfo,
			},
		}
		if len(queryResp.QueryRespCnts) > 0 {
			dataPoints := queryResp.QueryRespCnts[0].GetDataPoints()
			var values []float64
			for index, v := range dataPoints {
				value := types.BasicOverviewSlotValue{
					Name:        fmt.Sprintf("%d", tools.UnixToUnixMilli(v.Timestamp)),
					Code:        metric,
					Value:       v.Value,
					Unit:        tsdbMetric.Unit,
					UnitType:    types.ParseUnitTypeByUnit(tsdbMetric.Unit),
					Kind:        types.KindInfo,
					Description: v.Metric,
				}
				if tsdbMetric.Unit == "%" {
					line.Info.UnitType = ""
					value.UnitType = ""
				}
				line.Values = append(line.Values, value)
				values = append(values, v.Value.(float64))
				if index == len(dataPoints)-1 {
					line.Info.Value = v.Value
				}
			}
			line.Info.Avg = tools.GetAvg(values)
			line.Info.Max = tools.GetMax(values)
			line.Info.Min = tools.GetMin(values)
		}
		lines = append(lines, line)
	}
	return &dto.VmDetailMetricLinesRsp{
		Lines: lines,
	}, nil
}

```

File path: /Users/mac/Desktop/woker_code/monitor/modules/compute/service/compute_pool.go
```golang
package service

import (
	"context"
	"fmt"
	"sort"
	"strconv"
	"time"

	"ezone.ksyun.com/ezone/luban/monitor/common/utils"
	computeutils "ezone.ksyun.com/ezone/luban/monitor/modules/compute/utils"

	"ezone.ksyun.com/ezone/luban/communal/lib"
	alarmv1alpha "ezone.ksyun.com/ezone/luban/luban_api/alarmapis/alarm/v1alpha/gen"
	resource_computev1alpha "ezone.ksyun.com/ezone/luban/luban_api/resourceapis/resource_compute/v1alpha/gen"
	resource_serverv1alpha "ezone.ksyun.com/ezone/luban/luban_api/resourceapis/resource_server/v1alpha/gen"
	prom_client "ezone.ksyun.com/ezone/luban/monitor/common/client/prom"
	"ezone.ksyun.com/ezone/luban/monitor/common/promql_template/compute"
	"ezone.ksyun.com/ezone/luban/monitor/common/promql_template/server"
	"ezone.ksyun.com/ezone/luban/monitor/common/tools"
	"ezone.ksyun.com/ezone/luban/monitor/common/types"
	"ezone.ksyun.com/ezone/luban/monitor/modules/compute/dao"
	"ezone.ksyun.com/ezone/luban/monitor/modules/compute/dto"
	"ezone.ksyun.com/ezone/luban/monitor/modules/compute/utils/convert"
	"github.com/pkg/errors"
	v1 "github.com/prometheus/client_golang/api/prometheus/v1"
)

var (
	alertLevels = []string{"p0", "p1", "p2", "p3"}
	alertKinds  = map[string]string{
		"p0": types.KindError,
		"p1": types.KindWarn,
		"p2": types.KindMinor,
		"p3": types.KindInfo,
	}
)

type ComputePoolService interface {
	OverviewAlert(ctx context.Context, par dto.ComputePoolOverviewAlertReq) (*dto.ComputePoolOverviewAlertRsp, error)
	OverviewMonitor(ctx context.Context, par dto.ComputePoolOverviewMonitorReq) (*dto.ComputePoolOverviewMonitorRsp, error)
	OverviewLine(ctx context.Context, par dto.ComputePoolOverviewLineReq) (*dto.ComputePoolOverviewLineRsp, error)
	List(ctx context.Context, par dto.ComputePoolListReq) (*dto.ComputePoolListRsp, error)
	DetailLine(ctx context.Context, par dto.ComputePoolDetailLineReq) (*dto.ComputePoolDetailLineRsp, error)
}

type computePoolService struct {
	Store dao.Store
}

func NewComputePoolService() ComputePoolService {
	return &computePoolService{
		Store: dao.NewComputeStore(),
	}
}

func NewMockComputePoolService() ComputePoolService {
	return &computePoolService{Store: dao.NewMockComputeStore()}
}

func (n *computePoolService) OverviewAlert(ctx context.Context, par dto.ComputePoolOverviewAlertReq) (*dto.ComputePoolOverviewAlertRsp, error) {
	var az []string
	if par.Az != "" {
		az = []string{par.Az}
	}
	alerts, err := n.Store.AlarmRpcClient().ListAlerts(ctx, &alarmv1alpha.ListAlertsRequest{
		PageNo:   -1,
		PageSize: -1,
		Status:   "firing",
		Region:   par.Region,
		Az:       az,
	})
	if err != nil {
		return nil, errors.WithMessage(err, "rpc call AlarmRpcClient.ListAlerts err")
	}
	// 概览数据
	alertSlots := []types.BasicOverviewSlot{}
	for _, level := range alertLevels {
		alertSlot := types.BasicOverviewSlot{
			Info: types.BasicOverviewSlotInfo{
				Index:       0,
				Name:        level,
				Value:       utils.CountAlertsNum(alerts.Items, "kec", level),
				UnitType:    types.TypeNumber,
				Unit:        "个",
				Kind:        alertKinds[level],
				Prognosis:   0,
				Description: "",
			},
		}
		alertSlots = append(alertSlots, alertSlot)
	}
	return &dto.ComputePoolOverviewAlertRsp{
		Alerts: alertSlots,
	}, nil
}

func (n *computePoolService) OverviewMonitor(ctx context.Context, par dto.ComputePoolOverviewMonitorReq) (*dto.ComputePoolOverviewMonitorRsp, error) {
	// computePool grpc
	computePoolRpcRes, err := n.Store.ComputePoolRpcClient().ListComputePool(ctx, &resource_computev1alpha.ListComputePoolReq{
		Region: par.Region,
		Az:     []string{par.Az},
	})
	if par.Az == "" {
		computePoolRpcRes, err = n.Store.ComputePoolRpcClient().ListComputePool(ctx, &resource_computev1alpha.ListComputePoolReq{
			Region: par.Region,
		})
	}
	if err != nil {
		lib.Log.TagError(lib.GetTraceContext(ctx), lib.DLTagHTTPFailed, map[string]interface{}{"error": err.Error()})
		return nil, err
	}

	// 服务器监控信息
	upCount, downCount, err := n.fetchServerStatus(ctx, computePoolRpcRes)
	if err != nil {
		lib.Log.TagError(lib.GetTraceContext(ctx), lib.DLTagHTTPFailed, map[string]interface{}{"error": err.Error()})
		return nil, err
	}

	monitors := []types.BasicOverviewSlot{}
	monitorUp := types.BasicOverviewSlot{
		Info: types.BasicOverviewSlotInfo{
			Name:        "up",
			Value:       upCount,
			UnitType:    types.TypeNumber,
			Unit:        "个",
			Kind:        types.KindSuccess,
			Description: "服务器监控状态-监控中",
		},
	}
	monitorDown := types.BasicOverviewSlot{
		Info: types.BasicOverviewSlotInfo{
			Name:        "down",
			Value:       downCount,
			UnitType:    types.TypeNumber,
			Unit:        "个",
			Kind:        types.KindError,
			Description: "服务器监控状态-监控异常",
		},
	}
	monitors = append(monitors, monitorUp, monitorDown)
	return &dto.ComputePoolOverviewMonitorRsp{
		Monitors: monitors,
	}, nil
}

func (n *computePoolService) fetchServerStatus(ctx context.Context, rpcRes *resource_computev1alpha.ListComputePoolResult) (upCount int, downCount int, err error) {
	aggregates := rpcRes.DataList
	ipList := []string{}
	promIpList := []string{}
	for _, aggregate := range aggregates {
		// 每个资源池下的 服务器
		ListPhysicalServerRes, err := n.Store.ServerRpcClient().PhysicalServerList(ctx, &resource_serverv1alpha.PhysicalHostListRequest{
			PageSize:         -1,
			Region:           aggregate.Region,
			ResourcePoolName: aggregate.Name,
			ResourcePoolType: []string{"kec"},
		})
		if err != nil {
			lib.Log.TagError(lib.GetTraceContext(ctx), lib.DLTagHTTPFailed, map[string]interface{}{"error": err.Error()})
			continue
		}
		for _, physicalServer := range ListPhysicalServerRes.PhysicalServerHostList {
			ipList = append(ipList, physicalServer.ManageIp)
			promIpList = append(promIpList, physicalServer.ManageIp+":9100")
		}
	}
	rsp, err := n.Store.AlarmRpcClient().ListPromQLs(ctx, server.TemplateMap[server.Status](promIpList))
	if err != nil {
		return 0, 0, err
	}
	promQL := rsp.Items[0].RealPromql

	// prometheus
	up, err := prom_client.VectorQuery(ctx, promQL)
	if err != nil {
		return 0, 0, err
	}
	serverMonitorUpStatusMap := prom_client.ParseServerMonitoringStatus(up)
	for _, ip := range ipList {
		if serverMonitorUpStatusMap[ip] == "up" {
			upCount += 1
		} else {
			downCount += 1
		}
	}
	return upCount, downCount, nil
}

func (n *computePoolService) OverviewLine(ctx context.Context, par dto.ComputePoolOverviewLineReq) (*dto.ComputePoolOverviewLineRsp, error) {
	// computePool grpc
	computePoolRpcRes, err := n.Store.ComputePoolRpcClient().ListComputePool(ctx, &resource_computev1alpha.ListComputePoolReq{
		PageSize: -1,
		Region:   par.Region,
		Az:       []string{par.Az},
	})
	if par.Az == "" {
		computePoolRpcRes, err = n.Store.ComputePoolRpcClient().ListComputePool(ctx, &resource_computev1alpha.ListComputePoolReq{
			PageSize: -1,
			Region:   par.Region,
		})
	}
	if err != nil {
		lib.Log.TagError(lib.GetTraceContext(ctx), lib.DLTagHTTPFailed, map[string]interface{}{"error": err.Error()})
		return nil, err
	}
	lines := make([]types.BasicOverviewSlot, 0)
	// 带预测值
	predictionMetrics := []string{compute.VCpuStock, compute.MemoryStock}
	for _, computePool := range computePoolRpcRes.DataList {
		rsp, err := n.Store.AlarmRpcClient().ListPromQLs(ctx, compute.TemplateMap[par.MetricName](computePool.Region, computePool.Az, computePool.Name))
		if err != nil {
			lib.Log.TagError(lib.GetTraceContext(ctx), lib.DLTagResponseFailed, map[string]interface{}{"error": err.Error()})
		}
		promQL := rsp.Items[0].RealPromql
		unit := rsp.Items[0].Unit
		matrix, err := prom_client.MatrixQuery(ctx, promQL, v1.Range{
			Start: time.UnixMilli(par.Start),
			End:   time.UnixMilli(par.End),
			Step:  prom_client.TimeToStep(par.End - par.Start),
		})

		if err != nil {
			lib.Log.TagError(lib.GetTraceContext(ctx), lib.DLTagResponseFailed, map[string]interface{}{"error": err.Error()})
		}
		// 封装结果
		line := types.BasicOverviewSlot{
			Info: types.BasicOverviewSlotInfo{
				Index:       0,
				Name:        computePool.Name,
				Value:       0,
				UnitType:    types.ParseUnitTypeByUnit(unit),
				Unit:        unit,
				Kind:        types.KindInfo,
				Prognosis:   0, //预测值，values的下标，0则无预测值
				Description: "",
			},
		}
		for _, m := range matrix {
			for _, p := range m.Values {
				timeStamp := p.Timestamp
				value := p.Value
				line.Values = append(line.Values, types.BasicOverviewSlotValue{
					Name:        timeStamp.String(),
					Code:        par.MetricName,
					Value:       value,
					Unit:        unit,
					UnitType:    types.ParseUnitTypeByUnit(unit),
					Kind:        types.KindInfo,
					Description: "",
				})
			}
		}
		var predictSql string
		start, end := par.Start/1e3, par.End/1e3
		step := computeutils.TimeToStepForInt(end - start)
		predictStart, predictEnd := end, end+(end-start)
		// 添加预测分析
		if par.HasPrediction && tools.Contains(predictionMetrics, par.MetricName) != -1 {
			line.Info.Prognosis = len(line.Values)
			rangeDuration := strconv.FormatInt(3*(end-start), 10)
			predictDuration := strconv.FormatInt(end-start, 10)
			switch par.MetricName {
			case compute.VCpuStock:
				predictSql = compute.GetPredictVCpuStock(computePool.Name, "kec", rangeDuration+"s", predictDuration)
			case compute.MemoryStock:
				predictSql = compute.GetPredictMemoryStock(computePool.Name, "kec", rangeDuration+"s", predictDuration)
			}
			predictMatrix, err := prom_client.MatrixQuery(ctx, predictSql, v1.Range{
				Start: time.Unix(predictStart, 0),
				End:   time.Unix(predictEnd, 0),
				Step:  time.Duration(step) * time.Second,
			})

			if err != nil {
				fmt.Printf("Error querying Prometheus predictMatrix: %v\n", err)
			}
			for _, m := range predictMatrix {
				for _, p := range m.Values {
					timeStamp := p.Timestamp
					value := p.Value
					line.Values = append(line.Values, types.BasicOverviewSlotValue{
						Name:        timeStamp.String(),
						Value:       value,
						Unit:        unit,
						UnitType:    types.ParseUnitTypeByUnit(unit),
						Kind:        "",
						Description: "预测数据",
					})
				}
				break
			}
		}
		lines = append(lines, line)
	}
	return &dto.ComputePoolOverviewLineRsp{
		Lines: lines,
	}, nil
}

func (n *computePoolService) List(ctx context.Context, par dto.ComputePoolListReq) (*dto.ComputePoolListRsp, error) {
	// computePool grpc
	computePoolRpcRes, err := n.Store.ComputePoolRpcClient().ListComputePool(ctx, &resource_computev1alpha.ListComputePoolReq{
		Region:   par.Region,
		Az:       par.Az,
		PageNo:   int32(par.PageNo),
		PageSize: int32(par.PageSize),
		Query:    par.Query,
	})
	if err != nil {
		lib.Log.TagError(lib.GetTraceContext(ctx), lib.DLTagHTTPFailed, map[string]interface{}{"error": err.Error()})
		return nil, err
	}
	computePoolList := computePoolRpcRes.DataList
	res := &dto.ComputePoolListRsp{
		TotalCount: int(computePoolRpcRes.TotalCount),
		PageNo:     int(computePoolRpcRes.PageNo),
		PageSize:   int(computePoolRpcRes.PageSize),
		DataList:   make([]*dto.ComputePoolMonitor, 0),
	}
	for _, computePool := range computePoolList {
		serverList, err := n.Store.ServerRpcClient().PhysicalServerList(ctx, &resource_serverv1alpha.PhysicalHostListRequest{
			PageSize:         -1,
			Region:           computePool.Region,
			ResourcePoolName: computePool.Name,
			ResourcePoolType: []string{"kec"},
		})
		if err != nil {
			return nil, errors.WithMessage(err, "rpc call ServerRpcClient.PhysicalServerList err")
		}
		cpuTotal, err := n.ComputePoolServerVector(ctx, serverList, server.CpuTotal)
		if err != nil {
			return nil, errors.WithMessage(err, "rpc call computePoolVector err")
		}
		cpuRate, err := n.ComputePoolVector(ctx, computePool.Region, computePool.Az, computePool.Name, compute.CpuRate)
		if err != nil {
			return nil, errors.WithMessage(err, "rpc call computePoolVector err")
		}
		memoryTotal, err := n.ComputePoolServerVector(ctx, serverList, server.MemTotal)
		if err != nil {
			return nil, errors.WithMessage(err, "rpc call computePoolVector err")
		}
		memoryTotal = memoryTotal / 1024 / 1024 / 1024
		memoryRate, err := n.ComputePoolVector(ctx, computePool.Region, computePool.Az, computePool.Name, compute.MemoryRate)
		if err != nil {
			return nil, errors.WithMessage(err, "rpc call computePoolVector err")
		}
		diskRate, err := n.ComputePoolVector(ctx, computePool.Region, computePool.Az, computePool.Name, compute.DiskRate)
		if err != nil {
			return nil, errors.WithMessage(err, "rpc call computePoolVector err")
		}
		// 告警数量
		alertRpcRes, err := n.Store.AlarmRpcClient().ListAlerts(ctx, &alarmv1alpha.ListAlertsRequest{
			Region:          computePool.Region,
			Az:              []string{computePool.Az},
			Level:           alertLevels,
			ResourceType:    []string{"resourcePool"},
			ResourceSubType: []string{"kec"},
			SearchKey:       "resource",
			SearchValue:     computePool.Name,
			Status:          "firing",
		})
		alertCount := alertRpcRes.Total
		res.DataList = append(res.DataList, &dto.ComputePoolMonitor{
			Id:              computePool.Id,
			Name:            computePool.Name,
			Region:          computePool.Region,
			Az:              computePool.Az,
			CpuTotal:        int(cpuTotal),
			CpuRemain:       int(cpuTotal) - int(cpuTotal*cpuRate),
			CpuRate:         convert.Decimal(cpuRate) * 100,
			CpuUsedTotal:    int(cpuTotal * cpuRate),
			MemoryTotal:     convert.Decimal(memoryTotal),
			MemoryRemain:    convert.Decimal(memoryTotal - memoryTotal*memoryRate),
			MemoryRate:      convert.Decimal(memoryRate) * 100,
			MemoryUsedTotal: convert.Decimal(memoryTotal * memoryRate),
			DiskRate:        convert.Decimal(diskRate) * 100, // 磁盘使用率
			HostCount:       int(computePool.HostCount),
			VmCount:         int(computePool.VmCount),
			AlertCount:      int(alertCount),
			CreateTime:      computePool.CreatedAt.AsTime(),
			PType:           computePool.PType,
		})
	}
	// 排序最终结果
	switch par.OrderCode {
	case "CpuRate":
		sort.Slice(res.DataList, func(i, j int) bool {
			if par.OrderType == "ASC" {
				return res.DataList[i].CpuRate < res.DataList[j].CpuRate
			} else {
				return res.DataList[i].CpuRate > res.DataList[j].CpuRate
			}
		})
	case "MemoryRate":
		sort.Slice(res.DataList, func(i, j int) bool {
			if par.OrderType == "ASC" {
				return res.DataList[i].MemoryRate < res.DataList[j].MemoryRate
			} else {
				return res.DataList[i].MemoryRate > res.DataList[j].MemoryRate
			}
		})
	case "DiskRate":
		sort.Slice(res.DataList, func(i, j int) bool {
			if par.OrderType == "ASC" {
				return res.DataList[i].DiskRate < res.DataList[j].DiskRate
			} else {
				return res.DataList[i].DiskRate > res.DataList[j].DiskRate
			}
		})
	}
	// 排序规则 diskRate
	return res, nil
}

func (n *computePoolService) ComputePoolServerVector(ctx context.Context, serverList *resource_serverv1alpha.ListPhysicalHostResponse, metricName string) (float64, error) {
	promIpList := []string{}
	for _, s := range serverList.PhysicalServerHostList {
		promIpList = append(promIpList, s.ManageIp+":9100")
	}

	//查alarm获取promql
	promQlReq := server.TemplateMap[metricName](promIpList)
	rsp, err := n.Store.AlarmRpcClient().ListPromQLs(ctx, promQlReq)
	if err != nil {
		return 0, errors.WithMessagef(err, "rpc call ListPromQLs err, req: %+v", promQlReq)
	}
	if rsp == nil || len(rsp.Items) < 1 {
		return 0, err
	}
	promQL := rsp.Items[0].RealPromql
	fmt.Println("real promQL: ", promQL)

	//查Prometheus
	matrix, err := prom_client.VectorQuery(ctx, promQL)
	if err != nil {
		return 0, errors.WithMessage(err, "prom_client VectorQuery err")
	}
	var res float64
	if len(matrix) > 0 {
		for _, v := range matrix {
			res += float64(v.Value)
		}
		res = res / float64(len(matrix))
	}
	return res, nil
}

func (n *computePoolService) ComputePoolVector(ctx context.Context, region, az, computePoolName, metricName string) (float64, error) {
	//查alarm获取promql
	promQlReq := compute.TemplateMap[metricName](region, az, computePoolName)
	rsp, err := n.Store.AlarmRpcClient().ListPromQLs(ctx, promQlReq)
	if err != nil {
		return 0, errors.WithMessagef(err, "rpc call ListPromQLs err, req: %+v", promQlReq)
	}
	if rsp == nil || len(rsp.Items) < 1 {
		return 0, err
	}
	promQL := rsp.Items[0].RealPromql
	fmt.Println("real promQL: ", promQL)

	//查Prometheus
	matrix, err := prom_client.VectorQuery(ctx, promQL)
	if err != nil {
		return 0, errors.WithMessage(err, "prom_client VectorQuery err")
	}
	var res float64
	if len(matrix) > 0 {
		for _, v := range matrix {
			res += float64(v.Value)
		}
		res = res / float64(len(matrix))
	}
	res, _ = strconv.ParseFloat(fmt.Sprintf("%.2f", res), 64)
	return res, nil
}

func (n *computePoolService) DetailLine(ctx context.Context, par dto.ComputePoolDetailLineReq) (*dto.ComputePoolDetailLineRsp, error) {
	// 对应资源池服务器列表
	serverList, err := n.Store.ServerRpcClient().PhysicalServerList(ctx, &resource_serverv1alpha.PhysicalHostListRequest{
		PageSize:         -1,
		Region:           par.Region,
		ResourcePoolName: par.Name,
	})
	if err != nil {
		return nil, errors.WithMessage(err, "rpc call ServerRpcClient.PhysicalServerList err")
	}

	lines := []types.BasicOverviewSlot{}
	for _, physicalServer := range serverList.PhysicalServerHostList {
		//查alarm获取promql
		promIpList := []string{physicalServer.ManageIp + ":9100"}
		promReq := server.TemplateMap[par.MetricName](promIpList)
		rsp, err := n.Store.AlarmRpcClient().ListPromQLs(ctx, promReq)
		if err != nil {
			return nil, errors.WithMessage(err, "rpc call AlarmRpcClient.ListPromQLs err")
		}
		if rsp == nil || len(rsp.Items) < 1 {
			return nil, errors.New("rpc call AlarmRpcClient.ListPromQLs rsp err")
		}
		promQL := rsp.Items[0].RealPromql
		unit := rsp.Items[0].Unit

		//查Prometheus
		matrix, err := prom_client.MatrixQuery(ctx, promQL, v1.Range{
			Start: time.UnixMilli(par.Start),
			End:   time.UnixMilli(par.End),
			Step:  prom_client.TimeToStep(par.End - par.Start),
		})
		if err != nil {
			return nil, errors.WithMessage(err, "prom_client MatrixQuery err")
		}

		//封装结果数据
		line := types.BasicOverviewSlot{
			Info: types.BasicOverviewSlotInfo{
				Index:       0,
				Name:        physicalServer.HostName,
				Value:       0,
				UnitType:    types.ParseUnitTypeByUnit(unit),
				Unit:        unit,
				Kind:        types.KindInfo,
				Prognosis:   0,
				Description: "",
			},
		}
		for _, m := range matrix {
			for _, p := range m.Values {
				timeStamp := tools.UnixToUnixMilli(p.Timestamp.Unix())
				value := p.Value
				line.Values = append(line.Values, types.BasicOverviewSlotValue{
					Name:        strconv.Itoa(int(timeStamp)),
					Code:        par.MetricName,
					Value:       value,
					UnitType:    types.ParseUnitTypeByUnit(unit),
					Unit:        unit,
					Kind:        types.KindInfo,
					Description: "",
				})
			}
		}
		lines = append(lines, line)
	}

	return &dto.ComputePoolDetailLineRsp{
		Lines: lines,
	}, nil
}

```

File path: /Users/mac/Desktop/woker_code/monitor/modules/compute/service/vm_test.go
```golang
package service

import (
	"context"
	"encoding/json"
	"testing"
	"time"

	"ezone.ksyun.com/ezone/luban/monitor/modules/compute/dao"
	"ezone.ksyun.com/ezone/luban/monitor/modules/compute/dto"
	"go.uber.org/mock/gomock"
)

func Test_vmService_OverviewMonitor(t *testing.T) {
	ctrl := gomock.NewController(t)
	defer ctrl.Finish()

	type args struct {
		ctx context.Context
		par dto.VmOverviewMonitorReq
	}
	tests := []struct {
		name string
		args args
	}{
		{
			name: "全部区域",
			args: args{
				ctx: context.Background(),
				par: dto.VmOverviewMonitorReq{
					Region: "",
				},
			},
		},
		{
			name: "单region az",
			args: args{
				ctx: context.Background(),
				par: dto.VmOverviewMonitorReq{
					Region: "cn-shanghai-2",
					Az:     "cn-shanghai-2a",
				},
			},
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			n := &vmService{
				Store: dao.NewMockComputeStore(),
			}
			got, err := n.OverviewMonitor(tt.args.ctx, tt.args.par)

			jsonResult, err := json.Marshal(got)
			if err != nil {
				t.Errorf("Failed to marshal result to JSON: %v", err)
				return
			}

			t.Logf("OverviewMonitor result = %v", string(jsonResult))
		})
	}
}

func Test_vmService_OverviewTop(t *testing.T) {
	ctrl := gomock.NewController(t)
	defer ctrl.Finish()

	type args struct {
		ctx context.Context
		par dto.VmOverviewTopReq
	}
	tests := []struct {
		name string
		args args
	}{
		{
			name: "全部区域",
			args: args{
				ctx: context.Background(),
				par: dto.VmOverviewTopReq{
					Region: "",
					Az:     "",
					Name:   []string{"vm_disk_load"},
					Start:  time.Now().Add(-time.Hour).UnixMilli(),
					End:    time.Now().UnixMilli(),
					TopK:   5,
				},
			},
		},
		{
			name: "单region az",
			args: args{
				ctx: context.Background(),
				par: dto.VmOverviewTopReq{
					Region: "cn-shanghai-2",
					Az:     "cn-shanghai-2a",
					Name:   []string{"vm_net_in"},
					Start:  time.Now().Add(-time.Hour).UnixMilli(),
					End:    time.Now().UnixMilli(),
					TopK:   5,
				},
			},
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			n := &vmService{
				Store: dao.NewMockComputeStore(),
			}
			got, err := n.OverviewTop(tt.args.ctx, tt.args.par)

			jsonResult, err := json.Marshal(got)
			if err != nil {
				t.Errorf("Failed to marshal result to JSON: %v", err)
				return
			}

			t.Logf("OverviewTop result = %v", string(jsonResult))
		})
	}
}

func Test_vmService_DetailMetrics(t *testing.T) {
	ctrl := gomock.NewController(t)
	defer ctrl.Finish()

	type args struct {
		ctx context.Context
		par dto.VmDetailMetricsReq
	}
	tests := []struct {
		name string
		args args
	}{
		{
			name: "test01",
			args: args{
				ctx: context.Background(),
				par: dto.VmDetailMetricsReq{
					Id:         "171c7bba-f23e-42cb-a446-29f757cf3c81",
					MetricName: []string{"vm_cpu_load", "vm_memory_load", "vm_disk_load", "vm_disk_free"},
				},
			},
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			n := &vmService{
				Store: dao.NewMockComputeStore(),
			}
			got, err := n.DetailMetrics(tt.args.ctx, tt.args.par)

			jsonResult, err := json.Marshal(got)
			if err != nil {
				t.Errorf("Failed to marshal result to JSON: %v", err)
				return
			}

			t.Logf("DetailMetics result = %v", string(jsonResult))
		})
	}
}

func Test_vmService_DetailMetricLines(t *testing.T) {
	ctrl := gomock.NewController(t)
	defer ctrl.Finish()

	type args struct {
		ctx context.Context
		par dto.VmDetailMetricLinesReq
	}
	tests := []struct {
		name string
		args args
	}{
		{
			name: "test01",
			args: args{
				ctx: context.Background(),
				par: dto.VmDetailMetricLinesReq{
					Id:    "32f3bf85-497e-45d4-98dd-480f7a3c598b",
					Start: time.Now().Add(-time.Hour).UnixMilli(),
					End:   time.Now().UnixMilli(),
					MetricName: []string{
						"vm_disk_used_rate",
					},
				},
				/* ----- 目前所需参数 -------
				CPU平均负载
				vm_cpu_mode_system 			可以
				vm_cpu_mode_user 			可以
				vm_cpu_mode_soft_irq 		通的	云监控没数据
				vm_cpu_mode_irq  irq 		看着没对应tag
				vm_cpu_mode_io_wait 		iowait 没对应tag
				vm_cpu_mode_idle 			通的	云监控没数据
				vm_cpu_mode_nice nice 		nice 没对应tag
				vm_cpu_mode_steal 			通的 云监控没对应数据

				内存容量
				vm_memory_size_total 		可以
				vm_memory_size_free 		通的 云监控没数据

				网卡出入流量(eth0)
				vm_net_transmit 		    目前来看可以
				vm_net_receive

				网卡出入包(eth0)
				vm_net_packet_in 			通的 云监控没数据
				vm_net_packet_out 			可以

				磁盘使用率
				vm_disk_used_rate 			通的 云监控无数据

				磁盘读写带宽
				vm_disk_read_bps			vdd & vda 问题处理 暂时不清晰原代码所写逻辑 先按vda算
				vm_disk_write_bps

				磁盘IO
				disk_read_ops  				通的 云监控没数据	vda
				disk_write_ops 				通的 云监控没数据
				*/
			},
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			n := &vmService{
				Store: dao.NewMockComputeStore(),
			}
			got, err := n.DetailMetricLines(tt.args.ctx, tt.args.par)

			jsonResult, err := json.Marshal(got)
			if err != nil {
				t.Errorf("Failed to marshal result to JSON: %v", err)
				return
			}

			t.Logf("DetailMetricLines result = %v", string(jsonResult))
		})
	}
}

```

File path: /Users/mac/Desktop/woker_code/monitor/modules/compute/rpc/rpcserver.go
```golang
package rpc

import (
	pb "ezone.ksyun.com/ezone/luban/luban_api/monitorapis/compute/v1alpha/gen"
	"ezone.ksyun.com/ezone/luban/monitor/modules/compute/service"
)

type ComputeRpcServer struct {
	computePoolSvc service.ComputePoolService
	pb.UnimplementedComputePoolServiceServer
}

func NewComputeRpcServer() *ComputeRpcServer {
	return &ComputeRpcServer{
		computePoolSvc: service.NewComputePoolService(),
	}
}

```

File path: /Users/mac/Desktop/woker_code/monitor/modules/compute/rpc/compute_pool_test.go
```golang
package rpc

import (
	"context"
	"reflect"
	"testing"

	monitor_computev1alpha "ezone.ksyun.com/ezone/luban/luban_api/monitorapis/compute/v1alpha/gen"
	"ezone.ksyun.com/ezone/luban/monitor/modules/compute/service"
)

func TestComputeRpcServer_ComputePoolList(t *testing.T) {
	type fields struct {
		computePoolSvc                        service.ComputePoolService
		UnimplementedComputePoolServiceServer monitor_computev1alpha.UnimplementedComputePoolServiceServer
	}
	type args struct {
		ctx context.Context
		req *monitor_computev1alpha.ComputePoolListReq
	}
	tests := []struct {
		name    string
		fields  fields
		args    args
		want    *monitor_computev1alpha.ComputePoolListRsp
		wantErr bool
	}{
		{
			name: "TestComputePoolList",
			fields: fields{
				computePoolSvc: service.NewMockComputePoolService(),
			},
			args: args{
				ctx: context.Background(),
				req: &monitor_computev1alpha.ComputePoolListReq{
					Region: "cn-shanghai-2",
					Query:  make(map[string]string, 1),
				},
			},
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			n := &ComputeRpcServer{
				computePoolSvc:                        tt.fields.computePoolSvc,
				UnimplementedComputePoolServiceServer: tt.fields.UnimplementedComputePoolServiceServer,
			}
			got, err := n.ComputePoolList(tt.args.ctx, tt.args.req)
			if (err != nil) != tt.wantErr {
				t.Errorf("ComputePoolList() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if !reflect.DeepEqual(got, tt.want) {
				t.Errorf("ComputePoolList() got = %v, want %v", got, tt.want)
			}
		})
	}
}

```

File path: /Users/mac/Desktop/woker_code/monitor/modules/compute/rpc/compute_pool.go
```golang
package rpc

import (
	"context"

	"ezone.ksyun.com/ezone/luban/communal/lib"
	pb "ezone.ksyun.com/ezone/luban/luban_api/monitorapis/compute/v1alpha/gen"
	"ezone.ksyun.com/ezone/luban/monitor/modules/compute/dto"
	"github.com/jinzhu/copier"
	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/status"
)

func (n *ComputeRpcServer) ComputePoolList(ctx context.Context, req *pb.ComputePoolListReq) (*pb.ComputePoolListRsp, error) {
	lib.Log.TagInfo(lib.GetTraceContext(ctx), lib.DLTagRequestIn, map[string]interface{}{"params": req})
	var par dto.ComputePoolListReq
	copier.Copy(&par, req)
	res, err := n.computePoolSvc.List(ctx, par)
	if err != nil {
		lib.Log.TagError(lib.GetTraceContext(ctx), lib.DLTagUndefind, map[string]interface{}{"list err": err})
		return nil, status.Error(codes.Internal, err.Error())
	}
	resp := &pb.ComputePoolListRsp{}
	copier.Copy(&resp, res)
	return resp, nil
}

```

File path: /Users/mac/Desktop/woker_code/monitor/modules/switch/dto/response.go
```golang
package dto

import (
	"ezone.ksyun.com/ezone/luban/monitor/common/types"
)

type SwitchOverviewAlertRsp struct {
	Alerts []types.BasicOverviewSlot `json:"Alerts"`
}

type SwitchOverviewMonitorRsp struct {
	MonitoringStatus   []types.BasicOverviewSlot `json:"MonitoringStatus"`
	InterfaceStatus    []types.BasicOverviewSlot `json:"InterfaceStatus"`
	HardwareMonitoring []types.BasicOverviewSlot `json:"HardwareMonitoring"`
}

type SwitchCPU struct {
	Name        string  `json:"Name"`
	Health      int     `json:"Health"` //1:健康；2：告警；3：故障；0：未知
	Utilization float64 `json:"Utilization"`
	Temperature int     `json:"Temperature"`
	CPUType     string  `json:"CpuType"`
	MainHertz   float64 `json:"MainHertz"`
	MaxHertz    float64 `json:"MaxHertz"`
	CacheLv     int     `json:"CacheLv"` //1：1级；2：2级；3：3级
}

type SwitchMemory struct {
	Name        string  `json:"name"`
	Health      int     `json:"health"` //1:健康；2：告警；3：故障；0：未知
	Utilization float64 `json:"utilization"`
	Exist       bool    `json:"exist"` //false:不在位；true：在位
	Location    string  `json:"location"`
	Tunnel      string  `json:"tunnel"`
	SlotNum     string  `json:"slotNum"`
	MemType     string  `json:"memType"`
	Ranks       string  `json:"ranks"`
	BitWide     int     `json:"bitWide"`
	MaxHertz    float64 `json:"maxHertz"`
	Capacity    int     `json:"capacity"`
	Technology  string  `json:"technology"`
	MfgName     string  `json:"mfgName"`
	SerialNum   string  `json:"serialNum"`
	PartNum     string  `json:"partNum"`
}

type SwitchOverviewTopRsp struct {
	Tops []types.BasicOverviewSlot
}

type SwitchListRsp struct {
	TotalCount int64
	PageNo     int
	PageSize   int
	SwitchList []SwitchList `json:"SwitchList"`
}

type SwitchList struct {
	Id          int32   `json:"Id"`
	Name        string  `json:"Name"`
	RunStatus   string  `json:"RunStatus"`
	SnmpStatus  string  `json:"SnmpStatus"`
	Region      string  `json:"Region"`
	Az          string  `json:"Az"`
	Lab         string  `json:"Lab"`
	Sn          string  `json:"Sn"`
	Ip          string  `json:"Ip"`
	OutBindIp   string  `json:"OutBindIp"`
	ErrPortNum  int32   `json:"ErrPortNum"`
	CpuErrNum   int     `json:"CpuErrNum"`
	CpuLoad     float64 `json:"CpuLoad"`
	MemErrNum   int     `json:"MemErrNum"`
	MemLoad     float64 `json:"MemLoad"`
	DiskErrNum  int     `json:"DiskErrNum"`
	DiskLoad    float64 `json:"DiskLoad"`
	Power       string  `json:"Power"`
	AlertNumber int     `json:"AlertNumber"`
	Tag         string  `json:"Tag"`
}

type SwitchDetailsOverviewRsp struct {
	DetailsOverview []types.BasicOverviewSlot `json:"DetailsOverview"`
	InterfaceStatus []types.BasicOverviewSlot `json:"InterfaceStatus"`
}

type SwitchDetailsOverviewLineRsp struct {
	Lines []types.BasicOverviewSlot `json:"Lines"`
}

type SwitchHardwareRsp struct {
	InTemp        []types.BasicOverviewSlot `json:"InTemp"`
	OutTemp       []types.BasicOverviewSlot `json:"OutTemp"`
	PortStatus    []types.BasicOverviewSlot `json:"PortStatus"`
	CpuState      []types.BasicOverviewSlot `json:"CpuState"`
	MemState      []types.BasicOverviewSlot `json:"MemState"`
	PowerState    []types.BasicOverviewSlot `json:"PowerState"`
	FanState      []types.BasicOverviewSlot `json:"FanState"`
	MainBoardList []MainBoard               `json:"MainBoardList" description:"主板"`
	CpuList       CpuDetail                 `json:"CpuList" description:"cpu"`
	MemList       MemDetail                 `json:"MemList" description:"内存"`
	PowerList     []Power                   `json:"PowerList" description:"电源"`
	FanList       []Fan                     `json:"FanList" description:"风扇"`
}

type SwitchInterfaceListRsp struct {
	TotalCount int64
	PageNo     int
	PageSize   int
	SwitchList []SwitchInterfaceList `json:"SwitchInterfaceList"`
}

type SwitchInterfaceList struct {
	Id                int     `json:"-" gorm:"column:Id"`
	Sn                string  `json:"Sn"`
	IfName            string  `json:"IfName"`
	IfIndex           int     `json:"IfIndex"`
	IfIp              string  `json:"IfIp"`
	IfMac             string  `json:"IfMac"`
	IfSpeed           int     `json:"IfSpeed"`
	OrtherEndDevice   string  `json:"OrtherEndDevice"`
	OrtherEndDeviceId int     `json:"OrtherEndDeviceId"`
	OrtherEndIf       string  `json:"OrtherEndIf"`
	OrtherEndDescr    string  `json:"OrtherEndDescr"`
	OrtherEndType     string  `json:"OrtherEndType" `
	AdminState        int     `json:"AdminState"`
	OperState         int     `json:"OperState"`
	PortState         int     `json:"PortState"`
	LastUpdateAt      string  `json:"LastUpdateAt"`
	InErrRate         float64 `json:"InErrRate" description:"接收错包率"`
	OutErrRate        float64 `json:"OutErrRate" description:"发送错包率"`
	InDropRate        float64 `json:"InDropRate" description:"接收丢包率"`
	OutDropRate       float64 `json:"OutDropRate" description:"发送丢包率"`
	InBandRate        float64 `json:"InBandRate" description:"接收带宽利用率"`
	OutBandRate       float64 `json:"OutBandRate" description:"发送带宽利用率"`
}

type MainBoard struct {
	Name          string `json:"Name" description:"名称"`
	State         int    `json:"State" description:"健康状态"`
	Sn            string `json:"Sn" description:"序列号"`
	ProductNum    string `json:"ProductNum" description:"产品部件号"`
	ProductTime   int64  `json:"ProductTime" description:"产品生产日期"`
	ProducFactory string `json:"ProductFactory" description:"生产厂家"`
}

type CpuDetail struct {
	Sum     int   `json:"Sum" description:"cpu总数"`
	Cores   int   `json:"Cores" description:"cpu核心数"`
	CpuList []Cpu `json:"CpuList" description:"cpu列表"`
}
type Cpu struct {
	Name        string  `json:"Name" description:"名称"`
	State       int     `json:"State" description:"健康状态"`
	UsedRate    float64 `json:"UsedRate" description:"使用率"`
	Temperature int     `json:"Temperature" description:"温度"`
	Model       string  `json:"Model" description:"型号"`
	ClockSpeed  string  `json:"ClockSpeed" description:"主频"`
	MaxClock    string  `json:"MaxClock" description:"最大主频"`
	Cores       byte    `json:"Cores" description:"核心数"`
	Threads     byte    `json:"Threads" description:"线程数"`
	L1Cache     string  `json:"L1Cache" description:"L1缓存"`
	L2Cache     string  `json:"L2Cache" description:"L2缓存"`
	L3Cache     string  `json:"L3Cache" description:"L3缓存"`
}

type MemDetail struct {
	Sum      int      `json:"Sum" description:"总数"`
	Capacity string   `json:"Capacity" description:"总容量"`
	MemList  []Memory `json:"MemList" description:"内存列表"`
}

type Memory struct {
	Name          string  `json:"Name" description:"名称"`
	State         int     `json:"State" description:"健康状态"`
	UsedRate      float64 `json:"UsedRate" description:"使用率"`
	In            string  `json:"In" description:"在位信息"`
	Position      string  `json:"Position" description:"位置"`
	Channl        string  `json:"Channl" description:"通道"`
	Slot          string  `json:"Slot" description:"插槽"`
	Model         string  `json:"Model" description:"型号"`
	Ranks         string  `json:"ranks" description:"ranks"`
	Width         int     `json:"Width" description:"位宽"`
	MaxClock      int     `json:"MaxClock" description:"最大主频"`
	Capacity      int     `json:"Capacity" description:"容量"`
	Tech          string  `json:"Tech" description:"技术"`
	Sn            string  `json:"Sn" description:"序列号"`
	ProductNum    string  `json:"ProductNum" description:"产品部件号"`
	ProducFactory string  `json:"ProducFactory" description:"生产厂家"`
}

type DiskDetail struct {
	Sum      int    `json:"sum" description:"总数"`
	Capacity string `json:"capacity" description:"总容量"`
	DiskList []Disk `json:"DiskList" description:"硬盘列表"`
}

type Disk struct {
	Name          string  `json:"Name" description:"名称"`
	State         float64 `json:"State" description:"健康状态"`
	UpDown        string  `json:"UpDown" description:"启用状态"`
	UsedRate      string  `json:"UsedRate" description:"使用率"`
	In            string  `json:"In" description:"在位信息"`
	Capacity      string  `json:"Capacity" description:"容量"`
	Domain        string  `json:"Domain" description:"硬盘域"`
	Model         string  `json:"Model" description:"型号"`
	DiskType      string  `json:"DiskType" description:"类型"`
	Temperature   string  `json:"Temperature" description:"温度"`
	Speed         float64 `json:"Speed" description:"转速"`
	ProducFactory string  `json:"ProductFactory" description:"生产厂家"`
	Sn            string  `json:"Sn" description:"序列号"`
}

type Power struct {
	Id              string `json:"Id" description:"序号"`
	State           int    `json:"State" description:"健康状态"`
	In              string `json:"In" description:"在位信息"`
	Temperature     int    `json:"temperature" description:"温度"`
	RatedPower      string `json:"RatePower" description:"额定功率"`
	InputPower      string `json:"InputPower" description:"输入功率"`
	PowerInputModel string `json:"PowerInputModel" description:"电源输入模式"`
	Model           string `json:"Model" description:"型号"`
	FireWare        string `json:"FireWare" description:"固件"`
	Sn              string `json:"Sn" description:"序列号"`
	ProductNum      string `json:"ProductNum" description:"产品部件号"`
	ProducFactory   string `json:"ProductFactory" description:"生产厂家"`
}

type Fan struct {
	Name       string  `json:"Name" description:"名称"`
	State      int     `json:"state" description:"健康状态 1:健康；2：告警；3：故障；0：未知"`
	In         string  `json:"In" description:"在位信息"`
	Speed      int     `json:"Speed" description:"转速"`
	SpeedRate  float64 `json:"SpeedRate" description:"速率比"`
	Redundancy string  `json:"Redundancy" description:"冗余"`
}

type Work struct {
	Name         string `json:"Name"`
	HealthStatus string `json:"HealthStatus"` // 健康状态
	Product      string `json:"Product"`      // 厂商
	Vendor       string `json:"Vendor"`       // 型号
	Speed        string `json:"Speed"`        // 速率
	Units        string `json:"Units"`
	Size         int    `json:"Size"`
	Mac          string `json:"Mac"`
}

```

File path: /Users/mac/Desktop/woker_code/monitor/modules/switch/dto/request.go
```golang
package dto

type SwitchOverviewMonitorReq struct {
	Region string   `json:"Region"`
	Az     []string `json:"Az"`
	LabId  int      `json:"LabId"`
}

type SwitchOverviewTopReq struct {
	Region     string   `json:"Region"`
	Az         []string `json:"Az"`
	MetricName []string `json:"MetricName"`
	TopK       string   `json:"TopK"`
	Start      int64    `json:"Start"`
	End        int64    `json:"End"`
}

type SwitchListReq struct {
	PageNo     int      `json:"PageNo"`
	PageSize   int      `json:"PageSize"`
	Region     string   `json:"Region"`
	Az         []string `json:"Az"`
	Lab        []string `json:"Lab"`
	RunStatus  []string `json:"RunStatus"`  //监控状态
	SnmpStatus []string `json:"SnmpStatus"` //snmp监控状态
	CpuErrNum  string   `json:"CpuErrNum"`
	MemErrNum  string   `json:"MemErrNum"`
	Query      Query    `json:"Query"`
	OrderCode  string   `json:"OrderCode" form:"OrderCode"`
	OrderType  string   `json:"OrderType" form:"OrderType" binding:"omitempty,oneof=ASC DESC"`
}

type Query map[string]string

type SwitchDetailsOverviewReq struct {
	Id int32 `json:"Id" binding:"required"`
}

type SwitchDetailsLineReq struct {
	Id         int32    `json:"Id" binding:"required"`
	MetricName []string `json:"MetricName" binding:"required"`
	Start      int64    `json:"Start" binding:"required"`
	End        int64    `json:"End" binding:"required"`
}

type SwitchHardwareReq struct {
	Sn string
}

type SwitchInterfaceLineReq struct {
	Id         int32    `json:"Id" binding:"required"`
	Index      string   `json:"Index" binding:"required"`
	MetricName []string `json:"MetricName" binding:"required"`
	Start      int64    `json:"Start" binding:"required"`
	End        int64    `json:"End" binding:"required"`
}

type SwitchInterfaceListReq struct {
	Id        int     `json:"Id" binding:"required"`
	PageNo    int     `json:"PageNo"`
	PageSize  int     `json:"PageSize" binding:"lte=1000"`
	Region    string  `json:"Region"`
	OrderCode string  `json:"OrderCode"`
	OrderType string  `json:"OrderType" binding:"omitempty,oneof=ASC DESC asc desc"`
	Query     Query   `json:"Query"`
	PortState []int32 `json:"PortState" binding:"dive,oneof= 1 2 3"`
}

type SwitchInterfaceSingleLineReq struct {
	Ip         int32    `json:"Ip" binding:"required"`
	MetricName []string `json:"MetricName" binding:"required"`
	Start      int64    `json:"Start" binding:"required"`
	End        int64    `json:"End" binding:"required"`
}

```

File path: /Users/mac/Desktop/woker_code/monitor/modules/switch/dao/asset_switch.go
```golang
package dao

import (
	"context"

	"ezone.ksyun.com/ezone/luban/communal/lib"
	"ezone.ksyun.com/ezone/luban/monitor/modules/switch/model"
	"gorm.io/gorm"
)

type AssetSwitchDao struct {
	db *gorm.DB
}

func NewAssetSwitchDao() *AssetSwitchDao {
	return &AssetSwitchDao{
		db: lib.GORMMapPool["business"].Debug(),
	}
}

func (s *AssetSwitchDao) GetSwitchHardware(ctx context.Context, sn string) (*[]model.AssetSwitchHardware, error) {
	var hardware []model.AssetSwitchHardware
	db := s.db.Debug().Model(&model.AssetSwitchHardware{})

	if sn != "" {
		db.Where("sn=?", sn)
	}
	err := db.Scan(&hardware).Error
	if err != nil {
		lib.Log.TagError(lib.GetTraceContext(ctx), lib.DLTagMySqlFailed, map[string]interface{}{"error": err.Error()})
		return nil, err
	}
	return &hardware, err
}

func (s *AssetSwitchDao) GetSwitchHardwareInfo(ctx context.Context, sn string) (*model.AssetSwitchHardware, error) {
	var hardware model.AssetSwitchHardware
	err := s.db.Model(&model.AssetSwitchHardware{}).Where("sn=?", sn).Scan(&hardware).Error

	if err != nil {
		lib.Log.TagError(lib.GetTraceContext(ctx), lib.DLTagMySqlFailed, map[string]interface{}{"error": err.Error()})
		return nil, err
	}
	return &hardware, err
}

```

File path: /Users/mac/Desktop/woker_code/monitor/modules/switch/dao/overview.go
```golang
package dao

import (
	"ezone.ksyun.com/ezone/luban/communal/lib"
	alarmv1alpha "ezone.ksyun.com/ezone/luban/luban_api/alarmapis/alarm/v1alpha/gen"
	switchpb "ezone.ksyun.com/ezone/luban/luban_api/resourceapis/resource_switch/v1alpha/gen"
	"ezone.ksyun.com/ezone/luban/monitor/common/client/grpcx"
)

type SwitchStore struct {
	//rpc
	SwitchRpcClient switchpb.ResourceSwitchClient
	AlarmRpcClient  alarmv1alpha.AlarmServiceClient

	//dao
	AssetSwitchDao *AssetSwitchDao
}

func NewSwitchStore() *SwitchStore {
	//resource
	resourceAddr := lib.GetStringConf("base.grpc.luban_resource")
	resourceConn, err := grpcx.NewGrpcClientConn(resourceAddr)
	if err != nil {
		lib.Log.TagError(lib.NewTrace(), lib.DLTagUndefind, map[string]interface{}{"connect luban_resource grpc server error, %s": err.Error()})
	}

	//alarm
	alarmAddr := lib.GetStringConf("base.grpc.alarm")
	alarmConn, err := grpcx.NewGrpcClientConn(alarmAddr)
	if err != nil {
		lib.Log.TagError(lib.NewTrace(), lib.DLTagUndefind, map[string]interface{}{"connect alarm grpc server error, %s": err.Error()})
	}

	return &SwitchStore{
		SwitchRpcClient: switchpb.NewResourceSwitchClient(resourceConn),
		AlarmRpcClient:  alarmv1alpha.NewAlarmServiceClient(alarmConn),
		AssetSwitchDao:  NewAssetSwitchDao(),
	}
}

```

File path: /Users/mac/Desktop/woker_code/monitor/modules/switch/controller/switch.go
```golang
package controller

import (
	"ezone.ksyun.com/ezone/luban/communal/lib"
	"ezone.ksyun.com/ezone/luban/monitor/common/consts"
	"ezone.ksyun.com/ezone/luban/monitor/modules/switch/dto"
	"ezone.ksyun.com/ezone/luban/monitor/modules/switch/service"
	"ezone.ksyun.com/ezone/luban/monitor/response"
	"github.com/gin-gonic/gin"
	"net/http"
)

type SwitchController struct {
	svc *service.SwitchService
}

func NewSwitchController() *SwitchController {
	return &SwitchController{
		svc: service.NewSwitchService(),
	}
}

func (s *SwitchController) SwitchOverviewAlert(c *gin.Context) {
	// 参数绑定
	var params dto.SwitchOverviewMonitorReq
	if err := c.ShouldBind(&params); err != nil {
		lib.Log.TagError(lib.GetTraceContext(c), lib.DLTagRequestOut, map[string]interface{}{"error": err.Error(), "params": params})
		response.Failed(c, http.StatusBadRequest, consts.ParameterError, "参数绑定失败")
		return
	}
	lib.Log.TagInfo(lib.GetTraceContext(c), lib.DLTagResponseFailed, map[string]interface{}{"params": params})

	// 业务处理
	res, err := s.svc.SwitchOverviewAlert(c, params)
	if err != nil {
		lib.Log.TagError(lib.GetTraceContext(c), lib.DLTagResponseFailed, map[string]interface{}{"error": err.Error()})
		response.Failed(c, http.StatusInternalServerError, consts.GainFail, "获取交换机概览监控告警失败")
		return
	}

	lib.Log.TagInfo(lib.GetTraceContext(c), lib.DLTagResponseSuccess, map[string]interface{}{"res": res})
	response.Success(c, res)
}

func (s *SwitchController) SwitchOverviewMonitor(c *gin.Context) {
	// 参数绑定
	var params dto.SwitchOverviewMonitorReq
	if err := c.ShouldBind(&params); err != nil {
		lib.Log.TagError(lib.GetTraceContext(c), lib.DLTagRequestOut, map[string]interface{}{"error": err.Error(), "params": params})
		response.Failed(c, http.StatusBadRequest, consts.ParameterError, "参数绑定失败")
		return
	}
	lib.Log.TagInfo(lib.GetTraceContext(c), lib.DLTagResponseFailed, map[string]interface{}{"params": params})

	// 业务处理
	res, err := s.svc.SwitchOverviewMonitor(c, params)
	if err != nil {
		lib.Log.TagError(lib.GetTraceContext(c), lib.DLTagResponseFailed, map[string]interface{}{"error": err.Error()})
		response.Failed(c, http.StatusInternalServerError, consts.GainFail, "获取交换机概览监控状态失败")
		return
	}

	lib.Log.TagInfo(lib.GetTraceContext(c), lib.DLTagResponseSuccess, map[string]interface{}{"res": res})
	response.Success(c, res)
}

func (s *SwitchController) SwitchOverviewTop(c *gin.Context) {
	// 参数绑定
	var params dto.SwitchOverviewTopReq
	if err := c.ShouldBind(&params); err != nil {
		lib.Log.TagError(lib.GetTraceContext(c), lib.DLTagRequestOut, map[string]interface{}{"error": err.Error(), "params": params})
		response.Failed(c, http.StatusBadRequest, consts.ParameterError, "参数绑定失败")
		return
	}
	lib.Log.TagInfo(lib.GetTraceContext(c), lib.DLTagResponseFailed, map[string]interface{}{"params": params})

	// 业务处理
	res, err := s.svc.SwitchOverviewTop(c, params)
	if err != nil {
		lib.Log.TagError(lib.GetTraceContext(c), lib.DLTagResponseFailed, map[string]interface{}{"error": err.Error()})
		response.Failed(c, http.StatusInternalServerError, consts.GainFail, "获取交换机概览Top失败")
		return
	}

	lib.Log.TagInfo(lib.GetTraceContext(c), lib.DLTagResponseSuccess, map[string]interface{}{"res": res})
	response.Success(c, res)
}

func (s *SwitchController) SwitchList(c *gin.Context) {
	// 参数绑定
	var params dto.SwitchListReq
	if err := c.ShouldBind(&params); err != nil {
		lib.Log.TagError(lib.GetTraceContext(c), lib.DLTagRequestOut, map[string]interface{}{"error": err.Error(), "params": params})
		response.Failed(c, http.StatusBadRequest, consts.ParameterError, "参数绑定失败")
		return
	}
	lib.Log.TagInfo(lib.GetTraceContext(c), lib.DLTagResponseFailed, map[string]interface{}{"params": params})

	// 业务处理
	res, err := s.svc.SwitchList(c, params)
	if err != nil {
		lib.Log.TagError(lib.GetTraceContext(c), lib.DLTagResponseFailed, map[string]interface{}{"error": err.Error()})
		response.Failed(c, http.StatusInternalServerError, consts.GainFail, "获取交换机列表失败")
		return
	}

	lib.Log.TagInfo(lib.GetTraceContext(c), lib.DLTagResponseSuccess, map[string]interface{}{"res": res})
	response.Success(c, res)
}

func (s *SwitchController) SwitchDetailsOverview(c *gin.Context) {
	// 参数绑定
	var params dto.SwitchDetailsOverviewReq
	if err := c.ShouldBind(&params); err != nil {
		lib.Log.TagError(lib.GetTraceContext(c), lib.DLTagRequestOut, map[string]interface{}{"error": err.Error(), "params": params})
		response.Failed(c, http.StatusBadRequest, consts.ParameterError, "参数绑定失败")
		return
	}
	lib.Log.TagInfo(lib.GetTraceContext(c), lib.DLTagResponseFailed, map[string]interface{}{"params": params})

	// 业务处理
	res, err := s.svc.SwitchDetailsOverview(c, params)
	if err != nil {
		lib.Log.TagError(lib.GetTraceContext(c), lib.DLTagResponseFailed, map[string]interface{}{"error": err.Error()})
		response.Failed(c, http.StatusInternalServerError, consts.GainFail, "获取交换机概览失败")
		return
	}

	lib.Log.TagInfo(lib.GetTraceContext(c), lib.DLTagResponseSuccess, map[string]interface{}{"res": res})
	response.Success(c, res)
}

func (s *SwitchController) SwitchDetailsLine(c *gin.Context) {
	// 参数绑定
	var params dto.SwitchDetailsLineReq
	if err := c.ShouldBind(&params); err != nil {
		lib.Log.TagError(lib.GetTraceContext(c), lib.DLTagRequestOut, map[string]interface{}{"error": err.Error(), "params": params})
		response.Failed(c, http.StatusBadRequest, consts.ParameterError, "参数绑定失败")
		return
	}
	lib.Log.TagInfo(lib.GetTraceContext(c), lib.DLTagResponseFailed, map[string]interface{}{"params": params})

	// 业务处理
	res, err := s.svc.SwitchDetailsLine(c, params)
	if err != nil {
		lib.Log.TagError(lib.GetTraceContext(c), lib.DLTagResponseFailed, map[string]interface{}{"error": err.Error()})
		response.Failed(c, http.StatusInternalServerError, consts.GainFail, "获取交换机详情概览失败")
		return
	}

	lib.Log.TagInfo(lib.GetTraceContext(c), lib.DLTagResponseSuccess, map[string]interface{}{"res": res})
	response.Success(c, res)
}

func (s *SwitchController) SwitchHardware(c *gin.Context) {
	// 参数绑定
	var params dto.SwitchHardwareReq
	if err := c.ShouldBind(&params); err != nil {
		lib.Log.TagError(lib.GetTraceContext(c), lib.DLTagRequestOut, map[string]interface{}{"error": err.Error(), "params": params})
		response.Failed(c, http.StatusBadRequest, consts.ParameterError, "参数绑定失败")
		return
	}
	lib.Log.TagInfo(lib.GetTraceContext(c), lib.DLTagResponseFailed, map[string]interface{}{"params": params})

	// 业务处理
	res, err := s.svc.SwitchHardware(c, params)
	if err != nil {
		lib.Log.TagError(lib.GetTraceContext(c), lib.DLTagResponseFailed, map[string]interface{}{"error": err.Error()})
		response.Failed(c, http.StatusInternalServerError, consts.GainFail, "获取交换机硬件失败")
		return
	}

	lib.Log.TagInfo(lib.GetTraceContext(c), lib.DLTagResponseSuccess, map[string]interface{}{"res": res})
	response.Success(c, res)
}

func (s *SwitchController) SwitchInterfaceLine(c *gin.Context) {
	// 参数绑定
	var params dto.SwitchInterfaceLineReq
	if err := c.ShouldBind(&params); err != nil {
		lib.Log.TagError(lib.GetTraceContext(c), lib.DLTagRequestOut, map[string]interface{}{"error": err.Error(), "params": params})
		response.Failed(c, http.StatusBadRequest, consts.ParameterError, "参数绑定失败")
		return
	}
	lib.Log.TagInfo(lib.GetTraceContext(c), lib.DLTagResponseFailed, map[string]interface{}{"params": params})

	// 业务处理
	res, err := s.svc.SwitchInterfaceLine(c, params)
	if err != nil {
		lib.Log.TagError(lib.GetTraceContext(c), lib.DLTagResponseFailed, map[string]interface{}{"error": err.Error()})
		response.Failed(c, http.StatusInternalServerError, consts.GainFail, "获取交换接口折线图失败")
		return
	}

	lib.Log.TagInfo(lib.GetTraceContext(c), lib.DLTagResponseSuccess, map[string]interface{}{"res": res})
	response.Success(c, res)
}

func (s *SwitchController) SwitchInterfaceList(c *gin.Context) {
	// 参数绑定
	var params dto.SwitchInterfaceListReq
	if err := c.ShouldBind(&params); err != nil {
		lib.Log.TagError(lib.GetTraceContext(c), lib.DLTagRequestOut, map[string]interface{}{"error": err.Error(), "params": params})
		response.Failed(c, http.StatusBadRequest, consts.ParameterError, "参数绑定失败")
		return
	}
	lib.Log.TagInfo(lib.GetTraceContext(c), lib.DLTagResponseFailed, map[string]interface{}{"params": params})

	// 业务处理
	res, err := s.svc.SwitchInterfaceList(c, params)
	if err != nil {
		lib.Log.TagError(lib.GetTraceContext(c), lib.DLTagResponseFailed, map[string]interface{}{"error": err.Error()})
		response.Failed(c, http.StatusInternalServerError, consts.GainFail, "获取交换机接口列表失败")
		return
	}

	lib.Log.TagInfo(lib.GetTraceContext(c), lib.DLTagResponseSuccess, map[string]interface{}{"res": res})
	response.Success(c, res)
}

```

File path: /Users/mac/Desktop/woker_code/monitor/modules/switch/constant/constant.go
```golang
package constant

const ()

```

File path: /Users/mac/Desktop/woker_code/monitor/modules/switch/model/asset_switch_hardware.go
```golang
package model

import (
	"database/sql"
	"database/sql/driver"
	"encoding/json"
)

// AssetSwitchHardware 交换机硬件
type AssetSwitchHardware struct {
	Id            int                `gorm:"column:id;type:int(11);primary_key;AUTO_INCREMENT;comment:ID" json:"id"`
	Sn            string             `gorm:"column:sn;type:varchar(64);comment:设备sn号;NOT NULL" json:"sn"`
	AirInlet      int                `gorm:"column:air_inlet;type:int(11);comment:空气进口温度" json:"air_inlet"`
	AirOutlet     int                `gorm:"column:air_outlet;type:int(11);comment:空气出口温度" json:"air_outlet"`
	BaseboardInfo BaseboardInfoSlice `gorm:"column:baseboard_info;type:text;comment:主板信息" json:"baseboard_info"`
	CpuInfo       CpuInfoSlice       `gorm:"column:cpu_info;type:text;comment:cpu信息" json:"cpu_info"`
	MemoryInfo    MemoryInfoSlice    `gorm:"column:memory_info;type:text;comment:内存信息" json:"memory_info"`
	PowerInfo     PowerInfoSlice     `gorm:"column:power_info;type:text;comment:电源" json:"power_info"`
	FanInfo       FanInfoSlice       `gorm:"column:fan_info;type:text;comment:风扇信息" json:"fan_info"`
	LastUpdateAt  sql.NullTime       `gorm:"column:last_update_at;type:timestamp" json:"last_update_at"`
}

type (
	BaseboardInfoSlice []BaseboardInfo
	CpuInfoSlice       []CpuInfo
	MemoryInfoSlice    []MemoryInfo
	PowerInfoSlice     []PowerInfo
	FanInfoSlice       []FanInfo
)

type BaseboardInfo struct {
	Name             string `json:"name"`
	Health           int    `json:"health"`
	ManufacturedDate int64  `json:"manufacturedDate"`
	MfgName          string `json:"mfgName"`
	SerialNum        string `json:"serialNum"`
	PartNum          string `json:"partNum"`
}

type CpuInfo struct {
	Name        string  `json:"name"`
	Health      int     `json:"health"`
	Utilization float64 `json:"utilization"`
	Temperature int     `json:"temperature"`
	CPUType     string  `json:"cpuType"`
	MainHertz   int     `json:"mainHertz"`
	MaxHertz    int     `json:"maxHertz"`
	CacheLv     int     `json:"cacheLv"`
}

type MemoryInfo struct {
	Name        string  `json:"name"`
	Health      int     `json:"health"`
	Utilization float64 `json:"utilization"`
	Exist       bool    `json:"exist"`
	Location    string  `json:"location"`
	Tunnel      string  `json:"tunnel"`
	SlotNum     string  `json:"slotNum"`
	MemType     string  `json:"memType"`
	Ranks       string  `json:"ranks"`
	BitWide     int     `json:"bitWide"`
	MaxHertz    int     `json:"maxHertz"`
	Capacity    int     `json:"capacity"`
	Technology  string  `json:"technology"`
	MfgName     string  `json:"mfgName"`
	SerialNum   string  `json:"serialNum"`
	PartNum     string  `json:"partNum"`
}

type PowerInfo struct {
	Name            string `json:"name"`
	Health          int    `json:"health"`
	Exist           bool   `json:"exist"`
	Temperature     int    `json:"temperature"`
	RatedPower      int    `json:"ratedPower"`
	InPower         int    `json:"inPower"`
	InModel         string `json:"inModel"`
	PowerType       string `json:"powerType"`
	FirmwareVersion string `json:"firmwareVersion"`
	MfgName         string `json:"mfgName"`
	SerialNum       string `json:"serialNum"`
	PartNum         string `json:"partNum"`
}

type FanInfo struct {
	Name       string  `json:"name"`
	Health     int     `json:"health"`
	Exist      bool    `json:"exist"`
	Speed      int     `json:"speed"`
	SpeedRatio float64 `json:"speedRatio"`
	Redundant  bool    `json:"redundant"`
}

func (c BaseboardInfoSlice) Value() (driver.Value, error) {
	b, err := json.Marshal(c)
	return string(b), err
}

func (c *BaseboardInfoSlice) Scan(input interface{}) error {
	return json.Unmarshal(input.([]byte), c)
}

func (c CpuInfoSlice) Value() (driver.Value, error) {
	b, err := json.Marshal(c)
	return string(b), err
}

func (c *CpuInfoSlice) Scan(input interface{}) error {
	return json.Unmarshal(input.([]byte), c)
}

func (c MemoryInfoSlice) Value() (driver.Value, error) {
	b, err := json.Marshal(c)
	return string(b), err
}

func (c *MemoryInfoSlice) Scan(input interface{}) error {
	return json.Unmarshal(input.([]byte), c)
}

func (c PowerInfoSlice) Value() (driver.Value, error) {
	b, err := json.Marshal(c)
	return string(b), err
}

func (c *PowerInfoSlice) Scan(input interface{}) error {
	return json.Unmarshal(input.([]byte), c)
}

func (c FanInfoSlice) Value() (driver.Value, error) {
	b, err := json.Marshal(c)
	return string(b), err
}

func (c *FanInfoSlice) Scan(input interface{}) error {
	return json.Unmarshal(input.([]byte), c)
}

```

File path: /Users/mac/Desktop/woker_code/monitor/modules/switch/service/switch.go
```golang
package service

import (
	"context"
	"fmt"
	"math"
	"sort"
	"strconv"
	"strings"
	"time"

	alarmv1alpha "ezone.ksyun.com/ezone/luban/luban_api/alarmapis/alarm/v1alpha/gen"
	switch_rpc "ezone.ksyun.com/ezone/luban/luban_api/resourceapis/resource_switch/v1alpha/gen"
	prom_client "ezone.ksyun.com/ezone/luban/monitor/common/client/prom"
	"ezone.ksyun.com/ezone/luban/monitor/common/promql_template/server"
	"ezone.ksyun.com/ezone/luban/monitor/common/tools"
	"ezone.ksyun.com/ezone/luban/monitor/common/types"
	"ezone.ksyun.com/ezone/luban/monitor/common/utils"
	"ezone.ksyun.com/ezone/luban/monitor/modules/switch/dao"
	"ezone.ksyun.com/ezone/luban/monitor/modules/switch/dto"
	"github.com/pkg/errors"
	v1 "github.com/prometheus/client_golang/api/prometheus/v1"
	"k8s.io/klog/v2"
)

type SwitchService struct {
	Store dao.SwitchStore
}

func NewSwitchService() *SwitchService {
	return &SwitchService{
		Store: *dao.NewSwitchStore(),
	}
}

func (s *SwitchService) SwitchOverviewAlert(ctx context.Context, par dto.SwitchOverviewMonitorReq) (*dto.SwitchOverviewAlertRsp, error) {

	alertLevels := []types.OverviewAlert{
		{Name: "紧急告警", Level: "p0", Kind: "error", Number: 0, Unit: "个"},
		{Name: "重要告警", Level: "p1", Kind: "warn", Number: 0, Unit: "个"},
		{Name: "次要告警", Level: "p2", Kind: "minor", Number: 0, Unit: "个"},
		{Name: "提醒告警", Level: "p3", Kind: "info", Number: 0, Unit: "个"},
	}

	alerts, err := s.Store.AlarmRpcClient.ListAlerts(ctx, &alarmv1alpha.ListAlertsRequest{
		PageNo:   -1,
		PageSize: -1,
		Region:   par.Region,
		Az:       par.Az,
		Status:   "firing",
	})
	if err != nil {
		return nil, errors.WithMessage(err, "rpc call AlarmRpcClient.ListAlerts err")
	}

	//概览数据拼装
	var alertSlots []types.BasicOverviewSlot

	for _, alert := range alertLevels {
		var alertSlotInfo types.BasicOverviewSlot
		alertSlotInfo.Info = types.BasicOverviewSlotInfo{
			Index:       0,
			Name:        alert.Level,
			Value:       utils.CountAlertsNum(alerts.Items, "physicalSwitch", alert.Level),
			UnitType:    types.TypeNumber,
			Unit:        "个",
			Kind:        alert.Kind,
			Prognosis:   0,
			Description: "",
		}
		alertSlots = append(alertSlots, alertSlotInfo)
	}

	return &dto.SwitchOverviewAlertRsp{
		Alerts: alertSlots,
	}, nil

}

func (s *SwitchService) SwitchOverviewMonitor(ctx context.Context, par dto.SwitchOverviewMonitorReq) (*dto.SwitchOverviewMonitorRsp, error) {

	//获取交换机列表
	list, err := s.Store.SwitchRpcClient.SwitchList(ctx, &switch_rpc.SwitchListRequest{
		RegionCode: par.Region,
		AzCode:     par.Az,
		PageNo:     1,
		PageSize:   -1,
	})
	if err != nil {
		return nil, err
	}
	var (
		ipList             []string
		outIpList          []string
		sn                 []string
		monitoringStatus   []types.BasicOverviewSlot
		interfaceStatus    []types.BasicOverviewSlot
		hardwareMonitoring []types.BasicOverviewSlot
		up                 int
		down               int
		normal             int
		shutdown           int
		fault              int
		cpuFault           int
		memFault           int
	)
	for _, v := range list.DataList {
		sn = append(sn, v.Sn)
		ipList = append(ipList, v.Ip)
		outIpList = append(outIpList, v.OutbandIP)
	}
	//获取监控状态
	statusPromQL, err := s.Store.AlarmRpcClient.ListPromQLs(ctx, server.TemplateMap[server.SwitchStatus](ipList))
	if err != nil {
		return nil, err
	}
	statusPromQLStr := statusPromQL.Items[0].RealPromql
	//查Prometheus
	status, err := prom_client.VectorQuery(ctx, statusPromQLStr)
	if err != nil {
		return nil, err
	}
	switchMonitorUpStatusMap := prom_client.ParseServerMonitoringStatus(status)
	for _, v := range switchMonitorUpStatusMap {
		if v == "up" {
			up++
		} else {
			down++
		}
	}

	statusList := []string{"监控中", "监控异常"}
	for _, name := range statusList {
		var monitoringStatusInfo types.BasicOverviewSlot
		value := 0
		if name == "监控中" {
			value = up
		} else {
			value = down
		}
		monitoringStatusInfo.Info = types.BasicOverviewSlotInfo{
			Index:     0,
			Name:      name,
			Value:     value,
			UnitType:  types.TypeNumber,
			Unit:      "个",
			Prognosis: 0,
		}
		monitoringStatus = append(monitoringStatus, monitoringStatusInfo)
	}

	//获取接口故障数
	interfaceList, err := s.Store.SwitchRpcClient.SwitchInterfaceList(ctx, &switch_rpc.SwitchInterfaceListRequest{
		PageNo:   1,
		PageSize: -1,
	})
	if err != nil {
		return nil, err
	}
	for _, v := range interfaceList.Data {
		containsString := ContainsString(sn, v.Sn)
		if containsString == false {
			continue
		}
		switch int(v.PortState) {
		case 1:
			normal++
		case 2:
			shutdown++
		case 3:
			fault++
		}
	}
	faultList := []string{"故障", "正常", "关闭"}
	for _, name := range faultList {
		var interfaceStatusInfo types.BasicOverviewSlot
		value := 0
		switch name {
		case "故障":
			value = fault
		case "正常":
			value = normal
		case "关闭":
			value = shutdown
		}
		interfaceStatusInfo.Info = types.BasicOverviewSlotInfo{
			Index:     0,
			Name:      name,
			Value:     value,
			UnitType:  types.TypeNumber,
			Unit:      "个",
			Prognosis: 0,
		}
		interfaceStatus = append(interfaceStatus, interfaceStatusInfo)
	}

	//获取交换机硬件
	hardware, _ := s.Store.AssetSwitchDao.GetSwitchHardware(ctx, "")
	for _, v := range *hardware {
		containsString := ContainsString(sn, v.Sn)
		if containsString == false {
			continue
		}

		for _, cpu := range v.CpuInfo {
			if cpu.Health == 3 {
				cpuFault++
			}
		}
		for _, mem := range v.MemoryInfo {
			if mem.Health == 3 {
				memFault++
			}
		}
	}

	//硬件监控
	hardwareFaultList := []string{"CPU故障数量", "内存故障数量"}
	for _, name := range hardwareFaultList {
		var hardwareMonitoringInfo types.BasicOverviewSlot
		value := 0
		switch name {
		case "CPU故障数量":
			value = cpuFault
		case "内存故障数量":
			value = memFault
		}
		hardwareMonitoringInfo.Info = types.BasicOverviewSlotInfo{
			Index:     0,
			Name:      name,
			Value:     value,
			UnitType:  types.TypeNumber,
			Unit:      "个",
			Prognosis: 0,
		}
		hardwareMonitoring = append(hardwareMonitoring, hardwareMonitoringInfo)
	}
	return &dto.SwitchOverviewMonitorRsp{
		MonitoringStatus:   monitoringStatus,
		InterfaceStatus:    interfaceStatus,
		HardwareMonitoring: hardwareMonitoring,
	}, nil

}

func ContainsString(slice []string, item string) bool {
	for _, str := range slice {
		if str == item {
			return true
		}
	}
	return false
}

func (s *SwitchService) SwitchOverviewTop(ctx context.Context, par dto.SwitchOverviewTopReq) (*dto.SwitchOverviewTopRsp, error) {

	res := dto.SwitchOverviewTopRsp{}
	topk, _ := strconv.Atoi(par.TopK)
	t := tools.FormatTime(float64(par.End/1000 - par.Start/1000))

	list, err := s.Store.SwitchRpcClient.SwitchList(ctx, &switch_rpc.SwitchListRequest{
		RegionCode: par.Region,
		AzCode:     par.Az,
		PageNo:     1,
		PageSize:   -1,
	})

	if err != nil {
		return &res, nil
	}
	if list.TotalCount == 0 {
		klog.Info("getSwitchListFail")
		return nil, err
	}
	var ipList []string
	ipInterfaceMap := make(map[string]string, 0)
	idSnMap := make(map[string]string, list.TotalCount)

	for _, switchs := range list.DataList {
		ipList = append(ipList, switchs.Ip)
		idSnMap[switchs.Ip] = strconv.Itoa(int(switchs.Id)) + ":" + switchs.Sn
		interfaceLis, err := s.Store.SwitchRpcClient.SwitchInterfaceList(ctx, &switch_rpc.SwitchInterfaceListRequest{
			PageNo:    0,
			PageSize:  -1,
			Sn:        switchs.Sn,
			PortState: []int32{1},
		})
		if err != nil {
			return nil, err
		}
		var interfacesIndex []string
		for _, interfaces := range interfaceLis.Data {
			index := strconv.Itoa(int(interfaces.IfIndex))
			interfacesIndex = append(interfacesIndex, index)
		}
		if switchs.OutbandIP == "" {
			continue
		}
		ipInterfaceMap[switchs.OutbandIP] = strings.Join(interfacesIndex, "|")
	}
	klog.Info("ipInterfaceMap", ipInterfaceMap)

	ips := strings.Join(ipList, "|")

	var tops []types.BasicOverviewSlot

	for _, metric := range par.MetricName {
		switch metric {
		case "CpuRate":
			psql := server.GetSwitchCpuRateTop(par.TopK, ips, t)
			fmt.Println("CpuRatePSql", psql)
			result, err := prom_client.VectorQuery(ctx, psql)
			if err != nil {
				return nil, err
			}
			info := types.BasicOverviewSlotInfo{
				Name:     "CpuRate",
				UnitType: types.TypePercent,
				Unit:     "%",
			}
			var val []types.BasicOverviewSlotValue
			for _, v := range result {
				ip := string(v.Metric["instance"])
				subName := ""
				if idSn, ok := idSnMap[ip]; ok {
					subName = idSn
				}
				vv := types.BasicOverviewSlotValue{
					Name:     string(v.Metric["hostname"]),
					SubName:  subName,
					Code:     ip,
					Unit:     "%",
					UnitType: types.TypePercent,
				}
				if math.IsNaN(float64(v.Value)) {
					vv.Value = 0
				}
				vv.Value = tools.FormPercent(float64(v.Value) / 100)
				val = append(val, vv)
			}
			value := types.BasicOverviewSlot{
				Info:   info,
				Values: val,
			}
			tops = append(tops, value)
		case "MemRate":
			psql := server.GetSwitchMemRateTop(par.TopK, ips, t)
			fmt.Println("MemRatePSql", psql)
			result, err := prom_client.VectorQuery(ctx, psql)
			if err != nil {
				return nil, err
			}
			info := types.BasicOverviewSlotInfo{
				Name:     "MemRate",
				UnitType: types.TypePercent,
				Unit:     "%",
			}
			var val []types.BasicOverviewSlotValue
			for _, v := range result {
				ip := string(v.Metric["instance"])
				subName := ""
				if idSn, ok := idSnMap[ip]; ok {
					subName = idSn
				}
				vv := types.BasicOverviewSlotValue{
					Name:     string(v.Metric["hostname"]),
					SubName:  subName,
					Code:     ip,
					Unit:     "%",
					UnitType: types.TypePercent,
				}
				if math.IsNaN(float64(v.Value)) {
					vv.Value = 0
				}
				vv.Value = tools.FormPercent(float64(v.Value) / 100)
				val = append(val, vv)
			}
			value := types.BasicOverviewSlot{
				Info:   info,
				Values: val,
			}
			tops = append(tops, value)
		case "DropRateOut":
			info := types.BasicOverviewSlotInfo{
				Name:     "接口丢包率-发送",
				UnitType: types.TypePercent,
				Unit:     "%",
			}
			var val []types.BasicOverviewSlotValue
			for outBandIp, indexs := range ipInterfaceMap {
				promql := server.SwitchInterfaceOutDropRates(outBandIp, indexs, t)
				klog.Info("DropRateOutPromql", promql)
				result, err := prom_client.VectorQuery(ctx, promql)
				if err != nil {
					return nil, err
				}
				for _, m := range result {
					subName := ""
					if idSn, ok := idSnMap[string(m.Metric["instance"])]; ok {
						subName = idSn
					}
					slotValue := types.BasicOverviewSlotValue{
						Name:     fmt.Sprintf("%s(%s)(%s)", string(m.Metric["ifDescr"]), string(m.Metric["hostname"]), string(m.Metric["instance"])),
						SubName:  subName,
						Code:     string(m.Metric["instance"]),
						Unit:     "%",
						UnitType: types.TypePercent,
					}
					if math.IsNaN(float64(m.Value)) {
						m.Value = 0
					}
					slotValue.Value = tools.FormPercent(m.Value)
					val = append(val, slotValue)
				}
			}
			out := InterfaceValueOrder(val, "desc")
			if len(out) >= topk {
				out = out[:topk]
			}
			value := types.BasicOverviewSlot{
				Info:   info,
				Values: out,
			}
			tops = append(tops, value)
		case "DropRateIn":
			info := types.BasicOverviewSlotInfo{
				Name:     "接口丢包率-接收",
				UnitType: types.TypePercent,
				Unit:     "%",
			}
			var val []types.BasicOverviewSlotValue
			for outBandIp, indexs := range ipInterfaceMap {
				promql := server.SwitchInterfaceInDropRates(outBandIp, indexs, t)
				klog.Info("DropRateInPromql", promql)
				result, err := prom_client.VectorQuery(ctx, promql)
				if err != nil {
					return nil, err
				}
				for _, m := range result {
					subName := ""
					if idSn, ok := idSnMap[string(m.Metric["instance"])]; ok {
						subName = idSn
					}
					slotValue := types.BasicOverviewSlotValue{
						Name:     fmt.Sprintf("%s(%s)(%s)", string(m.Metric["ifDescr"]), string(m.Metric["hostname"]), string(m.Metric["instance"])),
						SubName:  subName,
						Code:     string(m.Metric["instance"]),
						Unit:     "%",
						UnitType: types.TypePercent,
					}
					if math.IsNaN(float64(m.Value)) {
						m.Value = 0
					}
					slotValue.Value = tools.FormPercent(m.Value)
					val = append(val, slotValue)
				}
			}
			out := InterfaceValueOrder(val, "desc")
			if len(out) >= topk {
				out = out[:topk]
			}
			value := types.BasicOverviewSlot{
				Info:   info,
				Values: out,
			}
			tops = append(tops, value)
		case "ErrRateOut":
			info := types.BasicOverviewSlotInfo{
				Name:     "接口错包率-发送",
				UnitType: types.TypePercent,
				Unit:     "%",
			}
			var val []types.BasicOverviewSlotValue
			for outBandIp, indexs := range ipInterfaceMap {
				promql := server.SwitchInterfaceOutErrRates(outBandIp, indexs, t)
				klog.Info("ErrRateOutPromql", promql)
				result, err := prom_client.VectorQuery(ctx, promql)
				if err != nil {
					return nil, err
				}
				for _, m := range result {
					subName := ""
					if idSn, ok := idSnMap[string(m.Metric["instance"])]; ok {
						subName = idSn
					}
					slotValue := types.BasicOverviewSlotValue{
						Name:     fmt.Sprintf("%s(%s)(%s)", string(m.Metric["ifDescr"]), string(m.Metric["hostname"]), string(m.Metric["instance"])),
						SubName:  subName,
						Code:     string(m.Metric["instance"]),
						Unit:     "%",
						UnitType: types.TypePercent,
					}
					if math.IsNaN(float64(m.Value)) {
						m.Value = 0
					}
					slotValue.Value = tools.FormPercent(m.Value)
					val = append(val, slotValue)
				}
			}
			out := InterfaceValueOrder(val, "desc")
			if len(out) >= topk {
				out = out[:topk]
			}
			value := types.BasicOverviewSlot{
				Info:   info,
				Values: out,
			}
			tops = append(tops, value)
		case "ErrRateIn":
			info := types.BasicOverviewSlotInfo{
				Name:     "接口错包率-接收",
				UnitType: types.TypePercent,
				Unit:     "%",
			}
			var val []types.BasicOverviewSlotValue
			for outBandIp, indexs := range ipInterfaceMap {
				promql := server.SwitchInterfaceInErrRates(outBandIp, indexs, t)
				klog.Info("ErrRateInPromql", promql)
				result, err := prom_client.VectorQuery(ctx, promql)
				if err != nil {
					return nil, err
				}
				for _, m := range result {
					subName := ""
					if idSn, ok := idSnMap[string(m.Metric["instance"])]; ok {
						subName = idSn
					}
					slotValue := types.BasicOverviewSlotValue{
						Name:     fmt.Sprintf("%s(%s)(%s)", string(m.Metric["ifDescr"]), string(m.Metric["hostname"]), string(m.Metric["instance"])),
						SubName:  subName,
						Code:     string(m.Metric["instance"]),
						Unit:     "%",
						UnitType: types.TypePercent,
					}
					if math.IsNaN(float64(m.Value)) {
						m.Value = 0
					}
					slotValue.Value = tools.FormPercent(m.Value)
					val = append(val, slotValue)
				}
			}
			out := InterfaceValueOrder(val, "desc")
			if len(out) >= topk {
				out = out[:topk]
			}
			value := types.BasicOverviewSlot{
				Info:   info,
				Values: out,
			}
			tops = append(tops, value)
		case "BandRateOut":
			info := types.BasicOverviewSlotInfo{
				Name:     "接口带宽利用率-发送",
				UnitType: types.TypePercent,
				Unit:     "%",
			}
			var val []types.BasicOverviewSlotValue
			for outBandIp, indexs := range ipInterfaceMap {
				promql := server.SwitchInterfaceBandOutRates(outBandIp, indexs, t)
				klog.Info("BandRateOutPromql ", promql)
				result, err := prom_client.VectorQuery(ctx, promql)
				if err != nil {
					return nil, err
				}
				for _, m := range result {
					subName := ""
					if idSn, ok := idSnMap[string(m.Metric["instance"])]; ok {
						subName = idSn
					}
					slotValue := types.BasicOverviewSlotValue{
						Name:     fmt.Sprintf("%s(%s)(%s)", string(m.Metric["ifDescr"]), string(m.Metric["hostname"]), string(m.Metric["instance"])),
						SubName:  subName,
						Code:     string(m.Metric["instance"]),
						Unit:     "%",
						UnitType: types.TypePercent,
					}
					if math.IsNaN(float64(m.Value)) {
						m.Value = 0
					}
					slotValue.Value = tools.FormPercent(m.Value)
					val = append(val, slotValue)
				}
			}
			out := InterfaceValueOrder(val, "desc")
			if len(out) >= topk {
				out = out[:topk]
			}
			value := types.BasicOverviewSlot{
				Info:   info,
				Values: out,
			}
			tops = append(tops, value)
		case "BandRateIn":
			info := types.BasicOverviewSlotInfo{
				Name:     "接口带宽利用率-接收",
				UnitType: types.TypePercent,
				Unit:     "%",
			}
			var val []types.BasicOverviewSlotValue
			for outBandIp, indexs := range ipInterfaceMap {
				promql := server.SwitchInterfaceBandInRates(outBandIp, indexs, t)
				klog.Info("BandRateInPromql ", promql)
				result, err := prom_client.VectorQuery(ctx, promql)
				if err != nil {
					return nil, err
				}
				for _, m := range result {
					subName := ""
					if idSn, ok := idSnMap[string(m.Metric["instance"])]; ok {
						subName = idSn
					}
					slotValue := types.BasicOverviewSlotValue{
						Name:     fmt.Sprintf("%s(%s)(%s)", string(m.Metric["ifDescr"]), string(m.Metric["hostname"]), string(m.Metric["instance"])),
						SubName:  subName,
						Code:     string(m.Metric["instance"]),
						Unit:     "%",
						UnitType: types.TypePercent,
					}
					if math.IsNaN(float64(m.Value)) {
						m.Value = 0
					}
					slotValue.Value = tools.FormPercent(m.Value)
					val = append(val, slotValue)
				}
			}
			out := InterfaceValueOrder(val, "desc")
			if len(out) >= topk {
				out = out[:topk]
			}
			value := types.BasicOverviewSlot{
				Info:   info,
				Values: out,
			}
			tops = append(tops, value)
		}

	}
	return &dto.SwitchOverviewTopRsp{
		Tops: tops,
	}, nil

}

func (s *SwitchService) SwitchList(ctx context.Context, par dto.SwitchListReq) (*dto.SwitchListRsp, error) {

	rpcSwitch, err := s.Store.SwitchRpcClient.SwitchList(ctx, &switch_rpc.SwitchListRequest{
		PageNo:     1,
		PageSize:   -1,
		RegionCode: par.Region,
		AzCode:     par.Az,
		LabCode:    par.Lab,
		Query:      par.Query,
		RunStatus:  par.RunStatus,
		SnmpStatus: par.SnmpStatus,
	})
	if err != nil {
		return nil, err
	}

	//获取服务器cpu mem 故障数
	switchCpuErrNum := make(map[string]int, rpcSwitch.TotalCount)
	switchMemErrNum := make(map[string]int, rpcSwitch.TotalCount)
	hardware, err := s.Store.AssetSwitchDao.GetSwitchHardware(ctx, "")
	if err != nil {
		return nil, err
	}

	for _, v := range *hardware {
		faultyCPUs := 0
		for _, cpu := range v.CpuInfo {
			if cpu.Health == 3 {
				faultyCPUs++
			}
		}
		faultyMems := 0
		for _, mem := range v.MemoryInfo {
			if mem.Health == 3 {
				faultyMems++
			}
		}
		switchCpuErrNum[v.Sn] = faultyCPUs
		switchMemErrNum[v.Sn] = faultyMems
	}

	var switchList []dto.SwitchList
	var identifier []string
	for _, v := range rpcSwitch.DataList {
		//		//			Power:       "",
		//		//			AlertNumber: 0,
		switchInfo := dto.SwitchList{
			Id:         v.Id,
			Name:       v.Name,
			RunStatus:  v.RunStatus,
			SnmpStatus: v.SnmpStatus,
			Region:     v.RegionCode,
			Az:         v.AzCode,
			Lab:        v.LabCode,
			Sn:         v.Sn,
			Ip:         v.Ip,
			OutBindIp:  v.OutbandIP,
			ErrPortNum: v.InterfaceErrCount,
			CpuErrNum:  switchCpuErrNum[v.Sn],
			MemErrNum:  switchMemErrNum[v.Sn],
			Power:      v.Power,
		}
		//获取cpu使用率
		cpuRate, _ := GetSwitchUsageRateMap(s.Store, ctx, []string{v.Ip}, "cpu")
		//获取内存使用率
		memRate, _ := GetSwitchUsageRateMap(s.Store, ctx, []string{v.Ip}, "mem")
		switchInfo.CpuLoad = cpuRate[v.Name]
		switchInfo.MemLoad = memRate[v.Name]

		if len(par.RunStatus) != 0 { //筛选交换机运行状态
			stateIn := tools.In(par.RunStatus, switchInfo.RunStatus)
			if !stateIn {
				continue
			}
		}

		if len(par.SnmpStatus) != 0 { //筛选交换机snmp状态
			stateIn := tools.In(par.SnmpStatus, switchInfo.SnmpStatus)
			if !stateIn {
				continue
			}
		}

		if par.CpuErrNum == "Zero" && switchInfo.CpuErrNum > 0 { //筛选cpu故障数等于0的
			continue
		}
		if par.MemErrNum == "Zero" && switchInfo.MemErrNum > 0 { //筛选mem故障数等于0的
			continue
		}
		if par.CpuErrNum == "NoZero" && switchInfo.CpuErrNum == 0 { //筛选cpu故障数大于0的
			continue
		}
		if par.MemErrNum == "NoZero" && switchInfo.MemErrNum == 0 { //筛选cpu故障数大于0的
			continue
		}
		switchList = append(switchList, switchInfo)
		identifier = append(identifier, v.Name)
	}

	//order
	if par.OrderCode != "" && par.OrderType != "" {
		results := utils.Bucket{}
		for i := 0; i < len(switchList); i++ {
			results.Slice = append(results.Slice, switchList[i])
		}
		time_by := func(a, b interface{}) bool {
			return true
		}
		switch par.OrderCode {
		case "CpuLoad":
			switch par.OrderType {
			case "ASC":
				time_by = func(a, b interface{}) bool {
					return a.(dto.SwitchList).CpuLoad < b.(dto.SwitchList).CpuLoad
				}
			case "DESC":
				time_by = func(a, b interface{}) bool {
					return a.(dto.SwitchList).CpuLoad > b.(dto.SwitchList).CpuLoad
				}
			}

		case "MemLoad":
			switch par.OrderType {
			case "ASC":
				time_by = func(a, b interface{}) bool {
					return a.(dto.SwitchList).MemLoad < b.(dto.SwitchList).MemLoad
				}
			case "DESC":
				time_by = func(a, b interface{}) bool {
					return a.(dto.SwitchList).MemLoad > b.(dto.SwitchList).MemLoad
				}
			}
		case "ErrPortNum":
			switch par.OrderType {
			case "ASC":
				time_by = func(a, b interface{}) bool {
					return a.(dto.SwitchList).ErrPortNum < b.(dto.SwitchList).ErrPortNum
				}
			case "DESC":
				time_by = func(a, b interface{}) bool {
					return a.(dto.SwitchList).ErrPortNum > b.(dto.SwitchList).ErrPortNum
				}
			}
		}

		results.By = time_by
		sort.Sort(results)
		for i := 0; i < len(results.Slice); i++ {
			switchList[i] = results.Slice[i].(dto.SwitchList)
		}
	}

	//分页
	low := (par.PageNo - 1) * par.PageSize
	if low > len(switchList) {
		klog.Info("PageSize is too large")
	}

	hight := low + par.PageSize
	if hight > len(switchList) {
		hight = len(switchList)
	}

	var results dto.SwitchListRsp
	results.PageSize = par.PageSize
	results.PageNo = par.PageNo
	results.TotalCount = int64(len(switchList))
	results.SwitchList = switchList[low:hight]

	alerts, err := s.Store.AlarmRpcClient.ListAlerts(ctx, &alarmv1alpha.ListAlertsRequest{
		PageNo:   -1,
		PageSize: -1,
		Region:   par.Region,
		Status:   "firing",
	})
	if err != nil {
		return nil, errors.WithMessage(err, "rpc call AlarmRpcClient.ListAlerts err")
	}

	alertNum := utils.CountAlertsListNum(alerts.Items, "physicalSwitch")

	//告警数量
	for k, v := range results.SwitchList {
		results.SwitchList[k].AlertNumber = alertNum[v.Name]
	}

	return &results, err

}

func GetSwitchUsageRateMap(s dao.SwitchStore, ctx context.Context, ips []string, errType string) (map[string]float64, error) {
	var promQLStr string
	switch errType {
	case "cpu":
		promQL, err := s.AlarmRpcClient.ListPromQLs(ctx, server.TemplateMap[server.SwitchCpuUsageRate](ips))
		if err != nil {
			return nil, err
		}
		promQLStr = promQL.Items[0].RealPromql
	case "mem":
		promQL, err := s.AlarmRpcClient.ListPromQLs(ctx, server.TemplateMap[server.SwitchMemUsageRate](ips))
		if err != nil {
			return nil, err
		}
		promQLStr = promQL.Items[0].RealPromql
	}
	//查Prometheus
	promRes, err := prom_client.VectorQuery(ctx, promQLStr)
	if err != nil {
		return nil, err
	}

	res := make(map[string]float64)
	for _, v := range promRes {
		if math.IsNaN(float64(v.Value)) {
			v.Value = 0
		}
		hostname := string(v.Metric["hostname"])
		_, ok := res[hostname]
		if !ok {
			res[hostname] = tools.FormPercent(float64(v.Value))
		}
	}
	return res, nil
}

func InterfaceValueOrder(in []types.BasicOverviewSlotValue, code string) []types.BasicOverviewSlotValue {
	results := utils.Bucket{}
	for i := 0; i < len(in); i++ {
		results.Slice = append(results.Slice, in[i])
	}
	time_by := func(a, b interface{}) bool {
		return true
	}

	switch code {
	case "asc":
		time_by = func(a, b interface{}) bool {
			aa, _ := strconv.ParseFloat(tools.Strval(a.(types.BasicOverviewSlotValue).Value), 64)
			bb, _ := strconv.ParseFloat(tools.Strval(b.(types.BasicOverviewSlotValue).Value), 64)
			return aa < bb
		}
	case "desc":
		time_by = func(a, b interface{}) bool {
			aa, _ := strconv.ParseFloat(tools.Strval(a.(types.BasicOverviewSlotValue).Value), 64)
			bb, _ := strconv.ParseFloat(tools.Strval(b.(types.BasicOverviewSlotValue).Value), 64)
			return aa > bb
		}
	}
	results.By = time_by
	sort.Sort(results)
	for i := 0; i < len(in); i++ {
		in[i] = results.Slice[i].(types.BasicOverviewSlotValue)
	}
	return in
}

func (s *SwitchService) SwitchDetailsOverview(ctx context.Context, par dto.SwitchDetailsOverviewReq) (*dto.SwitchDetailsOverviewRsp, error) {

	rpcSwitch, err := s.Store.SwitchRpcClient.SwitchDetails(ctx, &switch_rpc.SwitchDetailsRequest{
		Id: par.Id,
	})

	if err != nil {
		return nil, err
	}
	ip := rpcSwitch.Ip

	var (
		detailsOverview []types.BasicOverviewSlot
		interfaceStatus []types.BasicOverviewSlot
		cpuLoad         float64
		memLoad         float64
	)

	//cpu使用率
	cpuSp, err := s.Store.AlarmRpcClient.ListPromQLs(ctx, server.TemplateMap[server.SwitchCpuUsageRate]([]string{ip}))
	if err != nil {
		return nil, err
	}
	cpuPromQL := cpuSp.Items[0].RealPromql
	klog.Info("cpuPromQL", cpuPromQL)
	cpu, err := prom_client.VectorQuery(ctx, cpuPromQL)
	if err != nil {
		klog.Info(err)
	}
	for _, v := range cpu {
		if math.IsNaN(float64(v.Value)) {
			v.Value = 0
		}
		cpuLoad = tools.FormPercent(float64(v.Value))
	}
	cpuRes := types.BasicOverviewSlot{
		Info: types.BasicOverviewSlotInfo{
			Name:     "CpuUsage",
			Value:    cpuLoad,
			Unit:     "",
			UnitType: types.TypeNumber,
		},
	}

	//mem使用率
	memSp, err := s.Store.AlarmRpcClient.ListPromQLs(ctx, server.TemplateMap[server.SwitchMemUsageRate]([]string{ip}))
	if err != nil {
		return nil, err
	}
	memPromQL := memSp.Items[0].RealPromql
	klog.Info("memPromQL", memPromQL)
	mem, err := prom_client.VectorQuery(ctx, memPromQL)
	if err != nil {
		klog.Info(err)
	}
	for _, v := range mem {
		if math.IsNaN(float64(v.Value)) {
			v.Value = 0
		}
		memLoad = tools.FormPercent(float64(v.Value))
	}
	memRes := types.BasicOverviewSlot{
		Info: types.BasicOverviewSlotInfo{
			Name:     "MemoryUsage",
			Value:    memLoad,
			Unit:     "",
			UnitType: types.TypeNumber,
		},
	}

	detailsOverview = append(detailsOverview, cpuRes, memRes)

	faultList := []string{"故障", "正常", "关闭"}
	for _, name := range faultList {
		var interfaceStatusInfo types.BasicOverviewSlot
		value := 0
		switch name {
		case "正常":
			value = int(rpcSwitch.InterfaceNormalCount)
		case "故障":
			value = int(rpcSwitch.InterfaceFaultCount)
		case "关闭":
			value = int(rpcSwitch.InterfaceShutdownCount)
		}
		interfaceStatusInfo.Info = types.BasicOverviewSlotInfo{
			Index:     0,
			Name:      name,
			Value:     value,
			UnitType:  types.TypeNumber,
			Unit:      "个",
			Prognosis: 0,
		}
		interfaceStatus = append(interfaceStatus, interfaceStatusInfo)
	}

	return &dto.SwitchDetailsOverviewRsp{
		DetailsOverview: detailsOverview,
		InterfaceStatus: interfaceStatus,
	}, nil

}

func (s *SwitchService) SwitchDetailsLine(ctx context.Context, par dto.SwitchDetailsLineReq) (*dto.SwitchDetailsOverviewLineRsp, error) {

	rpcSwitch, err := s.Store.SwitchRpcClient.SwitchDetails(ctx, &switch_rpc.SwitchDetailsRequest{
		Id: par.Id,
	})

	if err != nil {
		klog.Info("getSwitchDetailsFail")
		return nil, err
	}

	ip := rpcSwitch.Ip
	start := par.Start / 1e3
	end := par.End / 1e3
	step := tools.TimeToStepForInt(end - start)

	var lines []types.BasicOverviewSlot

	for i := 0; i < len(par.MetricName); i++ {

		switch par.MetricName[i] {
		case "Cpu": //cpu使用率
			cpuMode, err := s.Store.AlarmRpcClient.ListPromQLs(ctx, server.TemplateMap[server.SwitchCpuUsageRate]([]string{ip}))
			if err != nil {
				return nil, err
			}
			fmt.Println("cpuMode", cpuMode)
			realPromql := cpuMode.Items[0].RealPromql
			fmt.Println("cpuSql", realPromql)
			matrix, err := prom_client.MatrixQuery(ctx, realPromql, v1.Range{
				Start: time.Unix(start, 0),
				End:   time.Unix(end, 0),
				Step:  time.Duration(step) * time.Second,
			})
			if err != nil {
				fmt.Printf("Error querying Prometheus: %v\n", err)
			}
			for _, m := range matrix {
				line := types.BasicOverviewSlot{}

				line.Info = types.BasicOverviewSlotInfo{
					Index:    0,
					Name:     "Cpu使用率",
					Value:    0,
					UnitType: types.TypeNumber,
					Unit:     "",
				}

				for _, p := range m.Values {
					timeStamp := p.Timestamp
					value := p.Value
					line.Values = append(line.Values, types.BasicOverviewSlotValue{
						Name:        timeStamp.String(),
						Value:       value,
						UnitType:    types.TypeNumber,
						Unit:        "",
						Kind:        "",
						Description: "",
					})
				}

				lines = append(lines, line)
			}
		case "Memory": //内存使用率
			cpuMode, err := s.Store.AlarmRpcClient.ListPromQLs(ctx, server.TemplateMap[server.SwitchMemUsageRate]([]string{ip}))
			if err != nil {
				return nil, err
			}
			realPromql := cpuMode.Items[0].RealPromql
			fmt.Println("memSql", realPromql)
			matrix, err := prom_client.MatrixQuery(ctx, realPromql, v1.Range{
				Start: time.Unix(start, 0),
				End:   time.Unix(end, 0),
				Step:  time.Duration(step) * time.Second,
			})
			if err != nil {
				fmt.Printf("Error querying Prometheus: %v\n", err)
			}
			for _, m := range matrix {
				line := types.BasicOverviewSlot{}

				line.Info = types.BasicOverviewSlotInfo{
					Index:    0,
					Name:     "内存使用率",
					Value:    0,
					UnitType: types.TypeNumber,
					Unit:     "",
				}

				for _, p := range m.Values {
					timeStamp := p.Timestamp
					value := p.Value
					line.Values = append(line.Values, types.BasicOverviewSlotValue{
						Name:        timeStamp.String(),
						Value:       value,
						Unit:        "",
						UnitType:    types.TypeNumber,
						Kind:        "",
						Description: "",
					})
				}

				lines = append(lines, line)
			}
		}
	}

	return &dto.SwitchDetailsOverviewLineRsp{
		Lines: lines,
	}, nil

}

type HardwareState struct {
	State string `json:"state" description:"状态"`
	Name  string `json:"name" description:"名称"`
}

var StateSlice = []HardwareState{
	{
		State: "1",
		Name:  "正常",
	},
	{
		State: "2",
		Name:  "告警",
	},
	{
		State: "3",
		Name:  "故障",
	},
	{
		State: "0",
		Name:  "未知",
	},
}

func (s *SwitchService) SwitchHardware(ctx context.Context, par dto.SwitchHardwareReq) (*dto.SwitchHardwareRsp, error) {

	interfaceList, err := s.Store.SwitchRpcClient.SwitchInterfaceList(ctx, &switch_rpc.SwitchInterfaceListRequest{
		Sn:       par.Sn,
		PageNo:   1,
		PageSize: -1,
	})
	if err != nil {
		klog.Error("getSwitchInterfaceListFail", interfaceList)
	}

	hardware, _ := s.Store.AssetSwitchDao.GetSwitchHardwareInfo(ctx, par.Sn)
	fmt.Printf("hardware %+v", hardware)
	var (
		inTemp     []types.BasicOverviewSlot
		outTemp    []types.BasicOverviewSlot
		portStatus []types.BasicOverviewSlot
		cpuState   []types.BasicOverviewSlot
		memState   []types.BasicOverviewSlot
		powerState []types.BasicOverviewSlot
		fanState   []types.BasicOverviewSlot
		boardList  []dto.MainBoard
		cpuList    dto.CpuDetail
		memList    dto.MemDetail
		powerList  []dto.Power
		fanList    []dto.Fan
	)

	var inlet types.BasicOverviewSlot
	var outlet types.BasicOverviewSlot
	inlet.Info = types.BasicOverviewSlotInfo{
		Name:  "进风口温度",
		Value: hardware.AirInlet,
	}
	outlet.Info = types.BasicOverviewSlotInfo{
		Name:  "出风口温度",
		Value: hardware.AirOutlet,
	}
	inTemp = append(inTemp, inlet)
	outTemp = append(outTemp, outlet)

	//接口运行状态
	interfaceMap := make(map[int]int)
	for _, status := range interfaceList.Data {
		interfaceMap[int(status.PortState)]++
	}
	portStat, _ := GetHardwareInterfaceStatus(s.Store, ctx, interfaceMap)
	portStatus = append(portStatus, portStat)

	//cpu
	stateMapCpu := make(map[int]int)
	for _, v := range hardware.CpuInfo {
		cpuList.Sum++
		mainHertz := strconv.Itoa(v.MainHertz)
		maxHertz := strconv.Itoa(v.MaxHertz)

		cpuList.CpuList = append(cpuList.CpuList, dto.Cpu{
			Name:        v.Name,
			State:       v.Health,
			UsedRate:    v.Utilization,
			Temperature: v.Temperature,
			Model:       v.CPUType,
			ClockSpeed:  mainHertz + "MHz",
			MaxClock:    maxHertz + "MHz",
		})

		if h, ok := stateMapCpu[v.Health]; ok {
			stateMapCpu[v.Health] = h + 1
		} else {
			stateMapCpu[v.Health] = 1
		}
	}

	cpuStat, _ := GetHardwareStatus("CPU健康状态", stateMapCpu)
	cpuState = append(cpuState, cpuStat)

	//mem
	stateMapMem := make(map[int]int)
	var capSum int
	for _, mem := range hardware.MemoryInfo {
		memList.Sum++
		capSum += mem.Capacity / 1024
		memList.MemList = append(memList.MemList, dto.Memory{
			Name:          mem.Name,
			State:         mem.Health,
			UsedRate:      mem.Utilization,
			In:            getSwitchPartExist(mem.Exist),
			Position:      mem.Location,
			Channl:        mem.Tunnel,
			Slot:          mem.SlotNum,
			Model:         mem.MemType,
			Ranks:         mem.Ranks,
			Width:         mem.BitWide,
			Capacity:      mem.Capacity,
			Tech:          mem.Technology,
			Sn:            mem.SerialNum,
			ProductNum:    mem.PartNum,
			ProducFactory: mem.MfgName,
		})
		if h, ok := stateMapMem[mem.Health]; ok {
			stateMapMem[mem.Health] = h + 1
		} else {
			stateMapMem[mem.Health] = 1
		}
	}
	memList.Capacity = strconv.Itoa(capSum)
	memStat, _ := GetHardwareStatus("内存健康状态", stateMapMem)
	memState = append(memState, memStat)

	//电源
	stateMapPower := make(map[int]int)
	for _, power := range hardware.PowerInfo {
		powerList = append(powerList, dto.Power{
			Id:              power.Name,
			State:           power.Health,
			In:              getSwitchPartExist(power.Exist),
			Temperature:     power.Temperature,
			RatedPower:      fmt.Sprintf("%dW", power.RatedPower),
			InputPower:      fmt.Sprintf("%dW", power.InPower),
			PowerInputModel: power.InModel,
			Model:           power.PowerType,
			FireWare:        power.FirmwareVersion,
			Sn:              power.SerialNum,
			ProductNum:      power.PartNum,
			ProducFactory:   power.MfgName,
		})
		if h, ok := stateMapPower[power.Health]; ok {
			stateMapPower[power.Health] = h + 1
		} else {
			stateMapPower[power.Health] = 1
		}
	}
	powerStat, _ := GetHardwareStatus("电源健康状态", stateMapPower)
	powerState = append(powerState, powerStat)

	//风扇
	stateMapFan := make(map[int]int)
	for _, fan := range hardware.FanInfo {
		fanList = append(fanList, dto.Fan{
			Name:       fan.Name,
			State:      fan.Health,
			In:         getSwitchPartExist(fan.Exist),
			Speed:      fan.Speed,
			SpeedRate:  fan.SpeedRatio,
			Redundancy: getSwitchPartRedundancy(fan.Redundant),
		})
		if h, ok := stateMapFan[fan.Health]; ok {
			stateMapFan[fan.Health] = h + 1
		} else {
			stateMapFan[fan.Health] = 1
		}
	}
	fanStat, _ := GetHardwareStatus("风扇健康状态", stateMapFan)
	fanState = append(fanState, fanStat)

	//主板
	for _, board := range hardware.BaseboardInfo {
		boardList = append(boardList, dto.MainBoard{
			Name:          board.Name,
			State:         board.Health,
			Sn:            board.SerialNum,
			ProductNum:    board.PartNum,
			ProductTime:   board.ManufacturedDate,
			ProducFactory: board.MfgName,
		})
	}

	return &dto.SwitchHardwareRsp{
		InTemp:        inTemp,
		OutTemp:       outTemp,
		PortStatus:    portStatus,
		CpuState:      cpuState,
		MemState:      memState,
		PowerState:    powerState,
		FanState:      fanState,
		MainBoardList: boardList,
		CpuList:       cpuList,
		MemList:       memList,
		PowerList:     powerList,
		FanList:       fanList,
	}, nil

}

func GetHardwareStatus(name string, statusMap map[int]int) (types.BasicOverviewSlot, error) {
	slot := types.BasicOverviewSlot{}
	slot.Info = types.BasicOverviewSlotInfo{
		Name: name,
	}
	for _, v := range StateSlice {
		state, _ := strconv.ParseFloat(v.State, 64)
		value, _ := statusMap[int(state)]
		slot.Values = append(slot.Values, types.BasicOverviewSlotValue{
			Name:  v.Name,
			Value: value,
		})
	}
	return slot, nil
}

func getSwitchPartExist(b bool) string {
	var In string = "不在位"
	if b {
		In = "在位"
	}
	return In
}
func getSwitchPartRedundancy(b bool) string {
	var In string = "不冗余"
	if b {
		In = "冗余"
	}
	return In
}

func GetHardwareInterfaceStatus(s dao.SwitchStore, ctx context.Context, interfaceMap map[int]int) (types.BasicOverviewSlot, error) {
	slot := types.BasicOverviewSlot{}
	slot.Info = types.BasicOverviewSlotInfo{
		Name: "接口运行状态",
	}
	//接口运行状态 1:运行中;2:关闭;3:故障
	interfaceStatus := []string{"正常", "关闭", "故障"}
	for _, v := range interfaceStatus {
		var value int
		switch v {
		case "正常":
			value = interfaceMap[1]
		case "关闭":
			value = interfaceMap[2]
		case "故障":
			value = interfaceMap[3]
		}

		slot.Values = append(slot.Values, types.BasicOverviewSlotValue{
			Name:  v,
			Value: value,
		})
	}
	return slot, nil
}

func (s *SwitchService) SwitchInterfaceLine(ctx context.Context, par dto.SwitchInterfaceLineReq) (*dto.SwitchDetailsOverviewLineRsp, error) {

	rpcSwitch, err := s.Store.SwitchRpcClient.SwitchDetails(ctx, &switch_rpc.SwitchDetailsRequest{
		Id: par.Id,
	})
	fmt.Println("rpcSwitch", rpcSwitch)
	if err != nil {
		klog.Info("getSwitchDetailsFail", err)
		return nil, err
	}

	ip := rpcSwitch.Ip
	start := par.Start / 1e3
	end := par.End / 1e3
	step := tools.TimeToStepForInt(end - start)
	//t := tools.FormatTime(float64(par.End/1000 - par.Start/1000))

	var lines []types.BasicOverviewSlot

	for i := 0; i < len(par.MetricName); i++ {
		var (
			promql   string
			infoName string
			unit     string
			UnitType string
		)
		switch par.MetricName[i] {
		case "InFlow": //接收速率
			p, err := s.Store.AlarmRpcClient.ListPromQLs(ctx, server.MultipleKeysTemplateMap[server.SwitchInFlow]([]*alarmv1alpha.Label{
				{
					Key:       "instance",
					Value:     ip,
					Operation: "=~",
				}, {
					Key:       "ifIndex",
					Value:     par.Index,
					Operation: "=",
				},
			}))
			if err != nil {
				fmt.Printf("Error querying Prometheus: %v\n", err)
			}
			promql = p.Items[0].RealPromql
			infoName = "接收速率"
			unit = "bps"
			UnitType = types.TypeStorage
		case "OutFlow": //发送速率
			p, err := s.Store.AlarmRpcClient.ListPromQLs(ctx, server.MultipleKeysTemplateMap[server.SwitchOutFlow]([]*alarmv1alpha.Label{
				{
					Key:       "instance",
					Value:     ip,
					Operation: "=~",
				}, {
					Key:       "ifIndex",
					Value:     par.Index,
					Operation: "=",
				},
			}))
			if err != nil {
				fmt.Printf("Error querying Prometheus: %v\n", err)
			}
			promql = p.Items[0].RealPromql
			infoName = "发送速率"
			unit = "bps"
			UnitType = types.TypeStorage
		case "InBandRate": //接收带宽利用率
			promql = server.SwitchInterfaceBandOutRates(ip, par.Index, "10m")
			infoName = "接收带宽利用率"
			unit = "%"
			UnitType = types.TypePercent
		case "OutBandRate": //发送带宽利用率
			promql = server.SwitchInterfaceBandOutRates(ip, par.Index, "10m")
			promql = server.SwitchInterfaceBandOutRates(ip, par.Index, "10m")
			infoName = "发送带宽利用率"
			unit = "%"
			UnitType = types.TypePercent
		case "inErrRate": //接收错包率
			promql = server.SwitchInterfaceOutErrRates(ip, par.Index, "10m")
			infoName = "接收错包率"
			unit = "%"
			UnitType = types.TypePercent
		case "OutErrRate": //接收错包率
			promql = server.SwitchInterfaceOutErrRates(ip, par.Index, "10m")
			infoName = "发送错包率"
			unit = "%"
			UnitType = types.TypePercent
		case "InDropRate":
			promql = server.SwitchInterfaceInDropRates(ip, par.Index, "10m")
			infoName = "接收丢包率"
			unit = "%"
			UnitType = types.TypePercent
		case "OutDropRate":
			promql = server.SwitchInterfaceOutDropRates(ip, par.Index, "10m")
			infoName = "接收丢包率"
			unit = "%"
			UnitType = types.TypePercent
		case "InPacketRate": //接收包速率
			p, err := s.Store.AlarmRpcClient.ListPromQLs(ctx, server.MultipleKeysTemplateMap[server.SwitchInPacketRate]([]*alarmv1alpha.Label{
				{
					Key:       "instance",
					Value:     ip,
					Operation: "=~",
				}, {
					Key:       "ifIndex",
					Value:     par.Index,
					Operation: "=",
				},
			}))
			if err != nil {
				fmt.Printf("Error querying Prometheus: %v\n", err)
			}
			promql = p.Items[0].RealPromql
			infoName = "接收包速率"
			unit = "pps"
			UnitType = types.TypeStorage
		case "OutPacketRate": //发送包速率
			p, err := s.Store.AlarmRpcClient.ListPromQLs(ctx, server.MultipleKeysTemplateMap[server.SwitchOutPacketRate]([]*alarmv1alpha.Label{
				{
					Key:       "instance",
					Value:     ip,
					Operation: "=~",
				}, {
					Key:       "ifIndex",
					Value:     par.Index,
					Operation: "=",
				},
			}))
			if err != nil {
				fmt.Printf("Error querying Prometheus: %v\n", err)
			}
			promql = p.Items[0].RealPromql
			infoName = "发送包速率"
			unit = "pps"
			UnitType = types.TypeStorage
		case "InErrNum":
			promql = server.SwitchInterfaceInErrNum(ip, par.Index, "10m")
			infoName = "每秒接收错包数"
			unit = "pps"
			UnitType = types.TypeNumber
		case "OutErrNum":
			promql = server.SwitchInterfaceOutErrNum(ip, par.Index, "10m")
			infoName = "每秒发送错包数"
			unit = "pps"
			UnitType = types.TypeNumber
		case "InDropNum":
			promql = server.SwitchInterfaceInDropNum(ip, par.Index, "10m")
			infoName = "每秒接收丢包数"
			unit = "pps"
			UnitType = types.TypeNumber
		case "OutDropNum":
			promql = server.SwitchInterfaceOutDropNum(ip, par.Index, "10m")
			infoName = "每秒接收丢包数"
			unit = "pps"
			UnitType = types.TypeNumber

		}
		fmt.Println("promqlName", infoName)
		fmt.Println("promql", promql)
		matrix, err := prom_client.MatrixQuery(ctx, promql, v1.Range{Start: time.Unix(start, 0), End: time.Unix(end, 0), Step: time.Duration(step) * time.Second})
		if err != nil {
			fmt.Printf("Error querying Prometheus: %v\n", err)
		}
		var matrixValue []float64
		for _, m := range matrix {
			line := types.BasicOverviewSlot{}

			for _, p := range m.Values {
				if math.IsNaN(float64(p.Value)) {
					p.Value = 0
				}
				timeStamp := p.Timestamp
				value := p.Value
				line.Values = append(line.Values, types.BasicOverviewSlotValue{
					Name:     timeStamp.String(),
					Value:    value,
					UnitType: UnitType,
					Unit:     unit,
				})
				matrixValue = append(matrixValue, float64(value))
			}
			current := m.Values[len(m.Values)-1].Value
			line.Info = types.BasicOverviewSlotInfo{
				Index:     0,
				Name:      infoName,
				Min:       tools.GetMin(matrixValue),
				Max:       tools.GetMin(matrixValue),
				Avg:       tools.GetAvg(matrixValue),
				Value:     current,
				Unit:      unit,
				UnitType:  UnitType,
				Prognosis: 0, //预测值，values的下标，0则无预测值
			}
			lines = append(lines, line)
		}
	}

	return &dto.SwitchDetailsOverviewLineRsp{
		Lines: lines,
	}, nil

}

func (s *SwitchService) SwitchInterfaceList(ctx context.Context, par dto.SwitchInterfaceListReq) (*dto.SwitchInterfaceListRsp, error) {

	switchInfo, err := s.Store.SwitchRpcClient.SwitchDetails(ctx, &switch_rpc.SwitchDetailsRequest{
		Id: int32(par.Id),
	})
	if err != nil {
		klog.Error("getSwitchDetailsFail", err)
		return nil, err
	}
	ip := switchInfo.Ip
	sn := switchInfo.Sn

	interfaceList, err := s.Store.SwitchRpcClient.SwitchInterfaceList(ctx, &switch_rpc.SwitchInterfaceListRequest{
		PageNo:    1,
		PageSize:  -1,
		Query:     par.Query,
		Sn:        sn,
		PortState: par.PortState,
	})
	if err != nil {
		klog.Error("getSwitchInterfaceListFail", err)
		return nil, err
	}

	var list []dto.SwitchInterfaceList
	var indexList []string

	for _, v := range interfaceList.Data {
		timeObj := v.LastUpdateAt.AsTime()
		info := dto.SwitchInterfaceList{
			Id:                int(v.Id),
			Sn:                v.Sn,
			IfName:            v.IfName,
			IfIndex:           int(v.IfIndex),
			IfIp:              v.IfIp,
			IfMac:             v.IfMac,
			IfSpeed:           int(v.IfSpeed),
			OrtherEndDevice:   v.OrtherEndDevice,
			OrtherEndDeviceId: int(v.OrtherEndDeviceId),
			OrtherEndIf:       v.OrtherEndIf,
			OrtherEndDescr:    v.OrtherEndDescr,
			OrtherEndType:     v.OrtherEndType,
			PortState:         int(v.PortState),
			LastUpdateAt:      timeObj.Format("2006-01-02 15:04:05"),
		}

		index := strconv.Itoa(int(v.IfIndex))
		indexList = append(indexList, index)
		//
		//if ins, ok := ipIndexMap[ip]; ok {
		//	ipIndexMap[ip] = append(ins, index)
		//} else {
		//	ipIndexMap[ip] = []string{index}
		//}

		list = append(list, info)
	}
	indexs := strings.Join(indexList, "|")

	outDropMap := make(map[string]float64, len(list))
	inDropMap := make(map[string]float64, len(list))
	outErrMap := make(map[string]float64, len(list))
	inErrMap := make(map[string]float64, len(list))
	outBandMap := make(map[string]float64, len(list))
	inBandMap := make(map[string]float64, len(list))

	//发送丢包率
	outDropPsql := server.SwitchInterfaceOutDropRates(ip, indexs, "10m")
	klog.Info("outDropPsql", outDropPsql)
	outDropRate, err := prom_client.VectorQuery(ctx, outDropPsql)
	if err != nil {
		klog.Error("outDropRate", err)
	}
	for _, v := range outDropRate {
		if math.IsNaN(float64(v.Value)) {
			v.Value = 0
		}
		index := string(v.Metric["ifIndex"])
		outDropMap[index] = tools.FormPercent(float64(v.Value))
	}

	//接收丢包率
	inDropPsql := server.SwitchInterfaceInDropRates(ip, indexs, "10m")
	klog.Info("inDropPsql", inDropPsql)
	inDropRate, err := prom_client.VectorQuery(ctx, inDropPsql)
	if err != nil {
		klog.Error("inDropRate", err)
	}
	for _, v := range inDropRate {
		if math.IsNaN(float64(v.Value)) {
			v.Value = 0
		}
		index := string(v.Metric["ifIndex"])
		inDropMap[index] = tools.FormPercent(float64(v.Value))
	}

	//发送错包率
	outErrRatePsql := server.SwitchInterfaceOutErrRates(ip, indexs, "10m")
	klog.Info("outErrRatePsql", outErrRatePsql)
	outErrRate, err := prom_client.VectorQuery(ctx, outErrRatePsql)
	if err != nil {
		klog.Error("outErrRate", err)
	}
	for _, v := range outErrRate {
		if math.IsNaN(float64(v.Value)) {
			v.Value = 0
		}
		index := string(v.Metric["ifIndex"])
		outErrMap[index] = tools.FormPercent(float64(v.Value))
	}

	//接收错包率
	inErrRatePsql := server.SwitchInterfaceInErrRates(ip, indexs, "10m")
	klog.Info("inErrRatePsql", inErrRatePsql)
	inErrRate, err := prom_client.VectorQuery(ctx, inErrRatePsql)
	if err != nil {
		klog.Error("inErrRate", err)
	}
	for _, v := range inErrRate {
		if math.IsNaN(float64(v.Value)) {
			v.Value = 0
		}
		index := string(v.Metric["ifIndex"])
		inErrMap[index] = tools.FormPercent(float64(v.Value))
	}

	//发送带宽利用率
	outBandRatePsql := server.SwitchInterfaceBandOutRates(ip, indexs, "10m")
	klog.Info("outBandRatePsql", outBandRatePsql)
	outBandRate, err := prom_client.VectorQuery(ctx, outBandRatePsql)
	if err != nil {
		klog.Error("outBandRate", err)
	}
	for _, v := range outBandRate {
		if math.IsNaN(float64(v.Value)) {
			v.Value = 0
		}
		index := string(v.Metric["ifIndex"])
		inBandMap[index] = tools.FormPercent(float64(v.Value))
	}

	//接收带宽利用率
	inBandRatePsql := server.SwitchInterfaceBandInRates(ip, indexs, "10m")
	klog.Info("inBandRatePsql", outBandRatePsql)
	inBandRate, err := prom_client.VectorQuery(ctx, inBandRatePsql)
	if err != nil {
		klog.Error("inBandRate", err)
	}
	for _, v := range inBandRate {
		if math.IsNaN(float64(v.Value)) {
			v.Value = 0
		}
		index := string(v.Metric["ifIndex"])
		outBandMap[index] = tools.FormPercent(float64(v.Value))
	}

	for k, v := range list {
		index := strconv.Itoa(v.IfIndex)
		if outDrop, ok := outDropMap[index]; ok {
			list[k].OutDropRate = outDrop
		}
		if inDrop, ok := inDropMap[index]; ok {
			list[k].InDropRate = inDrop
		}
		if outErr, ok := outErrMap[index]; ok {
			list[k].OutErrRate = outErr
		}
		if inErr, ok := inErrMap[index]; ok {
			list[k].InErrRate = inErr
		}
		if outBand, ok := outBandMap[index]; ok {
			list[k].OutBandRate = outBand
		}
		if inBand, ok := inBandMap[index]; ok {
			list[k].InBandRate = inBand
		}
	}

	//order
	if par.OrderCode != "" && par.OrderType != "" {
		results := utils.Bucket{}
		for i := 0; i < len(list); i++ {
			results.Slice = append(results.Slice, list[i])
		}
		time_by := func(a, b interface{}) bool {
			return true
		}
		switch par.OrderCode {
		case "OutDropRate":
			switch par.OrderType {
			case "ASC":
				time_by = func(a, b interface{}) bool {
					return a.(dto.SwitchInterfaceList).OutDropRate < b.(dto.SwitchInterfaceList).OutDropRate
				}
			case "DESC":
				time_by = func(a, b interface{}) bool {
					return a.(dto.SwitchInterfaceList).OutDropRate > b.(dto.SwitchInterfaceList).OutDropRate
				}
			}
		case "InDropRate":
			switch par.OrderType {
			case "ASC":
				time_by = func(a, b interface{}) bool {
					return a.(dto.SwitchInterfaceList).InDropRate < b.(dto.SwitchInterfaceList).InDropRate
				}
			case "DESC":
				time_by = func(a, b interface{}) bool {
					return a.(dto.SwitchInterfaceList).InDropRate > b.(dto.SwitchInterfaceList).InDropRate
				}
			}
		case "OutErrRate":
			switch par.OrderType {
			case "ASC":
				time_by = func(a, b interface{}) bool {
					return a.(dto.SwitchInterfaceList).OutErrRate < b.(dto.SwitchInterfaceList).OutErrRate
				}
			case "DESC":
				time_by = func(a, b interface{}) bool {
					return a.(dto.SwitchInterfaceList).OutErrRate > b.(dto.SwitchInterfaceList).OutErrRate
				}
			}
		case "InErrRate":
			switch par.OrderType {
			case "ASC":
				time_by = func(a, b interface{}) bool {
					return a.(dto.SwitchInterfaceList).InErrRate < b.(dto.SwitchInterfaceList).InErrRate
				}
			case "DESC":
				time_by = func(a, b interface{}) bool {
					return a.(dto.SwitchInterfaceList).InErrRate > b.(dto.SwitchInterfaceList).InErrRate
				}
			}
		case "OutBandRate":
			switch par.OrderType {
			case "ASC":
				time_by = func(a, b interface{}) bool {
					return a.(dto.SwitchInterfaceList).OutBandRate < b.(dto.SwitchInterfaceList).OutBandRate
				}
			case "DESC":
				time_by = func(a, b interface{}) bool {
					return a.(dto.SwitchInterfaceList).OutBandRate > b.(dto.SwitchInterfaceList).OutBandRate
				}
			}
		case "InBandRate":
			switch par.OrderType {
			case "ASC":
				time_by = func(a, b interface{}) bool {
					return a.(dto.SwitchInterfaceList).InBandRate < b.(dto.SwitchInterfaceList).InBandRate
				}
			case "DESC":
				time_by = func(a, b interface{}) bool {
					return a.(dto.SwitchInterfaceList).InBandRate > b.(dto.SwitchInterfaceList).InBandRate
				}
			}
		}
		results.By = time_by
		sort.Sort(results)
		for i := 0; i < len(results.Slice); i++ {
			list[i] = results.Slice[i].(dto.SwitchInterfaceList)
		}
	}

	//分页
	low := (par.PageNo - 1) * par.PageSize
	if low > len(list) {
		klog.Info("PageSize is too large")
	}

	hight := low + par.PageSize
	if hight > len(list) {
		hight = len(list)
	}

	var results dto.SwitchInterfaceListRsp
	results.PageSize = par.PageSize
	results.PageNo = par.PageNo
	results.TotalCount = int64(len(list))
	results.SwitchList = list[low:hight]

	return &results, err

}

```

File path: /Users/mac/Desktop/woker_code/monitor/modules/switch/rpc/rpcserver.go
```golang
package rpc

import (
	pb "ezone.ksyun.com/ezone/luban/luban_api/monitorapis/switch/v1alpha/gen"
	"ezone.ksyun.com/ezone/luban/monitor/modules/switch/service"
)

type switchRpcServer struct {
	switchSvc *service.SwitchService
	pb.UnimplementedSwitchServiceServer
}

func NewSwitchRpcServer() *switchRpcServer {
	return &switchRpcServer{
		switchSvc: service.NewSwitchService(),
	}
}

```

File path: /Users/mac/Desktop/woker_code/monitor/modules/switch/rpc/switch.go
```golang
package rpc

import (
	"context"

	"ezone.ksyun.com/ezone/luban/communal/lib"
	pb "ezone.ksyun.com/ezone/luban/luban_api/monitorapis/switch/v1alpha/gen"
	"ezone.ksyun.com/ezone/luban/monitor/modules/switch/dto"
	"github.com/jinzhu/copier"
	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/status"
)

func (n *switchRpcServer) SwitchInterfaceList(ctx context.Context, req *pb.SwitchInterfaceListReq) (*pb.SwitchInterfaceListRsp, error) {
	lib.Log.TagInfo(lib.GetTraceContext(ctx), lib.DLTagRequestIn, map[string]interface{}{"params": req})
	var par dto.SwitchInterfaceListReq
	if err := copier.Copy(&par, req); err != nil {
		lib.Log.TagError(lib.GetTraceContext(ctx), lib.DLTagUndefind, map[string]interface{}{"copy err": err})
		return nil, status.Error(codes.Internal, err.Error())
	}
	res, err := n.switchSvc.SwitchInterfaceList(ctx, par)
	if err != nil {
		lib.Log.TagError(lib.GetTraceContext(ctx), lib.DLTagUndefind, map[string]interface{}{"call service err": err})
		return nil, status.Error(codes.Internal, err.Error())
	}
	resp := &pb.SwitchInterfaceListRsp{}
	copier.Copy(&resp, res)
	return resp, nil
}

func (n *switchRpcServer) SwitchList(ctx context.Context, req *pb.SwitchListReq) (*pb.SwitchListRsp, error) {
	lib.Log.TagInfo(lib.GetTraceContext(ctx), lib.DLTagRequestIn, map[string]interface{}{"params": req})
	var par dto.SwitchListReq
	if err := copier.Copy(&par, req); err != nil {
		lib.Log.TagError(lib.GetTraceContext(ctx), lib.DLTagUndefind, map[string]interface{}{"copy err": err})
		return nil, status.Error(codes.Internal, err.Error())
	}
	res, err := n.switchSvc.SwitchList(ctx, par)
	if err != nil {
		lib.Log.TagError(lib.GetTraceContext(ctx), lib.DLTagUndefind, map[string]interface{}{"call service err": err})
		return nil, status.Error(codes.Internal, err.Error())
	}
	resp := &pb.SwitchListRsp{}
	copier.Copy(&resp, res)
	return resp, nil
}

func (n *switchRpcServer) SwitchHardware(ctx context.Context, req *pb.SwitchHardwareReq) (*pb.SwitchHardwareRsp, error) {
	lib.Log.TagInfo(lib.GetTraceContext(ctx), lib.DLTagRequestIn, map[string]interface{}{"params": req})
	var par dto.SwitchHardwareReq
	if err := copier.Copy(&par, req); err != nil {
		lib.Log.TagError(lib.GetTraceContext(ctx), lib.DLTagUndefind, map[string]interface{}{"copy err": err})
		return nil, status.Error(codes.Internal, err.Error())
	}
	res, err := n.switchSvc.SwitchHardware(ctx, par)
	if err != nil {
		lib.Log.TagError(lib.GetTraceContext(ctx), lib.DLTagUndefind, map[string]interface{}{"call service err": err})
		return nil, status.Error(codes.Internal, err.Error())
	}
	resp := &pb.SwitchHardwareRsp{}
	if err := copier.CopyWithOption(&resp, res, copier.Option{IgnoreEmpty: true}); err != nil { // 忽略nil
		lib.Log.TagError(lib.GetTraceContext(ctx), lib.DLTagUndefind, map[string]interface{}{"copy err": err})
		return nil, status.Error(codes.Internal, err.Error())
	}
	return resp, nil
}

```

File path: /Users/mac/Desktop/woker_code/monitor/modules/object_storage/dto/object_volume_request.go
```golang
package dto

type ObjectVolumeOverviewTopReq struct {
	Region     string   `json:"Region"`
	MetricName []string `json:"MetricName" binding:"required"`
	TopK       int      `json:"TopK" binding:"required"`
	Start      int64    `json:"Start" binding:"required"`
	End        int64    `json:"End" binding:"required"`
	DiskType   string   `json:"DiskType"`
}

type ObjectVolumeOverviewReq struct {
	Region     string     `json:"Region"`
	DiskType   string     `json:"DiskType"`
	MetricName [][]string `json:"MetricName" binding:"required"`
}

type ObjectVolumeDetailMetricReq struct {
	BucketId int64 `json:"BucketId" binding:"required"`
}

type ObjectVolumeDetailMetricLineReq struct {
	BucketId   int64    `json:"BucketId" binding:"required"`
	Start      int64    `json:"Start" binding:"required"`
	End        int64    `json:"End" binding:"required"`
	MetricName []string `json:"MetricName" binding:"required"`
}

```

File path: /Users/mac/Desktop/woker_code/monitor/modules/object_storage/dto/object_pool_request.go
```golang
package dto

// ListReq 资源池监控列表请求参数
type ListReq struct {
	PageNo    int               `json:"PageNo"`
	PageSize  int               `json:"PageSize"`
	Region    string            `json:"Region"`
	OrderCode string            `json:"OrderCode"`
	OrderType string            `json:"OrderType"`
	PoolType  []string          `json:"PoolType"`
	Query     map[string]string `json:"Query"`
}

// OverviewReq 资源池监控概览请求参数
type OverviewReq struct {
	Region   string `json:"Region"`
	PoolType string `json:"PoolType"`
}

// OverviewLineReq 资源池监控概览折线图请求参数
type OverviewLineReq struct {
	PoolType      string   `json:"PoolType"`
	Region        string   `json:"Region"`
	MetricName    []string `json:"MetricName"`
	Start         int64    `json:"Start"`
	End           int64    `json:"End"`
	HasPrediction bool     `json:"HasPrediction"`
}

// OverViewAlertReq 资源池监控概览告警请求参数
type OverViewAlertReq struct {
	Region   string `json:"Region"`
	PoolType string `json:"PoolType"`
}

// ObjectPoolDetailMetricReq 对象存储池监控详情
type ObjectPoolDetailMetricReq struct {
	PoolId     int64    `json:"PoolId"`
	PoolType   string   `json:"PoolType"`
	Region     string   `json:"Region"`
	MetricName []string `json:"MetricName"`
}

// ObjectPoolDetailMetricLineReq 对象存储池监控详情折线图
type ObjectPoolDetailMetricLineReq struct {
	PoolId     int64    `json:"PoolId"`
	PoolType   string   `json:"PoolType"`
	Region     string   `json:"Region"`
	MetricName []string `json:"MetricName"`
	Start      int64    `json:"Start"`
	End        int64    `json:"End"`
}

```

File path: /Users/mac/Desktop/woker_code/monitor/modules/object_storage/dto/object_pool_response.go
```golang
package dto

import "ezone.ksyun.com/ezone/luban/monitor/common/types"

// ListRes 资源池监控列表响应 --------------------------------
type ListRes struct {
	TotalCount int                     `json:"TotalCount"`
	PageNo     int                     `json:"PageNo"`
	PageSize   int                     `json:"PageSize"`
	DataList   []*ObjectStorageMonitor `json:"DataList"`
}

//type ObjectList struct {
//	Name         string    `json:"Name"`
//	Id           int       `json:"Id"`
//	RegionName   string    `json:"RegionName"`
//	RegionCode   string    `json:"RegionCode"`
//	AzCode       string    `json:"AzCode"`
//	ResourcePool string    `json:"ResourcePool"`
//	BucketNumber int       `json:"BucketNumber"`
//	HostNumber   int       `json:"HostNumber"`
//	TenantId     string    `json:"TenantId"`
//	TenantName   string    `json:"TenantName"`
//	ObjectNumber string    `json:"ObjectNumber"`
//	CreateTime   int64     `json:"CreateTime"`
//	Servers      []Ks3Host `json:"Servers"`
//	Status       string    `json:"Status"`
//	MetricUrl    string    `json:"MetricUrl"`
//}

type ObjectStorageMonitor struct {
	Id                int64   `json:"Id"`                // 资源池ID
	Name              string  `json:"Name"`              // 资源池名称
	DiskType          string  `json:"DiskType"`          // 存储类型
	MonitorStatus     int64   `json:"MonitorStatus"`     // 集群状态 1:正常 2:异常
	Region            string  `json:"Region"`            // 区域
	RegionCode        string  `json:"RegionCode"`        // 区域编码
	CapacityTotal     float64 `json:"CapacityTotal"`     // 总容量
	CapacityUsedTotal float64 `json:"CapacityUsedTotal"` // 已使用容量
	CapacityAvailable float64 `json:"CapacityAvailable"` // 可用容量
	CapacityUsedRate  float64 `json:"CapacityUsedRate"`  // 使用率
	BucketNumber      int64   `json:"BucketNumber"`      // 桶数量
	HostNumber        int64   `json:"HostNumber"`        // 主机数量
	UploadBandwidth   int64   `json:"UploadBandwidth"`   // 上传带宽 TODO
	DownloadBandwidth int64   `json:"DownloadBandwidth"` // 下载带宽 TODO
	//UploadFlow         int64   `json:"UploadFlow"`         // 上传流量 TODO
	//DownloadFlow       int64   `json:"DownloadFlow"`       // 下载流量 TODO
	//APIRequestAmount   int64   `json:"APIRequestAmount"`   // API请求次数 TODO
	//ErrorReturnAmount  int64   `json:"ErrorReturnAmount"`  // 错误返回次数 TODO
	HttpRequestAmount  int64 `json:"HttpRequestAmount"`  // HTTP请求次数 TODO
	HttpsRequestAmount int64 `json:"HttpsRequestAmount"` // HTTPS请求次数 TODO
	CreateTime         int64 `json:"CreateTime"`         // 创建时间
	AlertAmount        int64 `json:"AlertAmount"`        // 告警数量 TODO
}

type ObjectStorageServerStatus struct {
	Address string `json:"address"`
	Role    string `json:"role"`
	Status  string `json:"status"`
}

type Ks3Host struct {
	Ip        string `json:"Ip"`
	Port      int    `json:"Port"`
	Status    int    `json:"Status"`
	StatusMsg string `json:"StatusMsg"`
	Role      string `json:"Role"`
}

type ObjectPoolDetailMetricRes struct {
	Lines []types.BasicOverviewSlot `json:"Lines"`
}

type ObjectPoolDetailMetricLineRes struct {
	Lines []types.BasicOverviewSlot `json:"Lines"`
}

// OverViewRes 概览响应参数--------------------------------
type OverViewRes struct {
	ObjectPools        []types.BasicOverviewSlot `json:"ObjectPools"`
	ObjectVolumeCounts []types.BasicOverviewSlot `json:"ObjectVolumeCounts"`
}

// OverViewLineRes 概览折线图响应参数--------------------------------
type OverViewLineRes struct {
	Lines []types.BasicOverviewSlot `json:"Lines"`
}

// OverViewAlertRes 概览告警响应参数--------------------------------
type OverViewAlertRes struct {
	Alerts []types.BasicOverviewSlot `json:"Alerts"`
}

// OptionalObjectPoolResult 可选项列表--------------------------------
type OptionalObjectPoolResult map[string]any

```

File path: /Users/mac/Desktop/woker_code/monitor/modules/object_storage/dto/object_volume_response.go
```golang
package dto

import "ezone.ksyun.com/ezone/luban/monitor/common/types"

type ObjectVolumeOverviewTopRes struct {
	Tops []types.BasicOverviewSlot `json:"Tops"`
}

type ObjectVolumeOverviewRes struct {
	Overviews []types.BasicOverviewSlot `json:"Overviews"`
}

type ObjectVolumeDetailMetricRes struct {
	ResourceOverview  []ObjectVolumeDetailMetric `json:"ResourceOverview"`
	CreationTimestamp int64                      `json:"CreationTimestamp"`
}

type ObjectVolumeDetailMetric struct {
	PoolId   string      `json:"PoolId"`
	Name     string      `json:"Name"`
	Unit     string      `json:"Unit"`
	UnitType string      `json:"UnitType"`
	Value    interface{} `json:"Value"`
	Kind     string      `json:"Kind"`
}

type ObjectVolumeDetailMetricLineRes struct {
	Lines []types.BasicOverviewSlot `json:"Lines"`
}

```

File path: /Users/mac/Desktop/woker_code/monitor/modules/object_storage/dao/metric_top.go
```golang
package dao

import (
	"ezone.ksyun.com/ezone/luban/communal/lib"
	"ezone.ksyun.com/ezone/luban/monitor/common/gormSerializer"
	"ezone.ksyun.com/ezone/luban/monitor/modules/blockstorage/model"
	"gorm.io/gorm"
	"gorm.io/gorm/schema"
)

type MetricTopDao struct {
	db *gorm.DB
}

type QueryParams struct {
	Region string
	Code   string
}

func NewMetricTopDao() *MetricTopDao {
	schema.RegisterSerializer("json_str", gormSerializer.JSONSerializer{})
	return &MetricTopDao{
		db: lib.GORMMapPool["business"],
	}
}

func (m *MetricTopDao) GetOneByCode(q QueryParams) (model.MonitorTop, error) {
	var data model.MonitorTop
	if err := m.db.Where("region = ? AND code = ?", q.Region, q.Code).First(&data).Error; err != nil {
		return data, err
	}
	return data, nil
}

```

File path: /Users/mac/Desktop/woker_code/monitor/modules/object_storage/dao/object_pool.go
```golang
package dao

```

File path: /Users/mac/Desktop/woker_code/monitor/modules/object_storage/dao/metric.go
```golang
package dao

import (
	"ezone.ksyun.com/ezone/luban/communal/lib"
	"ezone.ksyun.com/ezone/luban/monitor/modules/blockstorage/model"
	"gorm.io/gorm"
)

type MetricDao struct {
	db *gorm.DB
}

func NewMetricDao() *MetricDao {
	return &MetricDao{
		db: lib.GORMMapPool["business"],
	}
}

// GetOneByCode 获取监控指标
func (m *MetricDao) GetOneByCode(code string) (*model.MonitorTsdbMetrics, error) {
	content := model.MonitorTsdbMetrics{}
	err := m.db.Where("code = ?", code).Find(&content).Error
	if err != nil {
		lib.Log.TagError(lib.NewTrace(), lib.DLTagMySqlFailed, map[string]interface{}{"error": err.Error()})
		return nil, err
	}
	return &content, nil
}

// GetListByCodes 获取监控指标列表
func (m *MetricDao) GetListByCodes(codes []string) ([]model.MonitorTsdbMetrics, error) {
	var content []model.MonitorTsdbMetrics
	err := m.db.Where("code in (?)", codes).Find(&content).Error
	if err != nil {
		lib.Log.TagError(lib.NewTrace(), lib.DLTagMySqlFailed, map[string]interface{}{"error": err.Error()})
		return nil, err
	}
	return content, nil
}

```

File path: /Users/mac/Desktop/woker_code/monitor/modules/object_storage/dao/overview.go
```golang
package dao

import (
	"ezone.ksyun.com/ezone/luban/communal/lib"
	alarmv1alpha "ezone.ksyun.com/ezone/luban/luban_api/alarmapis/alarm/v1alpha/gen"
	resource_objectstoragev1alpha "ezone.ksyun.com/ezone/luban/luban_api/resourceapis/resource_objectstorage/v1alpha/gen"
	resource_serverv1alpha "ezone.ksyun.com/ezone/luban/luban_api/resourceapis/resource_server/v1alpha/gen"
	"ezone.ksyun.com/ezone/luban/monitor/common/client/grpcx"
)

type Factory interface {
	Metric() *MetricDao
	MetricTop() *MetricTopDao

	AlarmRpcClient() alarmv1alpha.AlarmServiceClient
	ObjectPoolRpcClient() resource_objectstoragev1alpha.ObjectPoolServiceClient
	ObjectVolumeRpcClient() resource_objectstoragev1alpha.ObjectVolumeServiceClient
	ServerRpcClient() resource_serverv1alpha.ResourceServiceClient
}

var _ Factory = (*objectStorageStore)(nil)

type objectStorageStore struct {
}

func NewObjectStorageStore() *objectStorageStore {
	return &objectStorageStore{}
}

func (j *objectStorageStore) Metric() *MetricDao {
	return NewMetricDao()
}

func (j *objectStorageStore) MetricTop() *MetricTopDao {
	return NewMetricTopDao()
}

func (j *objectStorageStore) AlarmRpcClient() alarmv1alpha.AlarmServiceClient {
	alarmAddr := lib.GetStringConf("base.grpc.alarm")
	alarmConn, err := grpcx.NewGrpcClientConn(alarmAddr)
	if err != nil {
		lib.Log.TagError(lib.NewTrace(), lib.DLTagUndefind, map[string]interface{}{"connect alarm grpc server error, %s": err.Error()})
	}
	return alarmv1alpha.NewAlarmServiceClient(alarmConn)
}

func (j *objectStorageStore) ObjectPoolRpcClient() resource_objectstoragev1alpha.ObjectPoolServiceClient {
	resourceAddr := lib.GetStringConf("base.grpc.luban_resource")
	resourceConn, err := grpcx.NewGrpcClientConn(resourceAddr)
	if err != nil {
		lib.Log.TagError(lib.NewTrace(), lib.DLTagUndefind, map[string]interface{}{"connect luban_resource grpc server error, %s": err.Error()})
	}
	return resource_objectstoragev1alpha.NewObjectPoolServiceClient(resourceConn)
}

func (j *objectStorageStore) ObjectVolumeRpcClient() resource_objectstoragev1alpha.ObjectVolumeServiceClient {
	resourceAddr := lib.GetStringConf("base.grpc.luban_resource")
	resourceConn, err := grpcx.NewGrpcClientConn(resourceAddr)
	if err != nil {
		lib.Log.TagError(lib.NewTrace(), lib.DLTagUndefind, map[string]interface{}{"connect luban_resource grpc server error, %s": err.Error()})
	}
	return resource_objectstoragev1alpha.NewObjectVolumeServiceClient(resourceConn)
}

func (j *objectStorageStore) ServerRpcClient() resource_serverv1alpha.ResourceServiceClient {
	resourceAddr := lib.GetStringConf("base.grpc.luban_resource")
	resourceConn, err := grpcx.NewGrpcClientConn(resourceAddr)
	if err != nil {
		lib.Log.TagError(lib.NewTrace(), lib.DLTagUndefind, map[string]interface{}{"connect luban_resource grpc server error, %s": err.Error()})
	}
	return resource_serverv1alpha.NewResourceServiceClient(resourceConn)
}

```

File path: /Users/mac/Desktop/woker_code/monitor/modules/object_storage/dao/object_volume.go
```golang
package dao

```

File path: /Users/mac/Desktop/woker_code/monitor/modules/object_storage/controller/object_pool.go
```golang
package controller

import (
	"ezone.ksyun.com/ezone/luban/communal/lib"
	"ezone.ksyun.com/ezone/luban/monitor/common/consts"
	"ezone.ksyun.com/ezone/luban/monitor/modules/object_storage/dto"
	"ezone.ksyun.com/ezone/luban/monitor/modules/object_storage/service"
	"ezone.ksyun.com/ezone/luban/monitor/response"
	"github.com/gin-gonic/gin"
	"net/http"
)

type ObjectPoolController struct {
	svc service.ObjectPoolService
}

func NewObjectPoolController() *ObjectPoolController {
	return &ObjectPoolController{
		svc: service.NewObjectPoolService(),
	}
}

// OverviewMonitor godoc
// @Summary      ObjectPool Monitor OverviewMonitor
// @Description  资源池-对象存储-概览
// @Tags         ObjectPool
// @Accept       json
// @Produce      json
// @Param        body body dto.OverviewReq true "object pool monitor Overview monitor request"
// @Success      200  {object}  dto.OverViewRes
// @Router       /object_storage/object_pool/overview_monitor [POST]
func (j *ObjectPoolController) OverviewMonitor(c *gin.Context) {
	var params dto.OverviewReq
	if err := c.ShouldBind(&params); err != nil {
		lib.Log.TagError(lib.GetTraceContext(c), lib.DLTagRequestOut, map[string]interface{}{"error": err.Error(), "params": params})
		response.Failed(c, http.StatusBadRequest, consts.ParameterError, "参数绑定失败")
		return
	}
	lib.Log.TagInfo(lib.GetTraceContext(c), lib.DLTagResponseSuccess, map[string]interface{}{"params": params})

	// 业务处理
	res, err := j.svc.Overview(c, params)
	if err != nil {
		lib.Log.TagError(lib.GetTraceContext(c), lib.DLTagResponseFailed, map[string]interface{}{"error": err.Error()})
		response.Failed(c, http.StatusInternalServerError, consts.GainFail, "获取对象存储概览信息失败")
		return
	}

	lib.Log.TagInfo(lib.GetTraceContext(c), lib.DLTagResponseSuccess, map[string]interface{}{"res": res})
	response.Success(c, res)
}

// OverviewLine godoc
// @Summary      ObjectPool Monitor OverviewLine
// @Description  资源池-对象存储-概览折线图
// @Tags         ObjectPool
// @Accept       json
// @Produce      json
// @Param        body body dto.OverviewLineReq true "object pool monitor overview line request"
// @Success      200  {object}  dto.OverViewLineRes
// @Router       /object_storage/object_pool/overview_line [POST]
func (j *ObjectPoolController) OverviewLine(c *gin.Context) {
	var params dto.OverviewLineReq
	if err := c.ShouldBind(&params); err != nil {
		lib.Log.TagError(lib.GetTraceContext(c), lib.DLTagRequestOut, map[string]interface{}{"error": err.Error(), "params": params})
		response.Failed(c, http.StatusBadRequest, consts.ParameterError, "参数绑定失败")
		return
	}
	lib.Log.TagInfo(lib.GetTraceContext(c), lib.DLTagResponseSuccess, map[string]interface{}{"params": params})

	// 业务处理
	res, err := j.svc.OverviewLine(c, params)
	if err != nil {
		lib.Log.TagError(lib.GetTraceContext(c), lib.DLTagResponseFailed, map[string]interface{}{"error": err.Error()})
		response.Failed(c, http.StatusInternalServerError, consts.GainFail, "获取对象存储概览线信息失败")
		return
	}

	lib.Log.TagInfo(lib.GetTraceContext(c), lib.DLTagResponseSuccess, map[string]interface{}{"res": res})
	response.Success(c, res)
}

// OverviewAlert godoc
// @Summary      ObjectPool Monitor OverviewAlert
// @Description  资源池-对象存储-告警概览
// @Tags         ObjectPool
// @Accept       json
// @Produce      json
// @Param        body body dto.OverViewAlertReq true "object pool monitor overview alert request"
// @Success      200  {object}  dto.OverViewAlertRes
// @Router       /object_storage/object_pool/overview_alert [POST]
func (j *ObjectPoolController) OverviewAlert(c *gin.Context) {
	var params dto.OverViewAlertReq
	if err := c.ShouldBind(&params); err != nil {
		lib.Log.TagError(lib.GetTraceContext(c), lib.DLTagRequestOut, map[string]interface{}{"error": err.Error(), "params": params})
		response.Failed(c, http.StatusBadRequest, consts.ParameterError, "参数绑定失败")
		return
	}
	lib.Log.TagInfo(lib.GetTraceContext(c), lib.DLTagResponseSuccess, map[string]interface{}{"params": params})

	// 业务处理
	res, err := j.svc.OverviewAlert(c, params)
	if err != nil {
		lib.Log.TagError(lib.GetTraceContext(c), lib.DLTagResponseFailed, map[string]interface{}{"error": err.Error()})
		response.Failed(c, http.StatusInternalServerError, consts.GainFail, "获取对象存储概览告警信息失败")
		return
	}

	lib.Log.TagInfo(lib.GetTraceContext(c), lib.DLTagResponseSuccess, map[string]interface{}{"res": res})
	response.Success(c, res)
}

// List godoc
// @Summary      ObjectPool Monitor List
// @Description  资源池-对象存储-监控列表
// @Tags         ObjectPool
// @Accept       json
// @Produce      json
// @Param        body body dto.ListReq true "object pool monitor request"
// @Success      200  {object}  dto.ListRes
// @Router       /object_storage/object_pool/list [POST]
func (j *ObjectPoolController) List(c *gin.Context) {
	var params dto.ListReq
	if err := c.ShouldBind(&params); err != nil {
		lib.Log.TagError(lib.GetTraceContext(c), lib.DLTagRequestOut, map[string]interface{}{"error": err.Error(), "params": params})
		response.Failed(c, http.StatusBadRequest, consts.ParameterError, "参数绑定失败")
		return
	}
	lib.Log.TagInfo(lib.GetTraceContext(c), lib.DLTagResponseSuccess, map[string]interface{}{"params": params})

	// 业务处理
	res, err := j.svc.List(c, params)
	if err != nil {
		lib.Log.TagError(lib.GetTraceContext(c), lib.DLTagResponseFailed, map[string]interface{}{"error": err.Error()})
		response.Failed(c, http.StatusInternalServerError, consts.GainFail, "获取对象存储列表信息失败")
		return
	}

	lib.Log.TagInfo(lib.GetTraceContext(c), lib.DLTagResponseSuccess, map[string]interface{}{"res": res})
	response.Success(c, res)
}

// DetailMetricOverview godoc
// @Summary      ObjectPool Monitor DetailMetricOverview
// @Description  资源池-对象存储-监控详情-概览
// @Tags         ObjectPool
// @Accept       json
// @Produce      json
// @Param        body body dto.ObjectPoolDetailMetricReq true "object pool detail metric overview request"
// @Success      200  {object}  dto.ObjectPoolDetailMetricRes
// @Router       /object_storage/object_pool/detail_metric_overview [POST]
func (j *ObjectPoolController) DetailMetricOverview(c *gin.Context) {
	var params dto.ObjectPoolDetailMetricReq
	if err := c.ShouldBind(&params); err != nil {
		lib.Log.TagError(lib.GetTraceContext(c), lib.DLTagRequestOut, map[string]interface{}{"error": err.Error(), "params": params})
		response.Failed(c, http.StatusBadRequest, consts.ParameterError, "参数绑定失败")
		return
	}
	lib.Log.TagInfo(lib.GetTraceContext(c), lib.DLTagResponseSuccess, map[string]interface{}{"params": params})

	// 业务处理
	res, err := j.svc.DetailMetricOverview(c, params)
	if err != nil {
		lib.Log.TagError(lib.GetTraceContext(c), lib.DLTagResponseFailed, map[string]interface{}{"error": err.Error()})
		response.Failed(c, http.StatusInternalServerError, consts.GainFail, "获取对象存储详情-监控指标-详情概览信息失败")
		return
	}

	lib.Log.TagInfo(lib.GetTraceContext(c), lib.DLTagResponseSuccess, map[string]interface{}{"res": res})
	response.Success(c, res)
}

// DetailMetricLines godoc
// @Summary      ObjectPool Monitor DetailMetricLines
// @Description  资源池-对象存储-监控详情-折线图
// @Tags         ObjectPool
// @Accept       json
// @Produce      json
// @Param        body body dto.ObjectPoolDetailMetricLineReq true "object pool detail metric lines request"
// @Success      200  {object}  dto.ObjectPoolDetailMetricLineRes
// @Router       /object_storage/object_pool/detail_metric_lines [POST]
func (j *ObjectPoolController) DetailMetricLines(c *gin.Context) {
	var params dto.ObjectPoolDetailMetricLineReq
	if err := c.ShouldBind(&params); err != nil {
		lib.Log.TagError(lib.GetTraceContext(c), lib.DLTagRequestOut, map[string]interface{}{"error": err.Error(), "params": params})
		response.Failed(c, http.StatusBadRequest, consts.ParameterError, "参数绑定失败")
		return
	}
	lib.Log.TagInfo(lib.GetTraceContext(c), lib.DLTagResponseSuccess, map[string]interface{}{"params": params})

	// 业务处理
	res, err := j.svc.DetailMetricLine(c, params)
	if err != nil {
		lib.Log.TagError(lib.GetTraceContext(c), lib.DLTagResponseFailed, map[string]interface{}{"error": err.Error()})
		response.Failed(c, http.StatusInternalServerError, consts.GainFail, "获取对象存储详情-监控指标-监控线信息失败")
		return
	}

	lib.Log.TagInfo(lib.GetTraceContext(c), lib.DLTagResponseSuccess, map[string]interface{}{"res": res})
	response.Success(c, res)
}

// ListOptionalCondition 
// List godoc
// @Summary      ObjectPool Monitor List optional condition
// @Description  资源池-对象存储-监控详情-可选条件
// @Tags         ObjectPool
// @Accept       json
// @Produce      json
// @Success      200  {object}  dto.OptionalObjectPoolResult
// @Router       /object_storage/object_pool/list_optional_condition [GET]
func (j *ObjectPoolController) ListOptionalCondition(c *gin.Context) {
	// 业务处理
	res, err := j.svc.GetListOptionalCondition(c)
	if err != nil {
		lib.Log.TagError(lib.GetTraceContext(c), lib.DLTagResponseFailed, map[string]interface{}{"error": err.Error()})
		response.Failed(c, http.StatusInternalServerError, consts.GainFail, "获取可选列表信息失败")
		return
	}

	lib.Log.TagInfo(lib.GetTraceContext(c), lib.DLTagResponseSuccess, map[string]interface{}{"res": res})
	response.Success(c, res)
}

```

File path: /Users/mac/Desktop/woker_code/monitor/modules/object_storage/controller/object_volume.go
```golang
package controller

import (
	"ezone.ksyun.com/ezone/luban/communal/lib"
	"ezone.ksyun.com/ezone/luban/monitor/common/consts"
	"ezone.ksyun.com/ezone/luban/monitor/modules/object_storage/dto"
	"ezone.ksyun.com/ezone/luban/monitor/modules/object_storage/service"
	"ezone.ksyun.com/ezone/luban/monitor/response"
	"github.com/gin-gonic/gin"
	"github.com/pkg/errors"
	"net/http"
)

type ObjectVolumeController struct {
	svc service.ObjectVolumeService
}

func NewObjectVolumeController() *ObjectVolumeController {
	return &ObjectVolumeController{
		svc: service.NewObjectVolumeService(),
	}
}

// OverviewTop godoc
// @Summary      ObjectVolume Monitor OverviewTop
// @Description  云产品-对象存储-概览Top
// @Tags         ObjectVolume
// @Accept       json
// @Produce      json
// @Param        body body dto.ObjectVolumeOverviewTopReq true "object volume monitor overview top request"
// @Success      200  {object}  dto.ObjectVolumeOverviewTopRes
// @Router       /object_storage/object_volume/overview_top [POST]
func (j *ObjectVolumeController) OverviewTop(c *gin.Context) {
	var params dto.ObjectVolumeOverviewTopReq
	if err := c.ShouldBind(&params); err != nil {
		lib.Log.TagError(lib.GetTraceContext(c), lib.DLTagRequestOut, map[string]interface{}{"error": err.Error(), "params": params})
		response.Failed(c, http.StatusBadRequest, consts.ParameterError, "参数绑定失败")
		return
	}
	lib.Log.TagInfo(lib.GetTraceContext(c), lib.DLTagResponseSuccess, map[string]interface{}{"params": params})
	if params.MetricName == nil {
		lib.Log.TagError(lib.GetTraceContext(c), lib.DLTagRequestOut, map[string]interface{}{"error": errors.New("metric name nil"), "params": params})
		response.Failed(c, http.StatusBadRequest, consts.ParameterError, "指标名称不能为空")
		return
	}

	// 业务处理
	res, err := j.svc.OverviewTop(c, params)
	if err != nil {
		lib.Log.TagError(lib.GetTraceContext(c), lib.DLTagResponseFailed, map[string]interface{}{"error": err.Error()})
		response.Failed(c, http.StatusInternalServerError, consts.GainFail, "获取云产品-对象存储概览TopK信息失败")
		return
	}

	lib.Log.TagInfo(lib.GetTraceContext(c), lib.DLTagResponseSuccess, map[string]interface{}{"res": res})
	response.Success(c, res)
}

// Overview godoc
// @Summary      ObjectVolume Monitor Overview
// @Description  云产品-对象存储-概览
// @Tags         ObjectVolume
// @Accept       json
// @Produce      json
// @Param        body body dto.ObjectVolumeOverviewReq true "object volume monitor overview request"
// @Success      200  {object}  dto.ObjectVolumeOverviewRes
// @Router       /object_storage/object_volume/overview [POST]
func (j *ObjectVolumeController) Overview(c *gin.Context) {
	var params dto.ObjectVolumeOverviewReq
	if err := c.ShouldBind(&params); err != nil {
		lib.Log.TagError(lib.GetTraceContext(c), lib.DLTagRequestOut, map[string]interface{}{"error": err.Error(), "params": params})
		response.Failed(c, http.StatusBadRequest, consts.ParameterError, "参数绑定失败")
		return
	}
	lib.Log.TagInfo(lib.GetTraceContext(c), lib.DLTagResponseSuccess, map[string]interface{}{"params": params})
	if params.MetricName == nil {
		lib.Log.TagError(lib.GetTraceContext(c), lib.DLTagRequestOut, map[string]interface{}{"error": errors.New("metric name nil"), "params": params})
		response.Failed(c, http.StatusBadRequest, consts.ParameterError, "指标名称不能为空")
		return
	}

	// 业务处理
	res, err := j.svc.Overview(c, params)
	if err != nil {
		lib.Log.TagError(lib.GetTraceContext(c), lib.DLTagResponseFailed, map[string]interface{}{"error": err.Error()})
		response.Failed(c, http.StatusInternalServerError, consts.GainFail, "获取云产品-对象存储概览信息失败")
		return
	}

	lib.Log.TagInfo(lib.GetTraceContext(c), lib.DLTagResponseSuccess, map[string]interface{}{"res": res})
	response.Success(c, res)
}

// DetailMetric godoc
// @Summary      ObjectVolume Monitor DetailMetric
// @Description  云产品-对象存储-监控详情
// @Tags         ObjectVolume
// @Accept       json
// @Produce      json
// @Param        body body dto.ObjectVolumeDetailMetricReq true "object volume monitor detail metric request"
// @Success      200  {object}  dto.ObjectVolumeDetailMetricRes
// @Router       /object_storage/object_volume/detail_metric [POST]
func (j *ObjectVolumeController) DetailMetric(c *gin.Context) {
	var params dto.ObjectVolumeDetailMetricReq
	if err := c.ShouldBind(&params); err != nil {
		lib.Log.TagError(lib.GetTraceContext(c), lib.DLTagRequestOut, map[string]interface{}{"error": err.Error(), "params": params})
		response.Failed(c, http.StatusBadRequest, consts.ParameterError, "参数绑定失败")
		return
	}
	lib.Log.TagInfo(lib.GetTraceContext(c), lib.DLTagResponseSuccess, map[string]interface{}{"params": params})

	// 业务处理
	res, err := j.svc.DetailMetric(c, params)
	if err != nil {
		lib.Log.TagError(lib.GetTraceContext(c), lib.DLTagResponseFailed, map[string]interface{}{"error": err.Error()})
		response.Failed(c, http.StatusInternalServerError, consts.GainFail, "获取云产品-对象存储详情指标信息失败")
		return
	}

	lib.Log.TagInfo(lib.GetTraceContext(c), lib.DLTagResponseSuccess, map[string]interface{}{"res": res})
	response.Success(c, res)
}

// DetailMetricLines godoc
// @Summary      ObjectVolume Monitor DetailMetricLines
// @Description  云产品-对象存储-监控详情折线图
// @Tags         ObjectVolume
// @Accept       json
// @Produce      json
// @Param        body body dto.ObjectVolumeDetailMetricLineReq true "object volume monitor detail metric lines request"
// @Success      200  {object}  dto.ObjectVolumeDetailMetricLineRes
// @Router       /object_storage/object_volume/detail_metric_lines [POST]
func (j *ObjectVolumeController) DetailMetricLines(c *gin.Context) {
	var params dto.ObjectVolumeDetailMetricLineReq
	if err := c.ShouldBind(&params); err != nil {
		lib.Log.TagError(lib.GetTraceContext(c), lib.DLTagRequestOut, map[string]interface{}{"error": err.Error(), "params": params})
		response.Failed(c, http.StatusBadRequest, consts.ParameterError, "参数绑定失败")
		return
	}
	lib.Log.TagInfo(lib.GetTraceContext(c), lib.DLTagResponseSuccess, map[string]interface{}{"params": params})
	if len(params.MetricName) == 0 {
		lib.Log.TagError(lib.GetTraceContext(c), lib.DLTagRequestOut, map[string]interface{}{"error": errors.New("metric name nil"), "params": params})
		response.Failed(c, http.StatusBadRequest, consts.ParameterError, "指标名称不能为空")
		return
	}

	// 业务处理
	res, err := j.svc.DetailMetricLine(c, params)
	if err != nil {
		lib.Log.TagError(lib.GetTraceContext(c), lib.DLTagResponseFailed, map[string]interface{}{"error": err.Error()})
		response.Failed(c, http.StatusInternalServerError, consts.GainFail, "获取云产品-对象存储详情指标线信息失败")
		return
	}

	lib.Log.TagInfo(lib.GetTraceContext(c), lib.DLTagResponseSuccess, map[string]interface{}{"res": res})
	response.Success(c, res)
}

```

File path: /Users/mac/Desktop/woker_code/monitor/modules/object_storage/constant/constant.go
```golang
package constant

import "ezone.ksyun.com/ezone/luban/monitor/common/types"

var (
	// AlertLevels 告警级别
	AlertLevels = []string{"p0", "p1", "p2", "p3"}
	// AlertLevelsName 告警级别映射
	AlertLevelsName = map[string]string{
		"p0": "紧急告警",
		"p1": "重要告警",
		"p2": "次要告警",
		"p3": "提醒告警",
	}
	// AlertKinds 告警类型
	AlertKinds = map[string]string{
		"p0": types.KindError,
		"p1": types.KindWarn,
		"p2": types.KindMinor,
		"p3": types.KindInfo,
	}
	// ObjectPoolMap 对象存储池类型
	ObjectPoolMap = map[string]string{
		"ks3": "1",
	}

	ObjectVolumeStatusMap = map[string]string{
		"creating":        "创建中",
		"available":       "待挂载",
		"attaching":       "挂载中",
		"in-use":          "使用中",
		"detaching":       "卸载中",
		"extending":       "扩容中",
		"deleting":        "删除中",
		"error":           "错误",
		"error_attaching": "挂载失败",
		"error_detaching": "卸载失败",
		"error_deleting":  "删除失败",
		"error_extending": "扩容失败",
		"deleted":         "已删除",
		"recycling":       "回收中",
		"rollbacking":     "回滚中",
	}
)

const (
	Platform = "platform"
	Business = "business"

	SourcePlatform = "平台"
	SourceBusiness = "业务"
)

```

File path: /Users/mac/Desktop/woker_code/monitor/modules/object_storage/model/monitor_tsdb_metrics.go
```golang
package model

import "time"

type MonitorTsdbMetrics struct {
	ID           int       `gorm:"column:id;primary_key;AUTO_INCREMENT"`
	ProductLine  string    `gorm:"column:product_line;NOT NULL"`  // 产品线
	Code         string    `gorm:"column:code;NOT NULL"`          // 唯一标识
	Name         string    `gorm:"column:name;NOT NULL"`          // 中文名
	MetricPrefix string    `gorm:"column:metric_prefix;NOT NULL"` // metric前缀
	Unit         string    `gorm:"column:unit;NOT NULL;default:''"`
	CreatedAt    time.Time `gorm:"column:created_at;default:CURRENT_TIMESTAMP"`
	UpdatedAt    time.Time `gorm:"column:updated_at;default:CURRENT_TIMESTAMP"`
	DeletedAt    time.Time `gorm:"column:deleted_at"`
}

func (m *MonitorTsdbMetrics) TableName() string {
	return "monitor_tsdb_metrics"
}

```

File path: /Users/mac/Desktop/woker_code/monitor/modules/object_storage/model/object_pool.go
```golang
package model

```

File path: /Users/mac/Desktop/woker_code/monitor/modules/object_storage/model/monitor_top.go
```golang
package model

import (
	"time"

	"ezone.ksyun.com/ezone/luban/monitor/common/client/opentsdb"
)

// region + az + code 唯一
type MonitorTop struct {
	ID                 int        `gorm:"column:id;primary_key;AUTO_INCREMENT"`        // 主键
	ProductLine        string     `gorm:"column:product_line;NOT NULL"`                // 产品线
	Region             string     `gorm:"column:region;NOT NULL"`                      // 区域
	Az                 string     `gorm:"column:az;NOT NULL"`                          // 可用区
	Code               string     `gorm:"column:code;NOT NULL"`                        // top项的唯一标识
	Name               string     `gorm:"column:name;NOT NULL"`                        // 中文名
	HalfHour           []TopValue `gorm:"column:half_hour;serializer:json_str"`        // 0.5h top10数据
	HalfHourUpdateAt   time.Time  `gorm:"column:half_hour_update_at"`                  // 0.5h更新时间
	OneHour            []TopValue `gorm:"column:one_hour;serializer:json_str"`         // 1h top10数据
	OneHourUpdateAt    time.Time  `gorm:"column:one_hour_update_at"`                   // 1h更新时间
	ThreeHours         []TopValue `gorm:"column:three_hours;serializer:json_str"`      // 3h top10数据
	ThreeHoursUpdateAt time.Time  `gorm:"column:three_hours_update_at"`                // 3h更新时间
	OneDay             []TopValue `gorm:"column:one_day;serializer:json_str"`          // 1d top10数据
	OneDayUpdateAt     time.Time  `gorm:"column:one_day_update_at"`                    // 1d更新时间
	SevenDays          []TopValue `gorm:"column:seven_days;serializer:json_str"`       // 7d top10数据
	SevenDaysUpdateAt  time.Time  `gorm:"column:seven_days_update_at"`                 // 7d更新时间
	ThirtyDays         []TopValue `gorm:"column:thirty_days;serializer:json_str"`      // 30d top10数据
	ThirtyDaysUpdateAt time.Time  `gorm:"column:thirty_days_update_at"`                // 30d更新时间
	CreatedAt          time.Time  `gorm:"column:created_at;default:CURRENT_TIMESTAMP"` // 创建时间
	UpdatedAt          time.Time  `gorm:"column:updated_at;default:CURRENT_TIMESTAMP"` // 更新时间
	DeletedAt          time.Time  `gorm:"column:deleted_at"`                           // 删除时间
}

type TopValue struct {
	Id    string  //实例唯一id
	Name  string  //名称
	Value float64 //值
}

func (m *MonitorTop) TableName() string {
	return "monitor_top"
}

func (m *MonitorTop) ParseIntervalData(start, end int64) []TopValue {
	var intervalData []TopValue
	intervalStr := opentsdb.ParseTimeInterval(start, end)
	switch intervalStr {
	case "0.5h":
		intervalData = m.HalfHour
	case "1h":
		intervalData = m.OneHour
	case "3h":
		intervalData = m.ThreeHours
	case "1d":
		intervalData = m.OneDay
	case "7d":
		intervalData = m.SevenDays
	case "30d":
		intervalData = m.ThirtyDays
	}
	return intervalData
}

```

File path: /Users/mac/Desktop/woker_code/monitor/modules/object_storage/model/object_volume.go
```golang
package model

```

File path: /Users/mac/Desktop/woker_code/monitor/modules/object_storage/service/object_pool.go
```golang
package service

import (
	"context"
	"fmt"
	"strconv"
	"strings"
	"time"

	"ezone.ksyun.com/ezone/luban/communal/lib"
	alarmv1alpha "ezone.ksyun.com/ezone/luban/luban_api/alarmapis/alarm/v1alpha/gen"
	resource_objectstoragev1alpha "ezone.ksyun.com/ezone/luban/luban_api/resourceapis/resource_objectstorage/v1alpha/gen"
	prom_client "ezone.ksyun.com/ezone/luban/monitor/common/client/prom"
	"ezone.ksyun.com/ezone/luban/monitor/common/promql_template/objectstorage"
	"ezone.ksyun.com/ezone/luban/monitor/common/tools/collection"
	"ezone.ksyun.com/ezone/luban/monitor/common/types"
	"ezone.ksyun.com/ezone/luban/monitor/common/utils"
	blockstorage_utils "ezone.ksyun.com/ezone/luban/monitor/modules/blockstorage/utils"
	"ezone.ksyun.com/ezone/luban/monitor/modules/object_storage/constant"
	"ezone.ksyun.com/ezone/luban/monitor/modules/object_storage/dao"
	"ezone.ksyun.com/ezone/luban/monitor/modules/object_storage/dto"
	"github.com/gin-gonic/gin"
	"github.com/pkg/errors"
	v1 "github.com/prometheus/client_golang/api/prometheus/v1"
)

type ObjectPoolService interface {
	OverviewAlert(ctx context.Context, par dto.OverViewAlertReq) (*dto.OverViewAlertRes, error)
	Overview(ctx context.Context, par dto.OverviewReq) (*dto.OverViewRes, error)
	OverviewLine(ctx context.Context, par dto.OverviewLineReq) (*dto.OverViewLineRes, error)
	List(ctx context.Context, par dto.ListReq) (res *dto.ListRes, err error)
	DetailMetricOverview(ctx context.Context, par dto.ObjectPoolDetailMetricReq) (*dto.ObjectPoolDetailMetricRes, error)
	DetailMetricLine(ctx context.Context, par dto.ObjectPoolDetailMetricLineReq) (*dto.ObjectPoolDetailMetricLineRes, error)
	GetListOptionalCondition(ctx *gin.Context) (*dto.OptionalObjectPoolResult, error)
}

type objectPoolService struct {
	daoFactory dao.Factory
}

func NewObjectPoolService() ObjectPoolService {
	return &objectPoolService{
		daoFactory: dao.NewObjectStorageStore(),
	}
}

func (s *objectPoolService) OverviewAlert(ctx context.Context, par dto.OverViewAlertReq) (*dto.OverViewAlertRes, error) {
	alerts, err := s.daoFactory.AlarmRpcClient().ListAlerts(ctx, &alarmv1alpha.ListAlertsRequest{
		PageNo:   -1,
		PageSize: -1,
		Region:   par.Region,
		Status:   "firing",
	})
	if err != nil {
		return nil, errors.WithMessage(err, "rpc call AlarmRpcClient.ListAlerts err")
	}

	// 概览数据
	var alertSlots []types.BasicOverviewSlot
	for _, level := range constant.AlertLevels {
		alertSlot := types.BasicOverviewSlot{
			Info: types.BasicOverviewSlotInfo{
				Code:     par.PoolType,
				Name:     constant.AlertLevelsName[level],
				UnitType: types.TypeNumber,
				Unit:     "个",
				Value:    utils.CountAlertsNum(alerts.Items, strings.ToLower(par.PoolType), level),
				Kind:     constant.AlertKinds[level],
			},
		}
		alertSlots = append(alertSlots, alertSlot)
	}
	return &dto.OverViewAlertRes{
		Alerts: alertSlots,
	}, nil
}

func (s *objectPoolService) Overview(ctx context.Context, par dto.OverviewReq) (res *dto.OverViewRes, err error) {
	// 资源池容量
	var (
		statusCount        = map[string]int64{}
		useStatus          = map[string]string{"available": "待挂载", "in-use": "使用中"} // 没有
		objectPools        = make([]types.BasicOverviewSlot, 0)
		objectVolumeCounts = make([]types.BasicOverviewSlot, 0)
	)
	objectPoolStock, err := s.daoFactory.ObjectPoolRpcClient().ObjectPoolStock(ctx, &resource_objectstoragev1alpha.ObjectPoolStockReq{PoolId: constant.ObjectPoolMap[par.PoolType]})
	if err != nil {
		lib.Log.TagError(lib.GetTraceContext(ctx), lib.DLTagUndefind, map[string]interface{}{"rpc error": err})
		return nil, err
	}

	// 组装业务数据
	storageUse := types.BasicOverviewSlot{
		Info: types.BasicOverviewSlotInfo{
			Index: 0,
			Name:  "存储使用概览",
		},
		Values: make([]types.BasicOverviewSlotValue, 0),
	}
	storageUse.Values = append(storageUse.Values,
		types.BasicOverviewSlotValue{
			Name:     "已使用",
			Value:    objectPoolStock.TotalDiskCapacity - objectPoolStock.TotalFreeSpace,
			Unit:     "GB",
			UnitType: "storage",
		},
		types.BasicOverviewSlotValue{
			Name:     "可使用",
			Value:    objectPoolStock.TotalFreeSpace,
			Unit:     "GB",
			UnitType: "storage",
		},
	)

	// 对象存储数量
	for _, status := range useStatus {
		objectVolumeResult, err := s.daoFactory.ObjectVolumeRpcClient().ListObjectVolume(ctx, &resource_objectstoragev1alpha.ObjectVolumeReq{
			PageSize: -1,
			Region:   par.Region,
		})
		if err != nil {
			lib.Log.TagError(lib.GetTraceContext(ctx), lib.DLTagUndefind, map[string]interface{}{"rpc error": err})
			return nil, err
		}
		statusCount[status] = objectVolumeResult.TotalCount
	}
	objectVolumeCount := types.BasicOverviewSlot{
		Info: types.BasicOverviewSlotInfo{
			Index: 1,
			Name:  "对象存储概览",
		},
		Values: make([]types.BasicOverviewSlotValue, 0),
	}
	for status, count := range statusCount {
		objectVolumeCount.Values = append(objectVolumeCount.Values, types.BasicOverviewSlotValue{
			Name:     status,
			Value:    count,
			Unit:     "个",
			UnitType: "number",
		})
	}
	objectPools = append(objectPools, storageUse)
	objectVolumeCounts = append(objectVolumeCounts, objectVolumeCount)
	return &dto.OverViewRes{
		ObjectPools:        objectPools,
		ObjectVolumeCounts: objectVolumeCounts,
	}, nil
}

func (s *objectPoolService) OverviewLine(ctx context.Context, par dto.OverviewLineReq) (res *dto.OverViewLineRes, err error) {
	objectPoolRpcRes, err := s.daoFactory.ObjectPoolRpcClient().ListObjectPool(ctx, &resource_objectstoragev1alpha.ObjectPoolReq{
		Region:   par.Region,
		PoolType: []string{par.PoolType},
	})
	if err != nil {
		lib.Log.TagError(lib.GetTraceContext(ctx), lib.DLTagHTTPFailed, map[string]interface{}{"error": err.Error()})
		return nil, err
	}
	lines := make([]types.BasicOverviewSlot, 0)
	for _, name := range par.MetricName {
		qlName := objectstorage.TemplateMap[name](objectPoolRpcRes.List[0].Region, "", objectPoolRpcRes.List[0].Name, objectPoolRpcRes.List[0].Name, objectPoolRpcRes.List[0].Name)
		qlMuster, err := s.daoFactory.AlarmRpcClient().ListPromQLs(ctx, qlName)
		if err != nil {
			lib.Log.TagError(lib.GetTraceContext(ctx), lib.DLTagResponseFailed, map[string]interface{}{"Overview pool get qlMuster info error": err.Error()})
			return nil, err
		}
		if len(qlMuster.Items) == 0 {
			return nil, errors.New("pool qlMuster.Items is empty")
		}
		lib.Log.TagInfo(lib.GetTraceContext(ctx), lib.DLTagResponseSuccess, map[string]interface{}{"pool pSql": qlMuster.Items[0].RealPromql})
		qlResult, err := prom_client.MatrixQuery(ctx, qlMuster.Items[0].RealPromql, v1.Range{
			Start: time.UnixMilli(par.Start),
			End:   time.UnixMilli(par.End),
			Step:  prom_client.TimeToStep(par.End - par.Start),
		})
		if err != nil {
			lib.Log.TagError(lib.GetTraceContext(ctx), lib.DLTagResponseFailed, map[string]interface{}{"Overview pool get qlResult info error": err.Error()})
			return nil, err
		}
		if len(qlResult) == 0 {
			return nil, errors.New("pool qlResult.Items is empty")
		}
		var line types.BasicOverviewSlot
		for _, v := range qlResult {
			for _, value := range v.Values {
				line.Values = append(line.Values, types.BasicOverviewSlotValue{
					Name:        strconv.FormatInt(int64(value.Timestamp), 10),
					UnitType:    types.ParseUnitTypeByUnit(qlMuster.Items[0].Unit),
					Value:       value.Value,
					Unit:        qlMuster.Items[0].Unit,
					Kind:        types.KindInfo,
					Description: time.UnixMilli(int64(value.Timestamp)).Format("2006-01-02 15:04:05"),
				})
				fmt.Println(value.Value)
			}
		}

		line.Info = types.BasicOverviewSlotInfo{
			Name:     objectstorage.MetricMap[name],
			UnitType: types.ParseUnitTypeByUnit(qlMuster.Items[0].Unit),
			Unit:     qlMuster.Items[0].Unit,
			Kind:     types.KindInfo,
		}

		// 添加预测分析
		var predictSql string
		start, end := par.Start/1e3, par.End/1e3
		step := blockstorage_utils.TimeToStepForInt(end - start)
		predictStart, predictEnd := end, end+(end-start)

		if par.HasPrediction && objectstorage.ObjectPoolCapacityInventory == name {
			line.Info.Prognosis = len(line.Values)
			rangeDuration := strconv.FormatInt(3*(end-start), 10)
			predictDuration := strconv.FormatInt(end-start, 10)
			switch name {
			case objectstorage.ObjectPoolCapacityInventory:
				predictSql = objectstorage.GetPredictObjectCapacity(objectPoolRpcRes.List[0].Name, rangeDuration+"s", predictDuration)
			}
			predictMatrix, err := prom_client.MatrixQuery(ctx, predictSql, v1.Range{
				Start: time.Unix(predictStart, 0),
				End:   time.Unix(predictEnd, 0),
				Step:  time.Duration(step) * time.Second,
			})
			if err != nil {
				lib.Log.TagError(lib.GetTraceContext(ctx), lib.DLTagResponseFailed, map[string]interface{}{"Error querying Prometheus predictMatrix ": err.Error()})
				return nil, err
			}
			for _, m := range predictMatrix {
				for _, p := range m.Values {
					timeStamp := p.Timestamp
					value := p.Value
					line.Values = append(line.Values, types.BasicOverviewSlotValue{
						Name:        timeStamp.String(),
						Value:       value,
						Unit:        qlMuster.Items[0].Unit,
						UnitType:    types.ParseUnitTypeByUnit(qlMuster.Items[0].Unit),
						Kind:        types.KindInfo,
						Description: "预测数据",
					})
				}
				break
			}
		}
		lines = append(lines, line)
	}

	return &dto.OverViewLineRes{
		Lines: lines,
	}, nil
}

func (s *objectPoolService) List(ctx context.Context, par dto.ListReq) (res *dto.ListRes, err error) {

	objectPoolList, err := s.daoFactory.ObjectPoolRpcClient().ListObjectPool(ctx, &resource_objectstoragev1alpha.ObjectPoolReq{
		PageNo:    int32(par.PageNo),
		PageSize:  int32(par.PageSize),
		Region:    par.Region,
		OrderCode: par.OrderCode,
		OrderType: par.OrderType,
		PoolType:  par.PoolType,
		Query:     par.Query,
	})
	if err != nil {
		lib.Log.TagError(lib.GetTraceContext(ctx), lib.DLTagUndefind, map[string]interface{}{"rpc error": err})
		return nil, err
	}
	res = &dto.ListRes{
		TotalCount: len(objectPoolList.List),
		PageNo:     par.PageNo,
		PageSize:   par.PageSize,
		DataList:   make([]*dto.ObjectStorageMonitor, 0),
	}
	for _, data := range objectPoolList.List {
		result := &dto.ObjectStorageMonitor{
			Id:                 data.Id,
			Name:               data.Name,
			DiskType:           data.PoolType,
			MonitorStatus:      1,
			Region:             data.Region,
			CapacityTotal:      float64(data.TotalDiskCapacity),
			CapacityUsedTotal:  float64(data.TotalUsedSpace),
			CapacityAvailable:  float64(data.TotalFreeSpace),
			CapacityUsedRate:   (float64(data.TotalUsedSpace) / float64(data.TotalDiskCapacity)) * 100,
			BucketNumber:       int64(data.BucketCount),
			HostNumber:         int64(data.ServerCount),
			CreateTime:         data.CreateTime,
			AlertAmount:        0, // TODO
			UploadBandwidth:    0, // TODO
			DownloadBandwidth:  0, // TODO
			HttpRequestAmount:  0, // TODO
			HttpsRequestAmount: 0, // TODO
		}
		res.DataList = append(res.DataList, result)
	}

	return res, nil
}

func (s *objectPoolService) ObjectPoolVector(ctx context.Context, metricName, region, bucketID, resourcePool, resourcePoolType, name string) (float64, error) {
	promQlReq := objectstorage.TemplateMap[metricName](region, bucketID, resourcePool, resourcePoolType, name)
	rsp, err := s.daoFactory.AlarmRpcClient().ListPromQLs(ctx, promQlReq)
	if err != nil {
		return 0, errors.WithMessagef(err, "rpc call ListPromQLs err, req: %+v", promQlReq)
	}
	if rsp == nil || len(rsp.Items) < 1 {
		return 0, err
	}
	promQL := rsp.Items[0].RealPromql
	fmt.Println("real promQL: ", promQL)

	//查Prometheus
	matrix, err := prom_client.VectorQuery(ctx, promQL)
	if err != nil {
		return 0, errors.WithMessage(err, "prom_client VectorQuery err")
	}
	return prom_client.ParseOneVectorValue(matrix), nil
}

func (s *objectPoolService) GetListOptionalCondition(ctx *gin.Context) (*dto.OptionalObjectPoolResult, error) {
	var (
		poolTypeSet = collection.NewSet()
	)
	objectPoolList, err := s.daoFactory.ObjectPoolRpcClient().ListObjectPool(ctx, &resource_objectstoragev1alpha.ObjectPoolReq{PageNo: 1, PageSize: 1000})
	if err != nil {
		lib.Log.TagError(lib.GetTraceContext(ctx), lib.DLTagUndefind, map[string]interface{}{"rpc error": err})
		return nil, err
	}
	for _, objectPool := range objectPoolList.List {
		if objectPool.PoolType != "" {
			poolTypeSet.Add(objectPool.PoolType)
		}
	}
	result := dto.OptionalObjectPoolResult{
		"PoolTypeSet": poolTypeSet,
	}
	return &result, nil
}

func (s *objectPoolService) DetailMetricOverview(ctx context.Context, par dto.ObjectPoolDetailMetricReq) (*dto.ObjectPoolDetailMetricRes, error) {
	objectPool, err := s.daoFactory.ObjectPoolRpcClient().ObjectPoolStock(ctx, &resource_objectstoragev1alpha.ObjectPoolStockReq{
		PoolId: strconv.FormatInt(par.PoolId, 10),
	})
	if err != nil {
		lib.Log.TagError(lib.GetTraceContext(ctx), lib.DLTagUndefind, map[string]interface{}{"rpc error": err})
		return nil, err
	}

	lines := make([]types.BasicOverviewSlot, 0)
	for _, name := range par.MetricName {
		qlName := objectstorage.TemplateMap[name](objectPool.Region, "", objectPool.Name, objectPool.Name, objectPool.Name)
		qlMuster, err := s.daoFactory.AlarmRpcClient().ListPromQLs(ctx, qlName)
		if err != nil {
			lib.Log.TagError(lib.GetTraceContext(ctx), lib.DLTagResponseFailed, map[string]interface{}{"DetailMetricOverview pool get qlMuster info error": err.Error()})
			return nil, err
		}
		if len(qlMuster.Items) == 0 {
			return nil, errors.New("pool qlMuster.Items is empty")
		}
		lib.Log.TagInfo(lib.GetTraceContext(ctx), lib.DLTagResponseSuccess, map[string]interface{}{"pool pSql": qlMuster.Items[0].RealPromql})
		qlResult, err := prom_client.VectorQuery(ctx, qlMuster.Items[0].RealPromql)
		if err != nil {
			lib.Log.TagError(lib.GetTraceContext(ctx), lib.DLTagResponseFailed, map[string]interface{}{"DetailMetricOverview pool get qlResult info error": err.Error()})
			return nil, err
		}
		if len(qlResult) == 0 {
			return nil, errors.New("pool qlResult.Items is empty")
		}
		var line types.BasicOverviewSlot
		for _, v := range qlResult {
			line.Info = types.BasicOverviewSlotInfo{
				Name:     objectstorage.MetricMap[name],
				UnitType: types.ParseUnitTypeByUnit(qlMuster.Items[0].Unit),
				Unit:     qlMuster.Items[0].Unit,
				Kind:     types.KindInfo,
				Value:    v.Value,
			}
		}
		lines = append(lines, line)
	}
	return &dto.ObjectPoolDetailMetricRes{
		Lines: lines,
	}, nil
}

func (s *objectPoolService) DetailMetricLine(ctx context.Context, par dto.ObjectPoolDetailMetricLineReq) (*dto.ObjectPoolDetailMetricLineRes, error) {
	objectPoolRpcRes, err := s.daoFactory.ObjectPoolRpcClient().ListObjectPool(ctx, &resource_objectstoragev1alpha.ObjectPoolReq{
		Region:   par.Region,
		PoolType: []string{par.PoolType},
	})
	if err != nil {
		lib.Log.TagError(lib.GetTraceContext(ctx), lib.DLTagHTTPFailed, map[string]interface{}{"error": err.Error()})
		return nil, err
	}
	lines := make([]types.BasicOverviewSlot, 0)
	for _, name := range par.MetricName {
		qlName := objectstorage.TemplateMap[name](objectPoolRpcRes.List[0].Region, "", objectPoolRpcRes.List[0].Name, objectPoolRpcRes.List[0].Name, objectPoolRpcRes.List[0].Name)
		qlMuster, err := s.daoFactory.AlarmRpcClient().ListPromQLs(ctx, qlName)
		if err != nil {
			lib.Log.TagError(lib.GetTraceContext(ctx), lib.DLTagResponseFailed, map[string]interface{}{"Overview pool get qlMuster info error": err.Error()})
			return nil, err
		}
		if len(qlMuster.Items) == 0 {
			return nil, errors.New("pool qlMuster.Items is empty")
		}
		lib.Log.TagInfo(lib.GetTraceContext(ctx), lib.DLTagResponseSuccess, map[string]interface{}{"pool pSql": qlMuster.Items[0].RealPromql})
		qlResult, err := prom_client.MatrixQuery(ctx, qlMuster.Items[0].RealPromql, v1.Range{
			Start: time.UnixMilli(par.Start),
			End:   time.UnixMilli(par.End),
			Step:  prom_client.TimeToStep(par.End - par.Start),
		})
		if err != nil {
			lib.Log.TagError(lib.GetTraceContext(ctx), lib.DLTagResponseFailed, map[string]interface{}{"Overview pool get qlResult info error": err.Error()})
			return nil, err
		}
		if len(qlResult) == 0 {
			return nil, errors.New("pool qlResult.Items is empty")
		}
		var line types.BasicOverviewSlot
		for _, v := range qlResult {
			for _, value := range v.Values {
				line.Values = append(line.Values, types.BasicOverviewSlotValue{
					Name:        strconv.FormatInt(int64(value.Timestamp), 10),
					UnitType:    types.ParseUnitTypeByUnit(qlMuster.Items[0].Unit),
					Value:       value.Value,
					Unit:        qlMuster.Items[0].Unit,
					Kind:        types.KindInfo,
					Description: time.UnixMilli(int64(value.Timestamp)).Format("2006-01-02 15:04:05"),
				})
				fmt.Println(value.Value)
			}
		}

		line.Info = types.BasicOverviewSlotInfo{
			Name:     objectstorage.MetricMap[name],
			UnitType: types.ParseUnitTypeByUnit(qlMuster.Items[0].Unit),
			Unit:     qlMuster.Items[0].Unit,
			Kind:     types.KindInfo,
		}
		lines = append(lines, line)
	}
	return &dto.ObjectPoolDetailMetricLineRes{
		Lines: lines,
	}, nil
}

```

File path: /Users/mac/Desktop/woker_code/monitor/modules/object_storage/service/object_volume.go
```golang
package service

import (
	"errors"
	"ezone.ksyun.com/ezone/luban/communal/lib"
	resource_objectstoragev1alpha "ezone.ksyun.com/ezone/luban/luban_api/resourceapis/resource_objectstorage/v1alpha/gen"
	prom_client "ezone.ksyun.com/ezone/luban/monitor/common/client/prom"
	"ezone.ksyun.com/ezone/luban/monitor/common/promql_template/objectstorage"
	"ezone.ksyun.com/ezone/luban/monitor/common/types"
	"ezone.ksyun.com/ezone/luban/monitor/modules/object_storage/constant"
	"ezone.ksyun.com/ezone/luban/monitor/modules/object_storage/dao"
	"ezone.ksyun.com/ezone/luban/monitor/modules/object_storage/dto"
	"github.com/gin-gonic/gin"
	v1 "github.com/prometheus/client_golang/api/prometheus/v1"
	"strconv"
	"strings"
	"time"
)

type ObjectVolumeService interface {
	OverviewTop(c *gin.Context, req dto.ObjectVolumeOverviewTopReq) (*dto.ObjectVolumeOverviewTopRes, error)
	Overview(c *gin.Context, req dto.ObjectVolumeOverviewReq) (*dto.ObjectVolumeOverviewRes, error)
	DetailMetric(c *gin.Context, req dto.ObjectVolumeDetailMetricReq) (*dto.ObjectVolumeDetailMetricRes, error)
	DetailMetricLine(c *gin.Context, req dto.ObjectVolumeDetailMetricLineReq) (*dto.ObjectVolumeDetailMetricLineRes, error)
}

type objectVolumeService struct {
	daoFactory dao.Factory
}

func NewObjectVolumeService() ObjectVolumeService {
	return &objectVolumeService{
		daoFactory: dao.NewObjectStorageStore(),
	}
}

func (s *objectVolumeService) OverviewTop(ctx *gin.Context, par dto.ObjectVolumeOverviewTopReq) (*dto.ObjectVolumeOverviewTopRes, error) {
	var tops []types.BasicOverviewSlot
	objectBaseInfo, err := s.daoFactory.ObjectVolumeRpcClient().ListObjectVolume(ctx, &resource_objectstoragev1alpha.ObjectVolumeReq{
		PageSize:     -1,
		Region:       par.Region,
		Storageclass: par.DiskType,
	})
	if err != nil {
		lib.Log.TagError(lib.GetTraceContext(ctx), lib.DLTagResponseFailed, map[string]interface{}{"OverviewTop get objectBaseInfo error": err.Error()})
		return nil, err
	}
	if objectBaseInfo.List == nil {
		lib.Log.TagInfo(lib.GetTraceContext(ctx), lib.DLTagResponseFailed, map[string]interface{}{"OverviewTop get objectBaseInfo nil": "data is empty"})
		return &dto.ObjectVolumeOverviewTopRes{
			Tops: tops,
		}, nil
	}
	// 遍历metric
	for _, name := range par.MetricName {
		qlName := objectstorage.TemplateMap[name](objectBaseInfo.List[0].Region, "", objectBaseInfo.List[0].PoolName, objectBaseInfo.List[0].PoolName, objectBaseInfo.List[0].Name)
		qlMuster, err := s.daoFactory.AlarmRpcClient().ListPromQLs(ctx, qlName)
		if err != nil {
			lib.Log.TagError(lib.GetTraceContext(ctx), lib.DLTagResponseFailed, map[string]interface{}{"Overview get qlMuster info error": err.Error()})
			return nil, err
		}
		if len(qlMuster.Items) == 0 {
			return nil, errors.New("qlMuster.Items is empty")
		}
		pSql := "topk(" + strconv.Itoa(par.TopK) + ",avg_over_time(" + qlMuster.Items[0].RealPromql + "[" + strconv.FormatInt((par.End-par.Start)/1000/60, 10) + "m]))"
		lib.Log.TagInfo(lib.GetTraceContext(ctx), lib.DLTagResponseSuccess, map[string]interface{}{"pSql": pSql})
		qlResult, err := prom_client.VectorQuery(ctx, pSql)
		if err != nil {
			lib.Log.TagError(lib.GetTraceContext(ctx), lib.DLTagResponseFailed, map[string]interface{}{"Overview get qlResult info error": err.Error()})
			return nil, err
		}

		var line types.BasicOverviewSlot
		for _, v := range qlResult {
			line.Values = append(line.Values, types.BasicOverviewSlotValue{
				Name:     string(v.Metric["name"]),
				UnitType: types.ParseUnitTypeByUnit(qlMuster.Items[0].Unit),
				Value:    v.Value,
				Unit:     qlMuster.Items[0].Unit,
				Kind:     types.KindInfo,
			})
		}

		line.Info = types.BasicOverviewSlotInfo{
			Name:     objectstorage.MetricMap[name],
			UnitType: types.ParseUnitTypeByUnit(qlMuster.Items[0].Unit),
			Unit:     qlMuster.Items[0].Unit,
			Kind:     types.KindInfo,
		}
		tops = append(tops, line)
	}

	return &dto.ObjectVolumeOverviewTopRes{
		Tops: tops,
	}, nil
}

func (s *objectVolumeService) Overview(ctx *gin.Context, par dto.ObjectVolumeOverviewReq) (*dto.ObjectVolumeOverviewRes, error) {
	res := &dto.ObjectVolumeOverviewRes{}
	// 获取promql数据
	objectBaseInfo, err := s.daoFactory.ObjectVolumeRpcClient().ListObjectVolume(ctx, &resource_objectstoragev1alpha.ObjectVolumeReq{
		PageSize:     -1,
		Region:       par.Region,
		Storageclass: par.DiskType,
	})
	if err != nil {
		lib.Log.TagError(lib.GetTraceContext(ctx), lib.DLTagResponseFailed, map[string]interface{}{"Overview get objectBaseInfo error": err.Error()})
		return nil, err
	}
	if objectBaseInfo.List == nil {
		lib.Log.TagInfo(lib.GetTraceContext(ctx), lib.DLTagResponseFailed, map[string]interface{}{"Overview get objectBaseInfo nil": "data is empty"})
		return res, nil
	}

	for _, metricName := range par.MetricName {
		var line types.BasicOverviewSlot
		for _, v := range metricName {
			qlName := objectstorage.TemplateMap[v](objectBaseInfo.List[0].Region, "", objectBaseInfo.List[0].PoolName, objectBaseInfo.List[0].PoolName, objectBaseInfo.List[0].Name)
			qlMuster, err := s.daoFactory.AlarmRpcClient().ListPromQLs(ctx, qlName)
			if err != nil {
				lib.Log.TagError(lib.GetTraceContext(ctx), lib.DLTagResponseFailed, map[string]interface{}{"Overview get qlMuster info error": err.Error()})
				return nil, err
			}
			qlResult, err := prom_client.VectorQuery(ctx, qlMuster.Items[0].RealPromql)
			if err != nil {
				lib.Log.TagError(lib.GetTraceContext(ctx), lib.DLTagResponseFailed, map[string]interface{}{"Overview get qlResult info error": err.Error()})
				return nil, err
			}
			if len(qlResult) == 0 {
				return nil, errors.New("qlResult.Items is empty")
			}

			if metricName[0] == v {
				line = types.BasicOverviewSlot{
					Info: types.BasicOverviewSlotInfo{
						Name:     objectstorage.MetricMap[v],
						UnitType: types.ParseUnitTypeByUnit(qlMuster.Items[0].Unit),
						Unit:     qlMuster.Items[0].Unit,
						Kind:     types.KindInfo,
						Value:    qlResult[0].Value,
					},
				}
				var platform, business int
				if v == objectstorage.ObjectStorageVolumeBucketCount {
					for _, val := range objectBaseInfo.List {
						if val.Source == constant.Platform {
							platform++
						} else {
							business++
						}
					}
					line.Values = append(line.Values, types.BasicOverviewSlotValue{
						Name:     constant.SourcePlatform,
						UnitType: types.ParseUnitTypeByUnit(qlMuster.Items[0].Unit),
						Value:    platform,
						Unit:     qlMuster.Items[0].Unit,
						Kind:     types.KindInfo,
					})
					line.Values = append(line.Values, types.BasicOverviewSlotValue{
						Name:     constant.SourceBusiness,
						UnitType: types.ParseUnitTypeByUnit(qlMuster.Items[0].Unit),
						Value:    business,
						Unit:     qlMuster.Items[0].Unit,
						Kind:     types.KindInfo,
					})
				}
			} else {
				line.Values = append(line.Values, types.BasicOverviewSlotValue{
					Name:     objectstorage.MetricMap[v],
					UnitType: types.ParseUnitTypeByUnit(qlMuster.Items[0].Unit),
					Value:    qlResult[0].Value,
					Unit:     qlMuster.Items[0].Unit,
					Kind:     types.KindInfo,
				})
			}
		}
		res.Overviews = append(res.Overviews, line)
	}
	return res, nil
}

func (s *objectVolumeService) DetailMetric(ctx *gin.Context, par dto.ObjectVolumeDetailMetricReq) (*dto.ObjectVolumeDetailMetricRes, error) {
	rpcRes, err := s.daoFactory.ObjectVolumeRpcClient().ListObjectVolume(ctx, &resource_objectstoragev1alpha.ObjectVolumeReq{
		BucketId: par.BucketId,
	})
	if err != nil {
		lib.Log.TagError(lib.GetTraceContext(ctx), lib.DLTagUndefind, map[string]interface{}{"rpc error": err})
		return nil, err
	}
	objectVolume := rpcRes.List[0]

	result := []dto.ObjectVolumeDetailMetric{
		{
			PoolId:   objectVolume.PoolId,
			Name:     "当前存储总量",
			Value:    objectVolume.TotalStorage,
			Unit:     "B",
			UnitType: types.TypeStorage,
		},
		{
			PoolId:   objectVolume.PoolId,
			Name:     "近30天下载总量",
			Value:    objectVolume.DownloadFlowMonth,
			Unit:     "B",
			UnitType: types.TypeStorage,
		},
		{
			PoolId:   objectVolume.PoolId,
			Name:     "近30天API请求数",
			Value:    objectVolume.RequestAmountMonth,
			Unit:     "次",
			UnitType: types.TypeNumber,
		},
		{
			PoolId:   objectVolume.PoolId,
			Name:     "总流入流量",
			Value:    objectVolume.UploadFlow,
			Unit:     "B",
			UnitType: types.TypeStorage,
		},
		{
			PoolId:   objectVolume.PoolId,
			Name:     "总流出流量",
			Value:    objectVolume.DownloadFlow,
			Unit:     "B",
			UnitType: types.TypeStorage,
		},
	}
	return &dto.ObjectVolumeDetailMetricRes{
		ResourceOverview:  result,
		CreationTimestamp: objectVolume.CreateTime,
	}, nil
}

func (s *objectVolumeService) DetailMetricLine(ctx *gin.Context, par dto.ObjectVolumeDetailMetricLineReq) (*dto.ObjectVolumeDetailMetricLineRes, error) {
	rpcRes, err := s.daoFactory.ObjectVolumeRpcClient().ListObjectVolume(ctx, &resource_objectstoragev1alpha.ObjectVolumeReq{
		BucketId: par.BucketId,
	})
	if err != nil {
		lib.Log.TagError(lib.GetTraceContext(ctx), lib.DLTagUndefind, map[string]interface{}{"rpc error": err})
		return nil, err
	}
	lines := make([]types.BasicOverviewSlot, 0)
	var line types.BasicOverviewSlot
	var serverline types.BasicOverviewSlot
	var str string
	for _, name := range par.MetricName {
		str = name
		qlName := objectstorage.TemplateMap[name](rpcRes.List[0].Region, strconv.FormatInt(rpcRes.List[0].BucketId, 10), rpcRes.List[0].PoolName, rpcRes.List[0].PoolName, rpcRes.List[0].Name)
		qlMuster, err := s.daoFactory.AlarmRpcClient().ListPromQLs(ctx, qlName)
		if err != nil {
			lib.Log.TagError(lib.GetTraceContext(ctx), lib.DLTagResponseFailed, map[string]interface{}{"Detail get qlMuster info error": err.Error()})
			return nil, err
		}
		if len(qlMuster.Items) == 0 {
			return nil, errors.New("qlMuster.Items is empty")
		}
		lib.Log.TagInfo(lib.GetTraceContext(ctx), lib.DLTagResponseSuccess, map[string]interface{}{"pSql": qlMuster.Items[0].RealPromql})

		if strings.Contains(name, "_count") {
			qlResult, _ := prom_client.VectorQuery(ctx, qlMuster.Items[0].RealPromql)
			if qlResult == nil {
				continue
			}
			for _, v := range qlResult {
				serverline.Values = append(serverline.Values, types.BasicOverviewSlotValue{
					Name:        objectstorage.MetricMap[name],
					UnitType:    types.ParseUnitTypeByUnit(qlMuster.Items[0].Unit),
					Value:       v.Value,
					Unit:        qlMuster.Items[0].Unit,
					Kind:        types.KindInfo,
					Description: strconv.FormatInt(int64(v.Timestamp), 10),
				})
			}
			if err != nil {
				lib.Log.TagError(lib.GetTraceContext(ctx), lib.DLTagResponseFailed, map[string]interface{}{"Detail get qlResult info error": err.Error()})
				return nil, err
			}

		} else {
			qlResult, _ := prom_client.MatrixQuery(ctx, qlMuster.Items[0].RealPromql, v1.Range{
				Start: time.UnixMilli(par.Start),
				End:   time.UnixMilli(par.End),
				Step:  prom_client.TimeToStep(par.End - par.Start),
			})
			if qlResult == nil {
				continue
			}
			for _, v := range qlResult {
				for _, value := range v.Values {
					line.Values = append(line.Values, types.BasicOverviewSlotValue{
						Name:        strconv.FormatInt(int64(value.Timestamp), 10),
						UnitType:    types.ParseUnitTypeByUnit(qlMuster.Items[0].Unit),
						Value:       value.Value,
						Unit:        qlMuster.Items[0].Unit,
						Kind:        types.KindInfo,
						Description: objectstorage.MetricMap[name],
					})

				}
			}
			if err != nil {
				lib.Log.TagError(lib.GetTraceContext(ctx), lib.DLTagResponseFailed, map[string]interface{}{"Detail get qlResult info error": err.Error()})
				return nil, err
			}

			line.Info = types.BasicOverviewSlotInfo{
				Name:     objectstorage.MetricMap[name],
				UnitType: types.ParseUnitTypeByUnit(qlMuster.Items[0].Unit),
				Unit:     qlMuster.Items[0].Unit,
				Kind:     types.KindInfo,
			}

			lines = append(lines, line)
		}
	}
	if strings.Contains(str, "_count") {
		serverline.Info = types.BasicOverviewSlotInfo{
			Name:     "服务质量占比",
			UnitType: types.ParseUnitTypeByUnit("%"),
			Unit:     "%",
			Kind:     types.KindInfo,
		}
		lines = append(lines, serverline)
	}

	return &dto.ObjectVolumeDetailMetricLineRes{
		Lines: lines,
	}, nil
}

```

File path: /Users/mac/Desktop/woker_code/monitor/modules/jobs/dto/response.go
```golang
package dto

type TopJobRsp struct {
}

```

File path: /Users/mac/Desktop/woker_code/monitor/modules/jobs/dto/request.go
```golang
package dto

type TopJobReq struct {
	//资源类型
	ResourceType string `path:"resource_type"`

	//时间间隔
	Interval string `path:"interval"` //
}

```

File path: /Users/mac/Desktop/woker_code/monitor/modules/jobs/dao/monitor_tsdb_metrics.go
```golang
package dao

import (
	"ezone.ksyun.com/ezone/luban/communal/lib"
	"ezone.ksyun.com/ezone/luban/monitor/modules/jobs/model"
	"gorm.io/gorm"
)

type MetricDao struct {
	db *gorm.DB
}

func NewMetricDao() *MetricDao {
	return &MetricDao{
		db: lib.GORMMapPool["business"],
	}
}

func (m *MetricDao) GetOneByCode(code string) (*model.MonitorTsdbMetrics, error) {
	content := model.MonitorTsdbMetrics{}
	err := m.db.Where("code = ?", code).Find(&content).Error
	if err != nil {
		lib.Log.TagError(lib.NewTrace(), lib.DLTagMySqlFailed, map[string]interface{}{"error": err.Error()})
		return nil, err
	}
	return &content, nil
}

// get list by codes
func (m *MetricDao) GetListByCodes(codes []string) ([]model.MonitorTsdbMetrics, error) {
	var content []model.MonitorTsdbMetrics
	err := m.db.Where("code in (?)", codes).Find(&content).Error
	if err != nil {
		lib.Log.TagError(lib.NewTrace(), lib.DLTagMySqlFailed, map[string]interface{}{"error": err.Error()})
		return nil, err
	}
	return content, nil
}

```

File path: /Users/mac/Desktop/woker_code/monitor/modules/jobs/dao/monitor_top.go
```golang
package dao

import (
	"ezone.ksyun.com/ezone/luban/communal/lib"
	"ezone.ksyun.com/ezone/luban/monitor/common/gormSerializer"
	"ezone.ksyun.com/ezone/luban/monitor/modules/jobs/model"
	"gorm.io/gorm"
	"gorm.io/gorm/schema"
)

type MetricTopDao struct {
	db *gorm.DB
}

type QueryParams struct {
	Region string
	Az     string
	Code   string
}

func NewMetricTopDao() *MetricTopDao {
	schema.RegisterSerializer("json_str", gormSerializer.JSONSerializer{})
	return &MetricTopDao{
		db: lib.GORMMapPool["business"],
	}
}

//func (m *MetricTopDao) Insert(data model.MonitorTop) error {
//	if err := m.db.Create(&data).Error; err != nil {
//		return err
//	}
//	return nil
//}

func (m *MetricTopDao) CreateOrUpdate(data model.MonitorTop) error {
	// Save update value in database, if the value doesn't have primary key, will insert it
	if err := m.db.Save(&data).Error; err != nil {
		return err
	}
	return nil
}

func (m *MetricTopDao) GetOneByCode(q QueryParams) (model.MonitorTop, error) {
	var data model.MonitorTop
	if err := m.db.Where("region = ? AND az = ? AND code = ?", q.Region, q.Az, q.Code).First(&data).Error; err != nil {
		return data, err
	}
	return data, nil
}

```

File path: /Users/mac/Desktop/woker_code/monitor/modules/jobs/dao/overview.go
```golang
package dao

import (
	"ezone.ksyun.com/ezone/luban/communal/lib"

	blockstoragepb "ezone.ksyun.com/ezone/luban/luban_api/resourceapis/resource_blockstorage/v1alpha/gen"
	computepb "ezone.ksyun.com/ezone/luban/luban_api/resourceapis/resource_compute/v1alpha/gen"
	databasepb "ezone.ksyun.com/ezone/luban/luban_api/resourceapis/resource_database/v1alpha/gen"
	networkpb "ezone.ksyun.com/ezone/luban/luban_api/resourceapis/resource_network/v1alpha/gen"
	"ezone.ksyun.com/ezone/luban/monitor/common/client/grpcx"
)

type JobsStore struct {
	//rpc
	NetworkRpcClient   networkpb.ResourceNetworkClient
	DatabaseRpcClient  databasepb.DatabaseServiceClient
	VmRpcClient        computepb.VmServiceClient
	EbsVolumeRpcClient blockstoragepb.EbsVolumeServiceClient

	////dao
	MetricDao          *MetricDao
	MetricTopDao       *MetricTopDao
	DbRedisInstanceDao *DbRedisInstanceDao
}

func NewJobsStore() *JobsStore {
	//resource
	resourceAddr := lib.GetStringConf("base.grpc.luban_resource")
	resourceConn, err := grpcx.NewGrpcClientConn(resourceAddr)
	if err != nil {
		lib.Log.TagError(lib.NewTrace(), lib.DLTagUndefind, map[string]interface{}{"connect luban_resource grpc server error, %s": err.Error()})
	}

	return &JobsStore{
		NetworkRpcClient:   networkpb.NewResourceNetworkClient(resourceConn),
		DatabaseRpcClient:  databasepb.NewDatabaseServiceClient(resourceConn),
		VmRpcClient:        computepb.NewVmServiceClient(resourceConn),
		EbsVolumeRpcClient: blockstoragepb.NewEbsVolumeServiceClient(resourceConn),
		MetricDao:          NewMetricDao(),
		MetricTopDao:       NewMetricTopDao(),
		DbRedisInstanceDao: NewDbRedisInstanceDao(),
	}
}

```

File path: /Users/mac/Desktop/woker_code/monitor/modules/jobs/dao/db_redis_instance.go
```golang
package dao

import (
	"ezone.ksyun.com/ezone/luban/communal/lib"
	"ezone.ksyun.com/ezone/luban/monitor/modules/database/model"
	"gorm.io/gorm"
)

type DbRedisInstanceDao struct {
	db *gorm.DB
}

func NewDbRedisInstanceDao() *DbRedisInstanceDao {
	return &DbRedisInstanceDao{
		db: lib.GORMMapPool["business"],
	}
}

func (m *DbRedisInstanceDao) GetDbRedisInstance(instanceId string) (*[]model.DbRedisInstance, error) {
	var content []model.DbRedisInstance
	err := m.db.Where("role = 'MASTER' and instance_id = ?", instanceId).Find(&content).Error
	if err != nil {
		lib.Log.TagError(lib.NewTrace(), lib.DLTagMySqlFailed, map[string]interface{}{"error": err.Error()})
		return nil, err
	}
	return &content, nil
}

```

File path: /Users/mac/Desktop/woker_code/monitor/modules/jobs/controller/top_job.go
```golang
package controller

import (
	"ezone.ksyun.com/ezone/luban/communal/lib"
	"ezone.ksyun.com/ezone/luban/monitor/common/consts"
	"ezone.ksyun.com/ezone/luban/monitor/modules/jobs/constant"
	"ezone.ksyun.com/ezone/luban/monitor/modules/jobs/dto"
	"ezone.ksyun.com/ezone/luban/monitor/modules/jobs/service"

	"ezone.ksyun.com/ezone/luban/monitor/response"
	"github.com/gin-gonic/gin"
	"net/http"
)

type TopJobController struct {
	svc *service.TopJobService
}

func NewJobsController() *TopJobController {
	return &TopJobController{
		svc: service.NewTopJobService(),
	}
}

func (s *TopJobController) TopJob(c *gin.Context) {
	// 参数绑定
	params := dto.TopJobReq{
		ResourceType: c.Param("resource_type"),
		Interval:     c.Param("interval"),
	}

	lib.Log.TagInfo(lib.GetTraceContext(c), lib.DLTagResponseFailed, map[string]interface{}{"params": params})

	sliceIn := func(str string, slice []string) bool {
		for _, v := range slice {
			if v == str {
				return true
			}
		}
		return false
	}
	//参数校验
	if !sliceIn(params.ResourceType, constant.ResourceTypes) {
		lib.Log.TagError(lib.GetTraceContext(c), lib.DLTagRequestOut, map[string]interface{}{"error": consts.ParameterError, "params": params})
		response.Failed(c, http.StatusBadRequest, consts.ParameterError, "resource_type 参数错误")
		return
	}

	if !sliceIn(params.Interval, constant.Intervals) {
		lib.Log.TagError(lib.GetTraceContext(c), lib.DLTagRequestOut, map[string]interface{}{"error": consts.ParameterError, "params": params})
		response.Failed(c, http.StatusBadRequest, consts.ParameterError, "interval 参数错误")
		return
	}

	// 业务处理
	res, err := s.svc.TopJob(c.Request.Context(), &params)
	if err != nil {
		lib.Log.TagError(lib.GetTraceContext(c), lib.DLTagResponseFailed, map[string]interface{}{"error": err.Error()})
		response.Failed(c, http.StatusInternalServerError, consts.GainFail, "获取服务器概览失败")
		return
	}

	lib.Log.TagInfo(lib.GetTraceContext(c), lib.DLTagResponseSuccess, map[string]interface{}{"res": res})
	response.Success(c, res)
}

```

File path: /Users/mac/Desktop/woker_code/monitor/modules/jobs/constant/constant.go
```golang
package constant

const (
	// 网络云产品
	Eip = "eip"
	Lb  = "lb"
	Nat = "nat"

	// 计算云产品
	Vm = "vm"

	// 数据库云产品
	Mysql = "mysql"
	Redis = "redis"

	// 块存储云产品
	EbsVolumeEHDD = "ebs_volume_ehdd"
	EbsVolumeSSD  = "ebs_volume_ssd3.0"

	// 对象存储云产品
	ObjectVolumeKs3 = "object_volume_ks3"

	//定时任务时间间隔
	// 0.5h,1h,3h,12h,1d,7d,30d
	HalfHour    = "0.5h"
	OneHour     = "1h"
	ThreeHours  = "3h"
	TwelveHours = "12h"
	OneDay      = "1d"
	SevenDays   = "7d"
	ThirtyDays  = "30d"
)

var (
	ResourceTypes = []string{Eip, Lb, Nat, Vm, Mysql, Redis, EbsVolumeEHDD, EbsVolumeSSD, ObjectVolumeKs3}
	Intervals     = []string{HalfHour, OneHour, ThreeHours, TwelveHours, OneDay, SevenDays, ThirtyDays}
)

```

File path: /Users/mac/Desktop/woker_code/monitor/modules/jobs/model/monitor_tsdb_metrics.go
```golang
package model

import (
	"time"
)

type MonitorTsdbMetrics struct {
	ID           int       `gorm:"column:id;primary_key;AUTO_INCREMENT"`
	ProductLine  string    `gorm:"column:product_line;NOT NULL"`  // 产品线
	Code         string    `gorm:"column:code;NOT NULL"`          // 唯一标识
	Name         string    `gorm:"column:name;NOT NULL"`          // 中文名
	MetricPrefix string    `gorm:"column:metric_prefix;NOT NULL"` // metric前缀
	Unit         string    `gorm:"column:unit;NOT NULL;default:''"`
	CreatedAt    time.Time `gorm:"column:created_at;default:CURRENT_TIMESTAMP"`
	UpdatedAt    time.Time `gorm:"column:updated_at;default:CURRENT_TIMESTAMP"`
	DeletedAt    time.Time `gorm:"column:deleted_at"`
}

func (m *MonitorTsdbMetrics) TableName() string {
	return "monitor_tsdb_metrics"
}

```

File path: /Users/mac/Desktop/woker_code/monitor/modules/jobs/model/monitor_top.go
```golang
package model

import (
	"ezone.ksyun.com/ezone/luban/monitor/common/client/opentsdb"
	"time"
)

// region + az + code 唯一
type MonitorTop struct {
	ID                  int        `gorm:"column:id;primary_key;AUTO_INCREMENT"`        // 主键
	ProductLine         string     `gorm:"column:product_line;NOT NULL"`                // 产品线
	Region              string     `gorm:"column:region;NOT NULL"`                      // 区域
	Az                  string     `gorm:"column:az;NOT NULL"`                          // 可用区
	Code                string     `gorm:"column:code;NOT NULL"`                        // top项的唯一标识
	Name                string     `gorm:"column:name;NOT NULL"`                        // 中文名
	HalfHour            []TopValue `gorm:"column:half_hour;serializer:json_str"`        // 0.5h top10数据
	HalfHourUpdateAt    time.Time  `gorm:"column:half_hour_update_at"`                  // 0.5h更新时间
	OneHour             []TopValue `gorm:"column:one_hour;serializer:json_str"`         // 1h top10数据
	OneHourUpdateAt     time.Time  `gorm:"column:one_hour_update_at"`                   // 1h更新时间
	ThreeHours          []TopValue `gorm:"column:three_hours;serializer:json_str"`      // 3h top10数据
	ThreeHoursUpdateAt  time.Time  `gorm:"column:three_hours_update_at"`                // 3h更新时间
	TwelveHours         []TopValue `gorm:"column:twelve_hours;serializer:json_str"`     // 12h top10数据
	TwelveHoursUpdateAt time.Time  `gorm:"column:twelve_hours_update_at"`               // 12h更新时间
	OneDay              []TopValue `gorm:"column:one_day;serializer:json_str"`          // 1d top10数据
	OneDayUpdateAt      time.Time  `gorm:"column:one_day_update_at"`                    // 1d更新时间
	SevenDays           []TopValue `gorm:"column:seven_days;serializer:json_str"`       // 7d top10数据
	SevenDaysUpdateAt   time.Time  `gorm:"column:seven_days_update_at"`                 // 7d更新时间
	ThirtyDays          []TopValue `gorm:"column:thirty_days;serializer:json_str"`      // 30d top10数据
	ThirtyDaysUpdateAt  time.Time  `gorm:"column:thirty_days_update_at"`                // 30d更新时间
	CreatedAt           time.Time  `gorm:"column:created_at;default:CURRENT_TIMESTAMP"` // 创建时间
	UpdatedAt           time.Time  `gorm:"column:updated_at;default:CURRENT_TIMESTAMP"` // 更新时间
	DeletedAt           time.Time  `gorm:"column:deleted_at"`                           // 删除时间
}

type TopValue struct {
	ParentId string  //父级id，暂时用于标识redis的clusterId
	Id       string  //实例唯一id
	Name     string  //名称
	Value    float64 //值
}

func (m *MonitorTop) TableName() string {
	return "monitor_top"
}

func (m *MonitorTop) ParseIntervalData(start, end int64) []TopValue {
	var intervalData []TopValue
	intervalStr := opentsdb.ParseTimeInterval(start, end)
	switch intervalStr {
	case "0.5h":
		intervalData = m.HalfHour
	case "1h":
		intervalData = m.OneHour
	case "3h":
		intervalData = m.ThreeHours
	case "12h":
		intervalData = m.TwelveHours
	case "1d":
		intervalData = m.OneDay
	case "7d":
		intervalData = m.SevenDays
	case "30d":
		intervalData = m.ThirtyDays
	}
	return intervalData
}

```

File path: /Users/mac/Desktop/woker_code/monitor/modules/jobs/service/mysql_job.go
```golang
package service

import (
	"context"
	pb "ezone.ksyun.com/ezone/luban/luban_api/resourceapis/resource_database/v1alpha/gen"
	"ezone.ksyun.com/ezone/luban/monitor/common/tsdbql_template/mysql"
	"ezone.ksyun.com/ezone/luban/monitor/modules/jobs/dto"
	"fmt"
)

func (t *TopJobService) mysqlTopJob(ctx context.Context, par *dto.TopJobReq) (*jobParam, error) {

	mysqlListRsp, err := t.Store.DatabaseRpcClient.ListDatabase(ctx, &pb.ProductDbListRequest{
		PageSize:     -1,
		DataBaseType: "mysql",
	})
	if err != nil {
		fmt.Printf("error query rpc ListMysql: %v", err)
		return nil, err
	}
	mysqlList := mysqlListRsp.Data
	hasAz := false
	if len(mysqlList) > 0 && mysqlList[len(mysqlList)-1].Az != "" {
		hasAz = true
	}

	allIdToInstanceMap := make(map[string]instanceInfo)
	regionToInstancesMap := make(regionAzGroup)
	azToInstancesMap := make(regionAzGroup)
	for _, m := range mysqlList {
		instance := instanceInfo{
			Id:     m.Id,
			Name:   m.Name,
			Region: m.Region,
		}
		allIdToInstanceMap[m.Id] = instance
		rz := regionAz{
			Region: m.Region,
			Az:     m.Az,
		}
		regionToInstancesMap[rz] = append(regionToInstancesMap[rz], instance)
		azToInstancesMap[rz] = append(azToInstancesMap[rz], instance)
	}

	if !hasAz {
		azToInstancesMap = nil
	}

	//需要TOP的指标
	metrics := []string{mysql.Mysql_cpu_used_percent, mysql.Mysql_memory_used_percent, mysql.Mysql_riops, mysql.Mysql_wiops, mysql.Mysql_threads_connected, mysql.Mysql_threads_running, mysql.Mysql_bytes_received, mysql.Mysql_bytes_sent, mysql.Mysql_qps, mysql.Mysql_tps}
	return &jobParam{
		interval:             par.Interval,
		metrics:              metrics,
		allIdToInstanceMap:   allIdToInstanceMap,
		regionToInstancesMap: regionToInstancesMap,
		azToInstancesMap:     azToInstancesMap,
	}, nil
}

```

File path: /Users/mac/Desktop/woker_code/monitor/modules/jobs/service/network_job.go
```golang
package service

import (
	"context"
	pb "ezone.ksyun.com/ezone/luban/luban_api/resourceapis/resource_network/v1alpha/gen"
	"ezone.ksyun.com/ezone/luban/monitor/common/tsdbql_template/eip"
	"ezone.ksyun.com/ezone/luban/monitor/modules/jobs/dto"
	"fmt"
)

func (n *TopJobService) eipTopJob(ctx context.Context, par *dto.TopJobReq) (*jobParam, error) {

	eipListRsp, err := n.Store.NetworkRpcClient.ListEip(ctx, &pb.ListEipReq{
		PageSize: -1, //all
	})
	if err != nil {
		fmt.Printf("error query rpc ListEip: %v", err)
		return nil, err
	}
	eipList := eipListRsp.EipSet

	allIdToInstanceMap := make(map[string]instanceInfo)
	regionToInstancesMap := make(regionAzGroup)
	//azToInstancesMap := make(regionAzGroup)
	for _, e := range eipList {

		//只有绑定状态的eip才有监控数据
		if e.BoundState != 3 {
			continue
		}

		instance := instanceInfo{
			Id:     e.InstanceID,
			Name:   e.IpAddr,
			Region: e.Region,
		}
		allIdToInstanceMap[e.InstanceID] = instance
		rz := regionAz{
			Region: e.Region,
			//Az:     e.Az,   产品有az划分的添加
		}
		regionToInstancesMap[rz] = append(regionToInstancesMap[rz], instance)
		//azToInstancesMap[rz] = append(azToInstanceMap[rz], instance)
	}

	//需要TOP的指标
	metrics := eip.Eip_top_metirc
	return &jobParam{
		interval:             par.Interval,
		metrics:              metrics,
		allIdToInstanceMap:   allIdToInstanceMap,
		regionToInstancesMap: regionToInstancesMap,
		//azToInstancesMap: azToInstancesMap,
	}, nil
}

```

File path: /Users/mac/Desktop/woker_code/monitor/modules/jobs/service/top_job_test.go
```golang
package service

import (
	"context"
	"encoding/json"
	"log"
	"os"
	"path/filepath"
	"testing"

	"ezone.ksyun.com/ezone/luban/communal/lib"
	computePoolv1alpha "ezone.ksyun.com/ezone/luban/luban_api/resourceapis/resource_compute/v1alpha/gen"
	"ezone.ksyun.com/ezone/luban/monitor/common/client/grpcx"
	"ezone.ksyun.com/ezone/luban/monitor/common/client/opentsdb/pkg"
	"ezone.ksyun.com/ezone/luban/monitor/modules/jobs/dao"
	"ezone.ksyun.com/ezone/luban/monitor/modules/jobs/dto"
)

func findProjectRoot(startDir string) string {
	_, err := os.Stat(filepath.Join(startDir, "go.mod"))
	if err == nil {
		return startDir
	}
	// 获取上级目录
	parentDir := filepath.Dir(startDir)
	if parentDir == startDir {
		return ""
	}
	return findProjectRoot(parentDir)
}

func TestTopJobService_TopJob(t *testing.T) {
	type args struct {
		ctx context.Context
		par *dto.TopJobReq
	}
	tests := []struct {
		name string
		args args
	}{
		{
			name: "test01",
			args: args{
				ctx: context.Background(),
				par: &dto.TopJobReq{
					ResourceType: "vm",
					Interval:     "0.5h",
				},
			},
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			// 配置信息
			dir, _ := os.Getwd()
			if err := lib.InitModuleYaml(findProjectRoot(dir)+"/conf/", []string{"base", "mysql", "redis"}); err != nil {
				log.Println(err)
			}
			n := &TopJobService{}
			resourceAddr := "10.177.10.1:8810"
			resourceConn, _ := grpcx.NewGrpcClientConn(resourceAddr)
			n.Store.VmRpcClient = computePoolv1alpha.NewVmServiceClient(resourceConn)
			n.Store.MetricDao = dao.NewMetricDao()
			n.Store.MetricTopDao = dao.NewMetricTopDao()

			got, _ := n.TopJob(tt.args.ctx, tt.args.par)
			t.Logf("Test top job successful %v", got)
		})
	}
}

func Test_queryAndParseTopValues(t *testing.T) {
	type args struct {
		region string
		par    pkg.QueryParam
	}
	tests := []struct {
		name string
		args args
	}{
		{
			name: "test01",
			args: args{
				region: "cn-shanghai-2",
				par: pkg.QueryParam{
					Start: 1702651144,
					End:   1706251144,
					Queries: []pkg.SubQuery{
						{
							Aggregator: "sum",
							Metric:     "cpu.utilizition.total.171c7bba-f23e-42cb-a446-29f757cf3c81",
							Rate:       false,
							RateParams: nil,
							Downsample: "1h-avg-zero",
							Tags: map[string]string{
								"host": "171c7bba-f23e-42cb-a446-29f757cf3c81",
							},
							Fiters: nil,
						},
					},
					NoAnnotations:     false,
					GlobalAnnotations: false,
					MsResolution:      false,
					ShowTSUIDs:        false,
					Delete:            false,
				},
			},
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {

			got, _ := queryAndParseTopValues(context.Background(), tt.args.region, tt.args.par)

			jsonResult, err := json.Marshal(got)
			if err != nil {
				t.Errorf("Failed to marshal result to JSON: %v", err)
				return
			}

			t.Logf("query and parese top values result = %v", string(jsonResult))
		})
	}
}

```

File path: /Users/mac/Desktop/woker_code/monitor/modules/jobs/service/top_job.go
```golang
package service

import (
	"context"
	"errors"
	"fmt"
	"net/http"
	"sort"
	"sync"
	"time"

	"ezone.ksyun.com/ezone/luban/monitor/common/tools"
	"ezone.ksyun.com/ezone/luban/monitor/common/tsdbql_template/vm"
	"ezone.ksyun.com/ezone/luban/monitor/common/utils"

	"ezone.ksyun.com/ezone/luban/monitor/common/client/opentsdb"
	"ezone.ksyun.com/ezone/luban/monitor/common/client/opentsdb/pkg"
	"ezone.ksyun.com/ezone/luban/monitor/common/tsdbql_template"
	"ezone.ksyun.com/ezone/luban/monitor/modules/jobs/constant"
	"ezone.ksyun.com/ezone/luban/monitor/modules/jobs/dao"
	"ezone.ksyun.com/ezone/luban/monitor/modules/jobs/dto"
	"ezone.ksyun.com/ezone/luban/monitor/modules/jobs/model"
	"gorm.io/gorm"
)

type TopJobService struct {
	Store dao.JobsStore
}

func NewTopJobService() *TopJobService {
	return &TopJobService{
		Store: *dao.NewJobsStore(),
	}
}

type instanceInfo struct {
	Id        string
	Name      string
	Region    string
	Value     float64
	Instances []instanceInfo
}

type regionAz struct {
	Region string
	Az     string
}

type regionAzGroup map[regionAz][]instanceInfo

type jobParam struct {
	interval             string
	metrics              []string
	allIdToInstanceMap   map[string]instanceInfo //id:instanceInfo
	regionToInstancesMap regionAzGroup           //group by region,  cn-shanghai-2:[]instanceInfo
	azToInstancesMap     regionAzGroup           //group by region,az, cn-shanghai-2,cn-shanghai-2a:[]instanceInfo
}

func (n *TopJobService) TopJob(ctx context.Context, par *dto.TopJobReq) (*dto.TopJobRsp, error) {
	var (
		err   error
		param *jobParam
	)

	switch par.ResourceType {
	case constant.Eip:
		param, err = n.eipTopJob(ctx, par)
		if err != nil {
			return nil, err
		}
	case constant.Mysql:
		param, err = n.mysqlTopJob(ctx, par)
		if err != nil {
			return nil, err
		}
	case constant.Redis:
		param, err = n.redisTopJob(ctx, par)
		if err != nil {
			return nil, err
		}
	case constant.Vm:
		param, err = n.vmTopJob(ctx, par)
		if err != nil {
			return nil, err
		}
	case constant.EbsVolumeEHDD:
		param, err = n.ehddEbsVolumeTopJob(ctx, par)
		if err != nil {
			return nil, err
		}
	case constant.EbsVolumeSSD:
		param, err = n.ssdEbsVolumeTopJob(ctx, par)
		if err != nil {
			return nil, err
		}
	case constant.Lb:
		param, err = n.lbTopJob(ctx, par)
		if err != nil {
			return nil, err
		}
	case constant.Nat:
		param, err = n.natTopJob(ctx, par)
		if err != nil {
			return nil, err
		}
	default:
		return nil, errors.New("unimplement resource type")
	}

	err = n.doTopJob(ctx, *param)
	if err != nil {
		return nil, err
	}
	return &dto.TopJobRsp{}, nil
}

func (n *TopJobService) doTopJob(ctx context.Context, param jobParam) error {

	inTime := time.Now()

	interval := param.interval
	metrics := param.metrics
	allIdToInstanceMap := param.allIdToInstanceMap
	regionToInstancesMap := param.regionToInstancesMap
	azToInstancesMap := param.azToInstancesMap

	tsdbMetricList, err := n.Store.MetricDao.GetListByCodes(metrics)
	if err != nil {
		return err
	}

	var topValueChanCount int
	for _, v := range allIdToInstanceMap {
		if len(v.Instances) != 0 {
			topValueChanCount += len(v.Instances)
		} else {
			topValueChanCount++
		}
	}

	for _, m := range tsdbMetricList {
		allTopValues := []model.TopValue{}
		topValueChan := make(chan model.TopValue, topValueChanCount)
		wg := sync.WaitGroup{}
		for k, v := range allIdToInstanceMap {
			if len(v.Instances) == 0 {
				v.Instances = append(v.Instances, v)
				allIdToInstanceMap[k] = v
			}
			region := v.Region
			parentId := v.Id
			for _, childV := range v.Instances {
				queryParam := tsdbQuery(interval, childV.Id, m)
				wg.Add(1)
				utils.GoSafe(func() {
					defer wg.Done()
					topValue, err := queryAndParseTopValues(ctx, region, queryParam)
					if err != nil {
						fmt.Printf("Error queryAndParseTopValues: %v\n", err)
						return
					}
					topValue.ParentId = parentId
					topValueChan <- topValue
				})
			}
		}

		wg.Wait()
		close(topValueChan)
		for v := range topValueChan {
			if instance, ok := allIdToInstanceMap[v.ParentId]; ok {
				instance.Value += v.Value
				allIdToInstanceMap[v.ParentId] = instance
			}
		}

		for k, v := range allIdToInstanceMap {
			v.Value = v.Value / float64(len(v.Instances))
			if m.Unit == "%" {
				v.Value = tools.FormPercent(v.Value / 1e2)
			}
			allTopValues = append(allTopValues, model.TopValue{
				Id:    v.Id,
				Name:  v.Name,
				Value: v.Value,
			})
			v.Value = 0
			allIdToInstanceMap[k] = v
		}

		//top all region, all az
		err = saveTopValues(n.Store.MetricTopDao, interval, "", "", allTopValues, m)
		if err != nil {
			return err
		}
		idTotopValuesMap := topValuesToMap(allTopValues)
		//top by regions
		for rz, instances := range regionToInstancesMap {
			regionTopValues := []model.TopValue{}
			for _, instance := range instances {
				regionTopValues = append(regionTopValues, idTotopValuesMap[instance.Id])
			}
			err = saveTopValues(n.Store.MetricTopDao, interval, rz.Region, "", regionTopValues, m)
			if err != nil {
				return err
			}
		}

		//top by region,az
		if azToInstancesMap != nil && len(azToInstancesMap) > 0 {
			for rz, instances := range azToInstancesMap {
				azTopValues := []model.TopValue{}
				for _, instance := range instances {
					azTopValues = append(azTopValues, idTotopValuesMap[instance.Id])
				}
				err = saveTopValues(n.Store.MetricTopDao, interval, rz.Region, rz.Az, azTopValues, m)
				if err != nil {
					return err
				}
			}
		}
	}
	fmt.Printf("total cost: %v", time.Since(inTime))
	return nil
}

func topValuesToMap(topValues []model.TopValue) map[string]model.TopValue {
	topValuesMap := make(map[string]model.TopValue)
	for _, v := range topValues {
		topValuesMap[v.Id] = v
	}
	return topValuesMap
}

func tsdbQuery(interval string, instanceId string, m model.MonitorTsdbMetrics) pkg.QueryParam {

	//top的查询区间
	startTime, endTime := opentsdb.ParseTimeFromIntervalStr(interval)
	queryParam := pkg.QueryParam{
		Start: startTime,
		End:   endTime,
	}

	subqueries := make([]pkg.SubQuery, 0)
	eipQuery := tsdbql_template.ParseTsdbQuery(m.ProductLine, m.MetricPrefix, instanceId)
	subqueries = append(subqueries, pkg.SubQuery{
		Aggregator: "sum",
		Metric:     eipQuery.Metric,
		Tags:       map[string]string{"host": eipQuery.HostTag},
		//Downsample: opentsdb.TimeToDownsample(endTime - startTime),
		//根据时间间隔设置返回计算好平均值后一个点的downsample
		Downsample: opentsdb.ParseTopDownsampleFromIntervalStr(interval),
	})
	if m.ProductLine == "kec" {
		subqueries = make([]pkg.SubQuery, 0)
		vmQuery := vm.ParseTsdbQuery(m.Code, m.MetricPrefix, instanceId)
		subqueries = append(subqueries, pkg.SubQuery{
			Aggregator: "sum",
			Metric:     vmQuery.Metric,
			Downsample: opentsdb.ParseTopDownsampleFromIntervalStr(interval),
			Tags:       vmQuery.Tags,
		})
	}
	queryParam.Queries = subqueries
	return queryParam
}

func queryAndParseTopValues(ctx context.Context, region string, queryParam pkg.QueryParam) (topValue model.TopValue, err error) {
	queryResp, err := opentsdb.QueryWithLimiter(ctx, region, queryParam)
	if err != nil {
		fmt.Printf("Error tsdb query: %+v   err: [%v]\n", queryParam, err)
		return
	}

	//查询404返回空数据
	if queryResp.StatusCode != http.StatusOK {
		if queryResp.StatusCode == http.StatusNotFound {
			return topValue, errors.New(fmt.Sprintf("tsdb query err, metric not found, RSP: [%+v] REQ: [%+v]\n", queryResp.QueryRespCnts, queryParam))
		}
		return topValue, errors.New(fmt.Sprintf("tsdb query err, rsp error, RSP: [%+v] REQ: [%+v]\n", queryResp.QueryRespCnts, queryParam))
	}
	//查询200,但是数据为空，返回空数据
	if len(queryResp.QueryRespCnts) <= 0 {
		return topValue, errors.New(fmt.Sprintf("tsdb query err, rsp empty, RSP: [%+v] REQ: [%+v]\n", queryResp.QueryRespCnts, queryParam))
	}

	data := queryResp.QueryRespCnts[0]
	topValue = model.TopValue{
		Id:    tsdbql_template.GetInstanceIdFromHostTag(data.Tags["host"]),
		Value: data.GetDataPoints()[0].Value.(float64),
	}

	return
}

func saveTopValues(metricTopDao *dao.MetricTopDao, interval, region, az string, topValues []model.TopValue, m model.MonitorTsdbMetrics) error {

	//copy，no change original
	newTopValues := make([]model.TopValue, len(topValues))
	copy(newTopValues, topValues)

	//sort
	sort.Slice(newTopValues, func(i, j int) bool {
		return newTopValues[i].Value > newTopValues[j].Value
	})

	//limit top10
	if len(newTopValues) > 10 {
		newTopValues = newTopValues[:10]
	}

	//if all newTopValues value == 0 , print debug log
	allZero := true
	for _, v := range newTopValues {
		if v.Value != 0 {
			allZero = false
			break
		}
	}
	if allZero {
		fmt.Printf("\n Debug-Zero: All newTopValues are zero. region: %s, az: %s, code: %s, interval: %s\n", region, az, m.Code, interval)
		return nil
	}

	//save to mysql
	topData, err := metricTopDao.GetOneByCode(dao.QueryParams{
		Region: region,
		Az:     az,
		Code:   m.Code,
	})
	if err != nil && !errors.Is(err, gorm.ErrRecordNotFound) {
		return err
	}

	if errors.Is(err, gorm.ErrRecordNotFound) {
		topData.Region = region
		topData.Az = az
		topData.ProductLine = m.ProductLine
		topData.Name = m.Name
		topData.Code = m.Code
	}

	switch interval {
	case constant.HalfHour:
		topData.HalfHour = newTopValues
		topData.HalfHourUpdateAt = time.Now()
	case constant.OneHour:
		topData.OneHour = newTopValues
		topData.OneHourUpdateAt = time.Now()
	case constant.ThreeHours:
		topData.ThreeHours = newTopValues
		topData.ThreeHoursUpdateAt = time.Now()
	case constant.TwelveHours:
		topData.TwelveHours = newTopValues
		topData.TwelveHoursUpdateAt = time.Now()
	case constant.OneDay:
		topData.OneDay = newTopValues
		topData.OneDayUpdateAt = time.Now()
	case constant.SevenDays:
		topData.SevenDays = newTopValues
		topData.SevenDaysUpdateAt = time.Now()
	case constant.ThirtyDays:
		topData.ThirtyDays = newTopValues
		topData.ThirtyDaysUpdateAt = time.Now()
	}

	err = metricTopDao.CreateOrUpdate(topData)
	if err != nil {
		return err
	}
	return nil
}

```

File path: /Users/mac/Desktop/woker_code/monitor/modules/jobs/service/nat_job.go
```golang
package service

import (
	"context"
	pb "ezone.ksyun.com/ezone/luban/luban_api/resourceapis/resource_network/v1alpha/gen"
	"ezone.ksyun.com/ezone/luban/monitor/common/tsdbql_template/nat"
	"ezone.ksyun.com/ezone/luban/monitor/modules/jobs/dto"
	"fmt"
)

func (t *TopJobService) natTopJob(ctx context.Context, par *dto.TopJobReq) (*jobParam, error) {

	natListRsp, err := t.Store.NetworkRpcClient.ListNat(ctx, &pb.ListNatReq{
		PageSize: -1,
	})
	if err != nil {
		fmt.Printf("error query rpc ListLb: %v", err)
		return nil, err
	}
	natList := natListRsp.NatSet
	hasAz := false
	if len(natList) > 0 && natList[len(natList)-1].Az != "" {
		hasAz = true
	}

	allIdToInstanceMap := make(map[string]instanceInfo)
	regionToInstancesMap := make(regionAzGroup)
	azToInstancesMap := make(regionAzGroup)
	for _, m := range natList {
		instance := instanceInfo{
			Id:     m.NatId,
			Name:   m.NatName,
			Region: m.Region,
		}
		allIdToInstanceMap[m.NatId] = instance
		rz := regionAz{
			Region: m.Region,
			Az:     m.Az,
		}
		regionToInstancesMap[rz] = append(regionToInstancesMap[rz], instance)
		azToInstancesMap[rz] = append(azToInstancesMap[rz], instance)
	}

	if !hasAz {
		azToInstancesMap = nil
	}

	//需要TOP的指标
	metrics := []string{nat.Nat_bps_in, nat.Nat_bps_out, nat.Nat_public_bps_in, nat.Nat_public_bps_out, nat.Nat_pps_in, nat.Nat_pps_out, nat.Nat_public_pps_in, nat.Nat_public_pps_out}
	return &jobParam{
		interval:             par.Interval,
		metrics:              metrics,
		allIdToInstanceMap:   allIdToInstanceMap,
		regionToInstancesMap: regionToInstancesMap,
		azToInstancesMap:     azToInstancesMap,
	}, nil
}

```

File path: /Users/mac/Desktop/woker_code/monitor/modules/jobs/service/redis_job.go
```golang
package service

import (
	"context"
	pb "ezone.ksyun.com/ezone/luban/luban_api/resourceapis/resource_database/v1alpha/gen"
	"ezone.ksyun.com/ezone/luban/monitor/common/tsdbql_template/redis"
	"ezone.ksyun.com/ezone/luban/monitor/modules/jobs/dto"
	"fmt"
)

func (t *TopJobService) redisTopJob(ctx context.Context, par *dto.TopJobReq) (*jobParam, error) {
	redisListRsp, err := t.Store.DatabaseRpcClient.ListDatabase(ctx, &pb.ProductDbListRequest{
		PageSize:     -1,
		DataBaseType: "redis",
	})
	if err != nil {
		fmt.Printf("error query rpc ListRedis: %v", err)
		return nil, err
	}
	redisList := redisListRsp.Data
	hasAz := false
	if len(redisList) > 0 && redisList[len(redisList)-1].Az != "" {
		hasAz = true
	}

	allIdToInstanceMap := make(map[string]instanceInfo)
	regionToInstancesMap := make(regionAzGroup)
	azToInstancesMap := make(regionAzGroup)
	for _, r := range redisList {
		list, err := t.Store.DbRedisInstanceDao.GetDbRedisInstance(r.Id)
		if err != nil {
			return nil, err
		}
		instance := instanceInfo{
			Id:     r.Id,
			Name:   r.Name,
			Region: r.Region,
		}
		for _, v := range *list {
			instance.Instances = append(instance.Instances, instanceInfo{
				Id:     v.SubInstanceId,
				Name:   r.Name,
				Region: r.Region,
			})
		}
		allIdToInstanceMap[r.Id] = instance
		rz := regionAz{
			Region: r.Region,
			Az:     r.Az,
		}
		regionToInstancesMap[rz] = append(regionToInstancesMap[rz], instance)
		azToInstancesMap[rz] = append(azToInstancesMap[rz], instance)
	}

	if !hasAz {
		azToInstancesMap = nil
	}

	//需要TOP的指标
	metrics := []string{redis.Redis_cpu_load, redis.Redis_memory_load, redis.Redis_connection_usage}
	return &jobParam{
		interval:             par.Interval,
		metrics:              metrics,
		allIdToInstanceMap:   allIdToInstanceMap,
		regionToInstancesMap: regionToInstancesMap,
		azToInstancesMap:     azToInstancesMap,
	}, nil
}

```

File path: /Users/mac/Desktop/woker_code/monitor/modules/jobs/service/ebs_volume_job.go
```golang
package service

import (
	"context"
	"fmt"

	pb "ezone.ksyun.com/ezone/luban/luban_api/resourceapis/resource_blockstorage/v1alpha/gen"
	ebsVolume "ezone.ksyun.com/ezone/luban/monitor/common/tsdbql_template/ebs_volume"
	"ezone.ksyun.com/ezone/luban/monitor/modules/jobs/dto"
)

func (n *TopJobService) ehddEbsVolumeTopJob(ctx context.Context, par *dto.TopJobReq) (*jobParam, error) {
	ebsVolumeListRsp, err := n.Store.EbsVolumeRpcClient.ListEbsVolume(ctx, &pb.ListVolumeReq{
		PageSize:   -1,
		VolumeType: []string{"ehdd"},
	})
	if err != nil {
		err = fmt.Errorf("error query rpc ListEbsVolume: %v", err)
		return nil, err
	}
	ebsVolumeList := ebsVolumeListRsp.List
	IdToInstanceMap := make(map[string]instanceInfo)
	regionToInstancesMap := make(regionAzGroup)
	azToInstancesMap := make(regionAzGroup)
	for _, ebsVolume := range ebsVolumeList {
		instance := instanceInfo{
			Id:     ebsVolume.VmId,
			Name:   ebsVolume.Name,
			Region: ebsVolume.Region,
		}
		IdToInstanceMap[ebsVolume.VmId] = instance
		if ebsVolume.Region != "" {
			r := regionAz{
				Region: ebsVolume.Region,
			}
			regionToInstancesMap[r] = append(regionToInstancesMap[r], instance)
		}
		if ebsVolume.Region != "" && ebsVolume.Az != "" {
			rz := regionAz{
				Region: ebsVolume.Region,
				Az:     ebsVolume.Az,
			}
			azToInstancesMap[rz] = append(azToInstancesMap[rz], instance)
		}
	}
	// 查对应挂载云主机的指标数据
	metrics := ebsVolume.EbsVolumeTopEhddMetrics
	return &jobParam{
		interval:             par.Interval,
		metrics:              metrics,
		allIdToInstanceMap:   IdToInstanceMap,
		regionToInstancesMap: regionToInstancesMap,
		azToInstancesMap:     azToInstancesMap,
	}, nil
}

func (n *TopJobService) ssdEbsVolumeTopJob(ctx context.Context, par *dto.TopJobReq) (*jobParam, error) {
	ebsVolumeListRsp, err := n.Store.EbsVolumeRpcClient.ListEbsVolume(ctx, &pb.ListVolumeReq{
		PageSize:   -1,
		VolumeType: []string{"ssd3.0"},
	})
	if err != nil {
		err = fmt.Errorf("error query rpc ListEbsVolume: %v", err)
		return nil, err
	}
	ebsVolumeList := ebsVolumeListRsp.List
	IdToInstanceMap := make(map[string]instanceInfo)
	regionToInstancesMap := make(regionAzGroup)
	azToInstancesMap := make(regionAzGroup)
	for _, ebsVolume := range ebsVolumeList {
		instance := instanceInfo{
			Id:     ebsVolume.VmId,
			Name:   ebsVolume.Name,
			Region: ebsVolume.Region,
		}
		IdToInstanceMap[ebsVolume.VmId] = instance
		if ebsVolume.Region != "" {
			r := regionAz{
				Region: ebsVolume.Region,
			}
			regionToInstancesMap[r] = append(regionToInstancesMap[r], instance)
		}
		if ebsVolume.Region != "" && ebsVolume.Az != "" {
			rz := regionAz{
				Region: ebsVolume.Region,
				Az:     ebsVolume.Az,
			}
			azToInstancesMap[rz] = append(azToInstancesMap[rz], instance)
		}
	}
	// 查对应挂载云主机的指标数据
	metrics := ebsVolume.EbsVolumeTopSSDMetrics
	return &jobParam{
		interval:             par.Interval,
		metrics:              metrics,
		allIdToInstanceMap:   IdToInstanceMap,
		regionToInstancesMap: regionToInstancesMap,
		azToInstancesMap:     azToInstancesMap,
	}, nil
}

func (n *TopJobService) EbsVolumeTopJob(ctx context.Context, par *dto.TopJobReq) (*jobParam, error) {
	ebsVolumeListRsp, err := n.Store.EbsVolumeRpcClient.ListEbsVolume(ctx, &pb.ListVolumeReq{
		PageSize: -1,
	})
	if err != nil {
		err = fmt.Errorf("error query rpc ListEbsVolume: %v", err)
		return nil, err
	}
	ebsVolumeList := ebsVolumeListRsp.List
	IdToInstanceMap := make(map[string]instanceInfo)
	regionToInstancesMap := make(regionAzGroup)
	azToInstancesMap := make(regionAzGroup)
	for _, ebsVolume := range ebsVolumeList {
		instance := instanceInfo{
			Id:     ebsVolume.VmId,
			Name:   ebsVolume.Name,
			Region: ebsVolume.Region,
		}
		IdToInstanceMap[ebsVolume.VmId] = instance
		if ebsVolume.Region != "" {
			r := regionAz{
				Region: ebsVolume.Region,
			}
			regionToInstancesMap[r] = append(regionToInstancesMap[r], instance)
		}
		if ebsVolume.Region != "" && ebsVolume.Az != "" {
			rz := regionAz{
				Region: ebsVolume.Region,
				Az:     ebsVolume.Az,
			}
			azToInstancesMap[rz] = append(azToInstancesMap[rz], instance)
		}
	}
	// 查对应挂载云主机的指标数据
	metrics := ebsVolume.EbsVolumeTopEhddMetrics
	return &jobParam{
		interval:             par.Interval,
		metrics:              metrics,
		allIdToInstanceMap:   IdToInstanceMap,
		regionToInstancesMap: regionToInstancesMap,
		azToInstancesMap:     azToInstancesMap,
	}, nil
}

```

File path: /Users/mac/Desktop/woker_code/monitor/modules/jobs/service/lb_job.go
```golang
package service

import (
	"context"
	pb "ezone.ksyun.com/ezone/luban/luban_api/resourceapis/resource_network/v1alpha/gen"
	"ezone.ksyun.com/ezone/luban/monitor/common/tsdbql_template/lb"
	"ezone.ksyun.com/ezone/luban/monitor/modules/jobs/dto"
	"fmt"
)

func (t *TopJobService) lbTopJob(ctx context.Context, par *dto.TopJobReq) (*jobParam, error) {
	
	lbListRsp, err := t.Store.NetworkRpcClient.ListLb(ctx, &pb.ListLbReq{
		PageSize: -1,
	})
	if err != nil {
		fmt.Printf("error query rpc ListLb: %v", err)
		return nil, err
	}
	lbList := lbListRsp.LoadBalancerSet
	hasAz := false
	if len(lbList) > 0 && lbList[len(lbList)-1].Az != "" {
		hasAz = true
	}

	allIdToInstanceMap := make(map[string]instanceInfo)
	regionToInstancesMap := make(regionAzGroup)
	azToInstancesMap := make(regionAzGroup)
	for _, m := range lbList {
		instance := instanceInfo{
			Id:     m.LoadBalancerId,
			Name:   m.LoadBalancerName,
			Region: m.Region,
		}
		allIdToInstanceMap[m.LoadBalancerId] = instance
		rz := regionAz{
			Region: m.Region,
			Az:     m.Az,
		}
		regionToInstancesMap[rz] = append(regionToInstancesMap[rz], instance)
		azToInstancesMap[rz] = append(azToInstancesMap[rz], instance)
	}

	if !hasAz {
		azToInstancesMap = nil
	}

	//需要TOP的指标
	metrics := []string{lb.Lb_flow_in, lb.Lb_flow_out, lb.Lb_pps_in, lb.Lb_pps_out, lb.Lb_cps, lb.Lb_activeconn, lb.Lb_concurrentconn, lb.Lb_inactiveconn}
	return &jobParam{
		interval:             par.Interval,
		metrics:              metrics,
		allIdToInstanceMap:   allIdToInstanceMap,
		regionToInstancesMap: regionToInstancesMap,
		azToInstancesMap:     azToInstancesMap,
	}, nil
}

```

File path: /Users/mac/Desktop/woker_code/monitor/modules/jobs/service/vm_job.go
```golang
package service

import (
	"context"
	"fmt"

	pb "ezone.ksyun.com/ezone/luban/luban_api/resourceapis/resource_compute/v1alpha/gen"
	"ezone.ksyun.com/ezone/luban/monitor/common/tsdbql_template/vm"
	"ezone.ksyun.com/ezone/luban/monitor/modules/jobs/dto"
)

func (n *TopJobService) vmTopJob(ctx context.Context, par *dto.TopJobReq) (*jobParam, error) {
	vmListRsp, err := n.Store.VmRpcClient.ListVm(ctx, &pb.ListVmReq{
		PageSize: -1,
	})
	if err != nil {
		err = fmt.Errorf("error query rpc ListVm: %v", err)
		return nil, err
	}
	vmList := vmListRsp.DataList
	IdToInstanceMap := make(map[string]instanceInfo)
	regionToInstancesMap := make(regionAzGroup)
	azToInstancesMap := make(regionAzGroup)
	for _, vm := range vmList {
		instance := instanceInfo{
			Id:     vm.Id,
			Name:   vm.Name,
			Region: vm.Region,
		}
		IdToInstanceMap[vm.Id] = instance
		if vm.Region != "" {
			r := regionAz{
				Region: vm.Region,
			}
			regionToInstancesMap[r] = append(regionToInstancesMap[r], instance)
		}
		if vm.Region != "" && vm.Az != "" {
			rz := regionAz{
				Region: vm.Region,
				Az:     vm.Az,
			}
			azToInstancesMap[rz] = append(azToInstancesMap[rz], instance)
		}
	}
	metrics := vm.VmTopMetrics
	return &jobParam{
		interval:             par.Interval,
		metrics:              metrics,
		allIdToInstanceMap:   IdToInstanceMap,
		regionToInstancesMap: regionToInstancesMap,
		azToInstancesMap:     azToInstancesMap,
	}, nil
}

```

File path: /Users/mac/Desktop/woker_code/monitor/router/router.go
```golang
package router

import (
	"ezone.ksyun.com/ezone/luban/monitor/docs"
	basicCtl "ezone.ksyun.com/ezone/luban/monitor/modules/basic/controller"
	blockStorageCtl "ezone.ksyun.com/ezone/luban/monitor/modules/blockstorage/controller"
	computeCtl "ezone.ksyun.com/ezone/luban/monitor/modules/compute/controller"
	databaseCtl "ezone.ksyun.com/ezone/luban/monitor/modules/database/controller"
	jobsCtl "ezone.ksyun.com/ezone/luban/monitor/modules/jobs/controller"
	networkCtl "ezone.ksyun.com/ezone/luban/monitor/modules/network/controller"
	objectStorageCtl "ezone.ksyun.com/ezone/luban/monitor/modules/object_storage/controller"
	serverCtl "ezone.ksyun.com/ezone/luban/monitor/modules/server/controller"
	switchsCtl "ezone.ksyun.com/ezone/luban/monitor/modules/switch/controller"
	"github.com/gin-gonic/gin"
	swaggerFiles "github.com/swaggo/files"
	ginSwagger "github.com/swaggo/gin-swagger"
)

/******************************************** 路由定义 *****************************************************************
* 1. 路由定义在此文件中，每个模块的路由定义在对应的分组中，如：服务器相关的路由定义在 machine 分组中
* 2. 路由定义的格式为：分组名.请求方法(请求路径, 控制器方法)
* 3. 路由定义的请求方法为：Any
* 4. 路由定义的请求路径为：/open_api/分组名/请求路径 ，如：/open_api/machine/details，其中请求路径如果需要区分请使用下划线分割
* 5. 路由定义的控制器方法为：(&controller.控制器名{}).控制器方法名 ，如：dataCtl.NewUserController().List
***********************************************************************************************************************/

func InitRouter(engine *gin.Engine) {

	// 定义路由规则
	api := engine.Group("/monitor/v2")

	// 定时任务
	var job = api.Group("/jobs")
	{
		//resource_type : eip,nat,lb,vm,mysql,redis....
		//interval : 0.5h,1h,3h,1d,7d,30d
		//eg: localhost:8083/monitor/v2/jobs/top/eip/1h
		job.GET("/top/:resource_type/:interval", jobsCtl.NewJobsController().TopJob) // 获取指定资源类型和时间间隔的top任务数据   todo Action  获取TopJob数据Monitor
	}

	// 监控大屏
	var dashboard = api.Group("/dashboard")
	{
		dashboard.POST("/create", basicCtl.NewDashboardController().Create)                     // 创建新的监控大屏   todo Action  CreateDashboardMonitor
		dashboard.POST("/update", basicCtl.NewDashboardController().Update)                     // 更新监控大屏配置   todo Action  UpdateDashboardMonitor
		dashboard.POST("/delete", basicCtl.NewDashboardController().Delete)                     // 删除监控大屏   todo Action  DeleteDashboardMonitor
		dashboard.POST("/list", basicCtl.NewDashboardController().List)                         // 获取监控大屏列表   todo Action  ListDashboardMonitor
		dashboard.POST("/detail", basicCtl.NewDashboardController().Detail)                     // 获取监控大屏详细信息   todo Action  DetailDashboardMonitor
		dashboard.POST("/physical_device", basicCtl.NewDashboardController().PhysicalDevice)    // 获取监控大屏的物理设备信息   todo Action  PhysicalDeviceDashboardMonitor
		dashboard.POST("/compute_pool_line", basicCtl.NewDashboardController().ComputePoolLine) // 获取监控大屏计算资源池的线图   todo Action  ComputePoolLineDashboardMonitor
		dashboard.POST("/ebs_pool_line", basicCtl.NewDashboardController().EbsPoolLine)         // 获取监控大屏EBS资源池的线图   todo Action  EbsPoolLineDashboardMonitor
		dashboard.POST("/object_pool_line", basicCtl.NewDashboardController().ObjectPoolLine)   // 获取监控大屏对象存储资源池的线图   todo Action  ObjectPoolLineDashboardMonitor
	}

	// 网络相关
	var network = api.Group("/network")
	{
		//网络资源池
		network.POST("/network_pool/overview_alert", networkCtl.NewNetworkPoolController().OverviewAlert)     // 网络资源池告警概览   todo Action  NetworkPoolOverviewAlertMonitor
		network.POST("/network_pool/overview_monitor", networkCtl.NewNetworkPoolController().OverviewMonitor) // 网络资源池监控概览   todo Action  NetworkPoolOverviewMonitorMonitor
		network.POST("/network_pool/overview_line", networkCtl.NewNetworkPoolController().OverviewLine)       // 网络资源池概览线图   todo Action  NetworkPoolOverviewLineMonitor

		network.POST("/network_pool/lb/list", networkCtl.NewNetworkPoolController().ListLBPool)   // 网络资源池负载均衡列表   todo Action  LBPoolListMonitor
		network.POST("/network_pool/lb/detail", nil)                                              // 网络资源池-负载均衡监控详情   todo Action
		network.POST("/network_pool/eip/list", networkCtl.NewNetworkPoolController().ListEIPPool) // 网络资源池弹性IP列表   todo Action  EIPPoolListMonitor
		network.POST("/network_pool/eip/detail", nil)                                             // 网络资源池-弹性IP监控详情   todo Action
		network.POST("/network_pool/nat/list", networkCtl.NewNetworkPoolController().ListNatPool) // 网络资源池NAT列表   todo Action  NatPoolListMonitor
		network.POST("/network_pool/nat/detail", nil)                                             // 网络资源池-NAT监控详情   todo Action
		network.POST("/network_pool/bm/list", networkCtl.NewNetworkPoolController().ListBMPool)   // 网络资源池裸金属列表   todo Action  BMPoolListMonitor
		network.POST("/network_pool/bm/detail", nil)                                              // 网络资源池-裸金属监控详情   todo Action
		network.POST("/network_pool/sl/list", networkCtl.NewNetworkPoolController().ListSLPool)   // 网络资源池专线列表   todo Action  SLPoolListMonitor
		network.POST("/network_pool/sl/detail", nil)                                              // 网络资源池-专线监控详情   todo Action

		network.POST("/network_pool/detail_line", networkCtl.NewNetworkPoolController().DetailLine) // 网络资源池监控详情线图   todo Action  NetworkPoolDetailLineMonitor
		network.POST("/network_pool/detail_top", networkCtl.NewNetworkPoolController().DetailTop)   // 网络资源池监控详情Top图   todo Action  NetworkPoolDetailTopMonitor

		//云产品-EIP
		network.POST("/product/eip/overview_alert", networkCtl.NewProductEipController().OverviewAlert) // 云产品EIP告警概览   todo Action  ProductEipOverviewAlertMonitor
		network.POST("/product/eip/overview_top", networkCtl.NewProductEipController().OverviewTop)     // 云产品EIP概览Top信息   todo Action  ProductEipOverviewTopMonitor

		network.POST("/product/eip_detail", networkCtl.NewProductEipController().EipInfo) // 云产品EIP详细信息   todo Action  ProductEipDetailMonitor
		network.POST("/product/eip/line", networkCtl.NewProductEipController().EipLine)   // 云产品EIP监控线图   todo Action  ProductEipLineMonitor

		//云产品-LB
		network.POST("/product/lb/list", networkCtl.NewProductLbController().List)         // 云产品负载均衡列表   todo Action  ProductLbListMonitor
		network.POST("/product/lb/overview", networkCtl.NewProductLbController().Overview) // 云产品负载均衡概览   todo Action  ProductLbOverviewMonitor
		network.POST("/product/lb/overview_top", networkCtl.NewProductLbController().Top)  // 云产品负载均衡概览Top信息   todo Action  ProductLbOverviewTopMonitor
		network.POST("/product/lb/line", networkCtl.NewProductLbController().Line)         // 云产品负载均衡监控线图   todo Action  ProductLbLineMonitor

		//云产品-nat
		network.POST("/product/nat/overview", networkCtl.NewProductNatController().Overview) // 云产品NAT概览   todo Action  ProductNatOverviewMonitor
		network.POST("/product/nat/overview_top", networkCtl.NewProductNatController().Top)  // 云产品NAT概览Top信息   todo Action  ProductNatOverviewTopMonitor
		network.POST("/product/nat/line", networkCtl.NewProductNatController().Line)         // 云产品NAT监控线图   todo Action  ProductNatLineMonitor
	}

	// 服务器相关
	var server = api.Group("/server")
	{
		server.POST("/physical/overview_alert", serverCtl.NewServerController().PhysicalOverviewAlert)     // 服务器概览的告警信息   todo Action  ServerPhysicalOverviewAlertMonitor
		server.POST("/physical/overview_monitor", serverCtl.NewServerController().PhysicalOverviewMonitor) // 服务器概览的监控状态   todo Action  ServerPhysicalOverviewMonitorMonitor
		server.POST("/physical/overview_top", serverCtl.NewServerController().PhysicalOverviewTop)         // 服务器概览的Top信息   todo Action  ServerPhysicalOverviewTopMonitor
		server.POST("/physical/list", serverCtl.NewServerController().PhysicalList)                        // 服务器列表   todo Action  ServerPhysicalListMonitor
		server.POST("/physical/details_overview", serverCtl.NewServerController().PhysicalDetailsOverview) // 服务器详情概览   todo Action  ServerPhysicalDetailsOverviewMonitor
		server.POST("/physical/details_line", serverCtl.NewServerController().PhysicalDetailsLine)         // 服务器详情的线图   todo Action  ServerPhysicalDetailsLineMonitor
		server.GET("/physical/work_list", serverCtl.NewServerController().PhysicalWorkList)                // 服务器网卡列表   todo Action  ServerPhysicalWorkListMonitor
		server.POST("/physical/hardware", serverCtl.NewServerController().PhysicalHardware)                // 服务器硬件信息   todo Action  ServerPhysicalHardwareMonitor
		server.POST("/physical/monitoring_status", serverCtl.NewServerController().MonitoringStatus)       // 服务器交换机的监控状态   todo Action  ServerPhysicalMonitoringStatusMonitor
	}

	// 交换机相关
	var switchboard = api.Group("/switch")
	{
		switchboard.POST("/switch/overview_alert", switchsCtl.NewSwitchController().SwitchOverviewAlert)     // 交换机概览告警信息   todo Action  SwitchOverviewAlertMonitor
		switchboard.POST("/switch/overview_monitor", switchsCtl.NewSwitchController().SwitchOverviewMonitor) // 交换机概览监控状态   todo Action  SwitchOverviewMonitorMonitor
		switchboard.POST("/switch/overview_top", switchsCtl.NewSwitchController().SwitchOverviewTop)         // 交换机概览Top信息   todo Action  SwitchOverviewTopMonitor
		switchboard.POST("/switch/list", switchsCtl.NewSwitchController().SwitchList)                        // 交换机列表   todo Action  SwitchListMonitor
		switchboard.GET("/switch/details_overview", switchsCtl.NewSwitchController().SwitchDetailsOverview)  // 交换机详情概览   todo Action  SwitchDetailsOverviewMonitor
		switchboard.POST("/switch/details_line", switchsCtl.NewSwitchController().SwitchDetailsLine)         // 交换机详情线图   todo Action  SwitchDetailsLineMonitor
		switchboard.POST("/switch/hardware", switchsCtl.NewSwitchController().SwitchHardware)                // 交换机硬件信息   todo Action  SwitchHardwareMonitor
		switchboard.POST("/switch/interface_line", switchsCtl.NewSwitchController().SwitchInterfaceLine)     // 交换机接口线图   todo Action  SwitchInterfaceLineMonitor
		switchboard.POST("/switch/interface_list", switchsCtl.NewSwitchController().SwitchInterfaceList)     // 交换机接口列表   todo Action  SwitchInterfaceListMonitor
	}

	//database相关
	var database = api.Group("/db")
	{
		database.POST("/db_pool/overview_alert", databaseCtl.NewDbkPoolController().DbPoolOverviewAlert)     // 数据库资源池告警概览   todo Action  DbPoolOverviewAlertMonitor
		database.POST("/db_pool/overview_monitor", databaseCtl.NewDbkPoolController().DbPoolOverviewMonitor) // 数据库资源池监控概览   todo Action  DbPoolOverviewMonitorMonitor
		database.POST("/db_pool/overview_line", databaseCtl.NewDbkPoolController().DbPoolOverviewLine)       // 数据库资源池概览线图   todo Action  DbPoolOverviewLineMonitor
		database.POST("/db_pool/list", databaseCtl.NewDbkPoolController().DbPoolList)                        // 数据库资源池列表   todo Action  DbPoolListMonitor
		database.POST("/db_pool/details_line", databaseCtl.NewDbkPoolController().DbPoolDetailsLine)         // 数据库资源池详情线图   todo Action  DbPoolDetailsLineMonitor

		database.POST("/product/list", databaseCtl.NewDatabaseController().List)                           // 数据库产品列表   todo Action  DatabaseListMonitor
		database.POST("/product/overview_top", databaseCtl.NewDatabaseController().Top)                    // 数据库产品概览Top信息   todo Action  DatabaseOverviewTopMonitor
		database.POST("/product/redis_sub_list", databaseCtl.NewDatabaseController().RedisSubInstanceList) // 数据库产品Redis子实例列表   todo Action  DatabaseRedisSubListMonitor
		database.POST("/product/line", databaseCtl.NewDatabaseController().Line)                           // 数据库产品监控线图   todo Action  DatabaseLineMonitor
		database.POST("/product/redis/log", databaseCtl.NewDatabaseController().RedisLog)                  // 数据库产品Redis日志信息   todo Action  DatabaseRedisLogMonitor
		database.POST("/product/mysql/log", databaseCtl.NewDatabaseController().MysqlLog)                  // 数据库产品MySQL日志信息   todo Action  DatabaseMysqlLogMonitor
	}

	// 计算相关
	var compute = api.Group("/compute")
	{
		// 计算资源池
		compute.POST("/compute_pool/overview_alert", computeCtl.NewComputePoolController().OverviewAlert)     // 计算资源池告警概览   todo Action  ComputePoolOverviewAlertMonitor
		compute.POST("/compute_pool/overview_monitor", computeCtl.NewComputePoolController().OverviewMonitor) // 计算资源池监控概览   todo Action  ComputePoolOverviewMonitorMonitor
		compute.POST("/compute_pool/overview_line", computeCtl.NewComputePoolController().OverviewLine)       // 计算资源池概览线图   todo Action  ComputePoolOverviewLineMonitor
		compute.POST("/compute_pool/list", computeCtl.NewComputePoolController().List)                        // 计算资源池列表   todo Action  ComputePoolListMonitor
		compute.POST("/compute_pool/detail_line", computeCtl.NewComputePoolController().DetailLine)           // 计算资源池详情线图   todo Action  ComputePoolDetailLineMonitor

		// vm 云主机
		compute.POST("/product/vm/overview_monitor", computeCtl.NewVmController().OverviewMonitor)      // 云主机概览监控   todo Action  VmOverviewMonitor
		compute.POST("/product/vm/overview_top", computeCtl.NewVmController().OverviewTop)              // 云主机概览Top信息   todo Action  VmOverviewTopMonitor
		compute.POST("/product/vm/detail_metrics", computeCtl.NewVmController().DetailMetrics)          // 云主机详情监控指标   todo Action  VmDetailMetricsMonitor
		compute.POST("/product/vm/detail_metric_lines", computeCtl.NewVmController().DetailMetricLines) // 云主机详情监控线图   todo Action  VmDetailMetricLinesMonitor
	}
	// 块存储相关
	var blockStorage = api.Group("/block_storage")
	{
		blockStorage.POST("ebs_pool/overview_alert", blockStorageCtl.NewEbsPoolController().OverviewAlert)                 // EBS资源池告警概览   todo Action  EbsPoolOverviewAlertMonitor
		blockStorage.POST("ebs_pool/overview", blockStorageCtl.NewEbsPoolController().Overview)                            // EBS资源池概览   todo Action  EbsPoolOverviewMonitor
		blockStorage.POST("ebs_pool/overview_line", blockStorageCtl.NewEbsPoolController().OverviewLine)                   // EBS资源池概览线图   todo Action  EbsPoolOverviewLineMonitor
		blockStorage.POST("ebs_pool/list", blockStorageCtl.NewEbsPoolController().List)                                    // EBS资源池列表   todo Action  EbsPoolListMonitor
		blockStorage.POST("ebs_pool/detail_metric_overview", blockStorageCtl.NewEbsPoolController().DetailMetricOverview)  // EBS资源池详情指标概览   todo Action  EbsPoolDetailMetricOverviewMonitor
		blockStorage.POST("ebs_pool/detail_metric_lines", blockStorageCtl.NewEbsPoolController().DetailMetricLines)        // EBS资源池详情指标线图   todo Action  EbsPoolDetailMetricLinesMonitor
		blockStorage.GET("ebs_pool/list_optional_condition", blockStorageCtl.NewEbsPoolController().ListOptionalCondition) // EBS资源池列表可选条件   todo Action  EbsPoolListOptionalConditionMonitor

		// ebs_volume
		blockStorage.POST("ebs_volume/overview_top", blockStorageCtl.NewEbsVolumeController().OverviewTop)              // EBS卷概览Top信息   todo Action  EbsVolumeOverviewTopMonitor
		blockStorage.POST("ebs_volume/overview", blockStorageCtl.NewEbsVolumeController().Overview)                     // EBS卷概览   todo Action  EbsVolumeOverviewMonitor
		blockStorage.POST("ebs_volume/detail_metric", blockStorageCtl.NewEbsVolumeController().DetailMetric)            // EBS卷详情指标   todo Action  EbsVolumeDetailMetricMonitor
		blockStorage.POST("ebs_volume/detail_metric_lines", blockStorageCtl.NewEbsVolumeController().DetailMetricLines) // EBS卷详情指标线图   todo Action  EbsVolumeDetailMetricLinesMonitor
	}

	// 对象存储
	var objectStorage = api.Group("/object_storage")
	{
		// 资源池
		objectStorage.POST("object_pool/overview_alert", objectStorageCtl.NewObjectPoolController().OverviewAlert)                 // 对象存储资源池概览告警  todo Action  OverviewPoolAlertMonitor
		objectStorage.POST("object_pool/overview_monitor", objectStorageCtl.NewObjectPoolController().OverviewMonitor)             // 对象存储资源池概览基础信息 todo Action OverviewPoolMonitor
		objectStorage.POST("object_pool/overview_line", objectStorageCtl.NewObjectPoolController().OverviewLine)                   // 对象存储资源池概览折线图 todo Action OverviewPoolLineMonitor
		objectStorage.POST("object_pool/list", objectStorageCtl.NewObjectPoolController().List)                                    // 对象存储资源池监控列表 todo Action ListPoolMonitor
		objectStorage.POST("object_pool/detail_metric_overview", objectStorageCtl.NewObjectPoolController().DetailMetricOverview)  // 对象存储资源池监控详情 todo Action DetailMetricOverviewPoolMonitor
		objectStorage.POST("object_pool/detail_metric_lines", objectStorageCtl.NewObjectPoolController().DetailMetricLines)        // 对象存储资源池监控折线图 todo Action DetailMetricLinesPoolMonitor
		objectStorage.GET("object_pool/list_optional_condition", objectStorageCtl.NewObjectPoolController().ListOptionalCondition) // 对象存储资源池列表可选条件 todo Action ListOptionalConditionPoolMonitor

		// 云产品
		objectStorage.POST("object_volume/overview_top", objectStorageCtl.NewObjectVolumeController().OverviewTop)              // 对象存储云产品概览TOP todo Action OverviewVolumeTopMonitor
		objectStorage.POST("object_volume/overview", objectStorageCtl.NewObjectVolumeController().Overview)                     // 对象存储云产品概览基础信息 todo Action OverviewVolumeMonitor
		objectStorage.POST("object_volume/detail_metric", objectStorageCtl.NewObjectVolumeController().DetailMetric)            // 对象存储云产品监控详情 todo Action DetailMetricVolumeMonitor
		objectStorage.POST("object_volume/detail_metric_lines", objectStorageCtl.NewObjectVolumeController().DetailMetricLines) // 对象存储云产品监控折线图 todo Action DetailMetricLinesVolumeMonitor
	}
	docs.SwaggerInfo.Version = "2.0"
	docs.SwaggerInfo.BasePath = "/monitor/v2"
	engine.GET("/swagger/*any", ginSwagger.WrapHandler(swaggerFiles.Handler))
}

```

